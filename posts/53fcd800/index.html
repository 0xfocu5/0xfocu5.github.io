<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>AFL细节小计 | Focu$ on yourself.</title><meta name="description" content="AFL 一些细节实现的学习和总结。"><meta name="keywords" content="AFL,Fuzz"><meta name="author" content="0xfocu5"><meta name="copyright" content="0xfocu5"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="https://focu5.oss-accelerate.aliyuncs.com/blog/20200927102719.jpg"><link rel="canonical" href="https://0xfocu5.github.io/posts/53fcd800/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="AFL细节小计"><meta property="og:url" content="https://0xfocu5.github.io/posts/53fcd800/"><meta property="og:site_name" content="Focu$ on yourself."><meta property="og:description" content="AFL 一些细节实现的学习和总结。"><meta property="og:image" content="https://focu5.oss-accelerate.aliyuncs.com/blog/20200927102719.jpg"><meta property="article:published_time" content="2021-04-11T16:00:00.000Z"><meta property="article:modified_time" content="2021-07-20T11:13:37.145Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Snackbar.bookmark.message_prev',
    message_next: 'Snackbar.bookmark.message_next'
  },
  runtime: 'days',
  date_suffix: {"one_hour":"date_suffix.one_hour","hours":"date_suffix.hours","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-07-20 19:13:37'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://focu5.oss-cn-beijing.aliyuncs.com/img/20200714224051.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">26</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">11</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tages</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%8E%87"><span class="toc-number">1.</span> <span class="toc-text">覆盖率</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%EF%BC%88Fuction-Level%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">函数（Fuction-Level）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9D%97%EF%BC%88BasicBlock-Level%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">基本块（BasicBlock-Level）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%EF%BC%88Edge-Level%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">边界（Edge-Level）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8F%92%E6%A1%A9"><span class="toc-number">2.</span> <span class="toc-text">代码插桩</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fork-server"><span class="toc-number">3.</span> <span class="toc-text">fork server</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#init-fork-server"><span class="toc-number">3.1.</span> <span class="toc-text">init fork server</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#afl-maybe-log"><span class="toc-number">3.2.</span> <span class="toc-text">__afl_maybe_log()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">4.</span> <span class="toc-text">共享内存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E8%AE%B0%E5%BD%95"><span class="toc-number">5.</span> <span class="toc-text">分支信息的记录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">分支信息的分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">7.</span> <span class="toc-text">参考</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://focu5.oss-accelerate.aliyuncs.com/blog/20200927102719.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Focu$ on yourself.</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tages</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">AFL细节小计</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-11T16:00:00.000Z" title="发表于 2021-04-12 00:00:00">2021-04-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-20T11:13:37.145Z" title="更新于 2021-07-20 19:13:37">2021-07-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Fuzz/">Fuzz</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Fuzz/Afl/">Afl</a></span></div><div class="meta-secondline"> </div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h1><p>代码覆盖率，是一种通过计算测试过程中被执行的源代码占全部源代码的比例，进而间接度量软件质量的方法。其计量方式很多，但无论是 GCC 的 GCOV 还是 LLVM 的 SanitizerCoverage，都提供函数（function）、基本块（basic-block）、边界（edge）三种级别的覆盖率检测。</p>
<h2 id="函数（Fuction-Level）"><a href="#函数（Fuction-Level）" class="headerlink" title="函数（Fuction-Level）"></a><strong>函数（Fuction-Level）</strong></h2><p>函数就是代码执行时调用到哪些函数，但是函数里面的具体代码行却不作统计，相对比较粗糙但高效的统计方式。所以，通常的统计方式是用基本块，简称BB。</p>
<h2 id="基本块（BasicBlock-Level）"><a href="#基本块（BasicBlock-Level）" class="headerlink" title="基本块（BasicBlock-Level）"></a><strong>基本块（BasicBlock-Level）</strong></h2><p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210413173114.png" alt="image-20210413173114591"></p>
<p>IDA中每一块代码就代表着一个基本块，就是以指令跳转为作划分界限的。</p>
<h2 id="边界（Edge-Level）"><a href="#边界（Edge-Level）" class="headerlink" title="边界（Edge-Level）"></a><strong>边界（Edge-Level）</strong></h2><p>edge本身就涵盖了基本块部分，唯一的差别是edge多记录了一些执行边界的信息。</p>
<p>我们可以将程序看成一个控制流图（CFG），图的每个节点表示一个基本块，而edge就被用来表示在基本块之间的转跳。知道了每个基本块和跳转的执行次数，就可以知道程序中的每个语句和分支的执行次数，从而获得比记录BB更细粒度的覆盖率信息。</p>
<p>具体到AFL的实现中，使用二元组(branch_src, branch_dst)来记录<strong>当前基本块</strong> + <strong>前一基本块</strong> 的信息，从而获取目标的执行流程和代码覆盖情况，下文会详细介绍。</p>
<h1 id="代码插桩"><a href="#代码插桩" class="headerlink" title="代码插桩"></a>代码插桩</h1><p><code>afl</code>插桩的代码写在<code>afl-gcc.c</code>里面，afl-gcc 是 gcc 的一个封装(wrapper)。主要实现的下述的三个功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find_as(argv[<span class="number">0</span>]);                         <span class="comment">//找到gcc/clang/llvm编译器</span></span><br><span class="line">edit_params(argc, argv);                  <span class="comment">//设置cc的参数</span></span><br><span class="line">execvp(cc_params[<span class="number">0</span>], (<span class="keyword">char</span>**)cc_params);  <span class="comment">//执行</span></span><br></pre></td></tr></table></figure>

<p>我们在 <code>execvp</code>之前，加入一段代码打印出<code>cc_params</code>的参数如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$:	./afl-gcc demo.c -o <span class="built_in">test</span>                                                                                                    </span><br><span class="line">afl-cc 2.52b by &lt;lcamtuf@google.com&gt;</span><br><span class="line">        arg0: gcc</span><br><span class="line">        arg1: demo.c</span><br><span class="line">        arg2: -o</span><br><span class="line">        arg3: <span class="built_in">test</span></span><br><span class="line">        arg4: -B</span><br><span class="line">        arg5: .</span><br><span class="line">        arg6: -g</span><br><span class="line">        arg7: -O3</span><br><span class="line">        arg8: -funroll-loops</span><br><span class="line">        arg9: -D__AFL_COMPILER=1</span><br><span class="line">        arg10: -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</span><br></pre></td></tr></table></figure>

<p>我们知道一个二进制文件完整的流程是：预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接。而将汇编代码编译成为二进制的工具，即为汇编器assembler。Linux系统下的常用汇编器是<code>as</code>。编译完成<code>AFL</code>后，在其目录下也会存在一个<code>as</code>文件，并作为符号链接指向<code>afl-as</code>。所以，如果通过<code>-B</code>选项为<code>gcc</code>设置了搜索路径(根据gcc –help可知)，那么<code>afl-as</code>便会作为汇编器，执行实际的汇编操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-funroll-loops     ：执行循环强度消除并消除在循环内部使用的变量。这是用简单而快速的操作（如加法和减法）替代耗时操作（如乘法和除法）的过程</span><br><span class="line">-B &lt; &gt;             ：设置编译器的搜索路径。</span><br><span class="line">ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION     &#x2F;* a flag also shared with libfuzzer) or *&#x2F;</span><br><span class="line">ifdef __AFL_COMPILER                             &#x2F;* (this one is just for AFL). *&#x2F;</span><br></pre></td></tr></table></figure>



<p>反汇编我们刚刚所编译出来的 test 文件可以发现其中多了一些汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400860</span><br><span class="line">.text:0000000000400860 argc &#x3D; rdi                              ; int</span><br><span class="line">.text:0000000000400860 argv &#x3D; rsi                              ; char **</span><br><span class="line">.text:0000000000400860 ; __unwind &#123;</span><br><span class="line">.text:0000000000400860                 lea     rsp, [rsp-98h]</span><br><span class="line">.text:0000000000400868                 mov     [rsp+98h+var_98], rdx</span><br><span class="line">.text:000000000040086C                 mov     [rsp+98h+var_90], rcx</span><br><span class="line">.text:0000000000400871                 mov     [rsp+98h+var_88], rax</span><br><span class="line">.text:0000000000400876                 mov     rcx, 459Eh</span><br><span class="line">.text:000000000040087D                 call    __afl_maybe_log</span><br><span class="line">.text:0000000000400882                 mov     rax, [rsp+98h+var_88]</span><br><span class="line">.text:0000000000400887                 mov     rcx, [rsp+98h+var_90]</span><br><span class="line">.text:000000000040088C                 mov     rdx, [rsp+98h+var_98]</span><br><span class="line">.text:0000000000400890                 lea     rsp, [rsp+98h]</span><br></pre></td></tr></table></figure>

<p>阅读<code>afl-as.c</code>发现插桩完成在 <code>add_instrumentation</code>函数内部</p>
<blockquote>
<p><code>fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE));</code></p>
</blockquote>
<p>这里 afl 通过调用 fprintf 将 trampoline_fmt_64 或者 trampoline_fmt_32 插入目标的代码段，以完成插桩来计算代码覆盖率。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-as.h</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8* trampoline_fmt_32 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leal -16(%%esp), %%esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%edi,  0(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%edx,  4(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%ecx,  8(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl %%eax, 12(%%esp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl $0x%08x, %%ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl 12(%%esp), %%eax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  8(%%esp), %%ecx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  4(%%esp), %%edx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movl  0(%%esp), %%edi\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leal 16(%%esp), %%esp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到插桩主要完成了（x64）：</p>
<ul>
<li>保存<code>rax</code> <code>rcx</code> <code>rdx</code> 等寄存器的值</li>
<li>将<code>ecx</code>的值设置为随机数</li>
<li>调用<code>__afl_maybe_log</code></li>
<li>恢复原寄存器的数据</li>
</ul>
<p>关于<code>&quot;movq $0x%08x, %%rcx\n&quot;</code>这条汇编代码其对应<code>fprintf</code>中的参数为<code>R(MAP_SIZE)</code>，根据定义，宏<code>MAP_SIZE</code>为64K；<code>R(x)</code>的定义是<code>(random() % (x))</code>，所以<code>R(MAP_SIZE)</code>即为0到MAP_SIZE之间的一个随机数。这里的R(x)实际上是用来区分每个代码块的，也就是是一个标识。</p>
<p>关于<code>__afl_maybe_log()</code>的详细实现会在下文提及。</p>
<h1 id="fork-server"><a href="#fork-server" class="headerlink" title="fork server"></a>fork server</h1><p>afl 的流程大致是：对输入的样本文件不断地变异，并将这些 mutated input 喂给 loader 执行，检查是否会造成崩溃。因此，fuzzing 涉及到大量的 fork 和执行 loader 的过程。但是对于简单的库，我们会花费大量时间去等待<code>execve()</code>，载入目标文件和库、解析符号地址等，为了避免这种情况，AFL实现了一套 fork server 机制。其基本思路是：启动target进程后，target会运行一个fork server；fuzzer并不负责fork子进程，而是与这个fork server通信，并由fork server来完成fork及继续执行目标的操作。</p>
<h2 id="init-fork-server"><a href="#init-fork-server" class="headerlink" title="init fork server"></a>init fork server</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">init_forkserver</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">  <span class="keyword">int</span> st_pipe[<span class="number">2</span>], ctl_pipe[<span class="number">2</span>]; <span class="comment">//建立管道st_pipe和ctl_pipe，在父子进程之间，是通过管道进行通信，一个用于传递状态，另一个用于传递命令。</span></span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">  forksrv_pid = fork();        <span class="comment">//fork 出来一个子进程，父子进程之间通过管道进行通信。</span></span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">if</span> (!forksrv_pid) &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">/* Set up control and status pipes, close the unneeded original fds. */</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(ctl_pipe[<span class="number">0</span>], FORKSRV_FD) &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);    <span class="comment">//对于子进程（fork server），会进行一系列设置，其中包括将上述两个管道分配到预先指定的fd，并最终执行target：</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(st_pipe[<span class="number">1</span>], FORKSRV_FD + <span class="number">1</span>) &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;dup2() failed&quot;</span>);</span><br><span class="line">	...</span><br><span class="line">    execv(target_path, argv);</span><br><span class="line">    <span class="comment">/* Use a distinctive bitmap signature to tell the parent about execv() falling through. */</span></span><br><span class="line">    *(u32*)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//对于父进程（fuzzer），则会读取状态管道的信息，如果一切正常，则说明fork server创建完成。</span></span><br><span class="line">  close(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line">  close(st_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>];</span><br><span class="line">  fsrv_st_fd  = st_pipe[<span class="number">0</span>];</span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">  rlen = read(fsrv_st_fd, &amp;status, <span class="number">4</span>);  <span class="comment">//从管道中读取4个字节</span></span><br><span class="line">  ...</span><br><span class="line">     <span class="comment">/* If we have a four-byte &quot;hello&quot; message from the server, we&#x27;re all set.</span></span><br><span class="line"><span class="comment">     Otherwise, try to figure out what went wrong. */</span></span><br><span class="line">  <span class="keyword">if</span> (rlen == <span class="number">4</span>) &#123;</span><br><span class="line">    OKF(<span class="string">&quot;All right - fork server is up.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  FATAL(<span class="string">&quot;Fork server handshake failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>execv(target_path, argv)</code>带参数执行target，这个函数除非出错不然不会返回。</p>
<ul>
<li>execv会替换掉原有的进程空间为target_path代表的程序，所以相当于后续就是去执行target_path，这个程序结束的话，子进程就结束。</li>
<li><strong>此时由于我们的目标程序的 main 函数已经被插桩，程序的控制流会交到<code>_afl_maybe_log</code>手中。所以关于 fork server 的其余工作都在<code>_afl_maybe_log</code>中完成。而在这里非常特殊，第一个target会进入<code>__afl_maybe_log</code>里的<code>__afl_fork_wait_loop</code>，并充当fork server，在整个Fuzz的过程中，它都不会结束，每次要Fuzz一次target，都会从这个fork server fork出来一个子进程去fuzz。</strong></li>
</ul>
<h2 id="afl-maybe-log"><a href="#afl-maybe-log" class="headerlink" title="__afl_maybe_log()"></a>__afl_maybe_log()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> __usercall _afl_maybe_log@&lt;al&gt;(<span class="keyword">char</span> a1@&lt;of&gt;, __int64 a2@&lt;rcx&gt;, __int64 a3@&lt;xmm0&gt;, __int64 a4@&lt;xmm1&gt;, __int64 a5@&lt;xmm2&gt;, __int64 a6@&lt;xmm3&gt;, __int64 a7@&lt;xmm4&gt;, __int64 a8@&lt;xmm5&gt;, __int64 a9@&lt;xmm6&gt;, __int64 a10@&lt;xmm7&gt;, __int64 a11@&lt;xmm8&gt;, __int64 a12@&lt;xmm9&gt;, __int64 a13@&lt;xmm10&gt;, __int64 a14@&lt;xmm11&gt;, __int64 a15@&lt;xmm12&gt;, __int64 a16@&lt;xmm13&gt;, __int64 a17@&lt;xmm14&gt;, __int64 a18@&lt;xmm15&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  v19 = _afl_area_ptr;</span><br><span class="line">  <span class="keyword">if</span> ( !_afl_area_ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( _afl_setup_failure )</span><br><span class="line">      <span class="keyword">return</span> v18 + <span class="number">127</span>;</span><br><span class="line">    v19 = _afl_global_area_ptr;</span><br><span class="line">    <span class="keyword">if</span> ( _afl_global_area_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      _afl_area_ptr = _afl_global_area_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">      v22 = getenv(<span class="string">&quot;__AFL_SHM_ID&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v22 || (v23 = atoi(v22), v24 = shmat(v23, <span class="number">0L</span>L, <span class="number">0</span>), v24 == (<span class="keyword">void</span> *)<span class="number">-1L</span>L) )</span><br><span class="line">      &#123;</span><br><span class="line">        ++_afl_setup_failure;</span><br><span class="line">        v18 = v29;</span><br><span class="line">        <span class="keyword">return</span> v18 + <span class="number">127</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      _afl_area_ptr = (__int64)v24;</span><br><span class="line">      _afl_global_area_ptr = v24;</span><br><span class="line">      v28 = (__int64)v24;</span><br><span class="line">      <span class="keyword">if</span> ( write(<span class="number">199</span>, &amp;_afl_temp, <span class="number">4u</span>LL) == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v25 = <span class="number">198</span>;</span><br><span class="line">          <span class="keyword">if</span> ( read(<span class="number">198</span>, &amp;_afl_temp, <span class="number">4u</span>LL) != <span class="number">4</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          LODWORD(v26) = fork();</span><br><span class="line">          <span class="keyword">if</span> ( v26 &lt; <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">if</span> ( !v26 )</span><br><span class="line">            <span class="keyword">goto</span> __afl_fork_resume;</span><br><span class="line">          _afl_fork_pid = v26;</span><br><span class="line">          write(<span class="number">199</span>, &amp;_afl_fork_pid, <span class="number">4u</span>LL);</span><br><span class="line">          v25 = _afl_fork_pid;</span><br><span class="line">          LODWORD(v27) = waitpid(_afl_fork_pid, &amp;_afl_temp, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v27 &lt;= <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          write(<span class="number">199</span>, &amp;_afl_temp, <span class="number">4u</span>LL);</span><br><span class="line">        &#125;</span><br><span class="line">        _exit(v25);</span><br><span class="line">      &#125;</span><br><span class="line">__afl_fork_resume:</span><br><span class="line">      close(<span class="number">198</span>);</span><br><span class="line">      close(<span class="number">199</span>);</span><br><span class="line">      v19 = v28;</span><br><span class="line">      v18 = v29;</span><br><span class="line">      a2 = v30;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v20 = _afl_prev_loc ^ a2;</span><br><span class="line">  _afl_prev_loc ^= v20;</span><br><span class="line">  _afl_prev_loc = (<span class="keyword">unsigned</span> __int64)_afl_prev_loc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  ++*(_BYTE *)(v19 + v20);</span><br><span class="line">  <span class="keyword">return</span> v18 + <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过阅读伪代码或者汇编，可以总结其工作流程如下：</p>
<ol>
<li><p>先判断是否设置了共享内存，如果没设置则判断<code>_afl_setup_failure</code>是否为真，如果为真，则代表setup失败，直接返回。也就是说只有第一次执行<code>__afl_maybe_log()</code>的时候，才会进入该 if 语句。</p>
<ul>
<li>如果初始化失败则直接返回</li>
<li>初始化成功后，读取<code>_afl_global_area_ptr</code>的值，不为 0 ，则赋值给 <code>_afl_area_ptr</code></li>
<li><code>_afl_global_area_ptr</code>为 0， 则把共享内存连接到当前进程的地址空间，将得到的地址，保存到<code>_afl_area_ptr</code>和<code>_afl_global_area_ptr</code>中。</li>
<li><code>write(199, &amp;_afl_temp, 4uLL) == 4</code>写4个字节到状态管道<code>st_pipe[0]</code>，forkserver 告诉 fuzzer 自己准备好了，而这正好是<code>rlen = read(fsrv_st_fd, &amp;status, 4);</code>中等待的信息。<ul>
<li><code>read(198, &amp;_afl_temp, 4uLL) != 4</code>forkserver 再从管道中读取 4 个字节，这时候表示 fuzzer 也准备好了。这时候 fork 出一个新的子进程，用来跑 target，而原本的父进程则用来通信。</li>
<li><code>write(199, &amp;_afl_fork_pid, 4uLL);</code>将子进程的 pid 写进管道，以为<code>fuzzer</code>的监控。</li>
<li>然后父进程即fork server等待子进程结束，并保存其执行结果到<code>_afl_temp</code>中，然后将子进程的执行结果，从<code>_afl_temp</code>写入到状态管道，告知fuzz。</li>
<li>父进程不断执行<code>__afl_fork_wait_loop</code>循环，不断从控制管道读取，直到fuzz端命令fork server进行新一轮测试。</li>
</ul>
</li>
</ul>
</li>
<li><p>如果共享内存已经被设置，则直接进入<code>__afl_store</code>逻辑，看伪代码可以知道：就是将上一个桩点的值(prev_location)和当前桩点的值(<code>R(MAP_SIZE)</code>)异或，取值后，使得<strong>共享内存里对应的槽</strong>的值加一，然后将prev_location设置为<code>cur_location &gt;&gt; 1;</code>。其余内容我们在下文分析。</p>
</li>
</ol>
<p>在fork server执行完毕后，当我们运行<code>target</code>的时候，fuzzer会调用<code>run_target()</code>，在此方法中，便是通过命令管道，通知fork server准备fork；并通过状态管道，获取子进程pid：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line">s32 res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In non-dumb mode, we have the fork server up and running, so simply tell it to have at it, and then read back PID. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((res = write(fsrv_ctl_fd, &amp;prev_timed_out, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;child_pid, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((res = read(fsrv_st_fd, &amp;status, <span class="number">4</span>)) != <span class="number">4</span>) &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">/*fuzzer再次读取状态管道，获取子进程退出状态，并由此来判断子进程结束的原因，例如正常退出、超时、崩溃等，并进行相应的记录。. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (WIFSIGNALED(status) &amp;&amp; !stop_soon) &#123;</span><br><span class="line"></span><br><span class="line">    kill_signal = WTERMSIG(status);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_timed_out &amp;&amp; kill_signal == SIGKILL) <span class="keyword">return</span> FAULT_TMOUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FAULT_CRASH;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>简介来说整个 server 流程如下图：</p>
<p><img src= "https://i.loli.net/2020/07/14/shCfncNLw9axrt8.gif" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20210413092653.png" alt="image-20210413092646310"></p>
<blockquote>
<p>afl 在初始化 forkserver 的时候会创建两个管道，fork 后通过 execve 去执行 target，因为目标程序的 main 函数已经被插桩，程序的控制流会交到_afl_maybe_log手中。如果 fuzz 实例是第一次运行，则此子进程则会充当 fuzz server，之后的程序都是由该 server fork出来的子进程。fuzz进行的时候，fuzz server会一直fork子进程，并且将子进程的结束状态通过pipe传递给afl-fuzz。</p>
</blockquote>
<h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>我们知道AFL 是以无限 fork 的形式进行 fuzzing 的，那么可以了解到 fuzzer 和 target 直接信息是要共享的，比如：执行过程中的分支信息；随后，fuzzer便可以根据这些信息，判断这次执行的整体流程和代码覆盖情况。</p>
<p>AFL使用共享内存，来完成以上信息在fuzzer和target之间的传递。具体地，fuzzer在启动时，会执行<code>setup_shm()</code>方法进行配置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line"><span class="function">EXP_ST <span class="keyword">void</span> <span class="title">setup_shm</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  u8* shm_str;</span><br><span class="line">  <span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">  <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">  shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;shmget() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  atexit(remove_shm);</span><br><span class="line"></span><br><span class="line">  shm_str = alloc_printf(<span class="string">&quot;%d&quot;</span>, shm_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,</span></span><br><span class="line"><span class="comment">     we don&#x27;t want them to detect instrumentation, since we won&#x27;t be sending</span></span><br><span class="line"><span class="comment">     fork server commands. This should be replaced with better auto-detection</span></span><br><span class="line"><span class="comment">     later on, perhaps? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  ck_free(shm_str);</span><br><span class="line"></span><br><span class="line">  trace_bits = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!trace_bits) PFATAL(<span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>shmget()：用来创建共享内存</p>
<p>shmat() ：第一次创建完共享内存时，它还不能被任何进程访问，shmat()函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间</p>
</blockquote>
<ul>
<li><p>首先调用<code>shemget()</code>分配一块共享内存，大小<code>MAP_SIZE</code>为64K</p>
</li>
<li><p>分配成功后，该共享内存的标志符会通过<code>setenv</code>设置到环境变量中，从而之后<code>fork()</code>得到的子进程可以通过该环境变量，得到这块共享内存的标志符</p>
</li>
<li><p>fuzzer 则会通过 <code>trace_bits</code> 来保存共享内存的地址</p>
</li>
<li><p>每次 fuzzer 去运行 target 的时候都会初始化共享内存</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> u8 <span class="title">run_target</span><span class="params">(<span class="keyword">char</span>** argv, u32 timeout)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">memset</span>(trace_bits, <span class="number">0</span>, MAP_SIZE);</span><br><span class="line">  MEM_BARRIER();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>而在 forkserver 内部</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char __usercall _afl_maybe_log@&lt;al&gt;(char a1@&lt;of&gt;, __int64 a2@&lt;rcx&gt;, __int64 a3@&lt;xmm0&gt;, __int64 a4@&lt;xmm1&gt;, __int64 a5@&lt;xmm2&gt;, __int64 a6@&lt;xmm3&gt;, __int64 a7@&lt;xmm4&gt;, __int64 a8@&lt;xmm5&gt;, __int64 a9@&lt;xmm6&gt;, __int64 a10@&lt;xmm7&gt;, __int64 a11@&lt;xmm8&gt;, __int64 a12@&lt;xmm9&gt;, __int64 a13@&lt;xmm10&gt;, __int64 a14@&lt;xmm11&gt;, __int64 a15@&lt;xmm12&gt;, __int64 a16@&lt;xmm13&gt;, __int64 a17@&lt;xmm14&gt;, __int64 a18@&lt;xmm15&gt;)</span><br><span class="line">&#123;</span><br><span class="line">      ...</span><br><span class="line">      v22 &#x3D; getenv(&quot;__AFL_SHM_ID&quot;);</span><br><span class="line">      if ( !v22 || (v23 &#x3D; atoi(v22), v24 &#x3D; shmat(v23, 0LL, 0), v24 &#x3D;&#x3D; (void *)-1LL) )</span><br><span class="line">      &#123;</span><br><span class="line">        ++_afl_setup_failure;</span><br><span class="line">        v18 &#x3D; v29;</span><br><span class="line">        return v18 + 127;</span><br><span class="line">      &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  则会先判断共享内存是否被设置，然后通过调用<code>shmat()</code>，target将这块共享内存也映射到了自己的内存空间中，并将其地址保存在<code>__afl_area_ptr</code>及<code>edx</code>中。由此，便完成了fuzzer与target之间共享内存的设置。</p>
</li>
</ul>
<h1 id="分支信息的记录"><a href="#分支信息的记录" class="headerlink" title="分支信息的记录"></a>分支信息的记录</h1><p>由官网文档可知，AFL 是根据二元 tuple (跳转的源地址和目标地址)来记录分支信息，从而获取 target 的执行流程和代码覆盖情况，其伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000400</span>CB0 __afl_store:                            ; CODE XREF: __afl_maybe_log+<span class="number">4F</span>↓j</span><br><span class="line">.text:<span class="number">0000000000400</span>CB0                                         ; __afl_maybe_log+<span class="number">309</span>↓j</span><br><span class="line">.text:<span class="number">0000000000400</span>CB0                 <span class="keyword">xor</span>     rcx, cs:__afl_prev_loc</span><br><span class="line">.text:<span class="number">0000000000400</span>CB7                 <span class="keyword">xor</span>     cs:__afl_prev_loc, rcx</span><br><span class="line">.text:<span class="number">0000000000400</span>CBE                 shr     cs:__afl_prev_loc, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000400</span>CC5                 inc     byte ptr [rdx+rcx]</span><br><span class="line">    </span><br><span class="line">v20 = _afl_prev_loc ^ a2;</span><br><span class="line">_afl_prev_loc ^= v20;</span><br><span class="line"> _afl_prev_loc = (<span class="keyword">unsigned</span> __int64)_afl_prev_loc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">++*(_BYTE *)(v19 + v20);</span><br></pre></td></tr></table></figure>

<p>其中 a2 保存的寄存器 rcx 的值，跟踪可以发现，rcx 存贮的是随机数，那么简单来说上述流程就是：就是将上一个桩点的值(prev_location)和当前桩点的值(<code>R(MAP_SIZE)</code>)异或，取值后，使得<strong>共享内存里对应的槽</strong>的值加一，然后将<code>cur_location</code> 的值右移一位然后得到新的<code>prev_location</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class="line">shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>因为，AFL在为每个代码块插桩的时候都会生成一个随机数，作为其”位置”的记录，然后对分支处的”源位置”和”目标位置”进行异或，讲其结果作为该分支的 key，并保存每个分支的执行次数。</p>
<p>用于保存执行次数的实际上是一个哈希表，大小为<code>MAP_SIZE=64K</code>，当然会存在碰撞的问题；但根据AFL文档中的介绍，对于不是很复杂的目标，碰撞概率还是可以接受的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Branch cnt | Colliding tuples | Example targets</span><br><span class="line">------------+------------------+-----------------</span><br><span class="line">      1,000 | 0.75%            | giflib, lzo</span><br><span class="line">      2,000 | 1.5%             | zlib, tar, xz</span><br><span class="line">      5,000 | 3.5%             | libpng, libwebp</span><br><span class="line">     10,000 | 7%               | libxml</span><br><span class="line">     20,000 | 14%              | sqlite</span><br><span class="line">     50,000 | 30%              | -</span><br></pre></td></tr></table></figure>

<p>如果一个目标过于复杂，那么AFL状态面板中的map_density信息就会有相应的提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┬─ map coverage ─┴───────────────────────┤</span><br><span class="line">│    map density : 3.61% &#x2F; 14.13%        │</span><br><span class="line">│ count coverage : 6.35 bits&#x2F;tuple       │</span><br><span class="line">┼─ findings in depth ────────────────────┤</span><br></pre></td></tr></table></figure>

<p>这里的map density，就是这张哈希表的密度。可以看到，上面示例中，该次执行的哈希表密度仅为3.61%，即整个哈希表差不多有95%的地方还是空的，所以碰撞的概率很小。不过，如果目标很复杂，map density很大，那么就需要考虑到碰撞的影响了。</p>
<p>另外，AFL需要将<code>cur_location</code>右移1位后，再保存到<code>prev_location</code>中。官方文档中解释了这样做的原因。假设target中存在<code>A-&gt;A</code>和<code>B-&gt;B</code>这样两个跳转，如果不右移，那么这两个分支对应的异或后的key都是0，从而无法区分；另一个例子是<code>A-&gt;B</code>和<code>B-&gt;A</code>，如果不右移，这两个分支对应的异或后的key也是相同的。</p>
<p>由上述分析可知，之前提到的共享内存，被用于保存一张哈希表，target在这张表中记录每个分支的执行数量。随后，当target执行结束后，fuzzer便开始对这张表进行分析，从而判断代码的执行情况。</p>
<h1 id="分支信息的分析"><a href="#分支信息的分析" class="headerlink" title="分支信息的分析"></a>分支信息的分析</h1><p>首先，fuzzer通过调用 <code>classify_counts</code> 对<code>trace_bits</code>（共享内存）进行预处理</p>
<p>具体地，target 是将每个分支的执行次数用 1 个 byte 来储存，而 fuzzer 则进一步把这个执行次数归入以下的 buckets 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8 count_class_lookup8[<span class="number">256</span>] = &#123;</span><br><span class="line"></span><br><span class="line">  [<span class="number">0</span>]           = <span class="number">0</span>, </span><br><span class="line">  [<span class="number">1</span>]           = <span class="number">1</span>, </span><br><span class="line">  [<span class="number">2</span>]           = <span class="number">2</span>, </span><br><span class="line">  [<span class="number">3</span>]           = <span class="number">4</span>, </span><br><span class="line">  [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">8</span>, </span><br><span class="line">  [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">16</span>,</span><br><span class="line">  [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">32</span>,</span><br><span class="line">  [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">64</span>,</span><br><span class="line">  [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>举个例子，如果某分支执行了 1 次，那么落入第 2 个 bucket，其计数 byte 仍为 1；如果某分支执行了 4 次，那么落入第 5 个 bucket，其计数 byte 将变为 8，等等。（执行了 4-7 次的其计数为 8）</p>
<p>这样处理之后，对分支执行次数就会有一个简单的归类。例如，如果对某个测试用例处理时，分支A执行了32次；对另外一个测试用例，分支A执行了33次，那么AFL就会认为这两次的代码覆盖是相同的。当然，这样的简单分类肯定不能区分所有的情况，不过在某种程度上，处理了一些因为循环次数的微小区别，而误判为不同执行结果的情况。</p>
<p>随后，对于某些mutated input来说，如果这次执行没有出现崩溃等异常输出，fuzzer还会检查其是否新增了执行路径。具体来说，是对<code>trace_bits</code>计算hash并来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u32 cksum &#x3D; hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br></pre></td></tr></table></figure>

<p>通过比较hash值，就可以判断<code>trace_bits</code>是否发生了变化，从而判断此次mutated input是否带来了新路径，为之后的fuzzing提供参考信息。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html">https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/52php/p/5861372.html">https://www.cnblogs.com/52php/p/5861372.html</a></p>
<p><a target="_blank" rel="noopener" href="http://rk700.github.io/2017/12/28/afl-internals/">http://rk700.github.io/2017/12/28/afl-internals/</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/4628#toc-10">https://xz.aliyun.com/t/4628#toc-10</a></p>
<p><a target="_blank" rel="noopener" href="https://eternalsakura13.com/2020/08/23/afl/">https://eternalsakura13.com/2020/08/23/afl/</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU0MzgzNTU0Mw==&amp;mid=2247483746&amp;idx=1&amp;sn=9d0ff5e0bae65f9ca9dbea4cf74449c6&amp;chksm=fb04159acc739c8c36e0785e2ce9c3a202066c6cc39a9ce32fd0fc9dfeb348e860a82e29c9d6&amp;scene=178&amp;cur_album_id=1363100069033066496#rd">https://mp.weixin.qq.com/s?__biz=MzU0MzgzNTU0Mw==&amp;mid=2247483746&amp;idx=1&amp;sn=9d0ff5e0bae65f9ca9dbea4cf74449c6&amp;chksm=fb04159acc739c8c36e0785e2ce9c3a202066c6cc39a9ce32fd0fc9dfeb348e860a82e29c9d6&amp;scene=178&amp;cur_album_id=1363100069033066496#rd</a></p>
<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/842/#1-code-coverage">https://paper.seebug.org/842/#1-code-coverage</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">0xfocu5</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://0xfocu5.github.io/posts/53fcd800/">https://0xfocu5.github.io/posts/53fcd800/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://0xfocu5.github.io" target="_blank">0xfocu5</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/AFL/">AFL</a><a class="post-meta__tags" href="/tags/Fuzz/">Fuzz</a></div><div class="post_share"><div class="social-share" data-image="https://focu5.oss-accelerate.aliyuncs.com/blog/20200927102719.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/20f730a9/"><img class="prev-cover" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20200927102719.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">AFL 变异原理</div></div></a></div><div class="next-post pull-right"><a href="/posts/32c104a1/"><img class="next-cover" data-lazy-src="https://focu5.oss-accelerate.aliyuncs.com/blog/20200927102719.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Build Winafl | HonggFuzz | AFL</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 0xfocu5</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'P9GVfs1MeERE7LeK2DFsJXmn-gzGzoHsz',
      appKey: 'hzbjuPyWPjwk5HpiLPf3csE9',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/focu5.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="100" mobile="true" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/click_heart.js" async="async"></script></div></body></html>